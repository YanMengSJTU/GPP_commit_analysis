diff --git a/build.gradle b/build.gradle
index 358b8f1404..2996f48e50 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,7 +19,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.1'
+        classpath 'com.android.tools.build:gradle:2.2.2'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index b5db4c018d..c38abbd192 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -41,6 +41,8 @@ public void onCreate() {
         buildHttpDataSourceFactory(bandwidthMeter));
   }
 
+  // 如何选择: HttpDataSource呢?
+  // 当前的Demo中使用的是默认的HttpDataSource
   public HttpDataSource.Factory buildHttpDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
     return new DefaultHttpDataSourceFactory(userAgent, bandwidthMeter);
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index 5ad28f9e72..f75f96e858 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -18,6 +18,7 @@
 import android.os.SystemClock;
 import android.util.Log;
 import android.view.Surface;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -46,6 +47,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+
 import java.io.IOException;
 import java.text.NumberFormat;
 import java.util.Locale;
@@ -53,14 +55,16 @@
 /**
  * Logs player events using {@link Log}.
  */
-/* package */ final class EventLogger implements ExoPlayer.EventListener,
-    AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
-    MetadataRenderer.Output {
+/* package */
+final class EventLogger implements ExoPlayer.EventListener,
+        AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
+        ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
+        MetadataRenderer.Output {
 
   private static final String TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
   private static final NumberFormat TIME_FORMAT;
+
   static {
     TIME_FORMAT = NumberFormat.getInstance(Locale.US);
     TIME_FORMAT.setMinimumFractionDigits(2);
@@ -90,7 +94,7 @@ public void onLoadingChanged(boolean isLoading) {
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int state) {
     Log.d(TAG, "state [" + getSessionTimeString() + ", " + playWhenReady + ", "
-        + getStateString(state) + "]");
+            + getStateString(state) + "]");
   }
 
   @Override
@@ -108,15 +112,15 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
     Log.d(TAG, "sourceInfo [periodCount=" + periodCount + ", windowCount=" + windowCount);
     for (int i = 0; i < Math.min(periodCount, MAX_TIMELINE_ITEM_LINES); i++) {
       timeline.getPeriod(i, period);
-      Log.d(TAG, "  " +  "period [" + getTimeString(period.getDurationMs()) + "]");
+      Log.d(TAG, "  " + "period [" + getTimeString(period.getDurationMs()) + "]");
     }
     if (periodCount > MAX_TIMELINE_ITEM_LINES) {
       Log.d(TAG, "  ...");
     }
     for (int i = 0; i < Math.min(windowCount, MAX_TIMELINE_ITEM_LINES); i++) {
       timeline.getWindow(i, window);
-      Log.d(TAG, "  " +  "window [" + getTimeString(window.getDurationMs()) + ", "
-          + window.isSeekable + ", " + window.isDynamic + "]");
+      Log.d(TAG, "  " + "window [" + getTimeString(window.getDurationMs()) + ", "
+              + window.isSeekable + ", " + window.isDynamic + "]");
     }
     if (windowCount > MAX_TIMELINE_ITEM_LINES) {
       Log.d(TAG, "  ...");
@@ -146,15 +150,15 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
         for (int groupIndex = 0; groupIndex < rendererTrackGroups.length; groupIndex++) {
           TrackGroup trackGroup = rendererTrackGroups.get(groupIndex);
           String adaptiveSupport = getAdaptiveSupportString(trackGroup.length,
-              mappedTrackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false));
+                  mappedTrackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false));
           Log.d(TAG, "    Group:" + groupIndex + ", adaptive_supported=" + adaptiveSupport + " [");
           for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
             String status = getTrackStatusString(trackSelection, trackGroup, trackIndex);
             String formatSupport = getFormatSupportString(
-                mappedTrackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
+                    mappedTrackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
             Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-                + getFormatString(trackGroup.getFormat(trackIndex))
-                + ", supported=" + formatSupport);
+                    + getFormatString(trackGroup.getFormat(trackIndex))
+                    + ", supported=" + formatSupport);
           }
           Log.d(TAG, "    ]");
         }
@@ -183,10 +187,10 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
         for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
           String status = getTrackStatusString(false);
           String formatSupport = getFormatSupportString(
-              RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
+                  RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
           Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-              + getFormatString(trackGroup.getFormat(trackIndex))
-              + ", supported=" + formatSupport);
+                  + getFormatString(trackGroup.getFormat(trackIndex))
+                  + ", supported=" + formatSupport);
         }
         Log.d(TAG, "    ]");
       }
@@ -218,14 +222,14 @@ public void onAudioSessionId(int audioSessionId) {
 
   @Override
   public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs,
-      long initializationDurationMs) {
+                                        long initializationDurationMs) {
     Log.d(TAG, "audioDecoderInitialized [" + getSessionTimeString() + ", " + decoderName + "]");
   }
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
     Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
-        + "]");
+            + "]");
   }
 
   @Override
@@ -236,7 +240,7 @@ public void onAudioDisabled(DecoderCounters counters) {
   @Override
   public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
     printInternalError("audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
-        + elapsedSinceLastFeedMs + "]", null);
+            + elapsedSinceLastFeedMs + "]", null);
   }
 
   // VideoRendererEventListener
@@ -248,14 +252,14 @@ public void onVideoEnabled(DecoderCounters counters) {
 
   @Override
   public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs,
-      long initializationDurationMs) {
+                                        long initializationDurationMs) {
     Log.d(TAG, "videoDecoderInitialized [" + getSessionTimeString() + ", " + decoderName + "]");
   }
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
     Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
-        + "]");
+            + "]");
   }
 
   @Override
@@ -270,7 +274,7 @@ public void onDroppedFrames(int count, long elapsed) {
 
   @Override
   public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-      float pixelWidthHeightRatio) {
+                                 float pixelWidthHeightRatio) {
     // Do nothing.
   }
 
@@ -302,30 +306,30 @@ public void onLoadError(IOException error) {
 
   @Override
   public void onLoadStarted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs) {
+                            int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
+                            long mediaEndTimeMs, long elapsedRealtimeMs) {
     // Do nothing.
   }
 
   @Override
   public void onLoadError(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded,
-      IOException error, boolean wasCanceled) {
+                          int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
+                          long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded,
+                          IOException error, boolean wasCanceled) {
     printInternalError("loadError", error);
   }
 
   @Override
   public void onLoadCanceled(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
+                             int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
+                             long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
     // Do nothing.
   }
 
   @Override
   public void onLoadCompleted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
+                              int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
+                              long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
     // Do nothing.
   }
 
@@ -336,7 +340,7 @@ public void onUpstreamDiscarded(int trackType, long mediaStartTimeMs, long media
 
   @Override
   public void onDownstreamFormatChanged(int trackType, Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, long mediaTimeMs) {
+                                        Object trackSelectionData, long mediaTimeMs) {
     // Do nothing.
   }
 
@@ -352,26 +356,26 @@ private void printMetadata(Metadata metadata, String prefix) {
       if (entry instanceof TxxxFrame) {
         TxxxFrame txxxFrame = (TxxxFrame) entry;
         Log.d(TAG, prefix + String.format("%s: description=%s, value=%s", txxxFrame.id,
-            txxxFrame.description, txxxFrame.value));
+                txxxFrame.description, txxxFrame.value));
       } else if (entry instanceof PrivFrame) {
         PrivFrame privFrame = (PrivFrame) entry;
         Log.d(TAG, prefix + String.format("%s: owner=%s", privFrame.id, privFrame.owner));
       } else if (entry instanceof GeobFrame) {
         GeobFrame geobFrame = (GeobFrame) entry;
         Log.d(TAG, prefix + String.format("%s: mimeType=%s, filename=%s, description=%s",
-            geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
+                geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
       } else if (entry instanceof ApicFrame) {
         ApicFrame apicFrame = (ApicFrame) entry;
         Log.d(TAG, prefix + String.format("%s: mimeType=%s, description=%s",
-            apicFrame.id, apicFrame.mimeType, apicFrame.description));
+                apicFrame.id, apicFrame.mimeType, apicFrame.description));
       } else if (entry instanceof TextInformationFrame) {
         TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
         Log.d(TAG, prefix + String.format("%s: description=%s", textInformationFrame.id,
-            textInformationFrame.description));
+                textInformationFrame.description));
       } else if (entry instanceof CommentFrame) {
         CommentFrame commentFrame = (CommentFrame) entry;
         Log.d(TAG, prefix + String.format("%s: language=%s description=%s", commentFrame.id,
-            commentFrame.language, commentFrame.description));
+                commentFrame.language, commentFrame.description));
       } else if (entry instanceof Id3Frame) {
         Id3Frame id3Frame = (Id3Frame) entry;
         Log.d(TAG, prefix + String.format("%s", id3Frame.id));
@@ -387,6 +391,7 @@ private static String getTimeString(long timeMs) {
     return timeMs == C.TIME_UNSET ? "?" : TIME_FORMAT.format((timeMs) / 1000f);
   }
 
+  // 播放器的播放状态
   private static String getStateString(int state) {
     switch (state) {
       case ExoPlayer.STATE_BUFFERING:
@@ -402,6 +407,8 @@ private static String getStateString(int state) {
     }
   }
 
+
+  // 是否支持指定的Format，返回"YES", "NO", ...
   private static String getFormatSupportString(int formatSupport) {
     switch (formatSupport) {
       case RendererCapabilities.FORMAT_HANDLED:
@@ -433,6 +440,7 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
     }
   }
 
+  // 关注下面的指标， 是什么意思呢?
   private static String getFormatString(Format format) {
     if (format == null) {
       return "null";
@@ -461,9 +469,9 @@ private static String getFormatString(Format format) {
   }
 
   private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
-      int trackIndex) {
+                                             int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
-        && selection.indexOf(trackIndex) != C.INDEX_UNSET);
+            && selection.indexOf(trackIndex) != C.INDEX_UNSET);
   }
 
   private static String getTrackStatusString(boolean enabled) {
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 243fcadce0..9f3dfd79cf 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -125,9 +125,12 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     shouldAutoPlay = true;
+    // 创建一个HttpDataSource
     mediaDataSourceFactory = buildDataSourceFactory(true);
     mainHandler = new Handler();
+    // 时间窗
     window = new Timeline.Window();
+
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -140,6 +143,7 @@ public void onCreate(Bundle savedInstanceState) {
     retryButton = (Button) findViewById(R.id.retry_button);
     retryButton.setOnClickListener(this);
 
+    // 对应的UI部分
     simpleExoPlayerView = (SimpleExoPlayerView) findViewById(R.id.player_view);
     simpleExoPlayerView.setControllerVisibilityListener(this);
     simpleExoPlayerView.requestFocus();
@@ -231,10 +235,12 @@ public void onVisibilityChange(int visibility) {
 
   private void initializePlayer() {
     Intent intent = getIntent();
+
     if (player == null) {
       boolean preferExtensionDecoders = intent.getBooleanExtra(PREFER_EXTENSION_DECODERS, false);
       UUID drmSchemeUuid = intent.hasExtra(DRM_SCHEME_UUID_EXTRA)
           ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
+
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
       if (drmSchemeUuid != null) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
@@ -261,26 +267,34 @@ private void initializePlayer() {
         }
       }
 
-      @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode =
+      @SimpleExoPlayer.ExtensionRendererMode
+      int extensionRendererMode =
           ((DemoApplication) getApplication()).useExtensionRenderers()
               ? (preferExtensionDecoders ? SimpleExoPlayer.EXTENSION_RENDERER_MODE_PREFER
                   : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
               : SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF;
+
+
       TrackSelection.Factory videoTrackSelectionFactory =
           new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
       trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
       trackSelectionHelper = new TrackSelectionHelper(trackSelector, videoTrackSelectionFactory);
+
+
       player = ExoPlayerFactory.newSimpleInstance(this, trackSelector, new DefaultLoadControl(),
           drmSessionManager, extensionRendererMode);
       player.addListener(this);
 
+      // Player能打印出什么样的Logger呢?
       eventLogger = new EventLogger(trackSelector);
       player.addListener(eventLogger);
+
       player.setAudioDebugListener(eventLogger);
       player.setVideoDebugListener(eventLogger);
       player.setId3Output(eventLogger);
 
       simpleExoPlayerView.setPlayer(player);
+
       if (isTimelineStatic) {
         if (playerPosition == C.TIME_UNSET) {
           player.seekToDefaultPosition(playerWindow);
@@ -288,13 +302,18 @@ private void initializePlayer() {
           player.seekTo(playerWindow, playerPosition);
         }
       }
+
+      // 自动播放
       player.setPlayWhenReady(shouldAutoPlay);
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
       playerNeedsSource = true;
     }
+
     if (playerNeedsSource) {
       String action = intent.getAction();
+
+      // 如何获取? Uri?
       Uri[] uris;
       String[] extensions;
       if (ACTION_VIEW.equals(action)) {
@@ -314,16 +333,21 @@ private void initializePlayer() {
         showToast(getString(R.string.unexpected_intent_action, action));
         return;
       }
+
+      // 读取外部设备，需要权限
       if (Util.maybeRequestReadExternalStoragePermission(this, uris)) {
         // The player will be reinitialized if the permission is granted.
         return;
       }
+
+      // uris = [https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8]
       MediaSource[] mediaSources = new MediaSource[uris.length];
       for (int i = 0; i < uris.length; i++) {
         mediaSources[i] = buildMediaSource(uris[i], extensions[i]);
       }
       MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
           : new ConcatenatingMediaSource(mediaSources);
+
       player.prepare(mediaSource, !isTimelineStatic, !isTimelineStatic);
       playerNeedsSource = false;
       updateButtonVisibilities();
@@ -331,8 +355,7 @@ private void initializePlayer() {
   }
 
   private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
-    int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension
-        : uri.getLastPathSegment());
+    int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension : uri.getLastPathSegment());
     switch (type) {
       case C.TYPE_SS:
         return new SsMediaSource(uri, buildDataSourceFactory(false),
@@ -341,6 +364,7 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
         return new DashMediaSource(uri, buildDataSourceFactory(false),
             new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
       case C.TYPE_HLS:
+        // 如何使用Hls格式的文件呢?
         return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, eventLogger);
       case C.TYPE_OTHER:
         return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index 936cdf90f8..ee4fb12d80 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -44,7 +44,7 @@
 /**
  * Helper class for displaying track selection dialogs.
  */
-/* package */ final class TrackSelectionHelper implements View.OnClickListener,
+final class TrackSelectionHelper implements View.OnClickListener,
     DialogInterface.OnClickListener {
 
   private static final TrackSelection.Factory FIXED_FACTORY = new FixedTrackSelection.Factory();
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 8577d33781..68f4860c22 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -40,7 +40,8 @@
 import okhttp3.Response;
 
 /**
- * An {@link HttpDataSource} that delegates to Square's {@link Call.Factory}.
+ * An {@link HttpDataSource} that delegates to Square's {@link Call.Factory}
+ * 默认的HttpDataSource为: DefaultHttpDataSource, 问题是如何采用这个OkHttpDataSource的extension呢?
  */
 public class OkHttpDataSource implements HttpDataSource {
 
@@ -103,6 +104,7 @@ public OkHttpDataSource(Call.Factory callFactory, String userAgent,
   public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
       CacheControl cacheControl) {
+
     this.callFactory = Assertions.checkNotNull(callFactory);
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
@@ -150,8 +152,12 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
     this.bytesRead = 0;
     this.bytesSkipped = 0;
+
+    // 如何创建网络请求呢?
     Request request = makeRequest(dataSpec);
+
     try {
+      // 通过callFactory可以共享底部的Sesion, making http2.0可用
       response = callFactory.newCall(request).execute();
       responseByteStream = response.body().byteStream();
     } catch (IOException e) {
@@ -165,8 +171,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     if (!response.isSuccessful()) {
       Map<String, List<String>> headers = request.headers().toMultimap();
       closeConnectionQuietly();
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(
-          responseCode, headers, dataSpec);
+      InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode, headers, dataSpec);
+      // range有问题
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -176,6 +182,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     // Check for a valid content type.
     MediaType mediaType = response.body().contentType();
     String contentType = mediaType != null ? mediaType.toString() : null;
+    // ContentType格式是否OK？
     if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
       closeConnectionQuietly();
       throw new InvalidContentTypeException(contentType, dataSpec);
@@ -184,6 +191,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     // If we requested a range starting from a non-zero position and received a 200 rather than a
     // 206, then the server does not support partial requests. We'll need to manually skip to the
     // requested position.
+    // 如何兼容responseCode?
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
@@ -259,20 +267,27 @@ protected final long bytesRemaining() {
    * Establishes a connection.
    */
   private Request makeRequest(DataSpec dataSpec) {
+    // 1. 如何创建Request呢?
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
     Request.Builder builder = new Request.Builder().url(url);
+
+    // 2. 缓存控制?
     if (cacheControl != null) {
       builder.cacheControl(cacheControl);
     }
+
+    // 3. 添加Http Header
     synchronized (requestProperties) {
       for (Map.Entry<String, String> property : requestProperties.entrySet()) {
         builder.addHeader(property.getKey(), property.getValue());
       }
     }
+
+    // 4. position & range request
     if (!(position == 0 && length == C.LENGTH_UNSET)) {
       String rangeRequest = "bytes=" + position + "-";
       if (length != C.LENGTH_UNSET) {
@@ -280,6 +295,9 @@ private Request makeRequest(DataSpec dataSpec) {
       }
       builder.addHeader("Range", rangeRequest);
     }
+
+    // 5. 设置User-Agent等参数
+    //    gzip的控制
     builder.addHeader("User-Agent", userAgent);
     if (!allowGzip) {
       builder.addHeader("Accept-Encoding", "identity");
@@ -309,6 +327,7 @@ private void skipInternal() throws IOException {
       skipBuffer = new byte[4096];
     }
 
+    // 跳过: bytesToSkip
     while (bytesSkipped != bytesToSkip) {
       int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
       int read = responseByteStream.read(skipBuffer, 0, readLength);
@@ -346,6 +365,10 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
     if (readLength == 0) {
       return 0;
     }
+
+    // 处理不同的Stream
+    // 有些Stream是有结束标志的；
+    // 有些Stream，例如: 直播，是没有结束标志的
     if (bytesToRead != C.LENGTH_UNSET) {
       long bytesRemaining = bytesToRead - bytesRead;
       if (bytesRemaining == 0) {
@@ -355,6 +378,9 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
     }
 
     int read = responseByteStream.read(buffer, offset, readLength);
+
+    // 出错？
+    // 直播可以直接返回-1
     if (read == -1) {
       if (bytesToRead != C.LENGTH_UNSET) {
         // End of stream reached having not read sufficient data.
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 33f204a6f3..86525be0b0 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -23,6 +23,7 @@
 
 /**
  * A {@link Factory} that produces {@link OkHttpDataSource}.
+ * 实现了HttpDataSource#factory
  */
 public final class OkHttpDataSourceFactory implements Factory {
 
@@ -59,6 +60,7 @@ public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
 
   @Override
   public OkHttpDataSource createDataSource() {
+    // 创建OKHttpDataSource
     return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 3e6fac4a5e..88d7b837bf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -232,14 +232,12 @@ private C() {}
    * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
    */
   @SuppressWarnings("InlinedApi")
-  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
-      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT = MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
   /**
    * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
    */
   @SuppressWarnings("InlinedApi")
-  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
-      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
   /**
    * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 6c64d2c0f3..f2e5fe4455 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -104,6 +104,8 @@
  * <li>Injected player components may use additional background threads. For example a MediaSource
  * may use a background thread to load data. These are implementation specific.</li>
  * </ul>
+ * 整个系统的核心就是这个ExoPlayer接口
+ * 存在三个实现: {@link SimpleExoPlayer} {@link DebugSimpleExoPlayer} {@link ExoPlayerImpl}
  */
 public interface ExoPlayer {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 43de6fe751..88ad0c1137 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -44,6 +44,7 @@ private ExoPlayerFactory() {}
    */
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
       LoadControl loadControl) {
+    // 工厂类，默认返回：SimpleExoPlayer
     return newSimpleInstance(context, trackSelector, loadControl, null);
   }
 
@@ -102,6 +103,8 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
       LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
+
+    // 返回默认的实现
     return new SimpleExoPlayer(context, trackSelector, loadControl, drmSessionManager,
         extensionRendererMode, allowedVideoJoiningTimeMs);
   }
@@ -127,6 +130,7 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    */
   public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl) {
+    // 这个实现和 SimpleExoPlayer 关系?
     return new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index a7cbeb524c..545c86b142 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -20,6 +20,7 @@
 import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
+
 import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.SourceInfo;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.TrackInfo;
@@ -30,12 +31,15 @@
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
  * An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}.
+ * <p>
+ * 实际的播放器实现
  */
-/* package */ final class ExoPlayerImpl implements ExoPlayer {
+final class ExoPlayerImpl implements ExoPlayer {
 
   private static final String TAG = "ExoPlayerImpl";
 
@@ -68,20 +72,25 @@
   /**
    * Constructs an instance. Must be called from a thread that has an associated {@link Looper}.
    *
-   * @param renderers The {@link Renderer}s that will be used by the instance.
+   * @param renderers     The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param loadControl   The {@link LoadControl} that will be used by the instance.
    */
   @SuppressLint("HandlerLeak")
   public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
+
     Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION + " [" + Util.DEVICE_DEBUG_INFO + "]");
     Assertions.checkState(renderers.length > 0);
+
     this.renderers = Assertions.checkNotNull(renderers);
     this.trackSelector = Assertions.checkNotNull(trackSelector);
+
     this.playWhenReady = false;
     this.playbackState = STATE_IDLE;
+
     this.listeners = new CopyOnWriteArraySet<>();
     emptyTrackSelections = new TrackSelectionArray(new TrackSelection[renderers.length]);
+
     timeline = Timeline.EMPTY;
     window = new Timeline.Window();
     period = new Timeline.Period();
@@ -95,7 +104,7 @@ public void handleMessage(Message msg) {
     };
     playbackInfo = new ExoPlayerImplInternal.PlaybackInfo(0, 0);
     internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
-        eventHandler, playbackInfo, this);
+            eventHandler, playbackInfo, this);
   }
 
   @Override
@@ -138,6 +147,8 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
         }
       }
     }
+
+    // 内部播放器
     internalPlayer.prepare(mediaSource, resetPosition);
   }
 
@@ -268,7 +279,7 @@ public int getBufferedPercentage() {
     long bufferedPosition = getBufferedPosition();
     long duration = getDuration();
     return (bufferedPosition == C.TIME_UNSET || duration == C.TIME_UNSET) ? 0
-        : (int) (duration == 0 ? 100 : (bufferedPosition * 100) / duration);
+            : (int) (duration == 0 ? 100 : (bufferedPosition * 100) / duration);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 8866bb7c48..00bd6a5b17 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -22,6 +22,7 @@
 import android.os.SystemClock;
 import android.util.Log;
 import android.util.Pair;
+
 import com.google.android.exoplayer2.ExoPlayer.ExoPlayerMessage;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -36,13 +37,14 @@
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 
 /**
  * Implements the internal behavior of {@link ExoPlayerImpl}.
  */
-/* package */ final class ExoPlayerImplInternal implements Handler.Callback,
-    MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
+final class ExoPlayerImplInternal implements Handler.Callback,
+        MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
 
   /**
    * Playback position information which is read on the application's thread by
@@ -182,8 +184,8 @@ public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo,
   private Timeline timeline;
 
   public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
-      LoadControl loadControl, boolean playWhenReady, Handler eventHandler,
-      PlaybackInfo playbackInfo, ExoPlayer player) {
+                               LoadControl loadControl, boolean playWhenReady, Handler eventHandler,
+                               PlaybackInfo playbackInfo, ExoPlayer player) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
@@ -207,14 +209,14 @@ public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
     // Note: The documentation for Process.THREAD_PRIORITY_AUDIO that states "Applications can
     // not normally change to this priority" is incorrect.
     internalPlaybackThread = new PriorityHandlerThread("ExoPlayerImplInternal:Handler",
-        Process.THREAD_PRIORITY_AUDIO);
+            Process.THREAD_PRIORITY_AUDIO);
     internalPlaybackThread.start();
     handler = new Handler(internalPlaybackThread.getLooper(), this);
   }
 
   public void prepare(MediaSource mediaSource, boolean resetPosition) {
     handler.obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, 0, mediaSource)
-        .sendToTarget();
+            .sendToTarget();
   }
 
   public void setPlayWhenReady(boolean playWhenReady) {
@@ -223,7 +225,7 @@ public void setPlayWhenReady(boolean playWhenReady) {
 
   public void seekTo(Timeline timeline, int windowIndex, long positionUs) {
     handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs))
-        .sendToTarget();
+            .sendToTarget();
   }
 
   public void stop() {
@@ -363,7 +365,7 @@ public boolean handleMessage(Message msg) {
     } catch (RuntimeException e) {
       Log.e(TAG, "Internal runtime error.", e);
       eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForUnexpected(e))
-          .sendToTarget();
+              .sendToTarget();
       stopInternal();
       return true;
     }
@@ -391,6 +393,8 @@ private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
     if (resetPosition) {
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
     }
+    // 内部准备
+    // 设置mediaSource
     this.mediaSource = mediaSource;
     mediaSource.prepareSource(player, true, this);
     setState(ExoPlayer.STATE_BUFFERING);
@@ -451,10 +455,10 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
 
     // Update the buffered position.
     long bufferedPositionUs = enabledRenderers.length == 0 ? C.TIME_END_OF_SOURCE
-        : playingPeriodHolder.mediaPeriod.getBufferedPositionUs();
+            : playingPeriodHolder.mediaPeriod.getBufferedPositionUs();
     playbackInfo.bufferedPositionUs = bufferedPositionUs == C.TIME_END_OF_SOURCE
-        ? timeline.getPeriod(playingPeriodHolder.index, period).getDurationUs()
-        : bufferedPositionUs;
+            ? timeline.getPeriod(playingPeriodHolder.index, period).getDurationUs()
+            : bufferedPositionUs;
   }
 
   private void doSomeWork() throws ExoPlaybackException, IOException {
@@ -492,17 +496,17 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
     }
 
     long playingPeriodDurationUs = timeline.getPeriod(playingPeriodHolder.index, period)
-        .getDurationUs();
+            .getDurationUs();
     if (allRenderersEnded
-        && (playingPeriodDurationUs == C.TIME_UNSET
-        || playingPeriodDurationUs <= playbackInfo.positionUs)
-        && playingPeriodHolder.isLast) {
+            && (playingPeriodDurationUs == C.TIME_UNSET
+            || playingPeriodDurationUs <= playbackInfo.positionUs)
+            && playingPeriodHolder.isLast) {
       setState(ExoPlayer.STATE_ENDED);
       stopRenderers();
     } else if (state == ExoPlayer.STATE_BUFFERING) {
       boolean isNewlyReady = enabledRenderers.length > 0
-          ? (allRenderersReadyOrEnded && haveSufficientBuffer(rebuffering))
-          : isTimelineReady(playingPeriodDurationUs);
+              ? (allRenderersReadyOrEnded && haveSufficientBuffer(rebuffering))
+              : isTimelineReady(playingPeriodDurationUs);
       if (isNewlyReady) {
         setState(ExoPlayer.STATE_READY);
         if (playWhenReady) {
@@ -511,7 +515,7 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
       }
     } else if (state == ExoPlayer.STATE_READY) {
       boolean isStillReady = enabledRenderers.length > 0 ? allRenderersReadyOrEnded
-          : isTimelineReady(playingPeriodDurationUs);
+              : isTimelineReady(playingPeriodDurationUs);
       if (!isStillReady) {
         rebuffering = playWhenReady;
         setState(ExoPlayer.STATE_BUFFERING);
@@ -574,7 +578,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
 
     try {
       if (periodIndex == playbackInfo.periodIndex
-          && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
+              && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
         // Seek position equals the current position. Do nothing.
         return;
       }
@@ -586,7 +590,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
   }
 
   private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
-      throws ExoPlaybackException {
+          throws ExoPlaybackException {
     stopRenderers();
     rebuffering = false;
     setState(ExoPlayer.STATE_BUFFERING);
@@ -613,7 +617,7 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
     // Disable all the renderers if the period being played is changing, or if the renderers are
     // reading from a period other than the one being played.
     if (playingPeriodHolder != newPlayingPeriodHolder
-        || playingPeriodHolder != readingPeriodHolder) {
+            || playingPeriodHolder != readingPeriodHolder) {
       for (Renderer renderer : enabledRenderers) {
         renderer.disable();
       }
@@ -646,8 +650,8 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
 
   private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackException {
     rendererPositionUs = playingPeriodHolder == null
-        ? periodPositionUs + RENDERER_TIMESTAMP_OFFSET_US
-        : playingPeriodHolder.toRendererTime(periodPositionUs);
+            ? periodPositionUs + RENDERER_TIMESTAMP_OFFSET_US
+            : playingPeriodHolder.toRendererTime(periodPositionUs);
     standaloneMediaClock.setPositionUs(rendererPositionUs);
     for (Renderer renderer : enabledRenderers) {
       renderer.resetPosition(rendererPositionUs);
@@ -688,7 +692,7 @@ private void resetInternal(boolean releaseMediaSource) {
     }
     enabledRenderers = new Renderer[0];
     releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder
-        : loadingPeriodHolder);
+            : loadingPeriodHolder);
     loadingPeriodHolder = null;
     readingPeriodHolder = null;
     playingPeriodHolder = null;
@@ -759,7 +763,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
 
       boolean[] streamResetFlags = new boolean[renderers.length];
       long periodPositionUs = playingPeriodHolder.updatePeriodTrackSelection(
-          playbackInfo.positionUs, recreateStreams, streamResetFlags);
+              playbackInfo.positionUs, recreateStreams, streamResetFlags);
       if (periodPositionUs != playbackInfo.positionUs) {
         playbackInfo.positionUs = periodPositionUs;
         resetRendererPosition(periodPositionUs);
@@ -808,7 +812,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       loadingPeriodHolder.next = null;
       if (loadingPeriodHolder.prepared) {
         long loadingPeriodPositionUs = Math.max(loadingPeriodHolder.startPositionUs,
-            loadingPeriodHolder.toPeriodTime(rendererPositionUs));
+                loadingPeriodHolder.toPeriodTime(rendererPositionUs));
         loadingPeriodHolder.updatePeriodTrackSelection(loadingPeriodPositionUs, false);
       }
     }
@@ -819,29 +823,29 @@ private void reselectTracksInternal() throws ExoPlaybackException {
 
   private boolean isTimelineReady(long playingPeriodDurationUs) {
     return playingPeriodDurationUs == C.TIME_UNSET
-        || playbackInfo.positionUs < playingPeriodDurationUs
-        || (playingPeriodHolder.next != null && playingPeriodHolder.next.prepared);
+            || playbackInfo.positionUs < playingPeriodDurationUs
+            || (playingPeriodHolder.next != null && playingPeriodHolder.next.prepared);
   }
 
   private boolean haveSufficientBuffer(boolean rebuffering) {
     long loadingPeriodBufferedPositionUs = !loadingPeriodHolder.prepared
-        ? loadingPeriodHolder.startPositionUs
-        : loadingPeriodHolder.mediaPeriod.getBufferedPositionUs();
+            ? loadingPeriodHolder.startPositionUs
+            : loadingPeriodHolder.mediaPeriod.getBufferedPositionUs();
     if (loadingPeriodBufferedPositionUs == C.TIME_END_OF_SOURCE) {
       if (loadingPeriodHolder.isLast) {
         return true;
       }
       loadingPeriodBufferedPositionUs = timeline.getPeriod(loadingPeriodHolder.index, period)
-          .getDurationUs();
+              .getDurationUs();
     }
     return loadControl.shouldStartPlayback(
-        loadingPeriodBufferedPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs),
-        rebuffering);
+            loadingPeriodBufferedPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs),
+            rebuffering);
   }
 
   private void maybeThrowPeriodPrepareError() throws IOException {
     if (loadingPeriodHolder != null && !loadingPeriodHolder.prepared
-        && (readingPeriodHolder == null || readingPeriodHolder.next == loadingPeriodHolder)) {
+            && (readingPeriodHolder == null || readingPeriodHolder.next == loadingPeriodHolder)) {
       for (Renderer renderer : enabledRenderers) {
         if (!renderer.hasReadStreamToEnd()) {
           return;
@@ -852,7 +856,7 @@ private void maybeThrowPeriodPrepareError() throws IOException {
   }
 
   private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifest)
-      throws ExoPlaybackException {
+          throws ExoPlaybackException {
     Timeline oldTimeline = timeline;
     timeline = timelineAndManifest.first;
     Object manifest = timelineAndManifest.second;
@@ -882,7 +886,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
     }
 
     MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder
-        : loadingPeriodHolder;
+            : loadingPeriodHolder;
     if (periodHolder == null) {
       // We don't have any period holders, so we're done.
       notifySourceInfoRefresh(manifest, processedInitialSeekCount);
@@ -901,7 +905,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       }
       // We resolved a subsequent period. Seek to the default position in the corresponding window.
       Pair<Integer, Long> defaultPosition = getPeriodPosition(
-          timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
+              timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
       newPeriodIndex = defaultPosition.first;
       long newPositionUs = defaultPosition.second;
       timeline.getPeriod(newPeriodIndex, period, true);
@@ -923,7 +927,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
     // The current period is in the new timeline. Update the holder and playbackInfo.
     timeline.getPeriod(periodIndex, period);
     boolean isLastPeriod = periodIndex == timeline.getPeriodCount() - 1
-        && !timeline.getWindow(period.windowIndex, window).isDynamic;
+            && !timeline.getWindow(period.windowIndex, window).isDynamic;
     periodHolder.setIndex(periodIndex, isLastPeriod);
     boolean seenReadingPeriod = periodHolder == readingPeriodHolder;
     if (periodIndex != playbackInfo.periodIndex) {
@@ -938,7 +942,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       periodIndex++;
       timeline.getPeriod(periodIndex, period, true);
       isLastPeriod = periodIndex == timeline.getPeriodCount() - 1
-          && !timeline.getWindow(period.windowIndex, window).isDynamic;
+              && !timeline.getWindow(period.windowIndex, window).isDynamic;
       if (periodHolder.uid.equals(period.uid)) {
         // The holder is consistent with the new timeline. Update its index and continue.
         periodHolder.setIndex(periodIndex, isLastPeriod);
@@ -967,7 +971,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
   }
 
   private void handleSourceInfoRefreshEndedPlayback(Object manifest,
-      int processedInitialSeekCount) {
+                                                    int processedInitialSeekCount) {
     // Set the playback position to (0,0) for notifying the eventHandler.
     playbackInfo = new PlaybackInfo(0, 0);
     notifySourceInfoRefresh(manifest, processedInitialSeekCount);
@@ -980,7 +984,7 @@ private void handleSourceInfoRefreshEndedPlayback(Object manifest,
 
   private void notifySourceInfoRefresh(Object manifest, int processedInitialSeekCount) {
     eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED,
-        new SourceInfo(timeline, manifest, playbackInfo, processedInitialSeekCount)).sendToTarget();
+            new SourceInfo(timeline, manifest, playbackInfo, processedInitialSeekCount)).sendToTarget();
   }
 
   /**
@@ -988,17 +992,17 @@ private void notifySourceInfoRefresh(Object manifest, int processedInitialSeekCo
    * in a new timeline. The index of this period in the new timeline is returned.
    *
    * @param oldPeriodIndex The index of the period in the old timeline.
-   * @param oldTimeline The old timeline.
-   * @param newTimeline The new timeline.
+   * @param oldTimeline    The old timeline.
+   * @param newTimeline    The new timeline.
    * @return The index in the new timeline of the first subsequent period, or {@link C#INDEX_UNSET}
-   *     if no such period was found.
+   * if no such period was found.
    */
   private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
-      Timeline newTimeline) {
+                                      Timeline newTimeline) {
     int newPeriodIndex = C.INDEX_UNSET;
     while (newPeriodIndex == C.INDEX_UNSET && oldPeriodIndex < oldTimeline.getPeriodCount() - 1) {
       newPeriodIndex = newTimeline.getIndexOfPeriod(
-          oldTimeline.getPeriod(++oldPeriodIndex, period, true).uid);
+              oldTimeline.getPeriod(++oldPeriodIndex, period, true).uid);
     }
     return newPeriodIndex;
   }
@@ -1010,7 +1014,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * @param seekPosition The position to resolve.
    * @return The resolved position, or null if resolution was not successful.
    * @throws IllegalSeekPositionException If the window index of the seek position is outside the
-   *     bounds of the timeline.
+   *                                      bounds of the timeline.
    */
   private Pair<Integer, Long> resolveSeekPosition(SeekPosition seekPosition) {
     Timeline seekTimeline = seekPosition.timeline;
@@ -1023,11 +1027,11 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     Pair<Integer, Long> periodPosition;
     try {
       periodPosition = getPeriodPosition(seekTimeline, seekPosition.windowIndex,
-          seekPosition.windowPositionUs);
+              seekPosition.windowPositionUs);
     } catch (IndexOutOfBoundsException e) {
       // The window index of the seek position was outside the bounds of the timeline.
       throw new IllegalSeekPositionException(timeline, seekPosition.windowIndex,
-          seekPosition.windowPositionUs);
+              seekPosition.windowPositionUs);
     }
     if (timeline == seekTimeline) {
       // Our internal timeline is the seek timeline, so the mapped position is correct.
@@ -1035,7 +1039,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     }
     // Attempt to find the mapped period in the internal timeline.
     int periodIndex = timeline.getIndexOfPeriod(
-        seekTimeline.getPeriod(periodPosition.first, period, true).uid);
+            seekTimeline.getPeriod(periodPosition.first, period, true).uid);
     if (periodIndex != C.INDEX_UNSET) {
       // We successfully located the period in the internal timeline.
       return Pair.create(periodIndex, periodPosition.second);
@@ -1062,25 +1066,25 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * projection.
    */
   private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
-      long windowPositionUs) {
+                                                long windowPositionUs) {
     return getPeriodPosition(timeline, windowIndex, windowPositionUs, 0);
   }
 
   /**
    * Converts (windowIndex, windowPositionUs) to the corresponding (periodIndex, periodPositionUs).
    *
-   * @param timeline The timeline containing the window.
-   * @param windowIndex The window index.
-   * @param windowPositionUs The window time, or {@link C#TIME_UNSET} to use the window's default
-   *     start position.
+   * @param timeline                    The timeline containing the window.
+   * @param windowIndex                 The window index.
+   * @param windowPositionUs            The window time, or {@link C#TIME_UNSET} to use the window's default
+   *                                    start position.
    * @param defaultPositionProjectionUs If {@code windowPositionUs} is {@link C#TIME_UNSET}, the
-   *     duration into the future by which the window's position should be projected.
+   *                                    duration into the future by which the window's position should be projected.
    * @return The corresponding (periodIndex, periodPositionUs), or null if {@code #windowPositionUs}
-   *     is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
-   *     position could not be projected by {@code defaultPositionProjectionUs}.
+   * is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
+   * position could not be projected by {@code defaultPositionProjectionUs}.
    */
   private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
-      long windowPositionUs, long defaultPositionProjectionUs) {
+                                                long windowPositionUs, long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, timeline.getWindowCount());
     timeline.getWindow(windowIndex, window, false, defaultPositionProjectionUs);
     if (windowPositionUs == C.TIME_UNSET) {
@@ -1093,7 +1097,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
     long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();
     while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
-        && periodIndex < window.lastPeriodIndex) {
+            && periodIndex < window.lastPeriodIndex) {
       periodPositionUs -= periodDurationUs;
       periodDurationUs = timeline.getPeriod(++periodIndex, period).getDurationUs();
     }
@@ -1122,13 +1126,13 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
 
     // Update the playing and reading periods.
     while (playingPeriodHolder != readingPeriodHolder
-        && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
+            && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
       playingPeriodHolder.release();
       setPlayingPeriodHolder(playingPeriodHolder.next);
       playbackInfo = new PlaybackInfo(playingPeriodHolder.index,
-          playingPeriodHolder.startPositionUs);
+              playingPeriodHolder.startPositionUs);
       updatePlaybackPositions();
       eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
     }
@@ -1156,7 +1160,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       TrackSelectionArray newTrackSelections = readingPeriodHolder.trackSelections;
 
       boolean initialDiscontinuity =
-          readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
+              readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
       for (int i = 0; i < renderers.length; i++) {
         Renderer renderer = renderers[i];
         TrackSelection oldSelection = oldTrackSelections.get(i);
@@ -1176,7 +1180,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
               formats[j] = newSelection.getFormat(j);
             }
             renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
-                readingPeriodHolder.getRendererOffset());
+                    readingPeriodHolder.getRendererOffset());
           } else {
             // The renderer will be disabled when transitioning to playing the next period. Mark the
             // SampleStream as final to play out any remaining data.
@@ -1194,13 +1198,13 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     } else {
       int loadingPeriodIndex = loadingPeriodHolder.index;
       if (loadingPeriodHolder.isLast || !loadingPeriodHolder.isFullyBuffered()
-          || timeline.getPeriod(loadingPeriodIndex, period).getDurationUs() == C.TIME_UNSET) {
+              || timeline.getPeriod(loadingPeriodIndex, period).getDurationUs() == C.TIME_UNSET) {
         // Either the existing loading period is the last period, or we are not ready to advance to
         // loading the next period because it hasn't been fully buffered or its duration is unknown.
         return;
       }
       if (playingPeriodHolder != null
-          && loadingPeriodIndex - playingPeriodHolder.index == MAXIMUM_BUFFER_AHEAD_PERIODS) {
+              && loadingPeriodIndex - playingPeriodHolder.index == MAXIMUM_BUFFER_AHEAD_PERIODS) {
         // We are already buffering the maximum number of periods ahead.
         return;
       }
@@ -1219,7 +1223,7 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     } else {
       int newLoadingWindowIndex = timeline.getPeriod(newLoadingPeriodIndex, period).windowIndex;
       if (newLoadingPeriodIndex
-          != timeline.getWindow(newLoadingWindowIndex, window).firstPeriodIndex) {
+              != timeline.getWindow(newLoadingWindowIndex, window).firstPeriodIndex) {
         // We're starting to buffer a new period in the current window. Always start from the
         // beginning of the period.
         newLoadingPeriodStartPositionUs = 0;
@@ -1230,10 +1234,10 @@ private void maybeUpdateLoadingPeriod() throws IOException {
         // interruptions). Hence we project the default start position forward by the duration of
         // the buffer, and start buffering from this point.
         long defaultPositionProjectionUs = loadingPeriodHolder.getRendererOffset()
-            + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs()
-            - rendererPositionUs;
+                + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs()
+                - rendererPositionUs;
         Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline, newLoadingWindowIndex,
-            C.TIME_UNSET, Math.max(0, defaultPositionProjectionUs));
+                C.TIME_UNSET, Math.max(0, defaultPositionProjectionUs));
         if (defaultPosition == null) {
           return;
         }
@@ -1244,15 +1248,15 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     }
 
     long rendererPositionOffsetUs = loadingPeriodHolder == null
-        ? newLoadingPeriodStartPositionUs + RENDERER_TIMESTAMP_OFFSET_US
-        : (loadingPeriodHolder.getRendererOffset()
+            ? newLoadingPeriodStartPositionUs + RENDERER_TIMESTAMP_OFFSET_US
+            : (loadingPeriodHolder.getRendererOffset()
             + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs());
     timeline.getPeriod(newLoadingPeriodIndex, period, true);
     boolean isLastPeriod = newLoadingPeriodIndex == timeline.getPeriodCount() - 1
-        && !timeline.getWindow(period.windowIndex, window).isDynamic;
+            && !timeline.getWindow(period.windowIndex, window).isDynamic;
     MediaPeriodHolder newPeriodHolder = new MediaPeriodHolder(renderers, rendererCapabilities,
-        rendererPositionOffsetUs, trackSelector, loadControl, mediaSource, period.uid,
-        newLoadingPeriodIndex, isLastPeriod, newLoadingPeriodStartPositionUs);
+            rendererPositionOffsetUs, trackSelector, loadControl, mediaSource, period.uid,
+            newLoadingPeriodIndex, isLastPeriod, newLoadingPeriodStartPositionUs);
     if (loadingPeriodHolder != null) {
       loadingPeriodHolder.next = newPeriodHolder;
     }
@@ -1286,7 +1290,7 @@ private void handleContinueLoadingRequested(MediaPeriod period) {
 
   private void maybeContinueLoading() {
     long nextLoadPositionUs = !loadingPeriodHolder.prepared ? 0
-        : loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
+            : loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
     if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
       setIsLoading(false);
     } else {
@@ -1345,7 +1349,7 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
   }
 
   private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRendererCount)
-      throws ExoPlaybackException {
+          throws ExoPlaybackException {
     enabledRenderers = new Renderer[enabledRendererCount];
     enabledRendererCount = 0;
     for (int i = 0; i < renderers.length; i++) {
@@ -1365,12 +1369,12 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
           }
           // Enable the renderer.
           renderer.enable(formats, playingPeriodHolder.sampleStreams[i], rendererPositionUs,
-              joining, playingPeriodHolder.getRendererOffset());
+                  joining, playingPeriodHolder.getRendererOffset());
           MediaClock mediaClock = renderer.getMediaClock();
           if (mediaClock != null) {
             if (rendererMediaClock != null) {
               throw ExoPlaybackException.createForUnexpected(
-                  new IllegalStateException("Multiple renderer media clocks enabled."));
+                      new IllegalStateException("Multiple renderer media clocks enabled."));
             }
             rendererMediaClock = mediaClock;
             rendererMediaClockSource = renderer;
@@ -1415,9 +1419,9 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     private TrackSelectionArray periodTrackSelections;
 
     public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
-        long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
-        MediaSource mediaSource, Object periodUid, int periodIndex, boolean isLastPeriod,
-        long startPositionUs) {
+                             long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
+                             MediaSource mediaSource, Object periodUid, int periodIndex, boolean isLastPeriod,
+                             long startPositionUs) {
       this.renderers = renderers;
       this.rendererCapabilities = rendererCapabilities;
       this.rendererPositionOffsetUs = rendererPositionOffsetUs;
@@ -1431,7 +1435,7 @@ public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCa
       sampleStreams = new SampleStream[renderers.length];
       mayRetainStreamFlags = new boolean[renderers.length];
       mediaPeriod = mediaSource.createPeriod(periodIndex, loadControl.getAllocator(),
-          startPositionUs);
+              startPositionUs);
     }
 
     public long toRendererTime(long periodTimeUs) {
@@ -1453,7 +1457,7 @@ public void setIndex(int index, boolean isLast) {
 
     public boolean isFullyBuffered() {
       return prepared
-          && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
+              && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
     }
 
     public void handlePrepared() throws ExoPlaybackException {
@@ -1465,7 +1469,7 @@ public void handlePrepared() throws ExoPlaybackException {
 
     public boolean selectTracks() throws ExoPlaybackException {
       Pair<TrackSelectionArray, Object> selectorResult = trackSelector.selectTracks(
-          rendererCapabilities, trackGroups);
+              rendererCapabilities, trackGroups);
       TrackSelectionArray newTrackSelections = selectorResult.first;
       if (newTrackSelections.equals(periodTrackSelections)) {
         return false;
@@ -1477,20 +1481,20 @@ public boolean selectTracks() throws ExoPlaybackException {
 
     public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams) {
       return updatePeriodTrackSelection(positionUs, forceRecreateStreams,
-          new boolean[renderers.length]);
+              new boolean[renderers.length]);
     }
 
     public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams,
-        boolean[] streamResetFlags) {
+                                           boolean[] streamResetFlags) {
       for (int i = 0; i < trackSelections.length; i++) {
         mayRetainStreamFlags[i] = !forceRecreateStreams
-            && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),
-            trackSelections.get(i));
+                && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),
+                trackSelections.get(i));
       }
 
       // Disable streams on the period and get new streams for updated/newly-enabled tracks.
       positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
-          sampleStreams, streamResetFlags, positionUs);
+              sampleStreams, streamResetFlags, positionUs);
       periodTrackSelections = trackSelections;
 
       // Update whether we have enabled tracks and sanity check the expected streams are non-null.
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 36753309e2..6871e20fb6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -27,6 +27,7 @@
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 import android.view.TextureView;
+
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.AudioTrack;
@@ -46,6 +47,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Constructor;
@@ -67,21 +69,21 @@
     /**
      * Called each time there's a change in the size of the video being rendered.
      *
-     * @param width The video width in pixels.
-     * @param height The video height in pixels.
+     * @param width                    The video width in pixels.
+     * @param height                   The video height in pixels.
      * @param unappliedRotationDegrees For videos that require a rotation, this is the clockwise
-     *     rotation in degrees that the application should apply for the video for it to be rendered
-     *     in the correct orientation. This value will always be zero on API levels 21 and above,
-     *     since the renderer will apply all necessary rotations internally. On earlier API levels
-     *     this is not possible. Applications that use {@link android.view.TextureView} can apply
-     *     the rotation by calling {@link android.view.TextureView#setTransform}. Applications that
-     *     do not expect to encounter rotated videos can safely ignore this parameter.
-     * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case
-     *     of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
-     *     content.
+     *                                 rotation in degrees that the application should apply for the video for it to be rendered
+     *                                 in the correct orientation. This value will always be zero on API levels 21 and above,
+     *                                 since the renderer will apply all necessary rotations internally. On earlier API levels
+     *                                 this is not possible. Applications that use {@link android.view.TextureView} can apply
+     *                                 the rotation by calling {@link android.view.TextureView#setTransform}. Applications that
+     *                                 do not expect to encounter rotated videos can safely ignore this parameter.
+     * @param pixelWidthHeightRatio    The width to height ratio of each pixel. For the normal case
+     *                                 of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
+     *                                 content.
      */
     void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio);
+                            float pixelWidthHeightRatio);
 
     /**
      * Called when a frame is rendered for the first time since setting the surface, and when a
@@ -96,7 +98,9 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
-  public @interface ExtensionRendererMode {}
+  public @interface ExtensionRendererMode {
+  }
+
   /**
    * Do not allow use of extension renderers.
    */
@@ -149,17 +153,20 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private PlaybackParamsHolder playbackParamsHolder;
 
   protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadControl loadControl,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs) {
+                            DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                            @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs) {
+
+    // 初始化
     mainHandler = new Handler();
     componentListener = new ComponentListener();
 
     // Build the renderers.
     ArrayList<Renderer> renderersList = new ArrayList<>();
     buildRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
-        allowedVideoJoiningTimeMs, renderersList);
+            allowedVideoJoiningTimeMs, renderersList);
     renderers = renderersList.toArray(new Renderer[renderersList.size()]);
 
+    // 获取video/audio renders的数量
     // Obtain counts of video and audio renderers.
     int videoRendererCount = 0;
     int audioRendererCount = 0;
@@ -183,6 +190,7 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
     videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
     // Build the player and associated objects.
+    // 实际的播放器，其他的工作都是为player准备
     player = new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
 
@@ -197,11 +205,12 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
   public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
     this.videoScalingMode = videoScalingMode;
     ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
+
+    // 每一个Render构建一个Message
     int count = 0;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SCALING_MODE,
-            videoScalingMode);
+        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SCALING_MODE, videoScalingMode);
       }
     }
     player.sendMessages(messages);
@@ -210,7 +219,9 @@ public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
   /**
    * Returns the video scaling mode.
    */
-  public @C.VideoScalingMode int getVideoScalingMode() {
+  public
+  @C.VideoScalingMode
+  int getVideoScalingMode() {
     return videoScalingMode;
   }
 
@@ -314,7 +325,9 @@ public void setAudioStreamType(@C.StreamType int audioStreamType) {
   /**
    * Returns the stream type for audio playback.
    */
-  public @C.StreamType int getAudioStreamType() {
+  public
+  @C.StreamType
+  int getAudioStreamType() {
     return audioStreamType;
   }
 
@@ -450,8 +463,8 @@ public void setTextOutput(TextRenderer.Output output) {
   }
 
   /**
-   * @deprecated Use {@link #setMetadataOutput(MetadataRenderer.Output)} instead.
    * @param output The output.
+   * @deprecated Use {@link #setMetadataOutput(MetadataRenderer.Output)} instead.
    */
   @Deprecated
   public void setId3Output(MetadataRenderer.Output output) {
@@ -619,13 +632,19 @@ public Object getCurrentManifest() {
   // Renderer building.
 
   private void buildRenderers(Context context, Handler mainHandler,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs,
-      ArrayList<Renderer> out) {
+                              DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                              @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs,
+                              ArrayList<Renderer> out) {
+
+    // 创建各种Renders
+    // Video
+    // Audio
     buildVideoRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
-        componentListener, allowedVideoJoiningTimeMs, out);
+            componentListener, allowedVideoJoiningTimeMs, out);
     buildAudioRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
-        componentListener, out);
+            componentListener, out);
+
+    // 文本& MetaData, 其他的Render
     buildTextRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
     buildMetadataRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
     buildMiscellaneousRenderers(context, mainHandler, extensionRendererMode, out);
@@ -634,23 +653,25 @@ private void buildRenderers(Context context, Handler mainHandler,
   /**
    * Builds video renderers for use by the player.
    *
-   * @param context The {@link Context} associated with the player.
-   * @param mainHandler A handler associated with the main thread's looper.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
-   * not be used for DRM protected playbacks.
-   * @param extensionRendererMode The extension renderer mode.
-   * @param eventListener An event listener.
+   * @param context                   The {@link Context} associated with the player.
+   * @param mainHandler               A handler associated with the main thread's looper.
+   * @param drmSessionManager         An optional {@link DrmSessionManager}. May be null if the player will
+   *                                  not be used for DRM protected playbacks.
+   * @param extensionRendererMode     The extension renderer mode.
+   * @param eventListener             An event listener.
    * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video renderers
-   *     can attempt to seamlessly join an ongoing playback.
-   * @param out An array to which the built renderers should be appended.
+   *                                  can attempt to seamlessly join an ongoing playback.
+   * @param out                       An array to which the built renderers should be appended.
    */
   protected void buildVideoRenderers(Context context, Handler mainHandler,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      @ExtensionRendererMode int extensionRendererMode, VideoRendererEventListener eventListener,
-      long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
+                                     DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                                     @ExtensionRendererMode int extensionRendererMode,
+                                     VideoRendererEventListener eventListener,
+                                     long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
+
     out.add(new MediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
-        allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, eventListener,
-        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+            allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, eventListener,
+            MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
@@ -660,14 +681,16 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
       extensionRendererIndex--;
     }
 
+    // Extension可能有，也可能没有
     try {
-      Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
       Constructor<?> constructor = clazz.getConstructor(boolean.class, long.class, Handler.class,
-          VideoRendererEventListener.class, int.class);
+              VideoRendererEventListener.class, int.class);
+
       Renderer renderer = (Renderer) constructor.newInstance(true, allowedVideoJoiningTimeMs,
-          mainHandler, componentListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+              mainHandler, componentListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
       out.add(extensionRendererIndex++, renderer);
+
       Log.i(TAG, "Loaded LibvpxVideoRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
@@ -679,20 +702,20 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
   /**
    * Builds audio renderers for use by the player.
    *
-   * @param context The {@link Context} associated with the player.
-   * @param mainHandler A handler associated with the main thread's looper.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
-   * not be used for DRM protected playbacks.
+   * @param context               The {@link Context} associated with the player.
+   * @param mainHandler           A handler associated with the main thread's looper.
+   * @param drmSessionManager     An optional {@link DrmSessionManager}. May be null if the player will
+   *                              not be used for DRM protected playbacks.
    * @param extensionRendererMode The extension renderer mode.
-   * @param eventListener An event listener.
-   * @param out An array to which the built renderers should be appended.
+   * @param eventListener         An event listener.
+   * @param out                   An array to which the built renderers should be appended.
    */
   protected void buildAudioRenderers(Context context, Handler mainHandler,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      @ExtensionRendererMode int extensionRendererMode, AudioRendererEventListener eventListener,
-      ArrayList<Renderer> out) {
+                                     DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                                     @ExtensionRendererMode int extensionRendererMode, AudioRendererEventListener eventListener,
+                                     ArrayList<Renderer> out) {
     out.add(new MediaCodecAudioRenderer(MediaCodecSelector.DEFAULT, drmSessionManager, true,
-        mainHandler, eventListener, AudioCapabilities.getCapabilities(context)));
+            mainHandler, eventListener, AudioCapabilities.getCapabilities(context)));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
@@ -702,11 +725,12 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
       extensionRendererIndex--;
     }
 
+    // 可以选用不同的AudioRender
     try {
       Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
+              Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
+              AudioRendererEventListener.class);
       Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibopusAudioRenderer.");
@@ -718,9 +742,9 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
 
     try {
       Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
+              Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
+              AudioRendererEventListener.class);
       Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibflacAudioRenderer.");
@@ -732,9 +756,9 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
 
     try {
       Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
+              Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
+              AudioRendererEventListener.class);
       Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded FfmpegAudioRenderer.");
@@ -748,43 +772,43 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
   /**
    * Builds text renderers for use by the player.
    *
-   * @param context The {@link Context} associated with the player.
-   * @param mainHandler A handler associated with the main thread's looper.
+   * @param context               The {@link Context} associated with the player.
+   * @param mainHandler           A handler associated with the main thread's looper.
    * @param extensionRendererMode The extension renderer mode.
-   * @param output An output for the renderers.
-   * @param out An array to which the built renderers should be appended.
+   * @param output                An output for the renderers.
+   * @param out                   An array to which the built renderers should be appended.
    */
   protected void buildTextRenderers(Context context, Handler mainHandler,
-      @ExtensionRendererMode int extensionRendererMode, TextRenderer.Output output,
-      ArrayList<Renderer> out) {
+                                    @ExtensionRendererMode int extensionRendererMode, TextRenderer.Output output,
+                                    ArrayList<Renderer> out) {
     out.add(new TextRenderer(output, mainHandler.getLooper()));
   }
 
   /**
    * Builds metadata renderers for use by the player.
    *
-   * @param context The {@link Context} associated with the player.
-   * @param mainHandler A handler associated with the main thread's looper.
+   * @param context               The {@link Context} associated with the player.
+   * @param mainHandler           A handler associated with the main thread's looper.
    * @param extensionRendererMode The extension renderer mode.
-   * @param output An output for the renderers.
-   * @param out An array to which the built renderers should be appended.
+   * @param output                An output for the renderers.
+   * @param out                   An array to which the built renderers should be appended.
    */
   protected void buildMetadataRenderers(Context context, Handler mainHandler,
-      @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
-      ArrayList<Renderer> out) {
+                                        @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
+                                        ArrayList<Renderer> out) {
     out.add(new MetadataRenderer(output, mainHandler.getLooper(), new Id3Decoder()));
   }
 
   /**
    * Builds any miscellaneous renderers used by the player.
    *
-   * @param context The {@link Context} associated with the player.
-   * @param mainHandler A handler associated with the main thread's looper.
+   * @param context               The {@link Context} associated with the player.
+   * @param mainHandler           A handler associated with the main thread's looper.
    * @param extensionRendererMode The extension renderer mode.
-   * @param out An array to which the built renderers should be appended.
+   * @param out                   An array to which the built renderers should be appended.
    */
   protected void buildMiscellaneousRenderers(Context context, Handler mainHandler,
-      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+                                             @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
     // Do nothing.
   }
 
@@ -830,8 +854,8 @@ private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
   }
 
   private final class ComponentListener implements VideoRendererEventListener,
-      AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output,
-      SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
+          AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output,
+          SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
 
     // VideoRendererEventListener implementation
 
@@ -845,10 +869,10 @@ public void onVideoEnabled(DecoderCounters counters) {
 
     @Override
     public void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+                                          long initializationDurationMs) {
       if (videoDebugListener != null) {
         videoDebugListener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+                initializationDurationMs);
       }
     }
 
@@ -869,14 +893,14 @@ public void onDroppedFrames(int count, long elapsed) {
 
     @Override
     public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio) {
+                                   float pixelWidthHeightRatio) {
       if (videoListener != null) {
         videoListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-            pixelWidthHeightRatio);
+                pixelWidthHeightRatio);
       }
       if (videoDebugListener != null) {
         videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-            pixelWidthHeightRatio);
+                pixelWidthHeightRatio);
       }
     }
 
@@ -919,10 +943,10 @@ public void onAudioSessionId(int sessionId) {
 
     @Override
     public void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+                                          long initializationDurationMs) {
       if (audioDebugListener != null) {
         audioDebugListener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+                initializationDurationMs);
       }
     }
 
@@ -936,7 +960,7 @@ public void onAudioInputFormatChanged(Format format) {
 
     @Override
     public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
-        long elapsedSinceLastFeedMs) {
+                                     long elapsedSinceLastFeedMs) {
       if (audioDebugListener != null) {
         audioDebugListener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index adb3d5999b..264218e553 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -75,8 +75,10 @@
    */
   public static Format parseAc3AnnexFFormat(ParsableByteArray data, String trackId,
       String language, DrmInitData drmInitData) {
+    // Frame Sample Code
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
     int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
+
     int nextByte = data.readUnsignedByte();
     int channelCount = CHANNEL_COUNT_BY_ACMOD[(nextByte & 0x38) >> 3];
     if ((nextByte & 0x04) != 0) { // lfeon
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 31aa88d11a..1652b1dc49 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -56,6 +56,7 @@ public DefaultTsPayloadReaderFactory(@Flags int flags) {
     return new SparseArray<>();
   }
 
+  // 如何读取Ts的Payloader呢?
   @Override
   public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
     switch (streamType) {
@@ -73,9 +74,12 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
         return new PesReader(new DtsReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader());
+
+      // 默认使用H264
       case TsExtractor.TS_STREAM_TYPE_H264:
         return isSet(FLAG_IGNORE_H264_STREAM) ? null : new PesReader(
             new H264Reader(isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS)));
+
       case TsExtractor.TS_STREAM_TYPE_H265:
         return new PesReader(new H265Reader());
       case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index d27c4f06e9..87eeced245 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -114,6 +114,7 @@ private static Id3Header decodeHeader(ParsableByteArray data) {
     int flags = data.readUnsignedByte();
     int framesSize = data.readSynchSafeInt();
 
+    // Id3的版本处理
     if (majorVersion == 2) {
       boolean isCompressed = (flags & 0x40) != 0;
       if (isCompressed) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
index 393ac1988a..03b74bba0a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
@@ -29,6 +29,7 @@
  * at any given time, however this {@link SampleStream} may adapt between multiple tracks within the
  * group.
  */
+// 内部管理一系列的: Format
 public final class TrackGroup {
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index b953fcf79c..44b6f9b6cf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.TimestampAdjuster;
@@ -35,6 +36,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.Arrays;
@@ -43,7 +45,8 @@
 /**
  * Source of Hls (possibly adaptive) chunks.
  */
-/* package */ class HlsChunkSource {
+/* package */
+class HlsChunkSource {
 
   /**
    * Chunk holder that allows the scheduling of retries.
@@ -82,7 +85,11 @@ public void clear() {
 
   private final DataSource dataSource;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
+
+  // 不同的分辨率情况下的variants
   private final HlsUrl[] variants;
+
+  // 当前的播放列表
   private final HlsPlaylistTracker playlistTracker;
   private final TrackGroup trackGroup;
 
@@ -101,20 +108,21 @@ public void clear() {
   private TrackSelection trackSelection;
 
   /**
-   * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
-   * @param variants The available variants.
-   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param playlistTracker           The {@link HlsPlaylistTracker} from which to obtain media playlists.
+   * @param variants                  The available variants.
+   * @param dataSource                A {@link DataSource} suitable for loading the media data.
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
-   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
-   *     same provider.
+   *                                  multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+   *                                  same provider.
    */
   public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
-      DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
+                        DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
     this.playlistTracker = playlistTracker;
     this.variants = variants;
     this.dataSource = dataSource;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
 
+    // variants --> variantFormats --> TrackGroup
     Format[] variantFormats = new Format[variants.length];
     int[] initialTrackSelection = new int[variants.length];
     for (int i = 0; i < variants.length; i++) {
@@ -122,6 +130,7 @@ public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
       initialTrackSelection[i] = i;
     }
     trackGroup = new TrackGroup(variantFormats);
+
     trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
   }
 
@@ -164,7 +173,7 @@ public void reset() {
    * Sets whether this chunk source is responsible for initializing timestamp adjusters.
    *
    * @param isTimestampMaster True if this chunk source is responsible for initializing timestamp
-   *     adjusters.
+   *                          adjusters.
    */
   public void setIsTimestampMaster(boolean isTimestampMaster) {
     this.isTimestampMaster = isTimestampMaster;
@@ -178,22 +187,23 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    * the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
    * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
    *
-   * @param previous The most recently loaded media chunk.
+   * @param previous           The most recently loaded media chunk.
    * @param playbackPositionUs The current playback position. If {@code previous} is null then this
-   *     parameter is the position from which playback is expected to start (or restart) and hence
-   *     should be interpreted as a seek position.
-   * @param out A holder to populate.
+   *                           parameter is the position from which playback is expected to start (or restart) and hence
+   *                           should be interpreted as a seek position.
+   * @param out                A holder to populate.
    */
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
-    int oldVariantIndex = previous == null ? C.INDEX_UNSET
-        : trackGroup.indexOf(previous.trackFormat);
+
+    int oldVariantIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
     // Use start time of the previous chunk rather than its end time because switching format will
     // require downloading overlapping segments.
-    long bufferedDurationUs = previous == null ? 0
-        : Math.max(0, previous.startTimeUs - playbackPositionUs);
+    long bufferedDurationUs = previous == null ? 0 : Math.max(0, previous.startTimeUs - playbackPositionUs);
 
     // Select the variant.
     trackSelection.updateSelectedTrack(bufferedDurationUs);
+
+    // 选择variant
     int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
     boolean switchingVariant = oldVariantIndex != newVariantIndex;
@@ -207,14 +217,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Select the chunk.
     int chunkMediaSequence;
     if (previous == null || switchingVariant) {
+      // 第一次下载，或者切换: Variants
       long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;
+
       if (!mediaPlaylist.hasEndTag && targetPositionUs > mediaPlaylist.getEndTimeUs()) {
         // If the playlist is too old to contain the chunk, we need to refresh it.
         chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
       } else {
         chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
-            targetPositionUs - mediaPlaylist.startTimeUs, true,
-            !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
+                targetPositionUs - mediaPlaylist.startTimeUs, true,
+                !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
         if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
@@ -245,12 +257,13 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
 
     // Check if encryption is specified.
+    // 暂时认为都是非加密的
     if (segment.isEncrypted) {
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
         out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, newVariantIndex,
-            trackSelection.getSelectionReason(), trackSelection.getSelectionData());
+                trackSelection.getSelectionReason(), trackSelection.getSelectionData());
         return;
       }
       if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
@@ -265,23 +278,25 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     if (initSegment != null) {
       Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
       initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
-          initSegment.byterangeLength, null);
+              initSegment.byterangeLength, null);
     }
 
     // Compute start time of the next chunk.
     long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
     TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-        segment.discontinuitySequenceNumber, startTimeUs);
+            segment.discontinuitySequenceNumber, startTimeUs);
 
     // Configure the data source and spec for the chunk.
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
-        null);
+            null);
+
+    // 选择一个MediaChunk
     out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
-        trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
-        segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
-        encryptionKey, encryptionIv);
+            trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
+            startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
+            segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
+            encryptionKey, encryptionIv);
   }
 
   /**
@@ -291,11 +306,14 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
    * @param chunk The chunk whose load has been completed.
    */
   public void onChunkLoadCompleted(Chunk chunk) {
+
+    // 加载完毕，是否需要解密呢?
+    // 暂不考虑这个逻辑
     if (chunk instanceof EncryptionKeyChunk) {
       EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
       scratchSpace = encryptionKeyChunk.getDataHolder();
       setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
-          encryptionKeyChunk.getResult());
+              encryptionKeyChunk.getResult());
     }
   }
 
@@ -303,20 +321,20 @@ public void onChunkLoadCompleted(Chunk chunk) {
    * Called when the {@link HlsSampleStreamWrapper} encounters an error loading a chunk obtained
    * from this source.
    *
-   * @param chunk The chunk whose load encountered the error.
+   * @param chunk      The chunk whose load encountered the error.
    * @param cancelable Whether the load can be canceled.
-   * @param error The error.
+   * @param error      The error.
    * @return Whether the load should be canceled.
    */
   public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
     return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-        trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
+            trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
   }
 
   /**
    * Called when a playlist is blacklisted.
    *
-   * @param url The url that references the blacklisted playlist.
+   * @param url         The url that references the blacklisted playlist.
    * @param blacklistMs The amount of milliseconds for which the playlist was blacklisted.
    */
   public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
@@ -332,10 +350,10 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
   // Private methods.
 
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
-      int trackSelectionReason, Object trackSelectionData) {
+                                                   int trackSelectionReason, Object trackSelectionData) {
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
     return new EncryptionKeyChunk(dataSource, dataSpec, variants[variantIndex].format,
-        trackSelectionReason, trackSelectionData, scratchSpace, iv);
+            trackSelectionReason, trackSelectionData, scratchSpace, iv);
   }
 
   private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
@@ -350,7 +368,7 @@ private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     byte[] ivDataWithPadding = new byte[16];
     int offset = ivData.length > 16 ? ivData.length - 16 : 0;
     System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
-        + offset, ivData.length - offset);
+            + offset, ivData.length - offset);
 
     encryptionKeyUri = keyUri;
     encryptionKey = secretKey;
@@ -374,6 +392,7 @@ private void clearEncryptionData() {
 
     private int selectedIndex;
 
+    // 如何选择初始的Track呢?
     public InitializationTrackSelection(TrackGroup group, int[] tracks) {
       super(group, tracks);
       selectedIndex = indexOf(group.getFormat(0));
@@ -382,9 +401,13 @@ public InitializationTrackSelection(TrackGroup group, int[] tracks) {
     @Override
     public void updateSelectedTrack(long bufferedDurationUs) {
       long nowMs = SystemClock.elapsedRealtime();
+
+      // 如果当前的Track OK，则直接返回
       if (!isBlacklisted(selectedIndex, nowMs)) {
         return;
       }
+
+      // 选择一个新的Index
       // Try from lowest bitrate to highest.
       for (int i = length - 1; i >= 0; i--) {
         if (!isBlacklisted(i, nowMs)) {
@@ -420,9 +443,9 @@ public Object getSelectionData() {
     private byte[] result;
 
     public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-        int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
+                              int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
       super(dataSource, dataSpec, C.DATA_TYPE_DRM, trackFormat, trackSelectionReason,
-          trackSelectionData, scratchSpace);
+              trackSelectionData, scratchSpace);
       this.iv = iv;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 6082372b05..832357c689 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -17,6 +17,7 @@
 
 import android.os.Handler;
 import android.text.TextUtils;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
@@ -32,6 +33,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -39,9 +41,11 @@
 
 /**
  * A {@link MediaPeriod} that loads an HLS stream.
+ * <p>
+ * 如何加载HLS流呢?
  */
 public final class HlsMediaPeriod implements MediaPeriod, HlsSampleStreamWrapper.Callback,
-    HlsPlaylistTracker.PlaylistEventListener {
+        HlsPlaylistTracker.PlaylistEventListener {
 
   private final HlsPlaylistTracker playlistTracker;
   private final DataSource.Factory dataSourceFactory;
@@ -62,8 +66,9 @@
   private CompositeSequenceableLoader sequenceableLoader;
 
   public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, DataSource.Factory dataSourceFactory,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
-      long positionUs) {
+                        int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
+                        long positionUs) {
+
     this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -108,13 +113,13 @@ public TrackGroupArray getTrackGroups() {
 
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+                           SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
     // Map each selection and stream onto a child period index.
     int[] streamChildIndices = new int[selections.length];
     int[] selectionChildIndices = new int[selections.length];
     for (int i = 0; i < selections.length; i++) {
       streamChildIndices[i] = streams[i] == null ? C.INDEX_UNSET
-          : streamWrapperIndices.get(streams[i]);
+              : streamWrapperIndices.get(streams[i]);
       selectionChildIndices[i] = C.INDEX_UNSET;
       if (selections[i] != null) {
         TrackGroup trackGroup = selections[i].getTrackGroup();
@@ -133,14 +138,14 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     SampleStream[] childStreams = new SampleStream[selections.length];
     TrackSelection[] childSelections = new TrackSelection[selections.length];
     ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList = new ArrayList<>(
-        sampleStreamWrappers.length);
+            sampleStreamWrappers.length);
     for (int i = 0; i < sampleStreamWrappers.length; i++) {
       for (int j = 0; j < selections.length; j++) {
         childStreams[j] = streamChildIndices[j] == i ? streams[j] : null;
         childSelections[j] = selectionChildIndices[j] == i ? selections[j] : null;
       }
       selectedNewTracks |= sampleStreamWrappers[i].selectTracks(childSelections,
-          mayRetainStreamFlags, childStreams, streamResetFlags, !seenFirstTrackSelection);
+              mayRetainStreamFlags, childStreams, streamResetFlags, !seenFirstTrackSelection);
       boolean wrapperEnabled = false;
       for (int j = 0; j < selections.length; j++) {
         if (selectionChildIndices[j] == i) {
@@ -309,7 +314,7 @@ private void buildAndPrepareSampleStreamWrappers() {
     List<HlsUrl> audioRenditions = masterPlaylist.audios;
     List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
     sampleStreamWrappers = new HlsSampleStreamWrapper[1 /* variants */ + audioRenditions.size()
-        + subtitleRenditions.size()];
+            + subtitleRenditions.size()];
     int currentWrapperIndex = 0;
     pendingPrepareCount = sampleStreamWrappers.length;
 
@@ -317,7 +322,7 @@ private void buildAndPrepareSampleStreamWrappers() {
     HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
     selectedVariants.toArray(variants);
     HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
-        variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
+            variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
     sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     sampleStreamWrapper.setIsTimestampMaster(true);
     sampleStreamWrapper.continuePreparing();
@@ -327,7 +332,7 @@ private void buildAndPrepareSampleStreamWrappers() {
     // Build audio stream wrappers.
     for (int i = 0; i < audioRenditions.size(); i++) {
       sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
-          new HlsUrl[] {audioRenditions.get(i)}, null, null);
+              new HlsUrl[]{audioRenditions.get(i)}, null, null);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
       sampleStreamWrapper.continuePreparing();
     }
@@ -335,21 +340,21 @@ private void buildAndPrepareSampleStreamWrappers() {
     // Build subtitle stream wrappers.
     for (int i = 0; i < subtitleRenditions.size(); i++) {
       HlsUrl url = subtitleRenditions.get(i);
-      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null,
-          null);
+      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[]{url}, null,
+              null);
       sampleStreamWrapper.prepareSingleTrack(url.format);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     }
   }
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
-      Format muxedAudioFormat, Format muxedCaptionFormat) {
+                                                          Format muxedAudioFormat, Format muxedCaptionFormat) {
     DataSource dataSource = dataSourceFactory.createDataSource();
     HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants, dataSource,
-        timestampAdjusterProvider);
+            timestampAdjusterProvider);
     return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator,
-        preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
-        eventDispatcher);
+            preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
+            eventDispatcher);
   }
 
   private void continuePreparingOrLoading() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 869efa6cdc..fcd16ddd97 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -69,6 +69,8 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     Assertions.checkState(playlistTracker == null);
+    // 例如:
+    //       manifestUri = https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8
     playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
         minLoadableRetryCount, this);
     sourceListener = listener;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index a9bbddb69c..bf17697fd8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -18,6 +18,7 @@
 import android.os.Handler;
 import android.text.TextUtils;
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -39,6 +40,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
+
 import java.io.IOException;
 import java.util.LinkedList;
 
@@ -46,8 +48,8 @@
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
  * {@link SampleStream}s from which the loaded media can be consumed.
  */
-/* package */ final class HlsSampleStreamWrapper implements Loader.Callback<Chunk>,
-    SequenceableLoader, ExtractorOutput, UpstreamFormatChangedListener {
+final class HlsSampleStreamWrapper implements Loader.Callback<Chunk>,
+        SequenceableLoader, ExtractorOutput, UpstreamFormatChangedListener {
 
   /**
    * A callback to be notified of events.
@@ -107,22 +109,22 @@
   private boolean loadingFinished;
 
   /**
-   * @param trackType The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
-   * @param callback A callback for the wrapper.
-   * @param chunkSource A {@link HlsChunkSource} from which chunks to load are obtained.
-   * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
-   * @param positionUs The position from which to start loading media.
-   * @param muxedAudioFormat If HLS master playlist indicates that the stream contains muxed audio,
-   *     this is the audio {@link Format} as defined by the playlist.
-   * @param muxedCaptionFormat If HLS master playlist indicates that the stream contains muxed
-   *     captions, this is the audio {@link Format} as defined by the playlist.
+   * @param trackType             The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
+   * @param callback              A callback for the wrapper.
+   * @param chunkSource           A {@link HlsChunkSource} from which chunks to load are obtained.
+   * @param allocator             An {@link Allocator} from which to obtain media buffer allocations.
+   * @param positionUs            The position from which to start loading media.
+   * @param muxedAudioFormat      If HLS master playlist indicates that the stream contains muxed audio,
+   *                              this is the audio {@link Format} as defined by the playlist.
+   * @param muxedCaptionFormat    If HLS master playlist indicates that the stream contains muxed
+   *                              captions, this is the audio {@link Format} as defined by the playlist.
    * @param minLoadableRetryCount The minimum number of times that the source should retry a load
-   *     before propagating an error.
-   * @param eventDispatcher A dispatcher to notify of events.
+   *                              before propagating an error.
+   * @param eventDispatcher       A dispatcher to notify of events.
    */
   public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource chunkSource,
-      Allocator allocator, long positionUs, Format muxedAudioFormat, Format muxedCaptionFormat,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher) {
+                                Allocator allocator, long positionUs, Format muxedAudioFormat, Format muxedCaptionFormat,
+                                int minLoadableRetryCount, EventDispatcher eventDispatcher) {
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
@@ -171,7 +173,7 @@ public TrackGroupArray getTrackGroups() {
   }
 
   public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, boolean isFirstTrackSelection) {
+                              SampleStream[] streams, boolean[] streamResetFlags, boolean isFirstTrackSelection) {
     Assertions.checkState(prepared);
     // Disable old tracks.
     for (int i = 0; i < selections.length; i++) {
@@ -243,14 +245,14 @@ public long getBufferedPositionUs() {
       long bufferedPositionUs = lastSeekPositionUs;
       HlsMediaChunk lastMediaChunk = mediaChunks.getLast();
       HlsMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
-          : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
+              : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
       if (lastCompletedMediaChunk != null) {
         bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
       }
       int sampleQueueCount = sampleQueues.size();
       for (int i = 0; i < sampleQueueCount; i++) {
         bufferedPositionUs = Math.max(bufferedPositionUs,
-            sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
+                sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
       }
       return bufferedPositionUs;
     }
@@ -270,7 +272,7 @@ public long getLargestQueuedTimestampUs() {
     long largestQueuedTimestampUs = Long.MIN_VALUE;
     for (int i = 0; i < sampleQueues.size(); i++) {
       largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
-          sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
+              sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
     }
     return largestQueuedTimestampUs;
   }
@@ -306,13 +308,13 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
     Format trackFormat = currentChunk.trackFormat;
     if (!trackFormat.equals(downstreamTrackFormat)) {
       eventDispatcher.downstreamFormatChanged(trackType, trackFormat,
-          currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
-          currentChunk.startTimeUs);
+              currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
+              currentChunk.startTimeUs);
     }
     downstreamTrackFormat = trackFormat;
 
     return sampleQueues.valueAt(group).readData(formatHolder, buffer, loadingFinished,
-        lastSeekPositionUs);
+            lastSeekPositionUs);
   }
 
   /* package */ void skipToKeyframeBefore(int group, long timeUs) {
@@ -338,8 +340,8 @@ public boolean continueLoading(long positionUs) {
     }
 
     chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
-        pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
-        nextChunkHolder);
+            pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
+            nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
@@ -365,8 +367,8 @@ public boolean continueLoading(long positionUs) {
     }
     long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
     eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs);
+            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+            loadable.endTimeUs, elapsedRealtimeMs);
     return true;
   }
 
@@ -385,8 +387,8 @@ public long getNextLoadPositionUs() {
   public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
     eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
     if (!prepared) {
       continueLoading(lastSeekPositionUs);
     } else {
@@ -396,10 +398,10 @@ public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDur
 
   @Override
   public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
-      boolean released) {
+                             boolean released) {
     eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
     if (!released) {
       int sampleQueueCount = sampleQueues.size();
       for (int i = 0; i < sampleQueueCount; i++) {
@@ -411,7 +413,7 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
 
   @Override
   public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
-      IOException error) {
+                         IOException error) {
     long bytesLoaded = loadable.bytesLoaded();
     boolean isMediaChunk = isMediaChunk(loadable);
     boolean cancelable = !isMediaChunk || bytesLoaded == 0;
@@ -427,9 +429,9 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       canceled = true;
     }
     eventDispatcher.loadError(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded(), error,
-        canceled);
+            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded(), error,
+            canceled);
     if (canceled) {
       if (!prepared) {
         continueLoading(lastSeekPositionUs);
@@ -447,9 +449,9 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
   /**
    * Initializes the wrapper for loading a chunk.
    *
-   * @param chunkUid The chunk's uid.
+   * @param chunkUid       The chunk's uid.
    * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into any
-   *     samples already queued to the wrapper.
+   *                       samples already queued to the wrapper.
    */
   public void init(int chunkUid, boolean shouldSpliceIn) {
     upstreamChunkUid = chunkUid;
@@ -563,7 +565,7 @@ private void buildTracks() {
         primaryExtractorTrackType = trackType;
         primaryExtractorTrackIndex = i;
       } else if (trackType == primaryExtractorTrackType
-          && primaryExtractorTrackIndex != C.INDEX_UNSET) {
+              && primaryExtractorTrackIndex != C.INDEX_UNSET) {
         // We have multiple tracks of the primary type. We only want an index if there only exists a
         // single track of the primary type, so unset the index again.
         primaryExtractorTrackIndex = C.INDEX_UNSET;
@@ -606,7 +608,7 @@ private void buildTracks() {
   /**
    * Enables or disables a specified track group.
    *
-   * @param group The index of the track group.
+   * @param group        The index of the track group.
    * @param enabledState True if the group is being enabled, or false if it's being disabled.
    */
   private void setTrackGroupEnabledState(int group, boolean enabledState) {
@@ -620,7 +622,7 @@ private void setTrackGroupEnabledState(int group, boolean enabledState) {
    * level information obtained from the samples.
    *
    * @param containerFormat The container format for which the track format should be derived.
-   * @param sampleFormat A sample format from which to obtain sample level information.
+   * @param sampleFormat    A sample format from which to obtain sample level information.
    * @return The derived track format.
    */
   private static Format deriveFormat(Format containerFormat, Format sampleFormat) {
@@ -635,8 +637,8 @@ private static Format deriveFormat(Format containerFormat, Format sampleFormat)
       codecs = getVideoCodecs(containerFormat.codecs);
     }
     return sampleFormat.copyWithContainerInfo(containerFormat.id, codecs, containerFormat.bitrate,
-        containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
-        containerFormat.language);
+            containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
+            containerFormat.language);
   }
 
   private boolean isMediaChunk(Chunk chunk) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index 4aaec59f7d..1cb7906fd5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -39,15 +39,16 @@
     public final Format[] textFormats;
 
     public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
-      Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null,
-          Format.NO_VALUE);
+      Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null, Format.NO_VALUE);
       return new HlsUrl(null, baseUri, format, null, null, null);
     }
 
     public HlsUrl(String name, String url, Format format, Format videoFormat, Format audioFormat,
         Format[] textFormats) {
+
       this.name = name;
       this.url = url;
+
       this.format = format;
       this.videoFormat = videoFormat;
       this.audioFormat = audioFormat;
@@ -65,15 +66,22 @@ public HlsUrl(String name, String url, Format format, Format videoFormat, Format
 
   public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
       List<HlsUrl> subtitles, Format muxedAudioFormat, Format muxedCaptionFormat) {
+
     super(baseUri, HlsPlaylist.TYPE_MASTER);
+
+    // 例如: 不同分辨率，不同网络清下的的HlsMediaPlaylist的选择
     this.variants = Collections.unmodifiableList(variants);
+
     this.audios = Collections.unmodifiableList(audios);
     this.subtitles = Collections.unmodifiableList(subtitles);
+
     this.muxedAudioFormat = muxedAudioFormat;
     this.muxedCaptionFormat = muxedCaptionFormat;
   }
 
   public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
+    // variantUri --> List<HlsUrl>
+    // 只有一个：variantUri
     List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
     List<HlsUrl> emptyList = Collections.emptyList();
     return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null, null);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index fc70ec6de1..a6e027ecc9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -21,6 +21,8 @@
 
 /**
  * Represents an HLS media playlist.
+ *
+ * m3u8文件
  */
 public final class HlsMediaPlaylist extends HlsPlaylist {
 
@@ -78,16 +80,22 @@ public int compareTo(Long relativeStartTimeUs) {
   public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
       int version, long targetDurationUs, boolean hasEndTag, boolean hasProgramDateTime,
       Segment initializationSegment, List<Segment> segments) {
+
+    // HlsMasterPlaylist vs. HlsMediaPlaylist
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
-    this.startTimeUs = startTimeUs;
+
+    this.startTimeUs = startTimeUs; // 开始时间
     this.mediaSequence = mediaSequence;
     this.version = version;
     this.targetDurationUs = targetDurationUs;
-    this.hasEndTag = hasEndTag;
+    this.hasEndTag = hasEndTag; // 是否有结束标志
     this.hasProgramDateTime = hasProgramDateTime;
     this.initializationSegment = initializationSegment;
+
+    // 片段
     this.segments = Collections.unmodifiableList(segments);
 
+    // 整个Playlist的持续时间:duration
     if (!segments.isEmpty()) {
       Segment last = segments.get(segments.size() - 1);
       durationUs = last.relativeStartTimeUs + last.durationUs;
@@ -96,6 +104,7 @@ public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
     }
   }
 
+  // 两个Playlist如何比较呢?
   public boolean isNewerThan(HlsMediaPlaylist other) {
     return other == null || mediaSequence > other.mediaSequence
         || (mediaSequence == other.mediaSequence && segments.size() > other.segments.size())
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index fb62d9978e..784ec0ea4a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -30,6 +30,7 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_MASTER, TYPE_MEDIA})
   public @interface Type {}
+
   public static final int TYPE_MASTER = 0;
   public static final int TYPE_MEDIA = 1;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 1932caccf7..d29054b154 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -36,6 +36,7 @@
 
 /**
  * HLS playlists parsing logic.
+ * 如何m3u8文件呢?
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
@@ -96,13 +97,27 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
     Queue<String> extraLines = new LinkedList<>();
     String line;
+
+    // 这样的一个文件该如何分析呢？
+    //    #EXTM3U
+    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+    //    hls-360p/hls-360p.m3u8
+    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+    //    hls-480p/hls-480p.m3u8
+    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+    //    hls-720p/hls-720p.m3u8
+
     try {
       while ((line = reader.readLine()) != null) {
+        // 读取一行数据
         line = line.trim();
         if (line.isEmpty()) {
           // Do nothing.
         } else if (line.startsWith(TAG_STREAM_INF)) {
           extraLines.add(line);
+
+          // 一个m3u8文件有两种格式: master & playlist
+          // 通过个别的tag即可对两者进行区分
           return parseMasterPlaylist(new LineIterator(extraLines, reader), uri.toString());
         } else if (line.startsWith(TAG_TARGET_DURATION)
             || line.startsWith(TAG_MEDIA_SEQUENCE)
@@ -126,7 +141,7 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
 
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
-    ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
+    ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>(); // 不同分辨率，不同网络条件下的处理
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
     Format muxedAudioFormat = null;
@@ -134,8 +149,12 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
 
     String line;
     while (iterator.hasNext()) {
+      // 一行一行遍历
       line = iterator.next();
+
       if (line.startsWith(TAG_MEDIA)) {
+        // #EXT-X-MEDIA
+        // #EXTINF:3.008656,
         @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
         String uri = parseOptionalStringAttr(line, REGEX_URI);
         String name = parseStringAttr(line, REGEX_NAME);
@@ -169,9 +188,16 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
             break;
         }
       } else if (line.startsWith(TAG_STREAM_INF)) {
+        // #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+        // hls-360p/hls-360p.m3u8
+        // 解析出带宽
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
+        // 编码器
         String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
+        // 分辨率: 可选
         String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
+
+        // 解析分辨率(可选)
         int width;
         int height;
         if (resolutionString != null) {
@@ -191,9 +217,13 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         String name = Integer.toString(variants.size());
         Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
             codecs, bitrate, width, height, Format.NO_VALUE, null);
+
+        // 二级: m3u8文件
         variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
       }
     }
+
+    // 返回Master
     return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
         muxedCaptionFormat);
   }
@@ -205,6 +235,7 @@ private static int parseSelectionFlags(String line) {
         | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? C.SELECTION_FLAG_AUTOSELECT : 0);
   }
 
+  // 解析普通的Playlist文件
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     int mediaSequence = 0;
@@ -248,11 +279,13 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
         segmentMediaSequence = mediaSequence;
       } else if (line.startsWith(TAG_VERSION)) {
+        // 版本
         version = parseIntAttr(line, REGEX_VERSION);
       } else if (line.startsWith(TAG_MEDIA_DURATION)) {
-        segmentDurationUs =
-            (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
+        // 持续时间
+        segmentDurationUs = (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
+        // 秘钥
         String method = parseStringAttr(line, REGEX_METHOD);
         isEncrypted = METHOD_AES128.equals(method);
         if (isEncrypted) {
@@ -263,6 +296,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           encryptionIV = null;
         }
       } else if (line.startsWith(TAG_BYTERANGE)) {
+        // byte-range
         String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
         String[] splitByteRange = byteRange.split("@");
         segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
@@ -280,6 +314,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
         }
       } else if (!line.startsWith("#")) {
+        // 应该就是普通的ts的URL了
         String segmentEncryptionIV;
         if (!isEncrypted) {
           segmentEncryptionIV = null;
@@ -292,11 +327,14 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
+
+        // 获取segments的信息
         segments.add(new Segment(line, segmentDurationUs, discontinuitySequenceNumber,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
             segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
+
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
           segmentByteRangeOffset += segmentByteRangeLength;
         }
@@ -345,6 +383,7 @@ private static Pattern compileBooleanAttrPattern(String attribute) {
     return Pattern.compile(attribute + "=(" + BOOLEAN_FALSE + "|" + BOOLEAN_TRUE + ")");
   }
 
+  // 将reader和extralines组成的结构按照行遍历
   private static class LineIterator {
 
     private final BufferedReader reader;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index d25e5b1d9c..c36cc4caae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -36,6 +36,9 @@
 /**
  * Tracks playlists linked to a provided playlist url. The provided url might reference an HLS
  * master playlist or a media playlist.
+ *
+ * Track对应一个m3u8文件， 可能是master playlist或者media playlist; 注意不同的概念
+ * 负责m3u8的下载，管理，状态汇报
  */
 public final class HlsPlaylistTracker implements Loader.Callback<ParsingLoadable<HlsPlaylist>> {
 
@@ -45,7 +48,7 @@
   public interface PrimaryPlaylistListener {
 
     /**
-     * Called when the primary playlist changes.
+     * Called when the primary playlist changes. （主要的playlist?)
      *
      * @param mediaPlaylist The primary playlist new snapshot.
      */
@@ -108,13 +111,18 @@
   public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceFactory,
       EventDispatcher eventDispatcher, int minRetryCount,
       PrimaryPlaylistListener primaryPlaylistListener) {
+
     this.initialPlaylistUri = initialPlaylistUri;
     this.dataSourceFactory = dataSourceFactory;
     this.eventDispatcher = eventDispatcher;
     this.minRetryCount = minRetryCount;
     this.primaryPlaylistListener = primaryPlaylistListener;
     listeners = new ArrayList<>();
+
+    // 执行管理 Loadable
     initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
+
+    // Parse Playlist文件
     playlistParser = new HlsPlaylistParser();
     playlistBundles = new IdentityHashMap<>();
     playlistRefreshHandler = new Handler();
@@ -142,9 +150,8 @@ public void removeListener(PlaylistEventListener listener) {
    * Starts tracking all the playlists related to the provided Uri.
    */
   public void start() {
-    ParsingLoadable<HlsPlaylist> masterPlaylistLoadable = new ParsingLoadable<>(
-        dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST,
-        playlistParser);
+    ParsingLoadable<HlsPlaylist> masterPlaylistLoadable =
+            new ParsingLoadable<>(dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
     initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
   }
 
@@ -218,21 +225,37 @@ public boolean isLive() {
   @Override
   public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
+
+    // m3u8加载完毕
+    // 整个文件已经通过: playlistParser 进行解析
+    // 注意: ParsingLoadable<HlsPlaylist> 的构建方式
     HlsPlaylist result = loadable.getResult();
+
+    // 区分是一级索引还是二级索引
     HlsMasterPlaylist masterPlaylist;
     boolean isMediaPlaylist = result instanceof HlsMediaPlaylist;
+
+    // 如果是二级索引，则需要构建一个虚拟的masterPlaylist
     if (isMediaPlaylist) {
       masterPlaylist = HlsMasterPlaylist.createSingleVariantMasterPlaylist(result.baseUri);
     } else /* result instanceof HlsMasterPlaylist */ {
       masterPlaylist = (HlsMasterPlaylist) result;
     }
     this.masterPlaylist = masterPlaylist;
+
+    // XXX: 默认第一个为: primaryHlsUrl(因此在播放视频的时候刚开始总是不清晰....）
     primaryHlsUrl = masterPlaylist.variants.get(0);
     ArrayList<HlsUrl> urls = new ArrayList<>();
     urls.addAll(masterPlaylist.variants);
     urls.addAll(masterPlaylist.audios);
     urls.addAll(masterPlaylist.subtitles);
+
+    // 每一个URL <--> MediaPlaylistBundle
     createBundles(urls);
+
+    // 如何处理: MediaPlaylistBundle ?
+    // 1. 如果是MediaPlaylist, 则加载完毕
+    // 2. 如果是MastPlaylist, 则加载Playlist
     MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
     if (isMediaPlaylist) {
       // We don't need to load the playlist again. We can use the same result.
@@ -393,6 +416,11 @@ public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTim
       this.playlistUrl = playlistUrl;
       lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
       mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
+
+      // 注意: Loadable的构建
+      // UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url)
+      // 可能是从master m3u8触发，获取子的m3u8文件的URL
+      //
       mediaPlaylistLoadable = new ParsingLoadable<>(dataSourceFactory.createDataSource(),
           UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url), C.DATA_TYPE_MANIFEST,
           playlistParser);
@@ -420,6 +448,8 @@ public void loadPlaylist() {
     public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
         long loadDurationMs) {
       processLoadedPlaylist((HlsMediaPlaylist) loadable.getResult());
+
+      // 通知加载情况
       eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
           loadDurationMs, loadable.bytesLoaded());
     }
@@ -427,6 +457,7 @@ public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedR
     @Override
     public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
         long loadDurationMs, boolean released) {
+      // 通知加载情况
       eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
           loadDurationMs, loadable.bytesLoaded());
     }
@@ -434,12 +465,16 @@ public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRe
     @Override
     public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
         long loadDurationMs, IOException error) {
+      // 通知加载情况
       boolean isFatal = error instanceof ParserException;
       eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
           loadDurationMs, loadable.bytesLoaded(), error, isFatal);
       if (isFatal) {
         return Loader.DONT_RETRY_FATAL;
       }
+
+      // 加载出错了，是否该重试呢?
+      // 如何监控这种情况呢?
       boolean shouldRetry = true;
       if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {
         blacklistUntilMs =
@@ -461,8 +496,12 @@ public void run() {
     // Internal methods.
 
     private void processLoadedPlaylist(HlsMediaPlaylist loadedMediaPlaylist) {
+      // 认为: loadedMediaPlaylist 已经加载完毕，然后呢?
+
       HlsMediaPlaylist oldPlaylist = playlistSnapshot;
       playlistSnapshot = adjustPlaylistTimestamps(oldPlaylist, loadedMediaPlaylist);
+
+
       long refreshDelayUs = C.TIME_UNSET;
       if (oldPlaylist != playlistSnapshot) {
         if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index c81ffb441f..c085ee0831 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -64,6 +64,7 @@ public BaseTrackSelection(TrackGroup group, int... tracks) {
     Assertions.checkState(tracks.length > 0);
     this.group = Assertions.checkNotNull(group);
     this.length = tracks.length;
+
     // Set the formats, sorted in order of decreasing bandwidth.
     formats = new Format[length];
     for (int i = 0; i < tracks.length; i++) {
@@ -181,6 +182,7 @@ public boolean equals(Object obj) {
 
   /**
    * Sorts {@link Format} objects in order of decreasing bandwidth.
+   * 按照带宽从高到低排序
    */
   private static final class DecreasingBandwidthComparator implements Comparator<Format> {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
index c4296bd6f6..e2c4b4fab9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
@@ -23,11 +23,17 @@
 /**
  * Allows data corresponding to a given {@link DataSpec} to be read from a {@link DataSource} and
  * consumed through an {@link InputStream}.
+ *
+ * 通过: DataSpec来指定资源，通过InputStream接口来消费资源
  */
 public final class DataSourceInputStream extends InputStream {
 
+  // dataSource和dataSpec的关系？
+  // DataSource 通过 DataSpec来读取资源
+  //
   private final DataSource dataSource;
   private final DataSpec dataSpec;
+
   private final byte[] singleByteArray;
 
   private boolean opened = false;
@@ -79,6 +85,8 @@ public int read(byte[] buffer) throws IOException {
   public int read(byte[] buffer, int offset, int length) throws IOException {
     Assertions.checkState(!closed);
     checkOpened();
+
+
     int bytesRead = dataSource.read(buffer, offset, length);
     if (bytesRead == C.RESULT_END_OF_INPUT) {
       return -1;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index d251446976..c61a22d98a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -71,6 +71,7 @@
    */
   public final long length;
   /**
+   * 是否有缓存方面的优化呢?
    * A key that uniquely identifies the original stream. Used for cache indexing. May be null if the
    * {@link DataSpec} is not intended to be used in conjunction with a cache.
    */
@@ -158,6 +159,8 @@ public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long posi
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNSET);
+
+    // 注意: key参数的使用
     this.uri = uri;
     this.postBody = postBody;
     this.absoluteStreamPosition = absoluteStreamPosition;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index b326c41b18..94b649caa8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -189,6 +189,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.dataSpec = dataSpec;
     this.bytesRead = 0;
     this.bytesSkipped = 0;
+
+    // 每次创建一个新的连接
     try {
       connection = makeConnection(dataSpec);
     } catch (IOException e) {
@@ -345,6 +347,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     long length = dataSpec.length;
     boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
 
+    // 扩协议的跳转
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
       // automatically. This is the behavior we want, so use it.
@@ -391,6 +394,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
    */
   private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
       long length, boolean allowGzip, boolean followRedirects) throws IOException {
+    // 新建Connection
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index dcfed59145..e49dbcc7ae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -76,6 +76,7 @@ public DefaultHttpDataSourceFactory(String userAgent,
 
   @Override
   public DefaultHttpDataSource createDataSource() {
+    // 返回默认的HttpDataSource
     return new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
         readTimeoutMillis, allowCrossProtocolRedirects);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 64836dae4c..2137fa0c65 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -139,6 +139,7 @@ public UnexpectedLoaderException(Exception cause) {
    * @param threadName A name for the loader's thread.
    */
   public Loader(String threadName) {
+    // 包含一个线程 Executor
     this.downloadExecutorService = Util.newSingleThreadExecutor(threadName);
   }
 
@@ -161,6 +162,8 @@ public Loader(String threadName) {
     Looper looper = Looper.myLooper();
     Assertions.checkState(looper != null);
     long startTimeMs = SystemClock.elapsedRealtime();
+
+    // 创建一个LoadTask
     new LoadTask<>(looper, loadable, callback, defaultMinRetryCount, startTimeMs).start(0);
     return startTimeMs;
   }
@@ -292,6 +295,8 @@ public void run() {
         if (!loadable.isLoadCanceled()) {
           TraceUtil.beginSection("load:" + loadable.getClass().getSimpleName());
           try {
+            // 线程的核心:
+            // 和Loadable配合，处理Cancel, release, load等逻辑
             loadable.load();
           } finally {
             TraceUtil.endSection();
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index c23b609704..abc7071d25 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -72,6 +72,7 @@
    */
   public ParsingLoadable(DataSource dataSource, Uri uri, int type, Parser<T> parser) {
     this.dataSource = dataSource;
+    // 就像解析Html一样，需要一个Base URL
     this.dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP);
     this.type = type;
     this.parser = parser;
@@ -111,8 +112,11 @@ public final void load() throws IOException, InterruptedException {
     DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
     try {
       inputStream.open();
+
+      // 如何解析数据呢?
       result = parser.parse(dataSource.getUri(), inputStream);
     } finally {
+      // 读取了多少数据？
       bytesLoaded = inputStream.bytesRead();
       inputStream.close();
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
index 4477de7abb..8ab47f4bc3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -417,6 +417,7 @@ public static int binarySearchCeil(long[] array, long value, boolean inclusive,
   public static <T> int binarySearchFloor(List<? extends Comparable<? super T>> list, T value,
       boolean inclusive, boolean stayInBounds) {
     int index = Collections.binarySearch(list, value);
+    // - (-(insertion point) - 1 + 2) ==> insertion point - 1
     if (index < 0) {
       index = -(index + 2);
     } else {
