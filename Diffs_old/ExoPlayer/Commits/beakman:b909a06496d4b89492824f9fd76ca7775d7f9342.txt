diff --git a/build.gradle b/build.gradle
index 89ebb2ec42..d3afc90458 100644
--- a/build.gradle
+++ b/build.gradle
@@ -20,7 +20,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.android.tools.build:gradle:2.3.1'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 8c0c2db2de..c669c33c3a 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -82,21 +82,6 @@
             android:name=".LogService"
             android:enabled="true"
             android:exported="true" />
-
-        <receiver android:name="com.google.android.exoplayer2.demo.AutomationReceiver">
-            <intent-filter>
-                <action android:name="COMMAND" />
-                <action android:name="EXTRA_COMMAND" />
-                <action android:name="VIDEO_SOURCE" />
-                <action android:name="DBNAME" />
-                <action android:name="EXTRA_PARAMS" />
-                <action android:name="DRM_SCHEME_UUID_EXTRA" />
-                <action android:name="DRM_LICENSE_URL" />
-                <action android:name="DRM_KEY_REQUEST_PROPERTIES" />
-                <action android:name="PREFER_EXTENSION_DECODERS" />
-                <action android:name="EXTENSION_EXTRA" />
-            </intent-filter>
-        </receiver>
     </application>
 
 </manifest>
\ No newline at end of file
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java b/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java
deleted file mode 100644
index e79cd219b4..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package com.google.android.exoplayer2.demo;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-import android.net.Uri;
-import android.preference.PreferenceManager;
-
-import com.google.android.exoplayer2.util.Util;
-import com.google.android.exoplayer2.demo.SampleChooserActivity;
-import com.google.android.exoplayer2.demo.PlayerActivity;
-
-
-// Tenemos que llamar a esta funcion:
-/*
-private void onSampleSelected(Sample sample) {
-    PlayerActivity.VIDEO_SOURCE = sample.uri;
-    Intent mpdIntent = new Intent(this, PlayerActivity.class)
-    .setData(Uri.parse(sample.uri))
-    .putExtra(PlayerActivity.CONTENT_ID_EXTRA, sample.contentId)
-    .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type)
-    .putExtra(PlayerActivity.PROVIDER_EXTRA, sample.provider);
-    startActivity(mpdIntent);
-    }
-*/
-public class AutomationReceiver extends BroadcastReceiver {
-
-    /*
-    * Parametros del BroadcastReceiver
-    *
-    * - COMMAND_INTENT: esto creo que lo puedo quitar
-    * - EXTRA_COMMAND: esto es la accion a realizar (reproducir, reproducir x2, parar, etc)
-    * - VIDEO_SOURCE: la url donde esta alojado el video
-    * - EXTRA_PARAMS: esto creo que lo puedo quitar
-    * - DRM_SCHEME_UUID_EXTRA: parametros necesarios para videos con drm
-    * - DRM_LICENSE_URL: parametros necesarios para videos con drm
-    * - DRM_KEY_REQUEST_PROPERTIES: parametros necesarios para videos con drm
-    * - PREFER_EXTENSION_DECODERS: parametros necesarios para videos con drm
-    * - DBNAME: nombre de la base de datos que va a crear
-    *
-    * */
-    public static final String COMMAND_INTENT = "COMMAND";
-    public static final String DBNAME = "DBNAME";
-    public static final String EXTRA_COMMAND = "EXTRA_COMMAND";
-    public static final String VIDEO_SOURCE = "VIDEO_SOURCE";
-    public static final String EXTRA_PARAMS = "EXTRA_PARAMS";
-    public static final String DRM_SCHEME_UUID_EXTRA = "DRM_SCHEME_UUID_EXTRA";
-    public static final String DRM_LICENSE_URL = "DRM_LICENSE_URL";
-    public static final String DRM_KEY_REQUEST_PROPERTIES = "DRM_KEY_REQUEST_PROPERTIES";
-    public static final String PREFER_EXTENSION_DECODERS = "PREFER_EXTENSION_DECODERS";
-    public static final String EXTENSION_EXTRA = "EXTENSION_EXTRA";
-    private static final String TAG = "AutomationReceiver";
-    private Context mContext;
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        mContext = context;
-        String action = intent.getAction();
-        Log.d(TAG, "onReceive executed!");
-        if (action.equals(COMMAND_INTENT)) {
-            String command = intent.getStringExtra(EXTRA_COMMAND); // el comando ej: PLAY:VID:INI
-            if (command != null) {
-                Log.d(TAG, "Processing command...");
-                // Procesamos los parametros opcionales
-                String drm_scheme_uuid = null;
-                String drm_license_url = null;
-                String drm_key_request_properties = null;
-                String prefer_extension_decoders = null;
-                String dbname = null;
-
-                if (intent.getStringExtra(DRM_SCHEME_UUID_EXTRA) != null) { drm_scheme_uuid = intent.getStringExtra(DRM_SCHEME_UUID_EXTRA); }
-                if (intent.getStringExtra(DRM_LICENSE_URL) != null) { drm_license_url = intent.getStringExtra(DRM_LICENSE_URL); }
-                if (intent.getStringExtra(DRM_KEY_REQUEST_PROPERTIES) != null) { drm_key_request_properties = intent.getStringExtra(DRM_KEY_REQUEST_PROPERTIES); }
-                if (intent.getStringExtra(PREFER_EXTENSION_DECODERS) != null) { prefer_extension_decoders = intent.getStringExtra(PREFER_EXTENSION_DECODERS); }
-                if (intent.getStringExtra(DBNAME) != null) { dbname = intent.getStringExtra(DBNAME); }
-                String video_source = intent.getStringExtra(VIDEO_SOURCE);
-                processCommand(command, video_source, dbname, drm_scheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
-            }
-        }
-    }
-
-    // Estos son las funciones que se ejecutan con cada comando.
-    // La sitaxis de los comandos es SCAPY.
-    private void processCommand(String command,
-                                String video_source,
-                                String dbname,
-                                String drm_sheme_uuid,
-                                String drm_license_url,
-                                String drm_key_request_properties,
-                                String prefer_extension_decoders) {
-        if (command.equalsIgnoreCase("PLAY:VID:INI")) {
-            playVideo(video_source, dbname, drm_sheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
-            Log.d(TAG, "Command match: PLAY:VID:INI");
-        } else if (command.equalsIgnoreCase("PLAY:VID:5:MIN")) {
-            playVideoTo(video_source, 5);
-            Log.d(TAG, "Command match: PLAY:VID:5:MIN");
-        } else if (command.equalsIgnoreCase("STOP:VID")) {
-            stopVideo();
-            Log.d(TAG, "Command match: STOP:VID");
-        }
-    }
-
-    // Estas son las funciones que se ejecutan cuando se recibe cierto comando
-    public void playVideo(String video_source,
-                          String dbname,
-                          String drm_sheme_uuid,
-                          String drm_license_url,
-                          String drm_key_request_properties,
-                          String prefer_extension_decoders) {
-        Log.d(TAG, "Play video!");
-        Intent mpdIntent = new Intent(mContext, PlayerActivity.class);
-        mpdIntent.setData(Uri.parse(video_source));
-        if (dbname != null) { mpdIntent.putExtra(PlayerActivity.DBNAME, dbname); }
-        if (drm_sheme_uuid != null) { mpdIntent.putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drm_sheme_uuid); }
-        if (drm_license_url != null) { mpdIntent.putExtra(PlayerActivity.DRM_LICENSE_URL, drm_license_url); }
-        if (drm_key_request_properties != null) { mpdIntent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drm_key_request_properties); }
-        if (prefer_extension_decoders != null) { mpdIntent.putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS, prefer_extension_decoders); }
-        mpdIntent.setAction("com.google.android.exoplayer.demo.action.VIEW");
-        mContext.startActivity(mpdIntent);
-    }
-
-    public void playVideoTo(String video_source, int time) {
-        Log.d(TAG, "Play video for 5 minutes!");
-        /*Intent mpdIntent = new Intent(mContext, PlayerActivity.class)
-                .setData(Uri.parse(video_source))
-                .putExtra(PlayerActivity.CONTENT_ID_EXTRA, "0894c7c8719b28a0")
-                .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, Util.TYPE_DASH)
-                .putExtra(PlayerActivity.PROVIDER_EXTRA, "widevine_test")
-                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        mContext.startActivity(mpdIntent);*/
-    }
-
-    public void stopVideo() {
-        Log.d(TAG, "Stop video!");
-        Intent intent = new Intent(mContext, SampleChooserActivity.class)
-                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        //llamamos a la actividad
-        mContext.startActivity(intent);
-    }
-
-}
\ No newline at end of file
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index e6ee0028ff..d8de8d110f 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -448,6 +448,18 @@ public void onLoadCanceled(DataSpec dataSpec, int dataType, int trackType, Forma
   public void onLoadCompleted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
                               int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
                               long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
+    try {
+      String mimetype = trackFormat.sampleMimeType;
+      String bitrate = String.valueOf(trackFormat.bitrate);
+      String resolution = String.valueOf(trackFormat.width) + "x" + String.valueOf(trackFormat.height);
+      String fps = String.valueOf(trackFormat.frameRate);
+      if (trackFormat.width != -1) {
+        LogService.logVideoInputFormatChanged(mimetype, bitrate, resolution, fps);
+        Log.d("[LogService]", "onLoadCompleted! res=" + resolution);
+      }
+    } catch (Exception e) {
+      Log.e("[LogService]", "onLoadCompleted, fallo al escribir el log.");
+    }
   }
 
   @Override
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java b/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
index fdd1fcd150..d4d5c7bdd8 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
@@ -266,6 +266,7 @@ public static void logVideoInputFormatChanged(String mimetype, String bitrate, S
                 public void run() {
                     measure_points.get(0).inject(data); // video_format field
                     Log.d("[LogService]", "VideoInputFormatChanged at " + data[0] + "; mimetype: " + data[1] + "; bitrate: " + data[2] + "; resolution: " + data[3] + "; fps: " + data[4]);
+                    Log.d("[TrackSelection]", "VideoInputFormatChanged at " + data[0] + "; mimetype: " + data[1] + "; bitrate: " + data[2] + "; resolution: " + data[3] + "; fps: " + data[4]);
                 }
             });
             t.start();
@@ -350,14 +351,20 @@ public void onCreate() {
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         // Hemos metido en el Intent parametros adicionales, los sacamos con esto
-        Bundle extras = intent.getExtras();
+        Bundle extras = null;
+        try {
+            extras = intent.getExtras();
+        } catch (Exception e) {
+            Log.e("[LogService]", "Fallo al recuperar los extras del intent en LogService.");
+        }
         String dbname = "exoplayer_" + formatter.format(System.currentTimeMillis()); // default
         String server_address = ""; // ejemplo: 94.177.232.57:5432
 
         // Nombre de la base de datos:
 
+        // no hay extras, nombre por defecto para la base de datos
         if(extras.get("DBNAME") == null) {
-            Log.d("[LogService]", "null"); // no hay extras, nombre por defecto para la base de datos
+            Log.d("[LogService]", "No se ha especificado ningun nombre para la base de datos. Se le asigna: " + dbname);
         }
         else
         {
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 570f3a23eb..fd7c6f448f 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -53,8 +53,9 @@
 import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultFixedTrackSelector;
+import com.google.android.exoplayer2.trackselection.NonAdaptiveVideoTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.TrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -78,7 +79,6 @@
 /* Para seleccionar la resolucion */
 import android.util.Log;
 
-
 /**
  * An activity that plays media using {@link SimpleExoPlayer}.
  */
@@ -90,9 +90,23 @@
   public static final String DRM_KEY_REQUEST_PROPERTIES = "drm_key_request_properties";
   public static final String PREFER_EXTENSION_DECODERS = "prefer_extension_decoders";
 
-  public static final String DBNAME = "dbname";
-  public static final String OML2ADDR = "oml2addr";
-  public static final String RESOLUTION = "resolution";
+  /*
+  * Parámetros para pasar por adb
+  * =============================
+  *
+  * Ejemplo: ./adb shell am start -a com.google.android.exoplayer.demo.action.VIEW
+  *            -d "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd"
+  *            --es dbname "forzado-resolucion2"
+  *            --es oml2addr "tcp:94.177.232.57:3003"
+  *            --es video_tindex 1
+  *
+  * */
+  public static final String DBNAME = "dbname";              // Nombre de la BBDD
+  public static final String OML2ADDR = "oml2addr";          // Direccion del servidor OML
+  public static final String VIDEO_TINDEX = "video_tindex";  // Video TrackIndex
+  public static final String VIDEO_GINDEX = "video_gindex";  // Video GroupIndex
+  public static final String AUDIO_TINDEX = "audio_tindex";  // Audio TrackIndex
+  public static final String AUDIO_GINDEX = "audio_gindex";  // Audio GroupIndex
 
   public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
   public static final String EXTENSION_EXTRA = "extension";
@@ -169,7 +183,7 @@ public void onNewIntent(Intent intent) {
   public void onStart() {
     super.onStart();
     if (Util.SDK_INT > 23) {
-      initializePlayer();
+        initializePlayer();
     }
   }
 
@@ -185,7 +199,7 @@ public void onResume() {
   public void onPause() {
     super.onPause();
     if (Util.SDK_INT <= 23) {
-      releasePlayer();
+        releasePlayer();
     }
   }
 
@@ -227,20 +241,27 @@ public void onVisibilityChange(int visibility) {
     debugRootView.setVisibility(visibility);
   }
 
-  // Internal methods
-
+  /*
+  *   Parámetros para adb
+  *   ===================
+  *   - dbname: nombre de la base de datos, por defecto se genera a partir de la fecha y hora
+  *   - oml2addr: la direccion del servidor OML2 (i.e: tcp:94.177.232.57:3003)
+  *   - video_tindex: el indice de track para video. Sirve para forzar una determinada resolución
+  *   - video_gindex: el indice de grupo de video. No se aún para qué sirve
+  *   - audio_tindex: el indice de track para audio. Sirve para forzar un determinado bitrate de audio
+  *   - audio_gindex: el indice de grupo de audio. No se aún para qué sirve
+  *
+  * */
   private void initializePlayer() {
-    /*
-    *  Aqui se trata el Intent, con sus parametros.
-    *  Los parametros se cogen con los getStringExtras esos.
-    *
-    * */
-    Intent intent = getIntent(); // 1º capturamos el Intent
-    if (player == null) { // si no existe ningun player... lo configuramos:
+    Intent intent = getIntent();
+    if (player == null) {
 
       String dbname = intent.getStringExtra(DBNAME);
       String oml2addr = intent.getStringExtra(OML2ADDR);
-      String resolution = intent.getStringExtra(RESOLUTION);
+      String video_tindex = intent.getStringExtra(VIDEO_TINDEX);
+      String video_gindex = intent.getStringExtra(VIDEO_GINDEX);
+      String audio_tindex = intent.getStringExtra(AUDIO_TINDEX);
+      String audio_gindex = intent.getStringExtra(AUDIO_GINDEX);
 
       // Esto no se para que sirve. Es false por defecto
       boolean preferExtensionDecoders = intent.getBooleanExtra(PREFER_EXTENSION_DECODERS, false);
@@ -279,15 +300,15 @@ private void initializePlayer() {
         }
       }
 
-      // Llamamos al LogService. Si ya hay un LogService escuchando, lo paramos y creamos otro.
-      // Tenemos que ver como le pasamos el parametro DBNAME
-      // Podemos usar esto: intent.getStringExtra(DBNAME
-      // if... intent.getStringExtra(DBNAME) tal, Sino lo generamos con la fecha
-
+      /* Configuración de LogService:
+      *  ===========================
+      *  1- Llamamos al LogService. Si ya hay un LogService escuchando, lo paramos y creamos otro.
+      *
+      */
       Intent LogServiceIntent = new Intent(this,LogService.class);
 
       LogServiceIntent.putExtra("DBNAME", dbname); // dbname nunca sera null, viene de LogService
-      LogServiceIntent.putExtra("OML2ADDR", oml2addr); //
+      LogServiceIntent.putExtra("OML2ADDR", oml2addr); // la direccion del servidor oml
 
       if (LogService.logServiceIsRunning) {
         stopService(LogServiceIntent);
@@ -296,23 +317,65 @@ private void initializePlayer() {
       logservice = new LogService();
 
       eventLogger = new EventLogger();
-      TrackSelection.Factory videoTrackSelectionFactory =
-          new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
-      trackSelector = new DefaultTrackSelector(mainHandler, videoTrackSelectionFactory);
+
+      /*
+       *  Forzar una pista de audio/video/subtitulos
+       *  ==========================================
+       *  En todos los casos hay que especificar un grupo y pista: GroupIndex y TrackIndex
+       */
+      String vti = intent.hasExtra(VIDEO_TINDEX) ? intent.getStringExtra(VIDEO_TINDEX) : null;
+      String vgi = intent.hasExtra(VIDEO_GINDEX) ? intent.getStringExtra(VIDEO_GINDEX) : null;
+      String ati = intent.hasExtra(AUDIO_TINDEX) ? intent.getStringExtra(AUDIO_TINDEX) : null;
+      String agi = intent.hasExtra(AUDIO_GINDEX) ? intent.getStringExtra(AUDIO_GINDEX) : null;
+
+        int selectedVTIndex; // selected video track index
+        int selectedVGIndex; // selected video group index
+        int selectedATIndex; // selected audio track index
+        int selectedAGIndex; // selected audio group index
+
+        try {
+            selectedVTIndex = Integer.parseInt(vti);
+        } catch (NumberFormatException e) {
+            selectedVTIndex = -1;
+        }
+        try {
+            selectedVGIndex = Integer.parseInt(vgi);
+        } catch (NumberFormatException e) {
+            selectedVGIndex = -1;
+        }
+        try {
+            selectedATIndex = Integer.parseInt(ati);
+        } catch (NumberFormatException e) {
+            selectedATIndex = -1;
+        }
+        try {
+            selectedAGIndex = Integer.parseInt(agi);
+        } catch (NumberFormatException e) {
+            selectedAGIndex = -1;
+        }
+
+        TrackSelection.Factory videoTrackSelectionFactory =
+              new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
+
+      /*
+       * Si hemos fijado algun parametro de resolución de video o audio usamos
+       * este TrackSelector, sino nos quedamos con el Adaptativo por defecto
+       *
+       * */
+      if (vti!=null || vgi!=null || ati!=null || agi!=null) {
+          // nuestro trackSelector custom
+          videoTrackSelectionFactory =
+                  new NonAdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER, selectedVTIndex, selectedVGIndex, selectedATIndex, selectedAGIndex);
+          trackSelector = new DefaultFixedTrackSelector(mainHandler, null, selectedVTIndex, selectedVGIndex, selectedATIndex, selectedAGIndex); // null si no adaptiveVideo
+      } else {
+          // la opcion por defecto
+          trackSelector = new DefaultTrackSelector(mainHandler, videoTrackSelectionFactory);
+      }
+
       trackSelector.addListener(this);
       trackSelector.addListener(eventLogger);
-      Log.d("[TrackSelection]", "trackSelector " + trackSelector.getTrackInfo());
       trackSelectionHelper = new TrackSelectionHelper(trackSelector, videoTrackSelectionFactory);
 
-      // Si tenemos la resolucion, la forzamos
-      String res = intent.hasExtra(RESOLUTION) ? intent.getStringExtra(RESOLUTION) : null;
-      if (res == null) {
-        TrackSelection.Factory FIXED_FACTORY = new FixedTrackSelection.Factory();
-        MappingTrackSelector.SelectionOverride override = null;
-        override = new MappingTrackSelector.SelectionOverride(FIXED_FACTORY, 0, 0);
-        // MappingTrackSelector.setSelectionOverride();
-      }
-
       player = ExoPlayerFactory.newSimpleInstance(this, trackSelector, new DefaultLoadControl(),
           drmSessionManager, preferExtensionDecoders);
       player.addListener(this);
@@ -333,6 +396,19 @@ private void initializePlayer() {
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
       playerNeedsSource = true;
+
+      /*
+      *  Forzamos la resolucion
+      *
+      * */
+
+      // Si tenemos la resolucion, la forzamos creo que ya no se usa
+//      if (res != null) {
+//        int ti = Integer.parseInt(res); // trackIndex
+//        Log.d("[TrackSelection]", "Forzando resolucion...a " + ti + " !!!!!");
+//        trackSelectionHelper.setResolution(ti);
+//      }
+
     }
     if (playerNeedsSource) {
       String action = intent.getAction();
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index 1a02484888..ec2a76992b 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -39,6 +39,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.Arrays;
 import java.util.Locale;
+import java.util.Map;
 
 /**
  * Helper class for displaying track selection dialogs.
@@ -122,6 +123,7 @@ private View buildView(LayoutInflater inflater) {
     root.addView(disableView);
 
     // View for clearing the override to allow the selector to use its default selection logic.
+    Log.d("[TrackSelection]", "Haciendo algo con defaultView");
     defaultView = (CheckedTextView) inflater.inflate(
         android.R.layout.simple_list_item_single_choice, root, false);
     defaultView.setText(R.string.selection_default);
@@ -136,6 +138,7 @@ private View buildView(LayoutInflater inflater) {
     trackViews = new CheckedTextView[trackGroups.length][];
     for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
       TrackGroup group = trackGroups.get(groupIndex);
+      Log.d("[TrackSelection]", "trackGroups.get(groupIndex)..." + group);
       boolean groupIsAdaptive = trackGroupsAdaptive[groupIndex];
       haveAdaptiveTracks |= groupIsAdaptive;
       trackViews[groupIndex] = new CheckedTextView[group.length];
@@ -181,6 +184,7 @@ private View buildView(LayoutInflater inflater) {
   }
 
   private void updateViews() {
+    Log.d("[TrackSelection]", "UpdatingViews...");
     disableView.setChecked(isDisabled);
     defaultView.setChecked(!isDisabled && override == null);
     for (int i = 0; i < trackViews.length; i++) {
@@ -211,6 +215,7 @@ public void onClick(DialogInterface dialog, int which) {
     selector.setRendererDisabled(rendererIndex, false);
     if (override != null) {
       selector.setSelectionOverride(rendererIndex, trackGroups, override);
+      Log.d("[TrackSelection]", "trackGroups: " + trackGroups);
     } else {
       selector.clearSelectionOverrides(rendererIndex);
     }
@@ -236,8 +241,10 @@ public void onClick(View view) {
       int trackIndex = tag.second;
       if (!trackGroupsAdaptive[groupIndex] || override == null
           || override.groupIndex != groupIndex) {
-        override = new SelectionOverride(FIXED_FACTORY, groupIndex, trackIndex); // aqui seleccionamos las pistas
-        Log.d("[TrackSelection]", "SelectionOverride: " + override.tracks);
+        // este es el caso en el que solo seleccionamos una pista
+        override = new SelectionOverride(FIXED_FACTORY, groupIndex, trackIndex);
+        Log.d("[TrackSelection]", "trackGroupsAdaptive[: " + groupIndex + "]=" + trackGroupsAdaptive[groupIndex]);
+        Log.d("[TrackSelection]", "FIXED_FACTORY: " + groupIndex + ", " + trackIndex);
       } else {
         // The group being modified is adaptive and we already have a non-null override.
         boolean isEnabled = ((CheckedTextView) view).isChecked();
@@ -267,24 +274,33 @@ private void setOverride(int group, int[] tracks, boolean enableRandomAdaptation
     TrackSelection.Factory factory = tracks.length == 1 ? FIXED_FACTORY
         : (enableRandomAdaptation ? RANDOM_FACTORY : adaptiveVideoTrackSelectionFactory);
     override = new SelectionOverride(factory, group, tracks);
+    Log.d("[TrackSelection]", "setOverride: " + override.toString());
+    Log.d("[TrackSelection]", "RANDOM_FACTORY: " + RANDOM_FACTORY.toString());
   }
 
-   /*
-  *  Idea para forzar la resolución:
+  /*
+  *  Forzamos la resolución:
   *
-  *  1º Creamos un override = new SelectionOverride(FIXED_FACTORY, groupIndex, trackIndex);
-  *     trackIndex indicara la pista elegida. Cada pista tiene un formato determinado (resolucion entre otras cosas)
-  *
-  *  2º setOverride(groupIndex, getTracksAdding(override, trackIndex),
-  *           enableRandomAdaptationView.isChecked());
-  *
-  *  3º updateViews()
+  *  - Pasamos el trackIndex desde PlayerActivity, que es la que captura los parametros desde adb
+  *  - groupIndex: no sé qué es
   *
   * */
-  public void setResolution() {
-    Log.d("[TrackSelection]", "Forzando resolucion...!");
-    override = new SelectionOverride(FIXED_FACTORY, 0, 0);
-    setOverride(0, getTracksAdding(override, 0), false);
+
+  public void setResolution(int TrackIndex) {
+    int ti = TrackIndex;
+
+    Log.d("[TrackSelection]", "Marcando opciones...");
+    if (defaultView != null) {
+      defaultView.setChecked(false);
+    }
+    if (disableView != null) {
+      disableView.setChecked(false);
+    }
+
+    selector.clearSelectionOverrides(rendererIndex);
+    override = new SelectionOverride(FIXED_FACTORY, 0, ti);
+    Log.d("[TrackSelection]", "SelectionOverride " + rendererIndex + ", " + ti);
+    // updateViews(); esto sirve para actualizar el menu con las distintas resoluciones
   }
 
   // Track array manipulation.
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index c81ffb441f..6a3b5b4072 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -120,6 +122,7 @@ public final int indexOf(int indexInTrackGroup) {
 
   @Override
   public final Format getSelectedFormat() {
+    Log.d("[TrackSelection]", "getSelectedIndex()=" + getSelectedIndex());
     return formats[getSelectedIndex()];
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultFixedTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultFixedTrackSelector.java
new file mode 100644
index 0000000000..adeedfeedc
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultFixedTrackSelector.java
@@ -0,0 +1,691 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.os.Handler;
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Util;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * A {@link MappingTrackSelector} that allows configuration of common parameters.
+ */
+public class DefaultFixedTrackSelector extends MappingTrackSelector {
+
+  /**
+   * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
+   * corresponding viewport dimension, then the video is considered as filling the viewport (in that
+   * dimension).
+   */
+  private static final float FRACTION_TO_CONSIDER_FULLSCREEN = 0.98f;
+  private static final int[] NO_TRACKS = new int[0];
+
+  private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
+  private final int selectedVideoTrackIndex;
+  private final int selectedVideoGroupIndex;
+  private final int selectedAudioTrackIndex;
+  private final int selectedAudioGroupIndex;
+
+  // Audio.
+  private String preferredAudioLanguage;
+
+  // Text.
+  private String preferredTextLanguage;
+
+  // Video.
+  private boolean allowMixedMimeAdaptiveness;
+  private boolean allowNonSeamlessAdaptiveness;
+  private int maxVideoWidth;
+  private int maxVideoHeight;
+  private boolean exceedVideoConstraintsIfNecessary;
+  private boolean orientationMayChange;
+  private int viewportWidth;
+  private int viewportHeight;
+
+  /**
+   * Constructs an instance that does not support adaptive video.
+   *
+   * @param eventHandler A handler to use when delivering events to listeners. May be null if
+   *     listeners will not be added.
+   * @param selectedVideoTrackIndex
+   * @param selectedVideoGroupIndex
+   * @param selectedAudioTrackIndex
+   * @param selectedAudioGroupIndex
+   */
+  public DefaultFixedTrackSelector(Handler eventHandler, int selectedVideoTrackIndex, int selectedVideoGroupIndex, int selectedAudioTrackIndex, int selectedAudioGroupIndex) {
+    this(eventHandler, null, selectedVideoTrackIndex, selectedVideoGroupIndex, selectedAudioTrackIndex, selectedAudioGroupIndex);
+  }
+
+  /**
+   * Constructs an instance that uses a factory to create adaptive video track selections.
+   *
+   * @param eventHandler A handler to use when delivering events to listeners. May be null if
+   *     listeners will not be added.
+   * @param adaptiveVideoTrackSelectionFactory A factory for adaptive video {@link TrackSelection}s,
+   *     or null if the selector should not support adaptive video.
+   */
+  public DefaultFixedTrackSelector(Handler eventHandler,
+                                   TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
+                                   int selectedVideoTrackIndex,
+                                   int selectedVideoGroupIndex,
+                                   int selectedAudioTrackIndex,
+                                   int selectedAudioGroupIndex) {
+    super(eventHandler);
+    this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
+    this.selectedVideoTrackIndex = selectedVideoTrackIndex;
+    this.selectedVideoGroupIndex = selectedVideoGroupIndex;
+    this.selectedAudioTrackIndex = selectedAudioTrackIndex;
+    this.selectedAudioGroupIndex = selectedAudioGroupIndex;
+    allowNonSeamlessAdaptiveness = true;
+    exceedVideoConstraintsIfNecessary = true;
+    maxVideoWidth = Integer.MAX_VALUE;
+    maxVideoHeight = Integer.MAX_VALUE;
+    viewportWidth = Integer.MAX_VALUE;
+    viewportHeight = Integer.MAX_VALUE;
+    orientationMayChange = true;
+  }
+
+  /**
+   * Sets the preferred language for audio, as well as for forced text tracks.
+   *
+   * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
+   *     select the default track, or first track if there's no default.
+   */
+  public void setPreferredLanguages(String preferredAudioLanguage) {
+    preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
+    if (!Util.areEqual(this.preferredAudioLanguage, preferredAudioLanguage)) {
+      this.preferredAudioLanguage = preferredAudioLanguage;
+      invalidate();
+    }
+  }
+
+  /**
+   * Sets the preferred language for text tracks.
+   *
+   * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
+   *     select the default track, or no track if there's no default.
+   */
+  public void setPreferredTextLanguage(String preferredTextLanguage) {
+    preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+    if (!Util.areEqual(this.preferredTextLanguage, preferredTextLanguage)) {
+      this.preferredTextLanguage = preferredTextLanguage;
+      invalidate();
+    }
+  }
+
+  /**
+   * Sets whether to allow selections to contain mixed mime types.
+   *
+   * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
+   */
+  public void allowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
+    if (this.allowMixedMimeAdaptiveness != allowMixedMimeAdaptiveness) {
+      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+      invalidate();
+    }
+  }
+
+  /**
+   * Sets whether non-seamless adaptation is allowed.
+   *
+   * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
+   */
+  public void allowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
+    if (this.allowNonSeamlessAdaptiveness != allowNonSeamlessAdaptiveness) {
+      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+      invalidate();
+    }
+  }
+
+  /**
+   * Sets the maximum allowed size for video tracks.
+   *
+   * @param maxVideoWidth Maximum allowed width.
+   * @param maxVideoHeight Maximum allowed height.
+   */
+  public void setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
+    if (this.maxVideoWidth != maxVideoWidth || this.maxVideoHeight != maxVideoHeight) {
+      this.maxVideoWidth = maxVideoWidth;
+      this.maxVideoHeight = maxVideoHeight;
+      invalidate();
+    }
+  }
+
+  /**
+   * Equivalent to {@code setMaxVideoSize(1279, 719)}.
+   */
+  public void setMaxVideoSizeSd() {
+    setMaxVideoSize(1279, 719);
+  }
+
+  /**
+   * Equivalent to {@code setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
+   */
+  public void clearMaxVideoSize() {
+    setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
+  }
+
+  /**
+   * Sets whether video constraints should be ignored when no selection can be made otherwise.
+   *
+   * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
+   *     can be made otherwise. False to force constraints anyway.
+   */
+  public void setExceedVideoConstraintsIfNecessary(boolean exceedVideoConstraintsIfNecessary) {
+    if (this.exceedVideoConstraintsIfNecessary != exceedVideoConstraintsIfNecessary) {
+      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+      invalidate();
+    }
+  }
+
+  /**
+   * Sets the target viewport size for selecting video tracks.
+   *
+   * @param viewportWidth Viewport width in pixels.
+   * @param viewportHeight Viewport height in pixels.
+   * @param orientationMayChange Whether orientation may change during playback.
+   */
+  public void setViewportSize(int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+    if (this.viewportWidth != viewportWidth || this.viewportHeight != viewportHeight
+        || this.orientationMayChange != orientationMayChange) {
+      this.viewportWidth = viewportWidth;
+      this.viewportHeight = viewportHeight;
+      this.orientationMayChange = orientationMayChange;
+      invalidate();
+    }
+  }
+
+  /**
+   * Retrieves the viewport size from the provided {@link Context} and calls
+   * {@link #setViewportSize(int, int, boolean)} with this information.
+   *
+   * @param context The context to obtain the viewport size from.
+   * @param orientationMayChange Whether orientation may change during playback.
+   */
+  public void setViewportSizeFromContext(Context context, boolean orientationMayChange) {
+    Point viewportSize = Util.getPhysicalDisplaySize(context); // Assume the viewport is fullscreen.
+    setViewportSize(viewportSize.x, viewportSize.y, orientationMayChange);
+  }
+
+  /**
+   * Equivalent to {@code setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+   */
+  public void clearViewportConstraints() {
+    setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+  }
+
+  // MappingTrackSelector implementation.
+
+  @Override
+  protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
+      throws ExoPlaybackException {
+    // Make a track selection for each renderer.
+    TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      switch (rendererCapabilities[i].getTrackType()) {
+        case C.TRACK_TYPE_VIDEO:
+          rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
+              rendererTrackGroupArrays[i], rendererFormatSupports[i], maxVideoWidth, maxVideoHeight,
+              allowNonSeamlessAdaptiveness, allowMixedMimeAdaptiveness, viewportWidth,
+              viewportHeight, orientationMayChange, adaptiveVideoTrackSelectionFactory,
+              exceedVideoConstraintsIfNecessary);
+          break;
+        case C.TRACK_TYPE_AUDIO:
+          rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
+              rendererFormatSupports[i], preferredAudioLanguage);
+          break;
+        case C.TRACK_TYPE_TEXT:
+          rendererTrackSelections[i] = selectTextTrack(rendererTrackGroupArrays[i],
+              rendererFormatSupports[i], preferredTextLanguage, preferredAudioLanguage);
+          break;
+        default:
+          rendererTrackSelections[i] = selectOtherTrack(rendererCapabilities[i].getTrackType(),
+              rendererTrackGroupArrays[i], rendererFormatSupports[i]);
+          break;
+      }
+    }
+    return rendererTrackSelections;
+  }
+
+  // Video track selection implementation.
+
+  protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilities,
+      TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
+      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
+      int viewportHeight, boolean orientationMayChange,
+      TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
+      boolean exceedConstraintsIfNecessary) throws ExoPlaybackException {
+    TrackSelection selection = null;
+    if (adaptiveVideoTrackSelectionFactory != null) {
+      selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
+          maxVideoWidth, maxVideoHeight, allowNonSeamlessAdaptiveness,
+          allowMixedMimeAdaptiveness, viewportWidth, viewportHeight,
+          orientationMayChange, adaptiveVideoTrackSelectionFactory);
+    }
+    if (selection == null) {
+      selection = selectFixedVideoTrack(groups, formatSupport, maxVideoWidth, maxVideoHeight,
+          viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary);
+    }
+    return selection;
+  }
+
+  private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rendererCapabilities,
+      TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
+      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
+      int viewportHeight, boolean orientationMayChange,
+      TrackSelection.Factory adaptiveVideoTrackSelectionFactory) throws ExoPlaybackException {
+    int requiredAdaptiveSupport = allowNonSeamlessAdaptiveness
+        ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
+        : RendererCapabilities.ADAPTIVE_SEAMLESS;
+    boolean allowMixedMimeTypes = allowMixedMimeAdaptiveness
+        && (rendererCapabilities.supportsMixedMimeTypeAdaptation() & requiredAdaptiveSupport) != 0;
+    for (int i = 0; i < groups.length; i++) {
+      TrackGroup group = groups.get(i);
+      int[] adaptiveTracks = getAdaptiveTracksForGroup(group, formatSupport[i],
+          allowMixedMimeTypes, requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+          viewportWidth, viewportHeight, orientationMayChange);
+      if (adaptiveTracks.length > 0) {
+        return adaptiveVideoTrackSelectionFactory.createTrackSelection(group, adaptiveTracks);
+      }
+    }
+    return null;
+  }
+
+  private static int[] getAdaptiveTracksForGroup(TrackGroup group, int[] formatSupport,
+      boolean allowMixedMimeTypes, int requiredAdaptiveSupport, int maxVideoWidth,
+      int maxVideoHeight, int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+    if (group.length < 2) {
+      return NO_TRACKS;
+    }
+
+    List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(group, viewportWidth,
+        viewportHeight, orientationMayChange);
+    if (selectedTrackIndices.size() < 2) {
+      return NO_TRACKS;
+    }
+
+    String selectedMimeType = null;
+    if (!allowMixedMimeTypes) {
+      // Select the mime type for which we have the most adaptive tracks.
+      HashSet<String> seenMimeTypes = new HashSet<>();
+      int selectedMimeTypeTrackCount = 0;
+      for (int i = 0; i < selectedTrackIndices.size(); i++) {
+        int trackIndex = selectedTrackIndices.get(i);
+        String sampleMimeType = group.getFormat(trackIndex).sampleMimeType;
+        if (!seenMimeTypes.contains(sampleMimeType)) {
+          seenMimeTypes.add(sampleMimeType);
+          int countForMimeType = getAdaptiveTrackCountForMimeType(group, formatSupport,
+              requiredAdaptiveSupport, sampleMimeType, maxVideoWidth, maxVideoHeight,
+              selectedTrackIndices);
+          if (countForMimeType > selectedMimeTypeTrackCount) {
+            selectedMimeType = sampleMimeType;
+            selectedMimeTypeTrackCount = countForMimeType;
+          }
+        }
+      }
+    }
+
+    // Filter by the selected mime type.
+    filterAdaptiveTrackCountForMimeType(group, formatSupport, requiredAdaptiveSupport,
+        selectedMimeType, maxVideoWidth, maxVideoHeight, selectedTrackIndices);
+
+    return selectedTrackIndices.size() < 2 ? NO_TRACKS : Util.toArray(selectedTrackIndices);
+  }
+
+  private static int getAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
+      int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
+      List<Integer> selectedTrackIndices) {
+    int adaptiveTrackCount = 0;
+    for (int i = 0; i < selectedTrackIndices.size(); i++) {
+      int trackIndex = selectedTrackIndices.get(i);
+      if (isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
+          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+        adaptiveTrackCount++;
+      }
+    }
+    return adaptiveTrackCount;
+  }
+
+  private static void filterAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
+      int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
+      List<Integer> selectedTrackIndices) {
+    for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
+      int trackIndex = selectedTrackIndices.get(i);
+      if (!isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
+          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+        selectedTrackIndices.remove(i);
+      }
+    }
+  }
+
+  private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeType,
+      int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight) {
+    return isSupported(formatSupport) && ((formatSupport & requiredAdaptiveSupport) != 0)
+        && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
+        && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
+        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+  }
+
+  /*
+   *  Para forzar la pista de video elegimos un valor de "selectedGroup" y "selectedTrackIndex"
+   *
+   *  en la llamada a: new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+   *
+   * */
+  private TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
+                                               int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int viewportWidth,
+                                               int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary) {
+    TrackGroup selectedGroup = null;
+
+    int selectedTrackIndex = 0;
+    int selectedPixelCount = Format.NO_VALUE;
+    boolean selectedIsWithinConstraints = false;
+    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+      TrackGroup group = groups.get(groupIndex);
+      List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(group, viewportWidth,
+          viewportHeight, orientationMayChange);
+      int[] trackFormatSupport = formatSupport[groupIndex];
+      for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
+        if (isSupported(trackFormatSupport[trackIndex])) {
+          Format format = group.getFormat(trackIndex);
+          boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
+              && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
+              && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+          int pixelCount = format.getPixelCount();
+          boolean selectTrack;
+          if (selectedIsWithinConstraints) {
+            selectTrack = isWithinConstraints
+                && comparePixelCounts(pixelCount, selectedPixelCount) > 0;
+          } else {
+            selectTrack = isWithinConstraints || (exceedConstraintsIfNecessary
+                && (selectedGroup == null
+                || comparePixelCounts(pixelCount, selectedPixelCount) < 0));
+          }
+          if (selectTrack) {
+            selectedGroup = group;
+            selectedTrackIndex = trackIndex;
+            selectedPixelCount = pixelCount;
+            selectedIsWithinConstraints = isWithinConstraints;
+          }
+        }
+      }
+    }
+
+    // si hemos especificado un trackIndex...
+    if (this.selectedVideoTrackIndex != -1) {
+      Log.d("[TrackSelector]", "selectedVideoTrackIndex=" + this.selectedVideoTrackIndex + "!!!!! yeah");
+      selectedTrackIndex = this.selectedVideoTrackIndex; // este hay que cambiarlo por selectedTrackIndex
+    }
+    // si hemos especificado un groupIndex...
+    if (this.selectedVideoGroupIndex != -1) {
+      try {
+        selectedGroup = groups.get(this.selectedVideoGroupIndex);
+      } catch (Exception e) {
+        Log.d("[TrackSelector]", "El selectedVideoGroupIndex excede los limites del array. Seleccionando indice de grupo=0...");
+        selectedGroup = groups.get(0);
+      }
+    }
+    // devolvemos la custom track selection o la selección por defecto
+    Log.d("[TrackSelector]", "selectedGroup=" + selectedGroup + "!!!!! yeah");
+    Log.d("[TrackSelector]", "selectedTrackIndex=" + selectedTrackIndex + "!!!!! yeah");
+    return selectedGroup == null ? null
+        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+  }
+
+  /**
+   * Compares two pixel counts for order. A known pixel count is considered greater than
+   * {@link Format#NO_VALUE}.
+   *
+   * @param first The first pixel count.
+   * @param second The second pixel count.
+   * @return A negative integer if the first pixel count is less than the second. Zero if they are
+   *     equal. A positive integer if the first pixel count is greater than the second.
+   */
+  private static int comparePixelCounts(int first, int second) {
+    return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
+        : (second == Format.NO_VALUE ? 1 : (first - second));
+  }
+
+
+  // Audio track selection implementation.
+  /*
+  *  Para forzar la pista de audio elegimos un valor de "selectedGroup" y "selectedTrackIndex"
+  *
+  *  en la llamada a: new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+  *
+  * */
+  protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
+      String preferredAudioLanguage) {
+    TrackGroup selectedGroup = null;
+    int selectedTrackIndex = 0;
+    int selectedTrackScore = 0;
+    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+      TrackGroup trackGroup = groups.get(groupIndex);
+      int[] trackFormatSupport = formatSupport[groupIndex];
+      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+        if (isSupported(trackFormatSupport[trackIndex])) {
+          Format format = trackGroup.getFormat(trackIndex);
+          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
+          int trackScore;
+          if (formatHasLanguage(format, preferredAudioLanguage)) {
+            if (isDefault) {
+              trackScore = 4;
+            } else {
+              trackScore = 3;
+            }
+          } else if (isDefault) {
+            trackScore = 2;
+          } else {
+            trackScore = 1;
+          }
+          if (trackScore > selectedTrackScore) {
+            selectedGroup = trackGroup;
+            selectedTrackIndex = trackIndex;
+            selectedTrackScore = trackScore;
+          }
+        }
+      }
+    }
+    // si hemos especificado un trackIndex...
+    if (this.selectedAudioTrackIndex != -1) {
+      selectedTrackIndex = this.selectedAudioTrackIndex; // este hay que cambiarlo por selectedTrackIndex
+    }
+    // si hemos especificado un groupIndex...
+    if (this.selectedAudioGroupIndex != -1) {
+      try {
+        selectedGroup = groups.get(this.selectedAudioGroupIndex);
+      } catch (Exception e) {
+        Log.d("[TrackSelector]", "El selectedAudioGroupIndex excede los limites del array. Seleccionando indice de grupo=0...");
+        selectedGroup = groups.get(0);
+      }
+    }
+    // devolvemos la custom track selection o la selección por defecto
+    return selectedGroup == null ? null
+        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+  }
+
+  // Text track selection implementation.
+
+  protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatSupport,
+      String preferredTextLanguage, String preferredAudioLanguage) {
+    TrackGroup selectedGroup = null;
+    int selectedTrackIndex = 0;
+    int selectedTrackScore = 0;
+    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+      TrackGroup trackGroup = groups.get(groupIndex);
+      int[] trackFormatSupport = formatSupport[groupIndex];
+      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+        if (isSupported(trackFormatSupport[trackIndex])) {
+          Format format = trackGroup.getFormat(trackIndex);
+          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
+          boolean isForced = (format.selectionFlags & Format.SELECTION_FLAG_FORCED) != 0;
+          int trackScore;
+          if (formatHasLanguage(format, preferredTextLanguage)) {
+            if (isDefault) {
+              trackScore = 6;
+            } else if (!isForced) {
+              // Prefer non-forced to forced if a preferred text language has been specified. Where
+              // both are provided the non-forced track will usually contain the forced subtitles as
+              // a subset.
+              trackScore = 5;
+            } else {
+              trackScore = 4;
+            }
+          } else if (isDefault) {
+            trackScore = 3;
+          } else if (isForced) {
+            if (formatHasLanguage(format, preferredAudioLanguage)) {
+              trackScore = 2;
+            } else {
+              trackScore = 1;
+            }
+          } else {
+            trackScore = 0;
+          }
+          if (trackScore > selectedTrackScore) {
+            selectedGroup = trackGroup;
+            selectedTrackIndex = trackIndex;
+            selectedTrackScore = trackScore;
+          }
+        }
+      }
+    }
+    Log.d("[TrackSelection]","DefaultFixedTrackSelector, selectedVideoTrackIndex=" + selectedTrackIndex);
+    return selectedGroup == null ? null
+        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+  }
+
+  // General track selection methods.
+
+  protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
+      int[][] formatSupport) {
+    TrackGroup selectedGroup = null;
+    int selectedTrackIndex = 0;
+    int selectedTrackScore = 0;
+    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+      TrackGroup trackGroup = groups.get(groupIndex);
+      int[] trackFormatSupport = formatSupport[groupIndex];
+      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+        if (isSupported(trackFormatSupport[trackIndex])) {
+          Format format = trackGroup.getFormat(trackIndex);
+          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
+          int trackScore = isDefault ? 2 : 1;
+          if (trackScore > selectedTrackScore) {
+            selectedGroup = trackGroup;
+            selectedTrackIndex = trackIndex;
+            selectedTrackScore = trackScore;
+          }
+        }
+      }
+    }
+    return selectedGroup == null ? null
+        : new FixedTrackSelection(selectedGroup, selectedVideoTrackIndex);
+  }
+
+  private static boolean isSupported(int formatSupport) {
+    return (formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK)
+        == RendererCapabilities.FORMAT_HANDLED;
+  }
+
+  private static boolean formatHasLanguage(Format format, String language) {
+    return language != null && language.equals(Util.normalizeLanguageCode(format.language));
+  }
+
+  // Viewport size util methods.
+
+  private static List<Integer> getViewportFilteredTrackIndices(TrackGroup group, int viewportWidth,
+      int viewportHeight, boolean orientationMayChange) {
+    // Initially include all indices.
+    ArrayList<Integer> selectedTrackIndices = new ArrayList<>(group.length);
+    for (int i = 0; i < group.length; i++) {
+      selectedTrackIndices.add(i);
+    }
+
+    if (viewportWidth == Integer.MAX_VALUE || viewportHeight == Integer.MAX_VALUE) {
+      // Viewport dimensions not set. Return the full set of indices.
+      return selectedTrackIndices;
+    }
+
+    int maxVideoPixelsToRetain = Integer.MAX_VALUE;
+    for (int i = 0; i < group.length; i++) {
+      Format format = group.getFormat(i);
+      // Keep track of the number of pixels of the selected format whose resolution is the
+      // smallest to exceed the maximum size at which it can be displayed within the viewport.
+      // We'll discard formats of higher resolution.
+      if (format.width > 0 && format.height > 0) {
+        Point maxVideoSizeInViewport = getMaxVideoSizeInViewport(orientationMayChange,
+            viewportWidth, viewportHeight, format.width, format.height);
+        int videoPixels = format.width * format.height;
+        if (format.width >= (int) (maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN)
+            && format.height >= (int) (maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN)
+            && videoPixels < maxVideoPixelsToRetain) {
+          maxVideoPixelsToRetain = videoPixels;
+        }
+      }
+    }
+
+    // Filter out formats that exceed maxVideoPixelsToRetain. These formats have an unnecessarily
+    // high resolution given the size at which the video will be displayed within the viewport. Also
+    // filter out formats with unknown dimensions, since we have some whose dimensions are known.
+    if (maxVideoPixelsToRetain != Integer.MAX_VALUE) {
+      for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
+        Format format = group.getFormat(selectedTrackIndices.get(i));
+        int pixelCount = format.getPixelCount();
+        if (pixelCount == Format.NO_VALUE || pixelCount > maxVideoPixelsToRetain) {
+          selectedTrackIndices.remove(i);
+        }
+      }
+    }
+
+    return selectedTrackIndices;
+  }
+
+  /**
+   * Given viewport dimensions and video dimensions, computes the maximum size of the video as it
+   * will be rendered to fit inside of the viewport.
+   */
+  private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int viewportWidth,
+      int viewportHeight, int videoWidth, int videoHeight) {
+    if (orientationMayChange && (videoWidth > videoHeight) != (viewportWidth > viewportHeight)) {
+      // Rotation is allowed, and the video will be larger in the rotated viewport.
+      int tempViewportWidth = viewportWidth;
+      viewportWidth = viewportHeight;
+      viewportHeight = tempViewportWidth;
+    }
+
+    if (videoWidth * viewportHeight >= videoHeight * viewportWidth) {
+      // Horizontal letter-boxing along top and bottom.
+      return new Point(viewportWidth, Util.ceilDivide(viewportWidth * videoHeight, videoWidth));
+    } else {
+      // Vertical letter-boxing along edges.
+      return new Point(Util.ceilDivide(viewportHeight * videoWidth, videoHeight), viewportHeight);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/NonAdaptiveVideoTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/NonAdaptiveVideoTrackSelection.java
new file mode 100644
index 0000000000..16a9584fea
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/NonAdaptiveVideoTrackSelection.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import android.os.SystemClock;
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+
+import java.util.List;
+
+/**
+ * A bandwidth based adaptive {@link TrackSelection} for video, whose selected track is updated to
+ * be the one of highest quality given the current network conditions and the state of the buffer.
+ */
+public class NonAdaptiveVideoTrackSelection extends BaseTrackSelection {
+
+  /**
+   * Factory for {@link NonAdaptiveVideoTrackSelection} instances.
+   */
+  public static final class Factory implements TrackSelection.Factory {
+
+    private final BandwidthMeter bandwidthMeter;
+    private final int VSTIndex;
+    private final int VSGIndex;
+    private final int ASTIndex;
+    private final int ASGIndex;
+    private final int maxInitialBitrate;
+    private final int minDurationForQualityIncreaseMs;
+    private final int maxDurationForQualityDecreaseMs;
+    private final int minDurationToRetainAfterDiscardMs;
+    private final float bandwidthFraction;
+
+    /**
+     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+     */
+    public Factory(BandwidthMeter bandwidthMeter, int VSTIndex, int VSGIndex, int ASTIndex, int ASGIndex) {
+      this (bandwidthMeter, VSTIndex, VSGIndex, ASTIndex, ASGIndex, DEFAULT_MAX_INITIAL_BITRATE,
+          DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+          DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+          DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+    }
+
+    /**
+     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+     * @param VSTIndex The Video Selected Track Index.
+     * @param VSGIndex The Video Selected Group Index.
+     * @param ASTIndex The Audio Selected Track Index.
+     * @param ASGIndex The Audio Selected Group Index.
+     * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed
+ *     when a bandwidth estimate is unavailable.
+     * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for
+*     the selected track to switch to one of higher quality.
+     * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for
+*     the selected track to switch to one of lower quality.
+     * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
+*     quality, the selection may indicate that media already buffered at the lower quality can
+*     be discarded to speed up the switch. This is the minimum duration of media that must be
+*     retained at the lower quality.
+     * @param bandwidthFraction The fraction of the available bandwidth that the selection should
+*     consider available for use. Setting to a value less than 1 is recommended to account
+*     for inaccuracies in the bandwidth estimator.
+     */
+    public Factory(BandwidthMeter bandwidthMeter, int VSTIndex, int VSGIndex, int ASTIndex, int ASGIndex, int maxInitialBitrate,
+                   int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
+                   int minDurationToRetainAfterDiscardMs, float bandwidthFraction) {
+      this.bandwidthMeter = bandwidthMeter;
+      this.VSTIndex = VSTIndex;
+      this.VSGIndex = VSGIndex;
+      this.ASTIndex = ASTIndex;
+      this.ASGIndex = ASGIndex;
+      this.maxInitialBitrate = maxInitialBitrate;
+      this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;
+      this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs;
+      this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs;
+      this.bandwidthFraction = bandwidthFraction;
+    }
+
+    @Override
+    public NonAdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+      return new NonAdaptiveVideoTrackSelection(group, tracks, bandwidthMeter, VSTIndex, VSGIndex, ASTIndex, ASGIndex, maxInitialBitrate,
+          minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
+          minDurationToRetainAfterDiscardMs, bandwidthFraction);
+    }
+
+  }
+
+  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
+  public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
+  public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
+  public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
+  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
+
+  private final BandwidthMeter bandwidthMeter;
+  private final int maxInitialBitrate;
+  private final long minDurationForQualityIncreaseUs;
+  private final long maxDurationForQualityDecreaseUs;
+  private final long minDurationToRetainAfterDiscardUs;
+  private final float bandwidthFraction;
+
+  private int selectedIndex;
+  private int selectedVideoTrackIndex;
+  private int selectedVideoGroupIndex;
+  private int selectedAudioTrackIndex;
+  private int selectedAudioGroupIndex;
+  private int reason;
+
+  /**
+   * @param group The {@link TrackGroup}. Must not be null.
+   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+   *     null or empty. May be in any order.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+   */
+  public NonAdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
+                                        BandwidthMeter bandwidthMeter, int VSTIndex, int VSGIndex, int ASTIndex, int ASGIndex) {
+    this (group, tracks, bandwidthMeter, VSTIndex, VSGIndex, ASTIndex, ASGIndex, DEFAULT_MAX_INITIAL_BITRATE,
+        DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+        DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+        DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+  }
+
+  /**
+   * @param group The {@link TrackGroup}. Must not be null.
+   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+   *     null or empty. May be in any order.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+   * @param VSTIndex Selected Video Track Index
+   * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed when a
+   *     bandwidth estimate is unavailable.
+   * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the
+   *     selected track to switch to one of higher quality.
+   * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
+   *     selected track to switch to one of lower quality.
+   * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
+   *     quality, the selection may indicate that media already buffered at the lower quality can
+   *     be discarded to speed up the switch. This is the minimum duration of media that must be
+   *     retained at the lower quality.
+   * @param bandwidthFraction The fraction of the available bandwidth that the selection should
+   *     consider available for use. Setting to a value less than 1 is recommended to account
+   *     for inaccuracies in the bandwidth estimator.
+   */
+  public NonAdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter, int VSTIndex,
+                                        int VSGIndex, int ASTIndex, int ASGIndex,
+                                        int maxInitialBitrate, long minDurationForQualityIncreaseMs,
+                                        long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
+                                        float bandwidthFraction) {
+    super(group, tracks);
+    this.bandwidthMeter = bandwidthMeter;
+    this.maxInitialBitrate = maxInitialBitrate;
+    this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;
+    this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;
+    this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;
+    this.bandwidthFraction = bandwidthFraction;
+    selectedIndex = VSTIndex;
+    selectedVideoTrackIndex = VSTIndex;
+    selectedVideoGroupIndex = VSGIndex;
+    selectedAudioTrackIndex = ASTIndex;
+    selectedAudioGroupIndex = ASGIndex;
+    reason = C.SELECTION_REASON_INITIAL;
+  }
+
+  @Override
+  public void updateSelectedTrack(long bufferedDurationUs) {
+    /*
+     * He modificado la funcion para que vuelva a elegir el mismo Index
+     *
+     * */
+    long nowMs = SystemClock.elapsedRealtime();
+    // Get the current and ideal selections.
+    int currentSelectedIndex = selectedIndex;
+    Format currentFormat = getSelectedFormat();
+    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
+    Format idealFormat = getFormat(idealSelectedIndex);
+    // Assume we can switch to the ideal selection.
+    selectedIndex = currentSelectedIndex;
+    // Revert back to the current selection if conditions are not suitable for switching.
+    if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
+      if (idealFormat.bitrate > currentFormat.bitrate
+          && bufferedDurationUs < minDurationForQualityIncreaseUs) {
+        // The ideal track is a higher quality, but we have insufficient buffer to safely switch
+        // up. Defer switching up for now.
+        selectedIndex = currentSelectedIndex;
+      } else if (idealFormat.bitrate < currentFormat.bitrate
+          && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
+        // The ideal track is a lower quality, but we have sufficient buffer to defer switching
+        // down for now.
+        selectedIndex = currentSelectedIndex;
+      }
+    }
+    // If we adapted, update the trigger.
+    if (selectedIndex != currentSelectedIndex) {
+      reason = C.SELECTION_REASON_ADAPTIVE;
+    }
+  }
+
+  @Override
+  public int getSelectedIndex() {
+    return selectedIndex;
+  }
+
+  @Override
+  public int getSelectionReason() {
+    return reason;
+  }
+
+  @Override
+  public Object getSelectionData() {
+    return null;
+  }
+
+  @Override
+  public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
+    if (queue.isEmpty()) {
+      return 0;
+    }
+    int queueSize = queue.size();
+    long bufferedDurationUs = queue.get(queueSize - 1).endTimeUs - playbackPositionUs;
+    if (bufferedDurationUs < minDurationToRetainAfterDiscardUs) {
+      return queueSize;
+    }
+    int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
+    Format idealFormat = getFormat(idealSelectedIndex);
+    // Discard from the first SD chunk beyond minDurationToRetainAfterDiscardUs whose resolution and
+    // bitrate are both lower than the ideal track.
+    for (int i = 0; i < queueSize; i++) {
+      MediaChunk chunk = queue.get(i);
+      long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
+      if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
+          && chunk.trackFormat.bitrate < idealFormat.bitrate
+          && chunk.trackFormat.height < idealFormat.height
+          && chunk.trackFormat.height < 720 && chunk.trackFormat.width < 1280) {
+        return i;
+      }
+    }
+    return queueSize;
+  }
+
+  /**
+   * Computes the ideal selected index ignoring buffer health.
+   *
+   * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}, or
+   *     {@link Long#MIN_VALUE} to ignore blacklisting.
+   */
+  private int determineIdealSelectedIndex(long nowMs) {
+    long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
+    long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE
+        ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
+    int lowestBitrateNonBlacklistedIndex = 0;
+    for (int i = 0; i < length; i++) {
+      if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
+        Format format = getFormat(i);
+        if (format.bitrate <= effectiveBitrate) {
+          return i;
+        } else {
+          lowestBitrateNonBlacklistedIndex = i;
+        }
+      }
+    }
+    return lowestBitrateNonBlacklistedIndex;
+  }
+
+}
