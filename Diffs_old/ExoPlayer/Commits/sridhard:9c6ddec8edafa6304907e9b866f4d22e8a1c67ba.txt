diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 43c4809480..94b349b217 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -16,9 +16,8 @@ all of the information requested in the issue template.
 ## Pull requests ##
 
 We will also consider high quality pull requests. These should normally merge
-into the `dev-vX` branch with the highest major version number. Bug fixes may
-be suitable for merging into older `dev-vX` branches. Before a pull request can
-be accepted you must submit a Contributor License Agreement, as described below.
+into the `dev-v2` branch. Before a pull request can be accepted you must submit
+a Contributor License Agreement, as described below.
 
 [dev]: https://github.com/google/ExoPlayer/tree/dev
 
diff --git a/README.md b/README.md
index 13dfaddab3..37967dd527 100644
--- a/README.md
+++ b/README.md
@@ -28,13 +28,13 @@ repository and depend on the modules locally.
 ### From JCenter ###
 
 The easiest way to get started using ExoPlayer is to add it as a gradle
-dependency. You need to make sure you have the JCenter and Google repositories
+dependency. You need to make sure you have the Google and JCenter repositories
 included in the `build.gradle` file in the root of your project:
 
 ```gradle
 repositories {
-    jcenter()
     google()
+    jcenter()
 }
 ```
 
@@ -45,10 +45,20 @@ following will add a dependency to the full library:
 implementation 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
-where `2.X.X` is your preferred version. Alternatively, you can depend on only
-the library modules that you actually need. For example the following will add
-dependencies on the Core, DASH and UI library modules, as might be required for
-an app that plays DASH content:
+where `2.X.X` is your preferred version. If not enabled already, you also need
+to turn on Java 8 support in all `build.gradle` files depending on ExoPlayer, by
+adding the following to the `android` section:
+
+```gradle
+compileOptions {
+    targetCompatibility JavaVersion.VERSION_1_8
+}
+```
+
+As an alternative to the full library, you can depend on only the library
+modules that you actually need. For example the following will add dependencies
+on the Core, DASH and UI library modules, as might be required for an app that
+plays DASH content:
 
 ```gradle
 implementation 'com.google.android.exoplayer:exoplayer-core:2.X.X'
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index dd7c9c95a9..6b3fbc4f27 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,84 @@
 # Release notes #
 
+### 2.9.2 ###
+
+* HLS:
+  * Fix issue causing unnecessary media playlist requests when playing live
+    streams ([#5059](https://github.com/google/ExoPlayer/issues/5059)).
+  * Fix decoder re-instantiation issue for packed audio streams
+    ([#5063](https://github.com/google/ExoPlayer/issues/5063)).
+* MP4: Support Opus and FLAC in the MP4 container, and in DASH
+  ([#4883](https://github.com/google/ExoPlayer/issues/4883)).
+* DASH: Fix detecting the end of live events
+  ([#4780](https://github.com/google/ExoPlayer/issues/4780)).
+* Spherical video: Fall back to `TYPE_ROTATION_VECTOR` if
+  `TYPE_GAME_ROTATION_VECTOR` is unavailable
+  ([#5119](https://github.com/google/ExoPlayer/issues/5119)).
+* Support seeking for a wider range of MPEG-TS streams
+  ([#5097](https://github.com/google/ExoPlayer/issues/5097)).
+* Include channel count in audio capabilities check
+  ([#4690](https://github.com/google/ExoPlayer/issues/4690)).
+* Fix issue with applying the `show_buffering` attribute in `PlayerView`
+  ([#5139](https://github.com/google/ExoPlayer/issues/5139)).
+* Fix issue where null `Metadata` was output when it failed to decode
+  ([#5149](https://github.com/google/ExoPlayer/issues/5149)).
+* Fix playback of some invalid but playable MP4 streams by replacing assertions
+  with logged warnings in sample table parsing code
+  ([#5162](https://github.com/google/ExoPlayer/issues/5162)).
+* Fix UUID passed to `MediaCrypto` when using `C.CLEARKEY_UUID` before API 27.
+
+### 2.9.1 ###
+
+* Add convenience methods `Player.next`, `Player.previous`, `Player.hasNext`
+  and `Player.hasPrevious`
+  ([#4863](https://github.com/google/ExoPlayer/issues/4863)).
+* Improve initial bandwidth meter estimates using the current country and
+  network type.
+* IMA extension:
+  * For preroll to live stream transitions, project forward the loading position
+    to avoid being behind the live window.
+  * Let apps specify whether to focus the skip button on ATV
+    ([#5019](https://github.com/google/ExoPlayer/issues/5019)).
+* MP3:
+  * Support seeking based on MLLT metadata
+    ([#3241](https://github.com/google/ExoPlayer/issues/3241)).
+  * Fix handling of streams with appended data
+    ([#4954](https://github.com/google/ExoPlayer/issues/4954)).
+* DASH: Parse ProgramInformation element if present in the manifest.
+* HLS:
+  * Add constructor to `DefaultHlsExtractorFactory` for adding TS payload
+    reader factory flags.
+  * Fix bug in segment sniffing
+    ([#5039](https://github.com/google/ExoPlayer/issues/5039)).
+  ([#4861](https://github.com/google/ExoPlayer/issues/4861)).
+* SubRip: Add support for alignment tags, and remove tags from the displayed
+  captions ([#4306](https://github.com/google/ExoPlayer/issues/4306)).
+* Fix issue with blind seeking to windows with non-zero offset in a
+  `ConcatenatingMediaSource`
+  ([#4873](https://github.com/google/ExoPlayer/issues/4873)).
+* Fix logic for enabling next and previous actions in `TimelineQueueNavigator`
+  ([#5065](https://github.com/google/ExoPlayer/issues/5065)).
+* Fix issue where audio focus handling could not be disabled after enabling it
+  ([#5055](https://github.com/google/ExoPlayer/issues/5055)).
+* Fix issue where subtitles were positioned incorrectly if `SubtitleView` had a
+  non-zero position offset to its parent
+  ([#4788](https://github.com/google/ExoPlayer/issues/4788)).
+* Fix issue where the buffered position was not updated correctly when
+  transitioning between periods
+  ([#4899](https://github.com/google/ExoPlayer/issues/4899)).
+* Fix issue where a `NullPointerException` is thrown when removing an unprepared
+  media source from a `ConcatenatingMediaSource` with the `useLazyPreparation`
+  option enabled ([#4986](https://github.com/google/ExoPlayer/issues/4986)).
+* Work around an issue where a non-empty end-of-stream audio buffer would be
+  output with timestamp zero, causing the player position to jump backwards
+  ([#5045](https://github.com/google/ExoPlayer/issues/5045)).
+* Suppress a spurious assertion failure on some Samsung devices
+  ([#4532](https://github.com/google/ExoPlayer/issues/4532)).
+* Suppress spurious "references unknown class member" shrinking warning
+  ([#4890](https://github.com/google/ExoPlayer/issues/4890)).
+* Swap recommended order for google() and jcenter() in gradle config
+  ([#4997](https://github.com/google/ExoPlayer/issues/4997)).
+
 ### 2.9.0 ###
 
 * Turn on Java 8 compiler support for the ExoPlayer library. Apps may need to
diff --git a/build.gradle b/build.gradle
index a013f4fb84..96eade1aa3 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 buildscript {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:3.1.4'
@@ -32,8 +32,8 @@ buildscript {
 }
 allprojects {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     project.ext {
         exoplayerPublishEnabled = true
diff --git a/constants.gradle b/constants.gradle
index 6db6d6310b..cac4f6d78b 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.9.0'
-    releaseVersionCode = 2009000
+    releaseVersion = '2.9.2'
+    releaseVersionCode = 2009002
     // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
index 26ab5eb0dd..77f6a6fc1a 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
@@ -81,8 +81,6 @@ public String toString() {
         + "hls/TearsOfSteel.m3u8", "Tears of Steel (HLS)", MIME_TYPE_HLS));
     samples.add(new Sample("https://html5demos.com/assets/dizzy.mp4", "Dizzy (MP4)",
         MIME_TYPE_VIDEO_MP4));
-
-
     SAMPLES = Collections.unmodifiableList(samples);
 
   }
diff --git a/demos/ima/src/main/res/values/strings.xml b/demos/ima/src/main/res/values/strings.xml
index 67a7f06f8b..2eb5700bf0 100644
--- a/demos/ima/src/main/res/values/strings.xml
+++ b/demos/ima/src/main/res/values/strings.xml
@@ -17,7 +17,7 @@
 
   <string name="application_name">Exo IMA Demo</string>
 
-  <string name="content_url"><![CDATA[http://rmcdn.2mdn.net/MotifFiles/html/1248596/android_1330378998288.mp4]]></string>
+  <string name="content_url"><![CDATA[https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv]]></string>
 
   <string name="ad_tag_url"><![CDATA[https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&correlator=]]></string>
 
diff --git a/demos/main/src/main/res/drawable-xxhdpi/ic_download.png b/demos/main/src/main/res/drawable-xxhdpi/ic_download.png
index f02715177a..4e04a30198 100644
Binary files a/demos/main/src/main/res/drawable-xxhdpi/ic_download.png and b/demos/main/src/main/res/drawable-xxhdpi/ic_download.png differ
diff --git a/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png b/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png
index 6602791545..f9bfb5edba 100644
Binary files a/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png and b/demos/main/src/main/res/drawable-xxxhdpi/ic_download.png differ
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index bee73cac12..30fe10085f 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -31,7 +31,7 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.0.1'
+    api 'com.google.android.gms:play-services-cast-framework:16.0.3'
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
     testImplementation project(modulePrefix + 'testutils')
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 97b05e3f0a..6cf6309796 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -18,6 +18,7 @@
 import android.os.Looper;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -31,7 +32,6 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
-import com.google.android.exoplayer2.util.Util;
 import com.google.android.gms.cast.CastStatusCodes;
 import com.google.android.gms.cast.MediaInfo;
 import com.google.android.gms.cast.MediaQueueItem;
@@ -62,7 +62,7 @@
  *
  * <p>Methods should be called on the application's main thread.</p>
  */
-public final class CastPlayer implements Player {
+public final class CastPlayer extends BasePlayer {
 
   /**
    * Listener of changes in the cast session availability.
@@ -95,7 +95,6 @@
   private final CastContext castContext;
   // TODO: Allow custom implementations of CastTimelineTracker.
   private final CastTimelineTracker timelineTracker;
-  private final Timeline.Window window;
   private final Timeline.Period period;
 
   private RemoteMediaClient remoteMediaClient;
@@ -128,7 +127,6 @@
   public CastPlayer(CastContext castContext) {
     this.castContext = castContext;
     timelineTracker = new CastTimelineTracker();
-    window = new Timeline.Window();
     period = new Timeline.Period();
     statusListener = new StatusListener();
     seekResultCallback = new SeekResultCallback();
@@ -341,21 +339,6 @@ public boolean getPlayWhenReady() {
     return playWhenReady;
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    seekTo(0);
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    seekTo(windowIndex, 0);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    seekTo(getCurrentWindowIndex(), positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     MediaStatus mediaStatus = getMediaStatus();
@@ -392,11 +375,6 @@ public PlaybackParameters getPlaybackParameters() {
     return PlaybackParameters.DEFAULT;
   }
 
-  @Override
-  public void stop() {
-    stop(/* reset= */ false);
-  }
-
   @Override
   public void stop(boolean reset) {
     playbackState = STATE_IDLE;
@@ -486,32 +464,11 @@ public int getCurrentWindowIndex() {
     return pendingSeekWindowIndex != C.INDEX_UNSET ? pendingSeekWindowIndex : currentWindowIndex;
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    return currentTimeline.isEmpty() ? C.INDEX_UNSET
-        : currentTimeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, false);
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    return currentTimeline.isEmpty() ? C.INDEX_UNSET
-        : currentTimeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, false);
-  }
-
-  @Override
-  public @Nullable Object getCurrentTag() {
-    int windowIndex = getCurrentWindowIndex();
-    return windowIndex >= currentTimeline.getWindowCount()
-        ? null
-        : currentTimeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
-  }
-
   // TODO: Fill the cast timeline information with ProgressListener's duration updates.
   // See [Internal: b/65152553].
   @Override
   public long getDuration() {
-    return currentTimeline.isEmpty() ? C.TIME_UNSET
-        : currentTimeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+    return getContentDuration();
   }
 
   @Override
@@ -528,15 +485,6 @@ public long getBufferedPosition() {
     return getCurrentPosition();
   }
 
-  @Override
-  public int getBufferedPercentage() {
-    long position = getBufferedPosition();
-    long duration = getDuration();
-    return position == C.TIME_UNSET || duration == C.TIME_UNSET
-        ? 0
-        : duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100);
-  }
-
   @Override
   public long getTotalBufferedDuration() {
     long bufferedPosition = getBufferedPosition();
@@ -546,18 +494,6 @@ public long getTotalBufferedDuration() {
         : bufferedPosition - currentPosition;
   }
 
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    return !currentTimeline.isEmpty()
-        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    return !currentTimeline.isEmpty()
-        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
-  }
-
   @Override
   public boolean isPlayingAd() {
     return false;
@@ -573,11 +509,6 @@ public int getCurrentAdIndexInAdGroup() {
     return C.INDEX_UNSET;
   }
 
-  @Override
-  public long getContentDuration() {
-    return getDuration();
-  }
-
   @Override
   public boolean isLoading() {
     return false;
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 9525983491..ab10f41d8f 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
@@ -326,8 +327,12 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     // Check for a valid response code.
     int responseCode = responseInfo.getHttpStatusCode();
     if (responseCode < 200 || responseCode > 299) {
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode,
-          responseInfo.getAllHeaders(), currentDataSpec);
+      InvalidResponseCodeException exception =
+          new InvalidResponseCodeException(
+              responseCode,
+              responseInfo.getHttpStatusText(),
+              responseInfo.getAllHeaders(),
+              currentDataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -451,6 +456,18 @@ public synchronized void close() {
     }
   }
 
+  /** Returns current {@link UrlRequest}. May be null if the data source is not opened. */
+  @Nullable
+  protected UrlRequest getCurrentUrlRequest() {
+    return currentUrlRequest;
+  }
+
+  /** Returns current {@link UrlResponseInfo}. May be null if the data source is not opened. */
+  @Nullable
+  protected UrlResponseInfo getCurrentUrlResponseInfo() {
+    return responseInfo;
+  }
+
   // Internal methods.
 
   private UrlRequest.Builder buildRequestBuilder(DataSpec dataSpec) throws IOException {
@@ -611,7 +628,8 @@ public synchronized void onRedirectReceived(
         // The industry standard is to disregard POST redirects when the status code is 307 or 308.
         if (responseCode == 307 || responseCode == 308) {
           exception =
-              new InvalidResponseCodeException(responseCode, info.getAllHeaders(), currentDataSpec);
+              new InvalidResponseCodeException(
+                  responseCode, info.getHttpStatusText(), info.getAllHeaders(), currentDataSpec);
           operation.open();
           return;
         }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
index dd39ea2822..829b53f863 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetEngineWrapper.java
@@ -19,6 +19,7 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Field;
@@ -43,6 +44,7 @@
    * Source of {@link CronetEngine}. One of {@link #SOURCE_NATIVE}, {@link #SOURCE_GMS}, {@link
    * #SOURCE_UNKNOWN}, {@link #SOURCE_USER_PROVIDED} or {@link #SOURCE_UNAVAILABLE}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({SOURCE_NATIVE, SOURCE_GMS, SOURCE_UNKNOWN, SOURCE_USER_PROVIDED, SOURCE_UNAVAILABLE})
   public @interface CronetEngineSource {}
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index d5a37db013..52dacf8166 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -46,7 +46,7 @@ HOST_PLATFORM="linux-x86_64"
   be supported. See the [Supported formats][] page for more details of the
   available flags.
 
-For example, to fetch and build for armeabi-v7a,
+For example, to fetch and build FFmpeg release 4.0 for armeabi-v7a,
   arm64-v8a and x86 on Linux x86_64:
 
 ```
@@ -71,7 +71,7 @@ COMMON_OPTIONS="\
     " && \
 cd "${FFMPEG_EXT_PATH}/jni" && \
 (git -C ffmpeg pull || git clone git://source.ffmpeg.org/ffmpeg ffmpeg) && \
-cd ffmpeg && \
+cd ffmpeg && git checkout release/4.0 && \
 ./configure \
     --libdir=android-libs/armeabi-v7a \
     --arch=arm \
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index 13e3964c71..f0b30baa8a 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -145,12 +145,13 @@ public Format getOutputFormat() {
   }
 
   private boolean isOutputSupported(Format inputFormat) {
-    return shouldUseFloatOutput(inputFormat) || supportsOutputEncoding(C.ENCODING_PCM_16BIT);
+    return shouldUseFloatOutput(inputFormat)
+        || supportsOutput(inputFormat.channelCount, C.ENCODING_PCM_16BIT);
   }
 
   private boolean shouldUseFloatOutput(Format inputFormat) {
     Assertions.checkNotNull(inputFormat.sampleMimeType);
-    if (!enableFloatOutput || !supportsOutputEncoding(C.ENCODING_PCM_FLOAT)) {
+    if (!enableFloatOutput || !supportsOutput(inputFormat.channelCount, C.ENCODING_PCM_FLOAT)) {
       return false;
     }
     switch (inputFormat.sampleMimeType) {
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index fda5f0085d..54701eea1d 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -28,18 +28,19 @@ EXOPLAYER_ROOT="$(pwd)"
 FLAC_EXT_PATH="${EXOPLAYER_ROOT}/extensions/flac/src/main"
 ```
 
-* Download the [Android NDK][] and set its location in an environment variable:
+* Download the [Android NDK][] (version <= 17c) and set its location in an
+  environment variable:
 
 ```
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Download and extract flac-1.3.1 as "${FLAC_EXT_PATH}/jni/flac" folder:
+* Download and extract flac-1.3.2 as "${FLAC_EXT_PATH}/jni/flac" folder:
 
 ```
 cd "${FLAC_EXT_PATH}/jni" && \
-curl https://ftp.osuosl.org/pub/xiph/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
-mv flac-1.3.1 flac
+curl https://ftp.osuosl.org/pub/xiph/releases/flac/flac-1.3.2.tar.xz | tar xJ && \
+mv flac-1.3.2 flac
 ```
 
 * Build the JNI native libraries from the command line:
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index a1fbcc69d6..8f5dcef16b 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -37,6 +37,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -54,6 +55,7 @@
    * Flags controlling the behavior of the extractor. Possible flag value is {@link
    * #FLAG_DISABLE_ID3_METADATA}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index fa66abbdc6..424fcbb285 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -53,7 +53,7 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!FlacLibrary.isAvailable()
         || !MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+    } else if (!supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
diff --git a/extensions/flac/src/main/jni/Android.mk b/extensions/flac/src/main/jni/Android.mk
index ff54c1b3c0..69520a16e5 100644
--- a/extensions/flac/src/main/jni/Android.mk
+++ b/extensions/flac/src/main/jni/Android.mk
@@ -30,9 +30,9 @@ LOCAL_C_INCLUDES := \
     $(LOCAL_PATH)/flac/src/libFLAC/include
 LOCAL_SRC_FILES := $(FLAC_SOURCES)
 
-LOCAL_CFLAGS += '-DVERSION="1.3.1"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY -DFLAC__NO_ASM
+LOCAL_CFLAGS += '-DPACKAGE_VERSION="1.3.2"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY
 LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC -DHAVE_SYS_PARAM_H
-LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions
+LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions -DFLAC__NO_ASM '-DFLAC__HAS_OGG=0'
 
 LOCAL_LDLIBS := -llog -lz -lm
 include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/flac/src/main/jni/Application.mk b/extensions/flac/src/main/jni/Application.mk
index 59bf5f8f87..eba20352f4 100644
--- a/extensions/flac/src/main/jni/Application.mk
+++ b/extensions/flac/src/main/jni/Application.mk
@@ -17,4 +17,4 @@
 APP_OPTIM := release
 APP_STL := gnustl_static
 APP_CPPFLAGS := -frtti
-APP_PLATFORM := android-9
+APP_PLATFORM := android-14
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index 7fc7935cac..22196ff3ab 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -31,13 +31,13 @@ android {
 }
 
 dependencies {
-    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.9.4'
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.10.2'
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.google.android.gms:play-services-ads:15.0.1'
+    implementation 'com.google.android.gms:play-services-ads:17.1.1'
     // These dependencies are necessary to force the supportLibraryVersion of
     // com.android.support:support-v4 and com.android.support:customtabs to be
     // used. Else older versions are used, for example via:
-    // com.google.android.gms:play-services-ads:15.0.1
+    // com.google.android.gms:play-services-ads:17.1.1
     // |-- com.android.support:customtabs:26.1.0
     implementation 'com.android.support:support-v4:' + supportLibraryVersion
     implementation 'com.android.support:customtabs:' + supportLibraryVersion
diff --git a/extensions/ima/src/main/AndroidManifest.xml b/extensions/ima/src/main/AndroidManifest.xml
index 1bb79ff21d..226b15cb34 100644
--- a/extensions/ima/src/main/AndroidManifest.xml
+++ b/extensions/ima/src/main/AndroidManifest.xml
@@ -15,6 +15,10 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.ext.ima">
-  <meta-data android:name="com.google.android.gms.version"
-      android:value="@integer/google_play_services_version"/>
+  <application>
+    <meta-data android:name="com.google.android.gms.ads.AD_MANAGER_APP"
+        android:value="true"/>
+    <meta-data android:name="com.google.android.gms.version"
+        android:value="@integer/google_play_services_version"/>
+  </application>
 </manifest>
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 224f5aa6ee..6ca3bfd881 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -40,6 +40,7 @@
 import com.google.ads.interactivemedia.v3.api.CompanionAdSlot;
 import com.google.ads.interactivemedia.v3.api.ImaSdkFactory;
 import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
+import com.google.ads.interactivemedia.v3.api.UiElement;
 import com.google.ads.interactivemedia.v3.api.player.ContentProgressProvider;
 import com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer;
 import com.google.ads.interactivemedia.v3.api.player.VideoProgressUpdate;
@@ -60,14 +61,17 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /** Loads ads using the IMA SDK. All methods are called on the main thread. */
 public final class ImaAdsLoader
@@ -90,8 +94,11 @@
 
     private @Nullable ImaSdkSettings imaSdkSettings;
     private @Nullable AdEventListener adEventListener;
+    private @Nullable Set<UiElement> adUiElements;
     private int vastLoadTimeoutMs;
     private int mediaLoadTimeoutMs;
+    private int mediaBitrate;
+    private boolean focusSkipButtonWhenAvailable;
     private ImaFactory imaFactory;
 
     /**
@@ -103,6 +110,8 @@ public Builder(Context context) {
       this.context = Assertions.checkNotNull(context);
       vastLoadTimeoutMs = TIMEOUT_UNSET;
       mediaLoadTimeoutMs = TIMEOUT_UNSET;
+      mediaBitrate = BITRATE_UNSET;
+      focusSkipButtonWhenAvailable = true;
       imaFactory = new DefaultImaFactory();
     }
 
@@ -132,6 +141,18 @@ public Builder setAdEventListener(AdEventListener adEventListener) {
       return this;
     }
 
+    /**
+     * Sets the ad UI elements to be rendered by the IMA SDK.
+     *
+     * @param adUiElements The ad UI elements to be rendered by the IMA SDK.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setUiElements(Set)
+     */
+    public Builder setAdUiElements(Set<UiElement> adUiElements) {
+      this.adUiElements = new HashSet<>(Assertions.checkNotNull(adUiElements));
+      return this;
+    }
+
     /**
      * Sets the VAST load timeout, in milliseconds.
      *
@@ -140,7 +161,7 @@ public Builder setAdEventListener(AdEventListener adEventListener) {
      * @see AdsRequest#setVastLoadTimeout(float)
      */
     public Builder setVastLoadTimeoutMs(int vastLoadTimeoutMs) {
-      Assertions.checkArgument(vastLoadTimeoutMs >= 0);
+      Assertions.checkArgument(vastLoadTimeoutMs > 0);
       this.vastLoadTimeoutMs = vastLoadTimeoutMs;
       return this;
     }
@@ -153,11 +174,38 @@ public Builder setVastLoadTimeoutMs(int vastLoadTimeoutMs) {
      * @see AdsRenderingSettings#setLoadVideoTimeout(int)
      */
     public Builder setMediaLoadTimeoutMs(int mediaLoadTimeoutMs) {
-      Assertions.checkArgument(mediaLoadTimeoutMs >= 0);
+      Assertions.checkArgument(mediaLoadTimeoutMs > 0);
       this.mediaLoadTimeoutMs = mediaLoadTimeoutMs;
       return this;
     }
 
+    /**
+     * Sets the media maximum recommended bitrate for ads, in bps.
+     *
+     * @param bitrate The media maximum recommended bitrate for ads, in bps.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setBitrateKbps(int)
+     */
+    public Builder setMaxMediaBitrate(int bitrate) {
+      Assertions.checkArgument(bitrate > 0);
+      this.mediaBitrate = bitrate;
+      return this;
+    }
+
+    /**
+     * Sets whether to focus the skip button (when available) on Android TV devices. The default
+     * setting is {@code true}.
+     *
+     * @param focusSkipButtonWhenAvailable Whether to focus the skip button (when available) on
+     *     Android TV devices.
+     * @return This builder, for convenience.
+     * @see AdsRenderingSettings#setFocusSkipButtonWhenAvailable(boolean)
+     */
+    public Builder setFocusSkipButtonWhenAvailable(boolean focusSkipButtonWhenAvailable) {
+      this.focusSkipButtonWhenAvailable = focusSkipButtonWhenAvailable;
+      return this;
+    }
+
     // @VisibleForTesting
     /* package */ Builder setImaFactory(ImaFactory imaFactory) {
       this.imaFactory = Assertions.checkNotNull(imaFactory);
@@ -180,6 +228,9 @@ public ImaAdsLoader buildForAdTag(Uri adTagUri) {
           null,
           vastLoadTimeoutMs,
           mediaLoadTimeoutMs,
+          mediaBitrate,
+          focusSkipButtonWhenAvailable,
+          adUiElements,
           adEventListener,
           imaFactory);
     }
@@ -199,6 +250,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
           adsResponse,
           vastLoadTimeoutMs,
           mediaLoadTimeoutMs,
+          mediaBitrate,
+          focusSkipButtonWhenAvailable,
+          adUiElements,
           adEventListener,
           imaFactory);
     }
@@ -228,8 +282,10 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private static final long MAXIMUM_PRELOAD_DURATION_MS = 8000;
 
   private static final int TIMEOUT_UNSET = -1;
+  private static final int BITRATE_UNSET = -1;
 
   /** The state of ad playback. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({IMA_AD_STATE_NONE, IMA_AD_STATE_PLAYING, IMA_AD_STATE_PAUSED})
   private @interface ImaAdState {}
@@ -250,6 +306,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final @Nullable String adsResponse;
   private final int vastLoadTimeoutMs;
   private final int mediaLoadTimeoutMs;
+  private final boolean focusSkipButtonWhenAvailable;
+  private final int mediaBitrate;
+  private final @Nullable Set<UiElement> adUiElements;
   private final @Nullable AdEventListener adEventListener;
   private final ImaFactory imaFactory;
   private final Timeline.Period period;
@@ -336,6 +395,9 @@ public ImaAdsLoader(Context context, Uri adTagUri) {
         /* adsResponse= */ null,
         /* vastLoadTimeoutMs= */ TIMEOUT_UNSET,
         /* mediaLoadTimeoutMs= */ TIMEOUT_UNSET,
+        /* mediaBitrate= */ BITRATE_UNSET,
+        /* focusSkipButtonWhenAvailable= */ true,
+        /* adUiElements= */ null,
         /* adEventListener= */ null,
         /* imaFactory= */ new DefaultImaFactory());
   }
@@ -360,6 +422,9 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
         /* adsResponse= */ null,
         /* vastLoadTimeoutMs= */ TIMEOUT_UNSET,
         /* mediaLoadTimeoutMs= */ TIMEOUT_UNSET,
+        /* mediaBitrate= */ BITRATE_UNSET,
+        /* focusSkipButtonWhenAvailable= */ true,
+        /* adUiElements= */ null,
         /* adEventListener= */ null,
         /* imaFactory= */ new DefaultImaFactory());
   }
@@ -371,6 +436,9 @@ private ImaAdsLoader(
       @Nullable String adsResponse,
       int vastLoadTimeoutMs,
       int mediaLoadTimeoutMs,
+      int mediaBitrate,
+      boolean focusSkipButtonWhenAvailable,
+      @Nullable Set<UiElement> adUiElements,
       @Nullable AdEventListener adEventListener,
       ImaFactory imaFactory) {
     Assertions.checkArgument(adTagUri != null || adsResponse != null);
@@ -378,6 +446,9 @@ private ImaAdsLoader(
     this.adsResponse = adsResponse;
     this.vastLoadTimeoutMs = vastLoadTimeoutMs;
     this.mediaLoadTimeoutMs = mediaLoadTimeoutMs;
+    this.mediaBitrate = mediaBitrate;
+    this.focusSkipButtonWhenAvailable = focusSkipButtonWhenAvailable;
+    this.adUiElements = adUiElements;
     this.adEventListener = adEventListener;
     this.imaFactory = imaFactory;
     if (imaSdkSettings == null) {
@@ -924,6 +995,13 @@ private void startAdPlayback() {
     if (mediaLoadTimeoutMs != TIMEOUT_UNSET) {
       adsRenderingSettings.setLoadVideoTimeout(mediaLoadTimeoutMs);
     }
+    if (mediaBitrate != BITRATE_UNSET) {
+      adsRenderingSettings.setBitrateKbps(mediaBitrate / 1000);
+    }
+    adsRenderingSettings.setFocusSkipButtonWhenAvailable(focusSkipButtonWhenAvailable);
+    if (adUiElements != null) {
+      adsRenderingSettings.setUiElements(adUiElements);
+    }
 
     // Set up the ad playback state, skipping ads based on the start position as required.
     long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
diff --git a/extensions/ima/src/main/proguard-rules.txt b/extensions/ima/src/main/proguard-rules.txt
deleted file mode 100644
index feef3daf7a..0000000000
--- a/extensions/ima/src/main/proguard-rules.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-# Proguard rules specific to the IMA extension.
-
--keep class com.google.ads.interactivemedia.** { *; }
--keep interface com.google.ads.interactivemedia.** { *; }
--keep class com.google.obf.** { *; }
--keep interface com.google.obf.** { *; }
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
index 0c35c9b66d..b8024d6534 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
@@ -26,7 +26,6 @@
 /* package */ final class FakePlayer extends StubExoPlayer {
 
   private final ArrayList<Player.EventListener> listeners;
-  private final Timeline.Window window;
   private final Timeline.Period period;
   private final Timeline timeline;
 
@@ -41,7 +40,6 @@
 
   public FakePlayer() {
     listeners = new ArrayList<>();
-    window = new Timeline.Window();
     period = new Timeline.Period();
     state = Player.STATE_IDLE;
     playWhenReady = true;
@@ -151,16 +149,6 @@ public int getCurrentWindowIndex() {
     return 0;
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    return C.INDEX_UNSET;
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    return C.INDEX_UNSET;
-  }
-
   @Override
   public long getDuration() {
     if (timeline.isEmpty()) {
diff --git a/extensions/mediasession/build.gradle b/extensions/mediasession/build.gradle
index da04b0aec3..5fb25c6382 100644
--- a/extensions/mediasession/build.gradle
+++ b/extensions/mediasession/build.gradle
@@ -31,7 +31,7 @@ android {
 
 dependencies {
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
+    api 'com.android.support:support-media-compat:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 0915ee4b03..9323723601 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -49,6 +49,11 @@
 /**
  * Connects a {@link MediaSessionCompat} to a {@link Player}.
  *
+ * <p>This connector does <em>not</em> call {@link MediaSessionCompat#setActive(boolean)}, and so
+ * application code is responsible for making the session active when desired. A session must be
+ * active for transport controls to be displayed (e.g. on the lock screen) and for it to receive
+ * media button events.
+ *
  * <p>The connector listens for actions sent by the media session's controller and implements these
  * actions by calling appropriate player methods. The playback state of the media session is
  * automatically synced with the player. The connector can also be optionally extended by providing
@@ -259,6 +264,9 @@
 
     /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat)}. */
     void onSetRating(Player player, RatingCompat rating);
+    
+    /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat, Bundle)}. */
+    void onSetRating(Player player, RatingCompat rating, Bundle extras);
   }
 
   /**
@@ -1002,6 +1010,13 @@ public void onSetRating(RatingCompat rating) {
         ratingCallback.onSetRating(player, rating);
       }
     }
+    
+    @Override
+    public void onSetRating(RatingCompat rating, Bundle extras) {
+      if (canDispatchToRatingCallback(PlaybackStateCompat.ACTION_SET_RATING)) {
+        ratingCallback.onSetRating(player, rating, extras);
+      }
+    }
 
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description) {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
index 6671add7e5..d55f8e04f0 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueNavigator.java
@@ -39,6 +39,7 @@
   public static final int DEFAULT_MAX_QUEUE_SIZE = 10;
 
   private final MediaSessionCompat mediaSession;
+  private final Timeline.Window window;
   protected final int maxQueueSize;
 
   private long activeQueueItemId;
@@ -68,6 +69,7 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
     this.mediaSession = mediaSession;
     this.maxQueueSize = maxQueueSize;
     activeQueueItemId = MediaSessionCompat.QueueItem.UNKNOWN_ID;
+    window = new Timeline.Window();
   }
 
   /**
@@ -81,25 +83,24 @@ public TimelineQueueNavigator(MediaSessionCompat mediaSession, int maxQueueSize)
 
   @Override
   public long getSupportedQueueNavigatorActions(Player player) {
-    if (player == null || player.getCurrentTimeline().getWindowCount() < 2) {
+    if (player == null) {
       return 0;
     }
-    if (player.getRepeatMode() != Player.REPEAT_MODE_OFF) {
-      return PlaybackStateCompat.ACTION_SKIP_TO_NEXT | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS
-          | PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty() || player.isPlayingAd()) {
+      return 0;
     }
-
-    int currentWindowIndex = player.getCurrentWindowIndex();
-    long actions;
-    if (currentWindowIndex == 0) {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_NEXT;
-    } else if (currentWindowIndex == player.getCurrentTimeline().getWindowCount() - 1) {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
-    } else {
-      actions = PlaybackStateCompat.ACTION_SKIP_TO_NEXT
-          | PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
+    long actions = 0;
+    if (timeline.getWindowCount() > 1) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    }
+    if (window.isSeekable || !window.isDynamic || player.hasPrevious()) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
     }
-    return actions | PlaybackStateCompat.ACTION_SKIP_TO_QUEUE_ITEM;
+    if (window.isDynamic || player.hasNext()) {
+      actions |= PlaybackStateCompat.ACTION_SKIP_TO_NEXT;
+    }
+    return actions;
   }
 
   @Override
@@ -125,22 +126,25 @@ public final long getActiveQueueItemId(@Nullable Player player) {
   @Override
   public void onSkipToPrevious(Player player) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
+    int windowIndex = player.getCurrentWindowIndex();
+    timeline.getWindow(windowIndex, window);
     int previousWindowIndex = player.getPreviousWindowIndex();
-    if (player.getCurrentPosition() > MAX_POSITION_FOR_SEEK_TO_PREVIOUS
-        || previousWindowIndex == C.INDEX_UNSET) {
-      player.seekTo(0);
-    } else {
+    if (previousWindowIndex != C.INDEX_UNSET
+        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
+            || (window.isDynamic && !window.isSeekable))) {
       player.seekTo(previousWindowIndex, C.TIME_UNSET);
+    } else {
+      player.seekTo(0);
     }
   }
 
   @Override
   public void onSkipToQueueItem(Player player, long id) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = (int) id;
@@ -152,12 +156,15 @@ public void onSkipToQueueItem(Player player, long id) {
   @Override
   public void onSkipToNext(Player player) {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
+    int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       player.seekTo(nextWindowIndex, C.TIME_UNSET);
+    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
+      player.seekTo(windowIndex, C.TIME_UNSET);
     }
   }
 
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 031d6343d6..11cedcafd7 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -178,8 +178,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
 
       Map<String, List<String>> headers = response.headers().toMultimap();
       closeConnectionQuietly();
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(
-          responseCode, headers, dataSpec);
+      InvalidResponseCodeException exception =
+          new InvalidResponseCodeException(responseCode, response.message(), headers, dataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index 57937b4282..e288339058 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -78,7 +78,7 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!OpusLibrary.isAvailable()
         || !MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+    } else if (!supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index 2f2c65980a..af02ee2eaa 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -33,6 +33,8 @@ dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
 }
 
 ext {
diff --git a/extensions/rtmp/src/test/AndroidManifest.xml b/extensions/rtmp/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..7eab4e2d59
--- /dev/null
+++ b/extensions/rtmp/src/test/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.rtmp"/>
diff --git a/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
new file mode 100644
index 0000000000..f4753798b8
--- /dev/null
+++ b/extensions/rtmp/src/test/java/com/google/android/exoplayer2/ext/rtmp/DefaultDataSourceTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.rtmp;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link DefaultDataSource} with RTMP URIs. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultDataSourceTest {
+
+  @Test
+  public void openRtmpDataSpec_instantiatesRtmpDataSourceViaReflection() throws IOException {
+    DefaultDataSource dataSource =
+        new DefaultDataSource(
+            RuntimeEnvironment.application, "userAgent", /* allowCrossProtocolRedirects= */ false);
+    DataSpec dataSpec = new DataSpec(Uri.parse("rtmp://test.com/stream"));
+    try {
+      dataSource.open(dataSpec);
+    } catch (UnsatisfiedLinkError e) {
+      // RtmpDataSource was successfully instantiated (test run using Gradle).
+    } catch (UnsupportedOperationException e) {
+      // RtmpDataSource was successfully instantiated (test run using Blaze).
+    }
+  }
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index c09d2fe55a..e3081cd2d2 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -45,6 +45,7 @@
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -64,9 +65,13 @@
  */
 public class LibvpxVideoRenderer extends BaseRenderer {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The decoder does not need to be re-initialized.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
new file mode 100644
index 0000000000..eb3bd4f91a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+
+/** Abstract base {@link Player} which implements common implementation independent methods. */
+public abstract class BasePlayer implements Player {
+
+  protected final Timeline.Window window;
+
+  public BasePlayer() {
+    window = new Timeline.Window();
+  }
+
+  @Override
+  public final void seekToDefaultPosition() {
+    seekToDefaultPosition(getCurrentWindowIndex());
+  }
+
+  @Override
+  public final void seekToDefaultPosition(int windowIndex) {
+    seekTo(windowIndex, /* positionMs= */ C.TIME_UNSET);
+  }
+
+  @Override
+  public final void seekTo(long positionMs) {
+    seekTo(getCurrentWindowIndex(), positionMs);
+  }
+
+  @Override
+  public final boolean hasPrevious() {
+    return getPreviousWindowIndex() != C.INDEX_UNSET;
+  }
+
+  @Override
+  public final void previous() {
+    int previousWindowIndex = getPreviousWindowIndex();
+    if (previousWindowIndex != C.INDEX_UNSET) {
+      seekToDefaultPosition(previousWindowIndex);
+    }
+  }
+
+  @Override
+  public final boolean hasNext() {
+    return getNextWindowIndex() != C.INDEX_UNSET;
+  }
+
+  @Override
+  public final void next() {
+    int nextWindowIndex = getNextWindowIndex();
+    if (nextWindowIndex != C.INDEX_UNSET) {
+      seekToDefaultPosition(nextWindowIndex);
+    }
+  }
+
+  @Override
+  public final void stop() {
+    stop(/* reset= */ false);
+  }
+
+  @Override
+  public final int getNextWindowIndex() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.INDEX_UNSET
+        : timeline.getNextWindowIndex(
+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());
+  }
+
+  @Override
+  public final int getPreviousWindowIndex() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.INDEX_UNSET
+        : timeline.getPreviousWindowIndex(
+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());
+  }
+
+  @Override
+  @Nullable
+  public final Object getCurrentTag() {
+    int windowIndex = getCurrentWindowIndex();
+    Timeline timeline = getCurrentTimeline();
+    return windowIndex >= timeline.getWindowCount()
+        ? null
+        : timeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
+  }
+
+  @Override
+  public final int getBufferedPercentage() {
+    long position = getBufferedPosition();
+    long duration = getDuration();
+    return position == C.TIME_UNSET || duration == C.TIME_UNSET
+        ? 0
+        : duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100);
+  }
+
+  @Override
+  public final boolean isCurrentWindowDynamic() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public final boolean isCurrentWindowSeekable() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
+  @Override
+  public final long getContentDuration() {
+    Timeline timeline = getCurrentTimeline();
+    return timeline.isEmpty()
+        ? C.TIME_UNSET
+        : timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+  }
+
+  @RepeatMode
+  private int getRepeatModeForNavigation() {
+    @RepeatMode int repeatMode = getRepeatMode();
+    return repeatMode == REPEAT_MODE_ONE ? REPEAT_MODE_OFF : repeatMode;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 0cbdc14b1c..fac9818d9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.UUID;
@@ -114,6 +115,7 @@ private C() {}
    * Crypto modes for a codec. One of {@link #CRYPTO_MODE_UNENCRYPTED}, {@link #CRYPTO_MODE_AES_CTR}
    * or {@link #CRYPTO_MODE_AES_CBC}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
   public @interface CryptoMode {}
@@ -144,6 +146,7 @@ private C() {}
    * #ENCODING_E_AC3}, {@link #ENCODING_DTS}, {@link #ENCODING_DTS_HD} or {@link
    * #ENCODING_DOLBY_TRUEHD}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     Format.NO_VALUE,
@@ -169,6 +172,7 @@ private C() {}
    * #ENCODING_PCM_24BIT}, {@link #ENCODING_PCM_32BIT}, {@link #ENCODING_PCM_FLOAT}, {@link
    * #ENCODING_PCM_MU_LAW} or {@link #ENCODING_PCM_A_LAW}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     Format.NO_VALUE,
@@ -215,6 +219,7 @@ private C() {}
    * #STREAM_TYPE_RING}, {@link #STREAM_TYPE_SYSTEM}, {@link #STREAM_TYPE_VOICE_CALL} or {@link
    * #STREAM_TYPE_USE_DEFAULT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     STREAM_TYPE_ALARM,
@@ -269,6 +274,7 @@ private C() {}
    * #CONTENT_TYPE_MOVIE}, {@link #CONTENT_TYPE_MUSIC}, {@link #CONTENT_TYPE_SONIFICATION}, {@link
    * #CONTENT_TYPE_SPEECH} or {@link #CONTENT_TYPE_UNKNOWN}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     CONTENT_TYPE_MOVIE,
@@ -309,6 +315,7 @@ private C() {}
    * <p>Note that {@code FLAG_HW_AV_SYNC} is not available because the player takes care of setting
    * the flag when tunneling is enabled via a track selector.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -331,6 +338,7 @@ private C() {}
    * #USAGE_UNKNOWN}, {@link #USAGE_VOICE_COMMUNICATION} or {@link
    * #USAGE_VOICE_COMMUNICATION_SIGNALLING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     USAGE_ALARM,
@@ -427,6 +435,7 @@ private C() {}
    * #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or {@link
    * #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     AUDIOFOCUS_NONE,
@@ -454,6 +463,7 @@ private C() {}
    * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_ENCRYPTED} and
    * {@link #BUFFER_FLAG_DECODE_ONLY}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -482,6 +492,7 @@ private C() {}
    * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s. One of {@link
    * #VIDEO_SCALING_MODE_SCALE_TO_FIT} or {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
   public @interface VideoScalingMode {}
@@ -504,6 +515,7 @@ private C() {}
    * Track selection flags. Possible flag values are {@link #SELECTION_FLAG_DEFAULT}, {@link
    * #SELECTION_FLAG_FORCED} and {@link #SELECTION_FLAG_AUTOSELECT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -530,6 +542,7 @@ private C() {}
    * Represents a streaming or other media type. One of {@link #TYPE_DASH}, {@link #TYPE_SS}, {@link
    * #TYPE_HLS} or {@link #TYPE_OTHER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
   public @interface ContentType {}
@@ -796,6 +809,7 @@ private C() {}
    * #STEREO_MODE_MONO}, {@link #STEREO_MODE_TOP_BOTTOM}, {@link #STEREO_MODE_LEFT_RIGHT} or {@link
    * #STEREO_MODE_STEREO_MESH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     Format.NO_VALUE,
@@ -827,6 +841,7 @@ private C() {}
    * Video colorspaces. One of {@link Format#NO_VALUE}, {@link #COLOR_SPACE_BT709}, {@link
    * #COLOR_SPACE_BT601} or {@link #COLOR_SPACE_BT2020}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
   public @interface ColorSpace {}
@@ -847,6 +862,7 @@ private C() {}
    * Video color transfer characteristics. One of {@link Format#NO_VALUE}, {@link
    * #COLOR_TRANSFER_SDR}, {@link #COLOR_TRANSFER_ST2084} or {@link #COLOR_TRANSFER_HLG}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
   public @interface ColorTransfer {}
@@ -867,6 +883,7 @@ private C() {}
    * Video color range. One of {@link Format#NO_VALUE}, {@link #COLOR_RANGE_LIMITED} or {@link
    * #COLOR_RANGE_FULL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
   public @interface ColorRange {}
@@ -899,6 +916,7 @@ private C() {}
    * #NETWORK_TYPE_4G}, {@link #NETWORK_TYPE_CELLULAR_UNKNOWN}, {@link #NETWORK_TYPE_ETHERNET} or
    * {@link #NETWORK_TYPE_OTHER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NETWORK_TYPE_UNKNOWN,
@@ -960,7 +978,10 @@ public static long msToUs(long timeMs) {
   }
 
   /**
-   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   * Returns a newly generated audio session identifier, or {@link AudioManager#ERROR} if an error
+   * occurred in which case audio playback may fail.
+   *
+   * @see AudioManager#generateAudioSessionId()
    */
   @TargetApi(21)
   public static int generateAudioSessionIdV21(Context context) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index 97a56b844c..c109ed81c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -79,6 +79,7 @@
     private PriorityTaskManager priorityTaskManager;
     private int backBufferDurationMs;
     private boolean retainBackBufferFromKeyframe;
+    private boolean createDefaultLoadControlCalled;
 
     /** Constructs a new instance. */
     public Builder() {
@@ -99,8 +100,10 @@ public Builder() {
      *
      * @param allocator The {@link DefaultAllocator}.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setAllocator(DefaultAllocator allocator) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.allocator = allocator;
       return this;
     }
@@ -118,12 +121,14 @@ public Builder setAllocator(DefaultAllocator allocator) {
      *     for playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be
      *     caused by buffer depletion rather than a user action.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setBufferDurationsMs(
         int minBufferMs,
         int maxBufferMs,
         int bufferForPlaybackMs,
         int bufferForPlaybackAfterRebufferMs) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.minBufferMs = minBufferMs;
       this.maxBufferMs = maxBufferMs;
       this.bufferForPlaybackMs = bufferForPlaybackMs;
@@ -137,8 +142,10 @@ public Builder setBufferDurationsMs(
      *
      * @param targetBufferBytes The target buffer size in bytes.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setTargetBufferBytes(int targetBufferBytes) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.targetBufferBytes = targetBufferBytes;
       return this;
     }
@@ -150,8 +157,10 @@ public Builder setTargetBufferBytes(int targetBufferBytes) {
      * @param prioritizeTimeOverSizeThresholds Whether the load control prioritizes buffer time
      *     constraints over buffer size constraints.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setPrioritizeTimeOverSizeThresholds(boolean prioritizeTimeOverSizeThresholds) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.prioritizeTimeOverSizeThresholds = prioritizeTimeOverSizeThresholds;
       return this;
     }
@@ -161,8 +170,10 @@ public Builder setPrioritizeTimeOverSizeThresholds(boolean prioritizeTimeOverSiz
      *
      * @param priorityTaskManager The {@link PriorityTaskManager} to use.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setPriorityTaskManager(PriorityTaskManager priorityTaskManager) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.priorityTaskManager = priorityTaskManager;
       return this;
     }
@@ -175,8 +186,10 @@ public Builder setPriorityTaskManager(PriorityTaskManager priorityTaskManager) {
      * @param retainBackBufferFromKeyframe Whether the back buffer is retained from the previous
      *     keyframe.
      * @return This builder, for convenience.
+     * @throws IllegalStateException If {@link #createDefaultLoadControl()} has already been called.
      */
     public Builder setBackBuffer(int backBufferDurationMs, boolean retainBackBufferFromKeyframe) {
+      Assertions.checkState(!createDefaultLoadControlCalled);
       this.backBufferDurationMs = backBufferDurationMs;
       this.retainBackBufferFromKeyframe = retainBackBufferFromKeyframe;
       return this;
@@ -184,6 +197,7 @@ public Builder setBackBuffer(int backBufferDurationMs, boolean retainBackBufferF
 
     /** Creates a {@link DefaultLoadControl}. */
     public DefaultLoadControl createDefaultLoadControl() {
+      createDefaultLoadControlCalled = true;
       if (allocator == null) {
         allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
       }
@@ -371,7 +385,7 @@ public boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpee
     }
     if (bufferedDurationUs < minBufferUs) {
       isBuffering = prioritizeTimeOverSizeThresholds || !targetBufferSizeReached;
-    } else if (bufferedDurationUs > maxBufferUs || targetBufferSizeReached) {
+    } else if (bufferedDurationUs >= maxBufferUs || targetBufferSizeReached) {
       isBuffering = false;
     } // Else don't change the buffering state
     if (priorityTaskManager != null && isBuffering != wasBuffering) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 4e69bc316e..cc16c43b05 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -36,6 +36,7 @@
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionRenderer;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Constructor;
@@ -56,6 +57,7 @@
    * Modes for using extension renderers. One of {@link #EXTENSION_RENDERER_MODE_OFF}, {@link
    * #EXTENSION_RENDERER_MODE_ON} or {@link #EXTENSION_RENDERER_MODE_PREFER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
   public @interface ExtensionRendererMode {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index d591876a51..6b84245141 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -31,6 +32,7 @@
    * The type of source that produced the error. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER}
    * or {@link #TYPE_UNEXPECTED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_SOURCE, TYPE_RENDERER, TYPE_UNEXPECTED})
   public @interface Type {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 027f316493..ffdadb78f7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -40,10 +40,8 @@
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-/**
- * An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}.
- */
-/* package */ final class ExoPlayerImpl implements ExoPlayer {
+/** An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}. */
+/* package */ final class ExoPlayerImpl extends BasePlayer implements ExoPlayer {
 
   private static final String TAG = "ExoPlayerImpl";
 
@@ -61,7 +59,6 @@
   private final ExoPlayerImplInternal internalPlayer;
   private final Handler internalPlayerHandler;
   private final CopyOnWriteArraySet<Player.EventListener> listeners;
-  private final Timeline.Window window;
   private final Timeline.Period period;
   private final ArrayDeque<PlaybackInfoUpdate> pendingPlaybackInfoUpdates;
 
@@ -118,7 +115,6 @@ public ExoPlayerImpl(
             new RendererConfiguration[renderers.length],
             new TrackSelection[renderers.length],
             null);
-    window = new Timeline.Window();
     period = new Timeline.Period();
     playbackParameters = PlaybackParameters.DEFAULT;
     seekParameters = SeekParameters.DEFAULT;
@@ -293,21 +289,6 @@ public boolean isLoading() {
     return playbackInfo.isLoading;
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    seekToDefaultPosition(getCurrentWindowIndex());
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    seekTo(windowIndex, C.TIME_UNSET);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    seekTo(getCurrentWindowIndex(), positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     Timeline timeline = playbackInfo.timeline;
@@ -377,19 +358,6 @@ public SeekParameters getSeekParameters() {
     return seekParameters;
   }
 
-  @Override
-  public @Nullable Object getCurrentTag() {
-    int windowIndex = getCurrentWindowIndex();
-    return windowIndex >= playbackInfo.timeline.getWindowCount()
-        ? null
-        : playbackInfo.timeline.getWindow(windowIndex, window, /* setTag= */ true).tag;
-  }
-
-  @Override
-  public void stop() {
-    stop(/* reset= */ false);
-  }
-
   @Override
   public void stop(boolean reset) {
     if (reset) {
@@ -494,20 +462,6 @@ public int getCurrentWindowIndex() {
     }
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    Timeline timeline = playbackInfo.timeline;
-    return timeline.isEmpty() ? C.INDEX_UNSET
-        : timeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    Timeline timeline = playbackInfo.timeline;
-    return timeline.isEmpty() ? C.INDEX_UNSET
-        : timeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, shuffleModeEnabled);
-  }
-
   @Override
   public long getDuration() {
     if (isPlayingAd()) {
@@ -540,32 +494,11 @@ public long getBufferedPosition() {
     return getContentBufferedPosition();
   }
 
-  @Override
-  public int getBufferedPercentage() {
-    long position = getBufferedPosition();
-    long duration = getDuration();
-    return position == C.TIME_UNSET || duration == C.TIME_UNSET
-        ? 0
-        : (duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100));
-  }
-
   @Override
   public long getTotalBufferedDuration() {
     return Math.max(0, C.usToMs(playbackInfo.totalBufferedDurationUs));
   }
 
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    Timeline timeline = playbackInfo.timeline;
-    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    Timeline timeline = playbackInfo.timeline;
-    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
-  }
-
   @Override
   public boolean isPlayingAd() {
     return !shouldMaskPosition() && playbackInfo.periodId.isAd();
@@ -581,13 +514,6 @@ public int getCurrentAdIndexInAdGroup() {
     return isPlayingAd() ? playbackInfo.periodId.adIndexInAdGroup : C.INDEX_UNSET;
   }
 
-  @Override
-  public long getContentDuration() {
-    return playbackInfo.timeline.isEmpty()
-        ? C.TIME_UNSET
-        : playbackInfo.timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
-  }
-
   @Override
   public long getContentPosition() {
     if (isPlayingAd()) {
@@ -692,7 +618,7 @@ private void handlePlaybackInfo(
       if (playbackInfo.startPositionUs == C.TIME_UNSET) {
         // Replace internal unset start position with externally visible start position of zero.
         playbackInfo =
-            playbackInfo.fromNewPosition(
+            playbackInfo.resetToNewPosition(
                 playbackInfo.periodId, /* startPositionUs= */ 0, playbackInfo.contentPositionUs);
       }
       if ((!this.playbackInfo.timeline.isEmpty() || hasPendingPrepare)
@@ -731,20 +657,26 @@ private PlaybackInfo getResetPlaybackInfo(
       maskingPeriodIndex = getCurrentPeriodIndex();
       maskingWindowPositionMs = getCurrentPosition();
     }
+    MediaPeriodId mediaPeriodId =
+        resetPosition
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            : playbackInfo.periodId;
+    long startPositionUs = resetPosition ? 0 : playbackInfo.positionUs;
+    long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     return new PlaybackInfo(
         resetState ? Timeline.EMPTY : playbackInfo.timeline,
         resetState ? null : playbackInfo.manifest,
-        playbackInfo.periodId,
-        playbackInfo.startPositionUs,
-        playbackInfo.contentPositionUs,
+        mediaPeriodId,
+        startPositionUs,
+        contentPositionUs,
         playbackState,
         /* isLoading= */ false,
         resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
         resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
-        playbackInfo.periodId,
-        playbackInfo.startPositionUs,
+        mediaPeriodId,
+        startPositionUs,
         /* totalBufferedDurationUs= */ 0,
-        playbackInfo.startPositionUs);
+        startPositionUs);
   }
 
   private void updatePlaybackInfo(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index d861020d26..7f41719d1d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -448,7 +448,11 @@ private void seekToCurrentPosition(boolean sendDiscontinuity) throws ExoPlayback
         seekToPeriodPosition(periodId, playbackInfo.positionUs, /* forceDisableRenderers= */ true);
     if (newPositionUs != playbackInfo.positionUs) {
       playbackInfo =
-          playbackInfo.fromNewPosition(periodId, newPositionUs, playbackInfo.contentPositionUs);
+          playbackInfo.copyWithNewPosition(
+              periodId,
+              newPositionUs,
+              playbackInfo.contentPositionUs,
+              getTotalBufferedDurationUs());
       if (sendDiscontinuity) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
@@ -483,8 +487,12 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
       // A MediaPeriod may report a discontinuity at the current playback position to ensure the
       // renderers are flushed. Only report the discontinuity externally if the position changed.
       if (periodPositionUs != playbackInfo.positionUs) {
-        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
-            playbackInfo.contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                playbackInfo.periodId,
+                periodPositionUs,
+                playbackInfo.contentPositionUs,
+                getTotalBufferedDurationUs());
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
     } else {
@@ -496,10 +504,8 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
 
     // Update the buffered position and total buffered duration.
     MediaPeriodHolder loadingPeriod = queue.getLoadingPeriod();
-    playbackInfo.bufferedPositionUs =
-        loadingPeriod.getBufferedPositionUs(/* convertEosToDuration= */ true);
-    playbackInfo.totalBufferedDurationUs =
-        playbackInfo.bufferedPositionUs - loadingPeriod.toPeriodTime(rendererPositionUs);
+    playbackInfo.bufferedPositionUs = loadingPeriod.getBufferedPositionUs();
+    playbackInfo.totalBufferedDurationUs = getTotalBufferedDurationUs();
   }
 
   private void doSomeWork() throws ExoPlaybackException, IOException {
@@ -599,7 +605,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     if (resolvedSeekPosition == null) {
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed or is not ready and a suitable seek position could not be resolved.
-      periodId = getFirstMediaPeriodId();
+      periodId = playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
       periodPositionUs = C.TIME_UNSET;
       contentPositionUs = C.TIME_UNSET;
       seekPositionAdjusted = true;
@@ -647,7 +653,9 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         periodPositionUs = newPeriodPositionUs;
       }
     } finally {
-      playbackInfo = playbackInfo.fromNewPosition(periodId, periodPositionUs, contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              periodId, periodPositionUs, contentPositionUs, getTotalBufferedDurationUs());
       if (seekPositionAdjusted) {
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
       }
@@ -752,17 +760,6 @@ private void releaseInternal() {
     }
   }
 
-  private MediaPeriodId getFirstMediaPeriodId() {
-    Timeline timeline = playbackInfo.timeline;
-    if (timeline.isEmpty()) {
-      return PlaybackInfo.DUMMY_MEDIA_PERIOD_ID;
-    }
-    int firstPeriodIndex =
-        timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
-            .firstPeriodIndex;
-    return new MediaPeriodId(timeline.getUidOfPeriod(firstPeriodIndex));
-  }
-
   private void resetInternal(
       boolean releaseMediaSource, boolean resetPosition, boolean resetState) {
     handler.removeMessages(MSG_DO_SOME_WORK);
@@ -791,8 +788,11 @@ private void resetInternal(
       pendingMessages.clear();
       nextPendingMessageIndex = 0;
     }
+    MediaPeriodId mediaPeriodId =
+        resetPosition
+            ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window)
+            : playbackInfo.periodId;
     // Set the start position to TIME_UNSET so that a subsequent seek to 0 isn't ignored.
-    MediaPeriodId mediaPeriodId = resetPosition ? getFirstMediaPeriodId() : playbackInfo.periodId;
     long startPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.positionUs;
     long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     playbackInfo =
@@ -1020,8 +1020,12 @@ private void reselectTracksInternal() throws ExoPlaybackException {
               playbackInfo.positionUs, recreateStreams, streamResetFlags);
       if (playbackInfo.playbackState != Player.STATE_ENDED
           && periodPositionUs != playbackInfo.positionUs) {
-        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
-            playbackInfo.contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                playbackInfo.periodId,
+                periodPositionUs,
+                playbackInfo.contentPositionUs,
+                getTotalBufferedDurationUs());
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
         resetRendererPosition(periodPositionUs);
       }
@@ -1097,12 +1101,10 @@ private boolean shouldTransitionToReadyState(boolean renderersReadyOrEnded) {
     }
     // Renderers are ready and we're loading. Ask the LoadControl whether to transition.
     MediaPeriodHolder loadingHolder = queue.getLoadingPeriod();
-    long bufferedPositionUs = loadingHolder.getBufferedPositionUs(!loadingHolder.info.isFinal);
-    return bufferedPositionUs == C.TIME_END_OF_SOURCE
+    boolean bufferedToEnd = loadingHolder.isFullyBuffered() && loadingHolder.info.isFinal;
+    return bufferedToEnd
         || loadControl.shouldStartPlayback(
-            bufferedPositionUs - loadingHolder.toPeriodTime(rendererPositionUs),
-            mediaClock.getPlaybackParameters().speed,
-            rebuffering);
+            getTotalBufferedDurationUs(), mediaClock.getPlaybackParameters().speed, rebuffering);
   }
 
   private boolean isTimelineReady() {
@@ -1164,8 +1166,13 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
           periodPosition =
               resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
         } catch (IllegalSeekPositionException e) {
+          MediaPeriodId firstMediaPeriodId =
+              playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window);
           playbackInfo =
-              playbackInfo.fromNewPosition(getFirstMediaPeriodId(), C.TIME_UNSET, C.TIME_UNSET);
+              playbackInfo.resetToNewPosition(
+                  firstMediaPeriodId,
+                  /* startPositionUs= */ C.TIME_UNSET,
+                  /* contentPositionUs= */ C.TIME_UNSET);
           throw e;
         }
         pendingInitialSeekPosition = null;
@@ -1178,7 +1185,7 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
           long positionUs = periodPosition.second;
           MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, positionUs);
           playbackInfo =
-              playbackInfo.fromNewPosition(
+              playbackInfo.resetToNewPosition(
                   periodId, periodId.isAd() ? 0 : positionUs, /* contentPositionUs= */ positionUs);
         }
       } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
@@ -1192,7 +1199,7 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
           long startPositionUs = defaultPosition.second;
           MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
           playbackInfo =
-              playbackInfo.fromNewPosition(
+              playbackInfo.resetToNewPosition(
                   periodId,
                   periodId.isAd() ? 0 : startPositionUs,
                   /* contentPositionUs= */ startPositionUs);
@@ -1211,7 +1218,7 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
         long startPositionUs = defaultPosition.second;
         MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodUid, startPositionUs);
         playbackInfo =
-            playbackInfo.fromNewPosition(
+            playbackInfo.resetToNewPosition(
                 periodId,
                 /* startPositionUs= */ periodId.isAd() ? 0 : startPositionUs,
                 /* contentPositionUs= */ startPositionUs);
@@ -1250,7 +1257,9 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       }
       // Actually do the seek.
       long seekPositionUs = seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
-      playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
       return;
     }
 
@@ -1262,7 +1271,9 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
         // The previously playing ad should no longer be played, so skip it.
         long seekPositionUs =
             seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
-        playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
+        playbackInfo =
+            playbackInfo.copyWithNewPosition(
+                periodId, seekPositionUs, contentPositionUs, getTotalBufferedDurationUs());
         return;
       }
     }
@@ -1418,8 +1429,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       MediaPeriodHolder oldPlayingPeriodHolder = playingPeriodHolder;
       playingPeriodHolder = queue.advancePlayingPeriod();
       updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
-      playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id,
-          playingPeriodHolder.info.startPositionUs, playingPeriodHolder.info.contentPositionUs);
+      playbackInfo =
+          playbackInfo.copyWithNewPosition(
+              playingPeriodHolder.info.id,
+              playingPeriodHolder.info.startPositionUs,
+              playingPeriodHolder.info.contentPositionUs,
+              getTotalBufferedDurationUs());
       playbackInfoUpdate.setPositionDiscontinuity(discontinuityReason);
       updatePlaybackPositions();
       advancedPlayingPeriod = true;
@@ -1571,7 +1586,7 @@ private void maybeContinueLoading() {
       return;
     }
     long bufferedDurationUs =
-        nextLoadPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+        getTotalBufferedDurationUs(/* bufferedPositionInLoadingPeriodUs= */ nextLoadPositionUs);
     boolean continueLoading =
         loadControl.shouldContinueLoading(
             bufferedDurationUs, mediaClock.getPlaybackParameters().speed);
@@ -1667,6 +1682,11 @@ private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChange
     if (loadingMediaPeriodChanged) {
       playbackInfo = playbackInfo.copyWithLoadingMediaPeriodId(loadingMediaPeriodId);
     }
+    playbackInfo.bufferedPositionUs =
+        loadingMediaPeriodHolder == null
+            ? playbackInfo.positionUs
+            : loadingMediaPeriodHolder.getBufferedPositionUs();
+    playbackInfo.totalBufferedDurationUs = getTotalBufferedDurationUs();
     if ((loadingMediaPeriodChanged || loadingTrackSelectionChanged)
         && loadingMediaPeriodHolder != null
         && loadingMediaPeriodHolder.prepared) {
@@ -1675,6 +1695,17 @@ private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChange
     }
   }
 
+  private long getTotalBufferedDurationUs() {
+    return getTotalBufferedDurationUs(playbackInfo.bufferedPositionUs);
+  }
+
+  private long getTotalBufferedDurationUs(long bufferedPositionInLoadingPeriodUs) {
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    return loadingPeriodHolder == null
+        ? 0
+        : bufferedPositionInLoadingPeriodUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+  }
+
   private void updateLoadControlTrackSelection(
       TrackGroupArray trackGroups, TrackSelectorResult trackSelectorResult) {
     loadControl.onTracksSelected(renderers, trackGroups, trackSelectorResult.selections);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index f5ad677d77..c30fe160c9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.9.0";
+  public static final String VERSION = "2.9.2";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.0";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.2";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2009000;
+  public static final int VERSION_INT = 2009002;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 4941b4efc6..5925c8f383 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -117,23 +117,18 @@ public long getDurationUs() {
   }
 
   /**
-   * Returns the buffered position in microseconds. If the period is buffered to the end then
-   * {@link C#TIME_END_OF_SOURCE} is returned unless {@code convertEosToDuration} is true, in which
-   * case the period duration is returned.
+   * Returns the buffered position in microseconds. If the period is buffered to the end, then the
+   * period duration is returned.
    *
-   * @param convertEosToDuration Whether to return the period duration rather than
-   *     {@link C#TIME_END_OF_SOURCE} if the period is fully buffered.
    * @return The buffered position in microseconds.
    */
-  public long getBufferedPositionUs(boolean convertEosToDuration) {
+  public long getBufferedPositionUs() {
     if (!prepared) {
       return info.startPositionUs;
     }
     long bufferedPositionUs =
         hasEnabledTracks ? mediaPeriod.getBufferedPositionUs() : C.TIME_END_OF_SOURCE;
-    return bufferedPositionUs == C.TIME_END_OF_SOURCE && convertEosToDuration
-        ? info.durationUs
-        : bufferedPositionUs;
+    return bufferedPositionUs == C.TIME_END_OF_SOURCE ? info.durationUs : bufferedPositionUs;
   }
 
   public long getNextLoadPositionUs() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 2edf7bb8c6..c51c1cc149 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -532,6 +532,11 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
     // until the timeline is updated. Store whether the next timeline period is ready when the
     // timeline is updated, to avoid repeatedly checking the same timeline.
     MediaPeriodInfo mediaPeriodInfo = mediaPeriodHolder.info;
+    // The expected delay until playback transitions to the new period is equal the duration of
+    // media that's currently buffered (assuming no interruptions). This is used to project forward
+    // the start position for transitions to new windows.
+    long bufferedDurationUs =
+        mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;
     if (mediaPeriodInfo.isLastInTimelinePeriod) {
       int currentPeriodIndex = timeline.getIndexOfPeriod(mediaPeriodInfo.id.periodUid);
       int nextPeriodIndex =
@@ -549,19 +554,15 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
       long windowSequenceNumber = mediaPeriodInfo.id.windowSequenceNumber;
       if (timeline.getWindow(nextWindowIndex, window).firstPeriodIndex == nextPeriodIndex) {
         // We're starting to buffer a new window. When playback transitions to this window we'll
-        // want it to be from its default start position. The expected delay until playback
-        // transitions is equal the duration of media that's currently buffered (assuming no
-        // interruptions). Hence we project the default start position forward by the duration of
-        // the buffer, and start buffering from this point.
-        long defaultPositionProjectionUs =
-            mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;
+        // want it to be from its default start position, so project the default start position
+        // forward by the duration of the buffer, and start buffering from this point.
         Pair<Object, Long> defaultPosition =
             timeline.getPeriodPosition(
                 window,
                 period,
                 nextWindowIndex,
-                C.TIME_UNSET,
-                Math.max(0, defaultPositionProjectionUs));
+                /* windowPositionUs= */ C.TIME_UNSET,
+                /* defaultPositionProjectionUs= */ Math.max(0, bufferedDurationUs));
         if (defaultPosition == null) {
           return null;
         }
@@ -601,11 +602,27 @@ private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
                 mediaPeriodInfo.contentPositionUs,
                 currentPeriodId.windowSequenceNumber);
       } else {
-        // Play content from the ad group position.
+        // Play content from the ad group position. As a special case, if we're transitioning from a
+        // preroll ad group to content and there are no other ad groups, project the start position
+        // forward as if this were a transition to a new window. No attempt is made to handle
+        // midrolls in live streams, as it's unclear what content position should play after an ad
+        // (server-side dynamic ad insertion is more appropriate for this use case).
+        long startPositionUs = mediaPeriodInfo.contentPositionUs;
+        if (period.getAdGroupCount() == 1 && period.getAdGroupTimeUs(0) == 0) {
+          Pair<Object, Long> defaultPosition =
+              timeline.getPeriodPosition(
+                  window,
+                  period,
+                  period.windowIndex,
+                  /* windowPositionUs= */ C.TIME_UNSET,
+                  /* defaultPositionProjectionUs= */ Math.max(0, bufferedDurationUs));
+          if (defaultPosition == null) {
+            return null;
+          }
+          startPositionUs = defaultPosition.second;
+        }
         return getMediaPeriodInfoForContent(
-            currentPeriodId.periodUid,
-            mediaPeriodInfo.contentPositionUs,
-            currentPeriodId.windowSequenceNumber);
+            currentPeriodId.periodUid, startPositionUs, currentPeriodId.windowSequenceNumber);
       }
     } else if (mediaPeriodInfo.id.endPositionUs != C.TIME_END_OF_SOURCE) {
       // Play the next ad group if it's available.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index 02058c0484..4333f51bf7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.CheckResult;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -29,7 +30,7 @@
    * Dummy media period id used while the timeline is empty and no period id is specified. This id
    * is used when playback infos are created with {@link #createDummy(long, TrackSelectorResult)}.
    */
-  public static final MediaPeriodId DUMMY_MEDIA_PERIOD_ID =
+  private static final MediaPeriodId DUMMY_MEDIA_PERIOD_ID =
       new MediaPeriodId(/* periodUid= */ new Object());
 
   /** The current {@link Timeline}. */
@@ -40,7 +41,8 @@
   public final MediaPeriodId periodId;
   /**
    * The start position at which playback started in {@link #periodId} relative to the start of the
-   * associated period in the {@link #timeline}, in microseconds.
+   * associated period in the {@link #timeline}, in microseconds. Note that this value changes for
+   * each position discontinuity.
    */
   public final long startPositionUs;
   /**
@@ -103,6 +105,23 @@ public static PlaybackInfo createDummy(
         startPositionUs);
   }
 
+  /**
+   * Create playback info.
+   *
+   * @param timeline See {@link #timeline}.
+   * @param manifest See {@link #manifest}.
+   * @param periodId See {@link #periodId}.
+   * @param startPositionUs See {@link #startPositionUs}.
+   * @param contentPositionUs See {@link #contentPositionUs}.
+   * @param playbackState See {@link #playbackState}.
+   * @param isLoading See {@link #isLoading}.
+   * @param trackGroups See {@link #trackGroups}.
+   * @param trackSelectorResult See {@link #trackSelectorResult}.
+   * @param loadingMediaPeriodId See {@link #loadingMediaPeriodId}.
+   * @param bufferedPositionUs See {@link #bufferedPositionUs}.
+   * @param totalBufferedDurationUs See {@link #totalBufferedDurationUs}.
+   * @param positionUs See {@link #positionUs}.
+   */
   public PlaybackInfo(
       Timeline timeline,
       @Nullable Object manifest,
@@ -132,7 +151,35 @@ public PlaybackInfo(
     this.positionUs = positionUs;
   }
 
-  public PlaybackInfo fromNewPosition(
+  /**
+   * Returns dummy media period id for the first-to-be-played period of the current timeline.
+   *
+   * @param shuffleModeEnabled Whether shuffle mode is enabled.
+   * @param window A writable {@link Timeline.Window}.
+   * @return A dummy media period id for the first-to-be-played period of the current timeline.
+   */
+  public MediaPeriodId getDummyFirstMediaPeriodId(
+      boolean shuffleModeEnabled, Timeline.Window window) {
+    if (timeline.isEmpty()) {
+      return DUMMY_MEDIA_PERIOD_ID;
+    }
+    int firstPeriodIndex =
+        timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
+            .firstPeriodIndex;
+    return new MediaPeriodId(timeline.getUidOfPeriod(firstPeriodIndex));
+  }
+
+  /**
+   * Copies playback info and resets playing and loading position.
+   *
+   * @param periodId New playing and loading {@link MediaPeriodId}.
+   * @param startPositionUs New start position. See {@link #startPositionUs}.
+   * @param contentPositionUs New content position. See {@link #contentPositionUs}. Value is ignored
+   *     if {@code periodId.isAd()} is true.
+   * @return Copied playback info with reset position.
+   */
+  @CheckResult
+  public PlaybackInfo resetToNewPosition(
       MediaPeriodId periodId, long startPositionUs, long contentPositionUs) {
     return new PlaybackInfo(
         timeline,
@@ -150,6 +197,46 @@ public PlaybackInfo fromNewPosition(
         startPositionUs);
   }
 
+  /**
+   * Copied playback info with new playing position.
+   *
+   * @param periodId New playing media period. See {@link #periodId}.
+   * @param positionUs New position. See {@link #positionUs}.
+   * @param contentPositionUs New content position. See {@link #contentPositionUs}. Value is ignored
+   *     if {@code periodId.isAd()} is true.
+   * @param totalBufferedDurationUs New buffered duration. See {@link #totalBufferedDurationUs}.
+   * @return Copied playback info with new playing position.
+   */
+  @CheckResult
+  public PlaybackInfo copyWithNewPosition(
+      MediaPeriodId periodId,
+      long positionUs,
+      long contentPositionUs,
+      long totalBufferedDurationUs) {
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        positionUs,
+        periodId.isAd() ? contentPositionUs : C.TIME_UNSET,
+        playbackState,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
+  }
+
+  /**
+   * Copies playback info with new timeline and manifest.
+   *
+   * @param timeline New timeline. See {@link #timeline}.
+   * @param manifest New manifest. See {@link #manifest}.
+   * @return Copied playback info with new timeline and manifest.
+   */
+  @CheckResult
   public PlaybackInfo copyWithTimeline(Timeline timeline, Object manifest) {
     return new PlaybackInfo(
         timeline,
@@ -167,6 +254,13 @@ public PlaybackInfo copyWithTimeline(Timeline timeline, Object manifest) {
         positionUs);
   }
 
+  /**
+   * Copies playback info with new playback state.
+   *
+   * @param playbackState New playback state. See {@link #playbackState}.
+   * @return Copied playback info with new playback state.
+   */
+  @CheckResult
   public PlaybackInfo copyWithPlaybackState(int playbackState) {
     return new PlaybackInfo(
         timeline,
@@ -184,6 +278,13 @@ public PlaybackInfo copyWithPlaybackState(int playbackState) {
         positionUs);
   }
 
+  /**
+   * Copies playback info with new loading state.
+   *
+   * @param isLoading New loading state. See {@link #isLoading}.
+   * @return Copied playback info with new loading state.
+   */
+  @CheckResult
   public PlaybackInfo copyWithIsLoading(boolean isLoading) {
     return new PlaybackInfo(
         timeline,
@@ -201,6 +302,14 @@ public PlaybackInfo copyWithIsLoading(boolean isLoading) {
         positionUs);
   }
 
+  /**
+   * Copies playback info with new track information.
+   *
+   * @param trackGroups New track groups. See {@link #trackGroups}.
+   * @param trackSelectorResult New track selector result. See {@link #trackSelectorResult}.
+   * @return Copied playback info with new track information.
+   */
+  @CheckResult
   public PlaybackInfo copyWithTrackInfo(
       TrackGroupArray trackGroups, TrackSelectorResult trackSelectorResult) {
     return new PlaybackInfo(
@@ -219,6 +328,13 @@ public PlaybackInfo copyWithTrackInfo(
         positionUs);
   }
 
+  /**
+   * Copies playback info with new loading media period.
+   *
+   * @param loadingMediaPeriodId New loading media period id. See {@link #loadingMediaPeriodId}.
+   * @return Copied playback info with new loading media period.
+   */
+  @CheckResult
   public PlaybackInfo copyWithLoadingMediaPeriodId(MediaPeriodId loadingMediaPeriodId) {
     return new PlaybackInfo(
         timeline,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index d4b965dbd6..16f8aa2878 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -446,6 +447,7 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    * Repeat modes for playback. One of {@link #REPEAT_MODE_OFF}, {@link #REPEAT_MODE_ONE} or {@link
    * #REPEAT_MODE_ALL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REPEAT_MODE_OFF, REPEAT_MODE_ONE, REPEAT_MODE_ALL})
   @interface RepeatMode {}
@@ -467,6 +469,7 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    * {@link #DISCONTINUITY_REASON_SEEK}, {@link #DISCONTINUITY_REASON_SEEK_ADJUSTMENT}, {@link
    * #DISCONTINUITY_REASON_AD_INSERTION} or {@link #DISCONTINUITY_REASON_INTERNAL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     DISCONTINUITY_REASON_PERIOD_TRANSITION,
@@ -497,6 +500,7 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    * Reasons for timeline and/or manifest changes. One of {@link #TIMELINE_CHANGE_REASON_PREPARED},
    * {@link #TIMELINE_CHANGE_REASON_RESET} or {@link #TIMELINE_CHANGE_REASON_DYNAMIC}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     TIMELINE_CHANGE_REASON_PREPARED,
@@ -655,6 +659,32 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    */
   void seekTo(int windowIndex, long positionMs);
 
+  /**
+   * Returns whether a previous window exists, which may depend on the current repeat mode and
+   * whether shuffle mode is enabled.
+   */
+  boolean hasPrevious();
+
+  /**
+   * Seeks to the default position of the previous window in the timeline, which may depend on the
+   * current repeat mode and whether shuffle mode is enabled. Does nothing if {@link #hasPrevious()}
+   * is {@code false}.
+   */
+  void previous();
+
+  /**
+   * Returns whether a next window exists, which may depend on the current repeat mode and whether
+   * shuffle mode is enabled.
+   */
+  boolean hasNext();
+
+  /**
+   * Seeks to the default position of the next window in the timeline, which may depend on the
+   * current repeat mode and whether shuffle mode is enabled. Does nothing if {@link #hasNext()} is
+   * {@code false}.
+   */
+  void next();
+
   /**
    * Attempts to set the playback parameters. Passing {@code null} sets the parameters to the
    * default, {@link PlaybackParameters#DEFAULT}, which means there is no speed or pitch adjustment.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index d1e1541cdc..c6456e5f7f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -38,6 +39,7 @@
    * The renderer states. One of {@link #STATE_DISABLED}, {@link #STATE_ENABLED} or {@link
    * #STATE_STARTED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_DISABLED, STATE_ENABLED, STATE_STARTED})
   @interface State {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 39f1655ab5..8517556887 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -64,7 +64,7 @@
  * be obtained from {@link ExoPlayerFactory}.
  */
 @TargetApi(16)
-public class SimpleExoPlayer
+public class SimpleExoPlayer extends BasePlayer
     implements ExoPlayer, Player.AudioComponent, Player.VideoComponent, Player.TextComponent {
 
   /** @deprecated Use {@link com.google.android.exoplayer2.video.VideoListener}. */
@@ -927,27 +927,6 @@ public boolean isLoading() {
     return player.isLoading();
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    verifyApplicationThread();
-    analyticsCollector.notifySeekStarted();
-    player.seekToDefaultPosition();
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    verifyApplicationThread();
-    analyticsCollector.notifySeekStarted();
-    player.seekToDefaultPosition(windowIndex);
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    verifyApplicationThread();
-    analyticsCollector.notifySeekStarted();
-    player.seekTo(positionMs);
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     verifyApplicationThread();
@@ -979,17 +958,6 @@ public SeekParameters getSeekParameters() {
     return player.getSeekParameters();
   }
 
-  @Override
-  public @Nullable Object getCurrentTag() {
-    verifyApplicationThread();
-    return player.getCurrentTag();
-  }
-
-  @Override
-  public void stop() {
-    stop(/* reset= */ false);
-  }
-
   @Override
   public void stop(boolean reset) {
     verifyApplicationThread();
@@ -1092,18 +1060,6 @@ public int getCurrentWindowIndex() {
     return player.getCurrentWindowIndex();
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    verifyApplicationThread();
-    return player.getNextWindowIndex();
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    verifyApplicationThread();
-    return player.getPreviousWindowIndex();
-  }
-
   @Override
   public long getDuration() {
     verifyApplicationThread();
@@ -1122,30 +1078,12 @@ public long getBufferedPosition() {
     return player.getBufferedPosition();
   }
 
-  @Override
-  public int getBufferedPercentage() {
-    verifyApplicationThread();
-    return player.getBufferedPercentage();
-  }
-
   @Override
   public long getTotalBufferedDuration() {
     verifyApplicationThread();
     return player.getTotalBufferedDuration();
   }
 
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    verifyApplicationThread();
-    return player.isCurrentWindowDynamic();
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    verifyApplicationThread();
-    return player.isCurrentWindowSeekable();
-  }
-
   @Override
   public boolean isPlayingAd() {
     verifyApplicationThread();
@@ -1164,12 +1102,6 @@ public int getCurrentAdIndexInAdGroup() {
     return player.getCurrentAdIndexInAdGroup();
   }
 
-  @Override
-  public long getContentDuration() {
-    verifyApplicationThread();
-    return player.getContentDuration();
-  }
-
   @Override
   public long getContentPosition() {
     verifyApplicationThread();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 1639920aaa..bb7f027726 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -139,9 +139,12 @@
      */
     public boolean isSeekable;
 
-    /**
-     * Whether this window may change when the timeline is updated.
-     */
+    // TODO: Split this to better describe which parts of the window might change. For example it
+    // should be possible to individually determine whether the start and end positions of the
+    // window may change relative to the underlying periods. For an example of where it's useful to
+    // know that the end position is fixed whilst the start position may still change, see:
+    // https://github.com/google/ExoPlayer/issues/4780.
+    /** Whether this window may change when the timeline is updated. */
     public boolean isDynamic;
 
     /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index 3e00bcc902..230b96d01f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -40,6 +41,7 @@
      * AC3 stream types. See also ETSI TS 102 366 E.1.3.1.1. One of {@link #STREAM_TYPE_UNDEFINED},
      * {@link #STREAM_TYPE_TYPE0}, {@link #STREAM_TYPE_TYPE1} or {@link #STREAM_TYPE_TYPE2}.
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({STREAM_TYPE_UNDEFINED, STREAM_TYPE_TYPE0, STREAM_TYPE_TYPE1, STREAM_TYPE_TYPE2})
     public @interface StreamType {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
index 92d39dec65..6a5e58ef2a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java
@@ -29,11 +29,11 @@
 @TargetApi(21)
 public final class AudioCapabilities {
 
-  /**
-   * The minimum audio capabilities supported by all devices.
-   */
+  private static final int DEFAULT_MAX_CHANNEL_COUNT = 8;
+
+  /** The minimum audio capabilities supported by all devices. */
   public static final AudioCapabilities DEFAULT_AUDIO_CAPABILITIES =
-      new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, 2);
+      new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, DEFAULT_MAX_CHANNEL_COUNT);
 
   /**
    * Returns the current audio capabilities for the device.
@@ -52,8 +52,10 @@ public static AudioCapabilities getCapabilities(Context context) {
     if (intent == null || intent.getIntExtra(AudioManager.EXTRA_AUDIO_PLUG_STATE, 0) == 0) {
       return DEFAULT_AUDIO_CAPABILITIES;
     }
-    return new AudioCapabilities(intent.getIntArrayExtra(AudioManager.EXTRA_ENCODINGS),
-        intent.getIntExtra(AudioManager.EXTRA_MAX_CHANNEL_COUNT, 0));
+    return new AudioCapabilities(
+        intent.getIntArrayExtra(AudioManager.EXTRA_ENCODINGS),
+        intent.getIntExtra(
+            AudioManager.EXTRA_MAX_CHANNEL_COUNT, /* defaultValue= */ DEFAULT_MAX_CHANNEL_COUNT));
   }
 
   private final int[] supportedEncodings;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
index 5fb571d195..7146426a4a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
@@ -56,6 +57,7 @@
    * Player commands. One of {@link #PLAYER_COMMAND_DO_NOT_PLAY}, {@link
    * #PLAYER_COMMAND_WAIT_FOR_CALLBACK} or {@link #PLAYER_COMMAND_PLAY_WHEN_READY}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     PLAYER_COMMAND_DO_NOT_PLAY,
@@ -71,6 +73,7 @@
   public static final int PLAYER_COMMAND_PLAY_WHEN_READY = 1;
 
   /** Audio focus state. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     AUDIO_FOCUS_STATE_LOST_FOCUS,
@@ -141,8 +144,8 @@ public float getVolumeMultiplier() {
    */
   public @PlayerCommand int setAudioAttributes(
       @Nullable AudioAttributes audioAttributes, boolean playWhenReady, int playerState) {
-    if (audioAttributes == null) {
-      return PLAYER_COMMAND_PLAY_WHEN_READY;
+    if (this.audioAttributes == null && audioAttributes == null) {
+      return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
     }
 
     Assertions.checkNotNull(
@@ -160,11 +163,9 @@ public float getVolumeMultiplier() {
       }
     }
 
-    if (playerState == Player.STATE_IDLE) {
-      return PLAYER_COMMAND_WAIT_FOR_CALLBACK;
-    } else {
-      return handlePrepare(playWhenReady);
-    }
+    return playerState == Player.STATE_IDLE
+        ? handleIdle(playWhenReady)
+        : handlePrepare(playWhenReady);
   }
 
   /**
@@ -196,12 +197,9 @@ public float getVolumeMultiplier() {
     if (!playWhenReady) {
       abandonAudioFocus();
       return PLAYER_COMMAND_DO_NOT_PLAY;
-    } else if (playerState != Player.STATE_IDLE) {
-      return requestAudioFocus();
     }
-    return focusGain != C.AUDIOFOCUS_NONE
-        ? PLAYER_COMMAND_WAIT_FOR_CALLBACK
-        : PLAYER_COMMAND_PLAY_WHEN_READY;
+
+    return playerState == Player.STATE_IDLE ? handleIdle(playWhenReady) : requestAudioFocus();
   }
 
   /** Called by the player as part of {@link ExoPlayer#stop(boolean)}. */
@@ -215,6 +213,11 @@ public void handleStop() {
 
   // Internal methods.
 
+  @PlayerCommand
+  private int handleIdle(boolean playWhenReady) {
+    return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;
+  }
+
   private @PlayerCommand int requestAudioFocus() {
     int focusRequestResult;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
index bb7ef22ef4..24d218bf3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
@@ -18,6 +18,7 @@
 import android.media.AudioTrack;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import java.nio.ByteBuffer;
 
@@ -165,12 +166,13 @@ public WriteException(int errorCode) {
   void setListener(Listener listener);
 
   /**
-   * Returns whether it's possible to play audio in the specified encoding.
+   * Returns whether the sink supports the audio format.
    *
-   * @param encoding The audio encoding.
-   * @return Whether it's possible to play audio in the specified encoding.
+   * @param channelCount The number of channels, or {@link Format#NO_VALUE} if not known.
+   * @param encoding The audio encoding, or {@link Format#NO_VALUE} if not known.
+   * @return Whether the sink supports the audio format.
    */
-  boolean isEncodingSupported(@C.Encoding int encoding);
+  boolean supportsOutput(int channelCount, @C.Encoding int encoding);
 
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
index 47120e7375..569260efeb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTimestampPoller.java
@@ -22,6 +22,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -45,6 +46,7 @@
 /* package */ final class AudioTimestampPoller {
 
   /** Timestamp polling states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     STATE_INITIALIZING,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
index 0095001299..62b120f00a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrackPositionTracker.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
@@ -97,6 +98,7 @@ void onSystemTimeUsMismatch(
   }
 
   /** {@link AudioTrack} playback states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYSTATE_STOPPED, PLAYSTATE_PAUSED, PLAYSTATE_PLAYING})
   private @interface PlayState {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index fbd5b027c1..429510bcaf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -30,6 +30,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -171,6 +172,9 @@ public long getSkippedOutputFrameCount() {
    */
   private static final int BUFFER_MULTIPLICATION_FACTOR = 4;
 
+  /** To avoid underruns on some devices (e.g., Broadcom 7271), scale up the AC3 buffer duration. */
+  private static final int AC3_BUFFER_MULTIPLICATION_FACTOR = 2;
+
   /**
    * @see AudioTrack#ERROR_BAD_VALUE
    */
@@ -195,12 +199,12 @@ public long getSkippedOutputFrameCount() {
 
   private static final String TAG = "AudioTrack";
 
-  /**
-   * Represents states of the {@link #startMediaTimeUs} value.
-   */
+  /** Represents states of the {@link #startMediaTimeUs} value. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({START_NOT_SET, START_IN_SYNC, START_NEED_SYNC})
   private @interface StartMediaTimeState {}
+
   private static final int START_NOT_SET = 0;
   private static final int START_IN_SYNC = 1;
   private static final int START_NEED_SYNC = 2;
@@ -373,14 +377,18 @@ public void setListener(Listener listener) {
   }
 
   @Override
-  public boolean isEncodingSupported(@C.Encoding int encoding) {
+  public boolean supportsOutput(int channelCount, @C.Encoding int encoding) {
     if (Util.isEncodingLinearPcm(encoding)) {
       // AudioTrack supports 16-bit integer PCM output in all platform API versions, and float
       // output from platform API version 21 only. Other integer PCM encodings are resampled by this
-      // sink to 16-bit PCM.
+      // sink to 16-bit PCM. We assume that the audio framework will downsample any number of
+      // channels to the output device's required number of channels.
       return encoding != C.ENCODING_PCM_FLOAT || Util.SDK_INT >= 21;
     } else {
-      return audioCapabilities != null && audioCapabilities.supportsEncoding(encoding);
+      return audioCapabilities != null
+          && audioCapabilities.supportsEncoding(encoding)
+          && (channelCount == Format.NO_VALUE
+              || channelCount <= audioCapabilities.getMaxChannelCount());
     }
   }
 
@@ -411,7 +419,7 @@ public void configure(
     isInputPcm = Util.isEncodingLinearPcm(inputEncoding);
     shouldConvertHighResIntPcmToFloat =
         enableConvertHighResIntPcmToFloat
-            && isEncodingSupported(C.ENCODING_PCM_32BIT)
+            && supportsOutput(channelCount, C.ENCODING_PCM_32BIT)
             && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
     if (isInputPcm) {
       pcmFrameSize = Util.getPcmFrameSize(inputEncoding, channelCount);
@@ -483,6 +491,9 @@ private int getDefaultBufferSize() {
       return Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
     } else {
       int rate = getMaximumEncodedRateBytesPerSecond(outputEncoding);
+      if (outputEncoding == C.ENCODING_AC3) {
+        rate *= AC3_BUFFER_MULTIPLICATION_FACTOR;
+      }
       return (int) (PASSTHROUGH_BUFFER_DURATION_US * rate / C.MICROS_PER_SECOND);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 624e698ad6..daa0447905 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -24,6 +24,7 @@
 import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.support.annotation.CallSuper;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -86,6 +87,7 @@
   private int codecMaxInputSize;
   private boolean passthroughEnabled;
   private boolean codecNeedsDiscardChannelsWorkaround;
+  private boolean codecNeedsEosBufferTimestampWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
   private @C.Encoding int pcmEncoding;
   private int channelCount;
@@ -270,12 +272,14 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
     }
     int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     boolean supportsFormatDrm = supportsFormatDrm(drmSessionManager, format.drmInitData);
-    if (supportsFormatDrm && allowPassthrough(mimeType)
+    if (supportsFormatDrm
+        && allowPassthrough(format.channelCount, mimeType)
         && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
       return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
-    if ((MimeTypes.AUDIO_RAW.equals(mimeType) && !audioSink.isEncodingSupported(format.pcmEncoding))
-        || !audioSink.isEncodingSupported(C.ENCODING_PCM_16BIT)) {
+    if ((MimeTypes.AUDIO_RAW.equals(mimeType)
+            && !audioSink.supportsOutput(format.channelCount, format.pcmEncoding))
+        || !audioSink.supportsOutput(format.channelCount, C.ENCODING_PCM_16BIT)) {
       // Assume the decoder outputs 16-bit PCM, unless the input is raw.
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -314,7 +318,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
   protected List<MediaCodecInfo> getDecoderInfos(
       MediaCodecSelector mediaCodecSelector, Format format, boolean requiresSecureDecoder)
       throws DecoderQueryException {
-    if (allowPassthrough(format.sampleMimeType)) {
+    if (allowPassthrough(format.channelCount, format.sampleMimeType)) {
       MediaCodecInfo passthroughDecoderInfo = mediaCodecSelector.getPassthroughDecoderInfo();
       if (passthroughDecoderInfo != null) {
         return Collections.singletonList(passthroughDecoderInfo);
@@ -328,12 +332,13 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
    * This implementation returns true if the {@link AudioSink} indicates that encoded audio output
    * is supported.
    *
+   * @param channelCount The number of channels in the input media, or {@link Format#NO_VALUE} if
+   *     not known.
    * @param mimeType The type of input media.
    * @return Whether passthrough playback is supported.
    */
-  protected boolean allowPassthrough(String mimeType) {
-    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
-    return encoding != C.ENCODING_INVALID && audioSink.isEncodingSupported(encoding);
+  protected boolean allowPassthrough(int channelCount, String mimeType) {
+    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));
   }
 
   @Override
@@ -345,6 +350,7 @@ protected void configureCodec(
       float codecOperatingRate) {
     codecMaxInputSize = getCodecMaxInputSize(codecInfo, format, getStreamFormats());
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
+    codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);
     passthroughEnabled = codecInfo.passthrough;
     String codecMimeType = codecInfo.mimeType == null ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;
     MediaFormat mediaFormat =
@@ -583,9 +589,9 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
     lastInputTimeUs = Math.max(buffer.timeUs, lastInputTimeUs);
   }
 
+  @CallSuper
   @Override
   protected void onProcessedOutputBuffer(long presentationTimeUs) {
-    super.onProcessedOutputBuffer(presentationTimeUs);
     while (pendingStreamChangeCount != 0 && presentationTimeUs >= pendingStreamChangeTimesUs[0]) {
       audioSink.handleDiscontinuity();
       pendingStreamChangeCount--;
@@ -610,6 +616,13 @@ protected boolean processOutputBuffer(
       boolean shouldSkip,
       Format format)
       throws ExoPlaybackException {
+    if (codecNeedsEosBufferTimestampWorkaround
+        && bufferPresentationTimeUs == 0
+        && (bufferFlags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0
+        && lastInputTimeUs != C.TIME_UNSET) {
+      bufferPresentationTimeUs = lastInputTimeUs;
+    }
+
     if (passthroughEnabled && (bufferFlags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
       // Discard output buffers from the passthrough (raw) decoder containing codec specific data.
       codec.releaseOutputBuffer(bufferIndex, false);
@@ -777,6 +790,24 @@ private static boolean codecNeedsDiscardChannelsWorkaround(String codecName) {
         || Util.DEVICE.startsWith("heroqlte"));
   }
 
+  /**
+   * Returns whether the decoder may output a non-empty buffer with timestamp 0 as the end of stream
+   * buffer.
+   *
+   * <p>See <a href="https://github.com/google/ExoPlayer/issues/5045">GitHub issue #5045</a>.
+   */
+  private static boolean codecNeedsEosBufferTimestampWorkaround(String codecName) {
+    return Util.SDK_INT < 21
+        && "OMX.SEC.mp3.dec".equals(codecName)
+        && "samsung".equals(Util.MANUFACTURER)
+        && (Util.DEVICE.startsWith("baffin")
+            || Util.DEVICE.startsWith("grand")
+            || Util.DEVICE.startsWith("fortuna")
+            || Util.DEVICE.startsWith("gprimelte")
+            || Util.DEVICE.startsWith("j2y18lte")
+            || Util.DEVICE.startsWith("ms01"));
+  }
+
   private final class AudioSinkListener implements AudioSink.Listener {
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
index 7c4eacecfb..a1ff7028c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SilenceSkippingAudioProcessor.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -54,6 +55,7 @@
   private static final byte SILENCE_THRESHOLD_LEVEL_MSB = (SILENCE_THRESHOLD_LEVEL + 128) >> 8;
 
   /** Trimming states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     STATE_NOISY,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index a527a58be4..9b6be57e4c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -43,6 +43,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -65,9 +66,13 @@
  */
 public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The decoder does not need to be re-initialized.
@@ -244,13 +249,12 @@ protected abstract int supportsFormatInternal(
       DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format);
 
   /**
-   * Returns whether the audio sink can accept audio in the specified encoding.
+   * Returns whether the sink supports the audio format.
    *
-   * @param encoding The audio encoding.
-   * @return Whether the audio sink can accept audio in the specified encoding.
+   * @see AudioSink#supportsOutput(int, int)
    */
-  protected final boolean supportsOutputEncoding(@C.Encoding int encoding) {
-    return audioSink.isEncodingSupported(encoding);
+  protected final boolean supportsOutput(int channelCount, @C.Encoding int encoding) {
+    return audioSink.supportsOutput(channelCount, encoding);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index 7a32ef128b..983c96f89d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -31,6 +32,7 @@
    * #BUFFER_REPLACEMENT_MODE_DISABLED}, {@link #BUFFER_REPLACEMENT_MODE_NORMAL} or {@link
    * #BUFFER_REPLACEMENT_MODE_DIRECT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     BUFFER_REPLACEMENT_MODE_DISABLED,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 1c49011ee4..6062a6652a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -70,6 +71,7 @@ private MissingSchemeDataException(UUID uuid) {
    * Determines the action to be done after a session acquired. One of {@link #MODE_PLAYBACK},
    * {@link #MODE_QUERY}, {@link #MODE_DOWNLOAD} or {@link #MODE_RELEASE}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({MODE_PLAYBACK, MODE_QUERY, MODE_DOWNLOAD, MODE_RELEASE})
   public @interface Mode {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index bed3545d78..f2fbe94895 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -18,6 +18,7 @@
 import android.annotation.TargetApi;
 import android.media.MediaDrm;
 import android.support.annotation.IntDef;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
@@ -43,6 +44,7 @@ public DrmSessionException(Throwable cause) {
    * The state of the DRM session. One of {@link #STATE_RELEASED}, {@link #STATE_ERROR}, {@link
    * #STATE_OPENING}, {@link #STATE_OPENED} or {@link #STATE_OPENED_WITH_KEYS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_RELEASED, STATE_ERROR, STATE_OPENING, STATE_OPENED, STATE_OPENED_WITH_KEYS})
   @interface State {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 254b524b30..d2a5b6a0d6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -70,9 +70,7 @@ private FrameworkMediaDrm(UUID uuid) throws UnsupportedSchemeException {
     Assertions.checkNotNull(uuid);
     Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
     this.uuid = uuid;
-    // ClearKey had to be accessed using the Common PSSH UUID prior to API level 27.
-    this.mediaDrm =
-        new MediaDrm(Util.SDK_INT < 27 && C.CLEARKEY_UUID.equals(uuid) ? C.COMMON_PSSH_UUID : uuid);
+    this.mediaDrm = new MediaDrm(adjustUuid(uuid));
     if (C.WIDEVINE_UUID.equals(uuid) && needsForceWidevineL3Workaround()) {
       forceWidevineL3(mediaDrm);
     }
@@ -152,7 +150,6 @@ public KeyRequest getKeyRequest(
   @Override
   public byte[] provideKeyResponse(byte[] scope, byte[] response)
       throws NotProvisionedException, DeniedByServerException {
-
     if (C.CLEARKEY_UUID.equals(uuid)) {
       response = ClearKeyUtil.adjustResponseData(response);
     }
@@ -212,8 +209,8 @@ public FrameworkMediaCrypto createMediaCrypto(byte[] initData) throws MediaCrypt
     // indicate that it required secure video decoders [Internal ref: b/11428937].
     boolean forceAllowInsecureDecoderComponents = Util.SDK_INT < 21
         && C.WIDEVINE_UUID.equals(uuid) && "L3".equals(getPropertyString("securityLevel"));
-    return new FrameworkMediaCrypto(new MediaCrypto(uuid, initData),
-        forceAllowInsecureDecoderComponents);
+    return new FrameworkMediaCrypto(
+        new MediaCrypto(adjustUuid(uuid), initData), forceAllowInsecureDecoderComponents);
   }
 
   private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas) {
@@ -269,6 +266,11 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
     return schemeDatas.get(0);
   }
 
+  private static UUID adjustUuid(UUID uuid) {
+    // ClearKey had to be accessed using the Common PSSH UUID prior to API level 27.
+    return Util.SDK_INT < 27 && C.CLEARKEY_UUID.equals(uuid) ? C.COMMON_PSSH_UUID : uuid;
+  }
+
   private static byte[] adjustRequestInitData(UUID uuid, byte[] initData) {
     // Prior to L the Widevine CDM required data to be extracted from the PSSH atom. Some Amazon
     // devices also required data to be extracted from the PSSH atom for PlayReady.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
index 5bea83d020..7f4a0f5f03 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.drm;
 
 import android.support.annotation.IntDef;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -28,6 +29,7 @@
    * The reason for the exception. One of {@link #REASON_UNSUPPORTED_SCHEME} or {@link
    * #REASON_INSTANTIATION_ERROR}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REASON_UNSUPPORTED_SCHEME, REASON_INSTANTIATION_ERROR})
   public @interface Reason {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
index 435fb13648..e8b6e736ba 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/BinarySearchSeeker.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -41,37 +42,25 @@
   protected interface TimestampSeeker {
 
     /**
-     * Searches for a given timestamp from the input.
+     * Searches a limited window of the provided input for a target timestamp. The size of the
+     * window is implementation specific, but should be small enough such that it's reasonable for
+     * multiple such reads to occur during a seek operation.
      *
-     * <p>Given a target timestamp and an input stream, this seeker will try to read up to a range
-     * of {@code searchRangeBytes} bytes from that input, look for all available timestamps from all
-     * frames in that range, compare those with the target timestamp, and return one of the {@link
-     * TimestampSearchResult}.
-     *
-     * @param input The {@link ExtractorInput} from which data should be read.
-     * @param targetTimestamp The target timestamp that we are looking for.
-     * @param outputFrameHolder If {@link TimestampSearchResult#RESULT_TARGET_TIMESTAMP_FOUND} is
+     * @param input The {@link ExtractorInput} from which data should be peeked.
+     * @param targetTimestamp The target timestamp.
+     * @param outputFrameHolder If {@link TimestampSearchResult#TYPE_TARGET_TIMESTAMP_FOUND} is
      *     returned, this holder may be updated to hold the extracted frame that contains the target
      *     frame/sample associated with the target timestamp.
-     * @return A {@link TimestampSearchResult}, that includes a {@link TimestampSearchResult#result}
-     *     value, and other necessary info:
-     *     <ul>
-     *       <li>{@link TimestampSearchResult#RESULT_NO_TIMESTAMP} is returned if there is no
-     *           timestamp in the reading range.
-     *       <li>{@link TimestampSearchResult#RESULT_POSITION_UNDERESTIMATED} is returned if all
-     *           timestamps in the range are smaller than the target timestamp.
-     *       <li>{@link TimestampSearchResult#RESULT_POSITION_OVERESTIMATED} is returned if all
-     *           timestamps in the range are larger than the target timestamp.
-     *       <li>{@link TimestampSearchResult#RESULT_TARGET_TIMESTAMP_FOUND} is returned if this
-     *           seeker can find a timestamp that it deems close enough to the given target.
-     *     </ul>
-     *
+     * @return A {@link TimestampSearchResult} that describes the result of the search.
      * @throws IOException If an error occurred reading from the input.
      * @throws InterruptedException If the thread was interrupted.
      */
     TimestampSearchResult searchForTimestamp(
         ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
         throws IOException, InterruptedException;
+
+    /** Called when a seek operation finishes. */
+    default void onSeekFinished() {}
   }
 
   /**
@@ -230,22 +219,22 @@ public int handlePendingSeek(
           timestampSeeker.searchForTimestamp(
               input, seekOperationParams.getTargetTimePosition(), outputFrameHolder);
 
-      switch (timestampSearchResult.result) {
-        case TimestampSearchResult.RESULT_POSITION_OVERESTIMATED:
+      switch (timestampSearchResult.type) {
+        case TimestampSearchResult.TYPE_POSITION_OVERESTIMATED:
           seekOperationParams.updateSeekCeiling(
               timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);
           break;
-        case TimestampSearchResult.RESULT_POSITION_UNDERESTIMATED:
+        case TimestampSearchResult.TYPE_POSITION_UNDERESTIMATED:
           seekOperationParams.updateSeekFloor(
               timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);
           break;
-        case TimestampSearchResult.RESULT_TARGET_TIMESTAMP_FOUND:
+        case TimestampSearchResult.TYPE_TARGET_TIMESTAMP_FOUND:
           markSeekOperationFinished(
               /* foundTargetFrame= */ true, timestampSearchResult.bytePositionToUpdate);
           skipInputUntilPosition(input, timestampSearchResult.bytePositionToUpdate);
           return seekToPosition(
               input, timestampSearchResult.bytePositionToUpdate, seekPositionHolder);
-        case TimestampSearchResult.RESULT_NO_TIMESTAMP:
+        case TimestampSearchResult.TYPE_NO_TIMESTAMP:
           // We can't find any timestamp in the search range from the search position.
           // Give up, and just continue reading from the last search position in this case.
           markSeekOperationFinished(/* foundTargetFrame= */ false, searchPosition);
@@ -269,6 +258,7 @@ protected SeekOperationParams createSeekParamsForTargetTimeUs(long timeUs) {
 
   protected final void markSeekOperationFinished(boolean foundTargetFrame, long resultPosition) {
     seekOperationParams = null;
+    timestampSeeker.onSeekFinished();
     onSeekOperationFinished(foundTargetFrame, resultPosition);
   }
 
@@ -432,44 +422,49 @@ private void updateNextSearchBytePosition() {
    */
   public static final class TimestampSearchResult {
 
-    public static final int RESULT_TARGET_TIMESTAMP_FOUND = 0;
-    public static final int RESULT_POSITION_OVERESTIMATED = -1;
-    public static final int RESULT_POSITION_UNDERESTIMATED = -2;
-    public static final int RESULT_NO_TIMESTAMP = -3;
+    /** The search found a timestamp that it deems close enough to the given target. */
+    public static final int TYPE_TARGET_TIMESTAMP_FOUND = 0;
+    /** The search found only timestamps larger than the target timestamp. */
+    public static final int TYPE_POSITION_OVERESTIMATED = -1;
+    /** The search found only timestamps smaller than the target timestamp. */
+    public static final int TYPE_POSITION_UNDERESTIMATED = -2;
+    /** The search didn't find any timestamps. */
+    public static final int TYPE_NO_TIMESTAMP = -3;
 
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
-      RESULT_TARGET_TIMESTAMP_FOUND,
-      RESULT_POSITION_OVERESTIMATED,
-      RESULT_POSITION_UNDERESTIMATED,
-      RESULT_NO_TIMESTAMP
+      TYPE_TARGET_TIMESTAMP_FOUND,
+      TYPE_POSITION_OVERESTIMATED,
+      TYPE_POSITION_UNDERESTIMATED,
+      TYPE_NO_TIMESTAMP
     })
-    @interface SearchResult {}
+    @interface Type {}
 
     public static final TimestampSearchResult NO_TIMESTAMP_IN_RANGE_RESULT =
-        new TimestampSearchResult(RESULT_NO_TIMESTAMP, C.TIME_UNSET, C.POSITION_UNSET);
+        new TimestampSearchResult(TYPE_NO_TIMESTAMP, C.TIME_UNSET, C.POSITION_UNSET);
 
-    /** @see TimestampSeeker */
-    private final @SearchResult int result;
+    /** The type of the result. */
+    @Type private final int type;
 
     /**
-     * When {@code result} is {@link #RESULT_POSITION_OVERESTIMATED}, the {@link
-     * SeekOperationParams#ceilingTimePosition} should be updated with this value. When {@code
-     * result} is {@link #RESULT_POSITION_UNDERESTIMATED}, the {@link
+     * When {@link #type} is {@link #TYPE_POSITION_OVERESTIMATED}, the {@link
+     * SeekOperationParams#ceilingTimePosition} should be updated with this value. When {@link
+     * #type} is {@link #TYPE_POSITION_UNDERESTIMATED}, the {@link
      * SeekOperationParams#floorTimePosition} should be updated with this value.
      */
     private final long timestampToUpdate;
     /**
-     * When {@code result} is {@link #RESULT_POSITION_OVERESTIMATED}, the {@link
-     * SeekOperationParams#ceilingBytePosition} should be updated with this value. When {@code
-     * result} is {@link #RESULT_POSITION_UNDERESTIMATED}, the {@link
+     * When {@link #type} is {@link #TYPE_POSITION_OVERESTIMATED}, the {@link
+     * SeekOperationParams#ceilingBytePosition} should be updated with this value. When {@link
+     * #type} is {@link #TYPE_POSITION_UNDERESTIMATED}, the {@link
      * SeekOperationParams#floorBytePosition} should be updated with this value.
      */
     private final long bytePositionToUpdate;
 
     private TimestampSearchResult(
-        @SearchResult int result, long timestampToUpdate, long bytePositionToUpdate) {
-      this.result = result;
+        @Type int type, long timestampToUpdate, long bytePositionToUpdate) {
+      this.type = type;
       this.timestampToUpdate = timestampToUpdate;
       this.bytePositionToUpdate = bytePositionToUpdate;
     }
@@ -482,7 +477,7 @@ private TimestampSearchResult(
     public static TimestampSearchResult overestimatedResult(
         long newCeilingTimestamp, long newCeilingBytePosition) {
       return new TimestampSearchResult(
-          RESULT_POSITION_OVERESTIMATED, newCeilingTimestamp, newCeilingBytePosition);
+          TYPE_POSITION_OVERESTIMATED, newCeilingTimestamp, newCeilingBytePosition);
     }
 
     /**
@@ -493,11 +488,11 @@ public static TimestampSearchResult overestimatedResult(
     public static TimestampSearchResult underestimatedResult(
         long newFloorTimestamp, long newCeilingBytePosition) {
       return new TimestampSearchResult(
-          RESULT_POSITION_UNDERESTIMATED, newFloorTimestamp, newCeilingBytePosition);
+          TYPE_POSITION_UNDERESTIMATED, newFloorTimestamp, newCeilingBytePosition);
     }
 
     /**
-     * Returns a result to signal that the target timestamp has been found at the {@code
+     * Returns a result to signal that the target timestamp has been found at {@code
      * resultBytePosition}, and the seek operation can stop.
      *
      * <p>Note that when this value is returned from {@link
@@ -506,7 +501,7 @@ public static TimestampSearchResult underestimatedResult(
      */
     public static TimestampSearchResult targetFoundResult(long resultBytePosition) {
       return new TimestampSearchResult(
-          RESULT_TARGET_TIMESTAMP_FOUND, C.TIME_UNSET, resultBytePosition);
+          TYPE_TARGET_TIMESTAMP_FOUND, C.TIME_UNSET, resultBytePosition);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index c3f6304091..450cca42b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -130,16 +130,16 @@ public void peekFully(byte[] target, int offset, int length)
   public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
     ensureSpaceForPeek(length);
-    int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
+    int bytesPeeked = peekBufferLength - peekBufferPosition;
     while (bytesPeeked < length) {
       bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
           allowEndOfInput);
       if (bytesPeeked == C.RESULT_END_OF_INPUT) {
         return false;
       }
+      peekBufferLength = peekBufferPosition + bytesPeeked;
     }
     peekBufferPosition += length;
-    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
     return true;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 26d0788b33..05f5d98d3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -18,6 +18,7 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -48,6 +49,7 @@
    * Result values that can be returned by {@link #read(ExtractorInput, PositionHolder)}. One of
    * {@link #RESULT_CONTINUE}, {@link #RESULT_SEEK} or {@link #RESULT_END_OF_INPUT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {RESULT_CONTINUE, RESULT_SEEK, RESULT_END_OF_INPUT})
   @interface ReadResult {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
index 0742d96a06..a0effc0df8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
 import com.google.android.exoplayer2.metadata.id3.InternalFrame;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -28,15 +27,6 @@
  */
 public final class GaplessInfoHolder {
 
-  /**
-   * A {@link FramePredicate} suitable for use when decoding {@link Metadata} that will be passed to
-   * {@link #setFromMetadata(Metadata)}. Only frames that might contain gapless playback information
-   * are decoded.
-   */
-  public static final FramePredicate GAPLESS_INFO_ID3_FRAME_PREDICATE =
-      (majorVersion, id0, id1, id2, id3) ->
-          id0 == 'C' && id1 == 'O' && id2 == 'M' && (id3 == 'M' || majorVersion == 2);
-
   private static final String GAPLESS_DOMAIN = "com.apple.iTunes";
   private static final String GAPLESS_DESCRIPTION = "iTunSMPB";
   private static final Pattern GAPLESS_COMMENT_PATTERN =
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
index dfdce02450..b93969acfe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/amr/AmrExtractor.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -51,6 +52,7 @@
    * Flags controlling the behavior of the extractor. Possible flag value is {@link
    * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 604a520526..4211cab489 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -37,13 +38,17 @@
   /** Factory for {@link FlvExtractor} instances. */
   public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new FlvExtractor()};
 
-  /**
-   * Extractor states.
-   */
+  /** Extractor states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({STATE_READING_FLV_HEADER, STATE_SKIPPING_TO_TAG_HEADER, STATE_READING_TAG_HEADER,
-      STATE_READING_TAG_DATA})
+  @IntDef({
+    STATE_READING_FLV_HEADER,
+    STATE_SKIPPING_TO_TAG_HEADER,
+    STATE_READING_TAG_HEADER,
+    STATE_READING_TAG_DATA
+  })
   private @interface States {}
+
   private static final int STATE_READING_FLV_HEADER = 1;
   private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
   private static final int STATE_READING_TAG_HEADER = 3;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
index c0494e1ee0..0987bc473f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -31,6 +32,7 @@
  */
 /* package */ final class DefaultEbmlReader implements EbmlReader {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({ELEMENT_STATE_READ_ID, ELEMENT_STATE_READ_CONTENT_SIZE, ELEMENT_STATE_READ_CONTENT})
   private @interface ElementState {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
index 067c88b552..cc17af5632 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/EbmlReaderOutput.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -31,6 +32,7 @@
    * EBML element types. One of {@link #TYPE_UNKNOWN}, {@link #TYPE_MASTER}, {@link
    * #TYPE_UNSIGNED_INT}, {@link #TYPE_STRING}, {@link #TYPE_BINARY} or {@link #TYPE_FLOAT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNKNOWN, TYPE_MASTER, TYPE_UNSIGNED_INT, TYPE_STRING, TYPE_BINARY, TYPE_FLOAT})
   @interface ElementType {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 35b6969084..86b750e821 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -45,6 +45,7 @@
 import com.google.android.exoplayer2.video.ColorInfo;
 import com.google.android.exoplayer2.video.HevcConfig;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -68,6 +69,7 @@
    * Flags controlling the behavior of the extractor. Possible flag value is {@link
    * #FLAG_DISABLE_SEEK_FOR_CUES}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -155,6 +157,7 @@
   private static final int ID_FLAG_DEFAULT = 0x88;
   private static final int ID_FLAG_FORCED = 0x55AA;
   private static final int ID_DEFAULT_DURATION = 0x23E383;
+  private static final int ID_NAME = 0x536E;
   private static final int ID_CODEC_ID = 0x86;
   private static final int ID_CODEC_PRIVATE = 0x63A2;
   private static final int ID_CODEC_DELAY = 0x56AA;
@@ -813,6 +816,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           throw new ParserException("DocType " + value + " not supported");
         }
         break;
+      case ID_NAME:
+        currentTrack.name = value;
+        break;
       case ID_CODEC_ID:
         currentTrack.codecId = value;
         break;
@@ -1461,6 +1467,7 @@ public int getElementType(int id) {
         case ID_MAX_FALL:
           return TYPE_UNSIGNED_INT;
         case ID_DOC_TYPE:
+        case ID_NAME:
         case ID_CODEC_ID:
         case ID_LANGUAGE:
           return TYPE_STRING;
@@ -1607,6 +1614,7 @@ public void outputPendingSampleMetadata(Track track) {
     private static final int DEFAULT_MAX_FALL = 200;  // nits.
 
     // Common elements.
+    public String name;
     public String codecId;
     public int number;
     public int type;
@@ -1831,10 +1839,34 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           byte[] hdrStaticInfo = getHdrStaticInfo();
           colorInfo = new ColorInfo(colorSpace, colorRange, colorTransfer, hdrStaticInfo);
         }
-        format = Format.createVideoSampleFormat(Integer.toString(trackId), mimeType, null,
-            Format.NO_VALUE, maxInputSize, width, height, Format.NO_VALUE, initializationData,
-            Format.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode, colorInfo,
-            drmInitData);
+        int rotationDegrees = Format.NO_VALUE;
+        // Some HTC devices signal rotation in track names.
+        if ("htc_video_rotA-000".equals(name)) {
+          rotationDegrees = 0;
+        } else if ("htc_video_rotA-090".equals(name)) {
+          rotationDegrees = 90;
+        } else if ("htc_video_rotA-180".equals(name)) {
+          rotationDegrees = 180;
+        } else if ("htc_video_rotA-270".equals(name)) {
+          rotationDegrees = 270;
+        }
+        format =
+            Format.createVideoSampleFormat(
+                Integer.toString(trackId),
+                mimeType,
+                /* codecs= */ null,
+                /* bitrate= */ Format.NO_VALUE,
+                maxInputSize,
+                width,
+                height,
+                /* frameRate= */ Format.NO_VALUE,
+                initializationData,
+                rotationDegrees,
+                pixelWidthHeightRatio,
+                projectionData,
+                stereoMode,
+                colorInfo,
+                drmInitData);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         type = C.TRACK_TYPE_TEXT;
         format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, selectionFlags,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
index bffc43a540..f400720772 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
@@ -39,4 +39,9 @@ public ConstantBitrateSeeker(
   public long getTimeUs(long position) {
     return getTimeUsAtPosition(position);
   }
+
+  @Override
+  public long getDataEndPosition() {
+    return C.POSITION_UNSET;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
new file mode 100644
index 0000000000..868c1d9fbf
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/MlltSeeker.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp3;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.metadata.id3.MlltFrame;
+import com.google.android.exoplayer2.util.Util;
+
+/** MP3 seeker that uses metadata from an {@link MlltFrame}. */
+/* package */ final class MlltSeeker implements Mp3Extractor.Seeker {
+
+  /**
+   * Returns an {@link MlltSeeker} for seeking in the stream.
+   *
+   * @param firstFramePosition The position of the start of the first frame in the stream.
+   * @param mlltFrame The MLLT frame with seeking metadata.
+   * @return An {@link MlltSeeker} for seeking in the stream.
+   */
+  public static MlltSeeker create(long firstFramePosition, MlltFrame mlltFrame) {
+    int referenceCount = mlltFrame.bytesDeviations.length;
+    long[] referencePositions = new long[1 + referenceCount];
+    long[] referenceTimesMs = new long[1 + referenceCount];
+    referencePositions[0] = firstFramePosition;
+    referenceTimesMs[0] = 0;
+    long position = firstFramePosition;
+    long timeMs = 0;
+    for (int i = 1; i <= referenceCount; i++) {
+      position += mlltFrame.bytesBetweenReference + mlltFrame.bytesDeviations[i - 1];
+      timeMs += mlltFrame.millisecondsBetweenReference + mlltFrame.millisecondsDeviations[i - 1];
+      referencePositions[i] = position;
+      referenceTimesMs[i] = timeMs;
+    }
+    return new MlltSeeker(referencePositions, referenceTimesMs);
+  }
+
+  private final long[] referencePositions;
+  private final long[] referenceTimesMs;
+  private final long durationUs;
+
+  private MlltSeeker(long[] referencePositions, long[] referenceTimesMs) {
+    this.referencePositions = referencePositions;
+    this.referenceTimesMs = referenceTimesMs;
+    // Use the last reference point as the duration, as extrapolating variable bitrate at the end of
+    // the stream may give a large error.
+    durationUs = C.msToUs(referenceTimesMs[referenceTimesMs.length - 1]);
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public SeekPoints getSeekPoints(long timeUs) {
+    timeUs = Util.constrainValue(timeUs, 0, durationUs);
+    Pair<Long, Long> timeMsAndPosition =
+        linearlyInterpolate(C.usToMs(timeUs), referenceTimesMs, referencePositions);
+    timeUs = C.msToUs(timeMsAndPosition.first);
+    long position = timeMsAndPosition.second;
+    return new SeekPoints(new SeekPoint(timeUs, position));
+  }
+
+  @Override
+  public long getTimeUs(long position) {
+    Pair<Long, Long> positionAndTimeMs =
+        linearlyInterpolate(position, referencePositions, referenceTimesMs);
+    return C.msToUs(positionAndTimeMs.second);
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Given a set of reference points as coordinates in {@code xReferences} and {@code yReferences}
+   * and an x-axis value, linearly interpolates between corresponding reference points to give a
+   * y-axis value.
+   *
+   * @param x The x-axis value for which a y-axis value is needed.
+   * @param xReferences x coordinates of reference points.
+   * @param yReferences y coordinates of reference points.
+   * @return The linearly interpolated y-axis value.
+   */
+  private static Pair<Long, Long> linearlyInterpolate(
+      long x, long[] xReferences, long[] yReferences) {
+    int previousReferenceIndex =
+        Util.binarySearchFloor(xReferences, x, /* inclusive= */ true, /* stayInBounds= */ true);
+    long xPreviousReference = xReferences[previousReferenceIndex];
+    long yPreviousReference = yReferences[previousReferenceIndex];
+    int nextReferenceIndex = previousReferenceIndex + 1;
+    if (nextReferenceIndex == xReferences.length) {
+      return Pair.create(xPreviousReference, yPreviousReference);
+    } else {
+      long xNextReference = xReferences[nextReferenceIndex];
+      long yNextReference = yReferences[nextReferenceIndex];
+      double proportion =
+          xNextReference == xPreviousReference
+              ? 0.0
+              : ((double) x - xPreviousReference) / (xNextReference - xPreviousReference);
+      long y = (long) (proportion * (yNextReference - yPreviousReference)) + yPreviousReference;
+      return Pair.create(x, y);
+    }
+  }
+
+  @Override
+  public long getDataEndPosition() {
+    return C.POSITION_UNSET;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index 26a8bcce75..e8848bf983 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp3;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -31,10 +32,13 @@
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
+import com.google.android.exoplayer2.metadata.id3.MlltFrame;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -50,6 +54,7 @@
    * Flags controlling the behavior of the extractor. Possible flag values are {@link
    * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING} and {@link #FLAG_DISABLE_ID3_METADATA}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -66,6 +71,12 @@
    */
   public static final int FLAG_DISABLE_ID3_METADATA = 2;
 
+  /** Predicate that matches ID3 frames containing only required gapless/seeking metadata. */
+  private static final FramePredicate REQUIRED_ID3_FRAME_PREDICATE =
+      (majorVersion, id0, id1, id2, id3) ->
+          ((id0 == 'C' && id1 == 'O' && id2 == 'M' && (id3 == 'M' || majorVersion == 2))
+              || (id0 == 'M' && id1 == 'L' && id2 == 'L' && (id3 == 'T' || majorVersion == 2)));
+
   /**
    * The maximum number of bytes to search when synchronizing, before giving up.
    */
@@ -172,7 +183,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       }
     }
     if (seeker == null) {
-      seeker = maybeReadSeekFrame(input);
+      // Read past any seek frame and set the seeker based on metadata or a seek frame. Metadata
+      // takes priority as it can provide greater precision.
+      Seeker seekFrameSeeker = maybeReadSeekFrame(input);
+      Seeker metadataSeeker = maybeHandleSeekMetadata(metadata, input.getPosition());
+      if (metadataSeeker != null) {
+        seeker = metadataSeeker;
+      } else if (seekFrameSeeker != null) {
+        seeker = seekFrameSeeker;
+      }
       if (seeker == null
           || (!seeker.isSeekable() && (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0)) {
         seeker = getConstantBitrateSeeker(input);
@@ -204,7 +223,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (sampleBytesRemaining == 0) {
       extractorInput.resetPeekPosition();
-      if (!extractorInput.peekFully(scratch.data, 0, 4, true)) {
+      if (peekEndOfStreamOrHeader(extractorInput)) {
         return RESULT_END_OF_INPUT;
       }
       scratch.setPosition(0);
@@ -251,11 +270,11 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     int searchLimitBytes = sniffing ? MAX_SNIFF_BYTES : MAX_SYNC_BYTES;
     input.resetPeekPosition();
     if (input.getPosition() == 0) {
-      // We need to parse enough ID3 metadata to retrieve any gapless playback information even
-      // if ID3 metadata parsing is disabled.
-      boolean onlyDecodeGaplessInfoFrames = (flags & FLAG_DISABLE_ID3_METADATA) != 0;
+      // We need to parse enough ID3 metadata to retrieve any gapless/seeking playback information
+      // even if ID3 metadata parsing is disabled.
+      boolean parseAllId3Frames = (flags & FLAG_DISABLE_ID3_METADATA) == 0;
       Id3Decoder.FramePredicate id3FramePredicate =
-          onlyDecodeGaplessInfoFrames ? GaplessInfoHolder.GAPLESS_INFO_ID3_FRAME_PREDICATE : null;
+          parseAllId3Frames ? null : REQUIRED_ID3_FRAME_PREDICATE;
       metadata = id3Peeker.peekId3Data(input, id3FramePredicate);
       if (metadata != null) {
         gaplessInfoHolder.setFromMetadata(metadata);
@@ -266,9 +285,12 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
       }
     }
     while (true) {
-      if (!input.peekFully(scratch.data, 0, 4, validFrameCount > 0)) {
-        // We reached the end of the stream but found at least one valid frame.
-        break;
+      if (peekEndOfStreamOrHeader(input)) {
+        if (validFrameCount > 0) {
+          // We reached the end of the stream but found at least one valid frame.
+          break;
+        }
+        throw new EOFException();
       }
       scratch.setPosition(0);
       int headerData = scratch.readInt();
@@ -313,6 +335,17 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     return true;
   }
 
+  /**
+   * Returns whether the extractor input is peeking the end of the stream. If {@code false},
+   * populates the scratch buffer with the next four bytes.
+   */
+  private boolean peekEndOfStreamOrHeader(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    return (seeker != null && extractorInput.getPeekPosition() == seeker.getDataEndPosition())
+        || !extractorInput.peekFully(
+            scratch.data, /* offset= */ 0, /* length= */ 4, /* allowEndOfInput= */ true);
+  }
+
   /**
    * Consumes the next frame from the {@code input} if it contains VBRI or Xing seeking metadata,
    * returning a {@link Seeker} if the metadata was present and valid, or {@code null} otherwise.
@@ -399,9 +432,24 @@ private static int getSeekFrameHeader(ParsableByteArray frame, int xingBase) {
     return SEEK_HEADER_UNSET;
   }
 
+  @Nullable
+  private static MlltSeeker maybeHandleSeekMetadata(Metadata metadata, long firstFramePosition) {
+    if (metadata != null) {
+      int length = metadata.length();
+      for (int i = 0; i < length; i++) {
+        Metadata.Entry entry = metadata.get(i);
+        if (entry instanceof MlltFrame) {
+          return MlltSeeker.create(firstFramePosition, (MlltFrame) entry);
+        }
+      }
+    }
+    return null;
+  }
+
   /**
-   * {@link SeekMap} that also allows mapping from position (byte offset) back to time, which can be
-   * used to work out the new sample basis timestamp after seeking and resynchronization.
+   * {@link SeekMap} that provides the end position of audio data and also allows mapping from
+   * position (byte offset) back to time, which can be used to work out the new sample basis
+   * timestamp after seeking and resynchronization.
    */
   /* package */ interface Seeker extends SeekMap {
 
@@ -413,6 +461,11 @@ private static int getSeekFrameHeader(ParsableByteArray frame, int xingBase) {
      */
     long getTimeUs(long position);
 
+    /**
+     * Returns the position (byte offset) in the stream that is immediately after audio data, or
+     * {@link C#POSITION_UNSET} if not known.
+     */
+    long getDataEndPosition();
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
index 774505f622..15e778115d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
@@ -89,17 +89,19 @@
     if (inputLength != C.LENGTH_UNSET && inputLength != position) {
       Log.w(TAG, "VBRI data size mismatch: " + inputLength + ", " + position);
     }
-    return new VbriSeeker(timesUs, positions, durationUs);
+    return new VbriSeeker(timesUs, positions, durationUs, /* dataEndPosition= */ position);
   }
 
   private final long[] timesUs;
   private final long[] positions;
   private final long durationUs;
+  private final long dataEndPosition;
 
-  private VbriSeeker(long[] timesUs, long[] positions, long durationUs) {
+  private VbriSeeker(long[] timesUs, long[] positions, long durationUs, long dataEndPosition) {
     this.timesUs = timesUs;
     this.positions = positions;
     this.durationUs = durationUs;
+    this.dataEndPosition = dataEndPosition;
   }
 
   @Override
@@ -129,4 +131,8 @@ public long getDurationUs() {
     return durationUs;
   }
 
+  @Override
+  public long getDataEndPosition() {
+    return dataEndPosition;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
index c2971e47ce..42752e55fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
@@ -75,17 +75,17 @@
     if (inputLength != C.LENGTH_UNSET && inputLength != position + dataSize) {
       Log.w(TAG, "XING data size mismatch: " + inputLength + ", " + (position + dataSize));
     }
-    return new XingSeeker(position, mpegAudioHeader.frameSize, durationUs, dataSize,
-        tableOfContents);
+    return new XingSeeker(
+        position, mpegAudioHeader.frameSize, durationUs, dataSize, tableOfContents);
   }
 
   private final long dataStartPosition;
   private final int xingFrameSize;
   private final long durationUs;
-  /**
-   * Data size, including the XING frame.
-   */
+  /** Data size, including the XING frame. */
   private final long dataSize;
+
+  private final long dataEndPosition;
   /**
    * Entries are in the range [0, 255], but are stored as long integers for convenience. Null if the
    * table of contents was missing from the header, in which case seeking is not be supported.
@@ -93,7 +93,12 @@
   private final @Nullable long[] tableOfContents;
 
   private XingSeeker(long dataStartPosition, int xingFrameSize, long durationUs) {
-    this(dataStartPosition, xingFrameSize, durationUs, C.LENGTH_UNSET, null);
+    this(
+        dataStartPosition,
+        xingFrameSize,
+        durationUs,
+        /* dataSize= */ C.LENGTH_UNSET,
+        /* tableOfContents= */ null);
   }
 
   private XingSeeker(
@@ -105,8 +110,9 @@ private XingSeeker(
     this.dataStartPosition = dataStartPosition;
     this.xingFrameSize = xingFrameSize;
     this.durationUs = durationUs;
-    this.dataSize = dataSize;
     this.tableOfContents = tableOfContents;
+    this.dataSize = dataSize;
+    dataEndPosition = dataSize == C.LENGTH_UNSET ? C.POSITION_UNSET : dataStartPosition + dataSize;
   }
 
   @Override
@@ -166,6 +172,11 @@ public long getDurationUs() {
     return durationUs;
   }
 
+  @Override
+  public long getDataEndPosition() {
+    return dataEndPosition;
+  }
+
   /**
    * Returns the time in microseconds for a given table index.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index 3b85c3d2e3..f51c97389b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -145,6 +145,10 @@
   public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
   public static final int TYPE_alaw = Util.getIntegerCodeForString("alaw");
   public static final int TYPE_ulaw = Util.getIntegerCodeForString("ulaw");
+  public static final int TYPE_Opus = Util.getIntegerCodeForString("Opus");
+  public static final int TYPE_dOps = Util.getIntegerCodeForString("dOps");
+  public static final int TYPE_fLaC = Util.getIntegerCodeForString("fLaC");
+  public static final int TYPE_dfLa = Util.getIntegerCodeForString("dfLa");
 
   public final int type;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 7104630a23..d085156f2b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -58,6 +58,9 @@
    */
   private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 3;
 
+  /** The magic signature for an Opus Identification header, as defined in RFC-7845. */
+  private static final byte[] opusMagic = Util.getUtf8Bytes("OpusHead");
+
   /**
    * Parses a trak atom (defined in 14496-12).
    *
@@ -221,11 +224,20 @@ public static TrackSampleTable parseStbl(
 
       for (int i = 0; i < sampleCount; i++) {
         // Advance to the next chunk if necessary.
-        while (remainingSamplesInChunk == 0) {
-          Assertions.checkState(chunkIterator.moveNext());
+        boolean chunkDataComplete = true;
+        while (remainingSamplesInChunk == 0 && (chunkDataComplete = chunkIterator.moveNext())) {
           offset = chunkIterator.offset;
           remainingSamplesInChunk = chunkIterator.numSamples;
         }
+        if (!chunkDataComplete) {
+          Log.w(TAG, "Unexpected end of chunk data");
+          sampleCount = i;
+          offsets = Arrays.copyOf(offsets, sampleCount);
+          sizes = Arrays.copyOf(sizes, sampleCount);
+          timestamps = Arrays.copyOf(timestamps, sampleCount);
+          flags = Arrays.copyOf(flags, sampleCount);
+          break;
+        }
 
         // Add on the timestamp offset if ctts is present.
         if (ctts != null) {
@@ -279,23 +291,38 @@ public static TrackSampleTable parseStbl(
       }
       duration = timestampTimeUnits + timestampOffset;
 
-      Assertions.checkArgument(remainingSamplesAtTimestampOffset == 0);
-      // Remove trailing ctts entries with 0-valued sample counts.
+      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
+      // still be playable.
+      boolean isCttsValid = true;
       while (remainingTimestampOffsetChanges > 0) {
-        Assertions.checkArgument(ctts.readUnsignedIntToInt() == 0);
+        if (ctts.readUnsignedIntToInt() != 0) {
+          isCttsValid = false;
+          break;
+        }
         ctts.readInt(); // Ignore offset.
         remainingTimestampOffsetChanges--;
       }
-
-      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
-      // still be playable.
-      if (remainingSynchronizationSamples != 0 || remainingSamplesAtTimestampDelta != 0
-          || remainingSamplesInChunk != 0 || remainingTimestampDeltaChanges != 0) {
-        Log.w(TAG, "Inconsistent stbl box for track " + track.id
-            + ": remainingSynchronizationSamples " + remainingSynchronizationSamples
-            + ", remainingSamplesAtTimestampDelta " + remainingSamplesAtTimestampDelta
-            + ", remainingSamplesInChunk " + remainingSamplesInChunk
-            + ", remainingTimestampDeltaChanges " + remainingTimestampDeltaChanges);
+      if (remainingSynchronizationSamples != 0
+          || remainingSamplesAtTimestampDelta != 0
+          || remainingSamplesInChunk != 0
+          || remainingTimestampDeltaChanges != 0
+          || remainingSamplesAtTimestampOffset != 0
+          || !isCttsValid) {
+        Log.w(
+            TAG,
+            "Inconsistent stbl box for track "
+                + track.id
+                + ": remainingSynchronizationSamples "
+                + remainingSynchronizationSamples
+                + ", remainingSamplesAtTimestampDelta "
+                + remainingSamplesAtTimestampDelta
+                + ", remainingSamplesInChunk "
+                + remainingSamplesInChunk
+                + ", remainingTimestampDeltaChanges "
+                + remainingTimestampDeltaChanges
+                + ", remainingSamplesAtTimestampOffset "
+                + remainingSamplesAtTimestampOffset
+                + (!isCttsValid ? ", ctts invalid" : ""));
       }
     } else {
       long[] chunkOffsetsBytes = new long[chunkIterator.length];
@@ -668,7 +695,9 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
           || childAtomType == Atom.TYPE__mp3
           || childAtomType == Atom.TYPE_alac
           || childAtomType == Atom.TYPE_alaw
-          || childAtomType == Atom.TYPE_ulaw) {
+          || childAtomType == Atom.TYPE_ulaw
+          || childAtomType == Atom.TYPE_Opus
+          || childAtomType == Atom.TYPE_fLaC) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             language, isQuickTime, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_TTML || childAtomType == Atom.TYPE_tx3g
@@ -965,6 +994,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_ALAW;
     } else if (atomType == Atom.TYPE_ulaw) {
       mimeType = MimeTypes.AUDIO_MLAW;
+    } else if (atomType == Atom.TYPE_Opus) {
+      mimeType = MimeTypes.AUDIO_OPUS;
+    } else if (atomType == Atom.TYPE_fLaC) {
+      mimeType = MimeTypes.AUDIO_FLAC;
     }
 
     byte[] initializationData = null;
@@ -1005,7 +1038,20 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       } else if (childAtomType == Atom.TYPE_alac) {
         initializationData = new byte[childAtomSize];
         parent.setPosition(childPosition);
-        parent.readBytes(initializationData, 0, childAtomSize);
+        parent.readBytes(initializationData, /* offset= */ 0, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_dOps) {
+        // Build an Opus Identification Header (defined in RFC-7845) by concatenating the Opus Magic
+        // Signature and the body of the dOps atom.
+        int childAtomBodySize = childAtomSize - Atom.HEADER_SIZE;
+        initializationData = new byte[opusMagic.length + childAtomBodySize];
+        System.arraycopy(opusMagic, 0, initializationData, 0, opusMagic.length);
+        parent.setPosition(childPosition + Atom.HEADER_SIZE);
+        parent.readBytes(initializationData, opusMagic.length, childAtomBodySize);
+      } else if (childAtomSize == Atom.TYPE_dfLa) {
+        int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
+        initializationData = new byte[childAtomBodySize];
+        parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
+        parent.readBytes(initializationData, /* offset= */ 0, childAtomBodySize);
       }
       childPosition += childAtomSize;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index d8adcde28c..0f1fd8f649 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -43,6 +43,7 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -67,6 +68,7 @@
    * {@link #FLAG_ENABLE_EMSG_TRACK}, {@link #FLAG_SIDELOADED} and {@link
    * #FLAG_WORKAROUND_IGNORE_EDIT_LISTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 7cf61b4ff3..17c82c2c5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -35,6 +35,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayDeque;
@@ -53,6 +54,7 @@
    * Flags controlling the behavior of the extractor. Possible flag value is {@link
    * #FLAG_WORKAROUND_IGNORE_EDIT_LISTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -63,12 +65,12 @@
    */
   public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 1;
 
-  /**
-   * Parser states.
-   */
+  /** Parser states. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_READING_ATOM_HEADER, STATE_READING_ATOM_PAYLOAD, STATE_READING_SAMPLE})
   private @interface State {}
+
   private static final int STATE_READING_ATOM_HEADER = 0;
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_SAMPLE = 2;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 867e037f4b..59cd602209 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -19,6 +19,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -31,6 +32,7 @@
    * The transformation to apply to samples in the track, if any. One of {@link
    * #TRANSFORMATION_NONE} or {@link #TRANSFORMATION_CEA608_CDAT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TRANSFORMATION_NONE, TRANSFORMATION_CEA608_CDAT})
   public @interface Transformation {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 4141f83370..2ef9704a7a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -33,9 +34,11 @@
  */
 public final class Ac3Reader implements ElementaryStreamReader {
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STATE_FINDING_SYNC, STATE_READING_HEADER, STATE_READING_SAMPLE})
   private @interface State {}
+
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
   private static final int STATE_READING_SAMPLE = 2;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 0c2a0545dc..04a6b571bd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -47,6 +48,7 @@
    * Flags controlling the behavior of the extractor. Possible flag value is {@link
    * #FLAG_ENABLE_CONSTANT_BITRATE_SEEKING}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 06a60776c2..a5506e2cfb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.text.cea.Cea708InitializationData;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -39,6 +40,7 @@
    * #FLAG_IGNORE_H264_STREAM}, {@link #FLAG_DETECT_ACCESS_UNITS}, {@link
    * #FLAG_IGNORE_SPLICE_INFO_STREAM} and {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -52,11 +54,37 @@
       })
   public @interface Flags {}
 
+  /**
+   * When extracting H.264 samples, whether to treat samples consisting of non-IDR I slices as
+   * synchronization samples (key-frames).
+   */
   public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
+  /**
+   * Prevents the creation of {@link AdtsReader} and {@link LatmReader} instances. This flag should
+   * be enabled if the transport stream contains no packets for an AAC elementary stream that is
+   * declared in the PMT.
+   */
   public static final int FLAG_IGNORE_AAC_STREAM = 1 << 1;
+  /**
+   * Prevents the creation of {@link H264Reader} instances. This flag should be enabled if the
+   * transport stream contains no packets for an H.264 elementary stream that is declared in the
+   * PMT.
+   */
   public static final int FLAG_IGNORE_H264_STREAM = 1 << 2;
+  /**
+   * When extracting H.264 samples, whether to split the input stream into access units (samples)
+   * based on slice headers. This flag should be disabled if the stream contains access unit
+   * delimiters (AUDs).
+   */
   public static final int FLAG_DETECT_ACCESS_UNITS = 1 << 3;
+  /** Prevents the creation of {@link SpliceInfoSectionReader} instances. */
   public static final int FLAG_IGNORE_SPLICE_INFO_STREAM = 1 << 4;
+  /**
+   * Whether the list of {@code closedCaptionFormats} passed to {@link
+   * DefaultTsPayloadReaderFactory#DefaultTsPayloadReaderFactory(int, List)} should be used in spite
+   * of any closed captions service descriptors. If this flag is disabled, {@code
+   * closedCaptionFormats} will be ignored if the PMT contains closed captions service descriptors.
+   */
   public static final int FLAG_OVERRIDE_CAPTION_DESCRIPTORS = 1 << 5;
 
   private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java
index e8c207f75d..4efd38b7eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsBinarySearchSeeker.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -53,10 +54,9 @@ public PsBinarySearchSeeker(
   /**
    * A seeker that looks for a given SCR timestamp at a given position in a PS stream.
    *
-   * <p>Given a SCR timestamp, and a position within a PS stream, this seeker will try to read a
-   * range of up to {@link #TIMESTAMP_SEARCH_BYTES} bytes from that stream position, look for all
-   * packs in that range, and then compare the SCR timestamps (if available) of these packets vs the
-   * target timestamp.
+   * <p>Given a SCR timestamp, and a position within a PS stream, this seeker will peek up to {@link
+   * #TIMESTAMP_SEARCH_BYTES} bytes from that stream position, look for all packs in that range, and
+   * then compare the SCR timestamps (if available) of these packets to the target timestamp.
    */
   private static final class PsScrSeeker implements TimestampSeeker {
 
@@ -65,7 +65,7 @@ public PsBinarySearchSeeker(
 
     private PsScrSeeker(TimestampAdjuster scrTimestampAdjuster) {
       this.scrTimestampAdjuster = scrTimestampAdjuster;
-      packetBuffer = new ParsableByteArray(TIMESTAMP_SEARCH_BYTES);
+      packetBuffer = new ParsableByteArray();
     }
 
     @Override
@@ -73,14 +73,19 @@ public TimestampSearchResult searchForTimestamp(
         ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
         throws IOException, InterruptedException {
       long inputPosition = input.getPosition();
-      int bytesToRead =
-          (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - input.getPosition());
-      packetBuffer.reset(bytesToRead);
-      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
+      int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - inputPosition);
+
+      packetBuffer.reset(bytesToSearch);
+      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
       return searchForScrValueInBuffer(packetBuffer, targetTimestamp, inputPosition);
     }
 
+    @Override
+    public void onSeekFinished() {
+      packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    }
+
     private TimestampSearchResult searchForScrValueInBuffer(
         ParsableByteArray packetBuffer, long targetScrTimeUs, long bufferStartOffset) {
       int startOfLastPacketPosition = C.POSITION_UNSET;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java
index 3b52206235..b0cdf7eb79 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsDurationReader.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -38,7 +39,7 @@
  */
 /* package */ final class PsDurationReader {
 
-  private static final int DURATION_READ_BYTES = 20000;
+  private static final int TIMESTAMP_SEARCH_BYTES = 20000;
 
   private final TimestampAdjuster scrTimestampAdjuster;
   private final ParsableByteArray packetBuffer;
@@ -56,7 +57,7 @@
     firstScrValue = C.TIME_UNSET;
     lastScrValue = C.TIME_UNSET;
     durationUs = C.TIME_UNSET;
-    packetBuffer = new ParsableByteArray(DURATION_READ_BYTES);
+    packetBuffer = new ParsableByteArray();
   }
 
   /** Returns true if a PS duration has been read. */
@@ -129,6 +130,7 @@ public static long readScrValueFromPack(ParsableByteArray packetBuffer) {
   }
 
   private int finishReadDuration(ExtractorInput input) {
+    packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
     isDurationRead = true;
     input.resetPeekPosition();
     return Extractor.RESULT_CONTINUE;
@@ -136,16 +138,16 @@ private int finishReadDuration(ExtractorInput input) {
 
   private int readFirstScrValue(ExtractorInput input, PositionHolder seekPositionHolder)
       throws IOException, InterruptedException {
-    if (input.getPosition() != 0) {
-      seekPositionHolder.position = 0;
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength());
+    int searchStartPosition = 0;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
       return Extractor.RESULT_SEEK;
     }
 
-    int bytesToRead = (int) Math.min(DURATION_READ_BYTES, input.getLength());
+    packetBuffer.reset(bytesToSearch);
     input.resetPeekPosition();
-    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
-    packetBuffer.setPosition(0);
-    packetBuffer.setLimit(bytesToRead);
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
     firstScrValue = readFirstScrValueFromBuffer(packetBuffer);
     isFirstScrValueRead = true;
@@ -172,17 +174,17 @@ private long readFirstScrValueFromBuffer(ParsableByteArray packetBuffer) {
 
   private int readLastScrValue(ExtractorInput input, PositionHolder seekPositionHolder)
       throws IOException, InterruptedException {
-    int bytesToRead = (int) Math.min(DURATION_READ_BYTES, input.getLength());
-    long bufferStartStreamPosition = input.getLength() - bytesToRead;
-    if (input.getPosition() != bufferStartStreamPosition) {
-      seekPositionHolder.position = bufferStartStreamPosition;
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, inputLength);
+    long searchStartPosition = inputLength - bytesToSearch;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
       return Extractor.RESULT_SEEK;
     }
 
+    packetBuffer.reset(bytesToSearch);
     input.resetPeekPosition();
-    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
-    packetBuffer.setPosition(0);
-    packetBuffer.setLimit(bytesToRead);
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
     lastScrValue = readLastScrValueFromBuffer(packetBuffer);
     isLastScrValueRead = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java
index 29aa0d55d2..ea2519d2e9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsBinarySearchSeeker.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -33,10 +34,8 @@
 /* package */ final class TsBinarySearchSeeker extends BinarySearchSeeker {
 
   private static final long SEEK_TOLERANCE_US = 100_000;
-  private static final int MINIMUM_SEARCH_RANGE_BYTES = TsExtractor.TS_PACKET_SIZE * 5;
-  private static final int TIMESTAMP_SEARCH_PACKETS = 200;
-  private static final int TIMESTAMP_SEARCH_BYTES =
-      TsExtractor.TS_PACKET_SIZE * TIMESTAMP_SEARCH_PACKETS;
+  private static final int MINIMUM_SEARCH_RANGE_BYTES = 5 * TsExtractor.TS_PACKET_SIZE;
+  private static final int TIMESTAMP_SEARCH_BYTES = 600 * TsExtractor.TS_PACKET_SIZE;
 
   public TsBinarySearchSeeker(
       TimestampAdjuster pcrTimestampAdjuster, long streamDurationUs, long inputLength, int pcrPid) {
@@ -56,10 +55,10 @@ public TsBinarySearchSeeker(
    * A {@link TimestampSeeker} implementation that looks for a given PCR timestamp at a given
    * position in a TS stream.
    *
-   * <p>Given a PCR timestamp, and a position within a TS stream, this seeker will try to read up to
-   * {@link #TIMESTAMP_SEARCH_PACKETS} TS packets from that stream position, look for all packet
-   * with PID equals to PCR_PID, and then compare the PCR timestamps (if available) of these packets
-   * vs the target timestamp.
+   * <p>Given a PCR timestamp, and a position within a TS stream, this seeker will peek up to {@link
+   * #TIMESTAMP_SEARCH_BYTES} from that stream position, look for all packets with PID equal to
+   * PCR_PID, and then compare the PCR timestamps (if available) of these packets to the target
+   * timestamp.
    */
   private static final class TsPcrSeeker implements TimestampSeeker {
 
@@ -70,7 +69,7 @@ public TsBinarySearchSeeker(
     public TsPcrSeeker(int pcrPid, TimestampAdjuster pcrTimestampAdjuster) {
       this.pcrPid = pcrPid;
       this.pcrTimestampAdjuster = pcrTimestampAdjuster;
-      packetBuffer = new ParsableByteArray(TIMESTAMP_SEARCH_BYTES);
+      packetBuffer = new ParsableByteArray();
     }
 
     @Override
@@ -78,10 +77,10 @@ public TimestampSearchResult searchForTimestamp(
         ExtractorInput input, long targetTimestamp, OutputFrameHolder outputFrameHolder)
         throws IOException, InterruptedException {
       long inputPosition = input.getPosition();
-      int bytesToRead =
-          (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - input.getPosition());
-      packetBuffer.reset(bytesToRead);
-      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
+      int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength() - inputPosition);
+
+      packetBuffer.reset(bytesToSearch);
+      input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
       return searchForPcrValueInBuffer(packetBuffer, targetTimestamp, inputPosition);
     }
@@ -133,5 +132,10 @@ private TimestampSearchResult searchForPcrValueInBuffer(
         return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
       }
     }
+
+    @Override
+    public void onSeekFinished() {
+      packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
+    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java
index 350337cc86..804a643414 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsDurationReader.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -35,8 +36,7 @@
  */
 /* package */ final class TsDurationReader {
 
-  private static final int DURATION_READ_PACKETS = 200;
-  private static final int DURATION_READ_BYTES = TsExtractor.TS_PACKET_SIZE * DURATION_READ_PACKETS;
+  private static final int TIMESTAMP_SEARCH_BYTES = 600 * TsExtractor.TS_PACKET_SIZE;
 
   private final TimestampAdjuster pcrTimestampAdjuster;
   private final ParsableByteArray packetBuffer;
@@ -54,7 +54,7 @@
     firstPcrValue = C.TIME_UNSET;
     lastPcrValue = C.TIME_UNSET;
     durationUs = C.TIME_UNSET;
-    packetBuffer = new ParsableByteArray(DURATION_READ_BYTES);
+    packetBuffer = new ParsableByteArray();
   }
 
   /** Returns true if a TS duration has been read. */
@@ -117,6 +117,7 @@ public TimestampAdjuster getPcrTimestampAdjuster() {
   }
 
   private int finishReadDuration(ExtractorInput input) {
+    packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
     isDurationRead = true;
     input.resetPeekPosition();
     return Extractor.RESULT_CONTINUE;
@@ -124,16 +125,16 @@ private int finishReadDuration(ExtractorInput input) {
 
   private int readFirstPcrValue(ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid)
       throws IOException, InterruptedException {
-    if (input.getPosition() != 0) {
-      seekPositionHolder.position = 0;
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, input.getLength());
+    int searchStartPosition = 0;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
       return Extractor.RESULT_SEEK;
     }
 
-    int bytesToRead = (int) Math.min(DURATION_READ_BYTES, input.getLength());
+    packetBuffer.reset(bytesToSearch);
     input.resetPeekPosition();
-    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
-    packetBuffer.setPosition(0);
-    packetBuffer.setLimit(bytesToRead);
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
     firstPcrValue = readFirstPcrValueFromBuffer(packetBuffer, pcrPid);
     isFirstPcrValueRead = true;
@@ -159,17 +160,17 @@ private long readFirstPcrValueFromBuffer(ParsableByteArray packetBuffer, int pcr
 
   private int readLastPcrValue(ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid)
       throws IOException, InterruptedException {
-    int bytesToRead = (int) Math.min(DURATION_READ_BYTES, input.getLength());
-    long bufferStartStreamPosition = input.getLength() - bytesToRead;
-    if (input.getPosition() != bufferStartStreamPosition) {
-      seekPositionHolder.position = bufferStartStreamPosition;
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) Math.min(TIMESTAMP_SEARCH_BYTES, inputLength);
+    long searchStartPosition = inputLength - bytesToSearch;
+    if (input.getPosition() != searchStartPosition) {
+      seekPositionHolder.position = searchStartPosition;
       return Extractor.RESULT_SEEK;
     }
 
+    packetBuffer.reset(bytesToSearch);
     input.resetPeekPosition();
-    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToRead);
-    packetBuffer.setPosition(0);
-    packetBuffer.setLimit(bytesToRead);
+    input.peekFully(packetBuffer.data, /* offset= */ 0, bytesToSearch);
 
     lastPcrValue = readLastPcrValueFromBuffer(packetBuffer, pcrPid);
     isLastPcrValueRead = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 978b1e8813..f47a481d7e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -38,6 +38,7 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -57,6 +58,7 @@
    * Modes for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT} or {@link
    * #MODE_HLS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
   public @interface Mode {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 7e933e9474..86bbb330b7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -46,6 +46,7 @@
 import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -182,6 +183,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    * The possible return values for {@link #canKeepCodec(MediaCodec, MediaCodecInfo, Format,
    * Format)}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     KEEP_CODEC_RESULT_NO,
@@ -199,9 +201,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   protected static final int KEEP_CODEC_RESULT_YES_WITH_RECONFIGURATION = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({RECONFIGURATION_STATE_NONE, RECONFIGURATION_STATE_WRITE_PENDING,
-      RECONFIGURATION_STATE_QUEUE_PENDING})
+  @IntDef({
+    RECONFIGURATION_STATE_NONE,
+    RECONFIGURATION_STATE_WRITE_PENDING,
+    RECONFIGURATION_STATE_QUEUE_PENDING
+  })
   private @interface ReconfigurationState {}
   /**
    * There is no pending adaptive reconfiguration work.
@@ -217,9 +223,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int RECONFIGURATION_STATE_QUEUE_PENDING = 2;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReinitializationState {}
   /**
    * The codec does not need to be re-initialized.
@@ -238,9 +248,13 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({ADAPTATION_WORKAROUND_MODE_NEVER, ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION,
-      ADAPTATION_WORKAROUND_MODE_ALWAYS})
+  @IntDef({
+    ADAPTATION_WORKAROUND_MODE_NEVER,
+    ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION,
+    ADAPTATION_WORKAROUND_MODE_ALWAYS
+  })
   private @interface AdaptationWorkaroundMode {}
   /**
    * The adaptation workaround is never used.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index 152eb97e0c..864616e810 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -129,9 +129,12 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
           buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
           buffer.flip();
           int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
-          pendingMetadata[index] = decoder.decode(buffer);
-          pendingMetadataTimestamps[index] = buffer.timeUs;
-          pendingMetadataCount++;
+          Metadata metadata = decoder.decode(buffer);
+          if (metadata != null) {
+            pendingMetadata[index] = metadata;
+            pendingMetadataTimestamps[index] = buffer.timeUs;
+            pendingMetadataCount++;
+          }
         }
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index 0bf9d3b249..63bf30dd11 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.UnsupportedEncodingException;
@@ -382,6 +383,8 @@ private static boolean validateFrames(ParsableByteArray id3Data, int majorVersio
       } else if (frameId0 == 'C' && frameId1 == 'T' && frameId2 == 'O' && frameId3 == 'C') {
         frame = decodeChapterTOCFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
             frameHeaderSize, framePredicate);
+      } else if (frameId0 == 'M' && frameId1 == 'L' && frameId2 == 'L' && frameId3 == 'T') {
+        frame = decodeMlltFrame(id3Data, frameSize);
       } else {
         String id = getFrameId(majorVersion, frameId0, frameId1, frameId2, frameId3);
         frame = decodeBinaryFrame(id3Data, frameSize, id);
@@ -662,6 +665,36 @@ private static ChapterTocFrame decodeChapterTOCFrame(
     return new ChapterTocFrame(elementId, isRoot, isOrdered, children, subFrameArray);
   }
 
+  private static MlltFrame decodeMlltFrame(ParsableByteArray id3Data, int frameSize) {
+    // See ID3v2.4.0 native frames subsection 4.6.
+    int mpegFramesBetweenReference = id3Data.readUnsignedShort();
+    int bytesBetweenReference = id3Data.readUnsignedInt24();
+    int millisecondsBetweenReference = id3Data.readUnsignedInt24();
+    int bitsForBytesDeviation = id3Data.readUnsignedByte();
+    int bitsForMillisecondsDeviation = id3Data.readUnsignedByte();
+
+    ParsableBitArray references = new ParsableBitArray();
+    references.reset(id3Data);
+    int referencesBits = 8 * (frameSize - 10);
+    int bitsPerReference = bitsForBytesDeviation + bitsForMillisecondsDeviation;
+    int referencesCount = referencesBits / bitsPerReference;
+    int[] bytesDeviations = new int[referencesCount];
+    int[] millisecondsDeviations = new int[referencesCount];
+    for (int i = 0; i < referencesCount; i++) {
+      int bytesDeviation = references.readBits(bitsForBytesDeviation);
+      int millisecondsDeviation = references.readBits(bitsForMillisecondsDeviation);
+      bytesDeviations[i] = bytesDeviation;
+      millisecondsDeviations[i] = millisecondsDeviation;
+    }
+
+    return new MlltFrame(
+        mpegFramesBetweenReference,
+        bytesBetweenReference,
+        millisecondsBetweenReference,
+        bytesDeviations,
+        millisecondsDeviations);
+  }
+
   private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int frameSize,
       String id) {
     byte[] frame = new byte[frameSize];
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
new file mode 100644
index 0000000000..06a4dd9d2d
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/MlltFrame.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import android.support.annotation.Nullable;
+import java.util.Arrays;
+
+/** MPEG location lookup table frame. */
+public final class MlltFrame extends Id3Frame {
+
+  public static final String ID = "MLLT";
+
+  public final int mpegFramesBetweenReference;
+  public final int bytesBetweenReference;
+  public final int millisecondsBetweenReference;
+  public final int[] bytesDeviations;
+  public final int[] millisecondsDeviations;
+
+  public MlltFrame(
+      int mpegFramesBetweenReference,
+      int bytesBetweenReference,
+      int millisecondsBetweenReference,
+      int[] bytesDeviations,
+      int[] millisecondsDeviations) {
+    super(ID);
+    this.mpegFramesBetweenReference = mpegFramesBetweenReference;
+    this.bytesBetweenReference = bytesBetweenReference;
+    this.millisecondsBetweenReference = millisecondsBetweenReference;
+    this.bytesDeviations = bytesDeviations;
+    this.millisecondsDeviations = millisecondsDeviations;
+  }
+
+  /* package */ MlltFrame(Parcel in) {
+    super(ID);
+    this.mpegFramesBetweenReference = in.readInt();
+    this.bytesBetweenReference = in.readInt();
+    this.millisecondsBetweenReference = in.readInt();
+    this.bytesDeviations = in.createIntArray();
+    this.millisecondsDeviations = in.createIntArray();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    MlltFrame other = (MlltFrame) obj;
+    return mpegFramesBetweenReference == other.mpegFramesBetweenReference
+        && bytesBetweenReference == other.bytesBetweenReference
+        && millisecondsBetweenReference == other.millisecondsBetweenReference
+        && Arrays.equals(bytesDeviations, other.bytesDeviations)
+        && Arrays.equals(millisecondsDeviations, other.millisecondsDeviations);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + mpegFramesBetweenReference;
+    result = 31 * result + bytesBetweenReference;
+    result = 31 * result + millisecondsBetweenReference;
+    result = 31 * result + Arrays.hashCode(bytesDeviations);
+    result = 31 * result + Arrays.hashCode(millisecondsDeviations);
+    return result;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(mpegFramesBetweenReference);
+    dest.writeInt(bytesBetweenReference);
+    dest.writeInt(millisecondsBetweenReference);
+    dest.writeIntArray(bytesDeviations);
+    dest.writeIntArray(millisecondsDeviations);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Creator<MlltFrame> CREATOR =
+      new Creator<MlltFrame>() {
+
+        @Override
+        public MlltFrame createFromParcel(Parcel in) {
+          return new MlltFrame(in);
+        }
+
+        @Override
+        public MlltFrame[] newArray(int size) {
+          return new MlltFrame[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index 3b26741897..409f79f30b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -37,6 +37,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -532,6 +533,7 @@ private static void logd(String message, Task task) {
      *                    -&gt; failed
      * </pre>
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({STATE_QUEUED, STATE_STARTED, STATE_COMPLETED, STATE_CANCELED, STATE_FAILED})
     public @interface State {}
@@ -621,6 +623,7 @@ private TaskState(
      * +-----------+------+-------+---------+-----------+-----------+--------+--------+------+
      * </pre>
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
       STATE_QUEUED,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
index 0ee8d76bc7..5acd31ee0d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/Requirements.java
@@ -27,6 +27,7 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -39,6 +40,7 @@
    * Network types. One of {@link #NETWORK_TYPE_NONE}, {@link #NETWORK_TYPE_ANY}, {@link
    * #NETWORK_TYPE_UNMETERED}, {@link #NETWORK_TYPE_NOT_ROAMING} or {@link #NETWORK_TYPE_METERED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NETWORK_TYPE_NONE,
@@ -185,7 +187,7 @@ private boolean checkIdleRequirement(Context context) {
     }
     PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
     return Util.SDK_INT >= 23
-        ? !powerManager.isDeviceIdleMode()
+        ? powerManager.isDeviceIdleMode()
         : Util.SDK_INT >= 20 ? !powerManager.isInteractive() : !powerManager.isScreenOn();
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index 88e98e811f..78e37c1869 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -41,6 +42,7 @@
      * The reason clipping failed. One of {@link #REASON_INVALID_PERIOD_COUNT}, {@link
      * #REASON_NOT_SEEKABLE_TO_START} or {@link #REASON_START_EXCEEDS_END}.
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({REASON_INVALID_PERIOD_COUNT, REASON_NOT_SEEKABLE_TO_START, REASON_START_EXCEEDS_END})
     public @interface Reason {}
@@ -346,7 +348,7 @@ public ClippingTimeline(Timeline timeline, long startUs, long endUs)
       if (timeline.getPeriodCount() != 1) {
         throw new IllegalClippingException(IllegalClippingException.REASON_INVALID_PERIOD_COUNT);
       }
-      Window window = timeline.getWindow(0, new Window(), false);
+      Window window = timeline.getWindow(0, new Window());
       startUs = Math.max(0, startUs);
       long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : Math.max(0, endUs);
       if (window.durationUs != C.TIME_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index e0b7da8506..88cd4a1595 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -18,6 +18,7 @@
 import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
@@ -65,6 +66,7 @@
   private final boolean isAtomic;
   private final boolean useLazyPreparation;
   private final Timeline.Window window;
+  private final Timeline.Period period;
 
   private @Nullable ExoPlayer player;
   private @Nullable Handler playerApplicationHandler;
@@ -131,6 +133,7 @@ public ConcatenatingMediaSource(
     this.isAtomic = isAtomic;
     this.useLazyPreparation = useLazyPreparation;
     window = new Timeline.Window();
+    period = new Timeline.Period();
     addMediaSources(Arrays.asList(mediaSources));
   }
 
@@ -362,6 +365,9 @@ public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
   public final synchronized void moveMediaSource(
       int currentIndex, int newIndex, @Nullable Runnable actionOnCompletion) {
     if (currentIndex == newIndex) {
+      if (actionOnCompletion != null) {
+        actionOnCompletion.run();
+      }
       return;
     }
     mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
@@ -499,9 +505,7 @@ public final void releasePeriod(MediaPeriod mediaPeriod) {
         Assertions.checkNotNull(mediaSourceByMediaPeriod.remove(mediaPeriod));
     ((DeferredMediaPeriod) mediaPeriod).releasePeriod();
     holder.activeMediaPeriods.remove(mediaPeriod);
-    if (holder.activeMediaPeriods.isEmpty() && holder.isRemoved) {
-      releaseChildSource(holder);
-    }
+    maybeReleaseChildSource(holder);
   }
 
   @Override
@@ -569,9 +573,7 @@ public final void handleMessage(int messageType, @Nullable Object message)
         if (fromIndex == 0 && toIndex == shuffleOrder.getLength()) {
           shuffleOrder = shuffleOrder.cloneAndClear();
         } else {
-          for (int index = toIndex - 1; index >= fromIndex; index--) {
-            shuffleOrder = shuffleOrder.cloneAndRemove(index);
-          }
+          shuffleOrder = shuffleOrder.cloneAndRemove(fromIndex, toIndex);
         }
         for (int index = toIndex - 1; index >= fromIndex; index--) {
           removeMediaSourceInternal(index);
@@ -580,7 +582,7 @@ public final void handleMessage(int messageType, @Nullable Object message)
         break;
       case MSG_MOVE:
         MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(message);
-        shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index);
+        shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index, moveMessage.index + 1);
         shuffleOrder = shuffleOrder.cloneAndInsert(moveMessage.customData, 1);
         moveMediaSourceInternal(moveMessage.index, moveMessage.customData);
         scheduleListenerNotification(moveMessage.actionOnCompletion);
@@ -684,21 +686,53 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
           windowOffsetUpdate,
           periodOffsetUpdate);
     }
-    mediaSourceHolder.timeline = deferredTimeline.cloneWithNewTimeline(timeline);
-    if (!mediaSourceHolder.isPrepared && !timeline.isEmpty()) {
-      timeline.getWindow(/* windowIndex= */ 0, window);
-      long defaultPeriodPositionUs =
-          window.getPositionInFirstPeriodUs() + window.getDefaultPositionUs();
-      for (int i = 0; i < mediaSourceHolder.activeMediaPeriods.size(); i++) {
-        DeferredMediaPeriod deferredMediaPeriod = mediaSourceHolder.activeMediaPeriods.get(i);
-        deferredMediaPeriod.setDefaultPreparePositionUs(defaultPeriodPositionUs);
+    if (mediaSourceHolder.isPrepared) {
+      mediaSourceHolder.timeline = deferredTimeline.cloneWithUpdatedTimeline(timeline);
+    } else if (timeline.isEmpty()) {
+      mediaSourceHolder.timeline =
+          DeferredTimeline.createWithRealTimeline(timeline, DeferredTimeline.DUMMY_ID);
+    } else {
+      // We should have at most one deferred media period for the DummyTimeline because the duration
+      // is unset and we don't load beyond periods with unset duration. We need to figure out how to
+      // handle the prepare positions of multiple deferred media periods, should that ever change.
+      Assertions.checkState(mediaSourceHolder.activeMediaPeriods.size() <= 1);
+      DeferredMediaPeriod deferredMediaPeriod =
+          mediaSourceHolder.activeMediaPeriods.isEmpty()
+              ? null
+              : mediaSourceHolder.activeMediaPeriods.get(0);
+      // Determine first period and the start position.
+      // This will be:
+      //  1. The default window start position if no deferred period has been created yet.
+      //  2. The non-zero prepare position of the deferred period under the assumption that this is
+      //     a non-zero initial seek position in the window.
+      //  3. The default window start position if the deferred period has a prepare position of zero
+      //     under the assumption that the prepare position of zero was used because it's the
+      //     default position of the DummyTimeline window. Note that this will override an
+      //     intentional seek to zero for a window with a non-zero default position. This is
+      //     unlikely to be a problem as a non-zero default position usually only occurs for live
+      //     playbacks and seeking to zero in a live window would cause BehindLiveWindowExceptions
+      //     anyway.
+      long windowStartPositionUs = window.getDefaultPositionUs();
+      if (deferredMediaPeriod != null) {
+        long periodPreparePositionUs = deferredMediaPeriod.getPreparePositionUs();
+        if (periodPreparePositionUs != 0) {
+          windowStartPositionUs = periodPreparePositionUs;
+        }
+      }
+      Pair<Object, Long> periodPosition =
+          timeline.getPeriodPosition(window, period, /* windowIndex= */ 0, windowStartPositionUs);
+      Object periodUid = periodPosition.first;
+      long periodPositionUs = periodPosition.second;
+      mediaSourceHolder.timeline = DeferredTimeline.createWithRealTimeline(timeline, periodUid);
+      if (deferredMediaPeriod != null) {
+        deferredMediaPeriod.overridePreparePositionUs(periodPositionUs);
         MediaPeriodId idInSource =
             deferredMediaPeriod.id.copyWithPeriodUid(
                 getChildPeriodUid(mediaSourceHolder, deferredMediaPeriod.id.periodUid));
         deferredMediaPeriod.createPeriod(idInSource);
       }
-      mediaSourceHolder.isPrepared = true;
     }
+    mediaSourceHolder.isPrepared = true;
     scheduleListenerNotification(/* actionOnCompletion= */ null);
   }
 
@@ -712,9 +746,7 @@ private void removeMediaSourceInternal(int index) {
         -oldTimeline.getWindowCount(),
         -oldTimeline.getPeriodCount());
     holder.isRemoved = true;
-    if (holder.activeMediaPeriods.isEmpty()) {
-      releaseChildSource(holder);
-    }
+    maybeReleaseChildSource(holder);
   }
 
   private void moveMediaSourceInternal(int currentIndex, int newIndex) {
@@ -743,6 +775,16 @@ private void correctOffsets(
     }
   }
 
+  private void maybeReleaseChildSource(MediaSourceHolder mediaSourceHolder) {
+    // Release if the source has been removed from the playlist, but only if it has been previously
+    // prepared and only if we are not waiting for an existing media period to be released.
+    if (mediaSourceHolder.isRemoved
+        && mediaSourceHolder.hasStartedPreparing
+        && mediaSourceHolder.activeMediaPeriods.isEmpty()) {
+      releaseChildSource(mediaSourceHolder);
+    }
+  }
+
   /** Return uid of media source holder from period uid of concatenated source. */
   private static Object getMediaSourceHolderUid(Object periodUid) {
     return ConcatenatedTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);
@@ -897,18 +939,32 @@ public int getPeriodCount() {
   }
 
   /**
-   * Timeline used as placeholder for an unprepared media source. After preparation, a copy of the
-   * DeferredTimeline is used to keep the originally assigned first period ID.
+   * Timeline used as placeholder for an unprepared media source. After preparation, a
+   * DeferredTimeline is used to keep the originally assigned dummy period ID.
    */
   private static final class DeferredTimeline extends ForwardingTimeline {
 
     private static final Object DUMMY_ID = new Object();
-    private static final DummyTimeline dummyTimeline = new DummyTimeline();
+    private static final DummyTimeline DUMMY_TIMELINE = new DummyTimeline();
 
     private final Object replacedId;
 
+    /**
+     * Returns an instance with a real timeline, replacing the provided period ID with the already
+     * assigned dummy period ID.
+     *
+     * @param timeline The real timeline.
+     * @param firstPeriodUid The period UID in the timeline which will be replaced by the already
+     *     assigned dummy period UID.
+     */
+    public static DeferredTimeline createWithRealTimeline(
+        Timeline timeline, Object firstPeriodUid) {
+      return new DeferredTimeline(timeline, firstPeriodUid);
+    }
+
+    /** Creates deferred timeline exposing a {@link DummyTimeline}. */
     public DeferredTimeline() {
-      this(dummyTimeline, DUMMY_ID);
+      this(DUMMY_TIMELINE, DUMMY_ID);
     }
 
     private DeferredTimeline(Timeline timeline, Object replacedId) {
@@ -916,14 +972,16 @@ private DeferredTimeline(Timeline timeline, Object replacedId) {
       this.replacedId = replacedId;
     }
 
-    public DeferredTimeline cloneWithNewTimeline(Timeline timeline) {
-      return new DeferredTimeline(
-          timeline,
-          replacedId == DUMMY_ID && timeline.getPeriodCount() > 0
-              ? timeline.getUidOfPeriod(0)
-              : replacedId);
+    /**
+     * Returns a copy with an updated timeline. This keeps the existing period replacement.
+     *
+     * @param timeline The new timeline.
+     */
+    public DeferredTimeline cloneWithUpdatedTimeline(Timeline timeline) {
+      return new DeferredTimeline(timeline, replacedId);
     }
 
+    /** Returns wrapped timeline. */
     public Timeline getTimeline() {
       return timeline;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
index 5f84731b8d..26c25a749e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
@@ -79,23 +79,19 @@ public void setPrepareErrorListener(PrepareErrorListener listener) {
     this.listener = listener;
   }
 
+  /** Returns the position at which the deferred media period was prepared, in microseconds. */
+  public long getPreparePositionUs() {
+    return preparePositionUs;
+  }
+
   /**
-   * Sets the default prepare position at which to prepare the media period. This value is only used
-   * if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred and the call was
-   * made with a (presumably default) prepare position of 0.
+   * Overrides the default prepare position at which to prepare the media period. This value is only
+   * used if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred.
    *
-   * <p>Note that this will override an intentional seek to zero in the corresponding non-seekable
-   * timeline window. This is unlikely to be a problem as a non-zero default position usually only
-   * occurs for live playbacks and seeking to zero in a live window would cause
-   * BehindLiveWindowExceptions anyway.
-   *
-   * @param defaultPreparePositionUs The actual default prepare position, in microseconds.
+   * @param defaultPreparePositionUs The default prepare position to use, in microseconds.
    */
-  public void setDefaultPreparePositionUs(long defaultPreparePositionUs) {
-    if (preparePositionUs == 0 && defaultPreparePositionUs != 0) {
-      preparePositionOverrideUs = defaultPreparePositionUs;
-      preparePositionUs = defaultPreparePositionUs;
-    }
+  public void overridePreparePositionUs(long defaultPreparePositionUs) {
+    preparePositionOverrideUs = defaultPreparePositionUs;
   }
 
   /**
@@ -108,6 +104,10 @@ public void setDefaultPreparePositionUs(long defaultPreparePositionUs) {
   public void createPeriod(MediaPeriodId id) {
     mediaPeriod = mediaSource.createPeriod(id, allocator);
     if (callback != null) {
+      long preparePositionUs =
+          preparePositionOverrideUs != C.TIME_UNSET
+              ? preparePositionOverrideUs
+              : this.preparePositionUs;
       mediaPeriod.prepare(this, preparePositionUs);
     }
   }
@@ -157,7 +157,7 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    if (preparePositionOverrideUs != C.TIME_UNSET && positionUs == 0) {
+    if (preparePositionOverrideUs != C.TIME_UNSET && positionUs == preparePositionUs) {
       positionUs = preparePositionOverrideUs;
       preparePositionOverrideUs = C.TIME_UNSET;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 746af5719e..ecb4b10c6a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -41,6 +42,7 @@
   public static final class IllegalMergeException extends IOException {
 
     /** The reason the merge failed. One of {@link #REASON_PERIOD_COUNT_MISMATCH}. */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({REASON_PERIOD_COUNT_MISMATCH})
     public @interface Reason {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index d6f18665f4..ecc720c656 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -30,10 +30,8 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-/**
- * A queue of media samples.
- */
-public final class SampleQueue implements TrackOutput {
+/** A queue of media samples. */
+public class SampleQueue implements TrackOutput {
 
   /**
    * A listener for changes to the upstream format.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
index 750c42bbd0..5af9dbd20a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
@@ -55,6 +55,17 @@ public DefaultShuffleOrder(int length, long randomSeed) {
       this(length, new Random(randomSeed));
     }
 
+    /**
+     * Creates an instance with a specified shuffle order and the specified random seed. The random
+     * seed is used for {@link #cloneAndInsert(int, int)} invocations.
+     *
+     * @param shuffledIndices The shuffled indices to use as order.
+     * @param randomSeed A random seed.
+     */
+    public DefaultShuffleOrder(int[] shuffledIndices, long randomSeed) {
+      this(Arrays.copyOf(shuffledIndices, shuffledIndices.length), new Random(randomSeed));
+    }
+
     private DefaultShuffleOrder(int length, Random random) {
       this(createShuffledList(length, random), random);
     }
@@ -124,15 +135,16 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
     }
 
     @Override
-    public ShuffleOrder cloneAndRemove(int removalIndex) {
-      int[] newShuffled = new int[shuffled.length - 1];
-      boolean foundRemovedElement = false;
+    public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+      int numberOfElementsToRemove = indexToExclusive - indexFrom;
+      int[] newShuffled = new int[shuffled.length - numberOfElementsToRemove];
+      int foundElementsCount = 0;
       for (int i = 0; i < shuffled.length; i++) {
-        if (shuffled[i] == removalIndex) {
-          foundRemovedElement = true;
+        if (shuffled[i] >= indexFrom && shuffled[i] < indexToExclusive) {
+          foundElementsCount++;
         } else {
-          newShuffled[foundRemovedElement ? i - 1 : i] = shuffled[i] > removalIndex
-              ? shuffled[i] - 1 : shuffled[i];
+          newShuffled[i - foundElementsCount] =
+              shuffled[i] >= indexFrom ? shuffled[i] - numberOfElementsToRemove : shuffled[i];
         }
       }
       return new DefaultShuffleOrder(newShuffled, new Random(random.nextLong()));
@@ -202,8 +214,8 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
     }
 
     @Override
-    public ShuffleOrder cloneAndRemove(int removalIndex) {
-      return new UnshuffledShuffleOrder(length - 1);
+    public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+      return new UnshuffledShuffleOrder(length - indexToExclusive + indexFrom);
     }
 
     @Override
@@ -257,12 +269,14 @@ public ShuffleOrder cloneAndClear() {
   ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount);
 
   /**
-   * Returns a copy of the shuffle order with one element removed.
+   * Returns a copy of the shuffle order with a range of elements removed.
    *
-   * @param removalIndex The index of the element in the unshuffled order which is to be removed.
-   * @return A copy of this {@link ShuffleOrder} without the removed element.
+   * @param indexFrom The starting index in the unshuffled order of the range to remove.
+   * @param indexToExclusive The smallest index (must be greater or equal to {@code indexFrom}) that
+   *     will not be removed.
+   * @return A copy of this {@link ShuffleOrder} without the elements in the removed range.
    */
-  ShuffleOrder cloneAndRemove(int removalIndex);
+  ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive);
 
   /** Returns a copy of the shuffle order with all elements removed. */
   ShuffleOrder cloneAndClear();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
index 72fc162bc3..41adb78906 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
@@ -20,6 +20,7 @@
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -239,6 +240,7 @@ public AdGroup withAllAdsSkipped() {
    * #AD_STATE_AVAILABLE}, {@link #AD_STATE_SKIPPED}, {@link #AD_STATE_PLAYED} or {@link
    * #AD_STATE_ERROR}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     AD_STATE_UNAVAILABLE,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 3d5c41e8bc..7fc0f22bf3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -39,6 +39,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -87,6 +88,7 @@
      * Types of ad load exceptions. One of {@link #TYPE_AD}, {@link #TYPE_AD_GROUP}, {@link
      * #TYPE_ALL_ADS} or {@link #TYPE_UNEXPECTED}.
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({TYPE_AD, TYPE_AD_GROUP, TYPE_ALL_ADS, TYPE_UNEXPECTED})
     public @interface Type {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index a993c79b4a..9fac69b281 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -308,7 +308,7 @@ public void seekToUs(long positionUs) {
       // chunk even if the sample timestamps are slightly offset from the chunk start times.
       seekInsideBuffer =
           primarySampleQueue.setReadPosition(seekToMediaChunk.getFirstSampleIndex(0));
-      decodeOnlyUntilPositionUs = Long.MIN_VALUE;
+      decodeOnlyUntilPositionUs = 0;
     } else {
       seekInsideBuffer =
           primarySampleQueue.advanceTo(
@@ -583,7 +583,7 @@ public boolean continueLoading(long positionUs) {
       if (pendingReset) {
         boolean resetToMediaChunk = mediaChunk.startTimeUs == pendingResetPositionUs;
         // Only enable setting of the decode only flag if we're not resetting to a chunk boundary.
-        decodeOnlyUntilPositionUs = resetToMediaChunk ? Long.MIN_VALUE : pendingResetPositionUs;
+        decodeOnlyUntilPositionUs = resetToMediaChunk ? 0 : pendingResetPositionUs;
         pendingResetPositionUs = C.TIME_UNSET;
       }
       mediaChunk.init(mediaChunkOutput);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
index 87dcb97a81..e7bb0e16bf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
@@ -22,6 +22,7 @@
 import android.view.accessibility.CaptioningManager;
 import android.view.accessibility.CaptioningManager.CaptionStyle;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -35,6 +36,7 @@
    * #EDGE_TYPE_OUTLINE}, {@link #EDGE_TYPE_DROP_SHADOW}, {@link #EDGE_TYPE_RAISED} or {@link
    * #EDGE_TYPE_DEPRESSED}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     EDGE_TYPE_NONE,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
index e1305acd14..a5c666c44a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -19,6 +19,7 @@
 import android.graphics.Color;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -36,6 +37,7 @@
    * The type of anchor, which may be unset. One of {@link #TYPE_UNSET}, {@link #ANCHOR_TYPE_START},
    * {@link #ANCHOR_TYPE_MIDDLE} or {@link #ANCHOR_TYPE_END}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
   public @interface AnchorType {}
@@ -66,6 +68,7 @@
    * The type of line, which may be unset. One of {@link #TYPE_UNSET}, {@link #LINE_TYPE_FRACTION}
    * or {@link #LINE_TYPE_NUMBER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
   public @interface LineType {}
@@ -85,6 +88,7 @@
    * {@link #TEXT_SIZE_TYPE_FRACTIONAL}, {@link #TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING} or {@link
    * #TEXT_SIZE_TYPE_ABSOLUTE}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     TYPE_UNSET,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index 5b74bd1505..16f82a7293 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -49,9 +50,13 @@
   @Deprecated
   public interface Output extends TextOutput {}
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({REPLACEMENT_STATE_NONE, REPLACEMENT_STATE_SIGNAL_END_OF_STREAM,
-      REPLACEMENT_STATE_WAIT_END_OF_STREAM})
+  @IntDef({
+    REPLACEMENT_STATE_NONE,
+    REPLACEMENT_STATE_SIGNAL_END_OF_STREAM,
+    REPLACEMENT_STATE_WAIT_END_OF_STREAM
+  })
   private @interface ReplacementState {}
   /**
    * The decoder does not need to be replaced.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 60cdda06c4..3c39fdc6c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -451,7 +452,7 @@ private void handleMiscCode(byte cc2) {
 
     switch (cc2) {
       case CTRL_ERASE_DISPLAYED_MEMORY:
-        cues = null;
+        cues = Collections.emptyList();
         if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
           resetCueBuilders();
         }
@@ -506,7 +507,7 @@ private void setCaptionMode(int captionMode) {
     if (oldCaptionMode == CC_MODE_PAINT_ON || captionMode == CC_MODE_ROLL_UP
         || captionMode == CC_MODE_UNKNOWN) {
       // When switching from paint-on or to roll-up or unknown, we also need to clear the caption.
-      cues = null;
+      cues = Collections.emptyList();
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
index a95f1de738..b3be88b851 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -272,7 +272,10 @@ private void processCurrentPacket() {
     if (serviceNumber == 7) {
       // extended service numbers
       serviceBlockPacket.skipBits(2);
-      serviceNumber += serviceBlockPacket.readBits(6);
+      serviceNumber = serviceBlockPacket.readBits(6);
+      if (serviceNumber < 7) {
+        Log.w(TAG, "Invalid extended service number: " + serviceNumber);
+      }
     }
 
     // Ignore packets in which blockSize is 0
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 5598e063a6..3b039061b0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text.subrip;
 
+import android.support.annotation.Nullable;
 import android.text.Html;
 import android.text.Spanned;
 import android.text.TextUtils;
@@ -32,17 +33,38 @@
  */
 public final class SubripDecoder extends SimpleSubtitleDecoder {
 
+  // Fractional positions for use when alignment tags are present.
+  /* package */ static final float START_FRACTION = 0.08f;
+  /* package */ static final float END_FRACTION = 1 - START_FRACTION;
+  /* package */ static final float MID_FRACTION = 0.5f;
+
   private static final String TAG = "SubripDecoder";
 
   private static final String SUBRIP_TIMECODE = "(?:(\\d+):)?(\\d+):(\\d+),(\\d+)";
   private static final Pattern SUBRIP_TIMING_LINE =
       Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")?\\s*");
 
+  private static final Pattern SUBRIP_TAG_PATTERN = Pattern.compile("\\{\\\\.*?\\}");
+  private static final String SUBRIP_ALIGNMENT_TAG = "\\{\\\\an[1-9]\\}";
+
+  // Alignment tags for SSA V4+.
+  private static final String ALIGN_BOTTOM_LEFT = "{\\an1}";
+  private static final String ALIGN_BOTTOM_MID = "{\\an2}";
+  private static final String ALIGN_BOTTOM_RIGHT = "{\\an3}";
+  private static final String ALIGN_MID_LEFT = "{\\an4}";
+  private static final String ALIGN_MID_MID = "{\\an5}";
+  private static final String ALIGN_MID_RIGHT = "{\\an6}";
+  private static final String ALIGN_TOP_LEFT = "{\\an7}";
+  private static final String ALIGN_TOP_MID = "{\\an8}";
+  private static final String ALIGN_TOP_RIGHT = "{\\an9}";
+
   private final StringBuilder textBuilder;
+  private final ArrayList<String> tags;
 
   public SubripDecoder() {
     super("SubripDecoder");
     textBuilder = new StringBuilder();
+    tags = new ArrayList<>();
   }
 
   @Override
@@ -86,17 +108,29 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
         continue;
       }
 
-      // Read and parse the text.
+      // Read and parse the text and tags.
       textBuilder.setLength(0);
+      tags.clear();
       while (!TextUtils.isEmpty(currentLine = subripData.readLine())) {
         if (textBuilder.length() > 0) {
           textBuilder.append("<br>");
         }
-        textBuilder.append(currentLine.trim());
+        textBuilder.append(processLine(currentLine, tags));
       }
 
       Spanned text = Html.fromHtml(textBuilder.toString());
-      cues.add(new Cue(text));
+
+      String alignmentTag = null;
+      for (int i = 0; i < tags.size(); i++) {
+        String tag = tags.get(i);
+        if (tag.matches(SUBRIP_ALIGNMENT_TAG)) {
+          alignmentTag = tag;
+          // Subsequent alignment tags should be ignored.
+          break;
+        }
+      }
+      cues.add(buildCue(text, alignmentTag));
+
       if (haveEndTimecode) {
         cues.add(null);
       }
@@ -108,6 +142,96 @@ protected SubripSubtitle decode(byte[] bytes, int length, boolean reset) {
     return new SubripSubtitle(cuesArray, cueTimesUsArray);
   }
 
+  /**
+   * Trims and removes tags from the given line. The removed tags are added to {@code tags}.
+   *
+   * @param line The line to process.
+   * @param tags A list to which removed tags will be added.
+   * @return The processed line.
+   */
+  private String processLine(String line, ArrayList<String> tags) {
+    line = line.trim();
+
+    int removedCharacterCount = 0;
+    StringBuilder processedLine = new StringBuilder(line);
+    Matcher matcher = SUBRIP_TAG_PATTERN.matcher(line);
+    while (matcher.find()) {
+      String tag = matcher.group();
+      tags.add(tag);
+      int start = matcher.start() - removedCharacterCount;
+      int tagLength = tag.length();
+      processedLine.replace(start, /* end= */ start + tagLength, /* str= */ "");
+      removedCharacterCount += tagLength;
+    }
+
+    return processedLine.toString();
+  }
+
+  /**
+   * Build a {@link Cue} based on the given text and alignment tag.
+   *
+   * @param text The text.
+   * @param alignmentTag The alignment tag, or {@code null} if no alignment tag is available.
+   * @return Built cue
+   */
+  private Cue buildCue(Spanned text, @Nullable String alignmentTag) {
+    if (alignmentTag == null) {
+      return new Cue(text);
+    }
+
+    // Horizontal alignment.
+    @Cue.AnchorType int positionAnchor;
+    switch (alignmentTag) {
+      case ALIGN_BOTTOM_LEFT:
+      case ALIGN_MID_LEFT:
+      case ALIGN_TOP_LEFT:
+        positionAnchor = Cue.ANCHOR_TYPE_START;
+        break;
+      case ALIGN_BOTTOM_RIGHT:
+      case ALIGN_MID_RIGHT:
+      case ALIGN_TOP_RIGHT:
+        positionAnchor = Cue.ANCHOR_TYPE_END;
+        break;
+      case ALIGN_BOTTOM_MID:
+      case ALIGN_MID_MID:
+      case ALIGN_TOP_MID:
+      default:
+        positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+        break;
+    }
+
+    // Vertical alignment.
+    @Cue.AnchorType int lineAnchor;
+    switch (alignmentTag) {
+      case ALIGN_BOTTOM_LEFT:
+      case ALIGN_BOTTOM_MID:
+      case ALIGN_BOTTOM_RIGHT:
+        lineAnchor = Cue.ANCHOR_TYPE_END;
+        break;
+      case ALIGN_TOP_LEFT:
+      case ALIGN_TOP_MID:
+      case ALIGN_TOP_RIGHT:
+        lineAnchor = Cue.ANCHOR_TYPE_START;
+        break;
+      case ALIGN_MID_LEFT:
+      case ALIGN_MID_MID:
+      case ALIGN_MID_RIGHT:
+      default:
+        lineAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+        break;
+    }
+
+    return new Cue(
+        text,
+        /* textAlignment= */ null,
+        getFractionalPositionForAnchorType(lineAnchor),
+        Cue.LINE_TYPE_FRACTION,
+        lineAnchor,
+        getFractionalPositionForAnchorType(positionAnchor),
+        positionAnchor,
+        Cue.DIMEN_UNSET);
+  }
+
   private static long parseTimecode(Matcher matcher, int groupOffset) {
     long timestampMs = Long.parseLong(matcher.group(groupOffset + 1)) * 60 * 60 * 1000;
     timestampMs += Long.parseLong(matcher.group(groupOffset + 2)) * 60 * 1000;
@@ -116,4 +240,15 @@ private static long parseTimecode(Matcher matcher, int groupOffset) {
     return timestampMs * 1000;
   }
 
+  /* package */ static float getFractionalPositionForAnchorType(@Cue.AnchorType int anchorType) {
+    switch (anchorType) {
+      case Cue.ANCHOR_TYPE_START:
+        return SubripDecoder.START_FRACTION;
+      case Cue.ANCHOR_TYPE_MIDDLE:
+        return SubripDecoder.MID_FRACTION;
+      case Cue.ANCHOR_TYPE_END:
+      default:
+        return SubripDecoder.END_FRACTION;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
index 90f93d5b21..a4f0cca955 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
@@ -19,6 +19,7 @@
 import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -29,25 +30,32 @@
 
   public static final int UNSPECIFIED = -1;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
-      STYLE_BOLD_ITALIC})
+  @IntDef(
+      flag = true,
+      value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC, STYLE_BOLD_ITALIC})
   public @interface StyleFlags {}
+
   public static final int STYLE_NORMAL = Typeface.NORMAL;
   public static final int STYLE_BOLD = Typeface.BOLD;
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
   public @interface FontSizeUnit {}
+
   public static final int FONT_SIZE_UNIT_PIXEL = 1;
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, OFF, ON})
   private @interface OptionalBoolean {}
+
   private static final int OFF = 0;
   private static final int ON = 1;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index 0e46fa0d2f..fe274a6241 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -19,6 +19,7 @@
 import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -39,6 +40,7 @@
    * Style flag enum. Possible flag values are {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link
    * #STYLE_BOLD}, {@link #STYLE_ITALIC} and {@link #STYLE_BOLD_ITALIC}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -54,6 +56,7 @@
    * Font size unit enum. One of {@link #UNSPECIFIED}, {@link #FONT_SIZE_UNIT_PIXEL}, {@link
    * #FONT_SIZE_UNIT_EM} or {@link #FONT_SIZE_UNIT_PERCENT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
   public @interface FontSizeUnit {}
@@ -62,9 +65,11 @@
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, OFF, ON})
   private @interface OptionalBoolean {}
+
   private static final int OFF = 0;
   private static final int ON = 1;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
index 327428af36..06d3c14970 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoder.java
@@ -110,7 +110,7 @@ private static int getNextEvent(ParsableByteArray parsableWebvttData) {
         foundEvent = EVENT_END_OF_FILE;
       } else if (STYLE_START.equals(line)) {
         foundEvent = EVENT_STYLE_BLOCK;
-      } else if (COMMENT_START.startsWith(line)) {
+      } else if (line.startsWith(COMMENT_START)) {
         foundEvent = EVENT_COMMENT;
       } else {
         foundEvent = EVENT_CUE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index 9a15cbae14..798b6ce810 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -160,7 +161,10 @@ public final boolean blacklist(int index, long blacklistDurationMs) {
     if (!canBlacklist) {
       return false;
     }
-    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);
+    blacklistUntilTimes[index] =
+        Math.max(
+            blacklistUntilTimes[index],
+            Util.addWithOverflowDefault(nowMs, blacklistDurationMs, Long.MAX_VALUE));
     return true;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index f5a347b351..4a75b6f722 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -2141,7 +2141,7 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
   }
 
   /** Represents how well an audio track matches the selection {@link Parameters}. */
-  private static final class AudioTrackScore implements Comparable<AudioTrackScore> {
+  protected static final class AudioTrackScore implements Comparable<AudioTrackScore> {
 
     private final Parameters parameters;
     private final int withinRendererCapabilitiesScore;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index c2fda67728..59a4f96fb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -48,6 +49,7 @@
      * {@link #RENDERER_SUPPORT_NO_TRACKS}, {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS}, {@link
      * #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS} or {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS}.
      */
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
       RENDERER_SUPPORT_NO_TRACKS,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index c968921822..4a4cc021f4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -20,6 +20,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -33,6 +34,7 @@
    * The flags that apply to any request for data. Possible flag values are {@link #FLAG_ALLOW_GZIP}
    * and {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -61,6 +63,7 @@
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
    * #HTTP_METHOD_GET}, {@link #HTTP_METHOD_POST} or {@link #HTTP_METHOD_HEAD}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({HTTP_METHOD_GET, HTTP_METHOD_POST, HTTP_METHOD_HEAD})
   public @interface HttpMethod {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
index 06ca83dd93..71e2d8d19f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
@@ -117,19 +117,6 @@ public synchronized void release(Allocation[] allocations) {
           Math.max(availableAllocations.length * 2, availableCount + allocations.length));
     }
     for (Allocation allocation : allocations) {
-      // Weak sanity check that the allocation probably originated from this pool.
-      if (allocation.data != initialAllocationBlock
-          && allocation.data.length != individualAllocationSize) {
-        throw new IllegalArgumentException(
-            "Unexpected allocation: "
-                + System.identityHashCode(allocation.data)
-                + ", "
-                + System.identityHashCode(initialAllocationBlock)
-                + ", "
-                + allocation.data.length
-                + ", "
-                + individualAllocationSize);
-      }
       availableAllocations[availableCount++] = allocation;
     }
     allocatedCount -= allocations.length;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index 6e0fba27ae..e9f70ec92a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -15,20 +15,57 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.content.Context;
 import android.os.Handler;
 import android.support.annotation.Nullable;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.EventDispatcher;
 import com.google.android.exoplayer2.util.SlidingPercentile;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
- * Estimates bandwidth by listening to data transfers. The bandwidth estimate is calculated using a
- * {@link SlidingPercentile} and is updated each time a transfer ends.
+ * Estimates bandwidth by listening to data transfers.
+ *
+ * <p>The bandwidth estimate is calculated using a {@link SlidingPercentile} and is updated each
+ * time a transfer ends. The initial estimate is based on the current operator's network country
+ * code or the locale of the user, as well as the network connection type. This can be configured in
+ * the {@link Builder}.
  */
 public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener {
 
-  /** Default initial bitrate estimate in bits per second. */
+  /**
+   * Country groups used to determine the default initial bitrate estimate. The group assignment for
+   * each country is an array of group indices for [Wifi, 2G, 3G, 4G].
+   */
+  public static final Map<String, int[]> DEFAULT_INITIAL_BITRATE_COUNTRY_GROUPS =
+      createInitialBitrateCountryGroupAssignment();
+
+  /** Default initial Wifi bitrate estimate in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI =
+      new long[] {5_700_000, 3_400_000, 1_900_000, 1_000_000, 400_000};
+
+  /** Default initial 2G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_2G =
+      new long[] {169_000, 129_000, 114_000, 102_000, 87_000};
+
+  /** Default initial 3G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_3G =
+      new long[] {2_100_000, 1_300_000, 950_000, 700_000, 400_000};
+
+  /** Default initial 4G bitrate estimates in bits per second. */
+  public static final long[] DEFAULT_INITIAL_BITRATE_ESTIMATES_4G =
+      new long[] {6_900_000, 4_300_000, 2_700_000, 1_600_000, 450_000};
+
+  /**
+   * Default initial bitrate estimate used when the device is offline or the network type cannot be
+   * determined, in bits per second.
+   */
   public static final long DEFAULT_INITIAL_BITRATE_ESTIMATE = 1_000_000;
 
   /** Default maximum weight for the sliding window. */
@@ -37,15 +74,28 @@
   /** Builder for a bandwidth meter. */
   public static final class Builder {
 
-    private @Nullable Handler eventHandler;
-    private @Nullable EventListener eventListener;
-    private long initialBitrateEstimate;
+    @Nullable private final Context context;
+
+    @Nullable private Handler eventHandler;
+    @Nullable private EventListener eventListener;
+    private SparseArray<Long> initialBitrateEstimates;
     private int slidingWindowMaxWeight;
     private Clock clock;
 
-    /** Creates a builder with default parameters and without listener. */
+    /** @deprecated Use {@link #Builder(Context)} instead. */
+    @Deprecated
     public Builder() {
-      initialBitrateEstimate = DEFAULT_INITIAL_BITRATE_ESTIMATE;
+      this(/* context= */ null);
+    }
+
+    /**
+     * Creates a builder with default parameters and without listener.
+     *
+     * @param context A context.
+     */
+    public Builder(@Nullable Context context) {
+      this.context = context == null ? null : context.getApplicationContext();
+      initialBitrateEstimates = getInitialBitrateEstimatesForCountry(Util.getCountryCode(context));
       slidingWindowMaxWeight = DEFAULT_SLIDING_WINDOW_MAX_WEIGHT;
       clock = Clock.DEFAULT;
     }
@@ -84,7 +134,38 @@ public Builder setSlidingWindowMaxWeight(int slidingWindowMaxWeight) {
      * @return This builder.
      */
     public Builder setInitialBitrateEstimate(long initialBitrateEstimate) {
-      this.initialBitrateEstimate = initialBitrateEstimate;
+      for (int i = 0; i < initialBitrateEstimates.size(); i++) {
+        initialBitrateEstimates.setValueAt(i, initialBitrateEstimate);
+      }
+      return this;
+    }
+
+    /**
+     * Sets the initial bitrate estimate in bits per second for a network type that should be
+     * assumed when a bandwidth estimate is unavailable and the current network connection is of the
+     * specified type.
+     *
+     * @param networkType The {@link C.NetworkType} this initial estimate is for.
+     * @param initialBitrateEstimate The initial bitrate estimate in bits per second.
+     * @return This builder.
+     */
+    public Builder setInitialBitrateEstimate(
+        @C.NetworkType int networkType, long initialBitrateEstimate) {
+      initialBitrateEstimates.put(networkType, initialBitrateEstimate);
+      return this;
+    }
+
+    /**
+     * Sets the initial bitrate estimates to the default values of the specified country. The
+     * initial estimates are used when a bandwidth estimate is unavailable.
+     *
+     * @param countryCode The ISO 3166-1 alpha-2 country code of the country whose default bitrate
+     *     estimates should be used.
+     * @return This builder.
+     */
+    public Builder setInitialBitrateEstimate(String countryCode) {
+      initialBitrateEstimates =
+          getInitialBitrateEstimatesForCountry(Util.toUpperInvariant(countryCode));
       return this;
     }
 
@@ -106,6 +187,10 @@ public Builder setClock(Clock clock) {
      * @return A bandwidth meter with the configured properties.
      */
     public DefaultBandwidthMeter build() {
+      Long initialBitrateEstimate = initialBitrateEstimates.get(Util.getNetworkType(context));
+      if (initialBitrateEstimate == null) {
+        initialBitrateEstimate = initialBitrateEstimates.get(C.NETWORK_TYPE_UNKNOWN);
+      }
       DefaultBandwidthMeter bandwidthMeter =
           new DefaultBandwidthMeter(initialBitrateEstimate, slidingWindowMaxWeight, clock);
       if (eventHandler != null && eventListener != null) {
@@ -113,6 +198,26 @@ public DefaultBandwidthMeter build() {
       }
       return bandwidthMeter;
     }
+
+    private static SparseArray<Long> getInitialBitrateEstimatesForCountry(String countryCode) {
+      int[] groupIndices = getCountryGroupIndices(countryCode);
+      SparseArray<Long> result = new SparseArray<>(/* initialCapacity= */ 6);
+      result.append(C.NETWORK_TYPE_UNKNOWN, DEFAULT_INITIAL_BITRATE_ESTIMATE);
+      result.append(C.NETWORK_TYPE_WIFI, DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI[groupIndices[0]]);
+      result.append(C.NETWORK_TYPE_2G, DEFAULT_INITIAL_BITRATE_ESTIMATES_2G[groupIndices[1]]);
+      result.append(C.NETWORK_TYPE_3G, DEFAULT_INITIAL_BITRATE_ESTIMATES_3G[groupIndices[2]]);
+      result.append(C.NETWORK_TYPE_4G, DEFAULT_INITIAL_BITRATE_ESTIMATES_4G[groupIndices[3]]);
+      // Assume default Wifi bitrate for Ethernet to prevent using the slower fallback bitrate.
+      result.append(
+          C.NETWORK_TYPE_ETHERNET, DEFAULT_INITIAL_BITRATE_ESTIMATES_WIFI[groupIndices[0]]);
+      return result;
+    }
+
+    private static int[] getCountryGroupIndices(String countryCode) {
+      int[] groupIndices = DEFAULT_INITIAL_BITRATE_COUNTRY_GROUPS.get(countryCode);
+      // Assume median group if not found.
+      return groupIndices == null ? new int[] {2, 2, 2, 2} : groupIndices;
+    }
   }
 
   private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
@@ -153,10 +258,7 @@ public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener,
     }
   }
 
-  private DefaultBandwidthMeter(
-      long initialBitrateEstimate,
-      int maxWeight,
-      Clock clock) {
+  private DefaultBandwidthMeter(long initialBitrateEstimate, int maxWeight, Clock clock) {
     this.eventDispatcher = new EventDispatcher<>();
     this.slidingPercentile = new SlidingPercentile(maxWeight);
     this.clock = clock;
@@ -169,7 +271,8 @@ public synchronized long getBitrateEstimate() {
   }
 
   @Override
-  public @Nullable TransferListener getTransferListener() {
+  @Nullable
+  public TransferListener getTransferListener() {
     return this;
   }
 
@@ -237,4 +340,249 @@ public synchronized void onTransferEnd(DataSource source, DataSpec dataSpec, boo
   private void notifyBandwidthSample(int elapsedMs, long bytes, long bitrate) {
     eventDispatcher.dispatch(listener -> listener.onBandwidthSample(elapsedMs, bytes, bitrate));
   }
+
+  private static Map<String, int[]> createInitialBitrateCountryGroupAssignment() {
+    HashMap<String, int[]> countryGroupAssignment = new HashMap<>();
+    countryGroupAssignment.put("AD", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("AE", new int[] {1, 3, 4, 4});
+    countryGroupAssignment.put("AF", new int[] {4, 4, 3, 2});
+    countryGroupAssignment.put("AG", new int[] {3, 2, 1, 2});
+    countryGroupAssignment.put("AI", new int[] {1, 0, 0, 2});
+    countryGroupAssignment.put("AL", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("AM", new int[] {2, 2, 4, 3});
+    countryGroupAssignment.put("AO", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("AR", new int[] {2, 3, 2, 3});
+    countryGroupAssignment.put("AS", new int[] {3, 4, 4, 1});
+    countryGroupAssignment.put("AT", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("AU", new int[] {0, 3, 0, 0});
+    countryGroupAssignment.put("AW", new int[] {1, 1, 0, 4});
+    countryGroupAssignment.put("AX", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("AZ", new int[] {3, 3, 2, 2});
+    countryGroupAssignment.put("BA", new int[] {1, 1, 1, 2});
+    countryGroupAssignment.put("BB", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("BD", new int[] {2, 1, 3, 2});
+    countryGroupAssignment.put("BE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("BF", new int[] {4, 4, 4, 1});
+    countryGroupAssignment.put("BG", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("BH", new int[] {2, 1, 3, 4});
+    countryGroupAssignment.put("BI", new int[] {4, 3, 4, 4});
+    countryGroupAssignment.put("BJ", new int[] {4, 3, 4, 3});
+    countryGroupAssignment.put("BL", new int[] {1, 0, 1, 2});
+    countryGroupAssignment.put("BM", new int[] {1, 0, 0, 0});
+    countryGroupAssignment.put("BN", new int[] {4, 3, 3, 3});
+    countryGroupAssignment.put("BO", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("BQ", new int[] {1, 1, 2, 4});
+    countryGroupAssignment.put("BR", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("BS", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("BT", new int[] {3, 0, 2, 1});
+    countryGroupAssignment.put("BW", new int[] {4, 4, 2, 3});
+    countryGroupAssignment.put("BY", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("BZ", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("CA", new int[] {0, 2, 2, 3});
+    countryGroupAssignment.put("CD", new int[] {4, 4, 2, 1});
+    countryGroupAssignment.put("CF", new int[] {4, 4, 3, 3});
+    countryGroupAssignment.put("CG", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("CH", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("CI", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("CK", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("CL", new int[] {2, 2, 2, 3});
+    countryGroupAssignment.put("CM", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("CN", new int[] {2, 0, 1, 2});
+    countryGroupAssignment.put("CO", new int[] {2, 3, 2, 1});
+    countryGroupAssignment.put("CR", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("CU", new int[] {4, 4, 4, 1});
+    countryGroupAssignment.put("CV", new int[] {2, 2, 2, 4});
+    countryGroupAssignment.put("CW", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CX", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("CY", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("CZ", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("DE", new int[] {0, 2, 2, 2});
+    countryGroupAssignment.put("DJ", new int[] {3, 4, 4, 0});
+    countryGroupAssignment.put("DK", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("DM", new int[] {2, 0, 3, 4});
+    countryGroupAssignment.put("DO", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("DZ", new int[] {3, 3, 4, 4});
+    countryGroupAssignment.put("EC", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("EE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("EG", new int[] {3, 3, 1, 1});
+    countryGroupAssignment.put("EH", new int[] {2, 0, 2, 3});
+    countryGroupAssignment.put("ER", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("ES", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("ET", new int[] {4, 4, 4, 0});
+    countryGroupAssignment.put("FI", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("FJ", new int[] {3, 2, 3, 3});
+    countryGroupAssignment.put("FK", new int[] {3, 4, 2, 1});
+    countryGroupAssignment.put("FM", new int[] {4, 2, 4, 0});
+    countryGroupAssignment.put("FO", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("FR", new int[] {1, 0, 2, 1});
+    countryGroupAssignment.put("GA", new int[] {3, 3, 2, 1});
+    countryGroupAssignment.put("GB", new int[] {0, 1, 3, 2});
+    countryGroupAssignment.put("GD", new int[] {2, 0, 3, 0});
+    countryGroupAssignment.put("GE", new int[] {1, 1, 0, 3});
+    countryGroupAssignment.put("GF", new int[] {1, 2, 4, 4});
+    countryGroupAssignment.put("GG", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("GH", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("GI", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("GL", new int[] {2, 4, 1, 4});
+    countryGroupAssignment.put("GM", new int[] {4, 3, 3, 0});
+    countryGroupAssignment.put("GN", new int[] {4, 4, 3, 4});
+    countryGroupAssignment.put("GP", new int[] {2, 2, 1, 3});
+    countryGroupAssignment.put("GQ", new int[] {4, 4, 3, 1});
+    countryGroupAssignment.put("GR", new int[] {1, 1, 0, 1});
+    countryGroupAssignment.put("GT", new int[] {3, 2, 3, 4});
+    countryGroupAssignment.put("GU", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("GW", new int[] {4, 4, 4, 0});
+    countryGroupAssignment.put("GY", new int[] {3, 4, 1, 0});
+    countryGroupAssignment.put("HK", new int[] {0, 2, 3, 4});
+    countryGroupAssignment.put("HN", new int[] {3, 3, 2, 2});
+    countryGroupAssignment.put("HR", new int[] {1, 0, 0, 2});
+    countryGroupAssignment.put("HT", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("HU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("ID", new int[] {2, 3, 3, 4});
+    countryGroupAssignment.put("IE", new int[] {0, 0, 1, 1});
+    countryGroupAssignment.put("IL", new int[] {0, 1, 1, 3});
+    countryGroupAssignment.put("IM", new int[] {0, 1, 0, 1});
+    countryGroupAssignment.put("IN", new int[] {2, 3, 3, 4});
+    countryGroupAssignment.put("IO", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("IQ", new int[] {3, 3, 4, 3});
+    countryGroupAssignment.put("IR", new int[] {3, 2, 4, 4});
+    countryGroupAssignment.put("IS", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("IT", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("JE", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("JM", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("JO", new int[] {1, 1, 1, 2});
+    countryGroupAssignment.put("JP", new int[] {0, 1, 1, 2});
+    countryGroupAssignment.put("KE", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("KG", new int[] {2, 2, 3, 3});
+    countryGroupAssignment.put("KH", new int[] {1, 0, 4, 4});
+    countryGroupAssignment.put("KI", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("KM", new int[] {4, 4, 2, 2});
+    countryGroupAssignment.put("KN", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("KP", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("KR", new int[] {0, 4, 0, 2});
+    countryGroupAssignment.put("KW", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("KY", new int[] {1, 1, 0, 2});
+    countryGroupAssignment.put("KZ", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("LA", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("LB", new int[] {3, 2, 0, 0});
+    countryGroupAssignment.put("LC", new int[] {2, 2, 1, 0});
+    countryGroupAssignment.put("LI", new int[] {0, 0, 1, 2});
+    countryGroupAssignment.put("LK", new int[] {1, 1, 2, 2});
+    countryGroupAssignment.put("LR", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("LS", new int[] {3, 3, 2, 0});
+    countryGroupAssignment.put("LT", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("LU", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("LV", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("LY", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MA", new int[] {2, 1, 2, 2});
+    countryGroupAssignment.put("MC", new int[] {1, 0, 1, 0});
+    countryGroupAssignment.put("MD", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("ME", new int[] {1, 2, 2, 3});
+    countryGroupAssignment.put("MF", new int[] {1, 4, 3, 3});
+    countryGroupAssignment.put("MG", new int[] {3, 4, 1, 2});
+    countryGroupAssignment.put("MH", new int[] {4, 0, 2, 3});
+    countryGroupAssignment.put("MK", new int[] {1, 0, 0, 1});
+    countryGroupAssignment.put("ML", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("MM", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("MN", new int[] {2, 2, 2, 4});
+    countryGroupAssignment.put("MO", new int[] {0, 1, 4, 4});
+    countryGroupAssignment.put("MP", new int[] {0, 0, 4, 4});
+    countryGroupAssignment.put("MQ", new int[] {1, 1, 1, 3});
+    countryGroupAssignment.put("MR", new int[] {4, 2, 4, 2});
+    countryGroupAssignment.put("MS", new int[] {1, 2, 1, 2});
+    countryGroupAssignment.put("MT", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("MU", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("MV", new int[] {4, 2, 0, 1});
+    countryGroupAssignment.put("MW", new int[] {3, 2, 1, 1});
+    countryGroupAssignment.put("MX", new int[] {2, 4, 3, 1});
+    countryGroupAssignment.put("MY", new int[] {2, 3, 3, 3});
+    countryGroupAssignment.put("MZ", new int[] {3, 3, 2, 4});
+    countryGroupAssignment.put("NA", new int[] {4, 2, 1, 1});
+    countryGroupAssignment.put("NC", new int[] {2, 1, 3, 3});
+    countryGroupAssignment.put("NE", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("NF", new int[] {0, 2, 2, 2});
+    countryGroupAssignment.put("NG", new int[] {3, 4, 2, 2});
+    countryGroupAssignment.put("NI", new int[] {3, 4, 3, 3});
+    countryGroupAssignment.put("NL", new int[] {0, 1, 3, 2});
+    countryGroupAssignment.put("NO", new int[] {0, 0, 1, 0});
+    countryGroupAssignment.put("NP", new int[] {2, 3, 2, 2});
+    countryGroupAssignment.put("NR", new int[] {4, 3, 4, 1});
+    countryGroupAssignment.put("NU", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("NZ", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("OM", new int[] {2, 2, 1, 3});
+    countryGroupAssignment.put("PA", new int[] {1, 3, 2, 3});
+    countryGroupAssignment.put("PE", new int[] {2, 2, 4, 4});
+    countryGroupAssignment.put("PF", new int[] {2, 2, 0, 1});
+    countryGroupAssignment.put("PG", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("PH", new int[] {3, 0, 4, 4});
+    countryGroupAssignment.put("PK", new int[] {3, 3, 3, 3});
+    countryGroupAssignment.put("PL", new int[] {1, 0, 1, 3});
+    countryGroupAssignment.put("PM", new int[] {0, 2, 2, 3});
+    countryGroupAssignment.put("PR", new int[] {2, 3, 4, 3});
+    countryGroupAssignment.put("PS", new int[] {2, 3, 0, 4});
+    countryGroupAssignment.put("PT", new int[] {1, 1, 1, 1});
+    countryGroupAssignment.put("PW", new int[] {3, 2, 3, 0});
+    countryGroupAssignment.put("PY", new int[] {2, 1, 3, 3});
+    countryGroupAssignment.put("QA", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("RE", new int[] {1, 1, 2, 2});
+    countryGroupAssignment.put("RO", new int[] {0, 1, 1, 3});
+    countryGroupAssignment.put("RS", new int[] {1, 1, 0, 0});
+    countryGroupAssignment.put("RU", new int[] {0, 1, 1, 1});
+    countryGroupAssignment.put("RW", new int[] {3, 4, 3, 1});
+    countryGroupAssignment.put("SA", new int[] {3, 2, 2, 3});
+    countryGroupAssignment.put("SB", new int[] {4, 4, 3, 0});
+    countryGroupAssignment.put("SC", new int[] {4, 2, 0, 1});
+    countryGroupAssignment.put("SD", new int[] {3, 4, 4, 4});
+    countryGroupAssignment.put("SE", new int[] {0, 0, 0, 0});
+    countryGroupAssignment.put("SG", new int[] {1, 2, 3, 3});
+    countryGroupAssignment.put("SH", new int[] {4, 2, 2, 2});
+    countryGroupAssignment.put("SI", new int[] {0, 1, 0, 0});
+    countryGroupAssignment.put("SJ", new int[] {3, 2, 0, 2});
+    countryGroupAssignment.put("SK", new int[] {0, 1, 0, 1});
+    countryGroupAssignment.put("SL", new int[] {4, 3, 2, 4});
+    countryGroupAssignment.put("SM", new int[] {1, 0, 1, 1});
+    countryGroupAssignment.put("SN", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("SO", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("SR", new int[] {3, 2, 2, 3});
+    countryGroupAssignment.put("SS", new int[] {4, 3, 4, 2});
+    countryGroupAssignment.put("ST", new int[] {3, 2, 2, 2});
+    countryGroupAssignment.put("SV", new int[] {2, 3, 2, 3});
+    countryGroupAssignment.put("SX", new int[] {2, 4, 2, 0});
+    countryGroupAssignment.put("SY", new int[] {4, 4, 2, 0});
+    countryGroupAssignment.put("SZ", new int[] {3, 4, 1, 1});
+    countryGroupAssignment.put("TC", new int[] {2, 1, 2, 1});
+    countryGroupAssignment.put("TD", new int[] {4, 4, 4, 3});
+    countryGroupAssignment.put("TG", new int[] {3, 2, 2, 0});
+    countryGroupAssignment.put("TH", new int[] {1, 3, 4, 4});
+    countryGroupAssignment.put("TJ", new int[] {4, 4, 4, 4});
+    countryGroupAssignment.put("TL", new int[] {4, 2, 4, 4});
+    countryGroupAssignment.put("TM", new int[] {4, 1, 3, 3});
+    countryGroupAssignment.put("TN", new int[] {2, 2, 1, 2});
+    countryGroupAssignment.put("TO", new int[] {2, 3, 3, 1});
+    countryGroupAssignment.put("TR", new int[] {1, 2, 0, 2});
+    countryGroupAssignment.put("TT", new int[] {2, 1, 1, 0});
+    countryGroupAssignment.put("TV", new int[] {4, 2, 2, 4});
+    countryGroupAssignment.put("TW", new int[] {0, 0, 0, 1});
+    countryGroupAssignment.put("TZ", new int[] {3, 3, 3, 2});
+    countryGroupAssignment.put("UA", new int[] {0, 2, 1, 3});
+    countryGroupAssignment.put("UG", new int[] {4, 3, 2, 2});
+    countryGroupAssignment.put("US", new int[] {0, 1, 3, 3});
+    countryGroupAssignment.put("UY", new int[] {2, 1, 2, 2});
+    countryGroupAssignment.put("UZ", new int[] {4, 3, 2, 4});
+    countryGroupAssignment.put("VA", new int[] {1, 2, 2, 2});
+    countryGroupAssignment.put("VC", new int[] {2, 0, 3, 2});
+    countryGroupAssignment.put("VE", new int[] {3, 4, 4, 3});
+    countryGroupAssignment.put("VG", new int[] {3, 1, 3, 4});
+    countryGroupAssignment.put("VI", new int[] {1, 0, 2, 4});
+    countryGroupAssignment.put("VN", new int[] {0, 2, 4, 4});
+    countryGroupAssignment.put("VU", new int[] {4, 1, 3, 2});
+    countryGroupAssignment.put("WS", new int[] {3, 2, 3, 0});
+    countryGroupAssignment.put("XK", new int[] {1, 2, 1, 0});
+    countryGroupAssignment.put("YE", new int[] {4, 4, 4, 2});
+    countryGroupAssignment.put("YT", new int[] {3, 1, 1, 2});
+    countryGroupAssignment.put("ZA", new int[] {2, 3, 1, 2});
+    countryGroupAssignment.put("ZM", new int[] {3, 3, 3, 1});
+    countryGroupAssignment.put("ZW", new int[] {3, 3, 2, 1});
+    return Collections.unmodifiableMap(countryGroupAssignment);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index acb2c59e0c..6504562c58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -261,9 +262,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
 
   @Override
   public Map<String, List<String>> getResponseHeaders() {
-    return dataSource == null
-        ? DataSource.super.getResponseHeaders()
-        : dataSource.getResponseHeaders();
+    return dataSource == null ? Collections.emptyMap() : dataSource.getResponseHeaders();
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 3673af5540..c6749e6c8f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -283,8 +283,10 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     int responseCode;
+    String responseMessage;
     try {
       responseCode = connection.getResponseCode();
+      responseMessage = connection.getResponseMessage();
     } catch (IOException e) {
       closeConnectionQuietly();
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
@@ -296,7 +298,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       Map<String, List<String>> headers = connection.getHeaderFields();
       closeConnectionQuietly();
       InvalidResponseCodeException exception =
-          new InvalidResponseCodeException(responseCode, headers, dataSpec);
+          new InvalidResponseCodeException(responseCode, responseMessage, headers, dataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index daf5d3281a..e3e93bd6fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -16,10 +16,12 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -226,9 +228,11 @@ protected abstract HttpDataSource createDataSourceInternal(RequestProperties
    */
   class HttpDataSourceException extends IOException {
 
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({TYPE_OPEN, TYPE_READ, TYPE_CLOSE})
     public @interface Type {}
+
     public static final int TYPE_OPEN = 1;
     public static final int TYPE_READ = 2;
     public static final int TYPE_CLOSE = 3;
@@ -291,15 +295,29 @@ public InvalidContentTypeException(String contentType, DataSpec dataSpec) {
      */
     public final int responseCode;
 
+    /** The http status message. */
+    @Nullable public final String responseMessage;
+
     /**
      * An unmodifiable map of the response header fields and values.
      */
     public final Map<String, List<String>> headerFields;
 
-    public InvalidResponseCodeException(int responseCode, Map<String, List<String>> headerFields,
+    /** @deprecated Use {@link #InvalidResponseCodeException(int, String, Map, DataSpec)}. */
+    @Deprecated
+    public InvalidResponseCodeException(
+        int responseCode, Map<String, List<String>> headerFields, DataSpec dataSpec) {
+      this(responseCode, /* responseMessage= */ null, headerFields, dataSpec);
+    }
+
+    public InvalidResponseCodeException(
+        int responseCode,
+        @Nullable String responseMessage,
+        Map<String, List<String>> headerFields,
         DataSpec dataSpec) {
       super("Response code: " + responseCode, dataSpec, TYPE_OPEN);
       this.responseCode = responseCode;
+      this.responseMessage = responseMessage;
       this.headerFields = headerFields;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 03219380c7..ac3b3c5c5e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.concurrent.ExecutorService;
@@ -136,6 +137,7 @@ LoadErrorAction onLoadError(
   }
 
   /** Types of action that can be taken in response to a load error. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     ACTION_TYPE_RETRY,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index a91e3246cc..3a96544c54 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -31,8 +31,10 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -59,6 +61,7 @@
    * Flags controlling the cache's behavior. Possible flag values are {@link #FLAG_BLOCK_ON_CACHE},
    * {@link #FLAG_IGNORE_CACHE_ON_ERROR} and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -91,6 +94,7 @@
    * Reasons the cache may be ignored. One of {@link #CACHE_IGNORED_REASON_ERROR} or {@link
    * #CACHE_IGNORED_REASON_UNSET_LENGTH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({CACHE_IGNORED_REASON_ERROR, CACHE_IGNORED_REASON_UNSET_LENGTH})
   public @interface CacheIgnoredReason {}
@@ -358,7 +362,7 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
     // TODO: Implement.
     return isReadingFromUpstream()
         ? upstreamDataSource.getResponseHeaders()
-        : DataSource.super.getResponseHeaders();
+        : Collections.emptyMap();
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
index 90e37de828..deb981f0e8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EGLSurfaceTexture.java
@@ -26,6 +26,7 @@
 import android.os.Handler;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -43,6 +44,7 @@
    * Secure mode to be used by the EGL surface and context. One of {@link #SECURE_MODE_NONE}, {@link
    * #SECURE_MODE_SURFACELESS_CONTEXT} or {@link #SECURE_MODE_PROTECTED_PBUFFER}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({SECURE_MODE_NONE, SECURE_MODE_SURFACELESS_CONTEXT, SECURE_MODE_PROTECTED_PBUFFER})
   public @interface SecureMode {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java
index 26c02d8ae9..07f278c808 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventDispatcher.java
@@ -39,22 +39,23 @@
   /** The list of listeners and handlers. */
   private final CopyOnWriteArrayList<HandlerAndListener<T>> listeners;
 
-  /** Creates event dispatcher. */
+  /** Creates an event dispatcher. */
   public EventDispatcher() {
     listeners = new CopyOnWriteArrayList<>();
   }
 
-  /** Adds listener to event dispatcher. */
+  /** Adds a listener to the event dispatcher. */
   public void addListener(Handler handler, T eventListener) {
     Assertions.checkArgument(handler != null && eventListener != null);
     removeListener(eventListener);
     listeners.add(new HandlerAndListener<>(handler, eventListener));
   }
 
-  /** Removes listener from event dispatcher. */
+  /** Removes a listener from the event dispatcher. */
   public void removeListener(T eventListener) {
     for (HandlerAndListener<T> handlerAndListener : listeners) {
       if (handlerAndListener.listener == eventListener) {
+        handlerAndListener.release();
         listeners.remove(handlerAndListener);
       }
     }
@@ -67,19 +68,33 @@ public void removeListener(T eventListener) {
    */
   public void dispatch(Event<T> event) {
     for (HandlerAndListener<T> handlerAndListener : listeners) {
-      T eventListener = handlerAndListener.listener;
-      handlerAndListener.handler.post(() -> event.sendTo(eventListener));
+      handlerAndListener.dispatch(event);
     }
   }
 
   private static final class HandlerAndListener<T> {
 
-    public final Handler handler;
-    public final T listener;
+    private final Handler handler;
+    private final T listener;
+
+    private boolean released;
 
     public HandlerAndListener(Handler handler, T eventListener) {
       this.handler = handler;
       this.listener = eventListener;
     }
+
+    public void release() {
+      released = true;
+    }
+
+    public void dispatch(Event<T> event) {
+      handler.post(
+          () -> {
+            if (!released) {
+              event.sendTo(listener);
+            }
+          });
+    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
index 6a1e686dec..34fb684d25 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Log.java
@@ -18,6 +18,7 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import android.text.TextUtils;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -28,6 +29,7 @@
    * Log level for ExoPlayer logcat logging. One of {@link #LOG_LEVEL_ALL}, {@link #LOG_LEVEL_INFO},
    * {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR} or {@link #LOG_LEVEL_OFF}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({LOG_LEVEL_ALL, LOG_LEVEL_INFO, LOG_LEVEL_WARNING, LOG_LEVEL_ERROR, LOG_LEVEL_OFF})
   @interface LogLevel {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index f56aac7c70..e506ae1b19 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -207,7 +207,7 @@ public static boolean isApplication(@Nullable String mimeType) {
     if (codec == null) {
       return null;
     }
-    codec = codec.trim();
+    codec = Util.toLowerInvariant(codec.trim());
     if (codec.startsWith("avc1") || codec.startsWith("avc3")) {
       return MimeTypes.VIDEO_H264;
     } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
@@ -245,6 +245,8 @@ public static boolean isApplication(@Nullable String mimeType) {
       return MimeTypes.AUDIO_OPUS;
     } else if (codec.startsWith("vorbis")) {
       return MimeTypes.AUDIO_VORBIS;
+    } else if (codec.startsWith("flac")) {
+      return MimeTypes.AUDIO_FLAC;
     } else {
       return getCustomMimeTypeForCodec(codec);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
index e70f576754..e45ab0952e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NotificationUtil.java
@@ -24,6 +24,7 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import android.support.annotation.StringRes;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -36,6 +37,7 @@
    * #IMPORTANCE_NONE}, {@link #IMPORTANCE_MIN}, {@link #IMPORTANCE_LOW}, {@link
    * #IMPORTANCE_DEFAULT} or {@link #IMPORTANCE_HIGH}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     IMPORTANCE_UNSPECIFIED,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index 464061153f..b928ffc02b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -67,6 +67,12 @@ public ParsableByteArray(byte[] data, int limit) {
     this.limit = limit;
   }
 
+  /** Sets the position and limit to zero. */
+  public void reset() {
+    position = 0;
+    limit = 0;
+  }
+
   /**
    * Resets the position to zero and the limit to the specified value. If the limit exceeds the
    * capacity, {@code data} is replaced with a new array of sufficient size.
@@ -77,6 +83,16 @@ public void reset(int limit) {
     reset(capacity() < limit ? new byte[limit] : data, limit);
   }
 
+  /**
+   * Updates the instance to wrap {@code data}, and resets the position to zero and the limit to
+   * {@code data.length}.
+   *
+   * @param data The array to wrap.
+   */
+  public void reset(byte[] data) {
+    reset(data, data.length);
+  }
+
   /**
    * Updates the instance to wrap {@code data}, and resets the position to zero.
    *
@@ -89,14 +105,6 @@ public void reset(byte[] data, int limit) {
     position = 0;
   }
 
-  /**
-   * Sets the position and limit to zero.
-   */
-  public void reset() {
-    position = 0;
-    limit = 0;
-  }
-
   /**
    * Returns the number of bytes yet to be read.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
index de92e1ad93..cc23c9763c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/RepeatModeUtil.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.Player;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -25,11 +26,13 @@
  */
 public final class RepeatModeUtil {
 
+  // LINT.IfChange
   /**
    * Set of repeat toggle modes. Can be combined using bit-wise operations. Possible flag values are
    * {@link #REPEAT_TOGGLE_MODE_NONE}, {@link #REPEAT_TOGGLE_MODE_ONE} and {@link
    * #REPEAT_TOGGLE_MODE_ALL}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
@@ -45,6 +48,7 @@
   public static final int REPEAT_TOGGLE_MODE_ONE = 1;
   /** "Repeat All" button enabled. */
   public static final int REPEAT_TOGGLE_MODE_ALL = 1 << 1; // 2
+  // LINT.ThenChange(../../../../../../../../../ui/src/main/res/values/attrs.xml)
 
   private RepeatModeUtil() {
     // Prevent instantiation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index d217b47785..79adc87509 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -1329,6 +1329,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
           case "A7010a48":
           case "A7020a48":
           case "AquaPowerM":
+          case "ASUS_X00AD_2":
           case "Aura_Note_2":
           case "BLACK-1X":
           case "BRAVIA_ATV2":
@@ -1369,6 +1370,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
           case "HWBLN-H":
           case "HWCAM-H":
           case "HWVNS-H":
+          case "i9031":
           case "iball8735_9806":
           case "Infinix-X572":
           case "iris60":
@@ -1376,6 +1378,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
           case "j2xlteins":
           case "JGZ":
           case "K50a40":
+          case "kate":
           case "le_x6":
           case "LS-5017":
           case "M5c":
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
index 0a9d04bf0f..3d4879d50a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/Projection.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.StereoMode;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -26,6 +27,7 @@
 public final class Projection {
 
   /** Enforces allowed (sub) mesh draw modes. */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({DRAW_MODE_TRIANGLES, DRAW_MODE_TRIANGLES_STRIP, DRAW_MODE_TRIANGLES_FAN})
   public @interface DrawMode {}
diff --git a/library/core/src/test/assets/subrip/typical_with_tags b/library/core/src/test/assets/subrip/typical_with_tags
new file mode 100644
index 0000000000..85e304b498
--- /dev/null
+++ b/library/core/src/test/assets/subrip/typical_with_tags
@@ -0,0 +1,56 @@
+1
+00:00:00,000 --> 00:00:01,234
+This is {\an1} the first subtitle.
+
+2
+00:00:02,345 --> 00:00:03,456
+This is the second subtitle.
+Second {\ an 2} subtitle with second line.
+
+3
+00:00:04,567 --> 00:00:08,901
+This {\an2} is the third {\ tag} subtitle.
+
+4
+00:00:09,567 --> 00:00:12,901
+This { \an2} is not a valid tag due to the space after the opening bracket.
+
+5
+00:00:013,567 --> 00:00:14,901
+This {\an2} is the fifth subtitle with multiple {\xyz} valid {\qwe} tags.
+
+6
+00:00:015,567 --> 00:00:15,901
+This {\an1} is a lines.
+
+7
+00:00:016,567 --> 00:00:16,901
+This {\an2} is a line.
+
+8
+00:00:017,567 --> 00:00:17,901
+This {\an3} is a line.
+
+9
+00:00:018,567 --> 00:00:18,901
+This {\an4} is a line.
+
+10
+00:00:019,567 --> 00:00:19,901
+This {\an5} is a line.
+
+11
+00:00:020,567 --> 00:00:20,901
+This {\an6} is a line.
+
+12
+00:00:021,567 --> 00:00:22,901
+This {\an7} is a line.
+
+13
+00:00:023,567 --> 00:00:23,901
+This {\an8} is a line.
+
+14
+00:00:024,567 --> 00:00:24,901
+This {\an9} is a line.
diff --git a/library/core/src/test/assets/ts/sample.ts.1.dump b/library/core/src/test/assets/ts/sample.ts.1.dump
index 7454a02141..5c361e1246 100644
--- a/library/core/src/test/assets/ts/sample.ts.1.dump
+++ b/library/core/src/test/assets/ts/sample.ts.1.dump
@@ -26,10 +26,14 @@ track 256:
     drmInitData = -
     initializationData:
       data = length 22, hash CE183139
-  total output bytes = 24315
-  sample count = 1
+  total output bytes = 45026
+  sample count = 2
   sample 0:
-    time = 55611
+    time = 55610
+    flags = 1
+    data = length 20711, hash 34341E8
+  sample 1:
+    time = 88977
     flags = 0
     data = length 18112, hash EC44B35B
 track 257:
@@ -57,19 +61,19 @@ track 257:
   total output bytes = 5015
   sample count = 4
   sample 0:
-    time = 11333
+    time = 44699
     flags = 1
     data = length 1253, hash 727FD1C6
   sample 1:
-    time = 37455
+    time = 70821
     flags = 1
     data = length 1254, hash 73FB07B8
   sample 2:
-    time = 63578
+    time = 96944
     flags = 1
     data = length 1254, hash 73FB07B8
   sample 3:
-    time = 89700
+    time = 123066
     flags = 1
     data = length 1254, hash 73FB07B8
 track 8448:
diff --git a/library/core/src/test/assets/ts/sample.ts.2.dump b/library/core/src/test/assets/ts/sample.ts.2.dump
index c7cef05b93..cec91ae2b9 100644
--- a/library/core/src/test/assets/ts/sample.ts.2.dump
+++ b/library/core/src/test/assets/ts/sample.ts.2.dump
@@ -26,10 +26,14 @@ track 256:
     drmInitData = -
     initializationData:
       data = length 22, hash CE183139
-  total output bytes = 24315
-  sample count = 1
+  total output bytes = 45026
+  sample count = 2
   sample 0:
-    time = 77855
+    time = 77854
+    flags = 1
+    data = length 20711, hash 34341E8
+  sample 1:
+    time = 111221
     flags = 0
     data = length 18112, hash EC44B35B
 track 257:
@@ -57,19 +61,19 @@ track 257:
   total output bytes = 5015
   sample count = 4
   sample 0:
-    time = 33577
+    time = 66943
     flags = 1
     data = length 1253, hash 727FD1C6
   sample 1:
-    time = 59699
+    time = 93065
     flags = 1
     data = length 1254, hash 73FB07B8
   sample 2:
-    time = 85822
+    time = 119188
     flags = 1
     data = length 1254, hash 73FB07B8
   sample 3:
-    time = 111944
+    time = 145310
     flags = 1
     data = length 1254, hash 73FB07B8
 track 8448:
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
index b066cc263a..93ec5e0264 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/DefaultLoadControlTest.java
@@ -48,15 +48,15 @@ public void testShouldContinueLoading_untilMaxBufferExceeded() {
     createDefaultLoadControl();
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isTrue();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isTrue();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1, SPEED)).isTrue();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
   public void testShouldNotContinueLoadingOnceBufferingStopped_untilBelowMinBuffer() {
     createDefaultLoadControl();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US - 1, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1, SPEED)).isTrue();
   }
@@ -69,7 +69,7 @@ public void testShouldContinueLoadingWithTargetBufferBytesReached_untilMinBuffer
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US - 1, SPEED)).isTrue();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
@@ -82,7 +82,7 @@ public void testShouldNeverContinueLoading_ifMaxBufferReachedAndNotPrioritizeTim
 
     assertThat(loadControl.shouldContinueLoading(/* bufferedDurationUs= */ 0, SPEED)).isFalse();
     assertThat(loadControl.shouldContinueLoading(MIN_BUFFER_US, SPEED)).isFalse();
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, SPEED)).isFalse();
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, SPEED)).isFalse();
   }
 
   @Test
@@ -100,7 +100,7 @@ public void testShouldContinueLoadingWithMinBufferReached_inFastPlayback() {
   public void testShouldNotContinueLoadingWithMaxBufferReached_inFastPlayback() {
     createDefaultLoadControl();
 
-    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US + 1, /* playbackSpeed= */ 100f))
+    assertThat(loadControl.shouldContinueLoading(MAX_BUFFER_US, /* playbackSpeed= */ 100f))
         .isFalse();
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index 8414be1588..d131ed0f51 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -60,6 +60,7 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
@@ -1346,7 +1347,7 @@ public void testRestartAfterEmptyTimelineWithShuffleModeEnabledUsesCorrectFirstP
                 () ->
                     concatenatingMediaSource.addMediaSources(
                         Arrays.asList(mediaSource, mediaSource)))
-            .waitForTimelineChanged(null)
+            .waitForTimelineChanged()
             .executeRunnable(
                 new PlayerRunnable() {
                   @Override
@@ -2192,14 +2193,14 @@ public void testClippedLoopedPeriodsArePlayedFully() throws Exception {
             startPositionUs + expectedDurationUs);
     Clock clock = new AutoAdvancingFakeClock();
     AtomicReference<Player> playerReference = new AtomicReference<>();
-    AtomicReference<Long> positionAtDiscontinuityMs = new AtomicReference<>();
-    AtomicReference<Long> clockAtStartMs = new AtomicReference<>();
-    AtomicReference<Long> clockAtDiscontinuityMs = new AtomicReference<>();
+    AtomicLong positionAtDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
+    AtomicLong clockAtStartMs = new AtomicLong(C.TIME_UNSET);
+    AtomicLong clockAtDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
     EventListener eventListener =
         new EventListener() {
           @Override
           public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-            if (playbackState == Player.STATE_READY && clockAtStartMs.get() == null) {
+            if (playbackState == Player.STATE_READY && clockAtStartMs.get() == C.TIME_UNSET) {
               clockAtStartMs.set(clock.elapsedRealtime());
             }
           }
@@ -2446,6 +2447,146 @@ public void removingLoopingLastPeriodFromPlaylistDoesNotThrow() throws Exception
         .blockUntilEnded(TIMEOUT_MS);
   }
 
+  @Test
+  public void seekToUnpreparedWindowWithNonZeroOffsetInConcatenationStartsAtCorrectPosition()
+      throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    FakeMediaSource mediaSource = new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    MediaSource clippedMediaSource =
+        new ClippingMediaSource(
+            mediaSource,
+            /* startPositionUs= */ 3 * C.MICROS_PER_SECOND,
+            /* endPositionUs= */ C.TIME_END_OF_SOURCE);
+    MediaSource concatenatedMediaSource = new ConcatenatingMediaSource(clippedMediaSource);
+    AtomicLong positionWhenReady = new AtomicLong();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("seekToUnpreparedWindowWithNonZeroOffsetInConcatenation")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .seek(/* positionMs= */ 10)
+            .waitForTimelineChanged()
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
+            .waitForTimelineChanged()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionWhenReady.set(player.getContentPosition());
+                  }
+                })
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(concatenatedMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(positionWhenReady.get()).isEqualTo(10);
+  }
+
+  @Test
+  public void seekToUnpreparedWindowWithMultiplePeriodsInConcatenationStartsAtCorrectPeriod()
+      throws Exception {
+    long periodDurationMs = 5000;
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount =*/ 2,
+                /* id= */ new Object(),
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ 2 * periodDurationMs * 1000));
+    FakeMediaSource mediaSource = new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    MediaSource concatenatedMediaSource = new ConcatenatingMediaSource(mediaSource);
+    AtomicInteger periodIndexWhenReady = new AtomicInteger();
+    AtomicLong positionWhenReady = new AtomicLong();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("seekToUnpreparedWindowWithMultiplePeriodsInConcatenation")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Seek 10ms into the second period.
+            .seek(/* positionMs= */ periodDurationMs + 10)
+            .waitForTimelineChanged()
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
+            .waitForTimelineChanged()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    periodIndexWhenReady.set(player.getCurrentPeriodIndex());
+                    positionWhenReady.set(player.getContentPosition());
+                  }
+                })
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(concatenatedMediaSource)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(periodIndexWhenReady.get()).isEqualTo(1);
+    assertThat(positionWhenReady.get()).isEqualTo(periodDurationMs + 10);
+  }
+
+  @Test
+  public void periodTransitionReportsCorrectBufferedPosition() throws Exception {
+    int periodCount = 3;
+    long periodDurationUs = 5 * C.MICROS_PER_SECOND;
+    long windowDurationUs = periodCount * periodDurationUs;
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                periodCount,
+                /* id= */ new Object(),
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                windowDurationUs));
+    AtomicReference<Player> playerReference = new AtomicReference<>();
+    AtomicLong bufferedPositionAtFirstDiscontinuityMs = new AtomicLong(C.TIME_UNSET);
+    EventListener eventListener =
+        new EventListener() {
+          @Override
+          public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+            if (reason == Player.DISCONTINUITY_REASON_PERIOD_TRANSITION) {
+              if (bufferedPositionAtFirstDiscontinuityMs.get() == C.TIME_UNSET) {
+                bufferedPositionAtFirstDiscontinuityMs.set(
+                    playerReference.get().getBufferedPosition());
+              }
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("periodTransitionReportsCorrectBufferedPosition")
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    playerReference.set(player);
+                    player.addListener(eventListener);
+                  }
+                })
+            .pause()
+            // Wait until all periods are fully buffered.
+            .waitForIsLoading(/* targetIsLoading= */ true)
+            .waitForIsLoading(/* targetIsLoading= */ false)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(bufferedPositionAtFirstDiscontinuityMs.get()).isEqualTo(C.usToMs(windowDurationUs));
+  }
+
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
index e0feae6f49..3649685f3e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
@@ -585,7 +585,7 @@ public void testDynamicTimelineChange() throws Exception {
                 () ->
                     concatenatedMediaSource.moveMediaSource(
                         /* currentIndex= */ 0, /* newIndex= */ 1))
-            .waitForTimelineChanged(/* expectedTimeline= */ null)
+            .waitForTimelineChanged()
             .play()
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(concatenatedMediaSource, actionSchedule);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
index 1cf812559c..086c4ebc7f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
@@ -58,7 +58,38 @@ public void setAudioAttributes_withNullUsage_doesNotManageAudioFocus() {
     assertThat(
             audioFocusManager.setAudioAttributes(
                 /* audioAttributes= */ null, /* playWhenReady= */ false, Player.STATE_IDLE))
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request).isNull();
+  }
+
+  @Test
+  public void setAudioAttributes_withNullUsage_releasesAudioFocus() {
+    // Create attributes and request audio focus.
+    AudioAttributes media = new AudioAttributes.Builder().setUsage(C.USAGE_MEDIA).build();
+    Shadows.shadowOf(audioManager)
+        .setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_GRANTED);
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                media, /* playWhenReady= */ true, Player.STATE_READY))
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    ShadowAudioManager.AudioFocusRequest request =
+        Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
+    assertThat(request.durationHint).isEqualTo(AudioManager.AUDIOFOCUS_GAIN);
+
+    // Ensure that setting null audio attributes with audio focus releases audio focus.
+    assertThat(
+            audioFocusManager.setAudioAttributes(
+                /* audioAttributes= */ null, /* playWhenReady= */ true, Player.STATE_READY))
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+    AudioManager.OnAudioFocusChangeListener lastRequest =
+        Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener();
+    assertThat(lastRequest).isNotNull();
   }
 
   @Test
@@ -117,7 +148,7 @@ public void handlePrepare_afterSetAudioAttributes_setsPlayerCommandPlayWhenReady
     assertThat(
             audioFocusManager.setAudioAttributes(
                 media, /* playWhenReady= */ true, Player.STATE_IDLE))
-        .isEqualTo(PLAYER_COMMAND_WAIT_FOR_CALLBACK);
+        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
     assertThat(Shadows.shadowOf(audioManager).getLastAudioFocusRequest()).isNull();
     assertThat(audioFocusManager.handlePrepare(/* playWhenReady= */ true))
         .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
@@ -296,7 +327,7 @@ public void handleStop_withoutHandlingAudioFocus_isNoOp() {
     assertThat(
             audioFocusManager.setAudioAttributes(
                 /* audioAttributes= */ null, /* playWhenReady= */ false, Player.STATE_READY))
-        .isEqualTo(PLAYER_COMMAND_PLAY_WHEN_READY);
+        .isEqualTo(PLAYER_COMMAND_DO_NOT_PLAY);
     assertThat(Shadows.shadowOf(audioManager).getLastAbandonedAudioFocusListener()).isNull();
     ShadowAudioManager.AudioFocusRequest request =
         Shadows.shadowOf(audioManager).getLastAudioFocusRequest();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index a96dfaf2f8..8b26361578 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -338,6 +338,23 @@ public void testPeekFully() throws Exception {
     }
   }
 
+  @Test
+  public void testPeekFullyAfterEofExceptionPeeksAsExpected() throws Exception {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length + 10];
+
+    try {
+      input.peekFully(target, /* offset= */ 0, target.length);
+      fail();
+    } catch (EOFException expected) {
+      // Do nothing. Expected.
+    }
+    input.peekFully(target, /* offset= */ 0, /* length= */ TEST_DATA.length);
+
+    assertThat(input.getPeekPosition()).isEqualTo(TEST_DATA.length);
+    assertThat(Arrays.equals(TEST_DATA, Arrays.copyOf(target, TEST_DATA.length))).isTrue();
+  }
+
   @Test
   public void testResetPeekPosition() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
new file mode 100644
index 0000000000..3e6520beca
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/MlltFrameTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link MlltFrame}. */
+@RunWith(RobolectricTestRunner.class)
+public final class MlltFrameTest {
+
+  @Test
+  public void testParcelable() {
+    MlltFrame mlltFrameToParcel =
+        new MlltFrame(
+            /* mpegFramesBetweenReference= */ 1,
+            /* bytesBetweenReference= */ 1,
+            /* millisecondsBetweenReference= */ 1,
+            /* bytesDeviations= */ new int[] {1, 2},
+            /* millisecondsDeviations= */ new int[] {1, 2});
+
+    Parcel parcel = Parcel.obtain();
+    mlltFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    MlltFrame mlltFrameFromParcel = MlltFrame.CREATOR.createFromParcel(parcel);
+    assertThat(mlltFrameFromParcel).isEqualTo(mlltFrameToParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
index d3d3b39ea4..dd1221f160 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -925,6 +925,22 @@ public void testChildSourceWithLazyPreparationOnlyPreparesSourceOnce() throws IO
     testRunner.createPeriod(mediaPeriodId);
   }
 
+  @Test
+  public void testRemoveUnpreparedChildSourceWithLazyPreparation() throws IOException {
+    FakeMediaSource[] childSources = createMediaSources(/* count= */ 2);
+    mediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            /* useLazyPreparation= */ true,
+            new DefaultShuffleOrder(0),
+            childSources);
+    testRunner = new MediaSourceTestRunner(mediaSource, /* allocator= */ null);
+    testRunner.prepareSource();
+
+    // Check that removal doesn't throw even though the child sources are unprepared.
+    mediaSource.removeMediaSource(0);
+  }
+
   @Test
   public void testSetShuffleOrderBeforePreparation() throws Exception {
     mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0));
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
index e15c8f0aaa..430ceb87f1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
@@ -45,10 +45,32 @@ public void testDefaultShuffleOrder() {
         testCloneAndInsert(new DefaultShuffleOrder(initialLength, RANDOM_SEED), insertionPoint, 5);
       }
     }
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 0);
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 2);
-    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 4);
-    testCloneAndRemove(new DefaultShuffleOrder(1, RANDOM_SEED), 0);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 0, 1);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 2, 3);
+    testCloneAndRemove(new DefaultShuffleOrder(5, RANDOM_SEED), 4, 5);
+    testCloneAndRemove(new DefaultShuffleOrder(1, RANDOM_SEED), 0, 1);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 1000);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 999);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 0, 500);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 100, 600);
+    testCloneAndRemove(new DefaultShuffleOrder(1000, RANDOM_SEED), 500, 1000);
+  }
+
+  @Test
+  public void testDefaultShuffleOrderSideloaded() {
+    int[] shuffledIndices = new int[] {2, 1, 0, 4, 3};
+    ShuffleOrder shuffleOrder = new DefaultShuffleOrder(shuffledIndices, RANDOM_SEED);
+    assertThat(shuffleOrder.getFirstIndex()).isEqualTo(2);
+    assertThat(shuffleOrder.getLastIndex()).isEqualTo(3);
+    for (int i = 0; i < 4; i++) {
+      assertThat(shuffleOrder.getNextIndex(shuffledIndices[i])).isEqualTo(shuffledIndices[i + 1]);
+    }
+    assertThat(shuffleOrder.getNextIndex(3)).isEqualTo(C.INDEX_UNSET);
+    for (int i = 4; i > 0; i--) {
+      assertThat(shuffleOrder.getPreviousIndex(shuffledIndices[i]))
+          .isEqualTo(shuffledIndices[i - 1]);
+    }
+    assertThat(shuffleOrder.getPreviousIndex(2)).isEqualTo(C.INDEX_UNSET);
   }
 
   @Test
@@ -63,10 +85,15 @@ public void testUnshuffledShuffleOrder() {
         testCloneAndInsert(new UnshuffledShuffleOrder(initialLength), insertionPoint, 5);
       }
     }
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 0);
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 2);
-    testCloneAndRemove(new UnshuffledShuffleOrder(5), 4);
-    testCloneAndRemove(new UnshuffledShuffleOrder(1), 0);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 0, 1);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 2, 3);
+    testCloneAndRemove(new UnshuffledShuffleOrder(5), 4, 5);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1), 0, 1);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 1000);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 999);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 0, 500);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 100, 600);
+    testCloneAndRemove(new UnshuffledShuffleOrder(1000), 500, 1000);
   }
 
   @Test
@@ -120,22 +147,24 @@ private static void testCloneAndInsert(ShuffleOrder shuffleOrder, int position,
     }
   }
 
-  private static void testCloneAndRemove(ShuffleOrder shuffleOrder, int position) {
-    ShuffleOrder newOrder = shuffleOrder.cloneAndRemove(position);
-    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() - 1);
+  private static void testCloneAndRemove(
+      ShuffleOrder shuffleOrder, int indexFrom, int indexToExclusive) {
+    int numberOfElementsToRemove = indexToExclusive - indexFrom;
+    ShuffleOrder newOrder = shuffleOrder.cloneAndRemove(indexFrom, indexToExclusive);
+    assertShuffleOrderCorrectness(newOrder, shuffleOrder.getLength() - numberOfElementsToRemove);
     // Assert all elements still have the relative same order
     for (int i = 0; i < shuffleOrder.getLength(); i++) {
-      if (i == position) {
+      if (i >= indexFrom && i < indexToExclusive) {
         continue;
       }
       int expectedNextIndex = shuffleOrder.getNextIndex(i);
-      if (expectedNextIndex == position) {
+      while (expectedNextIndex >= indexFrom && expectedNextIndex < indexToExclusive) {
         expectedNextIndex = shuffleOrder.getNextIndex(expectedNextIndex);
       }
-      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= position) {
-        expectedNextIndex--;
+      if (expectedNextIndex != C.INDEX_UNSET && expectedNextIndex >= indexFrom) {
+        expectedNextIndex -= numberOfElementsToRemove;
       }
-      int newNextIndex = newOrder.getNextIndex(i < position ? i : i - 1);
+      int newNextIndex = newOrder.getNextIndex(i < indexFrom ? i : i - numberOfElementsToRemove);
       assertThat(newNextIndex).isEqualTo(expectedNextIndex);
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
index e9abaca075..1430c70e09 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.text.Cue;
 import java.io.IOException;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,6 +37,7 @@
   private static final String TYPICAL_MISSING_SEQUENCE = "subrip/typical_missing_sequence";
   private static final String TYPICAL_NEGATIVE_TIMESTAMPS = "subrip/typical_negative_timestamps";
   private static final String TYPICAL_UNEXPECTED_END = "subrip/typical_unexpected_end";
+  private static final String TYPICAL_WITH_TAGS = "subrip/typical_with_tags";
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
   @Test
@@ -154,6 +156,33 @@ public void testDecodeNoEndTimecodes() throws IOException {
         .isEqualTo("Or to the end of the media.");
   }
 
+  @Test
+  public void testDecodeCueWithTag() throws IOException {
+    SubripDecoder decoder = new SubripDecoder();
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_WITH_TAGS);
+    SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
+
+    assertTypicalCue1(subtitle, 0);
+    assertTypicalCue2(subtitle, 2);
+    assertTypicalCue3(subtitle, 4);
+
+    assertThat(subtitle.getCues(subtitle.getEventTime(6)).get(0).text.toString())
+        .isEqualTo("This { \\an2} is not a valid tag due to the space after the opening bracket.");
+
+    assertThat(subtitle.getCues(subtitle.getEventTime(8)).get(0).text.toString())
+        .isEqualTo("This is the fifth subtitle with multiple valid tags.");
+
+    assertAlignmentCue(subtitle, 10, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_START); // {/an1}
+    assertAlignmentCue(subtitle, 12, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_MIDDLE); // {/an2}
+    assertAlignmentCue(subtitle, 14, Cue.ANCHOR_TYPE_END, Cue.ANCHOR_TYPE_END); // {/an3}
+    assertAlignmentCue(subtitle, 16, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_START); // {/an4}
+    assertAlignmentCue(subtitle, 18, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_MIDDLE); // {/an5}
+    assertAlignmentCue(subtitle, 20, Cue.ANCHOR_TYPE_MIDDLE, Cue.ANCHOR_TYPE_END); // {/an6}
+    assertAlignmentCue(subtitle, 22, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_START); // {/an7}
+    assertAlignmentCue(subtitle, 24, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_MIDDLE); // {/an8}
+    assertAlignmentCue(subtitle, 26, Cue.ANCHOR_TYPE_START, Cue.ANCHOR_TYPE_END); // {/an9}
+  }
+
   private static void assertTypicalCue1(SubripSubtitle subtitle, int eventIndex) {
     assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(0);
     assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
@@ -174,4 +203,19 @@ private static void assertTypicalCue3(SubripSubtitle subtitle, int eventIndex) {
         .isEqualTo("This is the third subtitle.");
     assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(8901000);
   }
+
+  private static void assertAlignmentCue(
+      SubripSubtitle subtitle,
+      int eventIndex,
+      @Cue.AnchorType int lineAnchor,
+      @Cue.AnchorType int positionAnchor) {
+    long eventTimeUs = subtitle.getEventTime(eventIndex);
+    Cue cue = subtitle.getCues(eventTimeUs).get(0);
+    assertThat(cue.lineType).isEqualTo(Cue.LINE_TYPE_FRACTION);
+    assertThat(cue.lineAnchor).isEqualTo(lineAnchor);
+    assertThat(cue.line).isEqualTo(SubripDecoder.getFractionalPositionForAnchorType(lineAnchor));
+    assertThat(cue.positionAnchor).isEqualTo(positionAnchor);
+    assertThat(cue.position)
+        .isEqualTo(SubripDecoder.getFractionalPositionForAnchorType(positionAnchor));
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
new file mode 100644
index 0000000000..ebdb45909b
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeterTest.java
@@ -0,0 +1,531 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import static android.Manifest.permission.ACCESS_NETWORK_STATE;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.telephony.TelephonyManager;
+import com.google.android.exoplayer2.C;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.Shadows;
+import org.robolectric.shadows.ShadowNetworkInfo;
+
+/** Unit test for {@link DefaultBandwidthMeter}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultBandwidthMeterTest {
+
+  private static final String FAST_COUNTRY_ISO = "EE";
+  private static final String SLOW_COUNTRY_ISO = "PG";
+
+  private TelephonyManager telephonyManager;
+  private ConnectivityManager connectivityManager;
+  private NetworkInfo networkInfoOffline;
+  private NetworkInfo networkInfoWifi;
+  private NetworkInfo networkInfo2g;
+  private NetworkInfo networkInfo3g;
+  private NetworkInfo networkInfo4g;
+  private NetworkInfo networkInfoEthernet;
+
+  @Before
+  public void setUp() {
+    connectivityManager =
+        (ConnectivityManager)
+            RuntimeEnvironment.application.getSystemService(Context.CONNECTIVITY_SERVICE);
+    telephonyManager =
+        (TelephonyManager)
+            RuntimeEnvironment.application.getSystemService(Context.TELEPHONY_SERVICE);
+    Shadows.shadowOf(telephonyManager).setNetworkCountryIso(FAST_COUNTRY_ISO);
+    networkInfoOffline =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.DISCONNECTED,
+            ConnectivityManager.TYPE_WIFI,
+            /* subType= */ 0,
+            /* isAvailable= */ false,
+            /* isConnected= */ false);
+    networkInfoWifi =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_WIFI,
+            /* subType= */ 0,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo2g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_GPRS,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo3g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_HSDPA,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfo4g =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_MOBILE,
+            TelephonyManager.NETWORK_TYPE_LTE,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+    networkInfoEthernet =
+        ShadowNetworkInfo.newInstance(
+            DetailedState.CONNECTED,
+            ConnectivityManager.TYPE_ETHERNET,
+            /* subType= */ 0,
+            /* isAvailable= */ true,
+            /* isConnected= */ true);
+  }
+  
+  @Test
+  public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeterWifi =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimateWifi).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forWifi_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeterWifi =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateWifi = bandwidthMeterWifi.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimateWifi).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeterEthernet =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forEthernet_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeterEthernet =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateEthernet = bandwidthMeterEthernet.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimateEthernet).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter4g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimate4g).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for4G_isGreaterThanEstimateFor3G() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter4g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate4g = bandwidthMeter4g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    assertThat(initialEstimate4g).isGreaterThan(initialEstimate3g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_for3G_isGreaterThanEstimateFor2G() {
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter3g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate3g = bandwidthMeter3g.getBitrateEstimate();
+
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter2g =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate2g = bandwidthMeter2g.getBitrateEstimate();
+
+    assertThat(initialEstimate3g).isGreaterThan(initialEstimate2g);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_forOffline_isReasonable() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isGreaterThan(100_000L);
+    assertThat(initialEstimate).isLessThan(50_000_000L);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_forWifi_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfoWifi);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_forEthernet_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for2G_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo2g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for3G_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo3g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void
+      defaultInitialBitrateEstimate_for4g_forFastCountry_isGreaterThanEstimateForSlowCountry() {
+    setActiveNetworkInfo(networkInfo4g);
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFast =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();
+
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_whileConnectedToNetwork_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_whileOffline_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forWifi_whileConnectedToWifi_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forWifi_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forEthernet_whileConnectedToEthernet_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoEthernet);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_ETHERNET, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forEthernet_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_WIFI, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo2g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for2G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for3G_whileConnectedTo3G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo3g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for3G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_3G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_for4G_whileConnectedTo4G_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfo4g);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_for4G_whileConnectedToOtherNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_4G, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forOffline_whileOffline_setsInitialEstimate() {
+    setActiveNetworkInfo(networkInfoOffline);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isEqualTo(123456789);
+  }
+
+  @Test
+  public void
+      initialBitrateEstimateOverwrite_forOffline_whileConnectedToNetwork_doesNotSetInitialEstimate() {
+    setActiveNetworkInfo(networkInfoWifi);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(C.NETWORK_TYPE_OFFLINE, 123456789)
+            .build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isNotEqualTo(123456789);
+  }
+
+  @Test
+  public void initialBitrateEstimateOverwrite_forCountry_usesDefaultValuesForCountry() {
+    setNetworkCountryIso(SLOW_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterSlow =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();
+
+    setNetworkCountryIso(FAST_COUNTRY_ISO);
+    DefaultBandwidthMeter bandwidthMeterFastWithSlowOverwrite =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application)
+            .setInitialBitrateEstimate(SLOW_COUNTRY_ISO)
+            .build();
+    long initialEstimateFastWithSlowOverwrite =
+        bandwidthMeterFastWithSlowOverwrite.getBitrateEstimate();
+
+    assertThat(initialEstimateFastWithSlowOverwrite).isEqualTo(initialEstimateSlow);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_withoutContext_isReasonable() {
+    DefaultBandwidthMeter bandwidthMeterWithBuilder =
+        new DefaultBandwidthMeter.Builder(/* context= */ null).build();
+    long initialEstimateWithBuilder = bandwidthMeterWithBuilder.getBitrateEstimate();
+
+    DefaultBandwidthMeter bandwidthMeterWithoutBuilder = new DefaultBandwidthMeter();
+    long initialEstimateWithoutBuilder = bandwidthMeterWithoutBuilder.getBitrateEstimate();
+
+    assertThat(initialEstimateWithBuilder).isGreaterThan(100_000L);
+    assertThat(initialEstimateWithBuilder).isLessThan(50_000_000L);
+    assertThat(initialEstimateWithoutBuilder).isGreaterThan(100_000L);
+    assertThat(initialEstimateWithoutBuilder).isLessThan(50_000_000L);
+  }
+
+  @Test
+  public void defaultInitialBitrateEstimate_withoutAccessNetworkStatePermission_isReasonable() {
+    Shadows.shadowOf(RuntimeEnvironment.application).denyPermissions(ACCESS_NETWORK_STATE);
+    DefaultBandwidthMeter bandwidthMeter =
+        new DefaultBandwidthMeter.Builder(RuntimeEnvironment.application).build();
+    long initialEstimate = bandwidthMeter.getBitrateEstimate();
+
+    assertThat(initialEstimate).isGreaterThan(100_000L);
+    assertThat(initialEstimate).isLessThan(50_000_000L);
+  }
+
+  private void setActiveNetworkInfo(NetworkInfo networkInfo) {
+    Shadows.shadowOf(connectivityManager).setActiveNetworkInfo(networkInfo);
+  }
+
+  private void setNetworkCountryIso(String countryIso) {
+    Shadows.shadowOf(telephonyManager).setNetworkCountryIso(countryIso);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
index e1700e3b20..5576588857 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DefaultLoadErrorHandlingPolicyTest.java
@@ -35,7 +35,8 @@
   @Test
   public void getBlacklistDurationMsFor_blacklist404() {
     InvalidResponseCodeException exception =
-        new InvalidResponseCodeException(404, Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+        new InvalidResponseCodeException(
+            404, "Not Found", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
     assertThat(getDefaultPolicyBlacklistOutputFor(exception))
         .isEqualTo(DefaultLoadErrorHandlingPolicy.DEFAULT_TRACK_BLACKLIST_MS);
   }
@@ -43,7 +44,8 @@ public void getBlacklistDurationMsFor_blacklist404() {
   @Test
   public void getBlacklistDurationMsFor_blacklist410() {
     InvalidResponseCodeException exception =
-        new InvalidResponseCodeException(410, Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+        new InvalidResponseCodeException(
+            410, "Gone", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
     assertThat(getDefaultPolicyBlacklistOutputFor(exception))
         .isEqualTo(DefaultLoadErrorHandlingPolicy.DEFAULT_TRACK_BLACKLIST_MS);
   }
@@ -51,7 +53,8 @@ public void getBlacklistDurationMsFor_blacklist410() {
   @Test
   public void getBlacklistDurationMsFor_dontBlacklistUnexpectedHttpCodes() {
     InvalidResponseCodeException exception =
-        new InvalidResponseCodeException(500, Collections.emptyMap(), new DataSpec(Uri.EMPTY));
+        new InvalidResponseCodeException(
+            500, "Internal Server Error", Collections.emptyMap(), new DataSpec(Uri.EMPTY));
     assertThat(getDefaultPolicyBlacklistOutputFor(exception)).isEqualTo(C.TIME_UNSET);
   }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index a501435262..5c9a933508 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -47,6 +47,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -660,6 +661,7 @@ private static boolean hasCea608Track(List<AdaptationSet> adaptationSets,
 
   private static final class TrackGroupInfo {
 
+    @Documented
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({CATEGORY_PRIMARY, CATEGORY_EMBEDDED, CATEGORY_MANIFEST_EVENTS})
     public @interface TrackGroupCategory {}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 0c05be873a..8ee859b8bd 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -376,7 +376,6 @@ public DashMediaSource createMediaSource(
 
   private int staleManifestReloadAttempt;
   private long expiredManifestPublishTimeUs;
-  private boolean dynamicMediaPresentationEnded;
 
   private int firstPeriodId;
 
@@ -679,7 +678,6 @@ public void releaseSourceInternal() {
     elapsedRealtimeOffsetMs = 0;
     staleManifestReloadAttempt = 0;
     expiredManifestPublishTimeUs = C.TIME_UNSET;
-    dynamicMediaPresentationEnded = false;
     firstPeriodId = 0;
     periodsById.clear();
   }
@@ -691,10 +689,6 @@ public void releaseSourceInternal() {
     startLoadingManifest();
   }
 
-  /* package */ void onDashLiveMediaPresentationEndSignalEncountered() {
-    this.dynamicMediaPresentationEnded = true;
-  }
-
   /* package */ void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
     if (this.expiredManifestPublishTimeUs == C.TIME_UNSET
         || this.expiredManifestPublishTimeUs < expiredManifestPublishTimeUs) {
@@ -734,9 +728,8 @@ public void releaseSourceInternal() {
         // behind.
         Log.w(TAG, "Loaded out of sync manifest");
         isManifestStale = true;
-      } else if (dynamicMediaPresentationEnded
-          || (expiredManifestPublishTimeUs != C.TIME_UNSET
-              && newManifest.publishTimeMs * 1000 <= expiredManifestPublishTimeUs)) {
+      } else if (expiredManifestPublishTimeUs != C.TIME_UNSET
+          && newManifest.publishTimeMs * 1000 <= expiredManifestPublishTimeUs) {
         // If we receive a dynamic manifest that's older than expected (i.e. its publish time has
         // expired, or it's dynamic and we know the presentation has ended), then this manifest is
         // stale.
@@ -745,8 +738,6 @@ public void releaseSourceInternal() {
             "Loaded stale dynamic manifest: "
                 + newManifest.publishTimeMs
                 + ", "
-                + dynamicMediaPresentationEnded
-                + ", "
                 + expiredManifestPublishTimeUs);
         isManifestStale = true;
       }
@@ -763,7 +754,6 @@ public void releaseSourceInternal() {
       staleManifestReloadAttempt = 0;
     }
 
-
     manifest = newManifest;
     manifestLoadPending &= manifest.dynamic;
     manifestLoadStartTimestampMs = elapsedRealtimeMs - loadDurationMs;
@@ -1170,12 +1160,16 @@ public Window getWindow(
       long windowDefaultStartPositionUs = getAdjustedWindowDefaultStartPositionUs(
           defaultPositionProjectionUs);
       Object tag = setTag ? windowTag : null;
+      boolean isDynamic =
+          manifest.dynamic
+              && manifest.minUpdatePeriodMs != C.TIME_UNSET
+              && manifest.durationMs == C.TIME_UNSET;
       return window.set(
           tag,
           presentationStartTimeMs,
           windowStartTimeMs,
           /* isSeekable= */ true,
-          manifest.dynamic,
+          isDynamic,
           windowDefaultStartPositionUs,
           windowDurationUs,
           /* firstPeriodIndex= */ 0,
@@ -1253,11 +1247,6 @@ public void onDashManifestRefreshRequested() {
     public void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
       DashMediaSource.this.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
     }
-
-    @Override
-    public void onDashLiveMediaPresentationEndSignalEncountered() {
-      DashMediaSource.this.onDashLiveMediaPresentationEndSignalEncountered();
-    }
   }
 
   private final class ManifestCallback implements Loader.Callback<ParsingLoadable<DashManifest>> {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 37c9e313ae..5e20fb769c 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -318,9 +318,12 @@ public void getNextChunk(
       }
     }
 
+    long periodDurationUs = representationHolder.periodDurationUs;
+    boolean periodEnded = periodDurationUs != C.TIME_UNSET;
+
     if (representationHolder.getSegmentCount() == 0) {
       // The index doesn't define any segments.
-      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
+      out.endOfStream = periodEnded;
       return;
     }
 
@@ -343,17 +346,15 @@ public void getNextChunk(
       fatalError = new BehindLiveWindowException();
       return;
     }
+
     if (segmentNum > lastAvailableSegmentNum
         || (missingLastSegment && segmentNum >= lastAvailableSegmentNum)) {
-      // The segment is beyond the end of the period. We know the period will not be extended if the
-      // manifest is static, or if there's a period after this one.
-      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
+      // The segment is beyond the end of the period.
+      out.endOfStream = periodEnded;
       return;
     }
 
-    long periodDurationUs = representationHolder.periodDurationUs;
-    if (periodDurationUs != C.TIME_UNSET
-        && representationHolder.getSegmentStartTimeUs(segmentNum) >= periodDurationUs) {
+    if (periodEnded && representationHolder.getSegmentStartTimeUs(segmentNum) >= periodDurationUs) {
       // The period duration clips the period to a position before the segment.
       out.endOfStream = true;
       return;
@@ -544,7 +545,7 @@ protected Chunk newMediaChunk(
       long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum + segmentCount - 1);
       long periodDurationUs = representationHolder.periodDurationUs;
       long clippedEndTimeUs =
-          periodDurationUs != C.TIME_UNSET && periodDurationUs < endTimeUs
+          periodDurationUs != C.TIME_UNSET && periodDurationUs <= endTimeUs
               ? periodDurationUs
               : C.TIME_UNSET;
       DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
index e657d126bf..be299308a9 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -60,8 +60,7 @@
  */
 public final class PlayerEmsgHandler implements Handler.Callback {
 
-  private static final int EMSG_MEDIA_PRESENTATION_ENDED = 1;
-  private static final int EMSG_MANIFEST_EXPIRED = 2;
+  private static final int EMSG_MANIFEST_EXPIRED = 1;
 
   /** Callbacks for player emsg events encountered during DASH live stream. */
   public interface PlayerEmsgCallback {
@@ -75,9 +74,6 @@
      * @param expiredManifestPublishTimeUs The manifest publish time that has been expired.
      */
     void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs);
-
-    /** Called when a media presentation end signal is encountered during live stream. * */
-    void onDashLiveMediaPresentationEndSignalEncountered();
   }
 
   private final Allocator allocator;
@@ -88,7 +84,6 @@
 
   private DashManifest manifest;
 
-  private boolean dynamicMediaPresentationEnded;
   private long expiredManifestPublishTimeUs;
   private long lastLoadedChunkEndTimeUs;
   private long lastLoadedChunkEndTimeBeforeRefreshUs;
@@ -134,21 +129,15 @@ public void updateManifest(DashManifest newManifest) {
       return true;
     }
     boolean manifestRefreshNeeded = false;
-    if (dynamicMediaPresentationEnded) {
-      // The manifest we have is dynamic, but we know a non-dynamic one representing the final state
-      // should be available.
-      manifestRefreshNeeded = true;
-    } else {
-      // Find the smallest publishTime (greater than or equal to the current manifest's publish
-      // time) that has a corresponding expiry time.
-      Map.Entry<Long, Long> expiredEntry = ceilingExpiryEntryForPublishTime(manifest.publishTimeMs);
-      if (expiredEntry != null) {
-        long expiredPointUs = expiredEntry.getValue();
-        if (expiredPointUs < presentationPositionUs) {
-          expiredManifestPublishTimeUs = expiredEntry.getKey();
-          notifyManifestPublishTimeExpired();
-          manifestRefreshNeeded = true;
-        }
+    // Find the smallest publishTime (greater than or equal to the current manifest's publish time)
+    // that has a corresponding expiry time.
+    Map.Entry<Long, Long> expiredEntry = ceilingExpiryEntryForPublishTime(manifest.publishTimeMs);
+    if (expiredEntry != null) {
+      long expiredPointUs = expiredEntry.getValue();
+      if (expiredPointUs < presentationPositionUs) {
+        expiredManifestPublishTimeUs = expiredEntry.getKey();
+        notifyManifestPublishTimeExpired();
+        manifestRefreshNeeded = true;
       }
     }
     if (manifestRefreshNeeded) {
@@ -221,9 +210,6 @@ public boolean handleMessage(Message message) {
       return true;
     }
     switch (message.what) {
-      case (EMSG_MEDIA_PRESENTATION_ENDED):
-        handleMediaPresentationEndedMessageEncountered();
-        return true;
       case (EMSG_MANIFEST_EXPIRED):
         ManifestExpiryEventInfo messageObj = (ManifestExpiryEventInfo) message.obj;
         handleManifestExpiredMessage(
@@ -248,11 +234,6 @@ private void handleManifestExpiredMessage(long eventTimeUs, long manifestPublish
     }
   }
 
-  private void handleMediaPresentationEndedMessageEncountered() {
-    dynamicMediaPresentationEnded = true;
-    notifySourceMediaPresentationEnded();
-  }
-
   private @Nullable Map.Entry<Long, Long> ceilingExpiryEntryForPublishTime(long publishTimeMs) {
     return manifestPublishTimeToExpiryTimeUs.ceilingEntry(publishTimeMs);
   }
@@ -273,10 +254,6 @@ private void notifyManifestPublishTimeExpired() {
     playerEmsgCallback.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
   }
 
-  private void notifySourceMediaPresentationEnded() {
-    playerEmsgCallback.onDashLiveMediaPresentationEndSignalEncountered();
-  }
-
   /** Requests DASH media manifest to be refreshed if necessary. */
   private void maybeNotifyDashManifestRefreshNeeded() {
     if (lastLoadedChunkEndTimeBeforeRefreshUs != C.TIME_UNSET
@@ -298,12 +275,6 @@ private static long getManifestPublishTimeMsInEmsg(EventMessage eventMessage) {
     }
   }
 
-  private static boolean isMessageSignalingMediaPresentationEnded(EventMessage eventMessage) {
-    // According to section 4.5.2.1 DASH-IF IOP, if both presentation time delta and event duration
-    // are zero, the media presentation is ended.
-    return eventMessage.presentationTimeUs == 0 && eventMessage.durationMs == 0;
-  }
-
   /** Handles emsg messages for a specific track for the player. */
   public final class PlayerTrackEmsgHandler implements TrackOutput {
 
@@ -413,16 +384,7 @@ private void parsePlayerEmsgEvent(long eventTimeUs, EventMessage eventMessage) {
       if (manifestPublishTimeMsInEmsg == C.TIME_UNSET) {
         return;
       }
-
-      if (isMessageSignalingMediaPresentationEnded(eventMessage)) {
-        onMediaPresentationEndedMessageEncountered();
-      } else {
-        onManifestExpiredMessageEncountered(eventTimeUs, manifestPublishTimeMsInEmsg);
-      }
-    }
-
-    private void onMediaPresentationEndedMessageEncountered() {
-      handler.sendMessage(handler.obtainMessage(EMSG_MEDIA_PRESENTATION_ENDED));
+      onManifestExpiredMessageEncountered(eventTimeUs, manifestPublishTimeMsInEmsg);
     }
 
     private void onManifestExpiredMessageEncountered(
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
index 1fdb137be9..3637b80ecb 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.dash.manifest;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.FilterableManifest;
 import com.google.android.exoplayer2.offline.StreamKey;
@@ -86,12 +87,56 @@
    */
   public final Uri location;
 
+  /** The {@link ProgramInformation}, or null if not present. */
+  @Nullable public final ProgramInformation programInformation;
+
   private final List<Period> periods;
 
-  public DashManifest(long availabilityStartTimeMs, long durationMs, long minBufferTimeMs,
-      boolean dynamic, long minUpdatePeriodMs, long timeShiftBufferDepthMs,
-      long suggestedPresentationDelayMs, long publishTimeMs, UtcTimingElement utcTiming,
-      Uri location, List<Period> periods) {
+  /**
+   * @deprecated Use {@link #DashManifest(long, long, long, boolean, long, long, long, long,
+   *     ProgramInformation, UtcTimingElement, Uri, List)}.
+   */
+  @Deprecated
+  public DashManifest(
+      long availabilityStartTimeMs,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdatePeriodMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
+    this(
+        availabilityStartTimeMs,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdatePeriodMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        /* programInformation= */ null,
+        utcTiming,
+        location,
+        periods);
+  }
+
+  public DashManifest(
+      long availabilityStartTimeMs,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdatePeriodMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      @Nullable ProgramInformation programInformation,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
     this.availabilityStartTimeMs = availabilityStartTimeMs;
     this.durationMs = durationMs;
     this.minBufferTimeMs = minBufferTimeMs;
@@ -100,6 +145,7 @@ public DashManifest(long availabilityStartTimeMs, long durationMs, long minBuffe
     this.timeShiftBufferDepthMs = timeShiftBufferDepthMs;
     this.suggestedPresentationDelayMs = suggestedPresentationDelayMs;
     this.publishTimeMs = publishTimeMs;
+    this.programInformation = programInformation;
     this.utcTiming = utcTiming;
     this.location = location;
     this.periods = periods == null ? Collections.emptyList() : periods;
@@ -148,9 +194,19 @@ public final DashManifest copy(List<StreamKey> streamKeys) {
       }
     }
     long newDuration = durationMs != C.TIME_UNSET ? durationMs - shiftMs : C.TIME_UNSET;
-    return new DashManifest(availabilityStartTimeMs, newDuration, minBufferTimeMs, dynamic,
-        minUpdatePeriodMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs, publishTimeMs,
-        utcTiming, location, copyPeriods);
+    return new DashManifest(
+        availabilityStartTimeMs,
+        newDuration,
+        minBufferTimeMs,
+        dynamic,
+        minUpdatePeriodMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        copyPeriods);
   }
 
   private static ArrayList<AdaptationSet> copyAdaptationSets(
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 153856af8c..f017ae64ad 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -120,6 +120,7 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
     long suggestedPresentationDelayMs = dynamic
         ? parseDuration(xpp, "suggestedPresentationDelay", C.TIME_UNSET) : C.TIME_UNSET;
     long publishTimeMs = parseDateTime(xpp, "publishTime", C.TIME_UNSET);
+    ProgramInformation programInformation = null;
     UtcTimingElement utcTiming = null;
     Uri location = null;
 
@@ -134,6 +135,8 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
           baseUrl = parseBaseUrl(xpp, baseUrl);
           seenFirstBaseUrl = true;
         }
+      } else if (XmlPullParserUtil.isStartTag(xpp, "ProgramInformation")) {
+        programInformation = parseProgramInformation(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "UTCTiming")) {
         utcTiming = parseUtcTiming(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "Location")) {
@@ -155,6 +158,8 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
               : (period.startMs + periodDurationMs);
           periods.add(period);
         }
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "MPD"));
 
@@ -171,18 +176,47 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
       throw new ParserException("No periods found.");
     }
 
-    return buildMediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
-        publishTimeMs, utcTiming, location, periods);
+    return buildMediaPresentationDescription(
+        availabilityStartTime,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdateTimeMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        periods);
   }
 
-  protected DashManifest buildMediaPresentationDescription(long availabilityStartTime,
-      long durationMs, long minBufferTimeMs, boolean dynamic, long minUpdateTimeMs,
-      long timeShiftBufferDepthMs, long suggestedPresentationDelayMs, long publishTimeMs,
-      UtcTimingElement utcTiming, Uri location, List<Period> periods) {
-    return new DashManifest(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
-        publishTimeMs, utcTiming, location, periods);
+  protected DashManifest buildMediaPresentationDescription(
+      long availabilityStartTime,
+      long durationMs,
+      long minBufferTimeMs,
+      boolean dynamic,
+      long minUpdateTimeMs,
+      long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs,
+      long publishTimeMs,
+      ProgramInformation programInformation,
+      UtcTimingElement utcTiming,
+      Uri location,
+      List<Period> periods) {
+    return new DashManifest(
+        availabilityStartTime,
+        durationMs,
+        minBufferTimeMs,
+        dynamic,
+        minUpdateTimeMs,
+        timeShiftBufferDepthMs,
+        suggestedPresentationDelayMs,
+        publishTimeMs,
+        programInformation,
+        utcTiming,
+        location,
+        periods);
   }
 
   protected UtcTimingElement parseUtcTiming(XmlPullParser xpp) {
@@ -221,6 +255,8 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
         segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, null);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Period"));
 
@@ -409,22 +445,26 @@ protected int getContentType(Format format) {
       } else if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
         String robustnessLevel = xpp.getAttributeValue(null, "robustness_level");
         requiresSecureDecoder = robustnessLevel != null && robustnessLevel.startsWith("HW");
-      } else if (data == null) {
-        if (XmlPullParserUtil.isStartTagIgnorePrefix(xpp, "pssh")
-            && xpp.next() == XmlPullParser.TEXT) {
-          // The cenc:pssh element is defined in 23001-7:2015.
-          data = Base64.decode(xpp.getText(), Base64.DEFAULT);
-          uuid = PsshAtomUtil.parseUuid(data);
-          if (uuid == null) {
-            Log.w(TAG, "Skipping malformed cenc:pssh data");
-            data = null;
-          }
-        } else if (C.PLAYREADY_UUID.equals(uuid) && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
-            && xpp.next() == XmlPullParser.TEXT) {
-          // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
-          data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
-              Base64.decode(xpp.getText(), Base64.DEFAULT));
+      } else if (data == null
+          && XmlPullParserUtil.isStartTagIgnorePrefix(xpp, "pssh")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The cenc:pssh element is defined in 23001-7:2015.
+        data = Base64.decode(xpp.getText(), Base64.DEFAULT);
+        uuid = PsshAtomUtil.parseUuid(data);
+        if (uuid == null) {
+          Log.w(TAG, "Skipping malformed cenc:pssh data");
+          data = null;
         }
+      } else if (data == null
+          && C.PLAYREADY_UUID.equals(uuid)
+          && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
+        data =
+            PsshAtomUtil.buildPsshAtom(
+                C.PLAYREADY_UUID, Base64.decode(xpp.getText(), Base64.DEFAULT));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "ContentProtection"));
     SchemeData schemeData =
@@ -462,7 +502,7 @@ protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOExce
    */
   protected void parseAdaptationSetChild(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
-    // pass
+    maybeSkipTag(xpp);
   }
 
   // Representation parsing.
@@ -526,6 +566,8 @@ protected RepresentationInfo parseRepresentation(
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
       } else if (XmlPullParserUtil.isStartTag(xpp, "SupplementalProperty")) {
         supplementalProperties.add(parseDescriptor(xpp, "SupplementalProperty"));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
@@ -664,6 +706,8 @@ protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, SingleSegmentBas
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Initialization")) {
         initialization = parseInitialization(xpp);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentBase"));
 
@@ -701,6 +745,8 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
           segments = new ArrayList<>();
         }
         segments.add(parseSegmentUrl(xpp));
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentList"));
 
@@ -747,6 +793,8 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
         initialization = parseInitialization(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentTemplate"));
 
@@ -794,6 +842,8 @@ protected EventStream parseEventStream(XmlPullParser xpp)
         EventMessage event = parseEvent(xpp, schemeIdUri, value, timescale,
             scratchOutputStream);
         eventMessages.add(event);
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "EventStream"));
 
@@ -932,6 +982,8 @@ protected EventMessage buildEvent(String schemeIdUri, String value, long id,
           segmentTimeline.add(buildSegmentTimelineElement(elapsedTime, duration));
           elapsedTime += duration;
         }
+      } else {
+        maybeSkipTag(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentTimeline"));
     return segmentTimeline;
@@ -978,6 +1030,28 @@ protected RangedUri buildRangedUri(String urlText, long rangeStart, long rangeLe
     return new RangedUri(urlText, rangeStart, rangeLength);
   }
 
+  protected ProgramInformation parseProgramInformation(XmlPullParser xpp)
+      throws IOException, XmlPullParserException {
+    String title = null;
+    String source = null;
+    String copyright = null;
+    String moreInformationURL = parseString(xpp, "moreInformationURL", null);
+    String lang = parseString(xpp, "lang", null);
+    do {
+      xpp.next();
+      if (XmlPullParserUtil.isStartTag(xpp, "Title")) {
+        title = xpp.nextText();
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Source")) {
+        source = xpp.nextText();
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Copyright")) {
+        copyright = xpp.nextText();
+      } else {
+        maybeSkipTag(xpp);
+      }
+    } while (!XmlPullParserUtil.isEndTag(xpp, "ProgramInformation"));
+    return new ProgramInformation(title, source, copyright, moreInformationURL, lang);
+  }
+
   // AudioChannelConfiguration parsing.
 
   protected int parseAudioChannelConfiguration(XmlPullParser xpp)
@@ -995,6 +1069,29 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)
 
   // Utility methods.
 
+  /**
+   * If the provided {@link XmlPullParser} is currently positioned at the start of a tag, skips
+   * forward to the end of that tag.
+   *
+   * @param xpp The {@link XmlPullParser}.
+   * @throws XmlPullParserException If an error occurs parsing the stream.
+   * @throws IOException If an error occurs reading the stream.
+   */
+  public static void maybeSkipTag(XmlPullParser xpp) throws IOException, XmlPullParserException {
+    if (!XmlPullParserUtil.isStartTag(xpp)) {
+      return;
+    }
+    int depth = 1;
+    while (depth != 0) {
+      xpp.next();
+      if (XmlPullParserUtil.isStartTag(xpp)) {
+        depth++;
+      } else if (XmlPullParserUtil.isEndTag(xpp)) {
+        depth--;
+      }
+    }
+  }
+
   /**
    * Removes unnecessary {@link SchemeData}s with null {@link SchemeData#data}.
    */
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
new file mode 100644
index 0000000000..e3072c86bd
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/ProgramInformation.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+
+/** A parsed program information element. */
+public class ProgramInformation {
+  /** The title for the media presentation. */
+  public final String title;
+
+  /** Information about the original source of the media presentation. */
+  public final String source;
+
+  /** A copyright statement for the media presentation. */
+  public final String copyright;
+
+  /** A URL that provides more information about the media presentation. */
+  public final String moreInformationURL;
+
+  /** Declares the language code(s) for this ProgramInformation. */
+  public final String lang;
+
+  public ProgramInformation(
+      String title, String source, String copyright, String moreInformationURL, String lang) {
+    this.title = title;
+    this.source = source;
+    this.copyright = copyright;
+    this.moreInformationURL = moreInformationURL;
+    this.lang = lang;
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ProgramInformation other = (ProgramInformation) obj;
+    return Util.areEqual(this.title, other.title)
+        && Util.areEqual(this.source, other.source)
+        && Util.areEqual(this.copyright, other.copyright)
+        && Util.areEqual(this.moreInformationURL, other.moreInformationURL)
+        && Util.areEqual(this.lang, other.lang);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (title != null ? title.hashCode() : 0);
+    result = 31 * result + (source != null ? source.hashCode() : 0);
+    result = 31 * result + (copyright != null ? copyright.hashCode() : 0);
+    result = 31 * result + (moreInformationURL != null ? moreInformationURL.hashCode() : 0);
+    result = 31 * result + (lang != null ? lang.hashCode() : 0);
+    return result;
+  }
+}
diff --git a/library/dash/src/main/proguard-rules.txt b/library/dash/src/main/proguard-rules.txt
deleted file mode 100644
index f8725fff4d..0000000000
--- a/library/dash/src/main/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the dash module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.dash.offline.DashDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.dash.offline.DashDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/dash/src/test/assets/sample_mpd_1 b/library/dash/src/test/assets/sample_mpd_1
index 07bcdd4f50..ccd3ab4dd6 100644
--- a/library/dash/src/test/assets/sample_mpd_1
+++ b/library/dash/src/test/assets/sample_mpd_1
@@ -9,6 +9,12 @@
     xmlns="urn:mpeg:DASH:schema:MPD:2011"
     xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"
     yt:earliestMediaSequence="1266404" >
+    <ProgramInformation lang="enUs"
+        moreInformationURL="www.example.com">
+        <Title>MediaTitle</Title>
+        <Source>MediaSource</Source>
+        <Copyright>MediaCopyright</Copyright>
+    </ProgramInformation>
     <Period start="PT6462826.784S" >
         <SegmentList
             presentationTimeOffset="34740095"
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 23dc7f96ca..a1693f6985 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -152,6 +152,19 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
                 1000000000));
   }
 
+  @Test
+  public void testParseMediaPresentationDescriptionCanParseProgramInformation() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest mpd =
+        parser.parse(
+            Uri.parse("Https://example.com/test.mpd"),
+            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_1));
+    ProgramInformation expectedProgramInformation =
+        new ProgramInformation(
+            "MediaTitle", "MediaSource", "MediaCopyright", "www.example.com", "enUs");
+    assertThat(mpd.programInformation).isEqualTo(expectedProgramInformation);
+  }
+
   @Test
   public void testParseCea608AccessibilityChannel() {
     assertThat(
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
index 94f7a28a73..0d08df42e9 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
@@ -219,7 +219,18 @@ private static Representation newRepresentation() {
 
   private static DashManifest newDashManifest(int duration, Period... periods) {
     return new DashManifest(
-        0, duration, 1, false, 2, 3, 4, 12345, DUMMY_UTC_TIMING, Uri.EMPTY, Arrays.asList(periods));
+        /* availabilityStartTimeMs= */ 0,
+        duration,
+        /* minBufferTimeMs= */ 1,
+        /* dynamic= */ false,
+        /* minUpdatePeriodMs= */ 2,
+        /* timeShiftBufferDepthMs= */ 3,
+        /* suggestedPresentationDelayMs= */ 4,
+        /* publishTimeMs= */ 12345,
+        /* programInformation= */ null,
+        DUMMY_UTC_TIMING,
+        Uri.EMPTY,
+        Arrays.asList(periods));
   }
 
   private static Period newPeriod(String id, int startMs, AdaptationSet... adaptationSets) {
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index 951e6c95e0..8a403c3759 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -48,9 +48,28 @@
   public static final String MP4_FILE_EXTENSION = ".mp4";
   public static final String M4_FILE_EXTENSION_PREFIX = ".m4";
   public static final String MP4_FILE_EXTENSION_PREFIX = ".mp4";
+  public static final String CMF_FILE_EXTENSION_PREFIX = ".cmf";
   public static final String VTT_FILE_EXTENSION = ".vtt";
   public static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
+  @DefaultTsPayloadReaderFactory.Flags private final int payloadReaderFactoryFlags;
+
+  /** Creates a factory for HLS segment extractors. */
+  public DefaultHlsExtractorFactory() {
+    this(/* payloadReaderFactoryFlags= */ 0);
+  }
+
+  /**
+   * Creates a factory for HLS segment extractors.
+   *
+   * @param payloadReaderFactoryFlags Flags to add when constructing any {@link
+   *     DefaultTsPayloadReaderFactory} instances. Other flags may be added on top of {@code
+   *     payloadReaderFactoryFlags} when creating {@link DefaultTsPayloadReaderFactory}.
+   */
+  public DefaultHlsExtractorFactory(int payloadReaderFactoryFlags) {
+    this.payloadReaderFactoryFlags = payloadReaderFactoryFlags;
+  }
+
   @Override
   public Pair<Extractor, Boolean> createExtractor(
       Extractor previousExtractor,
@@ -138,7 +157,9 @@
     }
 
     if (!(extractorByFileExtension instanceof TsExtractor)) {
-      TsExtractor tsExtractor = createTsExtractor(format, muxedCaptionFormats, timestampAdjuster);
+      TsExtractor tsExtractor =
+          createTsExtractor(
+              payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
       if (sniffQuietly(tsExtractor, extractorInput)) {
         return buildResult(tsExtractor);
       }
@@ -171,7 +192,8 @@ private Extractor createExtractorByFileExtension(
       return new Mp3Extractor(/* flags= */ 0, /* forcedFirstSampleTimestampUs= */ 0);
     } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
         || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)
-        || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
+        || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)
+        || lastPathSegment.startsWith(CMF_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
       return new FragmentedMp4Extractor(
           /* flags= */ 0,
           timestampAdjuster,
@@ -180,17 +202,23 @@ private Extractor createExtractorByFileExtension(
           muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
     } else {
       // For any other file extension, we assume TS format.
-      return createTsExtractor(format, muxedCaptionFormats, timestampAdjuster);
+      return createTsExtractor(
+          payloadReaderFactoryFlags, format, muxedCaptionFormats, timestampAdjuster);
     }
   }
 
   private static TsExtractor createTsExtractor(
-      Format format, List<Format> muxedCaptionFormats, TimestampAdjuster timestampAdjuster) {
+      @DefaultTsPayloadReaderFactory.Flags int userProvidedPayloadReaderFactoryFlags,
+      Format format,
+      List<Format> muxedCaptionFormats,
+      TimestampAdjuster timestampAdjuster) {
     @DefaultTsPayloadReaderFactory.Flags
-    int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
+    int payloadReaderFactoryFlags =
+        DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM
+            | userProvidedPayloadReaderFactoryFlags;
     if (muxedCaptionFormats != null) {
       // The playlist declares closed caption renditions, we should ignore descriptors.
-      esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
+      payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
     } else {
       // The playlist does not provide any closed caption information. We preemptively declare a
       // closed caption track on channel 0.
@@ -208,17 +236,17 @@ private static TsExtractor createTsExtractor(
       // exist. If we know from the codec attribute that they don't exist, then we can
       // explicitly ignore them even if they're declared.
       if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
+        payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
       }
       if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
+        payloadReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
       }
     }
 
     return new TsExtractor(
         TsExtractor.MODE_HLS,
         timestampAdjuster,
-        new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
+        new DefaultTsPayloadReaderFactory(payloadReaderFactoryFlags, muxedCaptionFormats));
   }
 
   private static Pair<Extractor, Boolean> buildResult(Extractor extractor) {
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index a8cf1a1437..c1396de3d6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -262,7 +262,8 @@ public void getNextChunk(
       // Retry when playlist is refreshed.
       return;
     }
-    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
+    HlsMediaPlaylist mediaPlaylist =
+        playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
     independentSegments = mediaPlaylist.hasIndependentSegments;
 
     updateLiveEdgeTimeUs(mediaPlaylist);
@@ -279,7 +280,7 @@ public void getNextChunk(
         // behind the live window.
         selectedVariantIndex = oldVariantIndex;
         selectedUrl = variants[selectedVariantIndex];
-        mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
+        mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl, /* isForPlayback= */ true);
         startOfPlaylistInPeriodUs =
             mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
         chunkMediaSequence = previous.getNextChunkIndex();
@@ -435,7 +436,8 @@ public boolean onPlaylistError(HlsUrl url, long blacklistDurationMs) {
         chunkIterators[i] = MediaChunkIterator.EMPTY;
         continue;
       }
-      HlsMediaPlaylist playlist = playlistTracker.getPlaylistSnapshot(variantUrl);
+      HlsMediaPlaylist playlist =
+          playlistTracker.getPlaylistSnapshot(variantUrl, /* isForPlayback= */ false);
       long startOfPlaylistInPeriodUs =
           playlist.startTimeUs - playlistTracker.getInitialStartTimeUs();
       boolean switchingVariant = variantIndex != oldVariantIndex;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 0cfe31f3b9..2995f8b0aa 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -41,8 +42,7 @@
  */
 /* package */ final class HlsMediaChunk extends MediaChunk {
 
-
-  private static final String PRIV_TIMESTAMP_FRAME_OWNER =
+  public static final String PRIV_TIMESTAMP_FRAME_OWNER =
       "com.apple.streaming.transportStreamTimestamp";
 
   private static final AtomicInteger uidSource = new AtomicInteger();
@@ -313,8 +313,10 @@ private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec
    */
   private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
     input.resetPeekPosition();
-    if (input.getLength() < Id3Decoder.ID3_HEADER_LENGTH
-        || !input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH, true)) {
+    try {
+      input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+    } catch (EOFException e) {
+      // The input isn't long enough for there to be any ID3 data.
       return C.TIME_UNSET;
     }
     id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
@@ -330,9 +332,7 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
       id3Data.reset(requiredCapacity);
       System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
     }
-    if (!input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size, true)) {
-      return C.TIME_UNSET;
-    }
+    input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size);
     Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
     if (metadata == null) {
       return C.TIME_UNSET;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index e60dacb8f4..39598c4cd8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -24,6 +25,8 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.SampleQueue.UpstreamFormatChangedListener;
@@ -791,7 +794,7 @@ public TrackOutput track(int id, int type) {
         return createDummyTrackOutput(id, type);
       }
     }
-    SampleQueue trackOutput = new SampleQueue(allocator);
+    SampleQueue trackOutput = new PrivTimestampStrippingSampleQueue(allocator);
     trackOutput.setSampleOffsetUs(sampleOffsetUs);
     trackOutput.sourceId(chunkUid);
     trackOutput.setUpstreamFormatChangeListener(this);
@@ -1126,4 +1129,53 @@ private static DummyTrackOutput createDummyTrackOutput(int id, int type) {
     Log.w(TAG, "Unmapped track with id " + id + " of type " + type);
     return new DummyTrackOutput();
   }
+
+  private static final class PrivTimestampStrippingSampleQueue extends SampleQueue {
+
+    public PrivTimestampStrippingSampleQueue(Allocator allocator) {
+      super(allocator);
+    }
+
+    @Override
+    public void format(Format format) {
+      super.format(format.copyWithMetadata(getAdjustedMetadata(format.metadata)));
+    }
+
+    /**
+     * Strips the private timestamp frame from metadata, if present. See:
+     * https://github.com/google/ExoPlayer/issues/5063
+     */
+    @Nullable
+    private Metadata getAdjustedMetadata(@Nullable Metadata metadata) {
+      if (metadata == null) {
+        return null;
+      }
+      int length = metadata.length();
+      int transportStreamTimestampMetadataIndex = C.INDEX_UNSET;
+      for (int i = 0; i < length; i++) {
+        Metadata.Entry metadataEntry = metadata.get(i);
+        if (metadataEntry instanceof PrivFrame) {
+          PrivFrame privFrame = (PrivFrame) metadataEntry;
+          if (HlsMediaChunk.PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
+            transportStreamTimestampMetadataIndex = i;
+            break;
+          }
+        }
+      }
+      if (transportStreamTimestampMetadataIndex == C.INDEX_UNSET) {
+        return metadata;
+      }
+      if (length == 1) {
+        return null;
+      }
+      Metadata.Entry[] newMetadataEntries = new Metadata.Entry[length - 1];
+      for (int i = 0; i < length; i++) {
+        if (i != transportStreamTimestampMetadataIndex) {
+          int newIndex = i < transportStreamTimestampMetadataIndex ? i : i - 1;
+          newMetadataEntries[newIndex] = metadata.get(i);
+        }
+      }
+      return new Metadata(newMetadataEntries);
+    }
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
index 4e34c556e0..4269b66d30 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/DefaultHlsPlaylistTracker.java
@@ -162,9 +162,9 @@ public void removeListener(PlaylistEventListener listener) {
   }
 
   @Override
-  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
+  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback) {
     HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
-    if (snapshot != null) {
+    if (snapshot != null && isForPlayback) {
       maybeSetPrimaryUrl(url);
     }
     return snapshot;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index a29808933b..81d4e7a818 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.offline.StreamKey;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -157,6 +158,7 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * Type of the playlist, as defined by #EXT-X-PLAYLIST-TYPE. One of {@link
    * #PLAYLIST_TYPE_UNKNOWN}, {@link #PLAYLIST_TYPE_VOD} or {@link #PLAYLIST_TYPE_EVENT}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
   public @interface PlaylistType {}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 49826902cd..65f4796187 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -341,6 +341,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       String name = parseStringAttr(line, REGEX_NAME, variableDefinitions);
       String language = parseOptionalStringAttr(line, REGEX_LANGUAGE, variableDefinitions);
       String groupId = parseOptionalStringAttr(line, REGEX_GROUP_ID, variableDefinitions);
+      String id = groupId + ":" + name;
       Format format;
       switch (parseStringAttr(line, REGEX_TYPE, variableDefinitions)) {
         case TYPE_AUDIO:
@@ -348,7 +349,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           String sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
           format =
               Format.createAudioContainerFormat(
-                  /* id= */ name,
+                  /* id= */ id,
                   /* label= */ name,
                   /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                   sampleMimeType,
@@ -368,7 +369,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         case TYPE_SUBTITLES:
           format =
               Format.createTextContainerFormat(
-                  /* id= */ name,
+                  /* id= */ id,
                   /* label= */ name,
                   /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                   /* sampleMimeType= */ MimeTypes.TEXT_VTT,
@@ -394,7 +395,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           }
           muxedCaptionFormats.add(
               Format.createTextContainerFormat(
-                  /* id= */ name,
+                  /* id= */ id,
                   /* label= */ name,
                   /* containerMimeType= */ null,
                   /* sampleMimeType= */ mimeType,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index b83ae43f47..c73c9fa835 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -167,11 +167,13 @@ void start(
    * HlsUrl}.
    *
    * @param url The {@link HlsUrl} corresponding to the requested media playlist.
+   * @param isForPlayback Whether the caller might use the snapshot to request media segments for
+   *     playback. If true, the primary playlist may be updated to the one requested.
    * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
    *     be null if no snapshot has been loaded yet.
    */
   @Nullable
-  HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url);
+  HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url, boolean isForPlayback);
 
   /**
    * Returns the start time of the first loaded primary playlist, or {@link C#TIME_UNSET} if no
diff --git a/library/hls/src/main/proguard-rules.txt b/library/hls/src/main/proguard-rules.txt
deleted file mode 100644
index 3b8d1bb4ac..0000000000
--- a/library/hls/src/main/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the hls module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index d818111eec..d03049efb3 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -75,7 +75,7 @@
 
   private static final String PLAYLIST_WITH_CC =
       " #EXTM3U \n"
-          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,GROUP-ID=\"cc1\","
           + "LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
           + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
           + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
@@ -90,6 +90,14 @@
           + "CLOSED-CAPTIONS=NONE\n"
           + "http://example.com/low.m3u8\n";
 
+  private static final String PLAYLIST_WITH_SUBTITLES =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"sub1\","
+          + "LANGUAGE=\"es\",NAME=\"Eng\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
   private static final String PLAYLIST_WITH_AUDIO_MEDIA_TAG =
       "#EXTM3U\n"
           + "#EXT-X-STREAM-INF:BANDWIDTH=2227464,CODECS=\"avc1.640020,mp4a.40.2\",AUDIO=\"aud1\"\n"
@@ -216,6 +224,33 @@ public void testCodecPropagation() throws IOException {
     assertThat(secondAudioFormat.sampleMimeType).isEqualTo(MimeTypes.AUDIO_AC3);
   }
 
+  @Test
+  public void testAudioIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_AUDIO_MEDIA_TAG);
+
+    Format firstAudioFormat = playlist.audios.get(0).format;
+    assertThat(firstAudioFormat.id).isEqualTo("aud1:English");
+
+    Format secondAudioFormat = playlist.audios.get(1).format;
+    assertThat(secondAudioFormat.id).isEqualTo("aud2:English");
+  }
+
+  @Test
+  public void testCCIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_CC);
+
+    Format firstTextFormat = playlist.muxedCaptionFormats.get(0);
+    assertThat(firstTextFormat.id).isEqualTo("cc1:Eng");
+  }
+
+  @Test
+  public void testSubtitleIdPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_SUBTITLES);
+
+    Format firstTextFormat = playlist.subtitles.get(0).format;
+    assertThat(firstTextFormat.id).isEqualTo("sub1:Eng");
+  }
+
   @Test
   public void testIndependentSegments() throws IOException {
     HlsMasterPlaylist playlistWithIndependentSegments =
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index cc09b5ff11..3d5ade403a 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -378,8 +378,12 @@ public Object build() {
         DrmInitData drmInitData = new DrmInitData(new SchemeData(protectionElement.uuid,
             MimeTypes.VIDEO_MP4, protectionElement.data));
         for (StreamElement streamElement : streamElementArray) {
-          for (int i = 0; i < streamElement.formats.length; i++) {
-            streamElement.formats[i] = streamElement.formats[i].copyWithDrmInitData(drmInitData);
+          int type = streamElement.type;
+          if (type == C.TRACK_TYPE_VIDEO || type == C.TRACK_TYPE_AUDIO) {
+            Format[] formats = streamElement.formats;
+            for (int i = 0; i < formats.length; i++) {
+              formats[i] = formats[i].copyWithDrmInitData(drmInitData);
+            }
           }
         }
       }
diff --git a/library/smoothstreaming/src/main/proguard-rules.txt b/library/smoothstreaming/src/main/proguard-rules.txt
deleted file mode 100644
index d14244d783..0000000000
--- a/library/smoothstreaming/src/main/proguard-rules.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-# Proguard rules specific to the smoothstreaming module.
-
-# Constructors accessed via reflection in SegmentDownloadAction
--dontnote com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction
--keepclassmembers class com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction {
-  static ** DESERIALIZER;
-}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index 9d977d63b3..0d4c6a4038 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -20,6 +20,7 @@
 import android.support.annotation.IntDef;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -50,6 +51,7 @@ void onAspectRatioUpdated(
    * #RESIZE_MODE_FIXED_WIDTH}, {@link #RESIZE_MODE_FIXED_HEIGHT}, {@link #RESIZE_MODE_FILL} or
    * {@link #RESIZE_MODE_ZOOM}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     RESIZE_MODE_FIT,
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index 5f4864d783..8ab4210465 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -529,6 +529,7 @@ public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatTog
         controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ALL);
       }
     }
+    updateRepeatModeButton();
   }
 
   /** Returns whether the shuffle button is shown. */
@@ -633,9 +634,8 @@ private void updateNavigation() {
       int windowIndex = player.getCurrentWindowIndex();
       timeline.getWindow(windowIndex, window);
       isSeekable = window.isSeekable;
-      enablePrevious =
-          isSeekable || !window.isDynamic || player.getPreviousWindowIndex() != C.INDEX_UNSET;
-      enableNext = window.isDynamic || player.getNextWindowIndex() != C.INDEX_UNSET;
+      enablePrevious = isSeekable || !window.isDynamic || player.hasPrevious();
+      enableNext = window.isDynamic || player.hasNext();
     }
     setButtonEnabled(enablePrevious, previousButton);
     setButtonEnabled(enableNext, nextButton);
@@ -830,7 +830,7 @@ private void setButtonEnabled(boolean enabled, View view) {
 
   private void previous() {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = player.getCurrentWindowIndex();
@@ -847,14 +847,14 @@ private void previous() {
 
   private void next() {
     Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
+    if (timeline.isEmpty() || player.isPlayingAd()) {
       return;
     }
     int windowIndex = player.getCurrentWindowIndex();
     int nextWindowIndex = player.getNextWindowIndex();
     if (nextWindowIndex != C.INDEX_UNSET) {
       seekTo(nextWindowIndex, C.TIME_UNSET);
-    } else if (timeline.getWindow(windowIndex, window, false).isDynamic) {
+    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
       seekTo(windowIndex, C.TIME_UNSET);
     }
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 778f81375e..47025d9bba 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -42,6 +42,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.NotificationUtil;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -250,6 +251,7 @@ public void onBitmap(final Bitmap bitmap) {
    * NotificationCompat#VISIBILITY_PRIVATE}, {@link NotificationCompat#VISIBILITY_PUBLIC} or {@link
    * NotificationCompat#VISIBILITY_SECRET}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NotificationCompat.VISIBILITY_PRIVATE,
@@ -264,6 +266,7 @@ public void onBitmap(final Bitmap bitmap) {
    * NotificationCompat#PRIORITY_HIGH}, {@link NotificationCompat#PRIORITY_LOW }or {@link
    * NotificationCompat#PRIORITY_MIN}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({
     NotificationCompat.PRIORITY_DEFAULT,
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 8127fd617a..310d04a064 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -67,6 +67,7 @@
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoListener;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.List;
@@ -240,15 +241,12 @@
  */
 public class PlayerView extends FrameLayout {
 
-  private static final int SURFACE_TYPE_NONE = 0;
-  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
-  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
-  private static final int SURFACE_TYPE_MONO360_VIEW = 3;
-
+  // LINT.IfChange
   /**
    * Determines when the buffering view is shown. One of {@link #SHOW_BUFFERING_NEVER}, {@link
    * #SHOW_BUFFERING_WHEN_PLAYING} or {@link #SHOW_BUFFERING_ALWAYS}.
    */
+  @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({SHOW_BUFFERING_NEVER, SHOW_BUFFERING_WHEN_PLAYING, SHOW_BUFFERING_ALWAYS})
   public @interface ShowBuffering {}
@@ -264,6 +262,14 @@
    * buffering} state.
    */
   public static final int SHOW_BUFFERING_ALWAYS = 2;
+  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
+
+  // LINT.IfChange
+  private static final int SURFACE_TYPE_NONE = 0;
+  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
+  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
+  private static final int SURFACE_TYPE_MONO360_VIEW = 3;
+  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
 
   private final AspectRatioFrameLayout contentFrame;
   private final View shutterView;
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index d8c61f5e05..4f22362de6 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -310,7 +310,7 @@ private void setupTextLayout() {
       textLeft = Math.max(textLeft, parentLeft);
       textRight = Math.min(textLeft + textWidth, parentRight);
     } else {
-      textLeft = (parentWidth - textWidth) / 2;
+      textLeft = (parentWidth - textWidth) / 2 + parentLeft;
       textRight = textLeft + textWidth;
     }
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 7426671041..50a923bced 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -247,19 +247,17 @@ public void setBottomPaddingFraction(float bottomPaddingFraction) {
   @Override
   public void dispatchDraw(Canvas canvas) {
     int cueCount = (cues == null) ? 0 : cues.size();
-    int rawTop = getTop();
-    int rawBottom = getBottom();
+    int rawViewHeight = getHeight();
 
-    // Calculate the bounds after padding is taken into account.
-    int left = getLeft() + getPaddingLeft();
-    int top = rawTop + getPaddingTop();
-    int right = getRight() - getPaddingRight();
-    int bottom = rawBottom - getPaddingBottom();
+    // Calculate the cue box bounds relative to the canvas after padding is taken into account.
+    int left = getPaddingLeft();
+    int top = getPaddingTop();
+    int right = getWidth() - getPaddingRight();
+    int bottom = rawViewHeight - getPaddingBottom();
     if (bottom <= top || right <= left) {
       // No space to draw subtitles.
       return;
     }
-    int rawViewHeight = rawBottom - rawTop;
     int viewHeightMinusPadding = bottom - top;
 
     float defaultViewTextSizePx =
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
index c6ddb8148b..7b58f54ac2 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SphericalSurfaceView.java
@@ -104,12 +104,18 @@ public SphericalSurfaceView(Context context, @Nullable AttributeSet attributeSet
     // Configure sensors and touch.
     sensorManager =
         (SensorManager) Assertions.checkNotNull(context.getSystemService(Context.SENSOR_SERVICE));
-    // TYPE_GAME_ROTATION_VECTOR is the easiest sensor since it handles all the complex math for
-    // fusion. It's used instead of TYPE_ROTATION_VECTOR since the latter uses the magnetometer on
-    // devices. When used indoors, the magnetometer can take some time to settle depending on the
-    // device and amount of metal in the environment.
-    int type = Util.SDK_INT >= 18 ? Sensor.TYPE_GAME_ROTATION_VECTOR : Sensor.TYPE_ROTATION_VECTOR;
-    orientationSensor = sensorManager.getDefaultSensor(type);
+    Sensor orientationSensor = null;
+    if (Util.SDK_INT >= 18) {
+      // TYPE_GAME_ROTATION_VECTOR is the easiest sensor since it handles all the complex math for
+      // fusion. It's used instead of TYPE_ROTATION_VECTOR since the latter uses the magnetometer on
+      // devices. When used indoors, the magnetometer can take some time to settle depending on the
+      // device and amount of metal in the environment.
+      orientationSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR);
+    }
+    if (orientationSensor == null) {
+      orientationSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
+    }
+    this.orientationSensor = orientationSensor;
 
     scene = new SceneRenderer();
     renderer = new Renderer(scene);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
index 335f611b58..c0373c9ca1 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/TouchTracker.java
@@ -44,11 +44,10 @@
  * a nicer UI. An even more advanced UI would reproject the user's touch point into 3D and drag the
  * Mesh as the user moves their finger. However, that requires quaternion interpolation.
  */
-// @VisibleForTesting
-/*package*/ class TouchTracker extends GestureDetector.SimpleOnGestureListener
+/* package */ class TouchTracker extends GestureDetector.SimpleOnGestureListener
     implements View.OnTouchListener {
 
-  /*package*/ interface Listener {
+  /* package */ interface Listener {
     void onScrollChange(PointF scrollOffsetDegrees);
   }
 
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index 89f873edf7..c13622f182 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -53,8 +53,8 @@
     <attr name="auto_show" format="boolean"/>
     <attr name="show_buffering" format="enum">
       <enum name="never" value="0"/>
-      <enum name="always" value="1"/>
-      <enum name="when_playing" value="2"/>
+      <enum name="when_playing" value="1"/>
+      <enum name="always" value="2"/>
     </attr>
     <attr name="keep_content_on_player_reset" format="boolean"/>
     <attr name="resize_mode"/>
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index d458df55bb..4165a42568 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -18,6 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.playbacktests">
 
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index 14d62e85c8..c988c0c172 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -686,6 +686,56 @@ protected void doActionImpl(
     }
   }
 
+  /**
+   * Waits for a specified loading state, returning either immediately or after a call to {@link
+   * Player.EventListener#onLoadingChanged(boolean)}.
+   */
+  public static final class WaitForIsLoading extends Action {
+
+    private final boolean targetIsLoading;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param targetIsLoading The loading state to wait for.
+     */
+    public WaitForIsLoading(String tag, boolean targetIsLoading) {
+      super(tag, "WaitForIsLoading");
+      this.targetIsLoading = targetIsLoading;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final DefaultTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
+        final ActionNode nextAction) {
+      if (nextAction == null) {
+        return;
+      }
+      if (targetIsLoading == player.isLoading()) {
+        nextAction.schedule(player, trackSelector, surface, handler);
+      } else {
+        player.addListener(
+            new Player.EventListener() {
+              @Override
+              public void onLoadingChanged(boolean isLoading) {
+                if (targetIsLoading == isLoading) {
+                  player.removeListener(this);
+                  nextAction.schedule(player, trackSelector, surface, handler);
+                }
+              }
+            });
+      }
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
+      // Not triggered.
+    }
+  }
+
   /**
    * Waits for {@link Player.EventListener#onSeekProcessed()}.
    */
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 6e37d7d070..71f5fdeae1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -41,6 +41,7 @@
 import com.google.android.exoplayer2.testutil.Action.SetVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.Stop;
 import com.google.android.exoplayer2.testutil.Action.ThrowPlaybackException;
+import com.google.android.exoplayer2.testutil.Action.WaitForIsLoading;
 import com.google.android.exoplayer2.testutil.Action.WaitForPlaybackState;
 import com.google.android.exoplayer2.testutil.Action.WaitForPositionDiscontinuity;
 import com.google.android.exoplayer2.testutil.Action.WaitForSeekProcessed;
@@ -375,6 +376,15 @@ public Builder sendMessage(
       return apply(new SendMessages(tag, target, windowIndex, positionMs, deleteAfterDelivery));
     }
 
+    /**
+     * Schedules a delay until any timeline change.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder waitForTimelineChanged() {
+      return apply(new WaitForTimelineChanged(tag, /* expectedTimeline= */ null));
+    }
+
     /**
      * Schedules a delay until the timeline changed to a specified expected timeline.
      *
@@ -382,7 +392,7 @@ public Builder sendMessage(
      *     change.
      * @return The builder, for convenience.
      */
-    public Builder waitForTimelineChanged(@Nullable Timeline expectedTimeline) {
+    public Builder waitForTimelineChanged(Timeline expectedTimeline) {
       return apply(new WaitForTimelineChanged(tag, expectedTimeline));
     }
 
@@ -405,6 +415,16 @@ public Builder waitForPlaybackState(int targetPlaybackState) {
       return apply(new WaitForPlaybackState(tag, targetPlaybackState));
     }
 
+    /**
+     * Schedules a delay until {@code player.isLoading()} changes to the specified value.
+     *
+     * @param targetIsLoading The target value of {@code player.isLoading()}.
+     * @return The builder, for convenience.
+     */
+    public Builder waitForIsLoading(boolean targetIsLoading) {
+      return apply(new WaitForIsLoading(tag, targetIsLoading));
+    }
+
     /**
      * Schedules a {@link Runnable} to be executed.
      *
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
index cb70c75bdb..4b3a0d5051 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
@@ -61,8 +61,8 @@ public ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount) {
   }
 
   @Override
-  public ShuffleOrder cloneAndRemove(int removalIndex) {
-    return new FakeShuffleOrder(length - 1);
+  public ShuffleOrder cloneAndRemove(int indexFrom, int indexToExclusive) {
+    return new FakeShuffleOrder(length - indexToExclusive + indexFrom);
   }
 
   @Override
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
index f1349c1158..156b573df8 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Looper;
-import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.PlaybackParameters;
@@ -32,7 +32,7 @@
  * An abstract {@link ExoPlayer} implementation that throws {@link UnsupportedOperationException}
  * from every method.
  */
-public abstract class StubExoPlayer implements ExoPlayer {
+public abstract class StubExoPlayer extends BasePlayer implements ExoPlayer {
 
   @Override
   public AudioComponent getAudioComponent() {
@@ -129,21 +129,6 @@ public boolean isLoading() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public void seekToDefaultPosition() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void seekToDefaultPosition(int windowIndex) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void seekTo(long positionMs) {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void seekTo(int windowIndex, long positionMs) {
     throw new UnsupportedOperationException();
@@ -169,16 +154,6 @@ public SeekParameters getSeekParameters() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public @Nullable Object getCurrentTag() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void stop() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void stop(boolean resetStateAndPosition) {
     throw new UnsupportedOperationException();
@@ -248,16 +223,6 @@ public int getCurrentWindowIndex() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public int getNextWindowIndex() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public int getPreviousWindowIndex() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public long getDuration() {
     throw new UnsupportedOperationException();
@@ -273,26 +238,11 @@ public long getBufferedPosition() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public int getBufferedPercentage() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public long getTotalBufferedDuration() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public boolean isCurrentWindowDynamic() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isCurrentWindowSeekable() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public boolean isPlayingAd() {
     throw new UnsupportedOperationException();
@@ -308,11 +258,6 @@ public int getCurrentAdIndexInAdGroup() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public long getContentDuration() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public long getContentPosition() {
     throw new UnsupportedOperationException();
