diff --git a/README.md b/README.md
index d9c55904ae..c6935075ac 100644
--- a/README.md
+++ b/README.md
@@ -5,26 +5,29 @@
 ExoPlayer is an application level media player for Android. It provides an
 alternative to Android’s MediaPlayer API for playing audio and video both
 locally and over the Internet. ExoPlayer supports features not currently
-supported by Android’s MediaPlayer API (as of KitKat), including DASH and
-SmoothStreaming adaptive playbacks, persistent caching and custom renderers.
-Unlike the MediaPlayer API, ExoPlayer is easy to customize and extend, and
-can be updated through Play Store application updates.
+supported by Android’s MediaPlayer API, including DASH and SmoothStreaming
+adaptive playbacks. Unlike the MediaPlayer API, ExoPlayer is easy to
+customize and extend, and can be updated through Play Store application
+updates.
 
+## News ##
 
-## Developer guide ##
+Read news, hints and tips on the [news][] page.
 
-The [ExoPlayer developer guide][] provides a wealth of information to help you
-get started.
+[news]: https://google.github.io/ExoPlayer/news.html
 
-[ExoPlayer developer guide]: http://developer.android.com/guide/topics/media/exoplayer.html
+## Developer guide ##
 
+The [developer guide][] provides a wealth of information to help you get
+started.
 
-## Reference documentation ##
+[developer guide]: https://google.github.io/ExoPlayer/guide.html
 
-[Class reference][] (Documents the ExoPlayer library classes).
+## Reference documentation ##
 
-[Class reference]: http://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/package-summary.html
+The [class reference][] documents the ExoPlayer library classes.
 
+[class reference]: https://google.github.io/ExoPlayer/doc/reference
 
 ## Project branches ##
 
@@ -35,7 +38,6 @@ get started.
 [master]: https://github.com/google/ExoPlayer/tree/master
 [dev]: https://github.com/google/ExoPlayer/tree/dev
 
-
 ## Using Eclipse ##
 
 The repository includes Eclipse projects for both the ExoPlayer library and its
diff --git a/build.gradle b/build.gradle
index 2864587d3f..fab548dc65 100644
--- a/build.gradle
+++ b/build.gradle
@@ -20,7 +20,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:1.2.3'
         classpath 'com.novoda:bintray-release:0.2.7'
     }
 }
diff --git a/demo/build.gradle b/demo/build.gradle
index b7c53a67c8..5a95cfff41 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.2"
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
 
     defaultConfig {
         minSdkVersion 16
-        targetSdkVersion 21
+        targetSdkVersion 22
     }
     buildTypes {
         release {
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 39588b6fc9..f774c2aacc 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1204"
-    android:versionName="1.2.4"
+    android:versionCode="1301"
+    android:versionName="1.3.1"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -25,7 +25,7 @@
   <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
-  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="21"/>
+  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22"/>
 
   <application
       android:label="@string/application_name"
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java b/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
index dae5773100..558b294f09 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
@@ -15,13 +15,6 @@
  */
 package com.google.android.exoplayer.demo;
 
-import com.google.android.exoplayer.ExoPlayerLibraryInfo;
-
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.os.Build;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
@@ -32,22 +25,23 @@
 import java.net.CookieManager;
 import java.net.CookiePolicy;
 import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Map;
-import java.util.UUID;
 
 /**
  * Utility methods for the demo application.
  */
 public class DemoUtil {
 
-  public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
-
   public static final int TYPE_DASH = 0;
   public static final int TYPE_SS = 1;
-  public static final int TYPE_OTHER = 2;
-  public static final int TYPE_HLS = 3;
+  public static final int TYPE_HLS = 2;
+  public static final int TYPE_MP4 = 3;
+  public static final int TYPE_MP3 = 4;
+  public static final int TYPE_M4A = 5;
+  public static final int TYPE_WEBM = 6;
+  public static final int TYPE_TS = 7;
+  public static final int TYPE_AAC = 8;
 
   private static final CookieManager defaultCookieManager;
 
@@ -56,21 +50,8 @@
     defaultCookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
   }
 
-  public static String getUserAgent(Context context) {
-    String versionName;
-    try {
-      String packageName = context.getPackageName();
-      PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
-      versionName = info.versionName;
-    } catch (NameNotFoundException e) {
-      versionName = "?";
-    }
-    return "ExoPlayerDemo/" + versionName + " (Linux;Android " + Build.VERSION.RELEASE +
-        ") " + "ExoPlayerLib/" + ExoPlayerLibraryInfo.VERSION;
-  }
-
   public static byte[] executePost(String url, byte[] data, Map<String, String> requestProperties)
-      throws MalformedURLException, IOException {
+      throws IOException {
     HttpURLConnection urlConnection = null;
     try {
       urlConnection = (HttpURLConnection) new URL(url).openConnection();
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
index c9ece110b1..ffdf43a4d2 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
 import com.google.android.exoplayer.audio.AudioTrack;
+import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.demo.player.DemoPlayer;
 import com.google.android.exoplayer.util.VerboseLogUtil;
 
@@ -91,17 +92,18 @@ public void onDroppedFrames(int count, long elapsed) {
   }
 
   @Override
-  public void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitialization,
-      int mediaStartTimeMs, int mediaEndTimeMs, long length) {
+  public void onLoadStarted(int sourceId, long length, int type, int trigger, Format format,
+      int mediaStartTimeMs, int mediaEndTimeMs) {
     loadStartTimeMs[sourceId] = SystemClock.elapsedRealtime();
     if (VerboseLogUtil.isTagEnabled(TAG)) {
-      Log.v(TAG, "loadStart [" + getSessionTimeString() + ", " + sourceId
+      Log.v(TAG, "loadStart [" + getSessionTimeString() + ", " + sourceId + ", " + type
           + ", " + mediaStartTimeMs + ", " + mediaEndTimeMs + "]");
     }
   }
 
   @Override
-  public void onLoadCompleted(int sourceId, long bytesLoaded) {
+  public void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Format format,
+       int mediaStartTimeMs, int mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs) {
     if (VerboseLogUtil.isTagEnabled(TAG)) {
       long downloadTime = SystemClock.elapsedRealtime() - loadStartTimeMs[sourceId];
       Log.v(TAG, "loadEnd [" + getSessionTimeString() + ", " + sourceId + ", " + downloadTime
@@ -110,27 +112,22 @@ public void onLoadCompleted(int sourceId, long bytesLoaded) {
   }
 
   @Override
-  public void onVideoFormatEnabled(String formatId, int trigger, int mediaTimeMs) {
-    Log.d(TAG, "videoFormat [" + getSessionTimeString() + ", " + formatId + ", "
+  public void onVideoFormatEnabled(Format format, int trigger, int mediaTimeMs) {
+    Log.d(TAG, "videoFormat [" + getSessionTimeString() + ", " + format.id + ", "
         + Integer.toString(trigger) + "]");
   }
 
   @Override
-  public void onAudioFormatEnabled(String formatId, int trigger, int mediaTimeMs) {
-    Log.d(TAG, "audioFormat [" + getSessionTimeString() + ", " + formatId + ", "
+  public void onAudioFormatEnabled(Format format, int trigger, int mediaTimeMs) {
+    Log.d(TAG, "audioFormat [" + getSessionTimeString() + ", " + format.id + ", "
         + Integer.toString(trigger) + "]");
   }
 
   // DemoPlayer.InternalErrorListener
 
   @Override
-  public void onUpstreamError(int sourceId, IOException e) {
-    printInternalError("upstreamError", e);
-  }
-
-  @Override
-  public void onConsumptionError(int sourceId, IOException e) {
-    printInternalError("consumptionError", e);
+  public void onLoadError(int sourceId, IOException e) {
+    printInternalError("loadError", e);
   }
 
   @Override
@@ -163,6 +160,12 @@ public void onCryptoError(CryptoException e) {
     printInternalError("cryptoError", e);
   }
 
+  @Override
+  public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
+      long initializationDurationMs) {
+    Log.d(TAG, "decoderInitialized [" + getSessionTimeString() + "]");
+  }
+
   private void printInternalError(String type, Exception e) {
     Log.e(TAG, "internalError [" + getSessionTimeString() + ", " + type + "]", e);
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index 0cc37aa74d..e824ed0115 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -17,13 +17,22 @@
 
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.VideoSurfaceView;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+import com.google.android.exoplayer.audio.AudioCapabilitiesReceiver;
 import com.google.android.exoplayer.demo.player.DashRendererBuilder;
-import com.google.android.exoplayer.demo.player.DefaultRendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
+import com.google.android.exoplayer.demo.player.ExtractorRendererBuilder;
 import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
 import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
 import com.google.android.exoplayer.demo.player.UnsupportedDrmException;
+import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer.extractor.ts.AdtsExtractor;
+import com.google.android.exoplayer.extractor.ts.TsExtractor;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
+import com.google.android.exoplayer.metadata.GeobMetadata;
+import com.google.android.exoplayer.metadata.PrivMetadata;
 import com.google.android.exoplayer.metadata.TxxxMetadata;
 import com.google.android.exoplayer.text.CaptionStyleCompat;
 import com.google.android.exoplayer.text.SubtitleView;
@@ -40,12 +49,14 @@
 import android.text.TextUtils;
 import android.util.Log;
 import android.view.Display;
+import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.SurfaceHolder;
 import android.view.View;
 import android.view.View.OnClickListener;
+import android.view.View.OnKeyListener;
 import android.view.View.OnTouchListener;
 import android.view.WindowManager;
 import android.view.accessibility.CaptioningManager;
@@ -62,7 +73,8 @@
  * An activity that plays media using {@link DemoPlayer}.
  */
 public class PlayerActivity extends Activity implements SurfaceHolder.Callback, OnClickListener,
-    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener {
+    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener,
+    AudioCapabilitiesReceiver.Listener {
 
   public static final String CONTENT_TYPE_EXTRA = "content_type";
   public static final String CONTENT_ID_EXTRA = "content_id";
@@ -96,6 +108,9 @@
   private int contentType;
   private String contentId;
 
+  private AudioCapabilitiesReceiver audioCapabilitiesReceiver;
+  private AudioCapabilities audioCapabilities;
+
   // Activity lifecycle
 
   @Override
@@ -104,7 +119,7 @@ public void onCreate(Bundle savedInstanceState) {
 
     Intent intent = getIntent();
     contentUri = intent.getData();
-    contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
+    contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA, -1);
     contentId = intent.getStringExtra(CONTENT_ID_EXTRA);
 
     setContentView(R.layout.player_activity);
@@ -120,6 +135,16 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
         return true;
       }
     });
+    root.setOnKeyListener(new OnKeyListener() {
+      @Override
+      public boolean onKey(View v, int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
+          return mediaController.dispatchKeyEvent(event);
+        }
+        return false;
+      }
+    });
+    audioCapabilitiesReceiver = new AudioCapabilitiesReceiver(getApplicationContext(), this);
 
     shutterView = findViewById(R.id.shutter);
     debugRootView = findViewById(R.id.controls_root);
@@ -146,11 +171,9 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
   public void onResume() {
     super.onResume();
     configureSubtitleView();
-    if (player == null) {
-      preparePlayer();
-    } else if (player != null) {
-      player.setBackgrounded(false);
-    }
+
+    // The player will be prepared on receiving audio capabilities.
+    audioCapabilitiesReceiver.register();
   }
 
   @Override
@@ -161,6 +184,7 @@ public void onPause() {
     } else {
       player.setBackgrounded(true);
     }
+    audioCapabilitiesReceiver.unregister();
     shutterView.setVisibility(View.VISIBLE);
   }
 
@@ -179,21 +203,52 @@ public void onClick(View view) {
     }
   }
 
+  // AudioCapabilitiesReceiver.Listener methods
+
+  @Override
+  public void onAudioCapabilitiesChanged(AudioCapabilities audioCapabilities) {
+    boolean audioCapabilitiesChanged = !audioCapabilities.equals(this.audioCapabilities);
+    if (player == null || audioCapabilitiesChanged) {
+      this.audioCapabilities = audioCapabilities;
+      releasePlayer();
+      preparePlayer();
+    } else if (player != null) {
+      player.setBackgrounded(false);
+    }
+  }
+
   // Internal methods
 
   private RendererBuilder getRendererBuilder() {
-    String userAgent = DemoUtil.getUserAgent(this);
+    String userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
     switch (contentType) {
       case DemoUtil.TYPE_SS:
-        return new SmoothStreamingRendererBuilder(userAgent, contentUri.toString(), contentId,
+        return new SmoothStreamingRendererBuilder(this, userAgent, contentUri.toString(),
             new SmoothStreamingTestMediaDrmCallback(), debugTextView);
       case DemoUtil.TYPE_DASH:
-        return new DashRendererBuilder(userAgent, contentUri.toString(), contentId,
-            new WidevineTestMediaDrmCallback(contentId), debugTextView);
+        return new DashRendererBuilder(this, userAgent, contentUri.toString(),
+            new WidevineTestMediaDrmCallback(contentId), debugTextView, audioCapabilities);
       case DemoUtil.TYPE_HLS:
-        return new HlsRendererBuilder(userAgent, contentUri.toString(), contentId);
+        return new HlsRendererBuilder(this, userAgent, contentUri.toString(), debugTextView,
+            audioCapabilities);
+      case DemoUtil.TYPE_M4A: // There are no file format differences between M4A and MP4.
+      case DemoUtil.TYPE_MP4:
+        return new ExtractorRendererBuilder(userAgent, contentUri, debugTextView,
+            new Mp4Extractor());
+      case DemoUtil.TYPE_MP3:
+        return new ExtractorRendererBuilder(userAgent, contentUri, debugTextView,
+            new Mp3Extractor());
+      case DemoUtil.TYPE_TS:
+        return new ExtractorRendererBuilder(userAgent, contentUri, debugTextView,
+            new TsExtractor(0, audioCapabilities));
+      case DemoUtil.TYPE_AAC:
+        return new ExtractorRendererBuilder(userAgent, contentUri, debugTextView,
+            new AdtsExtractor());
+      case DemoUtil.TYPE_WEBM:
+        return new ExtractorRendererBuilder(userAgent, contentUri, debugTextView,
+            new WebmExtractor());
       default:
-        return new DefaultRendererBuilder(this, contentUri, debugTextView);
+        throw new IllegalStateException("Unsupported type: " + contentType);
     }
   }
 
@@ -425,11 +480,22 @@ public void onText(String text) {
 
   @Override
   public void onId3Metadata(Map<String, Object> metadata) {
-    for (int i = 0; i < metadata.size(); i++) {
-      if (metadata.containsKey(TxxxMetadata.TYPE)) {
-        TxxxMetadata txxxMetadata = (TxxxMetadata) metadata.get(TxxxMetadata.TYPE);
-        Log.i(TAG, String.format("ID3 TimedMetadata: description=%s, value=%s",
-            txxxMetadata.description, txxxMetadata.value));
+    for (Map.Entry<String, Object> entry : metadata.entrySet()) {
+      if (TxxxMetadata.TYPE.equals(entry.getKey())) {
+        TxxxMetadata txxxMetadata = (TxxxMetadata) entry.getValue();
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s, value=%s",
+            TxxxMetadata.TYPE, txxxMetadata.description, txxxMetadata.value));
+      } else if (PrivMetadata.TYPE.equals(entry.getKey())) {
+        PrivMetadata privMetadata = (PrivMetadata) entry.getValue();
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: owner=%s",
+            PrivMetadata.TYPE, privMetadata.owner));
+      } else if (GeobMetadata.TYPE.equals(entry.getKey())) {
+        GeobMetadata geobMetadata = (GeobMetadata) entry.getValue();
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, filename=%s, description=%s",
+            GeobMetadata.TYPE, geobMetadata.mimeType, geobMetadata.filename,
+            geobMetadata.description));
+      } else {
+        Log.i(TAG, String.format("ID3 TimedMetadata %s", entry.getKey()));
       }
     }
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index 8b9305bd80..f68bb58892 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -123,16 +123,31 @@ public Sample(String name, String contentId, String uri, int type) {
     new Sample("Apple AAC media playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/"
         + "prog_index.m3u8", DemoUtil.TYPE_HLS),
+    new Sample("Apple ID3 metadata", "http://devimages.apple.com/samplecode/adDemo/ad.m3u8",
+        DemoUtil.TYPE_HLS),
   };
 
   public static final Sample[] MISC = new Sample[] {
     new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4",
-        DemoUtil.TYPE_OTHER),
-    new Sample("Dizzy (https->http redirect)", "https://goo.gl/MtUDEj",
-        DemoUtil.TYPE_OTHER),
+        DemoUtil.TYPE_MP4),
     new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
         + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac",
-        DemoUtil.TYPE_OTHER),
+        DemoUtil.TYPE_AAC),
+    new Sample("Apple TS 10s", "https://devimages.apple.com.edgekey.net/streaming/examples/"
+        + "bipbop_4x3/gear1/fileSequence0.ts",
+        DemoUtil.TYPE_TS),
+    new Sample("Big Buck Bunny (MP4 Video)",
+        "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&"
+        + "sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature="
+        + "513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300"
+        + "&key=ik0",
+        DemoUtil.TYPE_MP4),
+    new Sample("Google Play (MP3 Audio)",
+        "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3",
+        DemoUtil.TYPE_MP3),
+    new Sample("Google Glass (WebM Video with Vorbis Audio)",
+        "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm",
+        DemoUtil.TYPE_WEBM),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index 378c74c202..1f29f6b7a1 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -22,8 +22,6 @@
 import android.media.MediaDrm.ProvisionRequest;
 import android.text.TextUtils;
 
-import org.apache.http.client.ClientProtocolException;
-
 import java.io.IOException;
 import java.util.UUID;
 
@@ -43,8 +41,7 @@ public WidevineTestMediaDrmCallback(String videoId) {
   }
 
   @Override
-  public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request)
-      throws ClientProtocolException, IOException {
+  public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
     return DemoUtil.executePost(url, null, null);
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
index e2476160d2..2b0de68c3d 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
@@ -15,27 +15,31 @@
  */
 package com.google.android.exoplayer.demo.player;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecUtil;
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.ChunkSource;
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
+import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.dash.DashChunkSource;
 import com.google.android.exoplayer.dash.mpd.AdaptationSet;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
 import com.google.android.exoplayer.dash.mpd.Period;
 import com.google.android.exoplayer.dash.mpd.Representation;
-import com.google.android.exoplayer.demo.DemoUtil;
+import com.google.android.exoplayer.dash.mpd.UtcTimingElement;
+import com.google.android.exoplayer.dash.mpd.UtcTimingElementResolver;
+import com.google.android.exoplayer.dash.mpd.UtcTimingElementResolver.UtcTimingCallback;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.DrmSessionManager;
@@ -44,19 +48,21 @@
 import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.text.ttml.TtmlParser;
 import com.google.android.exoplayer.text.webvtt.WebvttParser;
-import com.google.android.exoplayer.upstream.BufferPool;
 import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.upstream.UriDataSource;
 import com.google.android.exoplayer.util.ManifestFetcher;
 import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
-import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
+import android.content.Context;
 import android.media.MediaCodec;
 import android.media.UnsupportedSchemeException;
 import android.os.Handler;
+import android.util.Log;
 import android.util.Pair;
 import android.widget.TextView;
 
@@ -68,7 +74,9 @@
  * A {@link RendererBuilder} for DASH.
  */
 public class DashRendererBuilder implements RendererBuilder,
-    ManifestCallback<MediaPresentationDescription> {
+    ManifestCallback<MediaPresentationDescription>, UtcTimingCallback {
+
+  private static final String TAG = "DashRendererBuilder";
 
   private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
   private static final int VIDEO_BUFFER_SEGMENTS = 200;
@@ -80,26 +88,41 @@
   private static final int SECURITY_LEVEL_1 = 1;
   private static final int SECURITY_LEVEL_3 = 3;
 
-  private static final String AC_3_CODEC = "ac-3";
-  private static final String E_AC_3_CODEC = "ec-3";
+  /**
+   * Passthrough audio formats (encodings) in order of decreasing priority.
+   */
+  private static final int[] PASSTHROUGH_ENCODINGS_PRIORITY =
+      new int[] {C.ENCODING_E_AC3, C.ENCODING_AC3};
+  /**
+   * Passthrough audio codecs corresponding to the encodings in
+   * {@link #PASSTHROUGH_ENCODINGS_PRIORITY}.
+   */
+  private static final String[] PASSTHROUGH_CODECS_PRIORITY =
+      new String[] {"ec-3", "ac-3"};
 
+  private final Context context;
   private final String userAgent;
   private final String url;
-  private final String contentId;
   private final MediaDrmCallback drmCallback;
   private final TextView debugTextView;
+  private final AudioCapabilities audioCapabilities;
 
   private DemoPlayer player;
   private RendererBuilderCallback callback;
   private ManifestFetcher<MediaPresentationDescription> manifestFetcher;
+  private UriDataSource manifestDataSource;
+
+  private MediaPresentationDescription manifest;
+  private long elapsedRealtimeOffset;
 
-  public DashRendererBuilder(String userAgent, String url, String contentId,
-      MediaDrmCallback drmCallback, TextView debugTextView) {
+  public DashRendererBuilder(Context context, String userAgent, String url,
+      MediaDrmCallback drmCallback, TextView debugTextView, AudioCapabilities audioCapabilities) {
+    this.context = context;
     this.userAgent = userAgent;
     this.url = url;
-    this.contentId = contentId;
     this.drmCallback = drmCallback;
     this.debugTextView = debugTextView;
+    this.audioCapabilities = audioCapabilities;
   }
 
   @Override
@@ -107,21 +130,45 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
     this.player = player;
     this.callback = callback;
     MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
-    manifestFetcher = new ManifestFetcher<MediaPresentationDescription>(parser, contentId, url,
-        userAgent);
+    manifestDataSource = new DefaultUriDataSource(userAgent, null);
+    manifestFetcher = new ManifestFetcher<MediaPresentationDescription>(url, manifestDataSource,
+        parser);
     manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
 
   @Override
-  public void onManifestError(String contentId, IOException e) {
+  public void onSingleManifest(MediaPresentationDescription manifest) {
+    this.manifest = manifest;
+    if (manifest.dynamic && manifest.utcTiming != null) {
+      UtcTimingElementResolver.resolveTimingElement(manifestDataSource, manifest.utcTiming,
+          manifestFetcher.getManifestLoadTimestamp(), this);
+    } else {
+      buildRenderers();
+    }
+  }
+
+  @Override
+  public void onSingleManifestError(IOException e) {
     callback.onRenderersError(e);
   }
 
   @Override
-  public void onManifest(String contentId, MediaPresentationDescription manifest) {
+  public void onTimestampResolved(UtcTimingElement utcTiming, long elapsedRealtimeOffset) {
+    this.elapsedRealtimeOffset = elapsedRealtimeOffset;
+    buildRenderers();
+  }
+
+  @Override
+  public void onTimestampError(UtcTimingElement utcTiming, IOException e) {
+    Log.e(TAG, "Failed to resolve UtcTiming element [" + utcTiming + "]", e);
+    // Be optimistic and continue in the hope that the device clock is correct.
+    buildRenderers();
+  }
+
+  private void buildRenderers() {
     Period period = manifest.periods.get(0);
     Handler mainHandler = player.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
+    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
 
     boolean hasContentProtection = false;
@@ -167,76 +214,72 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
     }
 
     // Determine which video representations we should use for playback.
-    ArrayList<Integer> videoRepresentationIndexList = new ArrayList<Integer>();
+    int[] videoRepresentationIndices = null;
     if (videoAdaptationSet != null) {
-      int maxDecodableFrameSize;
       try {
-        maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
+        videoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+            context, videoAdaptationSet.representations, null, filterHdContent);
       } catch (DecoderQueryException e) {
         callback.onRenderersError(e);
         return;
       }
-      List<Representation> videoRepresentations = videoAdaptationSet.representations;
-      for (int i = 0; i < videoRepresentations.size(); i++) {
-        Format format = videoRepresentations.get(i).format;
-        if (filterHdContent && (format.width >= 1280 || format.height >= 720)) {
-          // Filtering HD content
-        } else if (format.width * format.height > maxDecodableFrameSize) {
-          // Filtering stream that device cannot play
-        } else if (!format.mimeType.equals(MimeTypes.VIDEO_MP4)
-            && !format.mimeType.equals(MimeTypes.VIDEO_WEBM)) {
-          // Filtering unsupported mime type
-        } else {
-          videoRepresentationIndexList.add(i);
-        }
-      }
     }
 
     // Build the video renderer.
     final MediaCodecVideoTrackRenderer videoRenderer;
     final TrackRenderer debugRenderer;
-    if (videoRepresentationIndexList.isEmpty()) {
+    if (videoRepresentationIndices == null || videoRepresentationIndices.length == 0) {
       videoRenderer = null;
       debugRenderer = null;
     } else {
-      int[] videoRepresentationIndices = Util.toArray(videoRepresentationIndexList);
-      DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      DataSource videoDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
       ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher, videoAdaptationSetIndex,
           videoRepresentationIndices, videoDataSource, new AdaptiveEvaluator(bandwidthMeter),
-          LIVE_EDGE_LATENCY_MS);
+          LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset);
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
           DemoPlayer.TYPE_VIDEO);
       videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
           MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
       debugRenderer = debugTextView != null
-          ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;
+          ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
     }
 
     // Build the audio chunk sources.
-    boolean haveAc3Tracks = false;
     List<ChunkSource> audioChunkSourceList = new ArrayList<ChunkSource>();
     List<String> audioTrackNameList = new ArrayList<String>();
     if (audioAdaptationSet != null) {
-      DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      DataSource audioDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
       FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
       List<Representation> audioRepresentations = audioAdaptationSet.representations;
+      List<String> codecs = new ArrayList<String>();
       for (int i = 0; i < audioRepresentations.size(); i++) {
         Format format = audioRepresentations.get(i).format;
         audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
             format.audioSamplingRate + "Hz)");
         audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
-            new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS));
-        haveAc3Tracks |= AC_3_CODEC.equals(format.codecs) || E_AC_3_CODEC.equals(format.codecs);
+            new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS,
+            elapsedRealtimeOffset));
+        codecs.add(format.codecs);
       }
-      // Filter out non-AC-3 tracks if there is an AC-3 track, to avoid having to switch renderers.
-      if (haveAc3Tracks) {
-        for (int i = audioRepresentations.size() - 1; i >= 0; i--) {
-          Format format = audioRepresentations.get(i).format;
-          if (!AC_3_CODEC.equals(format.codecs) && !E_AC_3_CODEC.equals(format.codecs)) {
-            audioTrackNameList.remove(i);
-            audioChunkSourceList.remove(i);
+
+      if (audioCapabilities != null) {
+        // If there are any passthrough audio encodings available, select the highest priority
+        // supported format (e.g. E-AC-3) and remove other tracks.
+        for (int i = 0; i < PASSTHROUGH_CODECS_PRIORITY.length; i++) {
+          String codec = PASSTHROUGH_CODECS_PRIORITY[i];
+          int encoding = PASSTHROUGH_ENCODINGS_PRIORITY[i];
+          if (codecs.indexOf(codec) == -1 || !audioCapabilities.supportsEncoding(encoding)) {
+            continue;
+          }
+
+          for (int j = audioRepresentations.size() - 1; j >= 0; j--) {
+            if (!audioRepresentations.get(j).format.codecs.equals(codec)) {
+              audioTrackNameList.remove(j);
+              audioChunkSourceList.remove(j);
+            }
           }
+          break;
         }
       }
     }
@@ -261,7 +304,7 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
     }
 
     // Build the text chunk sources.
-    DataSource textDataSource = new UriDataSource(userAgent, bandwidthMeter);
+    DataSource textDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
     FormatEvaluator textEvaluator = new FormatEvaluator.FixedEvaluator();
     List<ChunkSource> textChunkSourceList = new ArrayList<ChunkSource>();
     List<String> textTrackNameList = new ArrayList<String>();
@@ -273,7 +316,7 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
           Representation representation = representations.get(j);
           textTrackNameList.add(representation.format.id);
           textChunkSourceList.add(new DashChunkSource(manifestFetcher, i, new int[] {j},
-              textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS));
+              textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset));
         }
       }
     }
@@ -321,9 +364,9 @@ public void onManifest(String contentId, MediaPresentationDescription manifest)
     public static Pair<DrmSessionManager, Boolean> getDrmSessionManagerData(DemoPlayer player,
         MediaDrmCallback drmCallback) throws UnsupportedDrmException {
       try {
-        StreamingDrmSessionManager streamingDrmSessionManager = new StreamingDrmSessionManager(
-            DemoUtil.WIDEVINE_UUID, player.getPlaybackLooper(), drmCallback, null,
-            player.getMainHandler(), player);
+        StreamingDrmSessionManager streamingDrmSessionManager =
+            StreamingDrmSessionManager.newWidevineInstance(player.getPlaybackLooper(), drmCallback,
+            null, player.getMainHandler(), player);
         return Pair.create((DrmSessionManager) streamingDrmSessionManager,
             getWidevineSecurityLevel(streamingDrmSessionManager) == SECURITY_LEVEL_1);
       } catch (UnsupportedSchemeException e) {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
index c0b9d50417..2a846f46b2 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.MediaCodecTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.Format;
 
 import android.widget.TextView;
@@ -30,21 +29,17 @@
 /* package */ class DebugTrackRenderer extends TrackRenderer implements Runnable {
 
   private final TextView textView;
+  private final DemoPlayer player;
   private final MediaCodecTrackRenderer renderer;
-  private final ChunkSampleSource videoSampleSource;
 
   private volatile boolean pendingFailure;
   private volatile long currentPositionUs;
 
-  public DebugTrackRenderer(TextView textView, MediaCodecTrackRenderer renderer) {
-    this(textView, renderer, null);
-  }
-
-  public DebugTrackRenderer(TextView textView, MediaCodecTrackRenderer renderer,
-      ChunkSampleSource videoSampleSource) {
+  public DebugTrackRenderer(TextView textView, DemoPlayer player,
+      MediaCodecTrackRenderer renderer) {
     this.textView = textView;
+    this.player = player;
     this.renderer = renderer;
-    this.videoSampleSource = videoSampleSource;
   }
 
   public void injectFailure() {
@@ -62,7 +57,7 @@ protected boolean isReady() {
   }
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     maybeFail();
     return STATE_PREPARED;
   }
@@ -82,13 +77,13 @@ public void run() {
   }
 
   private String getRenderString() {
-    return "ms(" + (currentPositionUs / 1000) + "), " + getQualityString()
-        + ", " + renderer.codecCounters.getDebugString();
+    return getQualityString() + " " + renderer.codecCounters.getDebugString();
   }
 
   private String getQualityString() {
-    Format format = videoSampleSource == null ? null : videoSampleSource.getFormat();
-    return format == null ? "null" : "height(" + format.height + "), itag(" + format.id + ")";
+    Format format = player.getVideoFormat();
+    return format == null ? "id:? br:? h:?"
+        : "id:" + format.id + " br:" + format.bitrate + " h:" + format.height;
   }
 
   @Override
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index 4704999ad1..dd83694659 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -24,8 +24,10 @@
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
+import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.hls.HlsSampleSource;
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
 import com.google.android.exoplayer.text.TextRenderer;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
@@ -46,9 +48,9 @@
  * SmoothStreaming and so on).
  */
 public class DemoPlayer implements ExoPlayer.Listener, ChunkSampleSource.EventListener,
-    DefaultBandwidthMeter.EventListener, MediaCodecVideoTrackRenderer.EventListener,
-    MediaCodecAudioTrackRenderer.EventListener, TextRenderer,
-    StreamingDrmSessionManager.EventListener {
+    HlsSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
+    MediaCodecVideoTrackRenderer.EventListener, MediaCodecAudioTrackRenderer.EventListener,
+    StreamingDrmSessionManager.EventListener, TextRenderer {
 
   /**
    * Builds renderers for the player.
@@ -112,8 +114,7 @@ void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSource
     void onAudioTrackWriteError(AudioTrack.WriteException e);
     void onDecoderInitializationError(DecoderInitializationException e);
     void onCryptoError(CryptoException e);
-    void onUpstreamError(int sourceId, IOException e);
-    void onConsumptionError(int sourceId, IOException e);
+    void onLoadError(int sourceId, IOException e);
     void onDrmSessionManagerError(Exception e);
   }
 
@@ -121,13 +122,16 @@ void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSource
    * A listener for debugging information.
    */
   public interface InfoListener {
-    void onVideoFormatEnabled(String formatId, int trigger, int mediaTimeMs);
-    void onAudioFormatEnabled(String formatId, int trigger, int mediaTimeMs);
+    void onVideoFormatEnabled(Format format, int trigger, int mediaTimeMs);
+    void onAudioFormatEnabled(Format format, int trigger, int mediaTimeMs);
     void onDroppedFrames(int count, long elapsed);
     void onBandwidthSample(int elapsedMs, long bytes, long bitrateEstimate);
-    void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitialization,
-        int mediaStartTimeMs, int mediaEndTimeMs, long length);
-    void onLoadCompleted(int sourceId, long bytesLoaded);
+    void onLoadStarted(int sourceId, long length, int type, int trigger, Format format,
+        int mediaStartTimeMs, int mediaEndTimeMs);
+    void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Format format,
+        int mediaStartTimeMs, int mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs);
+    void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
+        long initializationDurationMs);
   }
 
   /**
@@ -178,6 +182,7 @@ void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitial
   private Surface surface;
   private InternalRendererBuilderCallback builderCallback;
   private TrackRenderer videoRenderer;
+  private Format videoFormat;
   private int videoTrackToRestore;
 
   private MultiTrackChunkSource[] multiTrackSources;
@@ -265,6 +270,10 @@ public void selectTrack(int type, int index) {
     }
   }
 
+  public Format getVideoFormat() {
+    return videoFormat;
+  }
+
   public void setBackgrounded(boolean backgrounded) {
     if (this.backgrounded == backgrounded) {
       return;
@@ -286,6 +295,9 @@ public void prepare() {
     if (builderCallback != null) {
       builderCallback.cancel();
     }
+    videoFormat = null;
+    videoRenderer = null;
+    multiTrackSources = null;
     rendererBuildingState = RENDERER_BUILDING_STATE_BUILDING;
     maybeReportPlayerState();
     builderCallback = new InternalRendererBuilderCallback();
@@ -314,15 +326,15 @@ public void prepare() {
       }
     }
     // Complete preparation.
-    this.videoRenderer = renderers[TYPE_VIDEO];
     this.trackNames = trackNames;
+    this.videoRenderer = renderers[TYPE_VIDEO];
     this.multiTrackSources = multiTrackSources;
-    rendererBuildingState = RENDERER_BUILDING_STATE_BUILT;
     pushSurface(false);
     pushTrackSelection(TYPE_VIDEO, true);
     pushTrackSelection(TYPE_AUDIO, true);
     pushTrackSelection(TYPE_TEXT, true);
     player.prepare(renderers);
+    rendererBuildingState = RENDERER_BUILDING_STATE_BUILT;
   }
 
   /* package */ void onRenderersError(Exception e) {
@@ -429,15 +441,15 @@ public void onBandwidthSample(int elapsedMs, long bytes, long bitrateEstimate) {
   }
 
   @Override
-  public void onDownstreamFormatChanged(int sourceId, String formatId, int trigger,
-      int mediaTimeMs) {
+  public void onDownstreamFormatChanged(int sourceId, Format format, int trigger, int mediaTimeMs) {
     if (infoListener == null) {
       return;
     }
     if (sourceId == TYPE_VIDEO) {
-      infoListener.onVideoFormatEnabled(formatId, trigger, mediaTimeMs);
+      videoFormat = format;
+      infoListener.onVideoFormatEnabled(format, trigger, mediaTimeMs);
     } else if (sourceId == TYPE_AUDIO) {
-      infoListener.onAudioFormatEnabled(formatId, trigger, mediaTimeMs);
+      infoListener.onAudioFormatEnabled(format, trigger, mediaTimeMs);
     }
   }
 
@@ -477,16 +489,19 @@ public void onCryptoError(CryptoException e) {
   }
 
   @Override
-  public void onUpstreamError(int sourceId, IOException e) {
-    if (internalErrorListener != null) {
-      internalErrorListener.onUpstreamError(sourceId, e);
+  public void onDecoderInitialized(
+      String decoderName,
+      long elapsedRealtimeMs,
+      long initializationDurationMs) {
+    if (infoListener != null) {
+      infoListener.onDecoderInitialized(decoderName, elapsedRealtimeMs, initializationDurationMs);
     }
   }
 
   @Override
-  public void onConsumptionError(int sourceId, IOException e) {
+  public void onLoadError(int sourceId, IOException e) {
     if (internalErrorListener != null) {
-      internalErrorListener.onConsumptionError(sourceId, e);
+      internalErrorListener.onLoadError(sourceId, e);
     }
   }
 
@@ -518,18 +533,20 @@ public void onDrawnToSurface(Surface surface) {
   }
 
   @Override
-  public void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitialization,
-      int mediaStartTimeMs, int mediaEndTimeMs, long length) {
+  public void onLoadStarted(int sourceId, long length, int type, int trigger, Format format,
+      int mediaStartTimeMs, int mediaEndTimeMs) {
     if (infoListener != null) {
-      infoListener.onLoadStarted(sourceId, formatId, trigger, isInitialization, mediaStartTimeMs,
-          mediaEndTimeMs, length);
+      infoListener.onLoadStarted(sourceId, length, type, trigger, format, mediaStartTimeMs,
+          mediaEndTimeMs);
     }
   }
 
   @Override
-  public void onLoadCompleted(int sourceId, long bytesLoaded) {
+  public void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Format format,
+      int mediaStartTimeMs, int mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs) {
     if (infoListener != null) {
-      infoListener.onLoadCompleted(sourceId, bytesLoaded);
+      infoListener.onLoadCompleted(sourceId, bytesLoaded, type, trigger, format, mediaStartTimeMs,
+          mediaEndTimeMs, elapsedRealtimeMs, loadDurationMs);
     }
   }
 
@@ -539,14 +556,7 @@ public void onLoadCanceled(int sourceId, long bytesLoaded) {
   }
 
   @Override
-  public void onUpstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs,
-      long bytesDiscarded) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onDownstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs,
-      long bytesDiscarded) {
+  public void onUpstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs) {
     // Do nothing.
   }
 
@@ -563,7 +573,7 @@ private void maybeReportPlayerState() {
   }
 
   private void pushSurface(boolean blockForSurfacePush) {
-    if (rendererBuildingState != RENDERER_BUILDING_STATE_BUILT) {
+    if (videoRenderer == null) {
       return;
     }
 
@@ -577,7 +587,7 @@ private void pushSurface(boolean blockForSurfacePush) {
   }
 
   private void pushTrackSelection(int type, boolean allowRendererEnable) {
-    if (rendererBuildingState != RENDERER_BUILDING_STATE_BUILT) {
+    if (multiTrackSources == null) {
       return;
     }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
similarity index 68%
rename from demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java
rename to demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
index 36c2e58879..c9cff47697 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DefaultRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
@@ -20,35 +20,41 @@
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
-import com.google.android.exoplayer.source.DefaultSampleSource;
-import com.google.android.exoplayer.source.FrameworkSampleExtractor;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 
-import android.content.Context;
 import android.media.MediaCodec;
 import android.net.Uri;
 import android.widget.TextView;
 
 /**
- * A {@link RendererBuilder} for streams that can be read using
- * {@link android.media.MediaExtractor}.
+ * A {@link RendererBuilder} for streams that can be read using an {@link Extractor}.
  */
-public class DefaultRendererBuilder implements RendererBuilder {
+public class ExtractorRendererBuilder implements RendererBuilder {
 
-  private final Context context;
+  private static final int BUFFER_SIZE = 10 * 1024 * 1024;
+
+  private final String userAgent;
   private final Uri uri;
   private final TextView debugTextView;
+  private final Extractor extractor;
 
-  public DefaultRendererBuilder(Context context, Uri uri, TextView debugTextView) {
-    this.context = context;
+  public ExtractorRendererBuilder(String userAgent, Uri uri, TextView debugTextView,
+      Extractor extractor) {
+    this.userAgent = userAgent;
     this.uri = uri;
     this.debugTextView = debugTextView;
+    this.extractor = extractor;
   }
 
   @Override
   public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
     // Build the video and audio renderers.
-    DefaultSampleSource sampleSource =
-        new DefaultSampleSource(new FrameworkSampleExtractor(context, uri, null), 2);
+    DataSource dataSource = new DefaultUriDataSource(userAgent, null);
+    ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor, 2,
+        BUFFER_SIZE);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
         null, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, player.getMainHandler(),
         player, 50);
@@ -57,8 +63,7 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
 
     // Build the debug renderer.
     TrackRenderer debugRenderer = debugTextView != null
-        ? new DebugTrackRenderer(debugTextView, videoRenderer)
-        : null;
+        ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
 
     // Invoke the callback.
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 326a0689d5..171433c0d8 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -16,11 +16,15 @@
 package com.google.android.exoplayer.demo.player;
 
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.hls.HlsChunkSource;
+import com.google.android.exoplayer.hls.HlsMasterPlaylist;
 import com.google.android.exoplayer.hls.HlsPlaylist;
 import com.google.android.exoplayer.hls.HlsPlaylistParser;
 import com.google.android.exoplayer.hls.HlsSampleSource;
@@ -29,11 +33,14 @@
 import com.google.android.exoplayer.text.eia608.Eia608TrackRenderer;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer.upstream.UriDataSource;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.util.ManifestFetcher;
 import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
 
+import android.content.Context;
 import android.media.MediaCodec;
+import android.os.Handler;
+import android.widget.TextView;
 
 import java.io.IOException;
 import java.util.Map;
@@ -43,17 +50,25 @@
  */
 public class HlsRendererBuilder implements RendererBuilder, ManifestCallback<HlsPlaylist> {
 
+  private static final int REQUESTED_BUFFER_SIZE = 18 * 1024 * 1024;
+  private static final long REQUESTED_BUFFER_DURATION_MS = 40000;
+
+  private final Context context;
   private final String userAgent;
   private final String url;
-  private final String contentId;
+  private final TextView debugTextView;
+  private final AudioCapabilities audioCapabilities;
 
   private DemoPlayer player;
   private RendererBuilderCallback callback;
 
-  public HlsRendererBuilder(String userAgent, String url, String contentId) {
+  public HlsRendererBuilder(Context context, String userAgent, String url, TextView debugTextView,
+      AudioCapabilities audioCapabilities) {
+    this.context = context;
     this.userAgent = userAgent;
     this.url = url;
-    this.contentId = contentId;
+    this.debugTextView = debugTextView;
+    this.audioCapabilities = audioCapabilities;
   }
 
   @Override
@@ -62,39 +77,58 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
     this.callback = callback;
     HlsPlaylistParser parser = new HlsPlaylistParser();
     ManifestFetcher<HlsPlaylist> playlistFetcher =
-        new ManifestFetcher<HlsPlaylist>(parser, contentId, url, userAgent);
+        new ManifestFetcher<HlsPlaylist>(url, new DefaultUriDataSource(userAgent, null), parser);
     playlistFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
 
   @Override
-  public void onManifestError(String contentId, IOException e) {
+  public void onSingleManifestError(IOException e) {
     callback.onRenderersError(e);
   }
 
   @Override
-  public void onManifest(String contentId, HlsPlaylist manifest) {
+  public void onSingleManifest(HlsPlaylist manifest) {
+    Handler mainHandler = player.getMainHandler();
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
 
-    DataSource dataSource = new UriDataSource(userAgent, bandwidthMeter);
-    HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter, null,
-        HlsChunkSource.ADAPTIVE_MODE_SPLICE);
-    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, true, 3);
+    int[] variantIndices = null;
+    if (manifest instanceof HlsMasterPlaylist) {
+      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) manifest;
+      try {
+        variantIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+            context, masterPlaylist.variants, null, false);
+      } catch (DecoderQueryException e) {
+        callback.onRenderersError(e);
+        return;
+      }
+    }
+
+    DataSource dataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
+    HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter,
+        variantIndices, HlsChunkSource.ADAPTIVE_MODE_SPLICE, audioCapabilities);
+    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, true, 3, REQUESTED_BUFFER_SIZE,
+        REQUESTED_BUFFER_DURATION_MS, mainHandler, player, DemoPlayer.TYPE_VIDEO);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
-        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, player.getMainHandler(), player, 50);
+        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, mainHandler, player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
 
     MetadataTrackRenderer<Map<String, Object>> id3Renderer =
         new MetadataTrackRenderer<Map<String, Object>>(sampleSource, new Id3Parser(),
-            player.getId3MetadataRenderer(), player.getMainHandler().getLooper());
+            player.getId3MetadataRenderer(), mainHandler.getLooper());
 
     Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
-        player.getMainHandler().getLooper());
+        mainHandler.getLooper());
+
+    // Build the debug renderer.
+    TrackRenderer debugRenderer = debugTextView != null
+        ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
 
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
     renderers[DemoPlayer.TYPE_TIMED_METADATA] = id3Renderer;
     renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
+    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;
     callback.onRenderers(null, null, renderers);
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
index 22a342bfc7..ce8a979209 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecUtil;
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
@@ -27,6 +26,7 @@
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
+import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.DrmSessionManager;
@@ -35,25 +35,26 @@
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingChunkSource;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
-import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifestParser;
 import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.text.ttml.TtmlParser;
-import com.google.android.exoplayer.upstream.BufferPool;
 import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer.upstream.UriDataSource;
+import com.google.android.exoplayer.upstream.DefaultHttpDataSource;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.util.ManifestFetcher;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
+import android.content.Context;
 import android.media.MediaCodec;
 import android.media.UnsupportedSchemeException;
 import android.os.Handler;
 import android.widget.TextView;
 
 import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.UUID;
 
 /**
@@ -68,9 +69,9 @@
   private static final int TEXT_BUFFER_SEGMENTS = 2;
   private static final int LIVE_EDGE_LATENCY_MS = 30000;
 
+  private final Context context;
   private final String userAgent;
   private final String url;
-  private final String contentId;
   private final MediaDrmCallback drmCallback;
   private final TextView debugTextView;
 
@@ -78,11 +79,11 @@
   private RendererBuilderCallback callback;
   private ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
 
-  public SmoothStreamingRendererBuilder(String userAgent, String url, String contentId,
+  public SmoothStreamingRendererBuilder(Context context, String userAgent, String url,
       MediaDrmCallback drmCallback, TextView debugTextView) {
+    this.context = context;
     this.userAgent = userAgent;
     this.url = url;
-    this.contentId = contentId;
     this.drmCallback = drmCallback;
     this.debugTextView = debugTextView;
   }
@@ -92,20 +93,20 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
     this.player = player;
     this.callback = callback;
     SmoothStreamingManifestParser parser = new SmoothStreamingManifestParser();
-    manifestFetcher = new ManifestFetcher<SmoothStreamingManifest>(parser, contentId,
-        url + "/Manifest", userAgent);
+    manifestFetcher = new ManifestFetcher<SmoothStreamingManifest>(url + "/Manifest",
+        new DefaultHttpDataSource(userAgent, null), parser);
     manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
 
   @Override
-  public void onManifestError(String contentId, IOException exception) {
+  public void onSingleManifestError(IOException exception) {
     callback.onRenderersError(exception);
   }
 
   @Override
-  public void onManifest(String contentId, SmoothStreamingManifest manifest) {
+  public void onSingleManifest(SmoothStreamingManifest manifest) {
     Handler mainHandler = player.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
+    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
 
     // Check drm support if necessary.
@@ -126,17 +127,9 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
     }
 
     // Obtain stream elements for playback.
-    int maxDecodableFrameSize;
-    try {
-      maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
-    } catch (DecoderQueryException e) {
-      callback.onRenderersError(e);
-      return;
-    }
     int audioStreamElementCount = 0;
     int textStreamElementCount = 0;
     int videoStreamElementIndex = -1;
-    ArrayList<Integer> videoTrackIndexList = new ArrayList<Integer>();
     for (int i = 0; i < manifest.streamElements.length; i++) {
       if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
         audioStreamElementCount++;
@@ -145,27 +138,29 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
       } else if (videoStreamElementIndex == -1
           && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
         videoStreamElementIndex = i;
-        StreamElement streamElement = manifest.streamElements[i];
-        for (int j = 0; j < streamElement.tracks.length; j++) {
-          TrackElement trackElement = streamElement.tracks[j];
-          if (trackElement.maxWidth * trackElement.maxHeight <= maxDecodableFrameSize) {
-            videoTrackIndexList.add(j);
-          } else {
-            // The device isn't capable of playing this stream.
-          }
-        }
+      }
+    }
+
+    // Determine which video tracks we should use for playback.
+    int[] videoTrackIndices = null;
+    if (videoStreamElementIndex != -1) {
+      try {
+        videoTrackIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(context,
+            Arrays.asList(manifest.streamElements[videoStreamElementIndex].tracks), null, false);
+      } catch (DecoderQueryException e) {
+        callback.onRenderersError(e);
+        return;
       }
     }
 
     // Build the video renderer.
     final MediaCodecVideoTrackRenderer videoRenderer;
     final TrackRenderer debugRenderer;
-    if (videoTrackIndexList.isEmpty()) {
+    if (videoTrackIndices == null || videoTrackIndices.length == 0) {
       videoRenderer = null;
       debugRenderer = null;
     } else {
-      int[] videoTrackIndices = Util.toArray(videoTrackIndexList);
-      DataSource videoDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      DataSource videoDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
       ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
           videoStreamElementIndex, videoTrackIndices, videoDataSource,
           new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
@@ -175,8 +170,7 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
       videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
           MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
       debugRenderer = debugTextView != null
-          ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource)
-          : null;
+          ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
     }
 
     // Build the audio renderer.
@@ -190,7 +184,7 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
     } else {
       audioTrackNames = new String[audioStreamElementCount];
       ChunkSource[] audioChunkSources = new ChunkSource[audioStreamElementCount];
-      DataSource audioDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      DataSource audioDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
       FormatEvaluator audioFormatEvaluator = new FormatEvaluator.FixedEvaluator();
       audioStreamElementCount = 0;
       for (int i = 0; i < manifest.streamElements.length; i++) {
@@ -221,7 +215,7 @@ public void onManifest(String contentId, SmoothStreamingManifest manifest) {
     } else {
       textTrackNames = new String[textStreamElementCount];
       ChunkSource[] textChunkSources = new ChunkSource[textStreamElementCount];
-      DataSource ttmlDataSource = new UriDataSource(userAgent, bandwidthMeter);
+      DataSource ttmlDataSource = new DefaultUriDataSource(userAgent, bandwidthMeter);
       FormatEvaluator ttmlFormatEvaluator = new FormatEvaluator.FixedEvaluator();
       textStreamElementCount = 0;
       for (int i = 0; i < manifest.streamElements.length; i++) {
diff --git a/demo/src/main/project.properties b/demo/src/main/project.properties
index 77dfd37843..4fdc858b92 100644
--- a/demo/src/main/project.properties
+++ b/demo/src/main/project.properties
@@ -8,6 +8,6 @@
 # project structure.
 
 # Project target.
-target=android-21
+target=android-22
 android.library=false
 android.library.reference.1=../../../library/src/main
diff --git a/demo/src/main/res/layout/player_activity.xml b/demo/src/main/res/layout/player_activity.xml
index 21fe68e5da..2480897ca0 100644
--- a/demo/src/main/res/layout/player_activity.xml
+++ b/demo/src/main/res/layout/player_activity.xml
@@ -16,6 +16,7 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/root"
+    android:focusable="true"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:keepScreenOn="true">
diff --git a/library/build.gradle b/library/build.gradle
index 417d627767..da79b37a4c 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -15,12 +15,17 @@ apply plugin: 'com.android.library'
 apply plugin: 'bintray-release'
 
 android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.2"
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
 
     defaultConfig {
+        // Important: ExoPlayerLib specifies a minSdkVersion of 9 because
+        // various components provided by the library may be of use on older
+        // devices. However, please note that the core video playback
+        // functionality provided by the library requires API level 16 or
+        // greater.
         minSdkVersion 9
-        targetSdkVersion 21
+        targetSdkVersion 22
     }
 
     buildTypes {
@@ -49,12 +54,27 @@ android.libraryVariants.all { variant ->
     artifacts.add('archives', task);
 }
 
+android.libraryVariants.all { variant ->
+    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {
+        title = "ExoPlayer library"
+        description "Generates Javadoc for $variant.name."
+        source = variant.javaCompile.source
+        classpath = files(variant.javaCompile.classpath.files, project.android.getBootClasspath())
+        options {
+            links "http://docs.oracle.com/javase/7/docs/api/"
+            linksOffline "https://d.android.com/reference","${android.sdkDirectory}/docs/reference"
+        }
+        exclude '**/BuildConfig.java'
+        exclude '**/R.java'
+    }
+}
+
 publish {
     repoName = 'exoplayer'
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.2.4'
+    version = 'r1.3.1'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/doc/images/exoplayer_diagrams.svg b/library/doc/images/exoplayer_diagrams.svg
deleted file mode 100644
index 6a703263a9..0000000000
--- a/library/doc/images/exoplayer_diagrams.svg
+++ /dev/null
@@ -1,2126 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   version="1.1"
-   viewBox="0.0 0.0 967.0 1445.0"
-   fill="none"
-   stroke="none"
-   stroke-linecap="square"
-   stroke-miterlimit="10"
-   id="svg2"
-   inkscape:version="0.48.3.1 r9886"
-   width="100%"
-   height="100%"
-   sodipodi:docname="exoplayer_diagrams.svg">
-  <metadata
-     id="metadata905">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <defs
-     id="defs903" />
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="640"
-     inkscape:window-height="480"
-     id="namedview901"
-     showgrid="false"
-     inkscape:zoom="0.2309719"
-     inkscape:cx="203.79815"
-     inkscape:cy="885.94073"
-     inkscape:window-x="155"
-     inkscape:window-y="24"
-     inkscape:window-maximized="0"
-     inkscape:current-layer="svg2" />
-  <clipPath
-     id="p.0">
-    <path
-       d="m0 0l967.0 0l0 1445.0l-967.0 0l0 -1445.0z"
-       clip-rule="nonzero"
-       id="path5" />
-  </clipPath>
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path9"
-     d="m 0,0 967.2362,0 0,1445.4199 -967.2362,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path11"
-     d="m 245.50919,480.56732 0,0 c 0,-10.8024 8.75706,-19.55945 19.55945,-19.55945 l 78.23544,0 0,0 c 5.18747,0 10.1625,2.06073 13.83059,5.72882 3.66813,3.66812 5.72886,8.64313 5.72886,13.83063 l 0,239.24335 c 0,10.80237 -8.75708,19.55945 -19.55945,19.55945 l -78.23544,0 c -10.80238,0 -19.55945,-8.75708 -19.55945,-19.55945 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path13"
-     d="m 245.50919,480.56732 0,0 c 0,-10.8024 8.75706,-19.55945 19.55945,-19.55945 l 78.23544,0 0,0 c 5.18747,0 10.1625,2.06073 13.83059,5.72882 3.66813,3.66812 5.72886,8.64313 5.72886,13.83063 l 0,239.24335 c 0,10.80237 -8.75708,19.55945 -19.55945,19.55945 l -78.23544,0 c -10.80238,0 -19.55945,-8.75708 -19.55945,-19.55945 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path15"
-     d="m 17.505413,495.737 0,0 c 0,-19.18106 15.549309,-34.73035 34.730354,-34.73035 l 138.917253,0 0,0 c 9.21106,0 18.04486,3.65906 24.55806,10.17228 6.51321,6.51321 10.17228,15.34701 10.17228,24.55807 l 0,208.90149 c 0,19.18103 -15.5493,34.73035 -34.73034,34.73035 l -138.917253,0 c -19.181046,0 -34.730354,-15.54932 -34.730354,-34.73035 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path17"
-     d="m 17.505413,495.737 0,0 c 0,-19.18106 15.549309,-34.73035 34.730354,-34.73035 l 138.917253,0 0,0 c 9.21106,0 18.04486,3.65906 24.55806,10.17228 6.51321,6.51321 10.17228,15.34701 10.17228,24.55807 l 0,208.90149 c 0,19.18103 -15.5493,34.73035 -34.73034,34.73035 l -138.917253,0 c -19.181046,0 -34.730354,-15.54932 -34.730354,-34.73035 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path19"
-     d="m 63.69029,524.2895 0,0 c 0,-20.86261 16.912457,-37.77506 37.77504,-37.77506 l 180.85938,0 c 10.01855,0 19.6268,3.97986 26.71099,11.06406 7.08417,7.0842 11.06403,16.69244 11.06403,26.711 l 0,151.09558 c 0,20.86261 -16.91244,37.77502 -37.77502,37.77502 l -180.85938,0 c -20.862583,0 -37.775039,-16.91241 -37.775039,-37.77502 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path21"
-     d="m 63.69029,524.2895 0,0 c 0,-20.86261 16.912457,-37.77506 37.77504,-37.77506 l 180.85938,0 c 10.01855,0 19.6268,3.97986 26.71099,11.06406 7.08417,7.0842 11.06403,16.69244 11.06403,26.711 l 0,151.09558 c 0,20.86261 -16.91244,37.77502 -37.77502,37.77502 l -180.85938,0 c -20.862583,0 -37.775039,-16.91241 -37.775039,-37.77502 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path23"
-     d="m 17.490814,740.29395 208.377936,0 0,20.97638 -208.377936,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path25"
-     d="m 84.06986,753.919 q -0.546875,0.45312 -1.046875,0.64062 -0.484375,0.1875 -1.0625,0.1875 -0.9375,0 -1.453125,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.203125,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.703125,-0.32812 0.28125,-0.0781 0.859375,-0.14063 1.171875,-0.14062 1.71875,-0.34375 0.01563,-0.1875 0.01563,-0.25 0,-0.59375 -0.28125,-0.82812 -0.359375,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.015625,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.953125,-0.125 q 0.125,-0.60938 0.421875,-0.98438 0.296875,-0.375 0.859375,-0.5625 0.5625,-0.20312 1.296875,-0.20312 0.734375,0 1.1875,0.17187 0.453125,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.04687,0.25 0.04687,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.015625,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.09375,-2.15625 q -0.515625,0.21875 -1.578125,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.234375,0.0937 -0.375,0.3125 -0.140625,0.20312 -0.140625,0.45312 0,0.39063 0.296875,0.65625 0.296875,0.25 0.859375,0.25 0.5625,0 0.984375,-0.25 0.4375,-0.25 0.65625,-0.67187 0.140625,-0.32813 0.140625,-0.96875 l 0,-0.34375 z m 2.285873,5.04687 0,-7.89062 0.890625,0 0,0.73437 q 0.3125,-0.42187 0.703125,-0.64062 0.390625,-0.21875 0.953125,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.921875,1.0625 -0.59375,0.375 -1.25,0.375 -0.484375,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.453125,1.625 0.453125,0.51563 1.078125,0.51563 0.640625,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.453125,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.109375,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.051499,5 0,-7.89062 0.890625,0 0,0.73437 q 0.3125,-0.42187 0.703125,-0.64062 0.390625,-0.21875 0.953125,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.921875,1.0625 -0.59375,0.375 -1.25,0.375 -0.484375,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.453125,1.625 0.453125,0.51563 1.078125,0.51563 0.640625,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.453125,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.109375,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.035873,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 2.398725,-6.76562 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 6.08623,-2.09375 0.9375,0.125 q -0.14062,0.98438 -0.79687,1.54688 -0.64063,0.54687 -1.5625,0.54687 -1.17188,0 -1.89063,-0.76562 -0.70312,-0.76563 -0.70312,-2.1875 0,-0.92188 0.29687,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.32812 l -0.95313,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82812,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45313,0.51563 -0.45313,1.64063 0,1.15625 0.4375,1.67187 0.4375,0.51563 1.15625,0.51563 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.07813 z m 5.32813,1.39063 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 4.41087,2 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10937,-0.26562 -0.10937,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.85127,-5.90625 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 1.99248,-2.85937 q 0,-1.57813 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76562 -0.73437,-0.76563 -0.73437,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.48437,-0.54687 0.48437,-1.67187 0,-1.04688 -0.48437,-1.59375 -0.48438,-0.54688 -1.1875,-0.54688 -0.73438,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.28587,2.85937 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.81249,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17187 0.64062,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67186,-0.1875 -0.60938,0 -1.0625,0.39063 -0.45313,0.39062 -0.45313,1.5 l 0,3.10937 -0.96875,0 z m 11.01214,-0.85937 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10937,-0.26562 -0.10937,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.83565,0.85937 0,-7.875 0.96875,0 0,2.82813 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60937 -0.96875,0 0,-3.60937 q 0,-0.73438 -0.3125,-1.0625 -0.3125,-0.32813 -0.89063,-0.32813 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60938 -0.15625,0.375 -0.15625,1.04687 l 0,3.125 -0.96875,0 z m 5.9265,0 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.50001,0 1.00001,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71877,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45488,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 8.92648,2.70313 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 5.98902,2.85937 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path27"
-     d="m 245.1181,740.46454 117.35434,0 0,20.97638 -117.35434,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path29"
-     d="m 266.89716,756.9803 0,-7.89062 0.89062,0 0,0.73437 q 0.3125,-0.42187 0.70313,-0.64062 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51563 1.07813,0.51563 0.64062,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45313,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10937,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.03586,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.11749,-0.70312 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 2.25461,5.0625 -0.10938,-0.90625 q 0.3125,0.0781 0.54688,0.0781 0.32812,0 0.51562,-0.10937 0.20313,-0.10938 0.3125,-0.29688 0.0937,-0.14062 0.29688,-0.71875 0.0312,-0.0781 0.0937,-0.23437 l -2.17188,-5.71875 1.04688,0 1.1875,3.29687 q 0.23437,0.64063 0.40625,1.32813 0.17187,-0.67188 0.40625,-1.29688 l 1.21875,-3.32812 0.96875,0 -2.17188,5.79687 q -0.34375,0.9375 -0.54687,1.29688 -0.25,0.48437 -0.59375,0.70312 -0.32813,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10937 z m 6.25,-2.20313 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76562 1.5625,-0.76562 0.53125,0 1,0.21875 0.46875,0.20312 0.76563,0.59375 0.3125,0.375 0.48437,0.92187 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26563 -0.71875,0.79687 -1.73437,0.79687 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89062 q 0,1.01562 0.28125,1.48437 0.45312,0.73438 1.23437,0.73438 0.625,0 1.07813,-0.54688 0.46875,-0.54687 0.46875,-1.64062 0,-1.10938 -0.4375,-1.64063 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54688 -0.45312,0.54687 -0.45312,1.59375 z m 8.77026,2.1875 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 6.02024,0.76562 0.9375,0.125 q -0.14063,0.98438 -0.79688,1.54688 -0.64062,0.54687 -1.5625,0.54687 -1.17187,0 -1.89062,-0.76562 -0.70313,-0.76563 -0.70313,-2.1875 0,-0.92188 0.29688,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35937,-0.34375 0.92188,0 1.51563,0.46875 0.59375,0.46875 0.76562,1.32812 l -0.95312,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82813,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45312,0.51563 -0.45312,1.64063 0,1.15625 0.4375,1.67187 0.4375,0.51563 1.15625,0.51563 0.5625,0 0.9375,-0.34375 0.39062,-0.34375 0.5,-1.07813 z m 1.60937,2.09375 0,-7.875 0.96875,0 0,4.48438 2.28125,-2.3125 1.25,0 -2.17187,2.10937 2.39062,3.59375 -1.1875,0 -1.89062,-2.92187 -0.67188,0.65625 0,2.26562 -0.96875,0 z m 10.39816,-0.85937 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10938,-0.26562 -0.10938,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 0.83564,0.85937 0,-7.875 0.96875,0 0,2.82813 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60937 -0.96875,0 0,-3.60937 q 0,-0.73438 -0.3125,-1.0625 -0.3125,-0.32813 -0.89063,-0.32813 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60938 -0.15625,0.375 -0.15625,1.04687 l 0,3.125 -0.96875,0 z m 5.92651,0 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89062 q -0.35937,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.92648,2.70313 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 5.98902,2.85937 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path31"
-     d="m 865.105,28.882114 0,0 c 0,-6.186872 5.01544,-11.202324 11.20233,-11.202324 l 44.80792,0 0,0 c 2.97107,0 5.82044,1.180241 7.92127,3.281084 2.10083,2.100843 3.28107,4.950199 3.28107,7.92124 l 0,184.398496 c 0,6.18688 -5.01545,11.20234 -11.20234,11.20234 l -44.80792,0 c -6.18689,0 -11.20233,-5.01546 -11.20233,-11.20234 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path33"
-     d="m 865.105,28.882114 0,0 c 0,-6.186872 5.01544,-11.202324 11.20233,-11.202324 l 44.80792,0 0,0 c 2.97107,0 5.82044,1.180241 7.92127,3.281084 2.10083,2.100843 3.28107,4.950199 3.28107,7.92124 l 0,184.398496 c 0,6.18688 -5.01545,11.20234 -11.20234,11.20234 l -44.80792,0 c -6.18689,0 -11.20233,-5.01546 -11.20233,-11.20234 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path35"
-     d="m 658.05774,49.039993 0,0 c 0,-17.180605 13.92761,-31.108234 31.10821,-31.108234 l 124.4292,0 0,0 c 8.25043,0 16.16297,3.277464 21.99689,9.111391 5.83393,5.833925 9.11139,13.746424 9.11139,21.996843 l 0,144.586687 c 0,17.18061 -13.92767,31.10823 -31.10828,31.10823 l -124.4292,0 c -17.1806,0 -31.10821,-13.92763 -31.10821,-31.10823 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path37"
-     d="m 658.05774,49.039993 0,0 c 0,-17.180605 13.92761,-31.108234 31.10821,-31.108234 l 124.4292,0 0,0 c 8.25043,0 16.16297,3.277464 21.99689,9.111391 5.83393,5.833925 9.11139,13.746424 9.11139,21.996843 l 0,144.586687 c 0,17.18061 -13.92767,31.10823 -31.10828,31.10823 l -124.4292,0 c -17.1806,0 -31.10821,-13.92763 -31.10821,-31.10823 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path39"
-     d="m 382.021,52.39964 0,0 c 0,-19.036083 15.43179,-34.46788 34.4679,-34.46788 l 187.4737,0 c 9.14141,0 17.9085,3.631426 24.37243,10.095407 6.46399,6.463984 10.09546,15.231024 10.09546,24.372473 l 0,137.86739 c 0,19.03609 -15.43182,34.46788 -34.46789,34.46788 l -187.4737,0 0,0 c -19.03611,0 -34.4679,-15.43179 -34.4679,-34.46788 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path41"
-     d="m 382.021,52.39964 0,0 c 0,-19.036083 15.43179,-34.46788 34.4679,-34.46788 l 187.4737,0 c 9.14141,0 17.9085,3.631426 24.37243,10.095407 6.46399,6.463984 10.09546,15.231024 10.09546,24.372473 l 0,137.86739 c 0,19.03609 -15.43182,34.46788 -34.46789,34.46788 l -187.4737,0 0,0 c -19.03611,0 -34.4679,-15.43179 -34.4679,-34.46788 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path43"
-     d="m 33.401573,147.2291 0,0 c 0,-20.764 16.83255,-37.59655 37.59655,-37.59655 l 181.216347,0 c 9.97122,0 19.53406,3.96105 26.58478,11.01177 7.05072,7.05073 11.01178,16.61356 11.01178,26.58478 l 0,150.38171 c 0,20.76398 -16.83255,37.59653 -37.59656,37.59653 l -181.216347,0 c -20.764,0 -37.59655,-16.83255 -37.59655,-37.59653 z" />
-  <path
-     style="stroke:#666666;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-dasharray:4, 3"
-     inkscape:connector-curvature="0"
-     id="path45"
-     d="m 33.401573,147.2291 0,0 c 0,-20.764 16.83255,-37.59655 37.59655,-37.59655 l 181.216347,0 c 9.97122,0 19.53406,3.96105 26.58478,11.01177 7.05072,7.05073 11.01178,16.61356 11.01178,26.58478 l 0,150.38171 c 0,20.76398 -16.83255,37.59653 -37.59656,37.59653 l -181.216347,0 c -20.764,0 -37.59655,-16.83255 -37.59655,-37.59653 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path47"
-     d="m 109.24869,130.87546 0,0 c 0,-3.68197 2.98483,-6.66679 6.6668,-6.66679 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95266 1.25027,1.25026 1.95267,2.94599 1.95267,4.71413 l 0,26.6664 c 0,3.68197 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98484 -6.6668,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path49"
-     d="m 109.24869,130.87546 0,0 c 0,-3.68197 2.98483,-6.66679 6.6668,-6.66679 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95266 1.25027,1.25026 1.95267,2.94599 1.95267,4.71413 l 0,26.6664 c 0,3.68197 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98484 -6.6668,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path51"
-     d="m 139.02151,148.04866 0,-7.875 2.96875,0 q 0.79687,0 1.20312,0.0781 0.57813,0.0937 0.96875,0.375 0.39063,0.26563 0.625,0.75 0.25,0.48438 0.25,1.07813 0,1 -0.64062,1.70312 -0.64063,0.6875 -2.3125,0.6875 l -2.01563,0 0,3.20313 -1.04687,0 z m 1.04687,-4.125 2.03125,0 q 1.01563,0 1.4375,-0.375 0.42188,-0.375 0.42188,-1.0625 0,-0.5 -0.25,-0.84375 -0.25,-0.35938 -0.65625,-0.46875 -0.26563,-0.0625 -0.96875,-0.0625 l -2.01563,0 0,2.8125 z m 5.93577,4.125 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 5.19213,5.59375 0,-7.89063 0.89062,0 0,0.73438 q 0.3125,-0.42188 0.70313,-0.64063 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51562 1.07813,0.51562 0.64062,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.45313,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.10937,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 8.78587,2.10937 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 2.28587,2.85938 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.56424,-6.76563 0,-1.10937 0.96875,0 0,1.10937 -0.96875,0 z m 0,6.76563 0,-5.70313 0.96875,0 0,5.70313 -0.96875,0 z m 2.35186,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 5.75462,0.46875 0.9375,0.14062 q 0.0625,0.4375 0.32813,0.64063 0.35937,0.26562 0.98437,0.26562 0.67188,0 1.03125,-0.26562 0.375,-0.26563 0.5,-0.75 0.0781,-0.29688 0.0781,-1.25 -0.64063,0.75 -1.59375,0.75 -1.17188,0 -1.8125,-0.84375 -0.64063,-0.85938 -0.64063,-2.04688 0,-0.8125 0.29688,-1.5 0.29687,-0.6875 0.84375,-1.0625 0.5625,-0.375 1.32812,-0.375 1,0 1.65625,0.8125 l 0,-0.6875 0.89063,0 0,4.92188 q 0,1.34375 -0.26563,1.89062 -0.26562,0.5625 -0.85937,0.875 -0.59375,0.32813 -1.45313,0.32813 -1.01562,0 -1.64062,-0.46875 -0.625,-0.45313 -0.60938,-1.375 z m 0.79688,-3.42188 q 0,1.125 0.4375,1.64063 0.45312,0.51562 1.125,0.51562 0.67187,0 1.125,-0.51562 0.45312,-0.51563 0.45312,-1.60938 0,-1.04687 -0.46875,-1.57812 -0.46875,-0.53125 -1.125,-0.53125 -0.64062,0 -1.09375,0.53125 -0.45312,0.51562 -0.45312,1.54687 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path53"
-     d="m 39.209972,209.74554 0,0 c 0,-3.68198 2.984829,-6.66681 6.666801,-6.66681 l 90.729387,0 c 1.76816,0 3.46388,0.70239 4.71414,1.95267 1.25028,1.25026 1.95267,2.946 1.95267,4.71414 l 0,26.6664 c 0,3.68197 -2.98484,6.66679 -6.66681,6.66679 l -90.729386,0 0,0 c -3.681973,0 -6.666802,-2.98482 -6.666802,-6.66679 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path55"
-     d="m 39.209972,209.74554 0,0 c 0,-3.68198 2.984829,-6.66681 6.666801,-6.66681 l 90.729387,0 c 1.76816,0 3.46388,0.70239 4.71414,1.95267 1.25028,1.25026 1.95267,2.946 1.95267,4.71414 l 0,26.6664 c 0,3.68197 -2.98484,6.66679 -6.66681,6.66679 l -90.729386,0 0,0 c -3.681973,0 -6.666802,-2.98482 -6.666802,-6.66679 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path57"
-     d="m 70.728455,226.91875 0,-7.875 2.953125,0 q 0.890625,0 1.4375,0.25 0.546875,0.23437 0.859375,0.73437 0.3125,0.48438 0.3125,1.03125 0,0.5 -0.28125,0.95313 -0.265625,0.4375 -0.828125,0.71875 0.71875,0.20312 1.09375,0.71875 0.390625,0.5 0.390625,1.1875 0,0.54687 -0.234375,1.03125 -0.234375,0.46875 -0.578125,0.73437 -0.34375,0.25 -0.859375,0.39063 -0.515625,0.125 -1.265625,0.125 l -3,0 z m 1.03125,-4.5625 1.703125,0 q 0.703125,0 1,-0.0937 0.390625,-0.125 0.59375,-0.39063 0.203125,-0.28125 0.203125,-0.6875 0,-0.39062 -0.1875,-0.6875 -0.1875,-0.29687 -0.546875,-0.40625 -0.34375,-0.10937 -1.1875,-0.10937 l -1.578125,0 0,2.375 z m 0,3.64062 1.96875,0 q 0.5,0 0.703125,-0.0469 0.359375,-0.0625 0.59375,-0.20313 0.25,-0.15625 0.40625,-0.4375 0.15625,-0.29687 0.15625,-0.67187 0,-0.4375 -0.234375,-0.76563 -0.21875,-0.32812 -0.625,-0.45312 -0.390625,-0.14063 -1.140625,-0.14063 l -1.828125,0 0,2.71875 z m 9.732635,0.92188 0,-0.84375 q -0.671875,0.96875 -1.8125,0.96875 -0.5,0 -0.953125,-0.1875 -0.4375,-0.20313 -0.65625,-0.48438 -0.203125,-0.29687 -0.28125,-0.71875 -0.0625,-0.28125 -0.0625,-0.90625 l 0,-3.53125 0.96875,0 0,3.15625 q 0,0.76563 0.0625,1.03125 0.09375,0.375 0.375,0.59375 0.296875,0.21875 0.734375,0.21875 0.4375,0 0.8125,-0.21875 0.390625,-0.23437 0.546875,-0.60937 0.15625,-0.39063 0.15625,-1.10938 l 0,-3.0625 0.96875,0 0,5.70313 -0.859375,0 z m 2.410874,0 0,-4.95313 -0.84375,0 0,-0.75 0.84375,0 0,-0.60937 q 0,-0.57813 0.109375,-0.85938 0.140625,-0.375 0.484375,-0.60937 0.359375,-0.23438 0.984375,-0.23438 0.40625,0 0.90625,0.10938 l -0.140625,0.84375 q -0.3125,-0.0625 -0.578125,-0.0625 -0.4375,0 -0.625,0.1875 -0.171875,0.1875 -0.171875,0.70312 l 0,0.53125 1.109375,0 0,0.75 -1.109375,0 0,4.95313 -0.96875,0 z m 2.960647,0 0,-4.95313 -0.84375,0 0,-0.75 0.84375,0 0,-0.60937 q 0,-0.57813 0.109375,-0.85938 0.140625,-0.375 0.484375,-0.60937 0.359375,-0.23438 0.984375,-0.23438 0.40625,0 0.90625,0.10938 l -0.140625,0.84375 q -0.3125,-0.0625 -0.578125,-0.0625 -0.4375,0 -0.625,0.1875 -0.171875,0.1875 -0.171875,0.70312 l 0,0.53125 1.109375,0 0,0.75 -1.109375,0 0,4.95313 -0.96875,0 z m 6.632523,-1.84375 1,0.125 q -0.234375,0.875 -0.875,1.35937 -0.640625,0.48438 -1.625,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 5.192123,3.40625 0,-5.70313 0.859375,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.609375,-0.1875 0.5,0 1,0.3125 l -0.328125,0.89063 q -0.359375,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.359375,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.56424,-6.76563 0,-1.10937 0.968748,0 0,1.10937 -0.968748,0 z m 0,6.76563 0,-5.70313 0.968748,0 0,5.70313 -0.968748,0 z m 2.351848,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 5.75463,0.46875 0.9375,0.14062 q 0.0625,0.4375 0.32812,0.64063 0.35938,0.26562 0.98438,0.26562 0.67187,0 1.03125,-0.26562 0.375,-0.26563 0.5,-0.75 0.0781,-0.29688 0.0781,-1.25 -0.64062,0.75 -1.59375,0.75 -1.17187,0 -1.8125,-0.84375 -0.64062,-0.85938 -0.64062,-2.04688 0,-0.8125 0.29687,-1.5 0.29688,-0.6875 0.84375,-1.0625 0.5625,-0.375 1.32813,-0.375 1,0 1.65625,0.8125 l 0,-0.6875 0.89062,0 0,4.92188 q 0,1.34375 -0.26562,1.89062 -0.26563,0.5625 -0.85938,0.875 -0.59375,0.32813 -1.45312,0.32813 -1.01563,0 -1.64063,-0.46875 -0.625,-0.45313 -0.60937,-1.375 z m 0.79687,-3.42188 q 0,1.125 0.4375,1.64063 0.45313,0.51562 1.125,0.51562 0.67188,0 1.125,-0.51562 0.45313,-0.51563 0.45313,-1.60938 0,-1.04687 -0.46875,-1.57812 -0.46875,-0.53125 -1.125,-0.53125 -0.64063,0 -1.09375,0.53125 -0.45313,0.51562 -0.45313,1.54687 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path59"
-     d="m 179.2874,209.74686 0,0 c 0,-3.68198 2.98483,-6.66681 6.66681,-6.66681 l 90.72938,0 c 1.76813,0 3.46387,0.70239 4.71415,1.95267 1.25027,1.25026 1.95266,2.946 1.95266,4.71414 l 0,26.6664 c 0,3.68197 -2.98483,6.66679 -6.66681,6.66679 l -90.72938,0 0,0 c -3.68198,0 -6.66681,-2.98482 -6.66681,-6.66679 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path61"
-     d="m 179.2874,209.74686 0,0 c 0,-3.68198 2.98483,-6.66681 6.66681,-6.66681 l 90.72938,0 c 1.76813,0 3.46387,0.70239 4.71415,1.95267 1.25027,1.25026 1.95266,2.946 1.95266,4.71414 l 0,26.6664 c 0,3.68197 -2.98483,6.66679 -6.66681,6.66679 l -90.72938,0 0,0 c -3.68198,0 -6.66681,-2.98482 -6.66681,-6.66679 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path63"
-     d="m 216.77666,226.92006 0,-7.875 3.5,0 q 1.04687,0 1.59375,0.21875 0.54687,0.20312 0.875,0.75 0.32812,0.53125 0.32812,1.1875 0,0.82812 -0.54687,1.40625 -0.53125,0.57812 -1.67188,0.73437 0.42188,0.1875 0.625,0.39063 0.46875,0.42187 0.875,1.04687 l 1.35938,2.14063 -1.29688,0 -1.04687,-1.64063 q -0.45313,-0.70312 -0.75,-1.07812 -0.29688,-0.375 -0.53125,-0.53125 -0.23438,-0.15625 -0.46875,-0.20313 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20313,0 0,3.5 -1.04687,0 z m 1.04687,-4.40625 2.23438,0 q 0.71875,0 1.125,-0.14063 0.40625,-0.14062 0.60937,-0.46875 0.20313,-0.32812 0.20313,-0.70312 0,-0.5625 -0.40625,-0.92188 -0.39063,-0.35937 -1.26563,-0.35937 l -2.5,0 0,2.59375 z m 10.41436,2.5625 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 8.9265,2.70312 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 5.989,2.85938 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z m 5.239,5.04687 -0.10937,-0.90625 q 0.3125,0.0781 0.54687,0.0781 0.32813,0 0.51563,-0.10938 0.20312,-0.10937 0.3125,-0.29687 0.0937,-0.14063 0.29687,-0.71875 0.0312,-0.0781 0.0937,-0.23438 l -2.17187,-5.71875 1.04687,0 1.1875,3.29688 q 0.23438,0.64062 0.40625,1.32812 0.17188,-0.67187 0.40625,-1.29687 l 1.21875,-3.32813 0.96875,0 -2.17187,5.79688 q -0.34375,0.9375 -0.54688,1.29687 -0.25,0.48438 -0.59375,0.70313 -0.32812,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10938 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path65"
-     d="m 109.24869,288.61563 0,0 c 0,-3.68198 2.98483,-6.66681 6.6668,-6.66681 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95267 1.25027,1.25024 1.95267,2.94598 1.95267,4.71414 l 0,26.66638 c 0,3.68198 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98483 -6.6668,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path67"
-     d="m 109.24869,288.61563 0,0 c 0,-3.68198 2.98483,-6.66681 6.6668,-6.66681 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95267 1.25027,1.25024 1.95267,2.94598 1.95267,4.71414 l 0,26.66638 c 0,3.68198 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98483 -6.6668,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path69"
-     d="m 146.74837,305.78882 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35937,0 0,0.92187 -4.35937,0 0,2.6875 4.84375,0 0,0.92188 -5.875,0 z m 6.95139,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 9.62962,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z m 9.1765,1 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89524,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29687,-0.70312 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42187,0.51562 -0.42187,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path71"
-     d="m 88.838585,73.16798 72.440935,0 0,20.97638 -72.440935,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path73"
-     d="m 109.17133,89.68367 0,-7.890625 0.89062,0 0,0.734375 q 0.3125,-0.421875 0.70313,-0.640625 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.671875 0.28125,1.5 0,0.875 -0.3125,1.578125 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.203125 -0.375,-0.203125 -0.625,-0.515625 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.515625 1.07813,0.515625 0.64062,0 1.09375,-0.53125 0.46875,-0.546875 0.46875,-1.703125 0,-1.078125 -0.45313,-1.625 -0.4375,-0.546875 -1.0625,-0.546875 -0.625,0 -1.10937,0.578125 -0.46875,0.578125 -0.46875,1.6875 z m 5.05149,2.8125 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19213,5.59375 0,-7.890625 0.89062,0 0,0.734375 q 0.3125,-0.421875 0.70313,-0.640625 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.671875 0.28125,1.5 0,0.875 -0.3125,1.578125 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.203125 -0.375,-0.203125 -0.625,-0.515625 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.515625 1.07813,0.515625 0.64062,0 1.09375,-0.53125 0.46875,-0.546875 0.46875,-1.703125 0,-1.078125 -0.45313,-1.625 -0.4375,-0.546875 -1.0625,-0.546875 -0.625,0 -1.10937,0.578125 -0.46875,0.578125 -0.46875,1.6875 z m 8.78587,2.109375 q -0.54687,0.453125 -1.04687,0.640625 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.453125 -0.5,-0.46875 -0.5,-1.171875 0,-0.421875 0.1875,-0.765625 0.20313,-0.34375 0.5,-0.546875 0.3125,-0.21875 0.70313,-0.328125 0.28125,-0.07813 0.85937,-0.140625 1.17188,-0.140625 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.828125 -0.35938,-0.328125 -1.09375,-0.328125 -0.6875,0 -1.01563,0.234375 -0.3125,0.234375 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.609375 0.42187,-0.984375 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.203125 1.29687,-0.203125 0.73438,0 1.1875,0.171875 0.45313,0.171875 0.65625,0.4375 0.21875,0.25 0.3125,0.640625 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.703125 0.0625,0.359375 0.25,0.6875 l -1.01563,0 q -0.15625,-0.296875 -0.1875,-0.703125 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.359375 -0.59375,0.09375 -0.84375,0.203125 -0.23438,0.09375 -0.375,0.3125 -0.14063,0.203125 -0.14063,0.453125 0,0.390625 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.671875 0.14062,-0.328125 0.14062,-0.96875 l 0,-0.34375 z m 2.28587,2.859375 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 7.0515,5.71875 q -0.8125,-1 -1.35937,-2.359375 -0.54688,-1.359375 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.015625 0,2.578125 1.60937,5.15625 l -0.6875,0 z m 2.32987,0 -0.6875,0 q 1.59375,-2.578125 1.59375,-5.15625 0,-1.015625 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.453125 -0.5625,2.8125 -0.54688,1.359375 -1.34375,2.359375 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path75"
-     d="m 109.23491,24.34659 0,0 c 0,-3.681973 2.98483,-6.6668 6.6668,-6.6668 l 90.72939,0 c 1.76814,0 3.46387,0.702393 4.71413,1.95266 1.25027,1.250269 1.95267,2.945995 1.95267,4.71414 l 0,26.666403 c 0,3.681969 -2.98484,6.666798 -6.6668,6.666798 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.984829 -6.6668,-6.666798 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path77"
-     d="m 109.23491,24.34659 0,0 c 0,-3.681973 2.98483,-6.6668 6.6668,-6.6668 l 90.72939,0 c 1.76814,0 3.46387,0.702393 4.71413,1.95266 1.25027,1.250269 1.95267,2.945995 1.95267,4.71414 l 0,26.666403 c 0,3.681969 -2.98484,6.666798 -6.6668,6.666798 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.984829 -6.6668,-6.666798 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path79"
-     d="m 153.70709,41.51979 0,-7.875 1.03125,0 0,7.875 -1.03125,0 z m 6.35127,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.046875 -0.3125,-0.671875 -0.3125,-1.546875 0,-0.859375 0.28125,-1.546875 0.29687,-0.703125 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.828125 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.640625 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.515625 0.4375,-0.515625 0.4375,-1.578125 0,-1.171875 -0.45313,-1.71875 -0.4375,-0.546875 -1.10937,-0.546875 -0.64063,0 -1.07813,0.53125 -0.42187,0.515625 -0.42187,1.65625 z m 5.25462,2.84375 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.359375 -0.64062,0.484375 -1.625,0.484375 -1.25,0 -1.98437,-0.765625 -0.73438,-0.765625 -0.73438,-2.15625 0,-1.453125 0.73438,-2.234375 0.75,-0.796875 1.92187,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.078125 -0.46875,-0.546875 -1.20312,-0.546875 -0.67188,0 -1.125,0.453125 -0.45313,0.4375 -0.5,1.171875 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path81"
-     d="M 161.28018,281.94882 91.23294,243.08267" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path83"
-     d="M 156.03368,279.03778 96.47945,245.99373" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path85"
-     d="m 155.2323,280.48206 4.76958,0.75748 -3.16681,-3.64606 z" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path87"
-     d="m 97.28082,244.54942 -4.769569,-0.75746 3.166809,3.64607 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path89"
-     d="m 231.32742,243.08267 -70.04724,38.86615" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path91"
-     d="m 226.08093,245.99373 -59.55425,33.04405" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path93"
-     d="m 226.88231,247.43803 3.16681,-3.64607 -4.76958,0.75746 z" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path95"
-     d="m 165.72531,277.59348 -3.16681,3.64606 4.76956,-0.75748 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path97"
-     d="m 143.2874,223.08005 36,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path99"
-     d="m 149.2874,223.08005 24,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path101"
-     d="m 149.2874,221.42831 -4.5381,1.65173 4.5381,1.65174 z" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path103"
-     d="m 173.2874,224.73178 4.5381,-1.65173 -4.5381,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path105"
-     d="M 161.28018,164.20866 91.23294,203.07479" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path107"
-     d="M 161.28018,164.20866 96.479445,200.16375" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path109"
-     d="m 95.67806,198.71945 -3.166809,3.64607 4.769569,-0.75747 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path111"
-     d="m 161.2664,57.67979 0.0138,66.52887" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path113"
-     d="m 161.2664,57.67979 0.0125,60.52887" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path115"
-     d="m 159.62721,118.20901 1.65266,4.53775 1.65081,-4.53844 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path117"
-     d="m 185.83202,73.16798 160.59843,0 0,20.97638 -160.59843,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path119"
-     d="m 195.17577,79.39304 0.95312,-0.15625 q 0.0781,0.578125 0.4375,0.890625 0.375,0.296875 1.03125,0.296875 0.67188,0 0.98438,-0.265625 0.32812,-0.265625 0.32812,-0.640625 0,-0.328125 -0.28125,-0.515625 -0.20312,-0.125 -0.98437,-0.328125 -1.0625,-0.265625 -1.48438,-0.453125 -0.40625,-0.203125 -0.625,-0.546875 -0.20312,-0.34375 -0.20312,-0.765625 0,-0.390625 0.17187,-0.703125 0.17188,-0.328125 0.48438,-0.546875 0.21875,-0.171875 0.60937,-0.28125 0.39063,-0.109375 0.82813,-0.109375 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.328125 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.671875 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.515625 0,0.1875 0.10937,0.328125 0.125,0.15625 0.375,0.265625 0.14063,0.04687 0.85938,0.25 1.01562,0.265625 1.42187,0.4375 0.40625,0.171875 0.64063,0.515625 0.23437,0.328125 0.23437,0.828125 0,0.484375 -0.28125,0.90625 -0.28125,0.421875 -0.8125,0.65625 -0.53125,0.234375 -1.20312,0.234375 -1.10938,0 -1.70313,-0.453125 -0.57812,-0.46875 -0.73437,-1.375 z m 7.82812,0.84375 0.125,0.84375 q -0.40625,0.09375 -0.71875,0.09375 -0.53125,0 -0.82812,-0.171875 -0.28125,-0.171875 -0.40625,-0.4375 -0.10938,-0.265625 -0.10938,-1.140625 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.109375 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.03125 z m 0.47628,-2 q 0,-1.578125 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.765625 -0.73437,-0.765625 -0.73437,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48437,-0.546875 0.48437,-1.671875 0,-1.046875 -0.48437,-1.59375 -0.48438,-0.546875 -1.1875,-0.546875 -0.73438,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 5.28587,5.046875 0,-7.890625 0.89063,0 0,0.734375 q 0.3125,-0.421875 0.70312,-0.640625 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.671875 0.28125,1.5 0,0.875 -0.3125,1.578125 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.203125 -0.375,-0.203125 -0.625,-0.515625 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.515625 1.07812,0.515625 0.64063,0 1.09375,-0.53125 0.46875,-0.546875 0.46875,-1.703125 0,-1.078125 -0.45312,-1.625 -0.4375,-0.546875 -1.0625,-0.546875 -0.625,0 -1.10938,0.578125 -0.46875,0.578125 -0.46875,1.6875 z m 6.91087,5.125 q -0.8125,-1 -1.35937,-2.359375 -0.54688,-1.359375 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.015625 0,2.578125 1.60937,5.15625 l -0.6875,0 z m 2.32987,0 -0.6875,0 q 1.59375,-2.578125 1.59375,-5.15625 0,-1.015625 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.453125 -0.5625,2.8125 -0.54688,1.359375 -1.34375,2.359375 z m 5.50926,-5.171875 q 0,-1.578125 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.765625 -0.73438,-0.765625 -0.73438,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48438,-0.546875 0.48438,-1.671875 0,-1.046875 -0.48438,-1.59375 -0.48437,-0.546875 -1.1875,-0.546875 -0.73437,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 5.28587,2.859375 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 6.60302,0 0,-7.875 1.03125,0 0,6.953125 3.875,0 0,0.921875 -4.90625,0 z m 5.84837,-6.765625 0,-1.109375 0.96875,0 0,1.109375 -0.96875,0 z m 0,6.765625 0,-5.703125 0.96875,0 0,5.703125 -0.96875,0 z m 1.97685,-1.703125 0.95313,-0.15625 q 0.0781,0.578125 0.4375,0.890625 0.375,0.296875 1.03125,0.296875 0.67187,0 0.98437,-0.265625 0.32813,-0.265625 0.32813,-0.640625 0,-0.328125 -0.28125,-0.515625 -0.20313,-0.125 -0.98438,-0.328125 -1.0625,-0.265625 -1.48437,-0.453125 -0.40625,-0.203125 -0.625,-0.546875 -0.20313,-0.34375 -0.20313,-0.765625 0,-0.390625 0.17188,-0.703125 0.17187,-0.328125 0.48437,-0.546875 0.21875,-0.171875 0.60938,-0.28125 0.39062,-0.109375 0.82812,-0.109375 0.67188,0 1.17188,0.1875 0.51562,0.1875 0.75,0.53125 0.25,0.328125 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39063,-0.671875 -0.29687,-0.25 -0.85937,-0.25 -0.67188,0 -0.95313,0.21875 -0.28125,0.21875 -0.28125,0.515625 0,0.1875 0.10938,0.328125 0.125,0.15625 0.375,0.265625 0.14062,0.04687 0.85937,0.25 1.01563,0.265625 1.42188,0.4375 0.40625,0.171875 0.64062,0.515625 0.23438,0.328125 0.23438,0.828125 0,0.484375 -0.28125,0.90625 -0.28125,0.421875 -0.8125,0.65625 -0.53125,0.234375 -1.20313,0.234375 -1.10937,0 -1.70312,-0.453125 -0.57813,-0.46875 -0.73438,-1.375 z m 7.82813,0.84375 0.125,0.84375 q -0.40625,0.09375 -0.71875,0.09375 -0.53125,0 -0.82813,-0.171875 -0.28125,-0.171875 -0.40625,-0.4375 -0.10937,-0.265625 -0.10937,-1.140625 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.109375 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.03125 z m 4.74189,-0.984375 1,0.125 q -0.23437,0.875 -0.875,1.359375 -0.64062,0.484375 -1.625,0.484375 -1.25,0 -1.98437,-0.765625 -0.73438,-0.765625 -0.73438,-2.15625 0,-1.453125 0.73438,-2.234375 0.75,-0.796875 1.92187,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.078125 -0.46875,-0.546875 -1.20312,-0.546875 -0.67188,0 -1.125,0.453125 -0.45313,0.4375 -0.5,1.171875 z m 5.19214,3.40625 0,-5.703125 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.171875 0.64063,0.484375 0.21875,0.296875 0.3125,0.703125 0.0469,0.28125 0.0469,0.953125 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.296875 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.390625 -0.45312,0.390625 -0.45312,1.5 l 0,3.109375 -0.96875,0 z m 9.83273,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.359375 -0.64062,0.484375 -1.625,0.484375 -1.25,0 -1.98437,-0.765625 -0.73438,-0.765625 -0.73438,-2.15625 0,-1.453125 0.73438,-2.234375 0.75,-0.796875 1.92187,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.078125 -0.46875,-0.546875 -1.20312,-0.546875 -0.67188,0 -1.125,0.453125 -0.45313,0.4375 -0.5,1.171875 z m 5.19214,3.40625 0,-5.703125 0.85937,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.890625 q -0.35937,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 3.82986,0 0,-1.09375 1.09375,0 0,1.09375 -1.09375,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path121"
-     d="m 195.19139,91.0368 q 0,-1.578125 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.765625 -0.73437,-0.765625 -0.73437,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48437,-0.546875 0.48437,-1.671875 0,-1.046875 -0.48437,-1.59375 -0.48438,-0.546875 -1.1875,-0.546875 -0.73438,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 5.28587,2.859375 0,-5.703125 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.171875 0.64062,0.484375 0.21875,0.296875 0.3125,0.703125 0.0469,0.28125 0.0469,0.953125 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.296875 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.390625 -0.45313,0.390625 -0.45313,1.5 l 0,3.109375 -0.96875,0 z m 6.08275,0 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35938,0 0,0.921875 -4.35938,0 0,2.6875 4.84375,0 0,0.921875 -5.875,0 z m 6.31076,0 2.09375,-2.96875 -1.9375,-2.734375 1.20313,0 0.89062,1.34375 q 0.23438,0.375 0.39063,0.625 0.23437,-0.34375 0.4375,-0.625 l 0.95312,-1.34375 1.15625,0 -1.96875,2.6875 2.125,3.015625 -1.1875,0 -1.17187,-1.765625 -0.3125,-0.484375 -1.5,2.25 -1.17188,0 z m 5.60938,-2.859375 q 0,-1.578125 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.765625 -0.73437,-0.765625 -0.73437,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48437,-0.546875 0.48437,-1.671875 0,-1.046875 -0.48437,-1.59375 -0.48438,-0.546875 -1.1875,-0.546875 -0.73438,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 5.41087,2.859375 0,-7.875 2.96875,0 q 0.79688,0 1.20313,0.07813 0.57812,0.09375 0.96875,0.375 0.39062,0.265625 0.625,0.75 0.25,0.484375 0.25,1.078125 0,1 -0.64063,1.703125 -0.64062,0.6875 -2.3125,0.6875 l -2.01562,0 0,3.203125 -1.04688,0 z m 1.04688,-4.125 2.03125,0 q 1.01562,0 1.4375,-0.375 0.42187,-0.375 0.42187,-1.0625 0,-0.5 -0.25,-0.84375 -0.25,-0.359375 -0.65625,-0.46875 -0.26562,-0.0625 -0.96875,-0.0625 l -2.01562,0 0,2.8125 z m 5.92013,4.125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.11748,-0.703125 q -0.54688,0.453125 -1.04688,0.640625 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.453125 -0.5,-0.46875 -0.5,-1.171875 0,-0.421875 0.1875,-0.765625 0.20312,-0.34375 0.5,-0.546875 0.3125,-0.21875 0.70312,-0.328125 0.28125,-0.07813 0.85938,-0.140625 1.17187,-0.140625 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.828125 -0.35937,-0.328125 -1.09375,-0.328125 -0.6875,0 -1.01562,0.234375 -0.3125,0.234375 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.609375 0.42188,-0.984375 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.203125 1.29688,-0.203125 0.73437,0 1.1875,0.171875 0.45312,0.171875 0.65625,0.4375 0.21875,0.25 0.3125,0.640625 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.703125 0.0625,0.359375 0.25,0.6875 l -1.01562,0 q -0.15625,-0.296875 -0.1875,-0.703125 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.359375 -0.59375,0.09375 -0.84375,0.203125 -0.23437,0.09375 -0.375,0.3125 -0.14062,0.203125 -0.14062,0.453125 0,0.390625 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.671875 0.14063,-0.328125 0.14063,-0.96875 l 0,-0.34375 z m 2.25462,5.0625 -0.10937,-0.90625 q 0.3125,0.07813 0.54687,0.07813 0.32813,0 0.51563,-0.109375 0.20312,-0.109375 0.3125,-0.296875 0.0937,-0.140625 0.29687,-0.71875 0.0312,-0.07813 0.0937,-0.234375 l -2.17187,-5.71875 1.04687,0 1.1875,3.296875 q 0.23438,0.640625 0.40625,1.328125 0.17188,-0.671875 0.40625,-1.296875 l 1.21875,-3.328125 0.96875,0 -2.17187,5.796875 q -0.34375,0.9375 -0.54688,1.296875 -0.25,0.484375 -0.59375,0.703125 -0.32812,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.109375 z m 9.26563,-4.046875 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19213,3.40625 0,-5.703125 0.85937,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.890625 q -0.35937,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 3.70488,0 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35937,0 0,0.921875 -4.35937,0 0,2.6875 4.84375,0 0,0.921875 -5.875,0 z m 6.95138,0 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 3.54862,0 0,-5.703125 0.85937,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.890625 q -0.35937,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 3.18923,-2.859375 q 0,-1.578125 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.765625 -0.73438,-0.765625 -0.73438,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48438,-0.546875 0.48438,-1.671875 0,-1.046875 -0.48438,-1.59375 -0.48437,-0.546875 -1.1875,-0.546875 -0.73437,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 5.28586,2.859375 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 5.40799,2.3125 q -0.8125,-1 -1.35937,-2.359375 -0.54688,-1.359375 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.015625 0,2.578125 1.60937,5.15625 l -0.6875,0 z m 2.32987,0 -0.6875,0 q 1.59375,-2.578125 1.59375,-5.15625 0,-1.015625 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.453125 -0.5625,2.8125 -0.54688,1.359375 -1.34375,2.359375 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path123"
-     d="m 161.28018,164.20866 70.04724,38.86613" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path125"
-     d="m 161.28018,164.20866 64.80075,35.95509" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path127"
-     d="m 225.27954,201.60805 4.76958,0.75748 -3.16681,-3.64608 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path129"
-     d="m 185.8307,58.805775 0,49.700785" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path131"
-     d="m 185.8307,64.80577 0,43.70079" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path133"
-     d="m 187.48244,64.80577 -1.65173,-4.538094 -1.65174,4.538094 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path135"
-     d="m 109.23491,387.4857 0,0 c 0,-3.68198 2.98483,-6.66678 6.6668,-6.66678 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95264 1.25027,1.25027 1.95267,2.94601 1.95267,4.71414 l 0,26.66641 c 0,3.68198 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98483 -6.6668,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path137"
-     d="m 109.23491,387.4857 0,0 c 0,-3.68198 2.98483,-6.66678 6.6668,-6.66678 l 90.72939,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95264 1.25027,1.25027 1.95267,2.94601 1.95267,4.71414 l 0,26.66641 c 0,3.68198 -2.98484,6.66681 -6.6668,6.66681 l -90.72939,0 0,0 c -3.68198,0 -6.6668,-2.98483 -6.6668,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path139"
-     d="m 139.61392,404.6589 0,-7.875 3.5,0 q 1.04687,0 1.59375,0.21875 0.54687,0.20313 0.875,0.75 0.32812,0.53125 0.32812,1.1875 0,0.82813 -0.54687,1.40625 -0.53125,0.57813 -1.67188,0.73438 0.42188,0.1875 0.625,0.39062 0.46875,0.42188 0.875,1.04688 l 1.35938,2.14062 -1.29688,0 -1.04687,-1.64062 q -0.45313,-0.70313 -0.75,-1.07813 -0.29688,-0.375 -0.53125,-0.53125 -0.23438,-0.15625 -0.46875,-0.20312 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20313,0 0,3.5 -1.04687,0 z m 1.04687,-4.40625 2.23438,0 q 0.71875,0 1.125,-0.14062 0.40625,-0.14063 0.60937,-0.46875 0.20313,-0.32813 0.20313,-0.70313 0,-0.5625 -0.40625,-0.92187 -0.39063,-0.35938 -1.26563,-0.35938 l -2.5,0 0,2.59375 z m 10.41436,2.5625 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.1765,3.40625 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.9265,2.70313 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 1.91087,1.15625 0.95312,-0.15625 q 0.0781,0.57812 0.4375,0.89062 0.375,0.29688 1.03125,0.29688 0.67188,0 0.98438,-0.26563 0.32812,-0.26562 0.32812,-0.64062 0,-0.32813 -0.28125,-0.51563 -0.20312,-0.125 -0.98437,-0.32812 -1.0625,-0.26563 -1.48438,-0.45313 -0.40625,-0.20312 -0.625,-0.54687 -0.20312,-0.34375 -0.20312,-0.76563 0,-0.39062 0.17187,-0.70312 0.17188,-0.32813 0.48438,-0.54688 0.21875,-0.17187 0.60937,-0.28125 0.39063,-0.10937 0.82813,-0.10937 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32812 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67188 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51563 0,0.1875 0.10937,0.32812 0.125,0.15625 0.375,0.26563 0.14063,0.0469 0.85938,0.25 1.01562,0.26562 1.42187,0.4375 0.40625,0.17187 0.64063,0.51562 0.23437,0.32813 0.23437,0.82813 0,0.48437 -0.28125,0.90625 -0.28125,0.42187 -0.8125,0.65625 -0.53125,0.23437 -1.20312,0.23437 -1.10938,0 -1.70313,-0.45312 -0.57812,-0.46875 -0.73437,-1.375 z m 9.60937,-0.14063 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.89525,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path141"
-     d="m 161.2664,335.2126 0,45.60632" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path143"
-     d="m 161.2664,335.2126 0,39.60632" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path145"
-     d="m 159.61467,374.8189 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path147"
-     d="m 60.16229,352.77692 0,0 C 48.725519,352.7753 37.7679,347.92591 29.746772,339.31629 21.725644,330.70664 17.312257,319.05726 17.496345,306.98056 l 42.67164,0.72547 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path149"
-     d="m 60.16229,352.77692 0,0 C 48.725519,352.7753 37.7679,347.92591 29.746772,339.31629 21.725644,330.70664 17.312257,319.05726 17.496345,306.98056" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path151"
-     d="m 60.16229,352.77692 0,0 C 48.725519,352.7753 37.7679,347.92591 29.746772,339.31629 21.725644,330.70664 17.312257,319.05726 17.496345,306.98056" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path153"
-     d="m 60.16229,352.77692 101.10236,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path155"
-     d="m 60.16229,352.77692 101.10236,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path157"
-     d="m 109.23491,37.67979 -45.947765,0.0055" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path159"
-     d="m 109.23491,37.67979 -45.947765,0.0055" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path161"
-     d="m 17.490814,80.35127 0,0 c 0.0016,-11.436768 4.850988,-22.394386 13.460623,-30.415516 8.609636,-8.021126 20.259027,-12.434513 32.33571,-12.250427 l -0.725468,42.671635 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path163"
-     d="m 17.490814,80.35127 0,0 c 0.0016,-11.436768 4.850988,-22.394386 13.460623,-30.415516 8.609636,-8.021126 20.259027,-12.434513 32.33571,-12.250427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path165"
-     d="m 17.490814,80.35127 0,0 c 0.0016,-11.436768 4.850988,-22.394386 13.460623,-30.415516 8.609636,-8.021126 20.259027,-12.434513 32.33571,-12.250427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path167"
-     d="m 17.490814,80.35127 0.0055,226.62929" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path169"
-     d="m 17.490814,80.35127 0.0055,226.62929" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path171"
-     d="m 161.2664,347.52493 72.44095,0 0,20.97638 -72.44095,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path173"
-     d="m 170.98515,361.85312 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.1765,3.40625 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.92649,2.70312 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 1.91088,1.15625 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 9.60937,-0.14062 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 7.0515,5.71875 q -0.8125,-1 -1.35938,-2.35938 -0.54687,-1.35937 -0.54687,-2.8125 0,-1.26562 0.40625,-2.4375 0.48437,-1.35937 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85938,1.60938 -0.32812,0.73437 -0.51562,1.54687 -0.23438,1 -0.23438,2.01563 0,2.57812 1.60938,5.15625 l -0.6875,0 z m 2.32986,0 -0.6875,0 q 1.59375,-2.57813 1.59375,-5.15625 0,-1.01563 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.54688 -0.20312,-0.48437 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.35938 1.5,2.71875 0.40625,1.17188 0.40625,2.4375 0,1.45313 -0.5625,2.8125 -0.54688,1.35938 -1.34375,2.35938 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path175"
-     d="m 161.28018,164.20866 0,117.74016" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path177"
-     d="m 161.28018,164.20866 0,111.74016" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path179"
-     d="m 159.62845,275.94882 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path181"
-     d="m 791.1917,156.03404 0,0 c 0,-3.68198 2.9848,-6.66681 6.66675,-6.66681 l 104.02075,0 c 1.76813,0 3.46387,0.70239 4.71411,1.95267 1.2503,1.25026 1.9527,2.946 1.9527,4.71414 l 0,26.6664 c 0,3.68197 -2.98487,6.66679 -6.66681,6.66679 l -104.02075,0 c -3.68195,0 -6.66675,-2.98482 -6.66675,-6.66679 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path183"
-     d="m 791.1917,156.03404 0,0 c 0,-3.68198 2.9848,-6.66681 6.66675,-6.66681 l 104.02075,0 c 1.76813,0 3.46387,0.70239 4.71411,1.95267 1.2503,1.25026 1.9527,2.946 1.9527,4.71414 l 0,26.6664 c 0,3.68197 -2.98487,6.66679 -6.66681,6.66679 l -104.02075,0 c -3.68195,0 -6.66675,-2.98482 -6.66675,-6.66679 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path185"
-     d="m 817.19525,173.20724 0,-6.9375 -2.59375,0 0,-0.9375 6.23437,0 0,0.9375 -2.60937,0 0,6.9375 -1.03125,0 z m 4.36865,0 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.28296,-0.70312 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 6.02026,0.76562 0.9375,0.125 q -0.14062,0.98438 -0.79687,1.54688 -0.64063,0.54687 -1.5625,0.54687 -1.17188,0 -1.89063,-0.76562 -0.70312,-0.76563 -0.70312,-2.1875 0,-0.92188 0.29687,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.32812 l -0.95313,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82812,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45313,0.51563 -0.45313,1.64063 0,1.15625 0.4375,1.67187 0.4375,0.51563 1.15625,0.51563 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.07813 z m 1.60938,2.09375 0,-7.875 0.96875,0 0,4.48438 2.28125,-2.3125 1.25,0 -2.17188,2.10937 2.39063,3.59375 -1.1875,0 -1.89063,-2.92187 -0.67187,0.65625 0,2.26562 -0.96875,0 z m 5.45312,0 0,-7.875 3.5,0 q 1.04688,0 1.59375,0.21875 0.54688,0.20313 0.875,0.75 0.32813,0.53125 0.32813,1.1875 0,0.82813 -0.54688,1.40625 -0.53125,0.57813 -1.67187,0.73438 0.42187,0.1875 0.625,0.39062 0.46875,0.42188 0.875,1.04688 l 1.35937,2.14062 -1.29687,0 -1.04688,-1.64062 q -0.45312,-0.70313 -0.75,-1.07813 -0.29687,-0.375 -0.53125,-0.53125 -0.23437,-0.15625 -0.46875,-0.20312 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20312,0 0,3.5 -1.04688,0 z m 1.04688,-4.40625 2.23437,0 q 0.71875,0 1.125,-0.14062 0.40625,-0.14063 0.60938,-0.46875 0.20312,-0.32813 0.20312,-0.70313 0,-0.5625 -0.40625,-0.92187 -0.39062,-0.35938 -1.26562,-0.35938 l -2.5,0 0,2.59375 z m 10.41437,2.5625 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19208,3.40625 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17187 0.64062,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39063 -0.45313,0.39062 -0.45313,1.5 l 0,3.10937 -0.96875,0 z m 9.62964,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z m 9.17652,1 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19214,3.40625 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45484,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19214,3.40625 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89062 q -0.35937,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path187"
-     d="m 791.1917,59.845837 0,0 c 0,-3.681972 2.9848,-6.666801 6.66675,-6.666801 l 104.02075,0 c 1.76813,0 3.46387,0.702392 4.71411,1.952663 1.2503,1.250267 1.9527,2.945991 1.9527,4.714138 l 0,26.6664 c 0,3.681969 -2.98487,6.666801 -6.66681,6.666801 l -104.02075,0 c -3.68195,0 -6.66675,-2.984832 -6.66675,-6.666801 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path189"
-     d="m 791.1917,59.845837 0,0 c 0,-3.681972 2.9848,-6.666801 6.66675,-6.666801 l 104.02075,0 c 1.76813,0 3.46387,0.702392 4.71411,1.952663 1.2503,1.250267 1.9527,2.945991 1.9527,4.714138 l 0,26.6664 c 0,3.681969 -2.98487,6.666801 -6.66681,6.666801 l -104.02075,0 c -3.68195,0 -6.66675,-2.984832 -6.66675,-6.666801 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path191"
-     d="m 817.19525,77.019035 0,-6.9375 -2.59375,0 0,-0.9375 6.23437,0 0,0.9375 -2.60937,0 0,6.9375 -1.03125,0 z m 4.36865,0 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.28296,-0.703125 q -0.54687,0.453125 -1.04687,0.640625 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.453125 -0.5,-0.46875 -0.5,-1.171875 0,-0.421875 0.1875,-0.765625 0.20313,-0.34375 0.5,-0.546875 0.3125,-0.21875 0.70313,-0.328125 0.28125,-0.07813 0.85937,-0.140625 1.17188,-0.140625 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.828125 -0.35938,-0.328125 -1.09375,-0.328125 -0.6875,0 -1.01563,0.234375 -0.3125,0.234375 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.609375 0.42187,-0.984375 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.203125 1.29687,-0.203125 0.73438,0 1.1875,0.171875 0.45313,0.171875 0.65625,0.4375 0.21875,0.25 0.3125,0.640625 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.703125 0.0625,0.359375 0.25,0.6875 l -1.01563,0 q -0.15625,-0.296875 -0.1875,-0.703125 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.359375 -0.59375,0.09375 -0.84375,0.203125 -0.23438,0.09375 -0.375,0.3125 -0.14063,0.203125 -0.14063,0.453125 0,0.390625 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.671875 0.14062,-0.328125 0.14062,-0.96875 l 0,-0.34375 z m 6.02026,0.765625 0.9375,0.125 q -0.14062,0.984375 -0.79687,1.546875 -0.64063,0.546875 -1.5625,0.546875 -1.17188,0 -1.89063,-0.765625 -0.70312,-0.765625 -0.70312,-2.1875 0,-0.921875 0.29687,-1.609375 0.3125,-0.703125 0.9375,-1.046875 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.328125 l -0.95313,0.140625 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.296875 -0.82812,-0.296875 -0.71875,0 -1.1875,0.53125 -0.45313,0.515625 -0.45313,1.640625 0,1.15625 0.4375,1.671875 0.4375,0.515625 1.15625,0.515625 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.078125 z m 1.60938,2.09375 0,-7.875 0.96875,0 0,4.484375 2.28125,-2.3125 1.25,0 -2.17188,2.109375 2.39063,3.59375 -1.1875,0 -1.89063,-2.921875 -0.67187,0.65625 0,2.265625 -0.96875,0 z m 5.45312,0 0,-7.875 3.5,0 q 1.04688,0 1.59375,0.21875 0.54688,0.203125 0.875,0.75 0.32813,0.53125 0.32813,1.1875 0,0.828125 -0.54688,1.40625 -0.53125,0.578125 -1.67187,0.734375 0.42187,0.1875 0.625,0.390625 0.46875,0.421875 0.875,1.046875 l 1.35937,2.140625 -1.29687,0 -1.04688,-1.640625 q -0.45312,-0.703125 -0.75,-1.078125 -0.29687,-0.375 -0.53125,-0.53125 -0.23437,-0.15625 -0.46875,-0.203125 -0.1875,-0.04687 -0.59375,-0.04687 l -1.20312,0 0,3.5 -1.04688,0 z m 1.04688,-4.40625 2.23437,0 q 0.71875,0 1.125,-0.140625 0.40625,-0.140625 0.60938,-0.46875 0.20312,-0.328125 0.20312,-0.703125 0,-0.5625 -0.40625,-0.921875 -0.39062,-0.359375 -1.26562,-0.359375 l -2.5,0 0,2.59375 z m 10.41437,2.5625 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19208,3.40625 0,-5.703125 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.171875 0.64062,0.484375 0.21875,0.296875 0.3125,0.703125 0.0469,0.28125 0.0469,0.953125 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.296875 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.390625 -0.45313,0.390625 -0.45313,1.5 l 0,3.109375 -0.96875,0 z m 9.62964,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.046875 -0.3125,-0.671875 -0.3125,-1.546875 0,-0.859375 0.28125,-1.546875 0.29688,-0.703125 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.828125 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.640625 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.515625 0.4375,-0.515625 0.4375,-1.578125 0,-1.171875 -0.45312,-1.71875 -0.4375,-0.546875 -1.10938,-0.546875 -0.64062,0 -1.07812,0.53125 -0.42188,0.515625 -0.42188,1.65625 z m 9.17652,1 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19214,3.40625 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.45484,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19214,3.40625 0,-5.703125 0.85937,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.890625 q -0.35937,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path193"
-     d="m 400.31104,60.383472 0,0 c 0,-7.468315 6.05426,-13.522579 13.52258,-13.522579 l 54.08869,0 0,0 c 3.58642,0 7.02594,1.424694 9.56192,3.96067 2.53598,2.535977 3.96066,5.975498 3.96066,9.561909 l 0,121.899718 c 0,7.46833 -6.05426,13.52259 -13.52258,13.52259 l -54.08869,0 c -7.46832,0 -13.52258,-6.05426 -13.52258,-13.52259 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path195"
-     d="m 400.31104,60.383472 0,0 c 0,-7.468315 6.05426,-13.522579 13.52258,-13.522579 l 54.08869,0 0,0 c 3.58642,0 7.02594,1.424694 9.56192,3.96067 2.53598,2.535977 3.96066,5.975498 3.96066,9.561909 l 0,121.899718 c 0,7.46833 -6.05426,13.52259 -13.52258,13.52259 l -54.08869,0 c -7.46832,0 -13.52258,-6.05426 -13.52258,-13.52259 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path197"
-     d="m 414.79666,118.77333 3.03125,-7.875 1.10937,0 3.23438,7.875 -1.1875,0 -0.92188,-2.39062 -3.29687,0 -0.85938,2.39062 -1.10937,0 z m 2.26562,-3.23437 2.67188,0 -0.8125,-2.1875 q -0.375,-0.98438 -0.5625,-1.625 -0.15625,0.75 -0.42188,1.5 l -0.875,2.3125 z m 5.57639,5.42187 0,-7.89062 0.89063,0 0,0.73437 q 0.3125,-0.42187 0.70312,-0.64062 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.51563 1.07812,0.51563 0.64063,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45312,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10938,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.05151,5 0,-7.89062 0.89063,0 0,0.73437 q 0.3125,-0.42187 0.70312,-0.64062 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.51563 1.07812,0.51563 0.64063,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45312,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10938,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.03586,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 2.39874,-6.76562 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 6.08622,-2.09375 0.9375,0.125 q -0.14063,0.98438 -0.79688,1.54688 -0.64062,0.54687 -1.5625,0.54687 -1.17187,0 -1.89062,-0.76562 -0.70313,-0.76563 -0.70313,-2.1875 0,-0.92188 0.29688,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35937,-0.34375 0.92188,0 1.51563,0.46875 0.59375,0.46875 0.76562,1.32812 l -0.95312,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82813,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45312,0.51563 -0.45312,1.64063 0,1.15625 0.4375,1.67187 0.4375,0.51563 1.15625,0.51563 0.5625,0 0.9375,-0.34375 0.39062,-0.34375 0.5,-1.07813 z m 5.32812,1.39063 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 4.41089,2 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10938,-0.26562 -0.10938,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 0.85126,-5.90625 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 1.99249,-2.85937 q 0,-1.57813 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.76562 -0.73438,-0.76563 -0.73438,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.48438,-0.54687 0.48438,-1.67187 0,-1.04688 -0.48438,-1.59375 -0.48437,-0.54688 -1.1875,-0.54688 -0.73437,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.28586,2.85937 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path199"
-     d="m 433.77728,129.47958 0.9375,0.125 q -0.14062,0.98437 -0.79687,1.54687 -0.64063,0.54688 -1.5625,0.54688 -1.17188,0 -1.89063,-0.76563 -0.70312,-0.76562 -0.70312,-2.1875 0,-0.92188 0.29687,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.32812 l -0.95313,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82812,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45313,0.51563 -0.45313,1.64063 0,1.15625 0.4375,1.67188 0.4375,0.51562 1.15625,0.51562 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.07812 z m 1.23438,-0.76563 q 0,-1.57813 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76562 0.75,0.76563 0.75,2.12501 0,1.10937 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76563 -0.73437,-0.76562 -0.73437,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48437,-0.54688 0.48437,-1.67188 0,-1.04688 -0.48437,-1.59375 -0.48438,-0.54688 -1.1875,-0.54688 -0.73438,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 8.98898,2.85938 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.87501 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65626 z m 9.17652,1 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71876 -0.35937,-1.07813 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17188 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path201"
-     d="m 552.8373,71.68554 0,0 c 0,-13.710274 11.11438,-24.824646 24.82465,-24.824646 l 158.72864,0 c 6.58392,0 12.89819,2.615444 17.55371,7.270969 4.65551,4.655522 7.27093,10.969769 7.27093,17.553677 l 0,99.29559 c 0,13.71028 -11.11438,24.82464 -24.82464,24.82464 l -158.72864,0 c -13.71027,0 -24.82465,-11.11436 -24.82465,-24.82464 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path203"
-     d="m 552.8373,71.68554 0,0 c 0,-13.710274 11.11438,-24.824646 24.82465,-24.824646 l 158.72864,0 c 6.58392,0 12.89819,2.615444 17.55371,7.270969 4.65551,4.655522 7.27093,10.969769 7.27093,17.553677 l 0,99.29559 c 0,13.71028 -11.11438,24.82464 -24.82464,24.82464 l -158.72864,0 c -13.71027,0 -24.82465,-11.11436 -24.82465,-24.82464 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path205"
-     d="m 633.6177,125.17333 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35938,0 0,0.92188 -4.35938,0 0,2.6875 4.84375,0 0,0.92187 -5.875,0 z m 6.31079,0 2.09375,-2.96875 -1.9375,-2.73437 1.20313,0 0.89062,1.34375 q 0.23438,0.375 0.39063,0.625 0.23437,-0.34375 0.4375,-0.625 l 0.95312,-1.34375 1.15625,0 -1.96875,2.6875 2.125,3.01562 -1.1875,0 -1.17187,-1.76562 -0.3125,-0.48438 -1.5,2.25 -1.17188,0 z m 5.60938,-2.85937 q 0,-1.57813 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76562 -0.73437,-0.76563 -0.73437,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.48437,-0.54687 0.48437,-1.67187 0,-1.04688 -0.48437,-1.59375 -0.48438,-0.54688 -1.1875,-0.54688 -0.73438,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.41082,2.85937 0,-7.875 2.96875,0 q 0.79688,0 1.20313,0.0781 0.57812,0.0937 0.96875,0.375 0.39062,0.26562 0.625,0.75 0.25,0.48437 0.25,1.07812 0,1 -0.64063,1.70313 -0.64062,0.6875 -2.3125,0.6875 l -2.01562,0 0,3.20312 -1.04688,0 z m 1.04688,-4.125 2.03125,0 q 1.01562,0 1.4375,-0.375 0.42187,-0.375 0.42187,-1.0625 0,-0.5 -0.25,-0.84375 -0.25,-0.35937 -0.65625,-0.46875 -0.26562,-0.0625 -0.96875,-0.0625 l -2.01562,0 0,2.8125 z m 5.92016,4.125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.1175,-0.70312 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 2.25457,5.0625 -0.10937,-0.90625 q 0.3125,0.0781 0.54687,0.0781 0.32813,0 0.51563,-0.10937 0.20312,-0.10938 0.3125,-0.29688 0.0937,-0.14062 0.29687,-0.71875 0.0312,-0.0781 0.0937,-0.23437 l -2.17187,-5.71875 1.04687,0 1.1875,3.29687 q 0.23438,0.64063 0.40625,1.32813 0.17188,-0.67188 0.40625,-1.29688 l 1.21875,-3.32812 0.96875,0 -2.17187,5.79687 q -0.34375,0.9375 -0.54688,1.29688 -0.25,0.48437 -0.59375,0.70312 -0.32812,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10937 z m 9.26563,-4.04688 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19214,3.40625 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path207"
-     d="m 737.29395,174.75853 0,-104.314964" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path209"
-     d="m 737.29395,174.75853 0,-104.314964" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path211"
-     d="m 481.9907,78.17375 138.36221,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path213"
-     d="m 481.9907,78.17375 132.36221,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path215"
-     d="m 614.3529,79.825485 4.53809,-1.651733 -4.53809,-1.651734 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path217"
-     d="m 620.33905,166.78355 -137.88974,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path219"
-     d="m 620.33905,166.78355 -131.88974,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path221"
-     d="m 488.4493,165.13182 -4.53809,1.65173 4.53809,1.65172 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path223"
-     d="m 620.34906,158.51706 73.35437,0 0,16.53543 -73.35437,0 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path225"
-     d="m 620.34906,158.51706 73.35437,0 0,16.53543 -73.35437,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path227"
-     d="m 620.34906,166.78477 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path229"
-     d="m 620.34906,166.78477 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path231"
-     d="m 630.8294,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path233"
-     d="m 630.8294,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path235"
-     d="m 641.3097,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path237"
-     d="m 641.3097,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path239"
-     d="m 651.79004,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path241"
-     d="m 651.79004,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path243"
-     d="m 662.2703,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path245"
-     d="m 662.2703,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path247"
-     d="m 672.7507,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path249"
-     d="m 672.7507,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path251"
-     d="m 683.23096,175.08398 0,-16.59842" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path253"
-     d="m 683.23096,175.08398 0,-16.59842" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path255"
-     d="m 693.26245,78.173225 44.44098,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path257"
-     d="m 693.26245,78.173225 38.44098,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path259"
-     d="m 731.7034,79.82496 4.53809,-1.651733 -4.53809,-1.651726 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path261"
-     d="m 693.7034,166.78477 43.55902,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path263"
-     d="m 699.7034,166.78477 37.55902,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path265"
-     d="m 699.7034,165.13304 -4.53809,1.65173 4.53809,1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path267"
-     d="m 737.0007,70.249435 68.69287,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path269"
-     d="m 737.0007,70.249435 62.69287,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path271"
-     d="m 799.69354,71.90117 4.53815,-1.651733 -4.53815,-1.651734 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path273"
-     d="m 748.3015,81.73987 57.66931,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path275"
-     d="m 748.3015,81.73987 57.66931,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path277"
-     d="m 748.61945,163.19423 0,-81.44882" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path279"
-     d="m 748.61945,163.19423 0,-81.44882" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path281"
-     d="m 805.51447,81.74016 0,-11.370079" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path283"
-     d="m 805.51447,81.74016 0,-11.370079" />
-  <path
-     style="fill:#efefef;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path285"
-     d="m 582.449,148.87401 0,0 c -3.82697,0 -6.92926,-3.10234 -6.92926,-6.92926 l 0,-38.92886 c 0,-1.83776 0.73004,-3.600247 2.02948,-4.899739 1.2995,-1.299492 3.06201,-2.029541 4.89978,-2.029541 l 27.71625,0 c 3.8269,0 6.92926,3.102341 6.92926,6.92928 l 0,38.92886 0,0 c 0,3.82692 -3.10236,6.92926 -6.92926,6.92926 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path287"
-     d="m 582.449,148.87401 0,0 c -3.82697,0 -6.92926,-3.10234 -6.92926,-6.92926 l 0,-38.92886 c 0,-1.83776 0.73004,-3.600247 2.02948,-4.899739 1.2995,-1.299492 3.06201,-2.029541 4.89978,-2.029541 l 27.71625,0 c 3.8269,0 6.92926,3.102341 6.92926,6.92928 l 0,38.92886 0,0 c 0,3.82692 -3.10236,6.92926 -6.92926,6.92926 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path289"
-     d="m 598.444,133.68777 -0.15625,-0.95313 q 0.57812,-0.0781 0.89062,-0.4375 0.29688,-0.375 0.29688,-1.03125 0,-0.67187 -0.26563,-0.98437 -0.26562,-0.32813 -0.64062,-0.32813 -0.32813,0 -0.51563,0.28125 -0.125,0.20313 -0.32812,0.98438 -0.26563,1.0625 -0.45313,1.48437 -0.20312,0.40625 -0.54687,0.625 -0.34375,0.20313 -0.76563,0.20313 -0.39062,0 -0.70312,-0.17188 -0.32813,-0.17187 -0.54688,-0.48437 -0.17187,-0.21875 -0.28125,-0.60938 -0.10937,-0.39062 -0.10937,-0.82812 0,-0.67188 0.1875,-1.17188 0.1875,-0.51562 0.53125,-0.75 0.32812,-0.25 0.875,-0.34375 l 0.125,0.9375 q -0.4375,0.0781 -0.67188,0.39063 -0.25,0.29687 -0.25,0.85937 0,0.67188 0.21875,0.95313 0.21875,0.28125 0.51563,0.28125 0.1875,0 0.32812,-0.10938 0.15625,-0.125 0.26563,-0.375 0.0469,-0.14062 0.25,-0.85937 0.26562,-1.01563 0.4375,-1.42188 0.17187,-0.40625 0.51562,-0.64062 0.32813,-0.23438 0.82813,-0.23438 0.48437,0 0.90625,0.28125 0.42187,0.28125 0.65625,0.8125 0.23437,0.53125 0.23437,1.20313 0,1.10937 -0.45312,1.70312 -0.46875,0.57813 -1.375,0.73438 z m 0.84375,-7.82812 0.84375,-0.125 q 0.0937,0.40625 0.0937,0.71875 0,0.53125 -0.17188,0.82812 -0.17187,0.28125 -0.4375,0.40625 -0.26562,0.10938 -1.14062,0.10938 l -3.28125,0 0,0.71874 -0.75,0 0,-0.71874 -1.40625,0 -0.59375,-0.95313 2,0 0,-0.98437 0.75,0 0,0.98437 3.34375,0 q 0.40625,0 0.53125,-0.0469 0.10937,-0.0625 0.1875,-0.17188 0.0625,-0.125 0.0625,-0.32812 0,-0.17188 -0.0312,-0.4375 z m 0.15625,-4.57003 q 0.45312,0.54688 0.64062,1.04688 0.1875,0.48437 0.1875,1.0625 0,0.9375 -0.45312,1.45312 -0.46875,0.5 -1.17188,0.5 -0.42187,0 -0.76562,-0.1875 -0.34375,-0.20312 -0.54688,-0.5 -0.21875,-0.3125 -0.32812,-0.70312 -0.0781,-0.28125 -0.14063,-0.85938 -0.14062,-1.17187 -0.34375,-1.71875 -0.1875,-0.0156 -0.25,-0.0156 -0.59375,0 -0.82812,0.28125 -0.32813,0.35937 -0.32813,1.09375 0,0.6875 0.23438,1.01562 0.23437,0.3125 0.84375,0.46875 l -0.125,0.95313 q -0.60938,-0.125 -0.98438,-0.42188 -0.375,-0.29687 -0.5625,-0.85937 -0.20312,-0.5625 -0.20312,-1.29688 0,-0.73437 0.17187,-1.1875 0.17188,-0.45312 0.4375,-0.65625 0.25,-0.21875 0.64063,-0.3125 0.25,-0.0469 0.90625,-0.0469 l 1.28125,0 q 1.34375,0 1.70312,-0.0625 0.35938,-0.0625 0.6875,-0.25 l 0,1.01562 q -0.29687,0.15625 -0.70312,0.1875 z m -2.15625,0.0937 q 0.21875,0.51563 0.35937,1.57813 0.0937,0.59375 0.20313,0.84375 0.0937,0.23437 0.3125,0.375 0.20312,0.14062 0.45312,0.14062 0.39063,0 0.65625,-0.29687 0.25,-0.29688 0.25,-0.85938 0,-0.5625 -0.25,-0.98437 -0.25,-0.4375 -0.67187,-0.65625 -0.32813,-0.14063 -0.96875,-0.14063 l -0.34375,0 z m 2,-4.41087 0.84375,-0.125 q 0.0937,0.40625 0.0937,0.71875 0,0.53125 -0.17188,0.82812 -0.17187,0.28125 -0.4375,0.40625 -0.26562,0.10938 -1.14062,0.10938 l -3.28125,0 0,0.71875 -0.75,0 0,-0.71875 -1.40625,0 -0.59375,-0.95313 2,0 0,-0.98437 0.75,0 0,0.98437 3.34375,0 q 0.40625,0 0.53125,-0.0469 0.10937,-0.0625 0.1875,-0.17188 0.0625,-0.125 0.0625,-0.32812 0,-0.17188 -0.0312,-0.4375 z m -0.98438,-4.74191 0.125,-1 q 0.875,0.23438 1.35938,0.875 0.48437,0.64063 0.48437,1.625 0,1.25001 -0.76562,1.98439 -0.76563,0.73437 -2.15625,0.73437 -1.45313,0 -2.23438,-0.73437 -0.79687,-0.75 -0.79687,-1.92189 0,-1.15625 0.78125,-1.875 0.76562,-0.71875 2.1875,-0.71875 0.0781,0 0.25,0 l 0,4.25001 q 0.9375,-0.0469 1.4375,-0.51562 0.5,-0.48439 0.5,-1.20314 0,-0.53125 -0.26563,-0.90625 -0.28125,-0.375 -0.90625,-0.59375 z m -1.5625,3.17189 0,-3.18751 q -0.71875,0.0625 -1.07812,0.35937 -0.54688,0.46875 -0.54688,1.20313 0,0.67187 0.45313,1.12501 0.4375,0.45312 1.17187,0.5 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path291"
-     d="m 596.30707,78.543304 0,17.543304" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path293"
-     d="m 596.30707,78.543304 0,11.543312" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path295"
-     d="m 594.65533,90.08662 1.65173,4.538094 1.65174,-4.538094 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path297"
-     d="m 748.3015,163.6209 56.97638,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path299"
-     d="m 748.3015,163.6209 50.97638,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path301"
-     d="m 799.2779,165.27263 4.53809,-1.65173 -4.53809,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path303"
-     d="m 737.0007,175.11205 67.21259,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path305"
-     d="m 737.0007,175.11205 67.21259,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path307"
-     d="m 804.8084,175.11285 0,-11.37007" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path309"
-     d="m 804.8084,175.11285 0,-11.37007" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path311"
-     d="m 596.30707,148.87401 0,17.38583" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path313"
-     d="m 596.30707,154.87401 0,11.38583" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path315"
-     d="m 597.9588,154.87401 -1.65173,-4.53809 -1.65174,4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path317"
-     d="m 482.12927,115.52628 99.77954,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path319"
-     d="m 482.12927,115.52628 93.77954,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path321"
-     d="m 575.9088,117.17801 4.53809,-1.65173 -4.53809,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path323"
-     d="m 483.159,127.01527 98.77167,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path325"
-     d="m 483.159,127.01527 98.77167,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path327"
-     d="m 581.92914,127.01837 0,-11.37008" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path329"
-     d="m 581.92914,127.01837 0,-11.37008" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path331"
-     d="m 480.39108,89.57218 72.44095,0 0,26.04724 -72.44095,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path333"
-     d="m 504.1295,104.52818 0.9375,0.14062 q 0.0625,0.4375 0.32812,0.64063 0.35938,0.26562 0.98438,0.26562 0.67187,0 1.03125,-0.26562 0.375,-0.26563 0.5,-0.75 0.0781,-0.29688 0.0781,-1.25 -0.64062,0.75 -1.59375,0.75 -1.17187,0 -1.8125,-0.84375 -0.64062,-0.85938 -0.64062,-2.04688 0,-0.8125 0.29687,-1.5 0.29688,-0.6875 0.84375,-1.0625 0.5625,-0.375 1.32813,-0.375 1,0 1.65625,0.8125 l 0,-0.6875 0.89062,0 0,4.92188 q 0,1.34375 -0.26562,1.89062 -0.26563,0.5625 -0.85938,0.875 -0.59375,0.32813 -1.45312,0.32813 -1.01563,0 -1.64063,-0.46875 -0.625,-0.45313 -0.60937,-1.375 z m 0.79687,-3.42188 q 0,1.125 0.4375,1.64063 0.45313,0.51562 1.125,0.51562 0.67188,0 1.125,-0.51562 0.45313,-0.51563 0.45313,-1.60938 0,-1.04687 -0.46875,-1.578125 -0.46875,-0.53125 -1.125,-0.53125 -0.64063,0 -1.09375,0.53125 -0.45313,0.515625 -0.45313,1.546875 z m 9.20774,1.10938 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.24997,0 -1.98435,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92185,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.0781 0,0.25 l -4.24997,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.2031,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17185,-1.5625 3.18747,0 q -0.0625,-0.718755 -0.35937,-1.07813 -0.46875,-0.546875 -1.20313,-0.546875 -0.67184,0 -1.12497,0.453125 -0.45312,0.4375 -0.5,1.17188 z m 7.31711,2.54687 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 0.46063,-5.5625 0.25,-0.765625 q 0.84375,0.296875 1.23438,0.515625 -0.0937,-0.96875 -0.10938,-1.34375 l 0.78125,0 q -0.0156,0.53125 -0.125,1.34375 0.5625,-0.28125 1.26563,-0.515625 l 0.25,0.765625 q -0.67188,0.21875 -1.32813,0.296875 0.32813,0.28125 0.92188,1.015625 L 521.24,99.403175 q -0.3125,-0.421875 -0.75,-1.15625 -0.39062,0.765625 -0.6875,1.15625 l -0.64062,-0.453125 q 0.625,-0.765625 0.89062,-1.015625 Q 519.365,97.7938 518.74,97.63755 z m 6.38141,8.73438 q -0.8125,-1 -1.35937,-2.35938 -0.54688,-1.35937 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.01563 0,2.57812 1.60937,5.15625 l -0.6875,0 z m 2.32984,0 -0.6875,0 q 1.59375,-2.57813 1.59375,-5.15625 0,-1.01563 -0.21875,-2.000005 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.45313 -0.5625,2.8125 -0.54688,1.35938 -1.34375,2.35938 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path335"
-     d="m 481.76117,32.569553 73.35431,0 0,45.606304 -73.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path337"
-     d="m 497.2436,43.203358 0,-7.890625 0.89063,0 0,0.734375 q 0.3125,-0.421875 0.70312,-0.640625 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.671875 0.28125,1.5 0,0.875 -0.3125,1.578125 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.203125 -0.375,-0.203125 -0.625,-0.515625 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.515625 1.07812,0.515625 0.64063,0 1.09375,-0.53125 0.46875,-0.546875 0.46875,-1.703125 0,-1.078125 -0.45312,-1.625 -0.4375,-0.546875 -1.0625,-0.546875 -0.625,0 -1.10938,0.578125 -0.46875,0.578125 -0.46875,1.6875 z m 5.05151,2.8125 0,-5.703125 0.85938,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.890625 q -0.35938,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.19211,5.59375 0,-7.890625 0.89063,0 0,0.734375 q 0.3125,-0.421875 0.70312,-0.640625 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.671875 0.28125,1.5 0,0.875 -0.3125,1.578125 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.203125 -0.375,-0.203125 -0.625,-0.515625 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.515625 1.07812,0.515625 0.64063,0 1.09375,-0.53125 0.46875,-0.546875 0.46875,-1.703125 0,-1.078125 -0.45312,-1.625 -0.4375,-0.546875 -1.0625,-0.546875 -0.625,0 -1.10938,0.578125 -0.46875,0.578125 -0.46875,1.6875 z m 8.78589,2.109375 q -0.54687,0.453125 -1.04687,0.640625 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.453125 -0.5,-0.46875 -0.5,-1.171875 0,-0.421875 0.1875,-0.765625 0.20313,-0.34375 0.5,-0.546875 0.3125,-0.21875 0.70313,-0.328125 0.28125,-0.07813 0.85937,-0.140625 1.17188,-0.140625 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.828125 -0.35938,-0.328125 -1.09375,-0.328125 -0.6875,0 -1.01563,0.234375 -0.3125,0.234375 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.609375 0.42187,-0.984375 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.203125 1.29687,-0.203125 0.73438,0 1.1875,0.171875 0.45313,0.171875 0.65625,0.4375 0.21875,0.25 0.3125,0.640625 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.703125 0.0625,0.359375 0.25,0.6875 l -1.01563,0 q -0.15625,-0.296875 -0.1875,-0.703125 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.359375 -0.59375,0.09375 -0.84375,0.203125 -0.23438,0.09375 -0.375,0.3125 -0.14063,0.203125 -0.14063,0.453125 0,0.390625 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.671875 0.14062,-0.328125 0.14062,-0.96875 l 0,-0.34375 z m 2.28589,2.859375 0,-5.703125 0.85937,0 0,0.859375 q 0.34375,-0.609375 0.625,-0.796875 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.890625 q -0.35937,-0.203125 -0.71875,-0.203125 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.515625 -0.15625,1.125 l 0,2.984375 -0.96875,0 z m 7.45483,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.359375 -0.64062,0.484375 -1.625,0.484375 -1.25,0 -1.98437,-0.765625 -0.73438,-0.765625 -0.73438,-2.15625 0,-1.453125 0.73438,-2.234375 0.75,-0.796875 1.92187,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.078125 -0.46875,-0.546875 -1.20312,-0.546875 -0.67188,0 -1.125,0.453125 -0.45313,0.4375 -0.5,1.171875 z m 7.05151,5.71875 q -0.8125,-1 -1.35937,-2.359375 -0.54688,-1.359375 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.015625 0,2.578125 1.60937,5.15625 l -0.6875,0 z m 2.32984,0 -0.6875,0 q 1.59375,-2.578125 1.59375,-5.15625 0,-1.015625 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.453125 -0.5625,2.8125 -0.54688,1.359375 -1.34375,2.359375 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path339"
-     d="m 497.76096,52.112732 0.95312,-0.15625 q 0.0781,0.578125 0.4375,0.890625 0.375,0.296875 1.03125,0.296875 0.67188,0 0.98438,-0.265625 0.32812,-0.265625 0.32812,-0.640625 0,-0.328125 -0.28125,-0.515625 -0.20312,-0.125 -0.98437,-0.328125 -1.0625,-0.265625 -1.48438,-0.453125 -0.40625,-0.203125 -0.625,-0.546875 -0.20312,-0.34375 -0.20312,-0.765625 0,-0.390625 0.17187,-0.703125 0.17188,-0.328125 0.48438,-0.546875 0.21875,-0.171875 0.60937,-0.28125 0.39063,-0.109375 0.82813,-0.109375 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.328125 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.671875 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.515625 0,0.1875 0.10937,0.328125 0.125,0.15625 0.375,0.265625 0.14063,0.04687 0.85938,0.25 1.01562,0.265625 1.42187,0.4375 0.40625,0.171875 0.64063,0.515625 0.23437,0.328125 0.23437,0.828125 0,0.484375 -0.28125,0.90625 -0.28125,0.421875 -0.8125,0.65625 -0.53125,0.234375 -1.20312,0.234375 -1.10938,0 -1.70313,-0.453125 -0.57812,-0.46875 -0.73437,-1.375 z m 9.60937,-0.140625 1,0.125 q -0.23437,0.875 -0.875,1.359375 -0.64062,0.484375 -1.625,0.484375 -1.25,0 -1.98437,-0.765625 -0.73438,-0.765625 -0.73438,-2.15625 0,-1.453125 0.73438,-2.234375 0.75,-0.796875 1.92187,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.078125 -0.46875,-0.546875 -1.20312,-0.546875 -0.67188,0 -1.125,0.453125 -0.45313,0.4375 -0.5,1.171875 z m 9.09836,1.5625 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.15625 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 5.20777,3.40625 0,-7.875 0.96875,0 0,4.484375 2.28125,-2.3125 1.25,0 -2.17188,2.109375 2.39063,3.59375 -1.1875,0 -1.89063,-2.921875 -0.67187,0.65625 0,2.265625 -0.96875,0 z m 7.45312,0 0,-6.9375 -2.59375,0 0,-0.9375 6.23438,0 0,0.9375 -2.60938,0 0,6.9375 -1.03125,0 z m 4.00928,-2.859375 q 0,-1.578125 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.765625 0.75,0.765625 0.75,2.125 0,1.109375 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.765625 -0.73437,-0.765625 -0.73437,-2.21875 z m 1,0 q 0,1.109375 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.546875 0.48437,-0.546875 0.48437,-1.671875 0,-1.046875 -0.48437,-1.59375 -0.48438,-0.546875 -1.1875,-0.546875 -0.73438,0 -1.21875,0.546875 -0.46875,0.53125 -0.46875,1.625 z m 7.1452,5.171875 q -0.8125,-1 -1.35937,-2.359375 -0.54688,-1.359375 -0.54688,-2.8125 0,-1.265625 0.40625,-2.4375 0.48438,-1.359375 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85937,1.609375 -0.32813,0.734375 -0.51563,1.546875 -0.23437,1 -0.23437,2.015625 0,2.578125 1.60937,5.15625 l -0.6875,0 z m 2.3299,0 -0.6875,0 q 1.59375,-2.578125 1.59375,-5.15625 0,-1.015625 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.546875 -0.20312,-0.484375 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.359375 1.5,2.71875 0.40625,1.171875 0.40625,2.4375 0,1.453125 -0.5625,2.8125 -0.54688,1.359375 -1.34375,2.359375 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path341"
-     d="m 511.5147,64.77211 1,0.125 q -0.23438,0.875 -0.875,1.359375 -0.64063,0.484375 -1.625,0.484375 -1.25,0 -1.98438,-0.765625 -0.73437,-0.765625 -0.73437,-2.156254 0,-1.453125 0.73437,-2.234375 0.75,-0.796875 1.92188,-0.796875 1.15625,0 1.875,0.78125 0.71875,0.765625 0.71875,2.1875 0,0.07813 0,0.250004 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.265625 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.562504 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.078125 -0.46875,-0.546875 -1.20313,-0.546875 -0.67187,0 -1.125,0.453125 -0.45312,0.4375 -0.5,1.171875 z m 7.31714,2.546879 0.125,0.84375 q -0.40625,0.09375 -0.71875,0.09375 -0.53125,0 -0.82812,-0.171875 -0.28125,-0.171875 -0.40625,-0.4375 -0.10938,-0.265625 -0.10938,-1.140625 l 0,-3.281254 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.343754 q 0,0.40625 0.0469,0.53125 0.0625,0.109375 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.03125 z m 4.57001,-1.234375 0.9375,0.125 q -0.14062,0.984375 -0.79687,1.546875 -0.64063,0.546875 -1.5625,0.546875 -1.17188,0 -1.89063,-0.765625 -0.70312,-0.765625 -0.70312,-2.187504 0,-0.921875 0.29687,-1.609375 0.3125,-0.703125 0.9375,-1.046875 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.328125 l -0.95313,0.140625 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.296875 -0.82812,-0.296875 -0.71875,0 -1.1875,0.53125 -0.45313,0.515625 -0.45313,1.640625 0,1.156254 0.4375,1.671879 0.4375,0.515625 1.15625,0.515625 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.078125 z m 1.875,2.09375 0,-1.09375 1.09375,0 0,1.09375 -1.09375,0 z m 2.96063,0 0,-1.09375 1.09375,0 0,1.09375 -1.09375,0 z m 2.9607,0 0,-1.09375 1.09375,0 0,1.09375 -1.09375,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path343"
-     d="m 475.08398,140.73753 85.35431,0 0,26.04724 -85.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path345"
-     d="m 492.5158,155.22478 0,-7.875 1.03125,0 0,6.95312 3.875,0 0,0.92188 -4.90625,0 z m 5.84836,-6.76563 0,-1.10937 0.96875,0 0,1.10937 -0.96875,0 z m 0,6.76563 0,-5.70313 0.96875,0 0,5.70313 -0.96875,0 z m 1.97687,-1.70313 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 7.82812,0.84375 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 4.74191,-0.98437 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.62503,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15628,0 1.87503,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25003,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90628,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.1719,-1.5625 3.18753,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20315,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.19211,3.40625 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 9.83276,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.19213,3.40625 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.82984,0 0,-1.09375 1.09375,0 0,1.09375 -1.09375,0 z m 2.30444,-6.42188 0.25,-0.76562 q 0.84375,0.29687 1.23438,0.51562 -0.0937,-0.96875 -0.10938,-1.34375 l 0.78125,0 q -0.0156,0.53125 -0.125,1.34375 0.5625,-0.28125 1.26563,-0.51562 l 0.25,0.76562 q -0.67188,0.21875 -1.32813,0.29688 0.32813,0.28125 0.92188,1.01562 l -0.64063,0.45313 q -0.3125,-0.42188 -0.75,-1.15625 -0.39062,0.76562 -0.6875,1.15625 l -0.64062,-0.45313 q 0.625,-0.76562 0.89062,-1.01562 -0.6875,-0.14063 -1.3125,-0.29688 z m 6.38135,8.73438 q -0.8125,-1 -1.35938,-2.35938 -0.54687,-1.35937 -0.54687,-2.8125 0,-1.26562 0.40625,-2.4375 0.48437,-1.35937 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85938,1.60938 -0.32812,0.73437 -0.51562,1.54687 -0.23438,1 -0.23438,2.01563 0,2.57812 1.60938,5.15625 l -0.6875,0 z m 2.32983,0 -0.6875,0 q 1.59375,-2.57813 1.59375,-5.15625 0,-1.01563 -0.21875,-2 -0.1875,-0.8125 -0.51562,-1.54688 -0.20313,-0.48437 -0.85938,-1.625 l 0.6875,0 q 1.01563,1.35938 1.5,2.71875 0.40625,1.17188 0.40625,2.4375 0,1.45313 -0.5625,2.8125 -0.54687,1.35938 -1.34375,2.35938 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path347"
-     d="m 620.34906,69.90551 73.35437,0 0,16.53543 -73.35437,0 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path349"
-     d="m 620.34906,69.90551 73.35437,0 0,16.53543 -73.35437,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path351"
-     d="m 620.34906,78.173225 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path353"
-     d="m 620.34906,78.173225 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path355"
-     d="m 630.8294,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path357"
-     d="m 630.8294,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path359"
-     d="m 683.23096,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path361"
-     d="m 683.23096,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path363"
-     d="m 672.7507,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path365"
-     d="m 672.7507,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path367"
-     d="m 662.2703,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path369"
-     d="m 662.2703,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path371"
-     d="m 651.79004,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path373"
-     d="m 651.79004,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path375"
-     d="m 641.3097,86.47244 0,-16.598427" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path377"
-     d="m 641.3097,86.47244 0,-16.598427" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path379"
-     d="m 382.00787,224.73491 256.4095,0 0,20.97638 -256.4095,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path381"
-     d="m 472.6027,238.35997 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 2.28586,5.04687 0,-7.89062 0.89062,0 0,0.73437 q 0.3125,-0.42187 0.70313,-0.64062 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51563 1.07813,0.51563 0.64062,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45313,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10937,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.05151,5 0,-7.89062 0.89063,0 0,0.73437 q 0.3125,-0.42187 0.70312,-0.64062 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.51563 1.07812,0.51563 0.64063,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45312,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10938,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.03586,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 2.39874,-6.76562 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 6.08621,-2.09375 0.9375,0.125 q -0.14062,0.98438 -0.79687,1.54688 -0.64063,0.54687 -1.5625,0.54687 -1.17188,0 -1.89063,-0.76562 -0.70312,-0.76563 -0.70312,-2.1875 0,-0.92188 0.29687,-1.60938 0.3125,-0.70312 0.9375,-1.04687 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.32812 l -0.95313,0.14063 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29688 -0.82812,-0.29688 -0.71875,0 -1.1875,0.53125 -0.45313,0.51563 -0.45313,1.64063 0,1.15625 0.4375,1.67187 0.4375,0.51563 1.15625,0.51563 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.07813 z m 5.32813,1.39063 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 4.41089,2 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10937,-0.26562 -0.10937,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.85126,-5.90625 0,-1.10938 0.96875,0 0,1.10938 -0.96875,0 z m 0,6.76562 0,-5.70312 0.96875,0 0,5.70312 -0.96875,0 z m 1.99249,-2.85937 q 0,-1.57813 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76562 -0.73437,-0.76563 -0.73437,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.48437,-0.54687 0.48437,-1.67187 0,-1.04688 -0.48437,-1.59375 -0.48438,-0.54688 -1.1875,-0.54688 -0.73438,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.28589,2.85937 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z m 11.01214,-0.85937 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10938,-0.26562 -0.10938,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 0.83564,0.85937 0,-7.875 0.96875,0 0,2.82813 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60937 -0.96875,0 0,-3.60937 q 0,-0.73438 -0.3125,-1.0625 -0.3125,-0.32813 -0.89063,-0.32813 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60938 -0.15625,0.375 -0.15625,1.04687 l 0,3.125 -0.96875,0 z m 5.92651,0 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89062 q -0.35937,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45483,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.92651,2.70313 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 5.98902,2.85937 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path383"
-     d="m 658.05774,224.73491 191.24408,0 0,20.97638 -191.24408,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path385"
-     d="m 716.7817,241.2506 0,-7.89063 0.89062,0 0,0.73438 q 0.3125,-0.42188 0.70313,-0.64063 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51562 1.07813,0.51562 0.64062,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.45313,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.10937,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 5.03589,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.11743,-0.70313 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 2.25464,5.0625 -0.10938,-0.90625 q 0.3125,0.0781 0.54688,0.0781 0.32812,0 0.51562,-0.10938 0.20313,-0.10937 0.3125,-0.29687 0.0937,-0.14063 0.29688,-0.71875 0.0312,-0.0781 0.0937,-0.23438 l -2.17188,-5.71875 1.04688,0 1.1875,3.29688 q 0.23437,0.64062 0.40625,1.32812 0.17187,-0.67187 0.40625,-1.29687 l 1.21875,-3.32813 0.96875,0 -2.17188,5.79688 q -0.34375,0.9375 -0.54687,1.29687 -0.25,0.48438 -0.59375,0.70313 -0.32813,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10938 z m 6.25,-2.20312 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76563 1.5625,-0.76563 0.53125,0 1,0.21875 0.46875,0.20313 0.76563,0.59375 0.3125,0.375 0.48437,0.92188 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26562 -0.71875,0.79688 -1.73437,0.79688 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89063 q 0,1.01563 0.28125,1.48438 0.45312,0.73437 1.23437,0.73437 0.625,0 1.07813,-0.54687 0.46875,-0.54688 0.46875,-1.64063 0,-1.10937 -0.4375,-1.64062 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54687 -0.45312,0.54688 -0.45312,1.59375 z m 8.77026,2.1875 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 6.02027,0.76563 0.9375,0.125 q -0.14063,0.98437 -0.79688,1.54687 -0.64062,0.54688 -1.5625,0.54688 -1.17187,0 -1.89062,-0.76563 -0.70313,-0.76562 -0.70313,-2.1875 0,-0.92187 0.29688,-1.60937 0.3125,-0.70313 0.9375,-1.04688 0.625,-0.34375 1.35937,-0.34375 0.92188,0 1.51563,0.46875 0.59375,0.46875 0.76562,1.32813 l -0.95312,0.14062 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29687 -0.82813,-0.29687 -0.71875,0 -1.1875,0.53125 -0.45312,0.51562 -0.45312,1.64062 0,1.15625 0.4375,1.67188 0.4375,0.51562 1.15625,0.51562 0.5625,0 0.9375,-0.34375 0.39062,-0.34375 0.5,-1.07812 z m 1.60937,2.09375 0,-7.875 0.96875,0 0,4.48437 2.28125,-2.3125 1.25,0 -2.17187,2.10938 2.39062,3.59375 -1.1875,0 -1.89062,-2.92188 -0.67188,0.65625 0,2.26563 -0.96875,0 z m 10.39813,-0.85938 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 0.83564,0.85938 0,-7.875 0.96875,0 0,2.82812 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60938 -0.96875,0 0,-3.60938 q 0,-0.73437 -0.3125,-1.0625 -0.3125,-0.32812 -0.89063,-0.32812 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60937 -0.15625,0.375 -0.15625,1.04688 l 0,3.125 -0.96875,0 z m 5.92651,0 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45483,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.92651,2.70312 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 5.98902,2.85938 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path387"
-     d="m 858.14435,232.60367 81.13385,0 0,20.97638 -81.13385,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path389"
-     d="m 872.47546,240.53186 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76563 1.5625,-0.76563 0.53125,0 1,0.21875 0.46875,0.20313 0.76563,0.59375 0.3125,0.375 0.48437,0.92188 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26562 -0.71875,0.79688 -1.73437,0.79688 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89063 q 0,1.01563 0.28125,1.48438 0.45312,0.73437 1.23437,0.73437 0.625,0 1.07813,-0.54687 0.46875,-0.54688 0.46875,-1.64063 0,-1.10937 -0.4375,-1.64062 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54687 -0.45312,0.54688 -0.45312,1.59375 z m 8.77026,2.1875 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 6.02027,0.76563 0.9375,0.125 q -0.14063,0.98437 -0.79688,1.54687 -0.64062,0.54688 -1.5625,0.54688 -1.17187,0 -1.89062,-0.76563 -0.70313,-0.76562 -0.70313,-2.1875 0,-0.92187 0.29688,-1.60937 0.3125,-0.70313 0.9375,-1.04688 0.625,-0.34375 1.35937,-0.34375 0.92188,0 1.51563,0.46875 0.59375,0.46875 0.76562,1.32813 l -0.95312,0.14062 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29687 -0.82813,-0.29687 -0.71875,0 -1.1875,0.53125 -0.45312,0.51562 -0.45312,1.64062 0,1.15625 0.4375,1.67188 0.4375,0.51562 1.15625,0.51562 0.5625,0 0.9375,-0.34375 0.39062,-0.34375 0.5,-1.07812 z m 1.60937,2.09375 0,-7.875 0.96875,0 0,4.48437 2.28125,-2.3125 1.25,0 -2.17187,2.10938 2.39062,3.59375 -1.1875,0 -1.89062,-2.92188 -0.67188,0.65625 0,2.26563 -0.96875,0 z m 5.14063,0.46875 0.9375,0.14062 q 0.0625,0.4375 0.32812,0.64063 0.35938,0.26562 0.98438,0.26562 0.67187,0 1.03125,-0.26562 0.375,-0.26563 0.5,-0.75 0.0781,-0.29688 0.0781,-1.25 -0.64062,0.75 -1.59375,0.75 -1.17187,0 -1.8125,-0.84375 -0.64062,-0.85938 -0.64062,-2.04688 0,-0.8125 0.29687,-1.5 0.29688,-0.6875 0.84375,-1.0625 0.5625,-0.375 1.32813,-0.375 1,0 1.65625,0.8125 l 0,-0.6875 0.89062,0 0,4.92188 q 0,1.34375 -0.26562,1.89062 -0.26563,0.5625 -0.85938,0.875 -0.59375,0.32813 -1.45312,0.32813 -1.01563,0 -1.64063,-0.46875 -0.625,-0.45313 -0.60937,-1.375 z m 0.79687,-3.42188 q 0,1.125 0.4375,1.64063 0.45313,0.51562 1.125,0.51562 0.67188,0 1.125,-0.51562 0.45313,-0.51563 0.45313,-1.60938 0,-1.04687 -0.46875,-1.57812 -0.46875,-0.53125 -1.125,-0.53125 -0.64063,0 -1.09375,0.53125 -0.45313,0.51562 -0.45313,1.54687 z m 5.30152,2.95313 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.18921,-2.85938 q 0,-1.57812 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76563 -0.73437,-0.76562 -0.73437,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48437,-0.54688 0.48437,-1.67188 0,-1.04687 -0.48437,-1.59375 -0.48438,-0.54687 -1.1875,-0.54687 -0.73438,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 9.03588,2.85938 0,-0.84375 q -0.67187,0.96875 -1.8125,0.96875 -0.5,0 -0.95312,-0.1875 -0.4375,-0.20313 -0.65625,-0.48438 -0.20313,-0.29687 -0.28125,-0.71875 -0.0625,-0.28125 -0.0625,-0.90625 l 0,-3.53125 0.96875,0 0,3.15625 q 0,0.76563 0.0625,1.03125 0.0937,0.375 0.375,0.59375 0.29687,0.21875 0.73437,0.21875 0.4375,0 0.8125,-0.21875 0.39063,-0.23437 0.54688,-0.60937 0.15625,-0.39063 0.15625,-1.10938 l 0,-3.0625 0.96875,0 0,5.70313 -0.85938,0 z m 2.17652,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 9.62958,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path391"
-     d="m 880.23474,252.47249 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17188 -0.28125,-0.17187 -0.40625,-0.4375 -0.10937,-0.26562 -0.10937,-1.14062 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10937 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.83563,0.85937 0,-7.875 0.96875,0 0,2.82813 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67188,0.6875 0.20312,0.4375 0.20312,1.28125 l 0,3.60937 -0.96875,0 0,-3.60937 q 0,-0.73438 -0.3125,-1.0625 -0.3125,-0.32813 -0.89062,-0.32813 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54688,0.60938 -0.15625,0.375 -0.15625,1.04687 l 0,3.125 -0.96875,0 z m 5.92652,0 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89062 q -0.35937,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45483,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.92651,2.70313 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 5.98901,2.85937 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29687,-0.70313 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64063 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45313,-1.71875 -0.4375,-0.54688 -1.10937,-0.54688 -0.64063,0 -1.07813,0.53125 -0.42187,0.51563 -0.42187,1.65625 z m 7.12964,5.15625 q -0.8125,-1 -1.35938,-2.35937 -0.54687,-1.35938 -0.54687,-2.8125 0,-1.26563 0.40625,-2.4375 0.48437,-1.35938 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85938,1.60937 -0.32812,0.73438 -0.51562,1.54688 -0.23438,1 -0.23438,2.01562 0,2.57813 1.60938,5.15625 l -0.6875,0 z m 1.31421,-4.01562 0.95312,-0.15625 q 0.0781,0.57812 0.4375,0.89062 0.375,0.29688 1.03125,0.29688 0.67188,0 0.98438,-0.26563 0.32812,-0.26562 0.32812,-0.64062 0,-0.32813 -0.28125,-0.51563 -0.20312,-0.125 -0.98437,-0.32812 -1.0625,-0.26563 -1.48438,-0.45313 -0.40625,-0.20312 -0.625,-0.54687 -0.20312,-0.34375 -0.20312,-0.76563 0,-0.39062 0.17187,-0.70312 0.17188,-0.32813 0.48438,-0.54688 0.21875,-0.17187 0.60937,-0.28125 0.39063,-0.10937 0.82813,-0.10937 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32812 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67188 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51563 0,0.1875 0.10937,0.32812 0.125,0.15625 0.375,0.26563 0.14063,0.0469 0.85938,0.25 1.01562,0.26562 1.42187,0.4375 0.40625,0.17187 0.64063,0.51562 0.23437,0.32813 0.23437,0.82813 0,0.48437 -0.28125,0.90625 -0.28125,0.42187 -0.8125,0.65625 -0.53125,0.23437 -1.20312,0.23437 -1.10938,0 -1.70313,-0.45312 -0.57812,-0.46875 -0.73437,-1.375 z m 6.34375,4.01562 -0.6875,0 q 1.59375,-2.57812 1.59375,-5.15625 0,-1.01562 -0.21875,-2 -0.1875,-0.8125 -0.51563,-1.54687 -0.20312,-0.48438 -0.85937,-1.625 l 0.6875,0 q 1.01562,1.35937 1.5,2.71875 0.40625,1.17187 0.40625,2.4375 0,1.45312 -0.5625,2.8125 -0.54688,1.35937 -1.34375,2.35937 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path397"
-     d="m 17.505322,831.72925 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path399"
-     d="m 17.505322,831.72925 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path401"
-     d="m 620.34906,47.61155 73.35437,0 0,20.97638 -73.35437,0 z" />
-  <path
-     style="fill:#1c4587;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path403"
-     d="m 634.3665,61.459736 -1.42188,-4.671875 0.8125,0 0.75,2.703125 0.26563,1 q 0.0156,-0.07813 0.25,-0.96875 l 0.73437,-2.734375 0.8125,0 0.70313,2.71875 0.23437,0.890625 0.26563,-0.90625 0.79687,-2.703125 0.76563,0 -1.45313,4.671875 -0.8125,0 -0.75,-2.796875 -0.1875,-0.796875 -0.9375,3.59375 -0.82812,0 z m 5.5802,-2.328125 q 0,-1.296875 0.71875,-1.921875 0.60937,-0.515625 1.46875,-0.515625 0.96875,0 1.57812,0.625 0.60938,0.625 0.60938,1.734375 0,0.90625 -0.28125,1.421875 -0.26563,0.515625 -0.78125,0.8125 -0.51563,0.28125 -1.125,0.28125 -0.98438,0 -1.59375,-0.625 -0.59375,-0.640625 -0.59375,-1.8125 z m 0.8125,0 q 0,0.890625 0.39062,1.34375 0.39063,0.4375 0.98438,0.4375 0.59375,0 0.98437,-0.4375 0.39063,-0.453125 0.39063,-1.375 0,-0.859375 -0.39063,-1.3125 -0.39062,-0.453125 -0.98437,-0.453125 -0.59375,0 -0.98438,0.453125 -0.39062,0.4375 -0.39062,1.34375 z m 4.65662,2.328125 0,-4.671875 0.71875,0 0,0.71875 q 0.26562,-0.5 0.5,-0.65625 0.23437,-0.15625 0.51562,-0.15625 0.39063,0 0.8125,0.25 l -0.28125,0.734375 q -0.28125,-0.171875 -0.57812,-0.171875 -0.25,0 -0.46875,0.15625 -0.20313,0.15625 -0.29688,0.4375 -0.125,0.421875 -0.125,0.921875 l 0,2.4375 -0.79687,0 z m 3.12201,0 0,-6.4375 0.79687,0 0,3.671875 1.875,-1.90625 1.01563,0 -1.78125,1.734375 1.96868,2.9375 -0.98431,0 -1.53125,-2.390625 -0.5625,0.546875 0,1.84375 -0.79687,0 z m 10.22442,1.78125 0,-2.28125 q -0.17187,0.265625 -0.51562,0.4375 -0.32813,0.171875 -0.70313,0.171875 -0.82812,0 -1.4375,-0.65625 -0.59375,-0.671875 -0.59375,-1.828125 0,-0.703125 0.23438,-1.265625 0.25,-0.5625 0.71875,-0.84375 0.46875,-0.28125 1.01562,-0.28125 0.875,0 1.35938,0.71875 l 0,-0.625 0.71875,0 0,6.453125 -0.79688,0 z m -2.4375,-4.125 q 0,0.890625 0.375,1.34375 0.39063,0.453125 0.90625,0.453125 0.51563,0 0.875,-0.421875 0.35938,-0.4375 0.35938,-1.3125 0,-0.921875 -0.39063,-1.390625 -0.375,-0.484375 -0.89062,-0.484375 -0.51563,0 -0.875,0.4375 -0.35938,0.4375 -0.35938,1.375 z m 7.71912,2.34375 0,-0.6875 q -0.54688,0.796875 -1.48438,0.796875 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.171875 -0.54688,-0.40625 -0.17187,-0.234375 -0.23437,-0.578125 -0.0469,-0.234375 -0.0469,-0.75 l 0,-2.890625 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.828125 0.0625,0.3125 0.29688,0.5 0.25,0.171875 0.60937,0.171875 0.35938,0 0.67188,-0.171875 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.921875 l 0,-2.5 0.79687,0 0,4.671875 -0.70312,0 z m 5.31286,-1.5 0.82813,0.09375 q -0.20313,0.71875 -0.73438,1.125 -0.51562,0.390625 -1.32812,0.390625 -1.01563,0 -1.625,-0.625 -0.59375,-0.640625 -0.59375,-1.78125 0,-1.171875 0.60937,-1.8125 0.60938,-0.65625 1.57813,-0.65625 0.9375,0 1.51562,0.640625 0.59375,0.625 0.59375,1.78125 0,0.07813 0,0.21875 l -3.48437,0 q 0.0469,0.765625 0.4375,1.171875 0.39062,0.40625 0.98437,0.40625 0.4375,0 0.73438,-0.21875 0.3125,-0.234375 0.48437,-0.734375 z m -2.59375,-1.28125 2.60938,0 q -0.0469,-0.59375 -0.29688,-0.890625 -0.375,-0.453125 -0.98437,-0.453125 -0.54688,0 -0.92188,0.375 -0.35937,0.359375 -0.40625,0.96875 z m 7.65662,2.78125 0,-0.6875 q -0.54688,0.796875 -1.48438,0.796875 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.171875 -0.54688,-0.40625 -0.17187,-0.234375 -0.23437,-0.578125 -0.0469,-0.234375 -0.0469,-0.75 l 0,-2.890625 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.828125 0.0625,0.3125 0.29688,0.5 0.25,0.171875 0.60937,0.171875 0.35938,0 0.67188,-0.171875 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.921875 l 0,-2.5 0.79687,0 0,4.671875 -0.70312,0 z m 5.31287,-1.5 0.82812,0.09375 q -0.20312,0.71875 -0.73437,1.125 -0.51563,0.390625 -1.32813,0.390625 -1.01562,0 -1.625,-0.625 -0.59375,-0.640625 -0.59375,-1.78125 0,-1.171875 0.60938,-1.8125 0.60937,-0.65625 1.57812,-0.65625 0.9375,0 1.51563,0.640625 0.59375,0.625 0.59375,1.78125 0,0.07813 0,0.21875 l -3.48438,0 q 0.0469,0.765625 0.4375,1.171875 0.39063,0.40625 0.98438,0.40625 0.4375,0 0.73437,-0.21875 0.3125,-0.234375 0.48438,-0.734375 z m -2.59375,-1.28125 2.60937,0 q -0.0469,-0.59375 -0.29687,-0.890625 -0.375,-0.453125 -0.98438,-0.453125 -0.54687,0 -0.92187,0.375 -0.35938,0.359375 -0.40625,0.96875 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path405"
-     d="m 620.34906,175.11285 73.35437,0 0,20.97638 -73.35437,0 z" />
-  <path
-     style="fill:#1c4587;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path407"
-     d="m 634.3665,188.96104 -1.42188,-4.67188 0.8125,0 0.75,2.70313 0.26563,1 q 0.0156,-0.0781 0.25,-0.96875 l 0.73437,-2.73438 0.8125,0 0.70313,2.71875 0.23437,0.89063 0.26563,-0.90625 0.79687,-2.70313 0.76563,0 -1.45313,4.67188 -0.8125,0 -0.75,-2.79688 -0.1875,-0.79687 -0.9375,3.59375 -0.82812,0 z m 5.5802,-2.32813 q 0,-1.29687 0.71875,-1.92187 0.60937,-0.51563 1.46875,-0.51563 0.96875,0 1.57812,0.625 0.60938,0.625 0.60938,1.73438 0,0.90625 -0.28125,1.42187 -0.26563,0.51563 -0.78125,0.8125 -0.51563,0.28125 -1.125,0.28125 -0.98438,0 -1.59375,-0.625 -0.59375,-0.64062 -0.59375,-1.8125 z m 0.8125,0 q 0,0.89063 0.39062,1.34375 0.39063,0.4375 0.98438,0.4375 0.59375,0 0.98437,-0.4375 0.39063,-0.45312 0.39063,-1.375 0,-0.85937 -0.39063,-1.3125 -0.39062,-0.45312 -0.98437,-0.45312 -0.59375,0 -0.98438,0.45312 -0.39062,0.4375 -0.39062,1.34375 z m 4.65662,2.32813 0,-4.67188 0.71875,0 0,0.71875 q 0.26562,-0.5 0.5,-0.65625 0.23437,-0.15625 0.51562,-0.15625 0.39063,0 0.8125,0.25 l -0.28125,0.73438 q -0.28125,-0.17188 -0.57812,-0.17188 -0.25,0 -0.46875,0.15625 -0.20313,0.15625 -0.29688,0.4375 -0.125,0.42188 -0.125,0.92188 l 0,2.4375 -0.79687,0 z m 3.12201,0 0,-6.4375 0.79687,0 0,3.67187 1.875,-1.90625 1.01563,0 -1.78125,1.73438 1.96868,2.9375 -0.98431,0 -1.53125,-2.39063 -0.5625,0.54688 0,1.84375 -0.79687,0 z m 10.22442,1.78125 0,-2.28125 q -0.17187,0.26562 -0.51562,0.4375 -0.32813,0.17187 -0.70313,0.17187 -0.82812,0 -1.4375,-0.65625 -0.59375,-0.67187 -0.59375,-1.82812 0,-0.70313 0.23438,-1.26563 0.25,-0.5625 0.71875,-0.84375 0.46875,-0.28125 1.01562,-0.28125 0.875,0 1.35938,0.71875 l 0,-0.625 0.71875,0 0,6.45313 -0.79688,0 z m -2.4375,-4.125 q 0,0.89062 0.375,1.34375 0.39063,0.45312 0.90625,0.45312 0.51563,0 0.875,-0.42187 0.35938,-0.4375 0.35938,-1.3125 0,-0.92188 -0.39063,-1.39063 -0.375,-0.48437 -0.89062,-0.48437 -0.51563,0 -0.875,0.4375 -0.35938,0.4375 -0.35938,1.375 z m 7.71912,2.34375 0,-0.6875 q -0.54688,0.79687 -1.48438,0.79687 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.17187 -0.54688,-0.40625 -0.17187,-0.23437 -0.23437,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29688,0.5 0.25,0.17187 0.60937,0.17187 0.35938,0 0.67188,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79687,0 0,4.67188 -0.70312,0 z m 5.31286,-1.5 0.82813,0.0937 q -0.20313,0.71875 -0.73438,1.125 -0.51562,0.39062 -1.32812,0.39062 -1.01563,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60937,-1.8125 0.60938,-0.65625 1.57813,-0.65625 0.9375,0 1.51562,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48437,0 q 0.0469,0.76562 0.4375,1.17187 0.39062,0.40625 0.98437,0.40625 0.4375,0 0.73438,-0.21875 0.3125,-0.23437 0.48437,-0.73437 z m -2.59375,-1.28125 2.60938,0 q -0.0469,-0.59375 -0.29688,-0.89063 -0.375,-0.45312 -0.98437,-0.45312 -0.54688,0 -0.92188,0.375 -0.35937,0.35937 -0.40625,0.96875 z m 7.65662,2.78125 0,-0.6875 q -0.54688,0.79687 -1.48438,0.79687 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.17187 -0.54688,-0.40625 -0.17187,-0.23437 -0.23437,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29688,0.5 0.25,0.17187 0.60937,0.17187 0.35938,0 0.67188,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79687,0 0,4.67188 -0.70312,0 z m 5.31287,-1.5 0.82812,0.0937 q -0.20312,0.71875 -0.73437,1.125 -0.51563,0.39062 -1.32813,0.39062 -1.01562,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60938,-1.8125 0.60937,-0.65625 1.57812,-0.65625 0.9375,0 1.51563,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48438,0 q 0.0469,0.76562 0.4375,1.17187 0.39063,0.40625 0.98438,0.40625 0.4375,0 0.73437,-0.21875 0.3125,-0.23437 0.48438,-0.73437 z m -2.59375,-1.28125 2.60937,0 q -0.0469,-0.59375 -0.29687,-0.89063 -0.375,-0.45312 -0.98438,-0.45312 -0.54687,0 -0.92187,0.375 -0.35938,0.35937 -0.40625,0.96875 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path409"
-     d="m 111.76602,1487.9132 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path411"
-     d="m 111.76602,1487.9132 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path413"
-     d="m 44.496544,525.8988 147.968496,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path415"
-     d="m 44.496544,525.8988 141.968496,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path417"
-     d="m 186.46504,527.55054 4.5381,-1.65173 -4.5381,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path419"
-     d="m 192.25958,676.96655 -147.55905,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path421"
-     d="m 192.25958,676.96655 -141.55905,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path423"
-     d="m 50.700527,675.3148 -4.538097,1.65173 4.538097,1.65174 z" />
-  <path
-     style="fill:#efefef;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path425"
-     d="m 143.34401,626.50653 0,0 c -4.86194,0 -8.80333,-3.94141 -8.80333,-8.80335 l 0,-35.21222 0,0 c 0,-2.33477 0.92749,-4.57397 2.57843,-6.22491 1.65096,-1.65094 3.89011,-2.57843 6.2249,-2.57843 l 50.20438,0 c 4.86194,0 8.80331,3.94141 8.80331,8.80335 l 0,35.21222 c 0,4.86193 -3.94138,8.80334 -8.80331,8.80334 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path427"
-     d="m 143.34401,626.50653 0,0 c -4.86194,0 -8.80333,-3.94141 -8.80333,-8.80335 l 0,-35.21222 0,0 c 0,-2.33477 0.92749,-4.57397 2.57843,-6.22491 1.65096,-1.65094 3.89011,-2.57843 6.2249,-2.57843 l 50.20438,0 c 4.86194,0 8.80331,3.94141 8.80331,8.80335 l 0,35.21222 c 0,4.86193 -3.94138,8.80334 -8.80331,8.80334 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path429"
-     d="m 170.58307,611.3045 -0.15625,-0.95313 q 0.57812,-0.0781 0.89062,-0.4375 0.29688,-0.375 0.29688,-1.03125 0,-0.67187 -0.26563,-0.98437 -0.26562,-0.32813 -0.64062,-0.32813 -0.32813,0 -0.51563,0.28125 -0.125,0.20313 -0.32812,0.98438 -0.26563,1.0625 -0.45313,1.48437 -0.20312,0.40625 -0.54687,0.625 -0.34375,0.20313 -0.76563,0.20313 -0.39062,0 -0.70312,-0.17188 -0.32813,-0.17187 -0.54688,-0.48437 -0.17187,-0.21875 -0.28125,-0.60938 -0.10937,-0.39062 -0.10937,-0.82812 0,-0.67188 0.1875,-1.17188 0.1875,-0.51562 0.53125,-0.75 0.32812,-0.25 0.875,-0.34375 l 0.125,0.9375 q -0.4375,0.0781 -0.67188,0.39063 -0.25,0.29687 -0.25,0.85937 0,0.67188 0.21875,0.95313 0.21875,0.28125 0.51563,0.28125 0.1875,0 0.32812,-0.10938 0.15625,-0.125 0.26563,-0.375 0.0469,-0.14062 0.25,-0.85937 0.26562,-1.01563 0.4375,-1.42188 0.17187,-0.40625 0.51562,-0.64062 0.32813,-0.23438 0.82813,-0.23438 0.48437,0 0.90625,0.28125 0.42187,0.28125 0.65625,0.8125 0.23437,0.53125 0.23437,1.20313 0,1.10937 -0.45312,1.70312 -0.46875,0.57813 -1.375,0.73438 z m 0.84375,-7.82813 0.84375,-0.125 q 0.0937,0.40625 0.0937,0.71875 0,0.53125 -0.17188,0.82813 -0.17187,0.28125 -0.4375,0.40625 -0.26562,0.10937 -1.14062,0.10937 l -3.28125,0 0,0.71875 -0.75,0 0,-0.71875 -1.40625,0 -0.59375,-0.95312 2,0 0,-0.98438 0.75,0 0,0.98438 3.34375,0 q 0.40625,0 0.53125,-0.0469 0.10937,-0.0625 0.1875,-0.17187 0.0625,-0.125 0.0625,-0.32813 0,-0.17187 -0.0312,-0.4375 z m 0.15625,-4.57 q 0.45312,0.54687 0.64062,1.04687 0.1875,0.48438 0.1875,1.0625 0,0.9375 -0.45312,1.45313 -0.46875,0.5 -1.17188,0.5 -0.42187,0 -0.76562,-0.1875 -0.34375,-0.20313 -0.54688,-0.5 -0.21875,-0.3125 -0.32812,-0.70313 -0.0781,-0.28125 -0.14063,-0.85937 -0.14062,-1.17188 -0.34375,-1.71875 -0.1875,-0.0156 -0.25,-0.0156 -0.59375,0 -0.82812,0.28125 -0.32813,0.35938 -0.32813,1.09375 0,0.6875 0.23438,1.01563 0.23437,0.3125 0.84375,0.46875 l -0.125,0.95312 q -0.60938,-0.125 -0.98438,-0.42187 -0.375,-0.29688 -0.5625,-0.85938 -0.20312,-0.5625 -0.20312,-1.29687 0,-0.73438 0.17187,-1.1875 0.17188,-0.45313 0.4375,-0.65625 0.25,-0.21875 0.64063,-0.3125 0.25,-0.0469 0.90625,-0.0469 l 1.28125,0 q 1.34375,0 1.70312,-0.0625 0.35938,-0.0625 0.6875,-0.25 l 0,1.01563 q -0.29687,0.15625 -0.70312,0.1875 z m -2.15625,0.0937 q 0.21875,0.51562 0.35937,1.57812 0.0937,0.59375 0.20313,0.84375 0.0937,0.23438 0.3125,0.375 0.20312,0.14063 0.45312,0.14063 0.39063,0 0.65625,-0.29688 0.25,-0.29687 0.25,-0.85937 0,-0.5625 -0.25,-0.98438 -0.25,-0.4375 -0.67187,-0.65625 -0.32813,-0.14062 -0.96875,-0.14062 l -0.34375,0 z m 2,-4.41089 0.84375,-0.125 q 0.0937,0.40625 0.0937,0.71875 0,0.53125 -0.17188,0.82812 -0.17187,0.28125 -0.4375,0.40625 -0.26562,0.10938 -1.14062,0.10938 l -3.28125,0 0,0.71875 -0.75,0 0,-0.71875 -1.40625,0 -0.59375,-0.95313 2,0 0,-0.98437 0.75,0 0,0.98437 3.34375,0 q 0.40625,0 0.53125,-0.0469 0.10937,-0.0625 0.1875,-0.17188 0.0625,-0.125 0.0625,-0.32812 0,-0.17188 -0.0312,-0.4375 z m -0.98438,-4.74188 0.125,-1 q 0.875,0.23437 1.35938,0.875 0.48437,0.64062 0.48437,1.625 0,1.25 -0.76562,1.98437 -0.76563,0.73438 -2.15625,0.73438 -1.45313,0 -2.23438,-0.73438 -0.79687,-0.75 -0.79687,-1.92187 0,-1.15625 0.78125,-1.875 0.76562,-0.71875 2.1875,-0.71875 0.0781,0 0.25,0 l 0,4.25 q 0.9375,-0.0469 1.4375,-0.51563 0.5,-0.48437 0.5,-1.20312 0,-0.53125 -0.26563,-0.90625 -0.28125,-0.375 -0.90625,-0.59375 z m -1.5625,3.17187 0,-3.1875 q -0.71875,0.0625 -1.07812,0.35938 -0.54688,0.46875 -0.54688,1.20312 0,0.67188 0.45313,1.125 0.4375,0.45313 1.17187,0.5 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path431"
-     d="m 168.4462,626.50653 0,50.45667" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path433"
-     d="m 168.4462,632.50653 0,44.45667" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path435"
-     d="m 170.09793,632.50653 -1.65173,-4.53809 -1.65174,4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path437"
-     d="m 44.911278,591.9188 100.283472,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path439"
-     d="m 44.911278,591.9188 94.283452,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path441"
-     d="m 139.19473,593.57056 4.5381,-1.65173 -4.5381,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path443"
-     d="m 45.945923,610.695 99.275587,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path445"
-     d="m 45.945923,610.695 99.275587,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path447"
-     d="m 144.9972,610.7002 0,-18.5827" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path449"
-     d="m 144.9972,610.7002 0,-18.5827" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path451"
-     d="m 168.44698,525.41205 0,50.45673" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path453"
-     d="m 168.44698,525.41205 0,44.45673" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path455"
-     d="m 166.79524,569.8688 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path457"
-     d="m 192.6273,676.96326 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path459"
-     d="m 192.6273,676.96326 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path461"
-     d="m 192.6273,525.90027 0,0" />
-  <path
-     style="stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path463"
-     d="m 192.6273,525.90027 0,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path465"
-     d="m 30.08399,528.08136 138.36221,0 0,45.60632 -138.36221,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path467"
-     d="m 74.85771,548.3245 0,-5.70313 0.859375,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.609375,-0.1875 0.5,0 1,0.3125 l -0.328125,0.89063 q -0.359375,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.359375,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.454864,-1.84375 1,0.125 q -0.234375,0.875 -0.875,1.35937 -0.640625,0.48438 -1.625,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 5.192124,3.40625 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.515625,0 0.953125,0.1875 0.4375,0.17188 0.640625,0.48438 0.21875,0.29687 0.3125,0.70312 0.04687,0.28125 0.04687,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.109375,-0.875 -0.109375,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.671875,-0.1875 -0.609375,0 -1.0625,0.39062 -0.453125,0.39063 -0.453125,1.5 l 0,3.10938 -0.96875,0 z m 9.629623,0 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.671875,0 -1.25,-0.375 -0.578125,-0.375 -0.890625,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.296875,-0.70312 0.859375,-1.0625 0.5625,-0.375 1.265625,-0.375 0.515625,0 0.921875,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.046875,-2.84375 q 0,1.09375 0.453125,1.64062 0.46875,0.53125 1.09375,0.53125 0.640625,0 1.078125,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.453125,-1.71875 -0.4375,-0.54687 -1.109375,-0.54687 -0.640625,0 -1.078125,0.53125 -0.421875,0.51562 -0.421875,1.65625 z m 9.176499,1 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.640626,0.48438 -1.625001,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875001,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.250001,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.593751,-0.90625 z m -3.171876,-1.5625 3.187496,0 q -0.0625,-0.71875 -0.359371,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 5.192126,3.40625 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.19212,3.40625 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.70486,0 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35938,0 0,0.92187 -4.35938,0 0,2.6875 4.84375,0 0,0.92188 -5.875,0 z m 6.95139,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 9.66087,-0.70313 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 3.1765,2.85938 -0.89062,0 0,-7.875 0.96875,0 0,2.8125 q 0.60937,-0.76563 1.5625,-0.76563 0.53125,0 1,0.21875 0.46875,0.20313 0.76562,0.59375 0.3125,0.375 0.48438,0.92188 0.17187,0.53125 0.17187,1.15625 0,1.46875 -0.73437,2.26562 -0.71875,0.79688 -1.73438,0.79688 -1.01562,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89063 q 0,1.01563 0.28125,1.48438 0.45313,0.73437 1.23438,0.73437 0.625,0 1.07812,-0.54687 0.46875,-0.54688 0.46875,-1.64063 0,-1.10937 -0.4375,-1.64062 -0.4375,-0.53125 -1.07812,-0.53125 -0.625,0 -1.09375,0.54687 -0.45313,0.54688 -0.45313,1.59375 z m 5.02025,2.89063 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89525,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z m 5.3015,5.03125 0,-10.0625 2.125,0 0,0.79687 -1.15625,0 0,8.46875 1.15625,0 0,0.79688 -2.125,0 z m 4.55438,0 -2.14061,0 0,-0.79688 1.17188,0 0,-8.46875 -1.17188,0 0,-0.79687 2.14061,0 0,10.0625 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path469"
-     d="m 81.97575,563.312 0,-7.89063 0.890625,0 0,0.73438 q 0.3125,-0.42188 0.703125,-0.64063 0.390625,-0.21875 0.953125,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.921875,1.0625 -0.59375,0.375 -1.25,0.375 -0.484375,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.453125,1.625 0.453125,0.51562 1.078125,0.51562 0.640625,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.453125,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.109375,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 5.035873,2.8125 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.117478,-0.70313 q -0.546875,0.45313 -1.046875,0.64063 -0.484375,0.1875 -1.0625,0.1875 -0.9375,0 -1.453125,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.203125,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.703125,-0.32813 0.28125,-0.0781 0.859375,-0.14062 1.171875,-0.14063 1.71875,-0.34375 0.01563,-0.1875 0.01563,-0.25 0,-0.59375 -0.28125,-0.82813 -0.359375,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.015625,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.953125,-0.125 q 0.125,-0.60937 0.421875,-0.98437 0.296875,-0.375 0.859375,-0.5625 0.5625,-0.20313 1.296875,-0.20313 0.734375,0 1.1875,0.17188 0.453125,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.04687,0.25 0.04687,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.015625,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.09375,-2.15625 q -0.515625,0.21875 -1.578125,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.234375,0.0937 -0.375,0.3125 -0.140625,0.20313 -0.140625,0.45313 0,0.39062 0.296875,0.65625 0.296875,0.25 0.859375,0.25 0.5625,0 0.984375,-0.25 0.4375,-0.25 0.65625,-0.67188 0.140625,-0.32812 0.140625,-0.96875 l 0,-0.34375 z m 2.254623,5.0625 -0.109375,-0.90625 q 0.3125,0.0781 0.546875,0.0781 0.328125,0 0.515625,-0.10938 0.203125,-0.10937 0.3125,-0.29687 0.09375,-0.14063 0.296875,-0.71875 0.03125,-0.0781 0.09375,-0.23438 l -2.171875,-5.71875 1.046875,0 1.1875,3.29688 q 0.234375,0.64062 0.40625,1.32812 0.171875,-0.67187 0.40625,-1.29687 l 1.21875,-3.32813 0.968746,0 -2.171871,5.79688 q -0.34375,0.9375 -0.546875,1.29687 -0.25,0.48438 -0.59375,0.70313 -0.328125,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10938 z m 6.859376,-2.20312 -2.07813,-7.875 1.0625,0 1.20313,5.15625 q 0.1875,0.8125 0.32812,1.625 0.29688,-1.26563 0.35938,-1.46875 l 1.5,-5.3125 1.25,0 1.125,3.98437 q 0.42187,1.48438 0.60937,2.79688 0.15625,-0.75 0.39063,-1.71875 l 1.25,-5.0625 1.04687,0 -2.17187,7.875 -1,0 -1.65625,-6 q -0.21875,-0.75 -0.25,-0.92188 -0.125,0.54688 -0.23438,0.92188 l -1.67187,6 -1.0625,0 z m 8.55788,0 0,-7.875 0.96875,0 0,2.82812 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60938 -0.96875,0 0,-3.60938 q 0,-0.73437 -0.3125,-1.0625 -0.3125,-0.32812 -0.89063,-0.32812 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60937 -0.15625,0.375 -0.15625,1.04688 l 0,3.125 -0.96875,0 z m 9.83274,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.19212,3.40625 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 6.06713,0 0,-7.875 3.5,0 q 1.04687,0 1.59375,0.21875 0.54687,0.20312 0.875,0.75 0.32812,0.53125 0.32812,1.1875 0,0.82812 -0.54687,1.40625 -0.53125,0.57812 -1.67188,0.73437 0.42188,0.1875 0.625,0.39063 0.46875,0.42187 0.875,1.04687 l 1.35938,2.14063 -1.29688,0 -1.04687,-1.64063 q -0.45313,-0.70312 -0.75,-1.07812 -0.29688,-0.375 -0.53125,-0.53125 -0.23438,-0.15625 -0.46875,-0.20313 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20313,0 0,3.5 -1.04687,0 z m 1.04687,-4.40625 2.23438,0 q 0.71875,0 1.125,-0.14063 0.40625,-0.14062 0.60937,-0.46875 0.20313,-0.32812 0.20313,-0.70312 0,-0.5625 -0.40625,-0.92188 -0.39063,-0.35937 -1.26563,-0.35937 l -2.5,0 0,2.59375 z m 10.41435,2.5625 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.9265,2.70312 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 5.98899,2.85938 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29687,-0.70312 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42187,0.51562 -0.42187,1.65625 z m 5.239,5.04687 -0.10938,-0.90625 q 0.3125,0.0781 0.54688,0.0781 0.32812,0 0.51562,-0.10938 0.20313,-0.10937 0.3125,-0.29687 0.0937,-0.14063 0.29688,-0.71875 0.0312,-0.0781 0.0937,-0.23438 l -2.17188,-5.71875 1.04688,0 1.1875,3.29688 q 0.23437,0.64062 0.40625,1.32812 0.17187,-0.67187 0.40625,-1.29687 l 1.21875,-3.32813 0.96875,0 -2.17188,5.79688 q -0.34375,0.9375 -0.54687,1.29687 -0.25,0.48438 -0.59375,0.70313 -0.32813,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10938 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path471"
-     d="m 30.08399,628.93176 138.36221,0 0,45.60632 -138.36221,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path473"
-     d="m 93.225174,657.7624 0,-7.89063 0.890625,0 0,0.73438 q 0.3125,-0.42188 0.703125,-0.64063 0.390625,-0.21875 0.953125,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.921875,1.0625 -0.59375,0.375 -1.25,0.375 -0.484375,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.453125,1.625 0.453125,0.51562 1.078125,0.51562 0.640625,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.453125,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.109375,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 5.035873,2.8125 0,-7.875 0.968753,0 0,7.875 -0.968753,0 z m 6.117473,-0.70313 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 2.25463,5.0625 -0.10938,-0.90625 q 0.3125,0.0781 0.54688,0.0781 0.32812,0 0.51562,-0.10938 0.20313,-0.10937 0.3125,-0.29687 0.0937,-0.14063 0.29688,-0.71875 0.0312,-0.0781 0.0937,-0.23438 l -2.17188,-5.71875 1.04688,0 1.1875,3.29688 q 0.23437,0.64062 0.40625,1.32812 0.17187,-0.67187 0.40625,-1.29687 l 1.21875,-3.32813 0.96875,0 -2.17188,5.79688 q -0.34375,0.9375 -0.54687,1.29687 -0.25,0.48438 -0.59375,0.70313 -0.32813,0.21875 -0.78125,0.21875 -0.28125,0 -0.625,-0.10938 z m 6.25,-2.20312 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76563 1.5625,-0.76563 0.53125,0 1,0.21875 0.46875,0.20313 0.76563,0.59375 0.3125,0.375 0.48437,0.92188 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26562 -0.71875,0.79688 -1.73437,0.79688 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89063 q 0,1.01563 0.28125,1.48438 0.45312,0.73437 1.23437,0.73437 0.625,0 1.07813,-0.54687 0.46875,-0.54688 0.46875,-1.64063 0,-1.10937 -0.4375,-1.64062 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54687 -0.45312,0.54688 -0.45312,1.59375 z m 8.77025,2.1875 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 6.02024,0.76563 0.9375,0.125 q -0.14062,0.98437 -0.79687,1.54687 -0.64063,0.54688 -1.5625,0.54688 -1.17188,0 -1.89063,-0.76563 -0.70312,-0.76562 -0.70312,-2.1875 0,-0.92187 0.29687,-1.60937 0.3125,-0.70313 0.9375,-1.04688 0.625,-0.34375 1.35938,-0.34375 0.92187,0 1.51562,0.46875 0.59375,0.46875 0.76563,1.32813 l -0.95313,0.14062 q -0.125,-0.5625 -0.46875,-0.84375 -0.34375,-0.29687 -0.82812,-0.29687 -0.71875,0 -1.1875,0.53125 -0.45313,0.51562 -0.45313,1.64062 0,1.15625 0.4375,1.67188 0.4375,0.51562 1.15625,0.51562 0.5625,0 0.9375,-0.34375 0.39063,-0.34375 0.5,-1.07812 z m 1.60938,2.09375 0,-7.875 0.96875,0 0,4.48437 2.28125,-2.3125 1.25,0 -2.17188,2.10938 2.39063,3.59375 -1.1875,0 -1.89063,-2.92188 -0.67187,0.65625 0,2.26563 -0.96875,0 z m 5.09375,-2.53125 0.98437,-0.0781 q 0.0625,0.57813 0.3125,0.96875 0.26563,0.375 0.79688,0.60938 0.53125,0.23437 1.20312,0.23437 0.60938,0 1.0625,-0.17187 0.45313,-0.1875 0.67188,-0.48438 0.23437,-0.3125 0.23437,-0.6875 0,-0.375 -0.21875,-0.64062 -0.21875,-0.28125 -0.71875,-0.46875 -0.3125,-0.125 -1.40625,-0.375 -1.07812,-0.26563 -1.51562,-0.5 -0.5625,-0.29688 -0.84375,-0.73438 -0.26563,-0.4375 -0.26563,-0.98437 0,-0.59375 0.32813,-1.10938 0.34375,-0.51562 0.98437,-0.78125 0.65625,-0.28125 1.45313,-0.28125 0.875,0 1.54687,0.29688 0.67188,0.28125 1.03125,0.82812 0.35938,0.54688 0.39063,1.23438 l -1,0.0781 q -0.0781,-0.75 -0.54688,-1.125 -0.46875,-0.39062 -1.375,-0.39062 -0.9375,0 -1.375,0.35937 -0.4375,0.34375 -0.4375,0.82813 0,0.42187 0.3125,0.70312 0.29688,0.26563 1.5625,0.5625 1.28125,0.28125 1.75,0.5 0.6875,0.3125 1.01563,0.79688 0.32812,0.48437 0.32812,1.125 0,0.625 -0.35937,1.1875 -0.35938,0.54687 -1.04688,0.85937 -0.67187,0.3125 -1.51562,0.3125 -1.0625,0 -1.78125,-0.3125 -0.71875,-0.3125 -1.14063,-0.9375 -0.40625,-0.625 -0.42187,-1.42187 z m 9.45139,1.67187 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.57002,0.15625 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 4.41087,2 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 4.74188,-0.98437 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64061,0.48438 -1.62498,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.87498,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.24998,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59373,-0.90625 z m -3.17186,-1.5625 3.18749,0 q -0.0625,-0.71875 -0.35936,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path475"
-     d="m 192.6273,517.63257 73.35432,0 0,16.5354 -73.35432,0 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path477"
-     d="m 192.6273,517.63257 73.35432,0 0,16.5354 -73.35432,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path479"
-     d="m 203.1076,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path481"
-     d="m 203.1076,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path483"
-     d="m 255.50919,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path485"
-     d="m 255.50919,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path487"
-     d="m 245.02887,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path489"
-     d="m 245.02887,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path491"
-     d="m 234.54855,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path493"
-     d="m 234.54855,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path495"
-     d="m 224.06824,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path497"
-     d="m 224.06824,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path499"
-     d="m 213.58792,534.19946 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path501"
-     d="m 213.58792,534.19946 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path503"
-     d="m 203.1076,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path505"
-     d="m 203.1076,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path507"
-     d="m 213.58792,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path509"
-     d="m 213.58792,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path511"
-     d="m 192.6273,668.69556 73.35432,0 0,16.5354 -73.35432,0 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path513"
-     d="m 192.6273,668.69556 73.35432,0 0,16.5354 -73.35432,0 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path515"
-     d="m 224.06824,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path517"
-     d="m 224.06824,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path519"
-     d="m 234.54855,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path521"
-     d="m 234.54855,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path523"
-     d="m 245.02887,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path525"
-     d="m 245.02887,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path527"
-     d="m 255.50919,685.26245 0,-16.59839" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path529"
-     d="m 255.50919,685.26245 0,-16.59839" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path531"
-     d="m 192.6273,683.8294 73.35432,0 0,20.97638 -73.35432,0 z" />
-  <path
-     style="fill:#1c4587;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path533"
-     d="m 206.64471,697.6776 -1.42188,-4.67188 0.8125,0 0.75,2.70313 0.26563,1 q 0.0156,-0.0781 0.25,-0.96875 l 0.73437,-2.73438 0.8125,0 0.70313,2.71875 0.23437,0.89063 0.26563,-0.90625 0.79687,-2.70313 0.76563,0 -1.45313,4.67188 -0.8125,0 -0.75,-2.79688 -0.1875,-0.79687 -0.9375,3.59375 -0.82812,0 z m 5.58023,-2.32813 q 0,-1.29687 0.71875,-1.92187 0.60938,-0.51563 1.46875,-0.51563 0.96875,0 1.57813,0.625 0.60937,0.625 0.60937,1.73438 0,0.90625 -0.28125,1.42187 -0.26562,0.51563 -0.78125,0.8125 -0.51562,0.28125 -1.125,0.28125 -0.98437,0 -1.59375,-0.625 -0.59375,-0.64062 -0.59375,-1.8125 z m 0.8125,0 q 0,0.89063 0.39063,1.34375 0.39062,0.4375 0.98437,0.4375 0.59375,0 0.98438,-0.4375 0.39062,-0.45312 0.39062,-1.375 0,-0.85937 -0.39062,-1.3125 -0.39063,-0.45312 -0.98438,-0.45312 -0.59375,0 -0.98437,0.45312 -0.39063,0.4375 -0.39063,1.34375 z m 4.65662,2.32813 0,-4.67188 0.71875,0 0,0.71875 q 0.26562,-0.5 0.5,-0.65625 0.23437,-0.15625 0.51562,-0.15625 0.39063,0 0.8125,0.25 l -0.28125,0.73438 q -0.28125,-0.17188 -0.57812,-0.17188 -0.25,0 -0.46875,0.15625 -0.20313,0.15625 -0.29688,0.4375 -0.125,0.42188 -0.125,0.92188 l 0,2.4375 -0.79687,0 z m 3.12196,0 0,-6.4375 0.79688,0 0,3.67187 1.875,-1.90625 1.01562,0 -1.78125,1.73438 1.96875,2.9375 -0.98437,0 -1.53125,-2.39063 -0.5625,0.54688 0,1.84375 -0.79688,0 z m 10.22447,1.78125 0,-2.28125 q -0.17187,0.26562 -0.51562,0.4375 -0.32813,0.17187 -0.70313,0.17187 -0.82812,0 -1.4375,-0.65625 -0.59375,-0.67187 -0.59375,-1.82812 0,-0.70313 0.23438,-1.26563 0.25,-0.5625 0.71875,-0.84375 0.46875,-0.28125 1.01562,-0.28125 0.875,0 1.35938,0.71875 l 0,-0.625 0.71875,0 0,6.45313 -0.79688,0 z m -2.4375,-4.125 q 0,0.89062 0.375,1.34375 0.39063,0.45312 0.90625,0.45312 0.51563,0 0.875,-0.42187 0.35938,-0.4375 0.35938,-1.3125 0,-0.92188 -0.39063,-1.39063 -0.375,-0.48437 -0.89062,-0.48437 -0.51563,0 -0.875,0.4375 -0.35938,0.4375 -0.35938,1.375 z m 7.71912,2.34375 0,-0.6875 q -0.54688,0.79687 -1.48438,0.79687 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.17187 -0.54688,-0.40625 -0.17187,-0.23437 -0.23437,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29688,0.5 0.25,0.17187 0.60937,0.17187 0.35938,0 0.67188,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79687,0 0,4.67188 -0.70312,0 z m 5.31286,-1.5 0.82813,0.0937 q -0.20313,0.71875 -0.73438,1.125 -0.51562,0.39062 -1.32812,0.39062 -1.01563,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60937,-1.8125 0.60938,-0.65625 1.57813,-0.65625 0.9375,0 1.51562,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48437,0 q 0.0469,0.76562 0.4375,1.17187 0.39062,0.40625 0.98437,0.40625 0.4375,0 0.73438,-0.21875 0.3125,-0.23437 0.48437,-0.73437 z m -2.59375,-1.28125 2.60938,0 q -0.0469,-0.59375 -0.29688,-0.89063 -0.375,-0.45312 -0.98437,-0.45312 -0.54688,0 -0.92188,0.375 -0.35937,0.35937 -0.40625,0.96875 z m 7.65662,2.78125 0,-0.6875 q -0.54687,0.79687 -1.48437,0.79687 -0.40625,0 -0.76563,-0.15625 -0.35937,-0.17187 -0.54687,-0.40625 -0.17188,-0.23437 -0.23438,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29687,0.5 0.25,0.17187 0.60938,0.17187 0.35937,0 0.67187,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79688,0 0,4.67188 -0.70313,0 z m 5.31287,-1.5 0.82812,0.0937 q -0.20312,0.71875 -0.73437,1.125 -0.51563,0.39062 -1.32813,0.39062 -1.01562,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60938,-1.8125 0.60937,-0.65625 1.57812,-0.65625 0.9375,0 1.51563,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48438,0 q 0.0469,0.76562 0.4375,1.17187 0.39063,0.40625 0.98438,0.40625 0.4375,0 0.73437,-0.21875 0.3125,-0.23437 0.48438,-0.73437 z m -2.59375,-1.28125 2.60937,0 q -0.0469,-0.59375 -0.29687,-0.89063 -0.375,-0.45312 -0.98438,-0.45312 -0.54687,0 -0.92187,0.375 -0.35938,0.35937 -0.40625,0.96875 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path535"
-     d="m 266.28854,676.9675 26.07873,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path537"
-     d="m 266.28854,676.9675 20.07873,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path539"
-     d="m 286.36728,678.61926 4.53812,-1.65173 -4.53812,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path541"
-     d="m 266.28854,525.89856 26.07873,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path543"
-     d="m 266.28854,525.89856 20.07873,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path545"
-     d="m 286.36728,527.5503 4.53812,-1.65173 -4.53812,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path547"
-     d="m 292.46982,684.5486 0,-167.55908" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path549"
-     d="m 292.46982,684.5486 0,-167.55908" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path551"
-     d="m 292.46783,516.7267 45.7323,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path553"
-     d="m 292.46783,516.7267 39.7323,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path555"
-     d="m 332.20013,518.3784 4.53809,-1.65173 -4.53809,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path557"
-     d="m 303.55777,534.19916 35.65356,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path559"
-     d="m 303.55777,534.19916 35.65356,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path561"
-     d="m 304.1916,669.44617 0,-134.8346" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path563"
-     d="m 304.1916,669.44617 0,-134.8346" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path565"
-     d="m 303.31284,668.6632 35.21262,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path567"
-     d="m 303.31284,668.6632 29.21262,0" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path569"
-     d="m 332.52545,670.31494 4.53809,-1.65173 -4.53809,-1.65174 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path571"
-     d="m 292.46783,683.8293 44.72443,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path573"
-     d="m 292.46783,683.8293 44.72443,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path575"
-     d="m 192.6273,494.2756 73.35432,0 0,20.97635 -73.35432,0 z" />
-  <path
-     style="fill:#1c4587;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path577"
-     d="m 206.64471,508.12378 -1.42188,-4.67188 0.8125,0 0.75,2.70313 0.26563,1 q 0.0156,-0.0781 0.25,-0.96875 l 0.73437,-2.73438 0.8125,0 0.70313,2.71875 0.23437,0.89063 0.26563,-0.90625 0.79687,-2.70313 0.76563,0 -1.45313,4.67188 -0.8125,0 -0.75,-2.79688 -0.1875,-0.79687 -0.9375,3.59375 -0.82812,0 z m 5.58023,-2.32813 q 0,-1.29687 0.71875,-1.92187 0.60938,-0.51563 1.46875,-0.51563 0.96875,0 1.57813,0.625 0.60937,0.625 0.60937,1.73438 0,0.90625 -0.28125,1.42187 -0.26562,0.51563 -0.78125,0.8125 -0.51562,0.28125 -1.125,0.28125 -0.98437,0 -1.59375,-0.625 -0.59375,-0.64062 -0.59375,-1.8125 z m 0.8125,0 q 0,0.89063 0.39063,1.34375 0.39062,0.4375 0.98437,0.4375 0.59375,0 0.98438,-0.4375 0.39062,-0.45312 0.39062,-1.375 0,-0.85937 -0.39062,-1.3125 -0.39063,-0.45312 -0.98438,-0.45312 -0.59375,0 -0.98437,0.45312 -0.39063,0.4375 -0.39063,1.34375 z m 4.65662,2.32813 0,-4.67188 0.71875,0 0,0.71875 q 0.26562,-0.5 0.5,-0.65625 0.23437,-0.15625 0.51562,-0.15625 0.39063,0 0.8125,0.25 l -0.28125,0.73438 q -0.28125,-0.17188 -0.57812,-0.17188 -0.25,0 -0.46875,0.15625 -0.20313,0.15625 -0.29688,0.4375 -0.125,0.42188 -0.125,0.92188 l 0,2.4375 -0.79687,0 z m 3.12196,0 0,-6.4375 0.79688,0 0,3.67187 1.875,-1.90625 1.01562,0 -1.78125,1.73438 1.96875,2.9375 -0.98437,0 -1.53125,-2.39063 -0.5625,0.54688 0,1.84375 -0.79688,0 z m 10.22447,1.78125 0,-2.28125 q -0.17187,0.26562 -0.51562,0.4375 -0.32813,0.17187 -0.70313,0.17187 -0.82812,0 -1.4375,-0.65625 -0.59375,-0.67187 -0.59375,-1.82812 0,-0.70313 0.23438,-1.26563 0.25,-0.5625 0.71875,-0.84375 0.46875,-0.28125 1.01562,-0.28125 0.875,0 1.35938,0.71875 l 0,-0.625 0.71875,0 0,6.45313 -0.79688,0 z m -2.4375,-4.125 q 0,0.89062 0.375,1.34375 0.39063,0.45312 0.90625,0.45312 0.51563,0 0.875,-0.42187 0.35938,-0.4375 0.35938,-1.3125 0,-0.92188 -0.39063,-1.39063 -0.375,-0.48437 -0.89062,-0.48437 -0.51563,0 -0.875,0.4375 -0.35938,0.4375 -0.35938,1.375 z m 7.71912,2.34375 0,-0.6875 q -0.54688,0.79687 -1.48438,0.79687 -0.40625,0 -0.76562,-0.15625 -0.35938,-0.17187 -0.54688,-0.40625 -0.17187,-0.23437 -0.23437,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29688,0.5 0.25,0.17187 0.60937,0.17187 0.35938,0 0.67188,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79687,0 0,4.67188 -0.70312,0 z m 5.31286,-1.5 0.82813,0.0937 q -0.20313,0.71875 -0.73438,1.125 -0.51562,0.39062 -1.32812,0.39062 -1.01563,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60937,-1.8125 0.60938,-0.65625 1.57813,-0.65625 0.9375,0 1.51562,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48437,0 q 0.0469,0.76562 0.4375,1.17187 0.39062,0.40625 0.98437,0.40625 0.4375,0 0.73438,-0.21875 0.3125,-0.23437 0.48437,-0.73437 z m -2.59375,-1.28125 2.60938,0 q -0.0469,-0.59375 -0.29688,-0.89063 -0.375,-0.45312 -0.98437,-0.45312 -0.54688,0 -0.92188,0.375 -0.35937,0.35937 -0.40625,0.96875 z m 7.65662,2.78125 0,-0.6875 q -0.54687,0.79687 -1.48437,0.79687 -0.40625,0 -0.76563,-0.15625 -0.35937,-0.17187 -0.54687,-0.40625 -0.17188,-0.23437 -0.23438,-0.57812 -0.0469,-0.23438 -0.0469,-0.75 l 0,-2.89063 0.78125,0 0,2.59375 q 0,0.625 0.0625,0.82813 0.0625,0.3125 0.29687,0.5 0.25,0.17187 0.60938,0.17187 0.35937,0 0.67187,-0.17187 0.3125,-0.1875 0.4375,-0.5 0.125,-0.3125 0.125,-0.92188 l 0,-2.5 0.79688,0 0,4.67188 -0.70313,0 z m 5.31287,-1.5 0.82812,0.0937 q -0.20312,0.71875 -0.73437,1.125 -0.51563,0.39062 -1.32813,0.39062 -1.01562,0 -1.625,-0.625 -0.59375,-0.64062 -0.59375,-1.78125 0,-1.17187 0.60938,-1.8125 0.60937,-0.65625 1.57812,-0.65625 0.9375,0 1.51563,0.64063 0.59375,0.625 0.59375,1.78125 0,0.0781 0,0.21875 l -3.48438,0 q 0.0469,0.76562 0.4375,1.17187 0.39063,0.40625 0.98438,0.40625 0.4375,0 0.73437,-0.21875 0.3125,-0.23437 0.48438,-0.73437 z m -2.59375,-1.28125 2.60937,0 q -0.0469,-0.59375 -0.29687,-0.89063 -0.375,-0.45312 -0.98438,-0.45312 -0.54687,0 -0.92187,0.375 -0.35938,0.35937 -0.40625,0.96875 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path579"
-     d="m 30.664042,872.8643 0,0 c 0,-3.68201 2.984827,-6.66681 6.666799,-6.66681 l 90.729399,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95264 1.25027,1.2503 1.95267,2.94604 1.95267,4.71417 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.6668,6.66681 l -90.729399,0 0,0 c -3.681972,0 -6.666799,-2.9848 -6.666799,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path581"
-     d="m 30.664042,872.8643 0,0 c 0,-3.68201 2.984827,-6.66681 6.666799,-6.66681 l 90.729399,0 c 1.76814,0 3.46387,0.70239 4.71413,1.95264 1.25027,1.2503 1.95267,2.94604 1.95267,4.71417 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.6668,6.66681 l -90.729399,0 0,0 c -3.681972,0 -6.666799,-2.9848 -6.666799,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path583"
-     d="m 68.61916,890.03754 0,-7.875 1.03125,0 0,7.875 -1.03125,0 z m 2.476273,0.46875 0.9375,0.14063 q 0.0625,0.4375 0.328125,0.64062 0.359375,0.26563 0.984375,0.26563 0.671875,0 1.03125,-0.26563 0.375,-0.26562 0.5,-0.75 0.07813,-0.29687 0.07813,-1.25 -0.640625,0.75 -1.59375,0.75 -1.171875,0 -1.8125,-0.84375 -0.640625,-0.85937 -0.640625,-2.04687 0,-0.8125 0.296875,-1.5 0.296875,-0.6875 0.84375,-1.0625 0.5625,-0.375 1.328125,-0.375 1,0 1.65625,0.8125 l 0,-0.6875 0.890625,0 0,4.92187 q 0,1.34375 -0.265625,1.89063 -0.265625,0.5625 -0.859375,0.875 -0.59375,0.32812 -1.453125,0.32812 -1.015625,0 -1.640625,-0.46875 -0.625,-0.45312 -0.609375,-1.375 z m 0.796875,-3.42187 q 0,1.125 0.4375,1.64062 0.453125,0.51563 1.125,0.51563 0.671875,0 1.125,-0.51563 0.453125,-0.51562 0.453125,-1.60937 0,-1.04688 -0.46875,-1.57813 -0.46875,-0.53125 -1.125,-0.53125 -0.640625,0 -1.09375,0.53125 -0.453125,0.51563 -0.453125,1.54688 z m 5.301498,2.95312 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.515625,0 0.953125,0.1875 0.4375,0.17187 0.640625,0.48437 0.21875,0.29688 0.3125,0.70313 0.04687,0.28125 0.04687,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.109375,-0.875 -0.109375,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.671875,-0.1875 -0.609375,0 -1.0625,0.39063 -0.453125,0.39062 -0.453125,1.5 l 0,3.10937 -0.96875,0 z m 5.567123,-2.85937 q 0,-1.57813 0.890625,-2.34375 0.734375,-0.625 1.796875,-0.625 1.171875,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.328125,1.75 -0.328125,0.625 -0.96875,0.96875 -0.625,0.34375 -1.359375,0.34375 -1.203125,0 -1.953125,-0.76562 -0.734375,-0.76563 -0.734375,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.484375,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.484375,-0.54687 0.484375,-1.67187 0,-1.04688 -0.484375,-1.59375 -0.484375,-0.54688 -1.1875,-0.54688 -0.734375,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.285874,2.85937 0,-5.70312 0.859375,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.609375,-0.1875 0.5,0 1,0.3125 l -0.328125,0.89062 q -0.359375,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.359375,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.454864,-1.84375 1,0.125 q -0.234375,0.875 -0.875,1.35938 -0.640625,0.48437 -1.625,0.48437 -1.25,0 -1.984375,-0.76562 -0.734375,-0.76563 -0.734375,-2.15625 0,-1.45313 0.734375,-2.23438 0.75,-0.79687 1.921875,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07812 -0.46875,-0.54688 -1.203125,-0.54688 -0.671875,0 -1.125,0.45313 -0.453125,0.4375 -0.5,1.17187 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path585"
-     d="m 179.21208,872.8643 0,0 c 0,-3.68201 2.98482,-6.66681 6.66679,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71415,1.95264 1.25027,1.2503 1.95266,2.94604 1.95266,4.71417 l 0,26.66638 c 0,3.68201 -2.98483,6.66681 -6.66681,6.66681 l -90.7294,0 0,0 c -3.68197,0 -6.66679,-2.9848 -6.66679,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path587"
-     d="m 179.21208,872.8643 0,0 c 0,-3.68201 2.98482,-6.66681 6.66679,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71415,1.95264 1.25027,1.2503 1.95266,2.94604 1.95266,4.71417 l 0,26.66638 c 0,3.68201 -2.98483,6.66681 -6.66681,6.66681 l -90.7294,0 0,0 c -3.68197,0 -6.66679,-2.9848 -6.66679,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path589"
-     d="m 209.12004,882.16254 1.04687,0 0,4.54688 q 0,1.1875 -0.28125,1.89062 -0.26562,0.70313 -0.96875,1.14063 -0.6875,0.4375 -1.82812,0.4375 -1.10938,0 -1.8125,-0.375 -0.70313,-0.39063 -1.01563,-1.10938 -0.29687,-0.73437 -0.29687,-1.98437 l 0,-4.54688 1.04687,0 0,4.54688 q 0,1.03125 0.1875,1.51562 0.1875,0.48438 0.65625,0.75 0.46875,0.25 1.14063,0.25 1.14062,0 1.625,-0.51562 0.5,-0.51563 0.5,-2 l 0,-4.54688 z m 2.39873,7.875 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z m 5.9265,2.1875 0,-7.89062 0.89062,0 0,0.73437 q 0.3125,-0.42187 0.70313,-0.64062 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51563 1.07813,0.51563 0.64062,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45313,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10937,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 5.05149,2.8125 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19213,5.59375 0,-7.89062 0.89062,0 0,0.73437 q 0.3125,-0.42187 0.70313,-0.64062 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51563 1.07813,0.51563 0.64062,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45313,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10937,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 8.78587,2.10938 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 2.28587,2.85937 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 8.89525,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29687,-0.70313 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64063 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45313,-1.71875 -0.4375,-0.54688 -1.10937,-0.54688 -0.64063,0 -1.07813,0.53125 -0.42187,0.51563 -0.42187,1.65625 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path591"
-     d="m 327.7608,872.8643 0,0 c 0,-3.68201 2.98483,-6.66681 6.66681,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71414,1.95264 1.25025,1.2503 1.95264,2.94604 1.95264,4.71417 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.66678,6.66681 l -90.7294,0 0,0 c -3.68198,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path593"
-     d="m 327.7608,872.8643 0,0 c 0,-3.68201 2.98483,-6.66681 6.66681,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71414,1.95264 1.25025,1.2503 1.95264,2.94604 1.95264,4.71417 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.66678,6.66681 l -90.7294,0 0,0 c -3.68198,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path595"
-     d="m 358.71738,890.03754 0,-7.875 2.96875,0 q 0.79687,0 1.20312,0.0781 0.57813,0.0937 0.96875,0.375 0.39063,0.26562 0.625,0.75 0.25,0.48437 0.25,1.07812 0,1 -0.64062,1.70313 -0.64063,0.6875 -2.3125,0.6875 l -2.01563,0 0,3.20312 -1.04687,0 z m 1.04687,-4.125 2.03125,0 q 1.01563,0 1.4375,-0.375 0.42188,-0.375 0.42188,-1.0625 0,-0.5 -0.25,-0.84375 -0.25,-0.35937 -0.65625,-0.46875 -0.26563,-0.0625 -0.96875,-0.0625 l -2.01563,0 0,2.8125 z m 5.93577,4.125 0,-5.70312 0.85937,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89062 q -0.35937,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 5.19211,5.59375 0,-7.89062 0.89063,0 0,0.73437 q 0.3125,-0.42187 0.70312,-0.64062 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67187 0.28125,1.5 0,0.875 -0.3125,1.57812 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.20312 -0.375,-0.20313 -0.625,-0.51563 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.51563 1.07812,0.51563 0.64063,0 1.09375,-0.53125 0.46875,-0.54688 0.46875,-1.70313 0,-1.07812 -0.45312,-1.625 -0.4375,-0.54687 -1.0625,-0.54687 -0.625,0 -1.10938,0.57812 -0.46875,0.57813 -0.46875,1.6875 z m 8.78589,2.10938 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 2.28586,2.85937 0,-5.70312 0.85938,0 0,0.85937 q 0.34375,-0.60937 0.625,-0.79687 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89062 q -0.35938,-0.20312 -0.71875,-0.20312 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51562 -0.15625,1.125 l 0,2.98437 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35938 -0.64062,0.48437 -1.625,0.48437 -1.25,0 -1.98437,-0.76562 -0.73438,-0.76563 -0.73438,-2.15625 0,-1.45313 0.73438,-2.23438 0.75,-0.79687 1.92187,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07812 -0.46875,-0.54688 -1.20312,-0.54688 -0.67188,0 -1.125,0.45313 -0.45313,0.4375 -0.5,1.17187 z m 8.89526,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29687,-0.70313 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64063 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45313,-1.71875 -0.4375,-0.54688 -1.10937,-0.54688 -0.64063,0 -1.07813,0.53125 -0.42187,0.51563 -0.42187,1.65625 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path597"
-     d="m 476.30954,872.8643 0,0 c 0,-3.68201 2.98483,-6.66681 6.66681,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71411,1.95264 1.25031,1.2503 1.9527,2.94604 1.9527,4.71417 l 0,26.66638 c 0,3.68201 -2.98487,6.66681 -6.66681,6.66681 l -90.7294,0 0,0 c -3.68198,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path599"
-     d="m 476.30954,872.8643 0,0 c 0,-3.68201 2.98483,-6.66681 6.66681,-6.66681 l 90.7294,0 c 1.76813,0 3.46387,0.70239 4.71411,1.95264 1.25031,1.2503 1.9527,2.94604 1.9527,4.71417 l 0,26.66638 c 0,3.68201 -2.98487,6.66681 -6.66681,6.66681 l -90.7294,0 0,0 c -3.68198,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path601"
-     d="m 509.66223,890.03754 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35938,0 0,0.92188 -4.35938,0 0,2.6875 4.84375,0 0,0.92187 -5.875,0 z m 6.95142,0 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z m 9.66082,-0.70312 q -0.54687,0.45312 -1.04687,0.64062 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20313,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70313,-0.32812 0.28125,-0.0781 0.85937,-0.14063 1.17188,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35938,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01563,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60938 0.42187,-0.98438 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20312 1.29687,-0.20312 0.73438,0 1.1875,0.17187 0.45313,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20312 -0.14063,0.45312 0,0.39063 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14062,-0.32813 0.14062,-0.96875 l 0,-0.34375 z m 3.17652,2.85937 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76562 1.5625,-0.76562 0.53125,0 1,0.21875 0.46875,0.20312 0.76563,0.59375 0.3125,0.375 0.48437,0.92187 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26563 -0.71875,0.79687 -1.73437,0.79687 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89062 q 0,1.01562 0.28125,1.48437 0.45312,0.73438 1.23437,0.73438 0.625,0 1.07813,-0.54688 0.46875,-0.54687 0.46875,-1.64062 0,-1.10938 -0.4375,-1.64063 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54688 -0.45312,0.54687 -0.45312,1.59375 z m 5.02026,2.89062 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28937,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 8.89521,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path603"
-     d="m 624.8583,872.8643 0,0 c 0,-3.68201 2.9848,-6.66681 6.66681,-6.66681 l 90.72937,0 c 1.76813,0 3.46387,0.70239 4.71417,1.95264 1.25025,1.2503 1.95264,2.94604 1.95264,4.71417 l 0,26.66638 c 0,3.68201 -2.98487,6.66681 -6.66681,6.66681 l -90.72937,0 0,0 c -3.68201,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path605"
-     d="m 624.8583,872.8643 0,0 c 0,-3.68201 2.9848,-6.66681 6.66681,-6.66681 l 90.72937,0 c 1.76813,0 3.46387,0.70239 4.71417,1.95264 1.25025,1.2503 1.95264,2.94604 1.95264,4.71417 l 0,26.66638 c 0,3.68201 -2.98487,6.66681 -6.66681,6.66681 l -90.72937,0 0,0 c -3.68201,0 -6.66681,-2.9848 -6.66681,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path607"
-     d="m 660.21124,887.5063 0.98437,-0.0781 q 0.0625,0.57813 0.3125,0.96875 0.26563,0.375 0.79688,0.60938 0.53125,0.23437 1.20312,0.23437 0.60938,0 1.0625,-0.17187 0.45313,-0.1875 0.67188,-0.48438 0.23437,-0.3125 0.23437,-0.6875 0,-0.375 -0.21875,-0.64062 -0.21875,-0.28125 -0.71875,-0.46875 -0.3125,-0.125 -1.40625,-0.375 -1.07812,-0.26563 -1.51562,-0.5 -0.5625,-0.29688 -0.84375,-0.73438 -0.26563,-0.4375 -0.26563,-0.98437 0,-0.59375 0.32813,-1.10938 0.34375,-0.51562 0.98437,-0.78125 0.65625,-0.28125 1.45313,-0.28125 0.875,0 1.54687,0.29688 0.67188,0.28125 1.03125,0.82812 0.35938,0.54688 0.39063,1.23438 l -1,0.0781 q -0.0781,-0.75 -0.54688,-1.125 -0.46875,-0.39062 -1.375,-0.39062 -0.9375,0 -1.375,0.35937 -0.4375,0.34375 -0.4375,0.82813 0,0.42187 0.3125,0.70312 0.29688,0.26563 1.5625,0.5625 1.28125,0.28125 1.75,0.5 0.6875,0.3125 1.01563,0.79688 0.32812,0.48437 0.32812,1.125 0,0.625 -0.35937,1.1875 -0.35938,0.54687 -1.04688,0.85937 -0.67187,0.3125 -1.51562,0.3125 -1.0625,0 -1.78125,-0.3125 -0.71875,-0.3125 -1.14063,-0.9375 -0.40625,-0.625 -0.42187,-1.42187 z m 9.45142,1.67187 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.57,0.15625 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 2.28589,2.85938 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 5.67359,-0.85938 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.74188,-0.98437 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 8.89527,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z" />
-  <path
-     style="fill:#cfe2f3;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path609"
-     d="m 30.664042,949.78754 0,0 c 0,-3.68195 2.984827,-6.66681 6.666799,-6.66681 l 90.729399,0 c 1.76814,0 3.46387,0.70239 4.71413,1.9527 1.25027,1.25024 1.95267,2.94598 1.95267,4.71411 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.6668,6.66681 l -90.729399,0 0,0 c -3.681972,0 -6.666799,-2.9848 -6.666799,-6.66681 z" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path611"
-     d="m 30.664042,949.78754 0,0 c 0,-3.68195 2.984827,-6.66681 6.666799,-6.66681 l 90.729399,0 c 1.76814,0 3.46387,0.70239 4.71413,1.9527 1.25027,1.25024 1.95267,2.94598 1.95267,4.71411 l 0,26.66638 c 0,3.68201 -2.98484,6.66681 -6.6668,6.66681 l -90.729399,0 0,0 c -3.681972,0 -6.666799,-2.9848 -6.666799,-6.66681 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path613"
-     d="m 61.043064,966.96075 0,-7.875 3.500004,0 q 1.046875,0 1.59375,0.21875 0.546875,0.20312 0.875,0.75 0.328125,0.53125 0.328125,1.1875 0,0.82812 -0.546875,1.40625 -0.53125,0.57812 -1.671875,0.73437 0.421875,0.1875 0.625,0.39063 0.46875,0.42187 0.875,1.04687 l 1.359375,2.14063 -1.296875,0 -1.046875,-1.64063 q -0.453125,-0.70312 -0.75,-1.07812 -0.296875,-0.375 -0.53125,-0.53125 -0.234375,-0.15625 -0.468754,-0.20313 -0.1875,-0.0469 -0.59375,-0.0469 l -1.203125,0 0,3.5 -1.046875,0 z m 1.046875,-4.40625 2.234379,0 q 0.71875,0 1.125,-0.14063 0.40625,-0.14062 0.609375,-0.46875 0.203125,-0.32812 0.203125,-0.70312 0,-0.5625 -0.40625,-0.92188 -0.390625,-0.35937 -1.265625,-0.35937 l -2.500004,0 0,2.59375 z m 10.414356,2.5625 1,0.125 q -0.234375,0.875 -0.875,1.35937 -0.640625,0.48438 -1.625,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 5.176498,3.40625 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.289353,-1.84375 1,0.125 q -0.234375,0.875 -0.875,1.35937 -0.640625,0.48438 -1.625,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 8.926498,2.70312 q -0.546875,0.45313 -1.046875,0.64063 -0.484375,0.1875 -1.0625,0.1875 -0.9375,0 -1.453125,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.203125,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.703125,-0.32813 0.28125,-0.0781 0.859375,-0.14062 1.171875,-0.14063 1.71875,-0.34375 0.01563,-0.1875 0.01563,-0.25 0,-0.59375 -0.28125,-0.82813 -0.359375,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.015625,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.953125,-0.125 q 0.125,-0.60937 0.421875,-0.98437 0.296875,-0.375 0.859375,-0.5625 0.5625,-0.20313 1.296875,-0.20313 0.734375,0 1.1875,0.17188 0.453125,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.04687,0.25 0.04687,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.015625,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.09375,-2.15625 q -0.515625,0.21875 -1.578125,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.234375,0.0937 -0.375,0.3125 -0.140625,0.20313 -0.140625,0.45313 0,0.39062 0.296875,0.65625 0.296875,0.25 0.859375,0.25 0.5625,0 0.984375,-0.25 0.4375,-0.25 0.65625,-0.67188 0.140625,-0.32812 0.140625,-0.96875 l 0,-0.34375 z m 1.910873,1.15625 0.953125,-0.15625 q 0.07813,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.671875,0 0.984375,-0.26562 0.328125,-0.26563 0.328125,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.203125,-0.125 -0.984375,-0.32813 -1.0625,-0.26562 -1.484375,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.203125,-0.34375 -0.203125,-0.76562 0,-0.39063 0.171875,-0.70313 0.171875,-0.32812 0.484375,-0.54687 0.21875,-0.17188 0.609375,-0.28125 0.390625,-0.10938 0.828125,-0.10938 0.671875,0 1.171875,0.1875 0.515625,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.07813,-0.4375 -0.390625,-0.67187 -0.296875,-0.25 -0.859375,-0.25 -0.671875,0 -0.953125,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.109375,0.32813 0.125,0.15625 0.375,0.26562 0.140625,0.0469 0.859375,0.25 1.015625,0.26563 1.421875,0.4375 0.40625,0.17188 0.640625,0.51563 0.234375,0.32812 0.234375,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.203125,0.23438 -1.109375,0 -1.703125,-0.45313 -0.578125,-0.46875 -0.734375,-1.375 z m 9.609375,-0.14062 1,0.125 q -0.234375,0.875 -0.875,1.35937 -0.640625,0.48438 -1.625,0.48438 -1.25,0 -1.984375,-0.76563 -0.734375,-0.76562 -0.734375,-2.15625 0,-1.45312 0.734375,-2.23437 0.75,-0.79688 1.921875,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.04687,0.9375 0.515625,1.4375 0.484375,0.5 1.203125,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.171875,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.359375,-1.07813 -0.46875,-0.54687 -1.203125,-0.54687 -0.671875,0 -1.125,0.45312 -0.453125,0.4375 -0.5,1.17188 z m 8.895253,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path615"
-     d="m 264.9508,856.99133 0,0 c -5.5e-4,-2.15045 -1.24246,-4.2113 -3.44867,-5.72278 -2.20618,-1.51141 -5.19311,-2.34778 -8.29442,-2.32245 l 0.1368,8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path617"
-     d="m 264.9508,856.99133 0,0 c -5.5e-4,-2.15045 -1.24246,-4.2113 -3.44867,-5.72278 -2.20618,-1.51141 -5.19311,-2.34778 -8.29442,-2.32245" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path619"
-     d="m 264.9508,856.99133 0,0 c -5.5e-4,-2.15045 -1.24246,-4.2113 -3.44867,-5.72278 -2.20618,-1.51141 -5.19311,-2.34778 -8.29442,-2.32245" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path621"
-     d="m 116.403,856.4659 0,9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path623"
-     d="m 116.403,856.4659 0,3.7323" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path625"
-     d="m 114.75127,860.1982 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path627"
-     d="m 127.39336,848.93365 0,0 c -2.95698,2.4e-4 -5.78913,0.92212 -7.85683,2.55749 -2.06769,1.63532 -3.19654,3.8462 -3.13157,6.13331 l 10.98948,-0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path629"
-     d="m 127.39336,848.93365 0,0 c -2.95698,2.4e-4 -5.78913,0.92212 -7.85683,2.55749 -2.06769,1.63532 -3.19654,3.8462 -3.13157,6.13331" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path631"
-     d="m 127.39336,848.93365 0,0 c -2.95698,2.4e-4 -5.78913,0.92212 -7.85683,2.55749 -2.06769,1.63532 -3.19654,3.8462 -3.13157,6.13331" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path633"
-     d="m 127.39336,848.93365 125.81436,0.0125" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path635"
-     d="m 127.39336,848.93365 125.81436,0.0125" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path637"
-     d="m 562.04724,925.6575 85.35431,0 0,20.97638 -85.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path639"
-     d="m 579.3069,937.1263 q 0,-1.57812 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.76563 -0.73438,-0.76562 -0.73438,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48438,-0.54688 0.48438,-1.67188 0,-1.04687 -0.48438,-1.59375 -0.48437,-0.54687 -1.1875,-0.54687 -0.73437,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.28589,2.85938 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 5.70776,-2.53125 0.98438,-0.0781 q 0.0625,0.57813 0.3125,0.96875 0.26562,0.375 0.79687,0.60938 0.53125,0.23437 1.20313,0.23437 0.60937,0 1.0625,-0.17187 0.45312,-0.1875 0.67187,-0.48438 0.23438,-0.3125 0.23438,-0.6875 0,-0.375 -0.21875,-0.64062 -0.21875,-0.28125 -0.71875,-0.46875 -0.3125,-0.125 -1.40625,-0.375 -1.07813,-0.26563 -1.51563,-0.5 -0.5625,-0.29688 -0.84375,-0.73438 -0.26562,-0.4375 -0.26562,-0.98437 0,-0.59375 0.32812,-1.10938 0.34375,-0.51562 0.98438,-0.78125 0.65625,-0.28125 1.45312,-0.28125 0.875,0 1.54688,0.29688 0.67187,0.28125 1.03125,0.82812 0.35937,0.54688 0.39062,1.23438 l -1,0.0781 q -0.0781,-0.75 -0.54687,-1.125 -0.46875,-0.39062 -1.375,-0.39062 -0.9375,0 -1.375,0.35937 -0.4375,0.34375 -0.4375,0.82813 0,0.42187 0.3125,0.70312 0.29687,0.26563 1.5625,0.5625 1.28125,0.28125 1.75,0.5 0.6875,0.3125 1.01562,0.79688 0.32813,0.48437 0.32813,1.125 0,0.625 -0.35938,1.1875 -0.35937,0.54687 -1.04687,0.85937 -0.67188,0.3125 -1.51563,0.3125 -1.0625,0 -1.78125,-0.3125 -0.71875,-0.3125 -1.14062,-0.9375 -0.40625,-0.625 -0.42188,-1.42187 z m 9.45136,1.67187 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.47625,-2 q 0,-1.57812 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.76563 -0.73438,-0.76562 -0.73438,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48438,-0.54688 0.48438,-1.67188 0,-1.04687 -0.48438,-1.59375 -0.48437,-0.54687 -1.1875,-0.54687 -0.73437,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.28589,5.04688 0,-7.89063 0.89063,0 0,0.73438 q 0.3125,-0.42188 0.70312,-0.64063 0.39063,-0.21875 0.95313,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.92188,1.0625 -0.59375,0.375 -1.25,0.375 -0.48437,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45313,1.625 0.45312,0.51562 1.07812,0.51562 0.64063,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.45312,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.10938,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 5.05152,5 0,-7.89063 0.89062,0 0,0.73438 q 0.3125,-0.42188 0.70313,-0.64063 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51562 1.07813,0.51562 0.64062,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.45313,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.10937,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 8.95776,0.96875 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89526,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57819,-0.375 -0.89069,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85944,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04694,-2.84375 q 0,1.09375 0.45319,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42194,0.51562 -0.42194,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path641"
-     d="m 264.95102,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19315,-2.34778 8.29443,-2.32245 l -0.13678,8.0467 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path643"
-     d="m 264.95102,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19315,-2.34778 8.29443,-2.32245" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path645"
-     d="m 264.95102,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19315,-2.34778 8.29443,-2.32245" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path647"
-     d="m 264.95102,856.9887 0,9.32281" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path649"
-     d="m 264.95102,856.9887 0,9.32281" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path651"
-     d="m 346.08417,856.46326 0,9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path653"
-     d="m 346.08417,856.46326 0,3.7323" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path655"
-     d="m 344.43243,860.19556 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path657"
-     d="m 335.09378,848.931 0,0 c 2.957,2.4e-4 5.78915,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333 l -10.98947,-0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path659"
-     d="m 335.09378,848.931 0,0 c 2.957,2.4e-4 5.78915,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path661"
-     d="m 335.09378,848.931 0,0 c 2.957,2.4e-4 5.78915,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path663"
-     d="m 335.09378,848.931 -58.39966,0.0124" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path665"
-     d="m 335.09378,848.931 -58.39966,0.0124" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path667"
-     d="m 413.49976,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19311,-2.34778 8.29443,-2.32245 l -0.13681,8.0467 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path669"
-     d="m 413.49976,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19311,-2.34778 8.29443,-2.32245" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path671"
-     d="m 413.49976,856.9887 0,0 c 5.8e-4,-2.15045 1.24249,-4.2113 3.44867,-5.72278 2.20621,-1.51141 5.19311,-2.34778 8.29443,-2.32245" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path673"
-     d="m 413.49976,856.9887 0,9.32281" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path675"
-     d="m 413.49976,856.9887 0,9.32281" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path677"
-     d="m 494.63287,856.46326 0,9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path679"
-     d="m 494.63287,856.46326 0,3.7323" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path681"
-     d="m 492.98114,860.19556 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path683"
-     d="m 483.64252,848.931 0,0 c 2.95697,2.4e-4 5.78912,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333 l -10.98947,-0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path685"
-     d="m 483.64252,848.931 0,0 c 2.95697,2.4e-4 5.78912,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path687"
-     d="m 483.64252,848.931 0,0 c 2.95697,2.4e-4 5.78912,0.92212 7.85684,2.5575 2.06769,1.63531 3.19654,3.84619 3.13156,6.1333" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path689"
-     d="m 483.64252,848.931 -58.39966,0.0124" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path691"
-     d="m 483.64252,848.931 -58.39966,0.0124" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path693"
-     d="m 562.0485,856.9887 0,0 c 5.5e-4,-2.15045 1.24243,-4.2113 3.44861,-5.72278 2.20624,-1.51141 5.19317,-2.34778 8.29443,-2.32245 l -0.13678,8.0467 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path695"
-     d="m 562.0485,856.9887 0,0 c 5.5e-4,-2.15045 1.24243,-4.2113 3.44861,-5.72278 2.20624,-1.51141 5.19317,-2.34778 8.29443,-2.32245" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path697"
-     d="m 562.0485,856.9887 0,0 c 5.5e-4,-2.15045 1.24243,-4.2113 3.44861,-5.72278 2.20624,-1.51141 5.19317,-2.34778 8.29443,-2.32245" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path699"
-     d="m 562.0485,856.9887 0,9.32281" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path701"
-     d="m 562.0485,856.9887 0,9.32281" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path703"
-     d="m 643.18164,856.46326 0,9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path705"
-     d="m 643.1816,856.46326 0,3.7323" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path707"
-     d="m 641.52985,860.19556 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path709"
-     d="m 632.1912,848.931 0,0 c 2.95703,2.4e-4 5.78918,0.92212 7.85687,2.5575 2.06769,1.63531 3.19654,3.84619 3.13153,6.1333 l -10.98944,-0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path711"
-     d="m 632.1912,848.931 0,0 c 2.95703,2.4e-4 5.78918,0.92212 7.85687,2.5575 2.06769,1.63531 3.19654,3.84619 3.13153,6.1333" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path713"
-     d="m 632.1912,848.931 0,0 c 2.95703,2.4e-4 5.78918,0.92212 7.85687,2.5575 2.06769,1.63531 3.19654,3.84619 3.13153,6.1333" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path715"
-     d="m 632.1912,848.931 -58.39966,0.0124" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path717"
-     d="m 632.1912,848.931 -58.39966,0.0124" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path719"
-     d="m 643.1823,916.561 0,0 c -5.5e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20618,1.51147 -5.19311,2.34784 -8.29443,2.32251 l 0.13678,-8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path721"
-     d="m 643.1823,916.561 0,0 c -5.5e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20618,1.51147 -5.19311,2.34784 -8.29443,2.32251" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path723"
-     d="m 643.1823,916.561 0,0 c -5.5e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20618,1.51147 -5.19311,2.34784 -8.29443,2.32251" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path725"
-     d="m 643.1823,916.561 0,-9.32281" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path727"
-     d="m 643.1823,916.561 0,-9.32281" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path729"
-     d="m 562.0492,917.0864 0,-9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path731"
-     d="m 562.0492,917.0864 0,-3.73224" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path733"
-     d="m 563.7009,913.3542 -1.65173,-4.53815 -1.65174,4.53815 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path735"
-     d="m 573.03955,924.61865 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85681,-2.5575 -2.06775,-1.63537 -3.19653,-3.84625 -3.13159,-6.1333 l 10.9895,0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path737"
-     d="m 573.03955,924.61865 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85681,-2.5575 -2.06775,-1.63537 -3.19653,-3.84625 -3.13159,-6.1333" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path739"
-     d="m 573.03955,924.61865 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85681,-2.5575 -2.06775,-1.63537 -3.19653,-3.84625 -3.13159,-6.1333" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path741"
-     d="m 573.03955,924.61865 58.39368,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path743"
-     d="m 573.03955,924.61865 58.39368,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path745"
-     d="m 494.63428,916.5636 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251 l 0.13678,-8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path747"
-     d="m 494.63428,916.5636 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path749"
-     d="m 494.63428,916.5636 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path751"
-     d="m 494.63428,916.5636 0,-9.32282" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path753"
-     d="m 494.63428,916.5636 0,-9.32282" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path755"
-     d="m 413.50116,917.08905 0,-9.7323" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path757"
-     d="m 413.50116,917.08905 0,-3.73224" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path759"
-     d="m 415.1529,913.3568 -1.65173,-4.53815 -1.65174,4.53815 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path761"
-     d="m 424.49152,924.6213 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85684,-2.5575 -2.06769,-1.63537 -3.19654,-3.84625 -3.13156,-6.1333 l 10.98947,0.18683 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path763"
-     d="m 424.49152,924.6213 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85684,-2.5575 -2.06769,-1.63537 -3.19654,-3.84625 -3.13156,-6.1333" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path765"
-     d="m 424.49152,924.6213 0,0 c -2.95697,-2.4e-4 -5.78912,-0.92212 -7.85684,-2.5575 -2.06769,-1.63537 -3.19654,-3.84625 -3.13156,-6.1333" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path767"
-     d="m 424.49152,924.6213 58.39371,0" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path769"
-     d="m 424.49152,924.6213 58.39371,0" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path771"
-     d="m 411.38977,924.6181 85.35431,0 0,20.97638 -85.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path773"
-     d="m 427.76746,936.0869 q 0,-1.57812 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.76563 -0.73438,-0.76562 -0.73438,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48438,-0.54688 0.48438,-1.67188 0,-1.04687 -0.48438,-1.59375 -0.48437,-0.54687 -1.1875,-0.54687 -0.73437,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.28589,2.85938 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 6.05148,0 0,-7.875 2.71875,0 q 0.92188,0 1.40625,0.10937 0.67188,0.15625 1.15625,0.5625 0.60938,0.53125 0.92188,1.35938 0.3125,0.8125 0.3125,1.85937 0,0.90625 -0.21875,1.59375 -0.20313,0.6875 -0.53125,1.14063 -0.32813,0.45312 -0.71875,0.71875 -0.39063,0.26562 -0.9375,0.40625 -0.54688,0.125 -1.26563,0.125 l -2.84375,0 z m 1.04688,-0.92188 1.6875,0 q 0.76562,0 1.20312,-0.14062 0.45313,-0.15625 0.71875,-0.42188 0.375,-0.375 0.57813,-1 0.20312,-0.625 0.20312,-1.51562 0,-1.23438 -0.40625,-1.89063 -0.40625,-0.67187 -0.98437,-0.89062 -0.42188,-0.15625 -1.34375,-0.15625 l -1.65625,0 0,6.01562 z m 6.53936,-5.84375 0,-1.10937 0.96875,0 0,1.10937 -0.96875,0 z m 0,6.76563 0,-5.70313 0.96875,0 0,5.70313 -0.96875,0 z m 1.97684,-1.70313 0.95313,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67187,0 0.98437,-0.26562 0.32813,-0.26563 0.32813,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20313,-0.125 -0.98438,-0.32813 -1.0625,-0.26562 -1.48437,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20313,-0.34375 -0.20313,-0.76562 0,-0.39063 0.17188,-0.70313 0.17187,-0.32812 0.48437,-0.54687 0.21875,-0.17188 0.60938,-0.28125 0.39062,-0.10938 0.82812,-0.10938 0.67188,0 1.17188,0.1875 0.51562,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39063,-0.67187 -0.29687,-0.25 -0.85937,-0.25 -0.67188,0 -0.95313,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10938,0.32813 0.125,0.15625 0.375,0.26562 0.14062,0.0469 0.85937,0.25 1.01563,0.26563 1.42188,0.4375 0.40625,0.17188 0.64062,0.51563 0.23438,0.32812 0.23438,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20313,0.23438 -1.10937,0 -1.70312,-0.45313 -0.57813,-0.46875 -0.73438,-1.375 z m 9.4375,1 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 3.17652,2.85938 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76563 1.5625,-0.76563 0.53125,0 1,0.21875 0.46875,0.20313 0.76563,0.59375 0.3125,0.375 0.48437,0.92188 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26562 -0.71875,0.79688 -1.73437,0.79688 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89063 q 0,1.01563 0.28125,1.48438 0.45312,0.73437 1.23437,0.73437 0.625,0 1.07813,-0.54687 0.46875,-0.54688 0.46875,-1.64063 0,-1.10937 -0.4375,-1.64062 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54687 -0.45312,0.54688 -0.45312,1.59375 z m 5.02023,2.89063 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28937,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 8.89523,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29687,-0.70312 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42187,0.51562 -0.42187,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path775"
-     d="m 411.38715,826.8018 85.35431,0 0,20.97638 -85.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path777"
-     d="m 428.9434,838.2706 q 0,-1.57813 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76562 0.75,0.76563 0.75,2.125 0,1.10938 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76562 -0.73437,-0.76563 -0.73437,-2.21875 z m 1,0 q 0,1.10937 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54688 0.48437,-0.54687 0.48437,-1.67187 0,-1.04688 -0.48437,-1.59375 -0.48438,-0.54688 -1.1875,-0.54688 -0.73438,0 -1.21875,0.54688 -0.46875,0.53125 -0.46875,1.625 z m 5.28586,2.85937 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z m 6.08276,0 0,-7.875 5.6875,0 0,0.9375 -4.65625,0 0,2.40625 4.35938,0 0,0.92188 -4.35938,0 0,2.6875 4.84375,0 0,0.92187 -5.875,0 z m 6.95139,0 0,-5.70312 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17187 0.64063,0.48437 0.21875,0.29688 0.3125,0.70313 0.0469,0.28125 0.0469,0.95312 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29687 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39063 -0.45312,0.39062 -0.45312,1.5 l 0,3.10937 -0.96875,0 z m 9.66086,-0.70312 q -0.54688,0.45312 -1.04688,0.64062 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45312 -0.5,-0.46875 -0.5,-1.17188 0,-0.42187 0.1875,-0.76562 0.20312,-0.34375 0.5,-0.54688 0.3125,-0.21875 0.70312,-0.32812 0.28125,-0.0781 0.85938,-0.14063 1.17187,-0.14062 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82812 -0.35937,-0.32813 -1.09375,-0.32813 -0.6875,0 -1.01562,0.23438 -0.3125,0.23437 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60938 0.42188,-0.98438 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20312 1.29688,-0.20312 0.73437,0 1.1875,0.17187 0.45312,0.17188 0.65625,0.4375 0.21875,0.25 0.3125,0.64063 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70312 0.0625,0.35938 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29687 -0.1875,-0.70312 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35937 -0.59375,0.0937 -0.84375,0.20313 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20312 -0.14062,0.45312 0,0.39063 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67187 0.14063,-0.32813 0.14063,-0.96875 l 0,-0.34375 z m 3.17651,2.85937 -0.89063,0 0,-7.875 0.96875,0 0,2.8125 q 0.60938,-0.76562 1.5625,-0.76562 0.53125,0 1,0.21875 0.46875,0.20312 0.76563,0.59375 0.3125,0.375 0.48437,0.92187 0.17188,0.53125 0.17188,1.15625 0,1.46875 -0.73438,2.26563 -0.71875,0.79687 -1.73437,0.79687 -1.01563,0 -1.59375,-0.84375 l 0,0.71875 z m 0,-2.89062 q 0,1.01562 0.28125,1.48437 0.45312,0.73438 1.23437,0.73438 0.625,0 1.07813,-0.54688 0.46875,-0.54687 0.46875,-1.64062 0,-1.10938 -0.4375,-1.64063 -0.4375,-0.53125 -1.07813,-0.53125 -0.625,0 -1.09375,0.54688 -0.45312,0.54687 -0.45312,1.59375 z m 5.02023,2.89062 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28937,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35938 -0.64063,0.48437 -1.625,0.48437 -1.25,0 -1.98438,-0.76562 -0.73437,-0.76563 -0.73437,-2.15625 0,-1.45313 0.73437,-2.23438 0.75,-0.79687 1.92188,-0.79687 1.15625,0 1.875,0.78125 0.71875,0.76562 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26563 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07812 -0.46875,-0.54688 -1.20313,-0.54688 -0.67187,0 -1.125,0.45313 -0.45312,0.4375 -0.5,1.17187 z m 8.89524,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04687 -0.3125,-0.67188 -0.3125,-1.54688 0,-0.85937 0.28125,-1.54687 0.29688,-0.70313 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82813 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64063 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51563 0.4375,-0.51562 0.4375,-1.57812 0,-1.17188 -0.45312,-1.71875 -0.4375,-0.54688 -1.10938,-0.54688 -0.64062,0 -1.07812,0.53125 -0.42188,0.51563 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path779"
-     d="m 557.521,825.76245 85.35431,0 0,20.97638 -85.35431,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path781"
-     d="m 577.4525,837.23126 q 0,-1.57812 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76563 -0.73437,-0.76562 -0.73437,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48437,-0.54688 0.48437,-1.67188 0,-1.04687 -0.48437,-1.59375 -0.48438,-0.54687 -1.1875,-0.54687 -0.73438,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.28589,2.85938 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51562,0 0.95312,0.1875 0.4375,0.17188 0.64063,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10937,-0.875 -0.10938,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67188,-0.1875 -0.60937,0 -1.0625,0.39062 -0.45312,0.39063 -0.45312,1.5 l 0,3.10938 -0.96875,0 z m 5.70776,-2.53125 0.98438,-0.0781 q 0.0625,0.57813 0.3125,0.96875 0.26562,0.375 0.79687,0.60938 0.53125,0.23437 1.20313,0.23437 0.60937,0 1.0625,-0.17187 0.45312,-0.1875 0.67187,-0.48438 0.23438,-0.3125 0.23438,-0.6875 0,-0.375 -0.21875,-0.64062 -0.21875,-0.28125 -0.71875,-0.46875 -0.3125,-0.125 -1.40625,-0.375 -1.07813,-0.26563 -1.51563,-0.5 -0.5625,-0.29688 -0.84375,-0.73438 -0.26562,-0.4375 -0.26562,-0.98437 0,-0.59375 0.32812,-1.10938 0.34375,-0.51562 0.98438,-0.78125 0.65625,-0.28125 1.45312,-0.28125 0.875,0 1.54688,0.29688 0.67187,0.28125 1.03125,0.82812 0.35937,0.54688 0.39062,1.23438 l -1,0.0781 q -0.0781,-0.75 -0.54687,-1.125 -0.46875,-0.39062 -1.375,-0.39062 -0.9375,0 -1.375,0.35937 -0.4375,0.34375 -0.4375,0.82813 0,0.42187 0.3125,0.70312 0.29687,0.26563 1.5625,0.5625 1.28125,0.28125 1.75,0.5 0.6875,0.3125 1.01562,0.79688 0.32813,0.48437 0.32813,1.125 0,0.625 -0.35938,1.1875 -0.35937,0.54687 -1.04687,0.85937 -0.67188,0.3125 -1.51563,0.3125 -1.0625,0 -1.78125,-0.3125 -0.71875,-0.3125 -1.14062,-0.9375 -0.40625,-0.625 -0.42188,-1.42187 z m 9.45136,1.67187 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.57,0.15625 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 2.28589,2.85938 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 5.67365,-0.85938 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.74188,-0.98437 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89526,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path783"
-     d="m 103.57747,826.8018 250.17323,0 0,20.97638 -250.17323,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path785"
-     d="m 125.28249,841.13 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z m 4.91087,-0.0156 q 0,-1.57812 0.89063,-2.34375 0.73437,-0.625 1.79687,-0.625 1.17188,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32812,1.75 -0.32813,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35938,0.34375 -1.20312,0 -1.95312,-0.76563 -0.73438,-0.76562 -0.73438,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48438,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48438,-0.54688 0.48438,-1.67188 0,-1.04687 -0.48438,-1.59375 -0.48437,-0.54687 -1.1875,-0.54687 -0.73437,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.41088,2.85938 0,-7.875 2.96875,0 q 0.79687,0 1.20312,0.0781 0.57813,0.0937 0.96875,0.375 0.39063,0.26563 0.625,0.75 0.25,0.48438 0.25,1.07813 0,1 -0.64062,1.70312 -0.64063,0.6875 -2.3125,0.6875 l -2.01563,0 0,3.20313 -1.04687,0 z m 1.04687,-4.125 2.03125,0 q 1.01563,0 1.4375,-0.375 0.42188,-0.375 0.42188,-1.0625 0,-0.5 -0.25,-0.84375 -0.25,-0.35938 -0.65625,-0.46875 -0.26563,-0.0625 -0.96875,-0.0625 l -2.01563,0 0,2.8125 z m 5.93576,4.125 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 5.19213,5.59375 0,-7.89063 0.89062,0 0,0.73438 q 0.3125,-0.42188 0.70313,-0.64063 0.39062,-0.21875 0.95312,-0.21875 0.71875,0 1.28125,0.375 0.5625,0.375 0.84375,1.0625 0.28125,0.67188 0.28125,1.5 0,0.875 -0.3125,1.57813 -0.3125,0.6875 -0.92187,1.0625 -0.59375,0.375 -1.25,0.375 -0.48438,0 -0.875,-0.20313 -0.375,-0.20312 -0.625,-0.51562 l 0,2.78125 -0.96875,0 z m 0.875,-5 q 0,1.09375 0.45312,1.625 0.45313,0.51562 1.07813,0.51562 0.64062,0 1.09375,-0.53125 0.46875,-0.54687 0.46875,-1.70312 0,-1.07813 -0.45313,-1.625 -0.4375,-0.54688 -1.0625,-0.54688 -0.625,0 -1.10937,0.57813 -0.46875,0.57812 -0.46875,1.6875 z m 8.78587,2.10937 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 2.28587,2.85938 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45487,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 10.01215,5.71875 q -0.8125,-1 -1.35938,-2.35938 -0.54687,-1.35937 -0.54687,-2.8125 0,-1.26562 0.40625,-2.4375 0.48437,-1.35937 1.5,-2.71875 l 0.6875,0 q -0.65625,1.125 -0.85938,1.60938 -0.32812,0.73437 -0.51562,1.54687 -0.23438,1 -0.23438,2.01563 0,2.57812 1.60938,5.15625 l -0.6875,0 z m 1.68924,-2.3125 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 7.45486,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 7.31712,2.54687 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 4.58565,0.85938 0,-0.84375 q -0.67188,0.96875 -1.8125,0.96875 -0.5,0 -0.95313,-0.1875 -0.4375,-0.20313 -0.65625,-0.48438 -0.20312,-0.29687 -0.28125,-0.71875 -0.0625,-0.28125 -0.0625,-0.90625 l 0,-3.53125 0.96875,0 0,3.15625 q 0,0.76563 0.0625,1.03125 0.0937,0.375 0.375,0.59375 0.29688,0.21875 0.73438,0.21875 0.4375,0 0.8125,-0.21875 0.39062,-0.23437 0.54687,-0.60937 0.15625,-0.39063 0.15625,-1.10938 l 0,-3.0625 0.96875,0 0,5.70313 -0.85937,0 z m 2.1765,0 0,-5.70313 0.85937,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60938,-0.1875 0.5,0 1,0.3125 l -0.32813,0.89063 q -0.35937,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35937,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.54861,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 10.4809,0 -2.17188,-5.70313 1.01563,0 1.23437,3.42188 q 0.1875,0.54687 0.35938,1.14062 0.125,-0.45312 0.35937,-1.07812 l 1.26563,-3.48438 1,0 -2.15625,5.70313 -0.90625,0 z m 7.46875,-0.70313 q -0.54688,0.45313 -1.04688,0.64063 -0.48437,0.1875 -1.0625,0.1875 -0.9375,0 -1.45312,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20312,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70312,-0.32813 0.28125,-0.0781 0.85938,-0.14062 1.17187,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35937,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01562,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95313,-0.125 q 0.125,-0.60937 0.42188,-0.98437 0.29687,-0.375 0.85937,-0.5625 0.5625,-0.20313 1.29688,-0.20313 0.73437,0 1.1875,0.17188 0.45312,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01562,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51563,0.21875 -1.57813,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23437,0.0937 -0.375,0.3125 -0.14062,0.20313 -0.14062,0.45313 0,0.39062 0.29687,0.65625 0.29688,0.25 0.85938,0.25 0.5625,0 0.98437,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14063,-0.32812 0.14063,-0.96875 l 0,-0.34375 z m 2.27025,2.85938 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.1331,0 0,-0.84375 q -0.67188,0.96875 -1.8125,0.96875 -0.5,0 -0.95313,-0.1875 -0.4375,-0.20313 -0.65625,-0.48438 -0.20312,-0.29687 -0.28125,-0.71875 -0.0625,-0.28125 -0.0625,-0.90625 l 0,-3.53125 0.96875,0 0,3.15625 q 0,0.76563 0.0625,1.03125 0.0937,0.375 0.375,0.59375 0.29688,0.21875 0.73438,0.21875 0.4375,0 0.8125,-0.21875 0.39062,-0.23437 0.54687,-0.60937 0.15625,-0.39063 0.15625,-1.10938 l 0,-3.0625 0.96875,0 0,5.70313 -0.85937,0 z m 6.08275,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 11.8559,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67188,0 -1.25,-0.375 -0.57813,-0.375 -0.89063,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29688,-0.70312 0.85938,-1.0625 0.5625,-0.375 1.26562,-0.375 0.51563,0 0.92188,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04688,-2.84375 q 0,1.09375 0.45313,1.64062 0.46875,0.53125 1.09375,0.53125 0.64062,0 1.07812,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45312,-1.71875 -0.4375,-0.54687 -1.10938,-0.54687 -0.64062,0 -1.07812,0.53125 -0.42188,0.51562 -0.42188,1.65625 z m 9.1765,1 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 7.31712,2.54687 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.7419,-0.98437 0.99998,0.125 q -0.23437,0.875 -0.87498,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.87498,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.24998,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 5.19212,3.40625 0,-5.70313 0.85938,0 0,0.85938 q 0.34375,-0.60938 0.625,-0.79688 0.28125,-0.1875 0.60937,-0.1875 0.5,0 1,0.3125 l -0.32812,0.89063 q -0.35938,-0.20313 -0.71875,-0.20313 -0.3125,0 -0.5625,0.1875 -0.25,0.1875 -0.35938,0.53125 -0.15625,0.51563 -0.15625,1.125 l 0,2.98438 -0.96875,0 z m 3.54862,0 0,-5.70313 0.875,0 0,0.79688 q 0.26562,-0.42188 0.70312,-0.67188 0.45313,-0.25 1.01563,-0.25 0.64062,0 1.04687,0.26563 0.40625,0.25 0.57813,0.73437 0.67187,-1 1.75,-1 0.85937,0 1.3125,0.46875 0.45312,0.46875 0.45312,1.4375 l 0,3.92188 -0.95312,0 0,-3.59375 q 0,-0.57813 -0.0937,-0.82813 -0.0937,-0.26562 -0.34375,-0.42187 -0.25,-0.15625 -0.57813,-0.15625 -0.60937,0 -1.01562,0.40625 -0.39063,0.40625 -0.39063,1.28125 l 0,3.3125 -0.96875,0 0,-3.70313 q 0,-0.64062 -0.23437,-0.96875 -0.23438,-0.32812 -0.76563,-0.32812 -0.40625,0 -0.76562,0.21875 -0.34375,0.21875 -0.5,0.64062 -0.15625,0.40625 -0.15625,1.1875 l 0,2.95313 -0.96875,0 z m 8.89236,-6.76563 0,-1.10937 0.96875,0 0,1.10937 -0.96875,0 z m 0,6.76563 0,-5.70313 0.96875,0 0,5.70313 -0.96875,0 z m 2.35184,0 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 9.83276,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 4.81711,1.70312 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 10.78879,0.84375 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 0.83563,0.85938 0,-7.875 0.96875,0 0,2.82812 q 0.6875,-0.78125 1.71875,-0.78125 0.625,0 1.09375,0.25 0.46875,0.25 0.67187,0.6875 0.20313,0.4375 0.20313,1.28125 l 0,3.60938 -0.96875,0 0,-3.60938 q 0,-0.73437 -0.3125,-1.0625 -0.3125,-0.32812 -0.89063,-0.32812 -0.4375,0 -0.8125,0.21875 -0.375,0.21875 -0.54687,0.60937 -0.15625,0.375 -0.15625,1.04688 l 0,3.125 -0.96875,0 z m 9.83276,-1.84375 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 7.77777,1.70312 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 7.82812,0.84375 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82812,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10938,-0.26563 -0.10938,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95313,-0.59375 0,2 0.98437,0 0,0.75 -0.98437,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17188,0.1875 0.125,0.0625 0.32812,0.0625 0.17188,0 0.4375,-0.0312 z m 4.57001,0.15625 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 4.41089,2 0.125,0.84375 q -0.40625,0.0937 -0.71875,0.0937 -0.53125,0 -0.82813,-0.17187 -0.28125,-0.17188 -0.40625,-0.4375 -0.10937,-0.26563 -0.10937,-1.14063 l 0,-3.28125 -0.71875,0 0,-0.75 0.71875,0 0,-1.40625 0.95312,-0.59375 0,2 0.98438,0 0,0.75 -0.98438,0 0,3.34375 q 0,0.40625 0.0469,0.53125 0.0625,0.10938 0.17187,0.1875 0.125,0.0625 0.32813,0.0625 0.17187,0 0.4375,-0.0312 z m 4.74188,-0.98437 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.83276,5.71875 -0.6875,0 q 1.59375,-2.57813 1.59375,-5.15625 0,-1.01563 -0.21875,-2 -0.1875,-0.8125 -0.51562,-1.54688 -0.20313,-0.48437 -0.85938,-1.625 l 0.6875,0 q 1.01563,1.35938 1.5,2.71875 0.40625,1.17188 0.40625,2.4375 0,1.45313 -0.5625,2.8125 -0.54687,1.35938 -1.34375,2.35938 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path787"
-     d="m 236.76184,856.99133 0,0 c 5.6e-4,-2.15045 1.24248,-4.2113 3.44867,-5.72278 2.20619,-1.51141 5.19311,-2.34778 8.29443,-2.32245 l -0.13681,8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path789"
-     d="m 236.76184,856.99133 0,0 c 5.6e-4,-2.15045 1.24248,-4.2113 3.44867,-5.72278 2.20619,-1.51141 5.19311,-2.34778 8.29443,-2.32245" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path791"
-     d="m 236.76184,856.99133 0,0 c 5.6e-4,-2.15045 1.24248,-4.2113 3.44867,-5.72278 2.20619,-1.51141 5.19311,-2.34778 8.29443,-2.32245" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path793"
-     d="m 236.78305,856.6685 0,9.32281" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path795"
-     d="m 236.78305,856.66846 0,3.32288" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path797"
-     d="m 235.13132,859.99133 1.65173,4.53809 1.65174,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path799"
-     d="m 82.69554,906.1975 0,36.92322" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path801"
-     d="m 82.69554,906.1975 0,30.92322" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path803"
-     d="m 81.04381,937.1207 1.651733,4.53809 1.651726,-4.53809 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path805"
-     d="m 134.72704,963.1207 199.61427,10e-4" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path807"
-     d="m 140.72704,963.1207 193.61424,10e-4" />
-  <path
-     style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt"
-     inkscape:connector-curvature="0"
-     id="path809"
-     d="m 140.72705,961.46906 -4.53812,1.65167 4.53809,1.6518 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path811"
-     d="m 346.0844,955.0767 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251 l 0.13678,-8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path813"
-     d="m 346.0844,955.0767 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path815"
-     d="m 346.0844,955.0767 0,0 c -5.8e-4,2.15045 -1.24249,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19315,2.34784 -8.29443,2.32251" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path817"
-     d="m 346.08398,955.0486 0,-48.8504" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path819"
-     d="m 346.08398,955.0486 0,-48.8504" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path821"
-     d="m 196.17102,955.0767 0,0 c -5.6e-4,2.15045 -1.24248,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19313,2.34784 -8.29443,2.32251 l 0.13679,-8.04669 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path823"
-     d="m 196.17102,955.0767 0,0 c -5.6e-4,2.15045 -1.24248,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19313,2.34784 -8.29443,2.32251" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path825"
-     d="m 196.17102,955.0767 0,0 c -5.6e-4,2.15045 -1.24248,4.2113 -3.44867,5.72272 -2.20621,1.51147 -5.19313,2.34784 -8.29443,2.32251" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path827"
-     d="m 196.17102,955.0767 0,-48.44092" />
-  <path
-     style="stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round"
-     inkscape:connector-curvature="0"
-     id="path829"
-     d="m 196.17102,955.0767 0,-48.44092" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path831"
-     d="m 140.27953,963.1221 85.35434,0 0,20.97638 -85.35434,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path833"
-     d="m 154.87772,974.5909 q 0,-1.57812 0.89062,-2.34375 0.73438,-0.625 1.79688,-0.625 1.17187,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.32813,1.75 -0.32812,0.625 -0.96875,0.96875 -0.625,0.34375 -1.35937,0.34375 -1.20313,0 -1.95313,-0.76563 -0.73437,-0.76562 -0.73437,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.48437,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.48437,-0.54688 0.48437,-1.67188 0,-1.04687 -0.48437,-1.59375 -0.48438,-0.54687 -1.1875,-0.54687 -0.73438,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.28587,2.85938 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.8125,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.60938,0 -1.0625,0.39062 -0.45313,0.39063 -0.45313,1.5 l 0,3.10938 -0.96875,0 z m 6.06713,0 0,-7.875 3.5,0 q 1.04687,0 1.59375,0.21875 0.54687,0.20312 0.875,0.75 0.32812,0.53125 0.32812,1.1875 0,0.82812 -0.54687,1.40625 -0.53125,0.57812 -1.67188,0.73437 0.42188,0.1875 0.625,0.39063 0.46875,0.42187 0.875,1.04687 l 1.35938,2.14063 -1.29688,0 -1.04687,-1.64063 q -0.45313,-0.70312 -0.75,-1.07812 -0.29688,-0.375 -0.53125,-0.53125 -0.23438,-0.15625 -0.46875,-0.20313 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20313,0 0,3.5 -1.04687,0 z m 1.04687,-4.40625 2.23438,0 q 0.71875,0 1.125,-0.14063 0.40625,-0.14062 0.60937,-0.46875 0.20313,-0.32812 0.20313,-0.70312 0,-0.5625 -0.40625,-0.92188 -0.39063,-0.35937 -1.26563,-0.35937 l -2.5,0 0,2.59375 z m 10.41435,2.5625 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.1765,3.40625 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 8.9265,2.70312 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 1.91088,1.15625 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 9.60937,-0.14062 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89524,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29687,-0.70312 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42187,0.51562 -0.42187,1.65625 z" />
-  <path
-     style="fill:#000000;fill-opacity:0;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path835"
-     d="m 76.66535,914.17194 85.35433,0 0,20.97638 -85.35433,0 z" />
-  <path
-     style="fill:#000000;fill-rule:nonzero"
-     inkscape:connector-curvature="0"
-     id="path837"
-     d="m 91.26355,925.64075 q 0,-1.57812 0.890625,-2.34375 0.734375,-0.625 1.796875,-0.625 1.171875,0 1.90625,0.76563 0.75,0.76562 0.75,2.125 0,1.10937 -0.328125,1.75 -0.328125,0.625 -0.96875,0.96875 -0.625,0.34375 -1.359375,0.34375 -1.203125,0 -1.953125,-0.76563 -0.734375,-0.76562 -0.734375,-2.21875 z m 1,0 q 0,1.10938 0.46875,1.65625 0.484375,0.53125 1.21875,0.53125 0.71875,0 1.1875,-0.54687 0.484375,-0.54688 0.484375,-1.67188 0,-1.04687 -0.484375,-1.59375 -0.484375,-0.54687 -1.1875,-0.54687 -0.734375,0 -1.21875,0.54687 -0.46875,0.53125 -0.46875,1.625 z m 5.285873,2.85938 0,-5.70313 0.875,0 0,0.8125 q 0.625,-0.9375 1.812497,-0.9375 0.51563,0 0.95313,0.1875 0.4375,0.17188 0.64062,0.48438 0.21875,0.29687 0.3125,0.70312 0.0469,0.28125 0.0469,0.95313 l 0,3.5 -0.96875,0 0,-3.46875 q 0,-0.59375 -0.10938,-0.875 -0.10937,-0.29688 -0.40625,-0.46875 -0.28125,-0.1875 -0.67187,-0.1875 -0.609377,0 -1.062502,0.39062 -0.453125,0.39063 -0.453125,1.5 l 0,3.10938 -0.96875,0 z m 6.067127,0 0,-7.875 3.5,0 q 1.04687,0 1.59375,0.21875 0.54687,0.20312 0.875,0.75 0.32812,0.53125 0.32812,1.1875 0,0.82812 -0.54687,1.40625 -0.53125,0.57812 -1.67188,0.73437 0.42188,0.1875 0.625,0.39063 0.46875,0.42187 0.875,1.04687 l 1.35938,2.14063 -1.29688,0 -1.04687,-1.64063 q -0.45313,-0.70312 -0.75,-1.07812 -0.29688,-0.375 -0.53125,-0.53125 -0.23438,-0.15625 -0.46875,-0.20313 -0.1875,-0.0469 -0.59375,-0.0469 l -1.20313,0 0,3.5 -1.04687,0 z m 1.04687,-4.40625 2.23438,0 q 0.71875,0 1.125,-0.14063 0.40625,-0.14062 0.60937,-0.46875 0.20313,-0.32812 0.20313,-0.70312 0,-0.5625 -0.40625,-0.92188 -0.39063,-0.35937 -1.26563,-0.35937 l -2.5,0 0,2.59375 z m 10.41435,2.5625 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 5.1765,3.40625 0,-7.875 0.96875,0 0,7.875 -0.96875,0 z m 6.28935,-1.84375 1,0.125 q -0.23438,0.875 -0.875,1.35937 -0.64063,0.48438 -1.625,0.48438 -1.25,0 -1.98438,-0.76563 -0.73437,-0.76562 -0.73437,-2.15625 0,-1.45312 0.73437,-2.23437 0.75,-0.79688 1.92188,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51562,1.4375 0.48438,0.5 1.20313,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17188,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35937,-1.07813 -0.46875,-0.54687 -1.20313,-0.54687 -0.67187,0 -1.125,0.45312 -0.45312,0.4375 -0.5,1.17188 z m 8.9265,2.70312 q -0.54687,0.45313 -1.04687,0.64063 -0.48438,0.1875 -1.0625,0.1875 -0.9375,0 -1.45313,-0.45313 -0.5,-0.46875 -0.5,-1.17187 0,-0.42188 0.1875,-0.76563 0.20313,-0.34375 0.5,-0.54687 0.3125,-0.21875 0.70313,-0.32813 0.28125,-0.0781 0.85937,-0.14062 1.17188,-0.14063 1.71875,-0.34375 0.0156,-0.1875 0.0156,-0.25 0,-0.59375 -0.28125,-0.82813 -0.35938,-0.32812 -1.09375,-0.32812 -0.6875,0 -1.01563,0.23437 -0.3125,0.23438 -0.46875,0.84375 l -0.95312,-0.125 q 0.125,-0.60937 0.42187,-0.98437 0.29688,-0.375 0.85938,-0.5625 0.5625,-0.20313 1.29687,-0.20313 0.73438,0 1.1875,0.17188 0.45313,0.17187 0.65625,0.4375 0.21875,0.25 0.3125,0.64062 0.0469,0.25 0.0469,0.90625 l 0,1.28125 q 0,1.34375 0.0625,1.70313 0.0625,0.35937 0.25,0.6875 l -1.01563,0 q -0.15625,-0.29688 -0.1875,-0.70313 z m -0.0937,-2.15625 q -0.51562,0.21875 -1.57812,0.35938 -0.59375,0.0937 -0.84375,0.20312 -0.23438,0.0937 -0.375,0.3125 -0.14063,0.20313 -0.14063,0.45313 0,0.39062 0.29688,0.65625 0.29687,0.25 0.85937,0.25 0.5625,0 0.98438,-0.25 0.4375,-0.25 0.65625,-0.67188 0.14062,-0.32812 0.14062,-0.96875 l 0,-0.34375 z m 1.91088,1.15625 0.95312,-0.15625 q 0.0781,0.57813 0.4375,0.89063 0.375,0.29687 1.03125,0.29687 0.67188,0 0.98438,-0.26562 0.32812,-0.26563 0.32812,-0.64063 0,-0.32812 -0.28125,-0.51562 -0.20312,-0.125 -0.98437,-0.32813 -1.0625,-0.26562 -1.48438,-0.45312 -0.40625,-0.20313 -0.625,-0.54688 -0.20312,-0.34375 -0.20312,-0.76562 0,-0.39063 0.17187,-0.70313 0.17188,-0.32812 0.48438,-0.54687 0.21875,-0.17188 0.60937,-0.28125 0.39063,-0.10938 0.82813,-0.10938 0.67187,0 1.17187,0.1875 0.51563,0.1875 0.75,0.53125 0.25,0.32813 0.34375,0.875 l -0.9375,0.125 q -0.0781,-0.4375 -0.39062,-0.67187 -0.29688,-0.25 -0.85938,-0.25 -0.67187,0 -0.95312,0.21875 -0.28125,0.21875 -0.28125,0.51562 0,0.1875 0.10937,0.32813 0.125,0.15625 0.375,0.26562 0.14063,0.0469 0.85938,0.25 1.01562,0.26563 1.42187,0.4375 0.40625,0.17188 0.64063,0.51563 0.23437,0.32812 0.23437,0.82812 0,0.48438 -0.28125,0.90625 -0.28125,0.42188 -0.8125,0.65625 -0.53125,0.23438 -1.20312,0.23438 -1.10938,0 -1.70313,-0.45313 -0.57812,-0.46875 -0.73437,-1.375 z m 9.60937,-0.14062 1,0.125 q -0.23437,0.875 -0.875,1.35937 -0.64062,0.48438 -1.625,0.48438 -1.25,0 -1.98437,-0.76563 -0.73438,-0.76562 -0.73438,-2.15625 0,-1.45312 0.73438,-2.23437 0.75,-0.79688 1.92187,-0.79688 1.15625,0 1.875,0.78125 0.71875,0.76563 0.71875,2.1875 0,0.0781 0,0.25 l -4.25,0 q 0.0469,0.9375 0.51563,1.4375 0.48437,0.5 1.20312,0.5 0.53125,0 0.90625,-0.26562 0.375,-0.28125 0.59375,-0.90625 z m -3.17187,-1.5625 3.1875,0 q -0.0625,-0.71875 -0.35938,-1.07813 -0.46875,-0.54687 -1.20312,-0.54687 -0.67188,0 -1.125,0.45312 -0.45313,0.4375 -0.5,1.17188 z m 8.89524,3.40625 0,-0.71875 q -0.53125,0.84375 -1.59375,0.84375 -0.67187,0 -1.25,-0.375 -0.57812,-0.375 -0.89062,-1.04688 -0.3125,-0.67187 -0.3125,-1.54687 0,-0.85938 0.28125,-1.54688 0.29687,-0.70312 0.85937,-1.0625 0.5625,-0.375 1.26563,-0.375 0.51562,0 0.92187,0.21875 0.40625,0.21875 0.65625,0.5625 l 0,-2.82812 0.96875,0 0,7.875 -0.90625,0 z m -3.04687,-2.84375 q 0,1.09375 0.45312,1.64062 0.46875,0.53125 1.09375,0.53125 0.64063,0 1.07813,-0.51562 0.4375,-0.51563 0.4375,-1.57813 0,-1.17187 -0.45313,-1.71875 -0.4375,-0.54687 -1.10937,-0.54687 -0.64063,0 -1.07813,0.53125 -0.42187,0.51562 -0.42187,1.65625 z" />
-</svg>
diff --git a/library/doc/images/exoplayer_playbackstate.png b/library/doc/images/exoplayer_playbackstate.png
deleted file mode 100644
index fb0ba72a60..0000000000
Binary files a/library/doc/images/exoplayer_playbackstate.png and /dev/null differ
diff --git a/library/doc/images/exoplayer_state.png b/library/doc/images/exoplayer_state.png
deleted file mode 100644
index d37a51e23a..0000000000
Binary files a/library/doc/images/exoplayer_state.png and /dev/null differ
diff --git a/library/doc/images/exoplayer_threading_model.png b/library/doc/images/exoplayer_threading_model.png
deleted file mode 100644
index 9f0306c111..0000000000
Binary files a/library/doc/images/exoplayer_threading_model.png and /dev/null differ
diff --git a/library/doc/images/trackrenderer_state.png b/library/doc/images/trackrenderer_state.png
deleted file mode 100644
index 604a447a6a..0000000000
Binary files a/library/doc/images/trackrenderer_state.png and /dev/null differ
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 39ee60e58d..6327960ac1 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -27,6 +27,6 @@
     the library may be of use on older devices. However, please note that the core video playback
     functionality provided by the library requires API level 16 or greater.
   -->
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="21"/>
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
 
 </manifest>
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 6bf5e08c42..3c9c679000 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer;
 
+import android.media.AudioFormat;
+import android.media.MediaCodec;
 import android.media.MediaExtractor;
 
 /**
@@ -43,11 +45,45 @@
   public static final String UTF8_NAME = "UTF-8";
 
   /**
-   * Sample flag that indicates the sample is a synchronization sample.
+   * @see MediaCodec#CRYPTO_MODE_AES_CTR
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
+
+  /**
+   * @see AudioFormat#ENCODING_AC3
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
+
+  /**
+   * @see AudioFormat#ENCODING_E_AC3
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+
+  /**
+   * @see MediaExtractor#SAMPLE_FLAG_SYNC
    */
   @SuppressWarnings("InlinedApi")
   public static final int SAMPLE_FLAG_SYNC = MediaExtractor.SAMPLE_FLAG_SYNC;
 
+  /**
+   * @see MediaExtractor#SAMPLE_FLAG_ENCRYPTED
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int SAMPLE_FLAG_ENCRYPTED = MediaExtractor.SAMPLE_FLAG_ENCRYPTED;
+
+  /**
+   * Indicates that a sample should be decoded but not rendered.
+   */
+  public static final int SAMPLE_FLAG_DECODE_ONLY = 0x8000000;
+
+  /**
+   * A return value for methods where the end of an input was encountered.
+   */
+  public static final int RESULT_END_OF_INPUT = -1;
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
index 6b12b9c072..f70c4335f9 100644
--- a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
+++ b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
@@ -45,13 +45,13 @@ public synchronized void ensureUpdated() {
   public String getDebugString() {
     ensureUpdated();
     StringBuilder builder = new StringBuilder();
-    builder.append("cic(").append(codecInitCount).append(")");
-    builder.append("crc(").append(codecReleaseCount).append(")");
-    builder.append("ofc(").append(outputFormatChangedCount).append(")");
-    builder.append("obc(").append(outputBuffersChangedCount).append(")");
-    builder.append("ren(").append(renderedOutputBufferCount).append(")");
-    builder.append("sob(").append(skippedOutputBufferCount).append(")");
-    builder.append("dob(").append(droppedOutputBufferCount).append(")");
+    builder.append("cic:").append(codecInitCount);
+    builder.append(" crc:").append(codecReleaseCount);
+    builder.append(" ofc:").append(outputFormatChangedCount);
+    builder.append(" obc:").append(outputBuffersChangedCount);
+    builder.append(" ren:").append(renderedOutputBufferCount);
+    builder.append(" sob:").append(skippedOutputBufferCount);
+    builder.append(" dob:").append(droppedOutputBufferCount);
     return builder.toString();
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
index 9131c4816c..4c9b9f15f5 100644
--- a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
@@ -57,8 +57,8 @@
 
   public static final int DEFAULT_LOW_WATERMARK_MS = 15000;
   public static final int DEFAULT_HIGH_WATERMARK_MS = 30000;
-  public static final float DEFAULT_LOW_POOL_LOAD = 0.2f;
-  public static final float DEFAULT_HIGH_POOL_LOAD = 0.8f;
+  public static final float DEFAULT_LOW_BUFFER_LOAD = 0.2f;
+  public static final float DEFAULT_HIGH_BUFFER_LOAD = 0.8f;
 
   private static final int ABOVE_HIGH_WATERMARK = 0;
   private static final int BETWEEN_WATERMARKS = 1;
@@ -72,12 +72,12 @@
 
   private final long lowWatermarkUs;
   private final long highWatermarkUs;
-  private final float lowPoolLoad;
-  private final float highPoolLoad;
+  private final float lowBufferLoad;
+  private final float highBufferLoad;
 
   private int targetBufferSize;
   private long maxLoadStartPositionUs;
-  private int bufferPoolState;
+  private int bufferState;
   private boolean fillingBuffers;
   private boolean streamingPrioritySet;
 
@@ -101,7 +101,7 @@ public DefaultLoadControl(Allocator allocator) {
   public DefaultLoadControl(Allocator allocator, Handler eventHandler,
       EventListener eventListener) {
     this(allocator, eventHandler, eventListener, DEFAULT_LOW_WATERMARK_MS,
-        DEFAULT_HIGH_WATERMARK_MS, DEFAULT_LOW_POOL_LOAD, DEFAULT_HIGH_POOL_LOAD);
+        DEFAULT_HIGH_WATERMARK_MS, DEFAULT_LOW_BUFFER_LOAD, DEFAULT_HIGH_BUFFER_LOAD);
   }
 
   /**
@@ -116,14 +116,14 @@ public DefaultLoadControl(Allocator allocator, Handler eventHandler,
    *     the filling state.
    * @param highWatermarkMs The minimum duration of media that can be buffered for the control to
    *     transition from filling to draining.
-   * @param lowPoolLoad The minimum fraction of the buffer that must be utilized for the control
+   * @param lowBufferLoad The minimum fraction of the buffer that must be utilized for the control
    *     to be in the draining state. If the utilization is lower, then the control will transition
    *     to the filling state.
-   * @param highPoolLoad The minimum fraction of the buffer that must be utilized for the control
+   * @param highBufferLoad The minimum fraction of the buffer that must be utilized for the control
    *     to transition from the loading state to the draining state.
    */
   public DefaultLoadControl(Allocator allocator, Handler eventHandler, EventListener eventListener,
-      int lowWatermarkMs, int highWatermarkMs, float lowPoolLoad, float highPoolLoad) {
+      int lowWatermarkMs, int highWatermarkMs, float lowBufferLoad, float highBufferLoad) {
     this.allocator = allocator;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
@@ -131,8 +131,8 @@ public DefaultLoadControl(Allocator allocator, Handler eventHandler, EventListen
     this.loaderStates = new HashMap<Object, LoaderState>();
     this.lowWatermarkUs = lowWatermarkMs * 1000L;
     this.highWatermarkUs = highWatermarkMs * 1000L;
-    this.lowPoolLoad = lowPoolLoad;
-    this.highPoolLoad = highPoolLoad;
+    this.lowBufferLoad = lowBufferLoad;
+    this.highBufferLoad = highBufferLoad;
   }
 
   @Override
@@ -176,20 +176,20 @@ public boolean update(Object loader, long playbackPositionUs, long nextLoadPosit
       loaderState.failed = failed;
     }
 
-    // Update the buffer pool state.
-    int allocatedSize = allocator.getAllocatedSize();
-    int bufferPoolState = getBufferPoolState(allocatedSize);
-    boolean bufferPoolStateChanged = this.bufferPoolState != bufferPoolState;
-    if (bufferPoolStateChanged) {
-      this.bufferPoolState = bufferPoolState;
+    // Update the buffer state.
+    int currentBufferSize = allocator.getTotalBytesAllocated();
+    int bufferState = getBufferState(currentBufferSize);
+    boolean bufferStateChanged = this.bufferState != bufferState;
+    if (bufferStateChanged) {
+      this.bufferState = bufferState;
     }
 
     // If either of the individual states have changed, update the shared control state.
-    if (loaderStateChanged || bufferPoolStateChanged) {
+    if (loaderStateChanged || bufferStateChanged) {
       updateControlState();
     }
 
-    return allocatedSize < targetBufferSize && nextLoadPositionUs != -1
+    return currentBufferSize < targetBufferSize && nextLoadPositionUs != -1
         && nextLoadPositionUs <= maxLoadStartPositionUs;
   }
 
@@ -204,18 +204,18 @@ private int getLoaderBufferState(long playbackPositionUs, long nextLoadPositionU
     }
   }
 
-  private int getBufferPoolState(int allocatedSize) {
-    float bufferPoolLoad = (float) allocatedSize / targetBufferSize;
-    return bufferPoolLoad > highPoolLoad ? ABOVE_HIGH_WATERMARK :
-        bufferPoolLoad < lowPoolLoad ? BELOW_LOW_WATERMARK :
-        BETWEEN_WATERMARKS;
+  private int getBufferState(int currentBufferSize) {
+    float bufferLoad = (float) currentBufferSize / targetBufferSize;
+    return bufferLoad > highBufferLoad ? ABOVE_HIGH_WATERMARK
+        : bufferLoad < lowBufferLoad ? BELOW_LOW_WATERMARK
+        : BETWEEN_WATERMARKS;
   }
 
   private void updateControlState() {
     boolean loading = false;
     boolean failed = false;
     boolean haveNextLoadPosition = false;
-    int highestState = bufferPoolState;
+    int highestState = bufferState;
     for (int i = 0; i < loaders.size(); i++) {
       LoaderState loaderState = loaderStates.get(loaders.get(i));
       loading |= loaderState.loading;
diff --git a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
index 4dd5ef4a42..39aec48781 100644
--- a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
@@ -18,14 +18,14 @@
 /**
  * A {@link TrackRenderer} that does nothing.
  * <p>
- * This renderer returns {@link TrackRenderer#STATE_IGNORE} from {@link #doPrepare()} in order to
- * request that it should be ignored. {@link IllegalStateException} is thrown from all methods that
- * are documented to indicate that they should not be invoked unless the renderer is prepared.
+ * This renderer returns {@link TrackRenderer#STATE_IGNORE} from {@link #doPrepare(long)} in order
+ * to request that it should be ignored. {@link IllegalStateException} is thrown from all methods
+ * that are documented to indicate that they should not be invoked unless the renderer is prepared.
  */
 public class DummyTrackRenderer extends TrackRenderer {
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     return STATE_IGNORE;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlaybackException.java b/library/src/main/java/com/google/android/exoplayer/ExoPlaybackException.java
index 4c11104724..3e391a1fd8 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlaybackException.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlaybackException.java
@@ -20,18 +20,32 @@
  * <p>
  * Where possible, the cause returned by {@link #getCause()} will indicate the reason for failure.
  */
-public class ExoPlaybackException extends Exception {
+public final class ExoPlaybackException extends Exception {
+
+  /**
+   * True if the cause (i.e. the {@link Throwable} returned by {@link #getCause()}) was only caught
+   * by a fail-safe at the top level of the player. False otherwise.
+   */
+  public final boolean caughtAtTopLevel;
 
   public ExoPlaybackException(String message) {
     super(message);
+    caughtAtTopLevel = false;
   }
 
   public ExoPlaybackException(Throwable cause) {
     super(cause);
+    caughtAtTopLevel = false;
   }
 
   public ExoPlaybackException(String message, Throwable cause) {
     super(message, cause);
+    caughtAtTopLevel = false;
+  }
+
+  /* package */ ExoPlaybackException(Throwable cause, boolean caughtAtTopLevel) {
+    super(cause);
+    this.caughtAtTopLevel = caughtAtTopLevel;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index a5bc989a40..a0b544062a 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -52,7 +52,7 @@
  * <h3>Threading model</h3>
  *
  * <p>The figure below shows the {@link ExoPlayer} threading model.</p>
- * <p align="center"><img src="../../../../../doc_src/images/exoplayer_threading_model.png"
+ * <p align="center"><img src="../../../../../images/exoplayer_threading_model.png"
  *     alt="MediaPlayer state diagram"
  *     border="0"/></p>
  *
@@ -79,14 +79,14 @@
  * have been performed asynchronously by the playback thread. In contrast, the playback state
  * accessed by {@link #getPlaybackState()} is only ever changed as a result of operations
  * completing on the playback thread, as illustrated below.</p>
- * <p align="center"><img src="../../../../../doc_src/images/exoplayer_state.png"
+ * <p align="center"><img src="../../../../../images/exoplayer_state.png"
  *     alt="ExoPlayer state"
  *     border="0"/></p>
  *
  * <p>The possible playback state transitions are shown below. Transitions can be triggered either
  * by changes in the state of the {@link TrackRenderer}s being used, or as a result of
  * {@link #prepare(TrackRenderer[])}, {@link #stop()} or {@link #release()} being invoked.</p>
- * <p align="center"><img src="../../../../../doc_src/images/exoplayer_playbackstate.png"
+ * <p align="center"><img src="../../../../../images/exoplayer_playbackstate.png"
  *     alt="ExoPlayer playback state transitions"
  *     border="0"/></p>
  */
@@ -101,7 +101,7 @@
      * The default minimum duration of data that must be buffered for playback to start or resume
      * following a user action such as a seek.
      */
-    public static final int DEFAULT_MIN_BUFFER_MS = 500;
+    public static final int DEFAULT_MIN_BUFFER_MS = 2500;
 
     /**
      * The default minimum duration of data that must be buffered for playback to resume
@@ -141,14 +141,6 @@ public static ExoPlayer newInstance(int rendererCount) {
       return new ExoPlayerImpl(rendererCount, DEFAULT_MIN_BUFFER_MS, DEFAULT_MIN_REBUFFER_MS);
     }
 
-    /**
-     * @deprecated Please use {@link #newInstance(int, int, int)}.
-     */
-    @Deprecated
-    public static ExoPlayer newInstance(int rendererCount, int minRebufferMs) {
-      return new ExoPlayerImpl(rendererCount, DEFAULT_MIN_BUFFER_MS, minRebufferMs);
-    }
-
   }
 
   /**
@@ -160,7 +152,8 @@ public static ExoPlayer newInstance(int rendererCount, int minRebufferMs) {
      * {@link ExoPlayer#getPlaybackState()} changes.
      *
      * @param playWhenReady Whether playback will proceed when ready.
-     * @param playbackState One of the {@code STATE} constants defined in this class.
+     * @param playbackState One of the {@code STATE} constants defined in the {@link ExoPlayer}
+     *     interface.
      */
     void onPlayerStateChanged(boolean playWhenReady, int playbackState);
     /**
@@ -256,7 +249,7 @@ public static ExoPlayer newInstance(int rendererCount, int minRebufferMs) {
   /**
    * Returns the current state of the player.
    *
-   * @return One of the {@code STATE} constants defined in this class.
+   * @return One of the {@code STATE} constants defined in this interface.
    */
   public int getPlaybackState();
 
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index 96019112e7..2c87cd7133 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -233,7 +233,7 @@ public boolean handleMessage(Message msg) {
       return true;
     } catch (RuntimeException e) {
       Log.e(TAG, "Internal runtime error.", e);
-      eventHandler.obtainMessage(MSG_ERROR, new ExoPlaybackException(e)).sendToTarget();
+      eventHandler.obtainMessage(MSG_ERROR, new ExoPlaybackException(e, true)).sendToTarget();
       stopInternal();
       return true;
     }
@@ -247,7 +247,7 @@ private void setState(int state) {
   }
 
   private void prepareInternal(TrackRenderer[] renderers) {
-    rebuffering = false;
+    resetInternal();
     this.renderers = renderers;
     for (int i = 0; i < renderers.length; i++) {
       if (renderers[i].isTimeSource()) {
@@ -264,7 +264,7 @@ private void incrementalPrepareInternal() throws ExoPlaybackException {
     boolean prepared = true;
     for (int i = 0; i < renderers.length; i++) {
       if (renderers[i].getState() == TrackRenderer.STATE_UNPREPARED) {
-        int state = renderers[i].prepare();
+        int state = renderers[i].prepare(positionUs);
         if (state == TrackRenderer.STATE_UNPREPARED) {
           prepared = false;
         }
@@ -475,12 +475,13 @@ private void seekToInternal(long positionMs) throws ExoPlaybackException {
   }
 
   private void stopInternal() {
-    rebuffering = false;
     resetInternal();
+    setState(ExoPlayer.STATE_IDLE);
   }
 
   private void releaseInternal() {
     resetInternal();
+    setState(ExoPlayer.STATE_IDLE);
     synchronized (this) {
       released = true;
       notifyAll();
@@ -490,6 +491,7 @@ private void releaseInternal() {
   private void resetInternal() {
     handler.removeMessages(MSG_DO_SOME_WORK);
     handler.removeMessages(MSG_INCREMENTAL_PREPARE);
+    rebuffering = false;
     mediaClock.stop();
     if (renderers == null) {
       return;
@@ -502,7 +504,6 @@ private void resetInternal() {
     renderers = null;
     timeSourceTrackRenderer = null;
     enabledRenderers.clear();
-    setState(ExoPlayer.STATE_IDLE);
   }
 
   private void stopAndDisable(TrackRenderer renderer) {
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 30ee20645b..5b1eb77536 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -26,7 +26,7 @@ private ExoPlayerLibraryInfo() {}
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.2.4";
+  public static final String VERSION = "1.3.1";
 
   /**
    * The version of the library, expressed as an integer.
@@ -34,7 +34,7 @@ private ExoPlayerLibraryInfo() {}
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001002004;
+  public static final int VERSION_INT = 001003001;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
new file mode 100644
index 0000000000..8eab665aa8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.media.MediaExtractor;
+import android.net.Uri;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * Extracts samples from a stream using Android's {@link MediaExtractor}.
+ * <p>
+ * Warning - This class is marked as deprecated because there are known device specific issues
+ * associated with its use, including playbacks not starting, playbacks stuttering and other
+ * miscellaneous failures. For mp4, m4a, mp3, webm, mpeg-ts and aac playbacks it is strongly
+ * recommended to use {@link ExtractorSampleSource} instead, along with the corresponding extractor
+ * (e.g. {@link Mp4Extractor} for mp4 playbacks). Where this is not possible this class can still be
+ * used, but please be aware of the associated risks. Valid use cases of this class that are not
+ * yet supported by {@link ExtractorSampleSource} include:
+ * <ul>
+ * <li>Playing a container format for which an ExoPlayer extractor does not yet exist (e.g. ogg).
+ * </li>
+ * <li>Playing media whose container format is unknown and so needs to be inferred automatically.
+ * </li>
+ * </ul>
+ * Over time we hope to enhance {@link ExtractorSampleSource} to support these use cases, and hence
+ * make use of this class unnecessary.
+ */
+// TODO: This implementation needs to be fixed so that its methods are non-blocking (either
+// through use of a background thread, or through changes to the framework's MediaExtractor API).
+@Deprecated
+@TargetApi(16)
+public final class FrameworkSampleSource implements SampleSource {
+
+  private static final int ALLOWED_FLAGS_MASK = C.SAMPLE_FLAG_SYNC | C.SAMPLE_FLAG_ENCRYPTED;
+
+  private static final int TRACK_STATE_DISABLED = 0;
+  private static final int TRACK_STATE_ENABLED = 1;
+  private static final int TRACK_STATE_FORMAT_SENT = 2;
+
+  // Parameters for a Uri data source.
+  private final Context context;
+  private final Uri uri;
+  private final Map<String, String> headers;
+
+  // Parameters for a FileDescriptor data source.
+  private final FileDescriptor fileDescriptor;
+  private final long fileDescriptorOffset;
+  private final long fileDescriptorLength;
+
+  private MediaExtractor extractor;
+  private TrackInfo[] trackInfos;
+  private boolean prepared;
+  private int remainingReleaseCount;
+  private int[] trackStates;
+  private boolean[] pendingDiscontinuities;
+
+  private long seekPositionUs;
+
+  /**
+   * Instantiates a new sample extractor reading from the specified {@code uri}.
+   *
+   * @param context Context for resolving {@code uri}.
+   * @param uri The content URI from which to extract data.
+   * @param headers Headers to send with requests for data.
+   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   */
+  public FrameworkSampleSource(Context context, Uri uri, Map<String, String> headers,
+      int downstreamRendererCount) {
+    Assertions.checkState(Util.SDK_INT >= 16);
+    this.remainingReleaseCount = downstreamRendererCount;
+
+    this.context = Assertions.checkNotNull(context);
+    this.uri = Assertions.checkNotNull(uri);
+    this.headers = headers;
+
+    fileDescriptor = null;
+    fileDescriptorOffset = 0;
+    fileDescriptorLength = 0;
+  }
+
+  /**
+   * Instantiates a new sample extractor reading from the specified seekable {@code fileDescriptor}.
+   * The caller is responsible for releasing the file descriptor.
+   *
+   * @param fileDescriptor File descriptor from which to read.
+   * @param offset The offset in bytes into the file where the data to be extracted starts.
+   * @param length The length in bytes of the data to be extracted.
+   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   */
+  public FrameworkSampleSource(FileDescriptor fileDescriptor, long offset, long length,
+      int downstreamRendererCount) {
+    Assertions.checkState(Util.SDK_INT >= 16);
+    this.remainingReleaseCount = downstreamRendererCount;
+
+    context = null;
+    uri = null;
+    headers = null;
+
+    this.fileDescriptor = Assertions.checkNotNull(fileDescriptor);
+    fileDescriptorOffset = offset;
+    fileDescriptorLength = length;
+  }
+
+  @Override
+  public boolean prepare(long positionUs) throws IOException {
+    if (!prepared) {
+      extractor = new MediaExtractor();
+      if (context != null) {
+        extractor.setDataSource(context, uri, headers);
+      } else {
+        extractor.setDataSource(fileDescriptor, fileDescriptorOffset, fileDescriptorLength);
+      }
+
+      trackStates = new int[extractor.getTrackCount()];
+      pendingDiscontinuities = new boolean[trackStates.length];
+      trackInfos = new TrackInfo[trackStates.length];
+      for (int i = 0; i < trackStates.length; i++) {
+        android.media.MediaFormat format = extractor.getTrackFormat(i);
+        long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
+            ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
+        String mime = format.getString(android.media.MediaFormat.KEY_MIME);
+        trackInfos[i] = new TrackInfo(mime, durationUs);
+      }
+      prepared = true;
+    }
+    return true;
+  }
+
+  @Override
+  public int getTrackCount() {
+    Assertions.checkState(prepared);
+    return trackStates.length;
+  }
+
+  @Override
+  public TrackInfo getTrackInfo(int track) {
+    Assertions.checkState(prepared);
+    return trackInfos[track];
+  }
+
+  @Override
+  public void enable(int track, long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] == TRACK_STATE_DISABLED);
+    trackStates[track] = TRACK_STATE_ENABLED;
+    extractor.selectTrack(track);
+    seekToUsInternal(positionUs, positionUs != 0);
+  }
+
+  @Override
+  public boolean continueBuffering(long positionUs) {
+    // MediaExtractor takes care of buffering and blocks until it has samples, so we can always
+    // return true here. Although note that the blocking behavior is itself as bug, as per the
+    // TODO further up this file. This method will need to return something else as part of fixing
+    // the TODO.
+    return true;
+  }
+
+  @Override
+  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
+    if (pendingDiscontinuities[track]) {
+      pendingDiscontinuities[track] = false;
+      return DISCONTINUITY_READ;
+    }
+    if (onlyReadDiscontinuity) {
+      return NOTHING_READ;
+    }
+    if (trackStates[track] != TRACK_STATE_FORMAT_SENT) {
+      formatHolder.format = MediaFormat.createFromFrameworkMediaFormatV16(
+          extractor.getTrackFormat(track));
+      formatHolder.drmInitData = Util.SDK_INT >= 18 ? getDrmInitDataV18() : null;
+      trackStates[track] = TRACK_STATE_FORMAT_SENT;
+      return FORMAT_READ;
+    }
+    int extractorTrackIndex = extractor.getSampleTrackIndex();
+    if (extractorTrackIndex == track) {
+      if (sampleHolder.data != null) {
+        int offset = sampleHolder.data.position();
+        sampleHolder.size = extractor.readSampleData(sampleHolder.data, offset);
+        sampleHolder.data.position(offset + sampleHolder.size);
+      } else {
+        sampleHolder.size = 0;
+      }
+      sampleHolder.timeUs = extractor.getSampleTime();
+      sampleHolder.flags = extractor.getSampleFlags() & ALLOWED_FLAGS_MASK;
+      if (sampleHolder.isEncrypted()) {
+        sampleHolder.cryptoInfo.setFromExtractorV16(extractor);
+      }
+      seekPositionUs = C.UNKNOWN_TIME_US;
+      extractor.advance();
+      return SAMPLE_READ;
+    } else {
+      return extractorTrackIndex < 0 ? END_OF_STREAM : NOTHING_READ;
+    }
+  }
+
+  @Override
+  public void disable(int track) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
+    extractor.unselectTrack(track);
+    pendingDiscontinuities[track] = false;
+    trackStates[track] = TRACK_STATE_DISABLED;
+  }
+
+  @Override
+  public void seekToUs(long positionUs) {
+    Assertions.checkState(prepared);
+    seekToUsInternal(positionUs, false);
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    Assertions.checkState(prepared);
+    long bufferedDurationUs = extractor.getCachedDuration();
+    if (bufferedDurationUs == -1) {
+      return TrackRenderer.UNKNOWN_TIME_US;
+    } else {
+      long sampleTime = extractor.getSampleTime();
+      return sampleTime == -1 ? TrackRenderer.END_OF_TRACK_US : sampleTime + bufferedDurationUs;
+    }
+  }
+
+  @Override
+  public void release() {
+    Assertions.checkState(remainingReleaseCount > 0);
+    if (--remainingReleaseCount == 0 && extractor != null) {
+      extractor.release();
+      extractor = null;
+    }
+  }
+
+  @TargetApi(18)
+  private DrmInitData getDrmInitDataV18() {
+    // MediaExtractor only supports psshInfo for MP4, so it's ok to hard code the mimeType here.
+    Map<UUID, byte[]> psshInfo = extractor.getPsshInfo();
+    if (psshInfo == null || psshInfo.isEmpty()) {
+      return null;
+    }
+    DrmInitData.Mapped drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
+    drmInitData.putAll(psshInfo);
+    return drmInitData;
+  }
+
+  private void seekToUsInternal(long positionUs, boolean force) {
+    // Unless forced, avoid duplicate calls to the underlying extractor's seek method in the case
+    // that there have been no interleaving calls to readSample.
+    if (force || seekPositionUs != positionUs) {
+      seekPositionUs = positionUs;
+      extractor.seekTo(positionUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+      for (int i = 0; i < trackStates.length; ++i) {
+        if (trackStates[i] != TRACK_STATE_DISABLED) {
+          pendingDiscontinuities[i] = true;
+        }
+      }
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index a6ff3b0a44..48b54db597 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -15,13 +15,13 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.util.MimeTypes;
 
 import android.annotation.TargetApi;
 import android.media.MediaCodec;
-import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
 
@@ -62,6 +62,11 @@
    */
   public static final int MSG_SET_VOLUME = 1;
 
+  /**
+   * The name for the raw (passthrough) decoder OMX component.
+   */
+  private static final String RAW_DECODER_NAME = "OMX.google.raw.decoder";
+
   private final EventListener eventListener;
   private final AudioTrack audioTrack;
 
@@ -122,6 +127,29 @@ public MediaCodecAudioTrackRenderer(SampleSource source, DrmSessionManager drmSe
     this.audioTrack = new AudioTrack();
   }
 
+  @Override
+  protected DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+      throws DecoderQueryException {
+    if (MimeTypes.isPassthroughAudio(mimeType)) {
+      return new DecoderInfo(RAW_DECODER_NAME, true);
+    }
+    return super.getDecoderInfo(mimeType, requiresSecureDecoder);
+  }
+
+  @Override
+  protected void configureCodec(MediaCodec codec, String codecName,
+      android.media.MediaFormat format, android.media.MediaCrypto crypto) {
+    if (RAW_DECODER_NAME.equals(codecName)) {
+      // Override the MIME type used to configure the codec if we are using a passthrough decoder.
+      String mimeType = format.getString(android.media.MediaFormat.KEY_MIME);
+      format.setString(android.media.MediaFormat.KEY_MIME, MimeTypes.AUDIO_RAW);
+      codec.configure(format, null, crypto, 0);
+      format.setString(android.media.MediaFormat.KEY_MIME, mimeType);
+    } else {
+      codec.configure(format, null, crypto, 0);
+    }
+  }
+
   @Override
   protected boolean isTimeSource() {
     return true;
@@ -139,8 +167,13 @@ protected void onEnabled(long positionUs, boolean joining) {
   }
 
   @Override
-  protected void onOutputFormatChanged(MediaFormat format) {
-    audioTrack.reconfigure(format);
+  protected void onOutputFormatChanged(MediaFormat inputFormat,
+      android.media.MediaFormat outputFormat) {
+    if (MimeTypes.isPassthroughAudio(inputFormat.mimeType)) {
+      audioTrack.reconfigure(inputFormat.getFrameworkMediaFormatV16());
+    } else {
+      audioTrack.reconfigure(outputFormat);
+    }
   }
 
   /**
@@ -202,7 +235,7 @@ protected long getCurrentPositionUs() {
   protected void onDisabled() {
     audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
-      audioTrack.reset();
+      audioTrack.release();
     } finally {
       super.onDisabled();
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 61b12e33b1..6f8dcbd6be 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer;
 
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
@@ -25,7 +26,6 @@
 import android.media.MediaCodec.CodecException;
 import android.media.MediaCodec.CryptoException;
 import android.media.MediaCrypto;
-import android.media.MediaExtractor;
 import android.os.Handler;
 import android.os.SystemClock;
 
@@ -33,8 +33,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
-import java.util.UUID;
 
 /**
  * An abstract {@link TrackRenderer} that uses {@link MediaCodec} to decode samples for rendering.
@@ -61,6 +59,17 @@
      */
     void onCryptoError(CryptoException e);
 
+    /**
+     * Invoked when a decoder is successfully created.
+     *
+     * @param decoderName The decoder that was configured and created.
+     * @param elapsedRealtimeMs {@code elapsedRealtime} timestamp of when the initialization
+     *    finished.
+     * @param initializationDurationMs Amount of time taken to initialize the decoder.
+     */
+    void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
+        long initializationDurationMs);
+
   }
 
   /**
@@ -151,6 +160,23 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int RECONFIGURATION_STATE_QUEUE_PENDING = 2;
 
+  /**
+   * The codec does not need to be re-initialized.
+   */
+  private static final int REINITIALIZATION_STATE_NONE = 0;
+  /**
+   * The input format has changed in a way that requires the codec to be re-initialized, but we
+   * haven't yet signaled an end of stream to the existing codec. We need to do so in order to
+   * ensure that it outputs any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM = 1;
+  /**
+   * The input format has changed in a way that requires the codec to be re-initialized, and we've
+   * signaled an end of stream to the existing codec. We're waiting for the codec to output an end
+   * of stream signal to indicate that it has output any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
+
   public final CodecCounters codecCounters;
 
   private final DrmSessionManager drmSessionManager;
@@ -164,7 +190,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   protected final Handler eventHandler;
 
   private MediaFormat format;
-  private Map<UUID, byte[]> drmInitData;
+  private DrmInitData drmInitData;
   private MediaCodec codec;
   private boolean codecIsAdaptive;
   private ByteBuffer[] inputBuffers;
@@ -175,6 +201,8 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean openedDrmSession;
   private boolean codecReconfigured;
   private int codecReconfigurationState;
+  private int codecReinitializationState;
+  private boolean codecHasQueuedBuffers;
 
   private int trackIndex;
   private int sourceState;
@@ -210,12 +238,14 @@ public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSession
     formatHolder = new MediaFormatHolder();
     decodeOnlyPresentationTimestamps = new ArrayList<Long>();
     outputBufferInfo = new MediaCodec.BufferInfo();
+    codecReconfigurationState = RECONFIGURATION_STATE_NONE;
+    codecReinitializationState = REINITIALIZATION_STATE_NONE;
   }
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     try {
-      boolean sourcePrepared = source.prepare();
+      boolean sourcePrepared = source.prepare(positionUs);
       if (!sourcePrepared) {
         return TrackRenderer.STATE_UNPREPARED;
       }
@@ -259,12 +289,30 @@ protected void onEnabled(long positionUs, boolean joining) {
   }
 
   /**
-   * Configures a newly created {@link MediaCodec}. Sub-classes should
-   * override this method if they wish to configure the codec with a
-   * non-null surface.
-   **/
-  protected void configureCodec(MediaCodec codec, android.media.MediaFormat x, MediaCrypto crypto) {
-    codec.configure(x, null, crypto, 0);
+   * Returns a {@link DecoderInfo} for decoding media in the specified MIME type.
+   *
+   * @param mimeType The type of media to decode.
+   * @param requiresSecureDecoder Whether a secure decoder is needed for decoding {@code mimeType}.
+   * @return {@link DecoderInfo} for decoding media in the specified MIME type, or {@code null} if
+   *     no suitable decoder is available.
+   */
+  protected DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+      throws DecoderQueryException {
+    return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
+  }
+
+  /**
+   * Configures a newly created {@link MediaCodec}. Sub-classes should override this method if they
+   * wish to configure the codec with a non-null surface.
+   *
+   * @param codec The {@link MediaCodec} to configure.
+   * @param codecName The name of the codec.
+   * @param format The format for which the codec is being configured.
+   * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
+   */
+  protected void configureCodec(MediaCodec codec, String codecName,
+      android.media.MediaFormat format, MediaCrypto crypto) {
+    codec.configure(format, null, crypto, 0);
   }
 
   @SuppressWarnings("deprecation")
@@ -281,7 +329,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
         throw new ExoPlaybackException("Media requires a DrmSessionManager");
       }
       if (!openedDrmSession) {
-        drmSessionManager.open(drmInitData, mimeType);
+        drmSessionManager.open(drmInitData);
         openedDrmSession = true;
       }
       int drmSessionState = drmSessionManager.getState();
@@ -299,7 +347,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     DecoderInfo decoderInfo = null;
     try {
-      decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
+      decoderInfo = getDecoderInfo(mimeType, requiresSecureDecoder);
     } catch (DecoderQueryException e) {
       notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
           DecoderInitializationException.DECODER_QUERY_ERROR));
@@ -313,9 +361,13 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     String decoderName = decoderInfo.name;
     codecIsAdaptive = decoderInfo.adaptive;
     try {
+      long codecInitializingTimestamp = SystemClock.elapsedRealtime();
       codec = MediaCodec.createByCodecName(decoderName);
-      configureCodec(codec, format.getFrameworkMediaFormatV16(), mediaCrypto);
+      configureCodec(codec, decoderName, format.getFrameworkMediaFormatV16(), mediaCrypto);
       codec.start();
+      long codecInitializedTimestamp = SystemClock.elapsedRealtime();
+      notifyDecoderInitialized(decoderName, codecInitializedTimestamp,
+          codecInitializedTimestamp - codecInitializingTimestamp);
       inputBuffers = codec.getInputBuffers();
       outputBuffers = codec.getOutputBuffers();
     } catch (Exception e) {
@@ -370,12 +422,15 @@ protected void releaseCodec() {
       codecHotswapTimeMs = -1;
       inputIndex = -1;
       outputIndex = -1;
+      waitingForKeys = false;
       decodeOnlyPresentationTimestamps.clear();
       inputBuffers = null;
       outputBuffers = null;
       codecReconfigured = false;
+      codecHasQueuedBuffers = false;
       codecIsAdaptive = false;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
+      codecReinitializationState = REINITIALIZATION_STATE_NONE;
       codecCounters.codecReleaseCount++;
       try {
         codec.stop();
@@ -418,7 +473,6 @@ protected void seekTo(long positionUs) throws ExoPlaybackException {
     sourceState = SOURCE_STATE_NOT_READY;
     inputStreamEnded = false;
     outputStreamEnded = false;
-    waitingForKeys = false;
   }
 
   @Override
@@ -478,11 +532,13 @@ private void flushCodec() throws ExoPlaybackException {
     inputIndex = -1;
     outputIndex = -1;
     waitingForFirstSyncFrame = true;
+    waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
     // Workaround for framework bugs.
     // See [Internal: b/8347958], [Internal: b/8578467], [Internal: b/8543366].
-    if (Util.SDK_INT >= 18) {
+    if (Util.SDK_INT >= 18 && codecReinitializationState == REINITIALIZATION_STATE_NONE) {
       codec.flush();
+      codecHasQueuedBuffers = false;
     } else {
       releaseCodec();
       maybeInitCodec();
@@ -502,9 +558,13 @@ private void flushCodec() throws ExoPlaybackException {
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
   private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlaybackException {
-    if (inputStreamEnded) {
+    if (inputStreamEnded
+        || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+      // The input stream has ended, or we need to re-initialize the codec but are still waiting
+      // for the existing codec to output any final output buffers.
       return false;
     }
+
     if (inputIndex < 0) {
       inputIndex = codec.dequeueInputBuffer(0);
       if (inputIndex < 0) {
@@ -514,6 +574,15 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
       sampleHolder.data.clear();
     }
 
+    if (codecReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
+      // We need to re-initialize the codec. Send an end of stream signal to the existing codec so
+      // that it outputs any remaining buffers before we release it.
+      codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+      inputIndex = -1;
+      codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      return false;
+    }
+
     int result;
     if (waitingForKeys) {
       // We've already read an encrypted sample into sampleHolder, and are waiting for keys.
@@ -572,7 +641,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
     if (waitingForFirstSyncFrame) {
       // TODO: Find out if it's possible to supply samples prior to the first sync
       // frame for HE-AAC.
-      if ((sampleHolder.flags & C.SAMPLE_FLAG_SYNC) == 0) {
+      if (!sampleHolder.isSyncFrame()) {
         sampleHolder.data.clear();
         if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
           // The buffer we just cleared contained reconfiguration data. We need to re-write this
@@ -583,7 +652,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
       }
       waitingForFirstSyncFrame = false;
     }
-    boolean sampleEncrypted = (sampleHolder.flags & MediaExtractor.SAMPLE_FLAG_ENCRYPTED) != 0;
+    boolean sampleEncrypted = sampleHolder.isEncrypted();
     waitingForKeys = shouldWaitForKeys(sampleEncrypted);
     if (waitingForKeys) {
       return false;
@@ -592,7 +661,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
       int bufferSize = sampleHolder.data.position();
       int adaptiveReconfigurationBytes = bufferSize - sampleHolder.size;
       long presentationTimeUs = sampleHolder.timeUs;
-      if (sampleHolder.decodeOnly) {
+      if (sampleHolder.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
       if (sampleEncrypted) {
@@ -603,6 +672,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
         codec.queueInputBuffer(inputIndex, 0 , bufferSize, presentationTimeUs, 0);
       }
       inputIndex = -1;
+      codecHasQueuedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     } catch (CryptoException e) {
       notifyCryptoError(e);
@@ -656,8 +726,14 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
       codecReconfigured = true;
       codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
     } else {
-      releaseCodec();
-      maybeInitCodec();
+      if (codecHasQueuedBuffers) {
+        // Signal end of stream and wait for any final output buffers before re-initialization.
+        codecReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
+      } else {
+        // There aren't any final output buffers, so perform re-initialization immediately.
+        releaseCodec();
+        maybeInitCodec();
+      }
     }
   }
 
@@ -666,9 +742,11 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
    * <p>
    * The default implementation is a no-op.
    *
-   * @param format The new output format.
+   * @param inputFormat The format of media input to the codec.
+   * @param outputFormat The new output format.
    */
-  protected void onOutputFormatChanged(android.media.MediaFormat format) {
+  protected void onOutputFormatChanged(MediaFormat inputFormat,
+      android.media.MediaFormat outputFormat) {
     // Do nothing.
   }
 
@@ -717,6 +795,15 @@ private boolean isWithinHotswapPeriod() {
     return SystemClock.elapsedRealtime() < codecHotswapTimeMs + MAX_CODEC_HOTSWAP_TIME_MS;
   }
 
+  /**
+   * Returns the maximum time to block whilst waiting for a decoded output buffer.
+   *
+   * @return The maximum time to block, in microseconds.
+   */
+  protected long getDequeueOutputBufferTimeoutUs() {
+    return 0;
+  }
+
   /**
    * @return True if it may be possible to drain more output data. False otherwise.
    * @throws ExoPlaybackException If an error occurs draining the output buffer.
@@ -729,11 +816,11 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if (outputIndex < 0) {
-      outputIndex = codec.dequeueOutputBuffer(outputBufferInfo, 0);
+      outputIndex = codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
     }
 
     if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-      onOutputFormatChanged(codec.getOutputFormat());
+      onOutputFormatChanged(format, codec.getOutputFormat());
       codecCounters.outputFormatChangedCount++;
       return true;
     } else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
@@ -745,7 +832,13 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
-      outputStreamEnded = true;
+      if (codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+        // We're waiting to re-initialize the codec, and have now received all final output buffers.
+        releaseCodec();
+        maybeInitCodec();
+      } else {
+        outputStreamEnded = true;
+      }
       return false;
     }
 
@@ -797,6 +890,19 @@ public void run() {
     }
   }
 
+  private void notifyDecoderInitialized(final String decoderName,
+      final long initializedTimestamp, final long initializationDuration) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onDecoderInitialized(decoderName, initializedTimestamp,
+              initializationDuration);
+        }
+      });
+    }
+  }
+
   private int getDecodeOnlyIndex(long presentationTimeUs) {
     final int size = decodeOnlyPresentationTimestamps.size();
     for (int i = 0; i < size; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index f3dbc7e7d1..5dbe3c5a11 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
@@ -179,6 +180,33 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
     return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
+  /**
+   * Tests whether the device advertises it can decode video of a given type at a specified
+   * width, height, and frame rate.
+   * <p>
+   * Must not be called if the device SDK version is less than 21.
+   *
+   * @param mimeType The mime type.
+   * @param secure Whether the decoder is required to support secure decryption. Always pass false
+   *     unless secure decryption really is required.
+   * @param width Width in pixels.
+   * @param height Height in pixels.
+   * @param frameRate Frame rate in frames per second.
+   * @return Whether the decoder advertises support of the given size and frame rate.
+   */
+  @TargetApi(21)
+  public static boolean isSizeAndRateSupportedV21(String mimeType, boolean secure,
+      int width, int height, double frameRate) throws DecoderQueryException {
+    Assertions.checkState(Util.SDK_INT >= 21);
+    Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
+    if (info == null) {
+      return false;
+    }
+    MediaCodecInfo.VideoCapabilities videoCapabilities = info.second.getVideoCapabilities();
+    return videoCapabilities != null
+        && videoCapabilities.areSizeAndRateSupported(width, height, frameRate);
+  }
+
   /**
    * @param profile An AVC profile constant from {@link CodecProfileLevel}.
    * @param level An AVC profile level from {@link CodecProfileLevel}.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index 685b32eff3..49949f91a2 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -358,8 +358,8 @@ protected boolean shouldInitCodec() {
 
   // Override configureCodec to provide the surface.
   @Override
-  protected void configureCodec(MediaCodec codec, android.media.MediaFormat format,
-      MediaCrypto crypto) {
+  protected void configureCodec(MediaCodec codec, String codecName,
+      android.media.MediaFormat format, MediaCrypto crypto) {
     codec.configure(format, surface, crypto, 0);
     codec.setVideoScalingMode(videoScalingMode);
   }
@@ -373,16 +373,25 @@ protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlayback
         : holder.format.pixelWidthHeightRatio;
   }
 
+  /**
+   * @return True if the first frame has been rendered (playback has not necessarily begun).
+   */
+  protected final boolean haveRenderedFirstFrame() {
+    return renderedFirstFrame;
+  }
+
   @Override
-  protected void onOutputFormatChanged(android.media.MediaFormat format) {
-    boolean hasCrop = format.containsKey(KEY_CROP_RIGHT) && format.containsKey(KEY_CROP_LEFT)
-        && format.containsKey(KEY_CROP_BOTTOM) && format.containsKey(KEY_CROP_TOP);
+  protected void onOutputFormatChanged(MediaFormat inputFormat,
+      android.media.MediaFormat outputFormat) {
+    boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
+        && outputFormat.containsKey(KEY_CROP_LEFT) && outputFormat.containsKey(KEY_CROP_BOTTOM)
+        && outputFormat.containsKey(KEY_CROP_TOP);
     currentWidth = hasCrop
-        ? format.getInteger(KEY_CROP_RIGHT) - format.getInteger(KEY_CROP_LEFT) + 1
-        : format.getInteger(android.media.MediaFormat.KEY_WIDTH);
+        ? outputFormat.getInteger(KEY_CROP_RIGHT) - outputFormat.getInteger(KEY_CROP_LEFT) + 1
+        : outputFormat.getInteger(android.media.MediaFormat.KEY_WIDTH);
     currentHeight = hasCrop
-        ? format.getInteger(KEY_CROP_BOTTOM) - format.getInteger(KEY_CROP_TOP) + 1
-        : format.getInteger(android.media.MediaFormat.KEY_HEIGHT);
+        ? outputFormat.getInteger(KEY_CROP_BOTTOM) - outputFormat.getInteger(KEY_CROP_TOP) + 1
+        : outputFormat.getInteger(android.media.MediaFormat.KEY_HEIGHT);
   }
 
   @Override
@@ -427,7 +436,6 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     if (!renderedFirstFrame) {
       renderOutputBufferImmediate(codec, bufferIndex);
-      renderedFirstFrame = true;
       return true;
     }
 
@@ -463,14 +471,14 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
-  private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
+  protected void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
     codecCounters.skippedOutputBufferCount++;
   }
 
-  private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
+  protected void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("dropVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
@@ -481,22 +489,24 @@ private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     }
   }
 
-  private void renderOutputBufferImmediate(MediaCodec codec, int bufferIndex) {
+  protected void renderOutputBufferImmediate(MediaCodec codec, int bufferIndex) {
     maybeNotifyVideoSizeChanged();
     TraceUtil.beginSection("renderVideoBufferImmediate");
     codec.releaseOutputBuffer(bufferIndex, true);
     TraceUtil.endSection();
     codecCounters.renderedOutputBufferCount++;
+    renderedFirstFrame = true;
     maybeNotifyDrawnToSurface();
   }
 
   @TargetApi(21)
-  private void renderOutputBufferTimedV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
+  protected void renderOutputBufferTimedV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
     TraceUtil.beginSection("releaseOutputBufferTimed");
     codec.releaseOutputBuffer(bufferIndex, releaseTimeNs);
     TraceUtil.endSection();
     codecCounters.renderedOutputBufferCount++;
+    renderedFirstFrame = true;
     maybeNotifyDrawnToSurface();
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 5d1bf3945b..f98ea72f8a 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -40,6 +40,8 @@
   public final String mimeType;
   public final int maxInputSize;
 
+  public final long durationUs;
+
   public final int width;
   public final int height;
   public final float pixelWidthHeightRatio;
@@ -47,13 +49,11 @@
   public final int channelCount;
   public final int sampleRate;
 
-  public final int bitrate;
+  public final List<byte[]> initializationData;
 
   private int maxWidth;
   private int maxHeight;
 
-  public final List<byte[]> initializationData;
-
   // Lazy-initialized hashcode.
   private int hashCode;
   // Possibly-lazy-initialized framework media format.
@@ -66,25 +66,32 @@ public static MediaFormat createFromFrameworkMediaFormatV16(android.media.MediaF
 
   public static MediaFormat createVideoFormat(String mimeType, int maxInputSize, int width,
       int height, List<byte[]> initializationData) {
-    return createVideoFormat(mimeType, maxInputSize, width, height, 1, initializationData);
+    return createVideoFormat(
+        mimeType, maxInputSize, C.UNKNOWN_TIME_US, width, height, initializationData);
   }
 
-  public static MediaFormat createVideoFormat(String mimeType, int maxInputSize, int width,
-      int height, float pixelWidthHeightRatio, List<byte[]> initializationData) {
-    return new MediaFormat(mimeType, maxInputSize, width, height, pixelWidthHeightRatio, NO_VALUE,
+  public static MediaFormat createVideoFormat(String mimeType, int maxInputSize, long durationUs,
+      int width, int height, List<byte[]> initializationData) {
+    return createVideoFormat(
+        mimeType, maxInputSize, durationUs, width, height, 1, initializationData);
+  }
+
+  public static MediaFormat createVideoFormat(String mimeType, int maxInputSize, long durationUs,
+      int width, int height, float pixelWidthHeightRatio, List<byte[]> initializationData) {
+    return new MediaFormat(mimeType, maxInputSize, durationUs, width, height, pixelWidthHeightRatio,
         NO_VALUE, NO_VALUE, initializationData);
   }
 
   public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, int channelCount,
       int sampleRate, List<byte[]> initializationData) {
-    return new MediaFormat(mimeType, maxInputSize, NO_VALUE, NO_VALUE, NO_VALUE, channelCount,
-        sampleRate, NO_VALUE, initializationData);
+    return createAudioFormat(
+        mimeType, maxInputSize, C.UNKNOWN_TIME_US, channelCount, sampleRate, initializationData);
   }
 
-  public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, int channelCount,
-      int sampleRate, int bitrate, List<byte[]> initializationData) {
-    return new MediaFormat(mimeType, maxInputSize, NO_VALUE, NO_VALUE, NO_VALUE, channelCount,
-        sampleRate, bitrate, initializationData);
+  public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, long durationUs,
+      int channelCount, int sampleRate, List<byte[]> initializationData) {
+    return new MediaFormat(mimeType, maxInputSize, durationUs, NO_VALUE, NO_VALUE, NO_VALUE,
+        channelCount, sampleRate, initializationData);
   }
 
   public static MediaFormat createId3Format() {
@@ -100,8 +107,8 @@ public static MediaFormat createTtmlFormat() {
   }
 
   public static MediaFormat createFormatForMimeType(String mimeType) {
-    return new MediaFormat(mimeType, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, null);
+    return new MediaFormat(mimeType, NO_VALUE, C.UNKNOWN_TIME_US, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, null);
   }
 
   @TargetApi(16)
@@ -113,7 +120,6 @@ private MediaFormat(android.media.MediaFormat format) {
     height = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_HEIGHT);
     channelCount = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_CHANNEL_COUNT);
     sampleRate = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_SAMPLE_RATE);
-    bitrate = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_BIT_RATE);
     pixelWidthHeightRatio = getOptionalFloatV16(format, KEY_PIXEL_WIDTH_HEIGHT_RATIO);
     initializationData = new ArrayList<byte[]>();
     for (int i = 0; format.containsKey("csd-" + i); i++) {
@@ -123,21 +129,23 @@ private MediaFormat(android.media.MediaFormat format) {
       initializationData.add(data);
       buffer.flip();
     }
+    durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
+        ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
     maxWidth = NO_VALUE;
     maxHeight = NO_VALUE;
   }
 
-  private MediaFormat(String mimeType, int maxInputSize, int width, int height,
-      float pixelWidthHeightRatio, int channelCount, int sampleRate, int bitrate,
+  private MediaFormat(String mimeType, int maxInputSize, long durationUs, int width, int height,
+      float pixelWidthHeightRatio, int channelCount, int sampleRate,
       List<byte[]> initializationData) {
     this.mimeType = mimeType;
     this.maxInputSize = maxInputSize;
+    this.durationUs = durationUs;
     this.width = width;
     this.height = height;
     this.pixelWidthHeightRatio = pixelWidthHeightRatio;
     this.channelCount = channelCount;
     this.sampleRate = sampleRate;
-    this.bitrate = bitrate;
     this.initializationData = initializationData == null ? Collections.<byte[]>emptyList()
         : initializationData;
     maxWidth = NO_VALUE;
@@ -169,11 +177,11 @@ public int hashCode() {
       result = 31 * result + width;
       result = 31 * result + height;
       result = 31 * result + Float.floatToRawIntBits(pixelWidthHeightRatio);
+      result = 31 * result + (int) durationUs;
       result = 31 * result + maxWidth;
       result = 31 * result + maxHeight;
       result = 31 * result + channelCount;
       result = 31 * result + sampleRate;
-      result = 31 * result + bitrate;
       for (int i = 0; i < initializationData.size(); i++) {
         result = 31 * result + Arrays.hashCode(initializationData.get(i));
       }
@@ -209,7 +217,6 @@ private boolean equalsInternal(MediaFormat other, boolean ignoreMaxDimensions) {
         || (!ignoreMaxDimensions && (maxWidth != other.maxWidth || maxHeight != other.maxHeight))
         || channelCount != other.channelCount || sampleRate != other.sampleRate
         || !Util.areEqual(mimeType, other.mimeType)
-        || bitrate != other.bitrate
         || initializationData.size() != other.initializationData.size()) {
       return false;
     }
@@ -224,7 +231,7 @@ private boolean equalsInternal(MediaFormat other, boolean ignoreMaxDimensions) {
   @Override
   public String toString() {
     return "MediaFormat(" + mimeType + ", " + maxInputSize + ", " + width + ", " + height + ", "
-        + pixelWidthHeightRatio + ", " + channelCount + ", " + sampleRate + ", " + bitrate + ", "
+        + pixelWidthHeightRatio + ", " + channelCount + ", " + sampleRate + ", " + durationUs + ", "
         + maxWidth + ", " + maxHeight + ")";
   }
 
@@ -241,11 +248,13 @@ public String toString() {
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_HEIGHT, height);
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_CHANNEL_COUNT, channelCount);
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_SAMPLE_RATE, sampleRate);
-      maybeSetIntegerV16(format, android.media.MediaFormat.KEY_BIT_RATE, bitrate);
       maybeSetFloatV16(format, KEY_PIXEL_WIDTH_HEIGHT_RATIO, pixelWidthHeightRatio);
       for (int i = 0; i < initializationData.size(); i++) {
         format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
       }
+      if (durationUs != C.UNKNOWN_TIME_US) {
+        format.setLong(android.media.MediaFormat.KEY_DURATION, durationUs);
+      }
       maybeSetMaxDimensionsV16(format);
       frameworkMediaFormat = format;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormatHolder.java b/library/src/main/java/com/google/android/exoplayer/MediaFormatHolder.java
index 621a0f7986..fef993b945 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormatHolder.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormatHolder.java
@@ -15,8 +15,7 @@
  */
 package com.google.android.exoplayer;
 
-import java.util.Map;
-import java.util.UUID;
+import com.google.android.exoplayer.drm.DrmInitData;
 
 /**
  * Holds a {@link MediaFormat} and corresponding drm scheme initialization data.
@@ -28,9 +27,8 @@
    */
   public MediaFormat format;
   /**
-   * Initialization data for each of the drm schemes supported by the media, keyed by scheme UUID.
-   * Null if the media is not encrypted.
+   * Initialization data for drm schemes supported by the media. Null if the media is not encrypted.
    */
-  public Map<UUID, byte[]> drmInitData;
+  public DrmInitData drmInitData;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleHolder.java b/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
index 9a258b752c..59873e5921 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleHolder.java
@@ -50,9 +50,8 @@
   public int size;
 
   /**
-   * Flags that accompany the sample. A combination of
-   * {@link android.media.MediaExtractor#SAMPLE_FLAG_SYNC} and
-   * {@link android.media.MediaExtractor#SAMPLE_FLAG_ENCRYPTED}
+   * Flags that accompany the sample. A combination of {@link C#SAMPLE_FLAG_SYNC},
+   * {@link C#SAMPLE_FLAG_ENCRYPTED} and {@link C#SAMPLE_FLAG_DECODE_ONLY}.
    */
   public int flags;
 
@@ -61,11 +60,6 @@
    */
   public long timeUs;
 
-  /**
-   * If true then the sample should be decoded, but should not be presented.
-   */
-  public boolean decodeOnly;
-
   private final int bufferReplacementMode;
 
   /**
@@ -96,6 +90,27 @@ public boolean replaceBuffer(int capacity) {
     return false;
   }
 
+  /**
+   * Returns whether {@link #flags} has {@link C#SAMPLE_FLAG_ENCRYPTED} set.
+   */
+  public boolean isEncrypted() {
+    return (flags & C.SAMPLE_FLAG_ENCRYPTED) != 0;
+  }
+
+  /**
+   * Returns whether {@link #flags} has {@link C#SAMPLE_FLAG_DECODE_ONLY} set.
+   */
+  public boolean isDecodeOnly() {
+    return (flags & C.SAMPLE_FLAG_DECODE_ONLY) != 0;
+  }
+
+  /**
+   * Returns whether {@link #flags} has {@link C#SAMPLE_FLAG_SYNC} set.
+   */
+  public boolean isSyncFrame() {
+    return (flags & C.SAMPLE_FLAG_SYNC) != 0;
+  }
+
   /**
    * Clears {@link #data}. Does nothing if {@link #data} is null.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSource.java b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
index 9a3d40819b..b7a93e3f65 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
@@ -57,10 +57,11 @@
    * and formats). If insufficient data is available then the call will return {@code false} rather
    * than block. The method can be called repeatedly until the return value indicates success.
    *
+   * @param positionUs The player's current playback position.
    * @return True if the source was prepared successfully, false otherwise.
    * @throws IOException If an error occurred preparing the source.
    */
-  public boolean prepare() throws IOException;
+  public boolean prepare(long positionUs) throws IOException;
 
   /**
    * Returns the number of tracks exposed by the source.
diff --git a/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java b/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
index 7248f1cdeb..1245ea6454 100644
--- a/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
@@ -107,7 +107,7 @@ public long adjustReleaseTime(long unadjustedFrameTimeUs, long unadjustedRelease
       if (frameCount >= MIN_FRAMES_FOR_ADJUSTMENT) {
         // We're synced and have waited the required number of frames to apply an adjustment.
         // Calculate the average frame time across all the frames we've seen since the last sync.
-        // This will typically give us a framerate at a finer granularity than the frame times
+        // This will typically give us a frame rate at a finer granularity than the frame times
         // themselves (which often only have millisecond granularity).
         long averageFrameTimeNs = (unadjustedFrameTimeNs - syncFrameTimeNs) / frameCount;
         // Project the adjusted frame time forward using the average.
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index 8d5534e0b7..3b8b4f372b 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -25,7 +25,7 @@
  * will transition its renderers through various states as the overall playback state changes. The
  * valid state transitions are shown below, annotated with the methods that are invoked during each
  * transition.
- * <p align="center"><img src="../../../../../doc_src/images/trackrenderer_state.png"
+ * <p align="center"><img src="../../../../../images/trackrenderer_state.png"
  *     alt="TrackRenderer state transitions"
  *     border="0"/></p>
  */
@@ -108,11 +108,12 @@ protected final int getState() {
    * Prepares the renderer. This method is non-blocking, and hence it may be necessary to call it
    * more than once in order to transition the renderer into the prepared state.
    *
+   * @param positionUs The player's current playback position.
    * @return The current state (one of the STATE_* constants), for convenience.
    */
-  /* package */ final int prepare() throws ExoPlaybackException {
+  /* package */ final int prepare(long positionUs) throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_UNPREPARED);
-    state = doPrepare();
+    state = doPrepare(positionUs);
     Assertions.checkState(state == TrackRenderer.STATE_UNPREPARED ||
         state == TrackRenderer.STATE_PREPARED ||
         state == TrackRenderer.STATE_IGNORE);
@@ -127,11 +128,12 @@ protected final int getState() {
    * This method should return quickly, and should not block if the renderer is currently unable to
    * make any useful progress.
    *
+   * @param positionUs The player's current playback position.
    * @return The new state of the renderer. One of {@link #STATE_UNPREPARED},
    *     {@link #STATE_PREPARED} and {@link #STATE_IGNORE}.
    * @throws ExoPlaybackException If an error occurs.
    */
-  protected abstract int doPrepare() throws ExoPlaybackException;
+  protected abstract int doPrepare(long positionUs) throws ExoPlaybackException;
 
   /**
    * Enable the renderer.
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
index 24bcccaf03..0a56d2d7ed 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
@@ -15,13 +15,9 @@
  */
 package com.google.android.exoplayer.audio;
 
-import com.google.android.exoplayer.util.Util;
-
 import android.annotation.TargetApi;
-import android.media.AudioFormat;
 
-import java.util.HashSet;
-import java.util.Set;
+import java.util.Arrays;
 
 /**
  * Represents the set of audio formats a device is capable of playing back.
@@ -29,7 +25,7 @@
 @TargetApi(21)
 public final class AudioCapabilities {
 
-  private final Set<Integer> supportedEncodings;
+  private final int[] supportedEncodings;
   private final int maxChannelCount;
 
   /**
@@ -41,28 +37,23 @@
    * @param maxChannelCount The maximum number of audio channels that can be played simultaneously.
    */
   public AudioCapabilities(int[] supportedEncodings, int maxChannelCount) {
-    this.supportedEncodings = new HashSet<Integer>();
     if (supportedEncodings != null) {
-      for (int i : supportedEncodings) {
-        this.supportedEncodings.add(i);
-      }
+      this.supportedEncodings = Arrays.copyOf(supportedEncodings, supportedEncodings.length);
+      Arrays.sort(this.supportedEncodings);
+    } else {
+      this.supportedEncodings = new int[0];
     }
     this.maxChannelCount = maxChannelCount;
   }
 
-  /** Returns whether the device supports playback of AC-3. */
-  public boolean supportsAc3() {
-    return Util.SDK_INT >= 21 && supportedEncodings.contains(AudioFormat.ENCODING_AC3);
-  }
-
-  /** Returns whether the device supports playback of enhanced AC-3. */
-  public boolean supportsEAc3() {
-    return Util.SDK_INT >= 21 && supportedEncodings.contains(AudioFormat.ENCODING_E_AC3);
-  }
-
-  /** Returns whether the device supports playback of 16-bit PCM. */
-  public boolean supportsPcm() {
-    return supportedEncodings.contains(AudioFormat.ENCODING_PCM_16BIT);
+  /**
+   * Returns whether this device supports playback of the specified audio {@code encoding}.
+   *
+   * @param encoding One of {@link android.media.AudioFormat}'s {@code ENCODING_*} constants.
+   * @return Whether this device supports playback the specified audio {@code encoding}.
+   */
+  public boolean supportsEncoding(int encoding) {
+    return Arrays.binarySearch(supportedEncodings, encoding) >= 0;
   }
 
   /** Returns the maximum number of channels the device can play at the same time. */
@@ -79,19 +70,19 @@ public boolean equals(Object other) {
       return false;
     }
     AudioCapabilities audioCapabilities = (AudioCapabilities) other;
-    return supportedEncodings.equals(audioCapabilities.supportedEncodings)
+    return Arrays.equals(supportedEncodings, audioCapabilities.supportedEncodings)
         && maxChannelCount == audioCapabilities.maxChannelCount;
   }
 
   @Override
   public int hashCode() {
-    return maxChannelCount + 31 * supportedEncodings.hashCode();
+    return maxChannelCount + 31 * Arrays.hashCode(supportedEncodings);
   }
 
   @Override
   public String toString() {
     return "AudioCapabilities[maxChannelCount=" + maxChannelCount
-        + ", supportedEncodings=" + supportedEncodings + "]";
+        + ", supportedEncodings=" + Arrays.toString(supportedEncodings) + "]";
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 9c33014da8..96271a2774 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -16,9 +16,11 @@
 package com.google.android.exoplayer.audio;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Ac3Util;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.AudioFormat;
 import android.media.AudioManager;
@@ -44,6 +46,8 @@
  * <p>Call {@link #reconfigure} when the output format changes.
  *
  * <p>Call {@link #reset} to free resources. It is safe to re-{@link #initialize} the instance.
+ *
+ * <p>Call {@link #release} when the instance will no longer be used.
  */
 @TargetApi(16)
 public final class AudioTrack {
@@ -129,11 +133,21 @@ public WriteException(int errorCode) {
   private static final int MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US = 30000;
   private static final int MIN_TIMESTAMP_SAMPLE_INTERVAL_US = 500000;
 
+  /**
+   * Set to {@code true} to enable a workaround for an issue where an audio effect does not keep its
+   * session active across releasing/initializing a new audio track, on platform API version < 21.
+   * The flag must be set before creating the player.
+   */
+  public static boolean enablePreV21AudioSessionWorkaround = false;
+
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
+  private final AudioTrackUtil audioTrackUtil;
+
+  /** Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}). */
+  private android.media.AudioTrack keepSessionIdAudioTrack;
 
   private android.media.AudioTrack audioTrack;
-  private AudioTrackUtil audioTrackUtil;
   private int sampleRate;
   private int channelConfig;
   private int encoding;
@@ -175,6 +189,11 @@ public AudioTrack() {
         // There's no guarantee this method exists. Do nothing.
       }
     }
+    if (Util.SDK_INT >= 19) {
+      audioTrackUtil = new AudioTrackUtilV19();
+    } else {
+      audioTrackUtil = new AudioTrackUtil();
+    }
     playheadOffsets = new long[MAX_PLAYHEAD_OFFSET_COUNT];
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
@@ -267,37 +286,51 @@ public int initialize(int sessionId) throws InitializationException {
       audioTrack = new android.media.AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
           channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
     }
-
     checkAudioTrackInitialized();
-    if (Util.SDK_INT >= 19) {
-      audioTrackUtil = new AudioTrackUtilV19(audioTrack);
-    } else {
-      audioTrackUtil = new AudioTrackUtil(audioTrack);
+
+    sessionId = audioTrack.getAudioSessionId();
+    if (enablePreV21AudioSessionWorkaround) {
+      if (Util.SDK_INT < 21) {
+        // The workaround creates an audio track with a one byte buffer on the same session, and
+        // does not release it until this object is released, which keeps the session active.
+        if (keepSessionIdAudioTrack != null
+            && sessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
+          releaseKeepSessionIdAudioTrack();
+        }
+        if (keepSessionIdAudioTrack == null) {
+          int sampleRate = 4000; // Equal to private android.media.AudioTrack.MIN_SAMPLE_RATE.
+          int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
+          int encoding = AudioFormat.ENCODING_PCM_16BIT;
+          int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
+          keepSessionIdAudioTrack = new android.media.AudioTrack(AudioManager.STREAM_MUSIC,
+              sampleRate, channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STATIC,
+              sessionId);
+        }
+      }
     }
+
+    audioTrackUtil.reconfigure(audioTrack, isAc3);
     setVolume(volume);
-    return audioTrack.getAudioSessionId();
+
+    return sessionId;
   }
 
   /**
-   * Reconfigures the audio track to play back media in {@code format}. The encoding is assumed to
-   * be {@link AudioFormat#ENCODING_PCM_16BIT}.
+   * Reconfigures the audio track to play back media in {@code format}, inferring a buffer size from
+   * the format.
    */
   public void reconfigure(MediaFormat format) {
-    reconfigure(format, AudioFormat.ENCODING_PCM_16BIT, 0);
+    reconfigure(format, 0);
   }
 
   /**
-   * Reconfigures the audio track to play back media in {@code format}. Buffers passed to
-   * {@link #handleBuffer} must using the specified {@code encoding}, which should be a constant
-   * from {@link AudioFormat}.
+   * Reconfigures the audio track to play back media in {@code format}.
    *
    * @param format Specifies the channel count and sample rate to play back.
-   * @param encoding The format in which audio is represented.
    * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
    *     size inferred from the format.
    */
-  @SuppressLint("InlinedApi")
-  public void reconfigure(MediaFormat format, int encoding, int specifiedBufferSize) {
+  public void reconfigure(MediaFormat format, int specifiedBufferSize) {
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int channelConfig;
     switch (channelCount) {
@@ -318,9 +351,11 @@ public void reconfigure(MediaFormat format, int encoding, int specifiedBufferSiz
     }
 
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
+    String mimeType = format.getString(MediaFormat.KEY_MIME);
 
     // TODO: Does channelConfig determine channelCount?
-    boolean isAc3 = encoding == AudioFormat.ENCODING_AC3 || encoding == AudioFormat.ENCODING_E_AC3;
+    int encoding = MimeTypes.getEncodingForMimeType(mimeType);
+    boolean isAc3 = encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3;
     if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
         && !this.isAc3 && !isAc3) {
       // We already have an existing audio track with the correct sample rate and channel config.
@@ -336,6 +371,7 @@ public void reconfigure(MediaFormat format, int encoding, int specifiedBufferSiz
     ac3Bitrate = UNKNOWN_AC3_BITRATE; // Calculated on receiving the first buffer if isAc3 is true.
     frameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
     minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+    Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
 
     if (specifiedBufferSize != 0) {
       bufferSize = specifiedBufferSize;
@@ -387,14 +423,27 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
       return RESULT_BUFFER_CONSUMED;
     }
 
+    // Workarounds for issues with AC-3 passthrough AudioTracks on API versions 21/22:
+    if (Util.SDK_INT <= 22 && isAc3) {
+      // An AC-3 audio track continues to play data written while it is paused. Stop writing so its
+      // buffer empties. See [Internal: b/18899620].
+      if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED) {
+        return 0;
+      }
+
+      // A new AC-3 audio track's playback position continues to increase from the old track's
+      // position for a short time after is has been released. Avoid writing data until the playback
+      // head position actually returns to zero.
+      if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_STOPPED
+          && audioTrackUtil.getPlaybackHeadPosition() != 0) {
+        return 0;
+      }
+    }
+
     int result = 0;
     if (temporaryBufferSize == 0) {
       if (isAc3 && ac3Bitrate == UNKNOWN_AC3_BITRATE) {
-        // Each AC-3 buffer contains 1536 frames of audio, so the AudioTrack playback position
-        // advances by 1536 per buffer (32 ms at 48 kHz). Calculate the bitrate in kbit/s.
-        int unscaledAc3Bitrate = size * 8 * sampleRate;
-        int divisor = 1000 * 1536;
-        ac3Bitrate = (unscaledAc3Bitrate + divisor / 2) / divisor;
+        ac3Bitrate = Ac3Util.getBitrate(size, sampleRate);
       }
 
       // This is the first time we've seen this {@code buffer}.
@@ -474,7 +523,8 @@ private static int writeNonBlockingV21(
   /** Returns whether the audio track has more data pending that will be played back. */
   public boolean hasPendingData() {
     return isInitialized()
-        && bytesToFrames(submittedBytes) > audioTrackUtil.getPlaybackHeadPosition();
+        && (bytesToFrames(submittedBytes) > audioTrackUtil.getPlaybackHeadPosition()
+            || audioTrackUtil.overrideHasPendingData());
   }
 
   /** Returns whether enough data has been supplied via {@link #handleBuffer} to begin playback. */
@@ -515,9 +565,9 @@ public void pause() {
   }
 
   /**
-   * Releases resources associated with this instance asynchronously. Calling {@link #initialize}
-   * will block until the audio track has been released, so it is safe to initialize immediately
-   * after resetting.
+   * Releases the underlying audio track asynchronously. Calling {@link #initialize} will block
+   * until the audio track has been released, so it is safe to initialize immediately after
+   * resetting. The audio session may remain active until the instance is {@link #release}d.
    */
   public void reset() {
     if (isInitialized()) {
@@ -532,7 +582,7 @@ public void reset() {
       // AudioTrack.release can take some time, so we call it on a background thread.
       final android.media.AudioTrack toRelease = audioTrack;
       audioTrack = null;
-      audioTrackUtil = null;
+      audioTrackUtil.reconfigure(null, false);
       releasingConditionVariable.close();
       new Thread() {
         @Override
@@ -547,6 +597,29 @@ public void run() {
     }
   }
 
+  /** Releases all resources associated with this instance. */
+  public void release() {
+    reset();
+    releaseKeepSessionIdAudioTrack();
+  }
+
+  /** Releases {@link #keepSessionIdAudioTrack} asynchronously, if it is non-{@code null}. */
+  private void releaseKeepSessionIdAudioTrack() {
+    if (keepSessionIdAudioTrack == null) {
+      return;
+    }
+
+    // AudioTrack.release can take some time, so we call it on a background thread.
+    final android.media.AudioTrack toRelease = keepSessionIdAudioTrack;
+    keepSessionIdAudioTrack = null;
+    new Thread() {
+      @Override
+      public void run() {
+        toRelease.release();
+      }
+    }.start();
+  }
+
   /** Returns whether {@link #getCurrentPositionUs} can return the current playback position. */
   private boolean hasCurrentPositionUs() {
     return isInitialized() && startMediaTimeUs != START_NOT_SET;
@@ -575,7 +648,8 @@ private void maybeSampleSyncParams() {
     }
 
     if (systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US) {
-      audioTimestampSet = audioTrackUtil.updateTimestamp();
+      // Don't use AudioTrack.getTimestamp() on AC-3 tracks, as it gives an incorrect timestamp.
+      audioTimestampSet = !isAc3 && audioTrackUtil.updateTimestamp();
       if (audioTimestampSet) {
         // Perform sanity checks on the timestamp.
         long audioTimestampUs = audioTrackUtil.getTimestampNanoTime() / 1000;
@@ -676,15 +750,42 @@ private void resetSyncParams() {
    */
   private static class AudioTrackUtil {
 
-    protected final android.media.AudioTrack audioTrack;
-    private final int sampleRate;
-
+    protected android.media.AudioTrack audioTrack;
+    private boolean isPassthrough;
+    private int sampleRate;
     private long lastRawPlaybackHeadPosition;
     private long rawPlaybackHeadWrapCount;
+    private long passthroughWorkaroundPauseOffset;
 
-    public AudioTrackUtil(android.media.AudioTrack audioTrack) {
+    /**
+     * Reconfigures the audio track utility helper to use the specified {@code audioTrack}.
+     *
+     * @param audioTrack The audio track to wrap.
+     * @param isPassthrough Whether the audio track is used for passthrough (e.g. AC-3) playback.
+     */
+    public void reconfigure(android.media.AudioTrack audioTrack, boolean isPassthrough) {
       this.audioTrack = audioTrack;
-      this.sampleRate = audioTrack.getSampleRate();
+      this.isPassthrough = isPassthrough;
+      lastRawPlaybackHeadPosition = 0;
+      rawPlaybackHeadWrapCount = 0;
+      passthroughWorkaroundPauseOffset = 0;
+      if (audioTrack != null) {
+        sampleRate = audioTrack.getSampleRate();
+      }
+    }
+
+    /**
+     * Returns whether the audio track should behave as though it has pending data. This is to work
+     * around an issue on platform API versions 21/22 where AC-3 audio tracks can't be paused, so we
+     * empty their buffers when paused. In this case, they should still behave as if they have
+     * pending data, otherwise writing will never resume.
+     *
+     * @see #handleBuffer
+     */
+    public boolean overrideHasPendingData() {
+      return Util.SDK_INT <= 22 && isPassthrough
+          && audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED
+          && audioTrack.getPlaybackHeadPosition() == 0;
     }
 
     /**
@@ -698,6 +799,21 @@ public AudioTrackUtil(android.media.AudioTrack audioTrack) {
      */
     public long getPlaybackHeadPosition() {
       long rawPlaybackHeadPosition = 0xFFFFFFFFL & audioTrack.getPlaybackHeadPosition();
+      if (Util.SDK_INT <= 22 && isPassthrough) {
+        // Work around issues with passthrough/direct AudioTracks on platform API versions 21/22:
+        // - After resetting, the new AudioTrack's playback position continues to increase for a
+        //   short time from the old AudioTrack's position, while in the PLAYSTATE_STOPPED state.
+        // - The playback head position jumps back to zero on paused passthrough/direct audio
+        //   tracks. See [Internal: b/19187573].
+        if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_STOPPED) {
+          // Prevent detecting a wrapped position.
+          lastRawPlaybackHeadPosition = rawPlaybackHeadPosition;
+        } else if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED
+            && rawPlaybackHeadPosition == 0) {
+          passthroughWorkaroundPauseOffset = lastRawPlaybackHeadPosition;
+        }
+        rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;
+      }
       if (lastRawPlaybackHeadPosition > rawPlaybackHeadPosition) {
         // The value must have wrapped around.
         rawPlaybackHeadWrapCount++;
@@ -764,11 +880,18 @@ public long getTimestampFramePosition() {
     private long lastRawTimestampFramePosition;
     private long lastTimestampFramePosition;
 
-    public AudioTrackUtilV19(android.media.AudioTrack audioTrack) {
-      super(audioTrack);
+    public AudioTrackUtilV19() {
       audioTimestamp = new AudioTimestamp();
     }
 
+    @Override
+    public void reconfigure(android.media.AudioTrack audioTrack, boolean isPassthrough) {
+      super.reconfigure(audioTrack, isPassthrough);
+      rawTimestampFramePositionWrapCount = 0;
+      lastRawTimestampFramePosition = 0;
+      lastTimestampFramePosition = 0;
+    }
+
     @Override
     public boolean updateTimestamp() {
       boolean updated = audioTrack.getTimestamp(audioTimestamp);
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java b/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java
new file mode 100644
index 0000000000..c155928020
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.SampleSource;
+
+import java.io.IOException;
+
+/**
+ * Interface for callbacks to be notified of chunk based {@link SampleSource} events.
+ */
+public interface BaseChunkSampleSourceEventListener {
+
+  /**
+   * Invoked when an upstream load is started.
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param length The length of the data being loaded in bytes, or {@link C#LENGTH_UNBOUNDED} if
+   *     the length of the data is not known in advance.
+   * @param type The type of the data being loaded.
+   * @param trigger The reason for the data being loaded.
+   * @param format The particular format to which this data corresponds, or null if the data being
+   *     loaded does not correspond to a format.
+   * @param mediaStartTimeMs The media time of the start of the data being loaded, or -1 if this
+   *     load is for initialization data.
+   * @param mediaEndTimeMs The media time of the end of the data being loaded, or -1 if this
+   *     load is for initialization data.
+   */
+  void onLoadStarted(int sourceId, long length, int type, int trigger, Format format,
+      int mediaStartTimeMs, int mediaEndTimeMs);
+
+  /**
+   * Invoked when the current load operation completes.
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param bytesLoaded The number of bytes that were loaded.
+   * @param type The type of the loaded data.
+   * @param trigger The reason for the data being loaded.
+   * @param format The particular format to which this data corresponds, or null if the loaded data
+   *     does not correspond to a format.
+   * @param mediaStartTimeMs The media time of the start of the loaded data, or -1 if this load was
+   *     for initialization data.
+   * @param mediaEndTimeMs The media time of the end of the loaded data, or -1 if this load was for
+   *     initialization data.
+   * @param elapsedRealtimeMs {@code elapsedRealtime} timestamp of when the load finished.
+   * @param loadDurationMs Amount of time taken to load the data.
+   */
+   void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Format format,
+       int mediaStartTimeMs, int mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs);
+
+  /**
+   * Invoked when the current upstream load operation is canceled.
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param bytesLoaded The number of bytes that were loaded prior to the cancellation.
+   */
+  void onLoadCanceled(int sourceId, long bytesLoaded);
+
+  /**
+   * Invoked when an error occurs loading media data.
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param e The cause of the failure.
+   */
+  void onLoadError(int sourceId, IOException e);
+
+  /**
+   * Invoked when data is removed from the back of the buffer, typically so that it can be
+   * re-buffered using a different representation.
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param mediaStartTimeMs The media time of the start of the discarded data.
+   * @param mediaEndTimeMs The media time of the end of the discarded data.
+   */
+  void onUpstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs);
+
+  /**
+   * Invoked when the downstream format changes (i.e. when the format being supplied to the
+   * caller of {@link SampleSource#readData} changes).
+   *
+   * @param sourceId The id of the reporting {@link SampleSource}.
+   * @param format The format.
+   * @param trigger The trigger specified in the corresponding upstream load, as specified by the
+   *     {@link ChunkSource}.
+   * @param mediaTimeMs The media time at which the change occurred.
+   */
+  void onDownstreamFormatChanged(int sourceId, Format format, int trigger, int mediaTimeMs);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java
new file mode 100644
index 0000000000..73db1785d1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.DefaultTrackOutput;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+/**
+ * A base implementation of {@link MediaChunk}, for chunks that contain a single track.
+ * <p>
+ * Loaded samples are output to a {@link DefaultTrackOutput}.
+ */
+public abstract class BaseMediaChunk extends MediaChunk {
+
+  /**
+   * Whether {@link #getMediaFormat()} and {@link #getDrmInitData()} can be called at any time to
+   * obtain the chunk's media format and drm initialization data. If false, these methods are only
+   * guaranteed to return correct data after the first sample data has been output from the chunk.
+   */
+  public final boolean isFormatFinal;
+
+  private DefaultTrackOutput output;
+  private int firstSampleIndex;
+
+  /**
+   * @param dataSource A {@link DataSource} for loading the data.
+   * @param dataSpec Defines the data to be loaded.
+   * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
+   * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
+   * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
+   * @param chunkIndex The index of the chunk.
+   * @param isLastChunk True if this is the last chunk in the media. False otherwise.
+   * @param isFormatFinal True if {@link #getMediaFormat()} and {@link #getDrmInitData()} can be
+   *     called at any time to obtain the media format and drm initialization data. False if these
+   *     methods are only guaranteed to return correct data after the first sample data has been
+   *     output from the chunk.
+   */
+  public BaseMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
+      long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk,
+      boolean isFormatFinal) {
+    super(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs, chunkIndex, isLastChunk);
+    this.isFormatFinal = isFormatFinal;
+  }
+
+  /**
+   * Initializes the chunk for loading, setting the {@link DefaultTrackOutput} that will receive
+   * samples as they are loaded.
+   *
+   * @param output The output that will receive the loaded samples.
+   */
+  public void init(DefaultTrackOutput output) {
+    this.output = output;
+    this.firstSampleIndex = output.getWriteIndex();
+  }
+
+  /**
+   * Returns the index of the first sample in the output that was passed to
+   * {@link #init(DefaultTrackOutput)} that will originate from this chunk.
+   */
+  public final int getFirstSampleIndex() {
+    return firstSampleIndex;
+  }
+
+  /**
+   * Gets the {@link MediaFormat} corresponding to the chunk.
+   * <p>
+   * See {@link #isFormatFinal} for information about when this method is guaranteed to return
+   * correct data.
+   *
+   * @return The {@link MediaFormat} corresponding to this chunk.
+   */
+  public abstract MediaFormat getMediaFormat();
+
+  /**
+   * Gets the {@link DrmInitData} corresponding to the chunk.
+   * <p>
+   * See {@link #isFormatFinal} for information about when this method is guaranteed to return
+   * correct data.
+   *
+   * @return The {@link DrmInitData} corresponding to this chunk.
+   */
+  public abstract DrmInitData getDrmInitData();
+
+  /**
+   * Returns the output most recently passed to {@link #init(DefaultTrackOutput)}.
+   */
+  protected final DefaultTrackOutput getOutput() {
+    return output;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
index 9949037f4d..e0bd379b5f 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
@@ -15,18 +15,10 @@
  */
 package com.google.android.exoplayer.chunk;
 
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.upstream.Allocation;
-import com.google.android.exoplayer.upstream.Allocator;
 import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSourceStream;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.TraceUtil;
-
-import java.io.IOException;
 
 /**
  * An abstract base class for {@link Loadable} implementations that load chunks of data required
@@ -35,151 +27,94 @@
 public abstract class Chunk implements Loadable {
 
   /**
-   * The format associated with the data being loaded.
+   * Value of {@link #type} for chunks containing unspecified data.
    */
-  // TODO: Consider removing this and pushing it down into MediaChunk instead.
-  public final Format format;
+  public static final int TYPE_UNSPECIFIED = 0;
   /**
-   * The reason for a {@link ChunkSource} having generated this chunk. For reporting only. Possible
-   * values for this variable are defined by the specific {@link ChunkSource} implementations.
+   * Value of {@link #type} for chunks containing media data.
    */
-  public final int trigger;
-
-  private final DataSource dataSource;
-  private final DataSpec dataSpec;
-
-  private DataSourceStream dataSourceStream;
-
+  public static final int TYPE_MEDIA = 1;
   /**
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
-   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
-   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
-   *     {@link Integer#MAX_VALUE}.
-   * @param format See {@link #format}.
-   * @param trigger See {@link #trigger}.
+   * Value of {@link #type} for chunks containing media initialization data.
    */
-  public Chunk(DataSource dataSource, DataSpec dataSpec, Format format, int trigger) {
-    Assertions.checkState(dataSpec.length <= Integer.MAX_VALUE);
-    this.dataSource = Assertions.checkNotNull(dataSource);
-    this.dataSpec = Assertions.checkNotNull(dataSpec);
-    this.format = Assertions.checkNotNull(format);
-    this.trigger = trigger;
-  }
-
+  public static final int TYPE_MEDIA_INITIALIZATION = 2;
   /**
-   * Initializes the {@link Chunk}.
-   *
-   * @param allocator An {@link Allocator} from which the {@link Allocation} needed to contain the
-   *     data can be obtained.
+   * Value of {@link #type} for chunks containing drm related data.
    */
-  public final void init(Allocator allocator) {
-    Assertions.checkState(dataSourceStream == null);
-    dataSourceStream = new DataSourceStream(dataSource, dataSpec, allocator);
-  }
-
+  public static final int TYPE_DRM = 3;
   /**
-   * Releases the {@link Chunk}, releasing any backing {@link Allocation}s.
+   * Value of {@link #type} for chunks containing manifest or playlist data.
    */
-  public final void release() {
-    if (dataSourceStream != null) {
-      dataSourceStream.close();
-      dataSourceStream = null;
-    }
-  }
-
+  public static final int TYPE_MANIFEST = 4;
   /**
-   * Gets the length of the chunk in bytes.
-   *
-   * @return The length of the chunk in bytes, or {@link C#LENGTH_UNBOUNDED} if the length has yet
-   *     to be determined.
+   * Implementations may define custom {@link #type} codes greater than or equal to this value.
    */
-  public final long getLength() {
-    return dataSourceStream.getLength();
-  }
+  public static final int TYPE_CUSTOM_BASE = 10000;
 
   /**
-   * Whether the whole of the data has been consumed.
-   *
-   * @return True if the whole of the data has been consumed. False otherwise.
+   * Value of {@link #trigger} for a load whose reason is unspecified.
    */
-  public final boolean isReadFinished() {
-    return dataSourceStream.isEndOfStream();
-  }
-
+  public static final int TRIGGER_UNSPECIFIED = 0;
   /**
-   * Whether the whole of the chunk has been loaded.
-   *
-   * @return True if the whole of the chunk has been loaded. False otherwise.
+   * Value of {@link #trigger} for a load triggered by an initial format selection.
    */
-  public final boolean isLoadFinished() {
-    return dataSourceStream.isLoadFinished();
-  }
-
+  public static final int TRIGGER_INITIAL = 1;
   /**
-   * Gets the number of bytes that have been loaded.
-   *
-   * @return The number of bytes that have been loaded.
+   * Value of {@link #trigger} for a load triggered by a user initiated format selection.
    */
-  public final long bytesLoaded() {
-    return dataSourceStream.getLoadPosition();
-  }
-
+  public static final int TRIGGER_MANUAL = 2;
   /**
-   * Causes loaded data to be consumed.
-   *
-   * @throws IOException If an error occurs consuming the loaded data.
+   * Value of {@link #trigger} for a load triggered by an adaptive format selection.
    */
-  public final void consume() throws IOException {
-    Assertions.checkState(dataSourceStream != null);
-    consumeStream(dataSourceStream);
-  }
-
+  public static final int TRIGGER_ADAPTIVE = 3;
   /**
-   * Invoked by {@link #consume()}. Implementations may override this method if they wish to
-   * consume the loaded data at this point.
-   * <p>
-   * The default implementation is a no-op.
-   *
-   * @param stream The stream of loaded data.
-   * @throws IOException If an error occurs consuming the loaded data.
+   * Implementations may define custom {@link #trigger} codes greater than or equal to this value.
    */
-  protected void consumeStream(NonBlockingInputStream stream) throws IOException {
-    // Do nothing.
-  }
-
-  protected final NonBlockingInputStream getNonBlockingInputStream() {
-    return dataSourceStream;
-  }
-
-  protected final void resetReadPosition() {
-    if (dataSourceStream != null) {
-      dataSourceStream.resetReadPosition();
-    } else {
-      // We haven't been initialized yet, so the read position must already be 0.
-    }
-  }
+  public static final int TRIGGER_CUSTOM_BASE = 10000;
 
-  // Loadable implementation
+  /**
+   * The type of the chunk. For reporting only.
+   */
+  public final int type;
+  /**
+   * The reason why the chunk was generated. For reporting only.
+   */
+  public final int trigger;
+  /**
+   * The format associated with the data being loaded, or null if the data being loaded is not
+   * associated with a specific format.
+   */
+  public final Format format;
+  /**
+   * The {@link DataSpec} that defines the data to be loaded.
+   */
+  public final DataSpec dataSpec;
 
-  @Override
-  public final void cancelLoad() {
-    dataSourceStream.cancelLoad();
-  }
+  protected final DataSource dataSource;
 
-  @Override
-  public final boolean isLoadCanceled() {
-    return dataSourceStream.isLoadCanceled();
+  /**
+   * @param dataSource The source from which the data should be loaded.
+   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
+   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
+   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
+   *     {@link Integer#MAX_VALUE}.
+   * @param type See {@link #type}.
+   * @param trigger See {@link #trigger}.
+   * @param format See {@link #format}.
+   */
+  public Chunk(DataSource dataSource, DataSpec dataSpec, int type, int trigger, Format format) {
+    this.dataSource = Assertions.checkNotNull(dataSource);
+    this.dataSpec = Assertions.checkNotNull(dataSpec);
+    this.type = type;
+    this.trigger = trigger;
+    this.format = format;
   }
 
-  @Override
-  public final void load() throws IOException, InterruptedException {
-    TraceUtil.beginSection("chunkLoad");
-    try {
-      dataSourceStream.load();
-    } finally {
-      TraceUtil.endSection();
-    }
-  }
+  /**
+   * Gets the number of bytes that have been loaded.
+   *
+   * @return The number of bytes that have been loaded.
+   */
+  public abstract long bytesLoaded();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
new file mode 100644
index 0000000000..7cc0c72eeb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * An {@link Extractor} wrapper for loading chunks containing a single track.
+ * <p>
+ * The wrapper allows switching of the {@link SingleTrackOutput} that receives parsed data.
+ */
+public final class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
+
+  /**
+   * Receives stream level data extracted by the wrapped {@link Extractor}.
+   */
+  public interface SingleTrackOutput extends TrackOutput {
+
+    /**
+     * @see ExtractorOutput#seekMap(SeekMap)
+     */
+    void seekMap(SeekMap seekMap);
+
+    /**
+     * @see ExtractorOutput#drmInitData(DrmInitData)
+     */
+    void drmInitData(DrmInitData drmInitData);
+
+  }
+
+  private final Extractor extractor;
+  private boolean extractorInitialized;
+  private SingleTrackOutput output;
+
+  // Accessed only on the loader thread.
+  private boolean seenTrack;
+
+  /**
+   * @param extractor The extractor to wrap.
+   */
+  public ChunkExtractorWrapper(Extractor extractor) {
+    this.extractor = extractor;
+  }
+
+  /**
+   * Initializes the extractor to output to the provided {@link SingleTrackOutput}, and configures
+   * it to receive data from a new chunk.
+   *
+   * @param output The {@link SingleTrackOutput} that will receive the parsed data.
+   */
+  public void init(SingleTrackOutput output) {
+    this.output = output;
+    if (!extractorInitialized) {
+      extractor.init(this);
+      extractorInitialized = true;
+    } else {
+      extractor.seek();
+    }
+  }
+
+  /**
+   * Reads from the provided {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @return One of {@link Extractor#RESULT_CONTINUE} and {@link Extractor#RESULT_END_OF_INPUT}.
+   * @throws IOException If an error occurred reading from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public int read(ExtractorInput input) throws IOException, InterruptedException {
+    int result = extractor.read(input, null);
+    Assertions.checkState(result != Extractor.RESULT_SEEK);
+    return result;
+  }
+
+  // ExtractorOutput implementation.
+
+  @Override
+  public TrackOutput track(int id) {
+    Assertions.checkState(!seenTrack);
+    seenTrack = true;
+    return this;
+  }
+
+  @Override
+  public void endTracks() {
+    Assertions.checkState(seenTrack);
+  }
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    output.seekMap(seekMap);
+  }
+
+  @Override
+  public void drmInitData(DrmInitData drmInitData) {
+    output.drmInitData(drmInitData);
+  }
+
+  // TrackOutput implementation.
+
+  @Override
+  public void format(MediaFormat format) {
+    output.format(format);
+  }
+
+  @Override
+  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
+    return output.sampleData(input, length);
+  }
+
+  @Override
+  public void sampleData(ParsableByteArray data, int length) {
+    output.sampleData(data, length);
+  }
+
+  @Override
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    output.sampleMetadata(timeUs, flags, size, offset, encryptionKey);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index c51be31c5c..a023a31244 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.extractor.DefaultTrackOutput;
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
@@ -32,7 +33,6 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -45,94 +45,7 @@
   /**
    * Interface definition for a callback to be notified of {@link ChunkSampleSource} events.
    */
-  public interface EventListener {
-
-    /**
-     * Invoked when an upstream load is started.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param formatId The format id.
-     * @param trigger A trigger for the format selection, as specified by the {@link ChunkSource}.
-     * @param isInitialization Whether the load is for format initialization data.
-     * @param mediaStartTimeMs The media time of the start of the data being loaded, or -1 if this
-     *     load is for initialization data.
-     * @param mediaEndTimeMs The media time of the end of the data being loaded, or -1 if this
-     *     load is for initialization data.
-     * @param length The length of the data being loaded in bytes, or {@link C#LENGTH_UNBOUNDED} if
-     *     the length of the data has not yet been determined.
-     */
-    void onLoadStarted(int sourceId, String formatId, int trigger, boolean isInitialization,
-        int mediaStartTimeMs, int mediaEndTimeMs, long length);
-
-    /**
-     * Invoked when the current load operation completes.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param bytesLoaded The number of bytes that were loaded.
-     */
-    void onLoadCompleted(int sourceId, long bytesLoaded);
-
-    /**
-     * Invoked when the current upstream load operation is canceled.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param bytesLoaded The number of bytes that were loaded prior to the cancellation.
-     */
-    void onLoadCanceled(int sourceId, long bytesLoaded);
-
-    /**
-     * Invoked when data is removed from the back of the buffer, typically so that it can be
-     * re-buffered using a different representation.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param mediaStartTimeMs The media time of the start of the discarded data.
-     * @param mediaEndTimeMs The media time of the end of the discarded data.
-     * @param bytesDiscarded The length of the data being discarded in bytes.
-     */
-    void onUpstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs,
-        long bytesDiscarded);
-
-    /**
-     * Invoked when an error occurs loading media data.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param e The cause of the failure.
-     */
-    void onUpstreamError(int sourceId, IOException e);
-
-    /**
-     * Invoked when an error occurs consuming loaded data.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param e The cause of the failure.
-     */
-    void onConsumptionError(int sourceId, IOException e);
-
-    /**
-     * Invoked when data is removed from the front of the buffer, typically due to a seek or
-     * because the data has been consumed.
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param mediaStartTimeMs The media time of the start of the discarded data.
-     * @param mediaEndTimeMs The media time of the end of the discarded data.
-     * @param bytesDiscarded The length of the data being discarded in bytes.
-     */
-    void onDownstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeMs,
-        long bytesDiscarded);
-
-    /**
-     * Invoked when the downstream format changes (i.e. when the format being supplied to the
-     * caller of {@link SampleSource#readData} changes).
-     *
-     * @param sourceId The id of the reporting {@link SampleSource}.
-     * @param formatId The format id.
-     * @param trigger The trigger specified in the corresponding upstream load, as specified by the
-     *     {@link ChunkSource}.
-     * @param mediaTimeMs The media time at which the change occurred.
-     */
-    void onDownstreamFormatChanged(int sourceId, String formatId, int trigger, int mediaTimeMs);
-
-  }
+  public interface EventListener extends BaseChunkSampleSourceEventListener {}
 
   /**
    * The default minimum number of times to retry loading data prior to failing.
@@ -149,8 +62,9 @@ void onDownstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeM
   private final LoadControl loadControl;
   private final ChunkSource chunkSource;
   private final ChunkOperationHolder currentLoadableHolder;
-  private final LinkedList<MediaChunk> mediaChunks;
-  private final List<MediaChunk> readOnlyMediaChunks;
+  private final LinkedList<BaseMediaChunk> mediaChunks;
+  private final List<BaseMediaChunk> readOnlyMediaChunks;
+  private final DefaultTrackOutput sampleQueue;
   private final int bufferSizeContribution;
   private final boolean frameAccurateSeeking;
   private final Handler eventHandler;
@@ -165,13 +79,15 @@ void onDownstreamDiscarded(int sourceId, int mediaStartTimeMs, int mediaEndTimeM
   private boolean pendingDiscontinuity;
 
   private Loader loader;
+  private boolean loadingFinished;
   private IOException currentLoadableException;
   private boolean currentLoadableExceptionFatal;
   private int currentLoadableExceptionCount;
   private long currentLoadableExceptionTimestamp;
+  private long currentLoadStartTimeMs;
 
   private MediaFormat downstreamMediaFormat;
-  private volatile Format downstreamFormat;
+  private Format downstreamFormat;
 
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
       int bufferSizeContribution, boolean frameAccurateSeeking) {
@@ -197,22 +113,15 @@ public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
     this.eventSourceId = eventSourceId;
     this.minLoadableRetryCount = minLoadableRetryCount;
     currentLoadableHolder = new ChunkOperationHolder();
-    mediaChunks = new LinkedList<MediaChunk>();
+    mediaChunks = new LinkedList<BaseMediaChunk>();
     readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
+    sampleQueue = new DefaultTrackOutput(loadControl.getAllocator());
     state = STATE_UNPREPARED;
-  }
-
-  /**
-   * Exposes the current downstream format for debugging purposes. Can be called from any thread.
-   *
-   * @return The current downstream format.
-   */
-  public Format getFormat() {
-    return downstreamFormat;
+    pendingResetPositionUs = NO_RESET_PENDING;
   }
 
   @Override
-  public boolean prepare() {
+  public boolean prepare(long positionUs) {
     Assertions.checkState(state == STATE_UNPREPARED);
     loader = new Loader("Loader:" + chunkSource.getTrackInfo().mimeType);
     state = STATE_PREPARED;
@@ -259,7 +168,8 @@ public void disable(int track) {
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
-        clearMediaChunks();
+        sampleQueue.clear();
+        mediaChunks.clear();
         clearCurrentLoadable();
         loadControl.trimAllocator();
       }
@@ -273,22 +183,11 @@ public boolean continueBuffering(long positionUs) throws IOException {
     chunkSource.continueBuffering(positionUs);
     updateLoadControl();
 
-    boolean haveSamples = false;
-    if (isPendingReset() || mediaChunks.isEmpty()) {
-      // No sample available.
-    } else if (mediaChunks.getFirst().sampleAvailable()) {
-      // There's a sample available to be read from the current chunk.
-      haveSamples = true;
-    } else {
-      // It may be the case that the current chunk has been fully read but not yet discarded and
-      // that the next chunk has an available sample. Return true if so, otherwise false.
-      haveSamples = mediaChunks.size() > 1 && mediaChunks.get(1).sampleAvailable();
-    }
-
+    boolean haveSamples = !sampleQueue.isEmpty();
     if (!haveSamples) {
       maybeThrowLoadableException();
     }
-    return haveSamples;
+    return loadingFinished || haveSamples;
   }
 
   @Override
@@ -296,6 +195,7 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
     Assertions.checkState(state == STATE_ENABLED);
     Assertions.checkState(track == 0);
+    downstreamPositionUs = positionUs;
 
     if (pendingDiscontinuity) {
       pendingDiscontinuity = false;
@@ -306,84 +206,79 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       return NOTHING_READ;
     }
 
-    downstreamPositionUs = positionUs;
     if (isPendingReset()) {
       maybeThrowLoadableException();
-      IOException chunkSourceException = chunkSource.getError();
-      if (chunkSourceException != null) {
-        throw chunkSourceException;
-      }
       return NOTHING_READ;
     }
 
-    MediaChunk mediaChunk = mediaChunks.getFirst();
-    if (mediaChunk.isReadFinished()) {
-      // We've read all of the samples from the current media chunk.
-      if (mediaChunks.size() > 1) {
-        discardDownstreamMediaChunk();
-        mediaChunk = mediaChunks.getFirst();
-        mediaChunk.seekToStart();
-        return readData(track, positionUs, formatHolder, sampleHolder, false);
-      } else if (mediaChunk.isLastChunk()) {
-        return END_OF_STREAM;
-      }
-      IOException chunkSourceException = chunkSource.getError();
-      if (chunkSourceException != null) {
-        throw chunkSourceException;
-      }
-      return NOTHING_READ;
+    boolean haveSamples = !sampleQueue.isEmpty();
+    BaseMediaChunk currentChunk = mediaChunks.getFirst();
+    while (haveSamples && mediaChunks.size() > 1
+        && mediaChunks.get(1).getFirstSampleIndex() == sampleQueue.getReadIndex()) {
+      mediaChunks.removeFirst();
+      currentChunk = mediaChunks.getFirst();
     }
 
-    if (downstreamFormat == null || !downstreamFormat.equals(mediaChunk.format)) {
-      notifyDownstreamFormatChanged(mediaChunk.format.id, mediaChunk.trigger,
-          mediaChunk.startTimeUs);
-      downstreamFormat = mediaChunk.format;
+    if (downstreamFormat == null || !downstreamFormat.equals(currentChunk.format)) {
+      notifyDownstreamFormatChanged(currentChunk.format, currentChunk.trigger,
+          currentChunk.startTimeUs);
+      downstreamFormat = currentChunk.format;
     }
 
-    if (!mediaChunk.prepare()) {
-      if (currentLoadableException != null) {
-        throw currentLoadableException;
+    if (haveSamples || currentChunk.isFormatFinal) {
+      MediaFormat mediaFormat = currentChunk.getMediaFormat();
+      if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormat, true)) {
+        chunkSource.getMaxVideoDimensions(mediaFormat);
+        formatHolder.format = mediaFormat;
+        formatHolder.drmInitData = currentChunk.getDrmInitData();
+        downstreamMediaFormat = mediaFormat;
+        return FORMAT_READ;
       }
-      return NOTHING_READ;
     }
 
-    MediaFormat mediaFormat = mediaChunk.getMediaFormat();
-    if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormat, true)) {
-      chunkSource.getMaxVideoDimensions(mediaFormat);
-      formatHolder.format = mediaFormat;
-      formatHolder.drmInitData = mediaChunk.getPsshInfo();
-      downstreamMediaFormat = mediaFormat;
-      return FORMAT_READ;
+    if (!haveSamples) {
+      if (loadingFinished) {
+        return END_OF_STREAM;
+      }
+      maybeThrowLoadableException();
+      return NOTHING_READ;
     }
 
-    if (mediaChunk.read(sampleHolder)) {
-      sampleHolder.decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
-      onSampleRead(mediaChunk, sampleHolder);
+    if (sampleQueue.getSample(sampleHolder)) {
+      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
+      onSampleRead(currentChunk, sampleHolder);
       return SAMPLE_READ;
-    } else {
-      maybeThrowLoadableException();
-      return NOTHING_READ;
     }
+
+    maybeThrowLoadableException();
+    return NOTHING_READ;
   }
 
   @Override
   public void seekToUs(long positionUs) {
     Assertions.checkState(state == STATE_ENABLED);
-    downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
-    if (pendingResetPositionUs == positionUs) {
+    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
       return;
     }
 
-    MediaChunk mediaChunk = getMediaChunk(positionUs);
-    if (mediaChunk == null) {
-      restartFrom(positionUs);
-      pendingDiscontinuity = true;
+    downstreamPositionUs = positionUs;
+    // If we're not pending a reset, see if we can seek within the sample queue.
+    boolean seekInsideBuffer = !isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
+    if (seekInsideBuffer) {
+      // We succeeded. All we need to do is discard any chunks that we've moved past.
+      boolean haveSamples = !sampleQueue.isEmpty();
+      while (haveSamples && mediaChunks.size() > 1
+          && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
+        mediaChunks.removeFirst();
+      }
     } else {
-      pendingDiscontinuity |= mediaChunk.seekTo(positionUs, mediaChunk == mediaChunks.getFirst());
-      discardDownstreamMediaChunks(mediaChunk);
-      updateLoadControl();
+      // We failed, and need to restart.
+      restartFrom(positionUs);
     }
+    // Either way, we need to send a discontinuity to the downstream components.
+    pendingDiscontinuity = true;
   }
 
   private void maybeThrowLoadableException() throws IOException {
@@ -391,19 +286,12 @@ private void maybeThrowLoadableException() throws IOException {
         || currentLoadableExceptionCount > minLoadableRetryCount)) {
       throw currentLoadableException;
     }
-  }
-
-  private MediaChunk getMediaChunk(long positionUs) {
-    Iterator<MediaChunk> mediaChunkIterator = mediaChunks.iterator();
-    while (mediaChunkIterator.hasNext()) {
-      MediaChunk mediaChunk = mediaChunkIterator.next();
-      if (positionUs < mediaChunk.startTimeUs) {
-        return null;
-      } else if (mediaChunk.isLastChunk() || positionUs < mediaChunk.endTimeUs) {
-        return mediaChunk;
+    if (sampleQueue.isEmpty() && currentLoadableHolder.chunk == null) {
+      IOException chunkSourceException = chunkSource.getError();
+      if (chunkSourceException != null) {
+        throw chunkSourceException;
       }
     }
-    return null;
   }
 
   @Override
@@ -411,22 +299,12 @@ public long getBufferedPositionUs() {
     Assertions.checkState(state == STATE_ENABLED);
     if (isPendingReset()) {
       return pendingResetPositionUs;
-    }
-    MediaChunk mediaChunk = mediaChunks.getLast();
-    Chunk currentLoadable = currentLoadableHolder.chunk;
-    if (currentLoadable != null && mediaChunk == currentLoadable) {
-      // Linearly interpolate partially-fetched chunk times.
-      long chunkLength = mediaChunk.getLength();
-      if (chunkLength != C.LENGTH_UNBOUNDED && chunkLength != 0) {
-        return mediaChunk.startTimeUs + ((mediaChunk.endTimeUs - mediaChunk.startTimeUs) *
-            mediaChunk.bytesLoaded()) / chunkLength;
-      } else {
-        return mediaChunk.startTimeUs;
-      }
-    } else if (mediaChunk.isLastChunk()) {
+    } else if (loadingFinished) {
       return TrackRenderer.END_OF_TRACK_US;
     } else {
-      return mediaChunk.endTimeUs;
+      long largestParsedTimestampUs = sampleQueue.getLargestParsedTimestampUs();
+      return largestParsedTimestampUs == Long.MIN_VALUE ? downstreamPositionUs
+          : largestParsedTimestampUs;
     }
   }
 
@@ -442,39 +320,34 @@ public void release() {
 
   @Override
   public void onLoadCompleted(Loadable loadable) {
+    long now = SystemClock.elapsedRealtime();
+    long loadDurationMs = now - currentLoadStartTimeMs;
     Chunk currentLoadable = currentLoadableHolder.chunk;
-    notifyLoadCompleted(currentLoadable.bytesLoaded());
-    try {
-      currentLoadable.consume();
-    } catch (IOException e) {
-      currentLoadableException = e;
-      currentLoadableExceptionCount++;
-      currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
-      currentLoadableExceptionFatal = true;
-      notifyConsumptionError(e);
-    } finally {
-      if (!isMediaChunk(currentLoadable)) {
-        currentLoadable.release();
-      }
-      if (!currentLoadableExceptionFatal) {
-        clearCurrentLoadable();
-      }
-      updateLoadControl();
+    chunkSource.onChunkLoadCompleted(currentLoadable);
+    if (isMediaChunk(currentLoadable)) {
+      MediaChunk mediaChunk = (MediaChunk) currentLoadable;
+      notifyLoadCompleted(currentLoadable.bytesLoaded(), mediaChunk.type, mediaChunk.trigger,
+          mediaChunk.format, mediaChunk.startTimeUs, mediaChunk.endTimeUs, now, loadDurationMs);
+      loadingFinished = ((BaseMediaChunk) currentLoadable).isLastChunk;
+    } else {
+      notifyLoadCompleted(currentLoadable.bytesLoaded(), currentLoadable.type,
+          currentLoadable.trigger, currentLoadable.format, -1, -1, now, loadDurationMs);
     }
+    clearCurrentLoadable();
+    updateLoadControl();
   }
 
   @Override
   public void onLoadCanceled(Loadable loadable) {
     Chunk currentLoadable = currentLoadableHolder.chunk;
     notifyLoadCanceled(currentLoadable.bytesLoaded());
-    if (!isMediaChunk(currentLoadable)) {
-      currentLoadable.release();
-    }
     clearCurrentLoadable();
     if (state == STATE_ENABLED) {
       restartFrom(pendingResetPositionUs);
     } else {
-      clearMediaChunks();
+      sampleQueue.clear();
+      mediaChunks.clear();
+      clearCurrentLoadable();
       loadControl.trimAllocator();
     }
   }
@@ -484,39 +357,41 @@ public void onLoadError(Loadable loadable, IOException e) {
     currentLoadableException = e;
     currentLoadableExceptionCount++;
     currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
-    notifyUpstreamError(e);
+    notifyLoadError(e);
     chunkSource.onChunkLoadError(currentLoadableHolder.chunk, e);
     updateLoadControl();
   }
 
   /**
-   * Called when a sample has been read from a {@link MediaChunk}. Can be used to perform any
-   * modifications necessary before the sample is returned.
+   * Called when a sample has been read. Can be used to perform any modifications necessary before
+   * the sample is returned.
    *
-   * @param mediaChunk The MediaChunk the sample was ready from.
-   * @param sampleHolder The sample that has just been read.
+   * @param mediaChunk The chunk from which the sample was obtained.
+   * @param sampleHolder Holds the read sample.
    */
   protected void onSampleRead(MediaChunk mediaChunk, SampleHolder sampleHolder) {
-    // no-op
+    // Do nothing.
   }
 
   private void restartFrom(long positionUs) {
     pendingResetPositionUs = positionUs;
+    loadingFinished = false;
     if (loader.isLoading()) {
       loader.cancelLoading();
     } else {
-      clearMediaChunks();
+      sampleQueue.clear();
+      mediaChunks.clear();
       clearCurrentLoadable();
       updateLoadControl();
     }
   }
 
-  private void clearMediaChunks() {
-    discardDownstreamMediaChunks(null);
-  }
-
   private void clearCurrentLoadable() {
     currentLoadableHolder.chunk = null;
+    clearCurrentLoadableException();
+  }
+
+  private void clearCurrentLoadableException() {
     currentLoadableException = null;
     currentLoadableExceptionCount = 0;
     currentLoadableExceptionFatal = false;
@@ -579,8 +454,8 @@ private long getNextLoadPositionUs() {
     if (isPendingReset()) {
       return pendingResetPositionUs;
     } else {
-      MediaChunk lastMediaChunk = mediaChunks.getLast();
-      return lastMediaChunk.nextChunkIndex == -1 ? -1 : lastMediaChunk.endTimeUs;
+      BaseMediaChunk lastMediaChunk = mediaChunks.getLast();
+      return lastMediaChunk.isLastChunk ? -1 : lastMediaChunk.endTimeUs;
     }
   }
 
@@ -604,7 +479,9 @@ private void resumeFromBackOff() {
         // Chunk was unchanged. Resume loading.
         loader.startLoading(backedOffChunk, this);
       } else {
-        backedOffChunk.release();
+        // Chunk was changed. Notify that the existing load was canceled.
+        notifyLoadCanceled(backedOffChunk.bytesLoaded());
+        // Start loading the replacement.
         maybeStartLoading();
       }
       return;
@@ -619,7 +496,7 @@ private void resumeFromBackOff() {
 
     // The current loadable is the last media chunk. Remove it before we invoke the chunk source,
     // and add it back again afterwards.
-    MediaChunk removedChunk = mediaChunks.removeLast();
+    BaseMediaChunk removedChunk = mediaChunks.removeLast();
     Assertions.checkState(backedOffChunk == removedChunk);
     currentLoadableHolder.queueSize = readOnlyMediaChunks.size();
     chunkSource.getChunkOperation(readOnlyMediaChunks, pendingResetPositionUs, downstreamPositionUs,
@@ -630,10 +507,12 @@ private void resumeFromBackOff() {
       // Chunk was unchanged. Resume loading.
       loader.startLoading(backedOffChunk, this);
     } else {
+      // Chunk was changed. Notify that the existing load was canceled.
+      notifyLoadCanceled(backedOffChunk.bytesLoaded());
       // This call will remove and release at least one chunk from the end of mediaChunks. Since
       // the current loadable is the last media chunk, it is guaranteed to be removed.
       discardUpstreamMediaChunks(currentLoadableHolder.queueSize);
-      clearCurrentLoadable();
+      clearCurrentLoadableException();
       maybeStartLoading();
     }
   }
@@ -644,55 +523,23 @@ private void maybeStartLoading() {
       // Nothing to load.
       return;
     }
-    currentLoadable.init(loadControl.getAllocator());
+    currentLoadStartTimeMs = SystemClock.elapsedRealtime();
     if (isMediaChunk(currentLoadable)) {
-      MediaChunk mediaChunk = (MediaChunk) currentLoadable;
+      BaseMediaChunk mediaChunk = (BaseMediaChunk) currentLoadable;
+      mediaChunk.init(sampleQueue);
+      mediaChunks.add(mediaChunk);
       if (isPendingReset()) {
-        mediaChunk.seekTo(pendingResetPositionUs, false);
         pendingResetPositionUs = NO_RESET_PENDING;
       }
-      mediaChunks.add(mediaChunk);
-      notifyLoadStarted(mediaChunk.format.id, mediaChunk.trigger, false,
-          mediaChunk.startTimeUs, mediaChunk.endTimeUs, mediaChunk.getLength());
+      notifyLoadStarted(mediaChunk.dataSpec.length, mediaChunk.type, mediaChunk.trigger,
+          mediaChunk.format, mediaChunk.startTimeUs, mediaChunk.endTimeUs);
     } else {
-      notifyLoadStarted(currentLoadable.format.id, currentLoadable.trigger, true, -1, -1,
-          currentLoadable.getLength());
+      notifyLoadStarted(currentLoadable.dataSpec.length, currentLoadable.type,
+          currentLoadable.trigger, currentLoadable.format, -1, -1);
     }
     loader.startLoading(currentLoadable, this);
   }
 
-  /**
-   * Discards downstream media chunks until {@code untilChunk} if found. {@code untilChunk} is not
-   * itself discarded. Null can be passed to discard all media chunks.
-   *
-   * @param untilChunk The first media chunk to keep, or null to discard all media chunks.
-   */
-  private void discardDownstreamMediaChunks(MediaChunk untilChunk) {
-    if (mediaChunks.isEmpty() || untilChunk == mediaChunks.getFirst()) {
-      return;
-    }
-    long totalBytes = 0;
-    long startTimeUs = mediaChunks.getFirst().startTimeUs;
-    long endTimeUs = 0;
-    while (!mediaChunks.isEmpty() && untilChunk != mediaChunks.getFirst()) {
-      MediaChunk removed = mediaChunks.removeFirst();
-      totalBytes += removed.bytesLoaded();
-      endTimeUs = removed.endTimeUs;
-      removed.release();
-    }
-    notifyDownstreamDiscarded(startTimeUs, endTimeUs, totalBytes);
-  }
-
-  /**
-   * Discards the first downstream media chunk.
-   */
-  private void discardDownstreamMediaChunk() {
-    MediaChunk removed = mediaChunks.removeFirst();
-    long totalBytes = removed.bytesLoaded();
-    removed.release();
-    notifyDownstreamDiscarded(removed.startTimeUs, removed.endTimeUs, totalBytes);
-  }
-
   /**
    * Discard upstream media chunks until the queue length is equal to the length specified.
    *
@@ -703,21 +550,22 @@ private boolean discardUpstreamMediaChunks(int queueLength) {
     if (mediaChunks.size() <= queueLength) {
       return false;
     }
-    long totalBytes = 0;
     long startTimeUs = 0;
     long endTimeUs = mediaChunks.getLast().endTimeUs;
+
+    BaseMediaChunk removed = null;
     while (mediaChunks.size() > queueLength) {
-      MediaChunk removed = mediaChunks.removeLast();
-      totalBytes += removed.bytesLoaded();
+      removed = mediaChunks.removeLast();
       startTimeUs = removed.startTimeUs;
-      removed.release();
     }
-    notifyUpstreamDiscarded(startTimeUs, endTimeUs, totalBytes);
+    sampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex());
+
+    notifyUpstreamDiscarded(startTimeUs, endTimeUs);
     return true;
   }
 
   private boolean isMediaChunk(Chunk chunk) {
-    return chunk instanceof MediaChunk;
+    return chunk instanceof BaseMediaChunk;
   }
 
   private boolean isPendingReset() {
@@ -732,26 +580,28 @@ protected final int usToMs(long timeUs) {
     return (int) (timeUs / 1000);
   }
 
-  private void notifyLoadStarted(final String formatId, final int trigger,
-      final boolean isInitialization, final long mediaStartTimeUs, final long mediaEndTimeUs,
-      final long length) {
+  private void notifyLoadStarted(final long length, final int type, final int trigger,
+      final Format format, final long mediaStartTimeUs, final long mediaEndTimeUs) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
-          eventListener.onLoadStarted(eventSourceId, formatId, trigger, isInitialization,
-              usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs), length);
+          eventListener.onLoadStarted(eventSourceId, length, type, trigger, format,
+              usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs));
         }
       });
     }
   }
 
-  private void notifyLoadCompleted(final long bytesLoaded) {
+  private void notifyLoadCompleted(final long bytesLoaded, final int type, final int trigger,
+      final Format format, final long mediaStartTimeUs, final long mediaEndTimeUs,
+      final long elapsedRealtimeMs, final long loadDurationMs) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
-          eventListener.onLoadCompleted(eventSourceId, bytesLoaded);
+          eventListener.onLoadCompleted(eventSourceId, bytesLoaded, type, trigger, format,
+              usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs);
         }
       });
     }
@@ -768,65 +618,40 @@ public void run() {
     }
   }
 
-  private void notifyUpstreamError(final IOException e) {
+  private void notifyLoadError(final IOException e) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
-          eventListener.onUpstreamError(eventSourceId, e);
+          eventListener.onLoadError(eventSourceId, e);
         }
       });
     }
   }
 
-  private void notifyConsumptionError(final IOException e) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
-        @Override
-        public void run() {
-          eventListener.onConsumptionError(eventSourceId, e);
-        }
-      });
-    }
-  }
-
-  private void notifyUpstreamDiscarded(final long mediaStartTimeUs, final long mediaEndTimeUs,
-      final long totalBytes) {
+  private void notifyUpstreamDiscarded(final long mediaStartTimeUs, final long mediaEndTimeUs) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
           eventListener.onUpstreamDiscarded(eventSourceId, usToMs(mediaStartTimeUs),
-              usToMs(mediaEndTimeUs), totalBytes);
+              usToMs(mediaEndTimeUs));
         }
       });
     }
   }
 
-  private void notifyDownstreamFormatChanged(final String formatId, final int trigger,
+  private void notifyDownstreamFormatChanged(final Format format, final int trigger,
       final long positionUs) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
-          eventListener.onDownstreamFormatChanged(eventSourceId, formatId, trigger,
+          eventListener.onDownstreamFormatChanged(eventSourceId, format, trigger,
               usToMs(positionUs));
         }
       });
     }
   }
 
-  private void notifyDownstreamDiscarded(final long mediaStartTimeUs, final long mediaEndTimeUs,
-      final long bytesDiscarded) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
-        @Override
-        public void run() {
-          eventListener.onDownstreamDiscarded(eventSourceId, usToMs(mediaStartTimeUs),
-              usToMs(mediaEndTimeUs), bytesDiscarded);
-        }
-      });
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
index cc3a1f9d6c..88306bc8f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
@@ -102,6 +102,14 @@ void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
    */
   IOException getError();
 
+  /**
+   * Invoked when the {@link ChunkSampleSource} has finished loading a chunk obtained from this
+   * source.
+   *
+   * @param chunk The chunk whose load has been completed.
+   */
+  void onChunkLoadCompleted(Chunk chunk);
+
   /**
    * Invoked when the {@link ChunkSampleSource} encounters an error loading a chunk obtained from
    * this source.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
index a3eefa9b5c..d1145ff91b 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
@@ -16,137 +16,150 @@
 package com.google.android.exoplayer.chunk;
 
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.chunk.parser.Extractor;
+import com.google.android.exoplayer.chunk.ChunkExtractorWrapper.SingleTrackOutput;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
-import java.util.Map;
-import java.util.UUID;
+import android.util.Log;
+
+import java.io.IOException;
 
 /**
- * A {@link MediaChunk} extracted from a container.
+ * A {@link BaseMediaChunk} that uses an {@link Extractor} to parse sample data.
  */
-public final class ContainerMediaChunk extends MediaChunk {
+public class ContainerMediaChunk extends BaseMediaChunk implements SingleTrackOutput {
+
+  private static final String TAG = "ContainerMediaChunk";
 
-  private final Extractor extractor;
-  private final boolean maybeSelfContained;
+  private final ChunkExtractorWrapper extractorWrapper;
   private final long sampleOffsetUs;
 
-  private boolean prepared;
   private MediaFormat mediaFormat;
-  private Map<UUID, byte[]> psshInfo;
+  private DrmInitData drmInitData;
 
-  /**
-   * @deprecated Use the other constructor, passing null as {@code psshInfo}.
-   */
-  @Deprecated
-  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
-      int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex,
-      Extractor extractor, boolean maybeSelfContained, long sampleOffsetUs) {
-    this(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex,
-        extractor, null, maybeSelfContained, sampleOffsetUs);
-  }
+  private volatile int bytesLoaded;
+  private volatile boolean loadCanceled;
 
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
-   * @param format The format of the stream to which this chunk belongs.
    * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param nextChunkIndex The index of the next chunk, or -1 if this is the last chunk.
-   * @param extractor The extractor that will be used to extract the samples.
-   * @param psshInfo Pssh data. May be null if pssh data is present within the stream, meaning it
-   *     can be obtained directly from {@code extractor}, or if no pssh data is required.
-   * @param maybeSelfContained Set to true if this chunk might be self contained, meaning it might
-   *     contain a moov atom defining the media format of the chunk. This parameter can always be
-   *     safely set to true. Setting to false where the chunk is known to not be self contained may
-   *     improve startup latency.
-   * @param sampleOffsetUs An offset to subtract from the sample timestamps parsed by the extractor.
+   * @param chunkIndex The index of the chunk.
+   * @param isLastChunk True if this is the last chunk in the media. False otherwise.
+   * @param sampleOffsetUs An offset to add to the sample timestamps parsed by the extractor.
+   * @param extractorWrapper A wrapped extractor to use for parsing the data.
+   * @param mediaFormat The {@link MediaFormat} of the chunk, if known. May be null if the data is
+   *     known to define its own format.
+   * @param drmInitData The {@link DrmInitData} for the chunk. Null if the media is not drm
+   *     protected. May also be null if the data is known to define its own initialization data.
+   * @param isFormatFinal True if {@code mediaFormat} and {@code drmInitData} are known to be
+   *     correct and final. False if the data may define its own format or initialization data.
    */
-  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
-      int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex, Extractor extractor,
-      Map<UUID, byte[]> psshInfo, boolean maybeSelfContained, long sampleOffsetUs) {
-    super(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex);
-    this.extractor = extractor;
-    this.maybeSelfContained = maybeSelfContained;
+  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
+      long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk, long sampleOffsetUs,
+      ChunkExtractorWrapper extractorWrapper, MediaFormat mediaFormat, DrmInitData drmInitData,
+      boolean isFormatFinal) {
+    super(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs, chunkIndex, isLastChunk,
+        isFormatFinal);
+    this.extractorWrapper = extractorWrapper;
     this.sampleOffsetUs = sampleOffsetUs;
-    this.psshInfo = psshInfo;
+    this.mediaFormat = mediaFormat;
+    this.drmInitData = drmInitData;
   }
 
   @Override
-  public void seekToStart() {
-    extractor.seekTo(0, false);
-    resetReadPosition();
+  public long bytesLoaded() {
+    return bytesLoaded;
   }
 
   @Override
-  public boolean seekTo(long positionUs, boolean allowNoop) {
-    long seekTimeUs = positionUs + sampleOffsetUs;
-    boolean isDiscontinuous = extractor.seekTo(seekTimeUs, allowNoop);
-    if (isDiscontinuous) {
-      resetReadPosition();
-    }
-    return isDiscontinuous;
+  public MediaFormat getMediaFormat() {
+    return mediaFormat;
   }
 
   @Override
-  public boolean prepare() throws ParserException {
-    if (!prepared) {
-      if (maybeSelfContained) {
-        // Read up to the first sample. Once we're there, we know that the extractor must have
-        // parsed a moov atom if the chunk contains one.
-        NonBlockingInputStream inputStream = getNonBlockingInputStream();
-        Assertions.checkState(inputStream != null);
-        int result = extractor.read(inputStream, null);
-        prepared = (result & Extractor.RESULT_NEED_SAMPLE_HOLDER) != 0;
-      } else {
-        // We know there isn't a moov atom. The extractor must have parsed one from a separate
-        // initialization chunk.
-        prepared = true;
-      }
-      if (prepared) {
-        mediaFormat = extractor.getFormat();
-        Map<UUID, byte[]> extractorPsshInfo = extractor.getPsshInfo();
-        if (extractorPsshInfo != null) {
-          psshInfo = extractorPsshInfo;
-        }
-      }
-    }
-    return prepared;
+  public DrmInitData getDrmInitData() {
+    return drmInitData;
   }
 
+  // SingleTrackOutput implementation.
+
   @Override
-  public boolean sampleAvailable() throws ParserException {
-    NonBlockingInputStream inputStream = getNonBlockingInputStream();
-    int result = extractor.read(inputStream, null);
-    return (result & Extractor.RESULT_NEED_SAMPLE_HOLDER) != 0;
+  public void seekMap(SeekMap seekMap) {
+    Log.w(TAG, "Ignoring unexpected seekMap");
   }
 
   @Override
-  public boolean read(SampleHolder holder) throws ParserException {
-    NonBlockingInputStream inputStream = getNonBlockingInputStream();
-    Assertions.checkState(inputStream != null);
-    int result = extractor.read(inputStream, holder);
-    boolean sampleRead = (result & Extractor.RESULT_READ_SAMPLE) != 0;
-    if (sampleRead) {
-      holder.timeUs -= sampleOffsetUs;
-    }
-    return sampleRead;
+  public void drmInitData(DrmInitData drmInitData) {
+    this.drmInitData = drmInitData;
   }
 
   @Override
-  public MediaFormat getMediaFormat() {
-    return mediaFormat;
+  public void format(MediaFormat mediaFormat) {
+    this.mediaFormat = mediaFormat;
+  }
+
+  @Override
+  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
+    return getOutput().sampleData(input, length);
+  }
+
+  @Override
+  public void sampleData(ParsableByteArray data, int length) {
+    getOutput().sampleData(data, length);
   }
 
   @Override
-  public Map<UUID, byte[]> getPsshInfo() {
-    return psshInfo;
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    getOutput().sampleMetadata(timeUs + sampleOffsetUs, flags, size, offset, encryptionKey);
+  }
+
+  // Loadable implementation.
+
+  @Override
+  public void cancelLoad() {
+    loadCanceled = true;
+  }
+
+  @Override
+  public boolean isLoadCanceled() {
+    return loadCanceled;
+  }
+
+  @SuppressWarnings("NonAtomicVolatileUpdate")
+  @Override
+  public void load() throws IOException, InterruptedException {
+    DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+    try {
+      // Create and open the input.
+      ExtractorInput input = new DefaultExtractorInput(dataSource,
+          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+      if (bytesLoaded == 0) {
+        // Set the target to ourselves.
+        extractorWrapper.init(this);
+      }
+      // Load and parse the initialization data.
+      try {
+        int result = Extractor.RESULT_CONTINUE;
+        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+          result = extractorWrapper.read(input);
+        }
+      } finally {
+        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+      }
+    } finally {
+      dataSource.close();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/DataChunk.java
similarity index 73%
rename from library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java
rename to library/src/main/java/com/google/android/exoplayer/chunk/DataChunk.java
index 04d1bc2728..ed0331f120 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/DataChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/DataChunk.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls;
+package com.google.android.exoplayer.chunk;
 
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
@@ -22,17 +22,16 @@
 import java.util.Arrays;
 
 /**
- * An abstract base class for {@link HlsChunk} implementations where the data should be loaded into
- * a {@code byte[]} before being consumed.
+ * A base class for {@link Chunk} implementations where the data should be loaded into a
+ * {@code byte[]} before being consumed.
  */
-public abstract class DataChunk extends HlsChunk {
+public abstract class DataChunk extends Chunk {
 
   private static final int READ_GRANULARITY = 16 * 1024;
 
   private byte[] data;
   private int limit;
 
-  private volatile boolean loadFinished;
   private volatile boolean loadCanceled;
 
   /**
@@ -41,36 +40,31 @@
    *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
    *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
    *     {@link Integer#MAX_VALUE}.
+   * @param type See {@link #type}.
+   * @param trigger See {@link #trigger}.
+   * @param format See {@link #format}.
    * @param data An optional recycled array that can be used as a holder for the data.
    */
-  public DataChunk(DataSource dataSource, DataSpec dataSpec, byte[] data) {
-    super(dataSource, dataSpec);
+  public DataChunk(DataSource dataSource, DataSpec dataSpec, int type, int trigger, Format format,
+      byte[] data) {
+    super(dataSource, dataSpec, type, trigger, format);
     this.data = data;
   }
 
-  @Override
-  public void consume() throws IOException {
-    consume(data, limit);
-  }
-
   /**
-   * Invoked by {@link #consume()}. Implementations should override this method to consume the
-   * loaded data.
+   * Returns the array in which the data is held.
+   * <p>
+   * This method should be used for recycling the holder only, and not for reading the data.
    *
-   * @param data An array containing the data.
-   * @param limit The limit of the data.
-   * @throws IOException If an error occurs consuming the loaded data.
+   * @return The array in which the data is held.
    */
-  protected abstract void consume(byte[] data, int limit) throws IOException;
+  public byte[] getDataHolder() {
+    return data;
+  }
 
-  /**
-   * Whether the whole of the chunk has been loaded.
-   *
-   * @return True if the whole of the chunk has been loaded. False otherwise.
-   */
   @Override
-  public boolean isLoadFinished() {
-    return loadFinished;
+  public long bytesLoaded() {
+    return limit;
   }
 
   // Loadable implementation
@@ -98,12 +92,24 @@ public final void load() throws IOException, InterruptedException {
           limit += bytesRead;
         }
       }
-      loadFinished = !loadCanceled;
+      if (!loadCanceled) {
+        consume(data, limit);
+      }
     } finally {
       dataSource.close();
     }
   }
 
+  /**
+   * Invoked by {@link #load()}. Implementations should override this method to consume the loaded
+   * data.
+   *
+   * @param data An array containing the data.
+   * @param limit The limit of the data.
+   * @throws IOException If an error occurs consuming the loaded data.
+   */
+  protected abstract void consume(byte[] data, int limit) throws IOException;
+
   private void maybeExpandData() {
     if (data == null) {
       data = new byte[READ_GRANULARITY];
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
index 2810dc4ff5..0c2f404426 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
@@ -47,34 +47,39 @@ public int compare(Format a, Format b) {
   public final String mimeType;
 
   /**
-   * The codecs used to decode the format, or {@code null} if they are not specified.
+   * The average bandwidth in bits per second.
    */
-  public final String codecs;
+  public final int bitrate;
 
   /**
-   * The width of the video in pixels, or -1 for non-video formats.
+   * The width of the video in pixels, or -1 if unknown or not applicable.
    */
   public final int width;
 
   /**
-   * The height of the video in pixels, or -1 for non-video formats.
+   * The height of the video in pixels, or -1 if unknown or not applicable.
    */
   public final int height;
 
   /**
-   * The number of audio channels, or -1 for non-audio formats.
+   * The video frame rate in frames per second, or -1 if unknown or not applicable.
+   */
+  public final float frameRate;
+
+  /**
+   * The number of audio channels, or -1 if unknown or not applicable.
    */
   public final int numChannels;
 
   /**
-   * The audio sampling rate in Hz, or -1 for non-audio formats.
+   * The audio sampling rate in Hz, or -1 if unknown or not applicable.
    */
   public final int audioSamplingRate;
 
   /**
-   * The average bandwidth in bits per second.
+   * The codecs used to decode the format. Can be {@code null} if unknown.
    */
-  public final int bitrate;
+  public final String codecs;
 
   /**
    * The language of the format. Can be null if unknown.
@@ -84,67 +89,66 @@ public int compare(Format a, Format b) {
    */
   public final String language;
 
-  /**
-   * The average bandwidth in bytes per second.
-   *
-   * @deprecated Use {@link #bitrate}. However note that the units of measurement are different.
-   */
-  @Deprecated
-  public final int bandwidth;
-
   /**
    * @param id The format identifier.
    * @param mimeType The format mime type.
-   * @param width The width of the video in pixels, or -1 for non-video formats.
-   * @param height The height of the video in pixels, or -1 for non-video formats.
-   * @param numChannels The number of audio channels, or -1 for non-audio formats.
-   * @param audioSamplingRate The audio sampling rate in Hz, or -1 for non-audio formats.
+   * @param width The width of the video in pixels, or -1 if unknown or not applicable.
+   * @param height The height of the video in pixels, or -1 if unknown or not applicable.
+   * @param frameRate The frame rate of the video in frames per second, or -1 if unknown or not
+   *     applicable.
+   * @param numChannels The number of audio channels, or -1 if unknown or not applicable.
+   * @param audioSamplingRate The audio sampling rate in Hz, or -1 if unknown or not applicable.
    * @param bitrate The average bandwidth of the format in bits per second.
    */
-  public Format(String id, String mimeType, int width, int height, int numChannels,
+  public Format(String id, String mimeType, int width, int height, float frameRate, int numChannels,
       int audioSamplingRate, int bitrate) {
-    this(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate, null, null);
+    this(id, mimeType, width, height, frameRate, numChannels, audioSamplingRate, bitrate, null);
   }
 
   /**
    * @param id The format identifier.
    * @param mimeType The format mime type.
-   * @param width The width of the video in pixels, or -1 for non-video formats.
-   * @param height The height of the video in pixels, or -1 for non-video formats.
-   * @param numChannels The number of audio channels, or -1 for non-audio formats.
-   * @param audioSamplingRate The audio sampling rate in Hz, or -1 for non-audio formats.
+   * @param width The width of the video in pixels, or -1 if unknown or not applicable.
+   * @param height The height of the video in pixels, or -1 if unknown or not applicable.
+   * @param frameRate The frame rate of the video in frames per second, or -1 if unknown or not
+   *     applicable.
+   * @param numChannels The number of audio channels, or -1 if unknown or not applicable.
+   * @param audioSamplingRate The audio sampling rate in Hz, or -1 if unknown or not applicable.
    * @param bitrate The average bandwidth of the format in bits per second.
    * @param language The language of the format.
    */
-  public Format(String id, String mimeType, int width, int height, int numChannels,
+  public Format(String id, String mimeType, int width, int height, float frameRate, int numChannels,
       int audioSamplingRate, int bitrate, String language) {
-    this(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate, language, null);
+    this(id, mimeType, width, height, frameRate, numChannels, audioSamplingRate, bitrate, language,
+        null);
   }
 
 
   /**
    * @param id The format identifier.
    * @param mimeType The format mime type.
-   * @param width The width of the video in pixels, or -1 for non-video formats.
-   * @param height The height of the video in pixels, or -1 for non-video formats.
-   * @param numChannels The number of audio channels, or -1 for non-audio formats.
-   * @param audioSamplingRate The audio sampling rate in Hz, or -1 for non-audio formats.
+   * @param width The width of the video in pixels, or -1 if unknown or not applicable.
+   * @param height The height of the video in pixels, or -1 if unknown or not applicable.
+   * @param frameRate The frame rate of the video in frames per second, or -1 if unknown or not
+   *     applicable.
+   * @param numChannels The number of audio channels, or -1 if unknown or not applicable.
+   * @param audioSamplingRate The audio sampling rate in Hz, or -1 if unknown or not applicable.
    * @param bitrate The average bandwidth of the format in bits per second.
    * @param language The language of the format.
    * @param codecs The codecs used to decode the format.
    */
-  public Format(String id, String mimeType, int width, int height, int numChannels,
+  public Format(String id, String mimeType, int width, int height, float frameRate, int numChannels,
       int audioSamplingRate, int bitrate, String language, String codecs) {
     this.id = Assertions.checkNotNull(id);
     this.mimeType = mimeType;
     this.width = width;
     this.height = height;
+    this.frameRate = frameRate;
     this.numChannels = numChannels;
     this.audioSamplingRate = audioSamplingRate;
     this.bitrate = bitrate;
     this.language = language;
     this.codecs = codecs;
-    this.bandwidth = bitrate / 8;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java b/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
index d64ca8a262..7c88ff68a0 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
@@ -25,23 +25,6 @@
  */
 public interface FormatEvaluator {
 
-  /**
-   * The trigger for the initial format selection.
-   */
-  static final int TRIGGER_INITIAL = 0;
-  /**
-   * The trigger for a format selection that was triggered by the user.
-   */
-  static final int TRIGGER_MANUAL = 1;
-  /**
-   * The trigger for an adaptive format selection.
-   */
-  static final int TRIGGER_ADAPTIVE = 2;
-  /**
-   * Implementations may define custom trigger codes greater than or equal to this value.
-   */
-  static final int TRIGGER_CUSTOM_BASE = 10000;
-
   /**
    * Enables the evaluator.
    */
@@ -93,7 +76,7 @@ void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs, Format[
     public Format format;
 
     public Evaluation() {
-      trigger = TRIGGER_INITIAL;
+      trigger = Chunk.TRIGGER_INITIAL;
     }
 
   }
@@ -101,7 +84,7 @@ public Evaluation() {
   /**
    * Always selects the first format.
    */
-  public static class FixedEvaluator implements FormatEvaluator {
+  public static final class FixedEvaluator implements FormatEvaluator {
 
     @Override
     public void enable() {
@@ -124,7 +107,7 @@ public void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs,
   /**
    * Selects randomly between the available formats.
    */
-  public static class RandomEvaluator implements FormatEvaluator {
+  public static final class RandomEvaluator implements FormatEvaluator {
 
     private final Random random;
 
@@ -146,8 +129,8 @@ public void disable() {
     public void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs,
         Format[] formats, Evaluation evaluation) {
       Format newFormat = formats[random.nextInt(formats.length)];
-      if (evaluation.format != null && !evaluation.format.id.equals(newFormat.id)) {
-        evaluation.trigger = TRIGGER_ADAPTIVE;
+      if (evaluation.format != null && !evaluation.format.equals(newFormat)) {
+        evaluation.trigger = Chunk.TRIGGER_ADAPTIVE;
       }
       evaluation.format = newFormat;
     }
@@ -162,7 +145,7 @@ public void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs,
    * reference implementation only. It is recommended that application developers implement their
    * own adaptive evaluator to more precisely suit their use case.
    */
-  public static class AdaptiveEvaluator implements FormatEvaluator {
+  public static final class AdaptiveEvaluator implements FormatEvaluator {
 
     public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
 
@@ -268,7 +251,7 @@ public void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs,
         ideal = current;
       }
       if (current != null && ideal != current) {
-        evaluation.trigger = FormatEvaluator.TRIGGER_ADAPTIVE;
+        evaluation.trigger = Chunk.TRIGGER_ADAPTIVE;
       }
       evaluation.format = ideal;
     }
@@ -276,8 +259,9 @@ public void evaluate(List<? extends MediaChunk> queue, long playbackPositionUs,
     /**
      * Compute the ideal format ignoring buffer health.
      */
-    protected Format determineIdealFormat(Format[] formats, long bitrateEstimate) {
-      long effectiveBitrate = computeEffectiveBitrateEstimate(bitrateEstimate);
+    private Format determineIdealFormat(Format[] formats, long bitrateEstimate) {
+      long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE
+          ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
       for (int i = 0; i < formats.length; i++) {
         Format format = formats[i];
         if (format.bitrate <= effectiveBitrate) {
@@ -288,14 +272,6 @@ protected Format determineIdealFormat(Format[] formats, long bitrateEstimate) {
       return formats[formats.length - 1];
     }
 
-    /**
-     * Apply overhead factor, or default value in absence of estimate.
-     */
-    protected long computeEffectiveBitrateEstimate(long bitrateEstimate) {
-      return bitrateEstimate == BandwidthMeter.NO_ESTIMATE
-          ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
-    }
-
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/FormatWrapper.java b/library/src/main/java/com/google/android/exoplayer/chunk/FormatWrapper.java
new file mode 100644
index 0000000000..b36a436b92
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/FormatWrapper.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+/**
+ * Represents an object that wraps a {@link Format}.
+ */
+public interface FormatWrapper {
+
+  /**
+   * Returns the wrapped format.
+   */
+  Format getFormat();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
new file mode 100644
index 0000000000..a83092ad3f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.chunk.ChunkExtractorWrapper.SingleTrackOutput;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.io.IOException;
+
+/**
+ * A {@link Chunk} that uses an {@link Extractor} to parse initialization data for single track.
+ */
+public final class InitializationChunk extends Chunk implements SingleTrackOutput {
+
+  private final ChunkExtractorWrapper extractorWrapper;
+
+  // Initialization results. Set by the loader thread and read by any thread that knows loading
+  // has completed. These variables do not need to be volatile, since a memory barrier must occur
+  // for the reading thread to know that loading has completed.
+  private MediaFormat mediaFormat;
+  private DrmInitData drmInitData;
+  private SeekMap seekMap;
+
+  private volatile int bytesLoaded;
+  private volatile boolean loadCanceled;
+
+  /**
+   * Constructor for a chunk of media samples.
+   *
+   * @param dataSource A {@link DataSource} for loading the initialization data.
+   * @param dataSpec Defines the initialization data to be loaded.
+   * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
+   * @param extractorWrapper A wrapped extractor to use for parsing the initialization data.
+   */
+  public InitializationChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
+      ChunkExtractorWrapper extractorWrapper) {
+    super(dataSource, dataSpec, Chunk.TYPE_MEDIA_INITIALIZATION, trigger, format);
+    this.extractorWrapper = extractorWrapper;
+  }
+
+  @Override
+  public long bytesLoaded() {
+    return bytesLoaded;
+  }
+
+  /**
+   * True if a {@link MediaFormat} was parsed from the chunk. False otherwise.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public boolean hasFormat() {
+    return mediaFormat != null;
+  }
+
+  /**
+   * Returns a {@link MediaFormat} parsed from the chunk, or null.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public MediaFormat getFormat() {
+    return mediaFormat;
+  }
+
+  /**
+   * True if a {@link DrmInitData} was parsed from the chunk. False otherwise.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public boolean hasDrmInitData() {
+    return drmInitData != null;
+  }
+
+  /**
+   * Returns a {@link DrmInitData} parsed from the chunk, or null.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public DrmInitData getDrmInitData() {
+    return drmInitData;
+  }
+
+  /**
+   * True if a {@link SeekMap} was parsed from the chunk. False otherwise.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public boolean hasSeekMap() {
+    return seekMap != null;
+  }
+
+  /**
+   * Returns a {@link SeekMap} parsed from the chunk, or null.
+   * <p>
+   * Should be called after loading has completed.
+   */
+  public SeekMap getSeekMap() {
+    return seekMap;
+  }
+
+  // SingleTrackOutput implementation.
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    this.seekMap = seekMap;
+  }
+
+  @Override
+  public void drmInitData(DrmInitData drmInitData) {
+    this.drmInitData = drmInitData;
+  }
+
+  @Override
+  public void format(MediaFormat mediaFormat) {
+    this.mediaFormat = mediaFormat;
+  }
+
+  @Override
+  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
+    throw new IllegalStateException("Unexpected sample data in initialization chunk");
+  }
+
+  @Override
+  public void sampleData(ParsableByteArray data, int length) {
+    throw new IllegalStateException("Unexpected sample data in initialization chunk");
+  }
+
+  @Override
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    throw new IllegalStateException("Unexpected sample data in initialization chunk");
+  }
+
+  // Loadable implementation.
+
+  @Override
+  public void cancelLoad() {
+    loadCanceled = true;
+  }
+
+  @Override
+  public boolean isLoadCanceled() {
+    return loadCanceled;
+  }
+
+  @SuppressWarnings("NonAtomicVolatileUpdate")
+  @Override
+  public void load() throws IOException, InterruptedException {
+    DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+    try {
+      // Create and open the input.
+      ExtractorInput input = new DefaultExtractorInput(dataSource,
+          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+      if (bytesLoaded == 0) {
+        // Set the target to ourselves.
+        extractorWrapper.init(this);
+      }
+      // Load and parse the initialization data.
+      try {
+        int result = Extractor.RESULT_CONTINUE;
+        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+          result = extractorWrapper.read(input);
+        }
+      } finally {
+        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+      }
+    } finally {
+      dataSource.close();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
index e03a529d8c..f7d3812a7a 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
@@ -15,14 +15,9 @@
  */
 package com.google.android.exoplayer.chunk;
 
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
-
-import java.util.Map;
-import java.util.UUID;
+import com.google.android.exoplayer.util.Assertions;
 
 /**
  * An abstract base class for {@link Chunk}s that contain media samples.
@@ -38,103 +33,32 @@
    */
   public final long endTimeUs;
   /**
-   * The index of the next media chunk, or -1 if this is the last media chunk in the stream.
+   * The chunk index.
+   */
+  public final int chunkIndex;
+  /**
+   * True if this is the last chunk in the media. False otherwise.
    */
-  public final int nextChunkIndex;
+  public final boolean isLastChunk;
 
   /**
-   * Constructor for a chunk of media samples.
-   *
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
-   * @param format The format of the stream to which this chunk belongs.
    * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param nextChunkIndex The index of the next chunk, or -1 if this is the last chunk.
+   * @param chunkIndex The index of the chunk.
+   * @param isLastChunk True if this is the last chunk in the media. False otherwise.
    */
-  public MediaChunk(DataSource dataSource, DataSpec dataSpec, Format format, int trigger,
-      long startTimeUs, long endTimeUs, int nextChunkIndex) {
-    super(dataSource, dataSpec, format, trigger);
+  public MediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
+      long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk) {
+    super(dataSource, dataSpec, Chunk.TYPE_MEDIA, trigger, format);
+    Assertions.checkNotNull(format);
     this.startTimeUs = startTimeUs;
     this.endTimeUs = endTimeUs;
-    this.nextChunkIndex = nextChunkIndex;
+    this.chunkIndex = chunkIndex;
+    this.isLastChunk = isLastChunk;
   }
 
-  /**
-   * Whether this is the last chunk in the stream.
-   *
-   * @return True if this is the last chunk in the stream. False otherwise.
-   */
-  public final boolean isLastChunk() {
-    return nextChunkIndex == -1;
-  }
-
-  /**
-   * Seeks to the beginning of the chunk.
-   */
-  public abstract void seekToStart();
-
-  /**
-   * Seeks to the specified position within the chunk.
-   *
-   * @param positionUs The desired seek time in microseconds.
-   * @param allowNoop True if the seek is allowed to do nothing if the result is more accurate than
-   *     seeking to a key frame. Always pass false if it is required that the next sample be a key
-   *     frame.
-   * @return True if the seek results in a discontinuity in the sequence of samples returned by
-   *     {@link #read(SampleHolder)}. False otherwise.
-   */
-  public abstract boolean seekTo(long positionUs, boolean allowNoop);
-
-  /**
-   * Prepares the chunk for reading. Does nothing if the chunk is already prepared.
-   * <p>
-   * Preparation may require consuming some of the chunk. If the data is not yet available then
-   * this method will return {@code false} rather than block. The method can be called repeatedly
-   * until the return value indicates success.
-   *
-   * @return True if the chunk was prepared. False otherwise.
-   * @throws ParserException If an error occurs parsing the media data.
-   */
-  public abstract boolean prepare() throws ParserException;
-
-  /**
-   * Returns whether the next sample is available.
-   *
-   * @return True if the next sample is available for reading. False otherwise.
-   * @throws ParserException
-   */
-  public abstract boolean sampleAvailable() throws ParserException;
-
-  /**
-   * Reads the next media sample from the chunk.
-   * <p>
-   * Should only be called after the chunk has been successfully prepared.
-   *
-   * @param holder A holder to store the read sample.
-   * @return True if a sample was read. False if more data is still required.
-   * @throws ParserException If an error occurs parsing the media data.
-   * @throws IllegalStateException If called before {@link #init}, or after {@link #release}
-   */
-  public abstract boolean read(SampleHolder holder) throws ParserException;
-
-  /**
-   * Returns the media format of the samples contained within this chunk.
-   * <p>
-   * Should only be called after the chunk has been successfully prepared.
-   *
-   * @return The sample media format.
-   */
-  public abstract MediaFormat getMediaFormat();
-
-  /**
-   * Returns the pssh information associated with the chunk.
-   * <p>
-   * Should only be called after the chunk has been successfully prepared.
-   *
-   * @return The pssh information.
-   */
-  public abstract Map<UUID, byte[]> getPsshInfo();
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
index ce9965f313..84f91c5465 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
@@ -106,6 +106,11 @@ public void handleMessage(int what, Object msg) throws ExoPlaybackException {
     }
   }
 
+  @Override
+  public void onChunkLoadCompleted(Chunk chunk) {
+    selectedSource.onChunkLoadCompleted(chunk);
+  }
+
   @Override
   public void onChunkLoadError(Chunk chunk, Exception e) {
     selectedSource.onChunkLoadError(chunk, e);
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
index 71a50241f4..5c6ca99989 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
@@ -97,14 +97,19 @@ public IOException getError() {
     return null;
   }
 
+  @Override
+  public void onChunkLoadCompleted(Chunk chunk) {
+    // Do nothing.
+  }
+
   @Override
   public void onChunkLoadError(Chunk chunk, Exception e) {
     // Do nothing.
   }
 
   private SingleSampleMediaChunk initChunk() {
-    return new SingleSampleMediaChunk(dataSource, dataSpec, format, 0, 0, durationUs, -1,
-        mediaFormat);
+    return new SingleSampleMediaChunk(dataSource, dataSpec, Chunk.TRIGGER_UNSPECIFIED, format, 0,
+        durationUs, 0, true, mediaFormat, null, null);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
index f097d9ee32..9e7a2a84df 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
@@ -15,125 +15,113 @@
  */
 package com.google.android.exoplayer.chunk;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
-import java.util.Map;
-import java.util.UUID;
+import java.io.IOException;
 
 /**
- * A {@link MediaChunk} containing a single sample.
+ * A {@link BaseMediaChunk} for chunks consisting of a single raw sample.
  */
-public class SingleSampleMediaChunk extends MediaChunk {
-
-  /**
-   * The sample header data. May be null.
-   */
-  public final byte[] headerData;
+public final class SingleSampleMediaChunk extends BaseMediaChunk {
 
   private final MediaFormat sampleFormat;
+  private final DrmInitData sampleDrmInitData;
+  private final byte[] headerData;
 
-  /**
-   * @param dataSource A {@link DataSource} for loading the data.
-   * @param dataSpec Defines the data to be loaded.
-   * @param format The format of the stream to which this chunk belongs.
-   * @param trigger The reason for this chunk being selected.
-   * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
-   * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param nextChunkIndex The index of the next chunk, or -1 if this is the last chunk.
-   * @param sampleFormat The format of the media contained by the chunk.
-   */
-  public SingleSampleMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
-      int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex, MediaFormat sampleFormat) {
-    this(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex,
-        sampleFormat, null);
-  }
+  private boolean writtenHeader;
+
+  private volatile int bytesLoaded;
+  private volatile boolean loadCanceled;
 
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
-   * @param format The format of the stream to which this chunk belongs.
    * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
-   * @param nextChunkIndex The index of the next chunk, or -1 if this is the last chunk.
-   * @param sampleFormat The format of the media contained by the chunk.
+   * @param chunkIndex The index of the chunk.
+   * @param isLastChunk True if this is the last chunk in the media. False otherwise.
+   * @param sampleFormat The format of the sample.
+   * @param sampleDrmInitData The {@link DrmInitData} for the sample. Null if the sample is not drm
+   *     protected.
    * @param headerData Custom header data for the sample. May be null. If set, the header data is
-   *     prepended to the sample data returned when {@link #read(SampleHolder)} is called. It is not
-   *     reflected in the values returned by {@link #bytesLoaded()} and {@link #getLength()}.
+   *     prepended to the sample data. It is not reflected in the values returned by
+   *     {@link #bytesLoaded()}.
    */
-  public SingleSampleMediaChunk(DataSource dataSource, DataSpec dataSpec, Format format,
-      int trigger, long startTimeUs, long endTimeUs, int nextChunkIndex, MediaFormat sampleFormat,
-      byte[] headerData) {
-    super(dataSource, dataSpec, format, trigger, startTimeUs, endTimeUs, nextChunkIndex);
+  public SingleSampleMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger,
+      Format format, long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk,
+      MediaFormat sampleFormat, DrmInitData sampleDrmInitData, byte[] headerData) {
+    super(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs, chunkIndex, isLastChunk,
+        true);
     this.sampleFormat = sampleFormat;
+    this.sampleDrmInitData = sampleDrmInitData;
     this.headerData = headerData;
   }
 
   @Override
-  public boolean prepare() {
-    return true;
+  public long bytesLoaded() {
+    return bytesLoaded;
   }
 
   @Override
-  public boolean sampleAvailable() {
-    return isLoadFinished() && !isReadFinished();
+  public MediaFormat getMediaFormat() {
+    return sampleFormat;
   }
 
   @Override
-  public boolean read(SampleHolder holder) {
-    NonBlockingInputStream inputStream = getNonBlockingInputStream();
-    Assertions.checkState(inputStream != null);
-    if (!sampleAvailable()) {
-      return false;
-    }
-    int bytesLoaded = (int) bytesLoaded();
-    int sampleSize = bytesLoaded;
-    if (headerData != null) {
-      sampleSize += headerData.length;
-    }
-    if (holder.data == null || holder.data.capacity() < sampleSize) {
-      holder.replaceBuffer(sampleSize);
-    }
-    int bytesRead;
-    if (holder.data != null) {
-      if (headerData != null) {
-        holder.data.put(headerData);
-      }
-      bytesRead = inputStream.read(holder.data, bytesLoaded);
-      holder.size = sampleSize;
-    } else {
-      bytesRead = inputStream.skip(bytesLoaded);
-      holder.size = 0;
-    }
-    Assertions.checkState(bytesRead == bytesLoaded);
-    holder.timeUs = startTimeUs;
-    return true;
+  public DrmInitData getDrmInitData() {
+    return sampleDrmInitData;
   }
 
-  @Override
-  public void seekToStart() {
-    resetReadPosition();
-  }
+  // Loadable implementation.
 
   @Override
-  public boolean seekTo(long positionUs, boolean allowNoop) {
-    resetReadPosition();
-    return true;
+  public void cancelLoad() {
+    loadCanceled = true;
   }
 
   @Override
-  public MediaFormat getMediaFormat() {
-    return sampleFormat;
+  public boolean isLoadCanceled() {
+    return loadCanceled;
   }
 
+  @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
-  public Map<UUID, byte[]> getPsshInfo() {
-    return null;
+  public void load() throws IOException, InterruptedException {
+    if (!writtenHeader) {
+      if (headerData != null) {
+        getOutput().sampleData(new ParsableByteArray(headerData), headerData.length);
+      }
+      writtenHeader = true;
+    }
+
+    DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+    try {
+      // Create and open the input.
+      dataSource.open(loadDataSpec);
+      // Load the sample data.
+      int result = 0;
+      while (result != C.RESULT_END_OF_INPUT) {
+        result = getOutput().sampleData(dataSource, Integer.MAX_VALUE);
+        if (result != C.RESULT_END_OF_INPUT) {
+          bytesLoaded += result;
+        }
+      }
+      int sampleSize = bytesLoaded;
+      if (headerData != null) {
+        sampleSize += headerData.length;
+      }
+      getOutput().sampleMetadata(startTimeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+    } finally {
+      dataSource.close();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
new file mode 100644
index 0000000000..de156ea0db
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.chunk;
+
+import com.google.android.exoplayer.MediaCodecUtil;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Point;
+import android.view.Display;
+import android.view.WindowManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Selects from possible video formats.
+ */
+public final class VideoFormatSelectorUtil {
+
+  /**
+   * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
+   * corresponding viewport dimension, then the video is considered as filling the viewport (in that
+   * dimension).
+   */
+  private static final float FRACTION_TO_CONSIDER_FULLSCREEN = 0.98f;
+
+  /**
+   * Chooses a suitable subset from a number of video formats, to be rendered on the device's
+   * default display.
+   *
+   * @param context A context.
+   * @param formatWrappers Wrapped formats from which to select.
+   * @param allowedContainerMimeTypes An array of allowed container mime types. Null allows all
+   *     mime types.
+   * @param filterHdFormats True to filter HD formats. False otherwise.
+   * @return An array holding the indices of the selected formats.
+   * @throws DecoderQueryException
+   */
+  public static int[] selectVideoFormatsForDefaultDisplay(Context context,
+      List<? extends FormatWrapper> formatWrappers, String[] allowedContainerMimeTypes,
+      boolean filterHdFormats) throws DecoderQueryException {
+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Display display = windowManager.getDefaultDisplay();
+    Point displaySize = getDisplaySize(display);
+    return selectVideoFormats(formatWrappers, allowedContainerMimeTypes, filterHdFormats, true,
+        displaySize.x, displaySize.y);
+  }
+
+  /**
+   * Chooses a suitable subset from a number of video formats.
+   * <p>
+   * A format is filtered (i.e. not selected) if:
+   * <ul>
+   * <li>{@code allowedContainerMimeTypes} is non-null and the format does not have one of the
+   *     permitted mime types.
+   * <li>{@code filterHdFormats} is true and the format is HD.
+   * <li>It's determined that the video decoder isn't powerful enough to decode the format.
+   * <li>There exists another format of lower resolution whose resolution exceeds the maximum size
+   *     in pixels that the video can be rendered within the viewport.
+   * </ul>
+   *
+   * @param formatWrappers Wrapped formats from which to select.
+   * @param allowedContainerMimeTypes An array of allowed container mime types. Null allows all
+   *     mime types.
+   * @param filterHdFormats True to filter HD formats. False otherwise.
+   * @param orientationMayChange True if the video's orientation may change with respect to the
+   *     viewport during playback.
+   * @param viewportWidth The width in pixels of the viewport within which the video will be
+   *     displayed. If the viewport size may change, this should be set to the maximum possible
+   *     width.
+   * @param viewportHeight The height in pixels of the viewport within which the video will be
+   *     displayed. If the viewport size may change, this should be set to the maximum possible
+   *     height.
+   * @return An array holding the indices of the selected formats.
+   * @throws DecoderQueryException
+   */
+  public static int[] selectVideoFormats(List<? extends FormatWrapper> formatWrappers,
+      String[] allowedContainerMimeTypes, boolean filterHdFormats, boolean orientationMayChange,
+      int viewportWidth, int viewportHeight) throws DecoderQueryException {
+    int maxVideoPixelsToRetain = Integer.MAX_VALUE;
+    ArrayList<Integer> selectedIndexList = new ArrayList<Integer>();
+    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
+
+    // First pass to filter out formats that individually fail to meet the selection criteria.
+    int formatWrapperCount = formatWrappers.size();
+    for (int i = 0; i < formatWrapperCount; i++) {
+      Format format = formatWrappers.get(i).getFormat();
+      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats,
+          maxDecodableFrameSize)) {
+        // Select the format for now. It may still be filtered in the second pass below.
+        selectedIndexList.add(i);
+        // Keep track of the number of pixels of the selected format whose resolution is the
+        // smallest to exceed the maximum size at which it can be displayed within the viewport.
+        // We'll discard formats of higher resolution in a second pass.
+        if (format.width != -1 && format.height != -1) {
+          Point maxVideoSizeInViewport = getMaxVideoSizeInViewport(orientationMayChange,
+              viewportWidth, viewportHeight, format.width, format.height);
+          int videoPixels = format.width * format.height;
+          if (format.width >= (int) (maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN)
+              && format.height >= (int) (maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN)
+              && videoPixels < maxVideoPixelsToRetain) {
+            maxVideoPixelsToRetain = videoPixels;
+          }
+        }
+      }
+    }
+
+    // Second pass to filter out formats that exceed maxVideoPixelsToRetain. These formats are have
+    // unnecessarily high resolution given the size at which the video will be displayed within the
+    // viewport.
+    for (int i = selectedIndexList.size() - 1; i >= 0; i--) {
+      Format format = formatWrappers.get(i).getFormat();
+      if (format.width != -1 && format.height != -1
+          && format.width * format.height > maxVideoPixelsToRetain) {
+        selectedIndexList.remove(i);
+      }
+    }
+
+    return Util.toArray(selectedIndexList);
+  }
+
+  /**
+   * Determines whether an individual format is playable, given an array of allowed container types,
+   * whether HD formats should be filtered and a maximum decodable frame size in pixels.
+   */
+  private static boolean isFormatPlayable(Format format, String[] allowedContainerMimeTypes,
+      boolean filterHdFormats, int maxDecodableFrameSize) {
+    if (allowedContainerMimeTypes != null
+        && !Util.contains(allowedContainerMimeTypes, format.mimeType)) {
+      // Filtering format based on its container mime type.
+      return false;
+    }
+    if (filterHdFormats && (format.width >= 1280 || format.height >= 720)) {
+      // Filtering format because it's HD.
+      return false;
+    }
+    if (format.width != -1 && format.height != -1) {
+      // TODO: Use MediaCodecUtil.isSizeAndRateSupportedV21 on API levels >= 21 if we know the
+      // mimeType of the media samples within the container. Remove the assumption that we're
+      // dealing with H.264.
+      if (format.width * format.height > maxDecodableFrameSize) {
+        // Filtering stream that device cannot play
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Given viewport dimensions and video dimensions, computes the maximum size of the video as it
+   * will be rendered to fit inside of the viewport.
+   */
+  private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int viewportWidth,
+      int viewportHeight, int videoWidth, int videoHeight) {
+    if (orientationMayChange && (videoWidth > videoHeight) != (viewportWidth > viewportHeight)) {
+      // Rotation is allowed, and the video will be larger in the rotated viewport.
+      int tempViewportWidth = viewportWidth;
+      viewportWidth = viewportHeight;
+      viewportHeight = tempViewportWidth;
+    }
+
+    if (videoWidth * viewportHeight >= videoHeight * viewportWidth) {
+      // Horizontal letter-boxing along top and bottom.
+      return new Point(viewportWidth, Util.ceilDivide(viewportWidth * videoHeight, videoWidth));
+    } else {
+      // Vertical letter-boxing along edges.
+      return new Point(Util.ceilDivide(viewportHeight * videoWidth, videoHeight), viewportHeight);
+    }
+  }
+
+  private static Point getDisplaySize(Display display) {
+    Point displaySize = new Point();
+    if (Util.SDK_INT >= 17) {
+      getDisplaySizeV17(display, displaySize);
+    } else if (Util.SDK_INT >= 16) {
+      getDisplaySizeV16(display, displaySize);
+    } else {
+      getDisplaySizeV9(display, displaySize);
+    }
+    return displaySize;
+  }
+
+  @TargetApi(17)
+  private static void getDisplaySizeV17(Display display, Point outSize) {
+    display.getRealSize(outSize);
+  }
+
+  @TargetApi(16)
+  private static void getDisplaySizeV16(Display display, Point outSize) {
+    display.getSize(outSize);
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void getDisplaySizeV9(Display display, Point outSize) {
+    outSize.x = display.getWidth();
+    outSize.y = display.getHeight();
+  }
+
+  private VideoFormatSelectorUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java
deleted file mode 100644
index d501e26bcb..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/Extractor.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-
-import java.util.Map;
-import java.util.UUID;
-
-/**
- * Facilitates extraction of media samples from a container format.
- */
-public interface Extractor {
-
-  /**
-   * An attempt to read from the input stream returned insufficient data.
-   */
-  public static final int RESULT_NEED_MORE_DATA = 1;
-  /**
-   * The end of the input stream was reached.
-   */
-  public static final int RESULT_END_OF_STREAM = 2;
-  /**
-   * A media sample was read.
-   */
-  public static final int RESULT_READ_SAMPLE = 4;
-  /**
-   * Initialization data was read. The parsed data can be read using {@link #getFormat()} and
-   * {@link #getPsshInfo}.
-   */
-  public static final int RESULT_READ_INIT = 8;
-  /**
-   * A sidx atom was read. The parsed data can be read using {@link #getIndex()}.
-   */
-  public static final int RESULT_READ_INDEX = 16;
-  /**
-   * The next thing to be read is a sample, but a {@link SampleHolder} was not supplied.
-   */
-  public static final int RESULT_NEED_SAMPLE_HOLDER = 32;
-
-  /**
-   * Returns the segment index parsed from the stream.
-   *
-   * @return The segment index, or null if a SIDX atom has yet to be parsed.
-   */
-  public SegmentIndex getIndex();
-
-  /**
-   * Returns true if the offsets in the index returned by {@link #getIndex()} are relative to the
-   * first byte following the initialization data, or false if they are absolute (i.e. relative to
-   * the first byte of the stream).
-   *
-   * @return True if the offsets are relative to the first byte following the initialization data.
-   *     False otherwise.
-   */
-  public boolean hasRelativeIndexOffsets();
-
-  /**
-   * Returns the format of the samples contained within the media stream.
-   *
-   * @return The sample media format, or null if the format has yet to be parsed.
-   */
-  public MediaFormat getFormat();
-
-  /**
-   * Returns the duration of the stream in microseconds, or {@link C#UNKNOWN_TIME_US} if unknown.
-   */
-  public long getDurationUs();
-
-  /**
-   * Returns the pssh information parsed from the stream.
-   *
-   * @return The pssh information. May be null if pssh data has yet to be parsed, or if the stream
-   *     does not contain any pssh data.
-   */
-  public Map<UUID, byte[]> getPsshInfo();
-
-  /**
-   * Consumes data from a {@link NonBlockingInputStream}.
-   * <p>
-   * The read terminates if the end of the input stream is reached, if an attempt to read from the
-   * input stream returned 0 bytes of data, or if a sample is read. The returned flags indicate
-   * both the reason for termination and data that was parsed during the read.
-   *
-   * @param inputStream The input stream from which data should be read.
-   * @param out A {@link SampleHolder} into which the next sample should be read. If null then
-   *     {@link #RESULT_NEED_SAMPLE_HOLDER} will be returned once a sample has been reached.
-   * @return One or more of the {@code RESULT_*} flags defined in this class.
-   * @throws ParserException If an error occurs parsing the media data.
-   */
-  public int read(NonBlockingInputStream inputStream, SampleHolder out) throws ParserException;
-
-  /**
-   * Seeks to a position before or equal to the requested time.
-   *
-   * @param seekTimeUs The desired seek time in microseconds.
-   * @param allowNoop Allow the seek operation to do nothing if the seek time is in the current
-   *     fragment run, is equal to or greater than the time of the current sample, and if there
-   *     does not exist a sync frame between these two times.
-   * @return True if the operation resulted in a change of state. False if it was a no-op.
-   */
-  public boolean seekTo(long seekTimeUs, boolean allowNoop);
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java
deleted file mode 100644
index ec68dc125d..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/SegmentIndex.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser;
-
-/**
- * Defines segments within a media stream.
- */
-public final class SegmentIndex {
-
-  /**
-   * The size in bytes of the segment index as it exists in the stream.
-   */
-  public final int sizeBytes;
-
-  /**
-   * The number of segments.
-   */
-  public final int length;
-
-  /**
-   * The segment sizes, in bytes.
-   */
-  public final int[] sizes;
-
-  /**
-   * The segment byte offsets.
-   */
-  public final long[] offsets;
-
-  /**
-   * The segment durations, in microseconds.
-   */
-  public final long[] durationsUs;
-
-  /**
-   * The start time of each segment, in microseconds.
-   */
-  public final long[] timesUs;
-
-  /**
-   * @param sizeBytes The size in bytes of the segment index as it exists in the stream.
-   * @param sizes The segment sizes, in bytes.
-   * @param offsets The segment byte offsets.
-   * @param durationsUs The segment durations, in microseconds.
-   * @param timesUs The start time of each segment, in microseconds.
-   */
-  public SegmentIndex(int sizeBytes, int[] sizes, long[] offsets, long[] durationsUs,
-      long[] timesUs) {
-    this.sizeBytes = sizeBytes;
-    this.length = sizes.length;
-    this.sizes = sizes;
-    this.offsets = offsets;
-    this.durationsUs = durationsUs;
-    this.timesUs = timesUs;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java
deleted file mode 100644
index b0e9c3f237..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/DefaultEbmlReader.java
+++ /dev/null
@@ -1,550 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser.webm;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-import com.google.android.exoplayer.util.Assertions;
-
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.Stack;
-
-/**
- * Default version of a basic event-driven incremental EBML parser which needs an
- * {@link EbmlEventHandler} to define IDs/types and react to events.
- *
- * <p>EBML can be summarized as a binary XML format somewhat similar to Protocol Buffers.
- * It was originally designed for the Matroska container format. More information about EBML and
- * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
- */
-/* package */ final class DefaultEbmlReader implements EbmlReader {
-
-  // State values used in variables state, elementIdState, elementContentSizeState, and
-  // varintBytesState.
-  private static final int STATE_BEGIN_READING = 0;
-  private static final int STATE_READ_CONTENTS = 1;
-  private static final int STATE_FINISHED_READING = 2;
-
-  /**
-   * The first byte of a variable-length integer (varint) will have one of these bit masks
-   * indicating the total length in bytes.
-   *
-   * <p>{@code 0x80} is a one-byte integer, {@code 0x40} is two bytes, and so on up to eight bytes.
-   */
-  private static final int[] VARINT_LENGTH_MASKS = new int[] {
-    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
-  };
-
-  private static final int MAX_INTEGER_ELEMENT_SIZE_BYTES = 8;
-  private static final int VALID_FLOAT32_ELEMENT_SIZE_BYTES = 4;
-  private static final int VALID_FLOAT64_ELEMENT_SIZE_BYTES = 8;
-
-  /**
-   * Scratch space to read in EBML varints, unsigned ints, and floats - each of which can be
-   * up to 8 bytes.
-   */
-  private final byte[] tempByteArray = new byte[8];
-  private final Stack<MasterElement> masterElementsStack = new Stack<MasterElement>();
-
-  /**
-   * Current {@link EbmlEventHandler} which is queried for element types
-   * and informed of element events.
-   */
-  private EbmlEventHandler eventHandler;
-
-  /**
-   * Overall state for the current element. Must be one of the {@code STATE_*} constants.
-   */
-  private int state;
-
-  /**
-   * Total bytes read since starting or the last {@link #reset()}.
-   */
-  private long bytesRead;
-
-  /**
-   * The starting byte offset of the current element being parsed.
-   */
-  private long elementOffset;
-
-  /**
-   * Holds the current element ID after {@link #elementIdState} is {@link #STATE_FINISHED_READING}.
-   */
-  private int elementId;
-
-  /**
-   * State for the ID of the current element. Must be one of the {@code STATE_*} constants.
-   */
-  private int elementIdState;
-
-  /**
-   * Holds the current element content size after {@link #elementContentSizeState}
-   * is {@link #STATE_FINISHED_READING}.
-   */
-  private long elementContentSize;
-
-  /**
-   * State for the content size of the current element.
-   * Must be one of the {@code STATE_*} constants.
-   */
-  private int elementContentSizeState;
-
-  /**
-   * State for the current variable-length integer (varint) being read into
-   * {@link #tempByteArray}. Must be one of the {@code STATE_*} constants.
-   */
-  private int varintBytesState;
-
-  /**
-   * Length in bytes of the current variable-length integer (varint) being read into
-   * {@link #tempByteArray}.
-   */
-  private int varintBytesLength;
-
-  /**
-   * Counts the number of bytes being contiguously read into either {@link #tempByteArray} or
-   * {@link #stringBytes}. Used to determine when all required bytes have been read across
-   * multiple calls.
-   */
-  private int bytesState;
-
-  /**
-   * Holds string element bytes as they're being read in. Allocated after the element content
-   * size is known and released after calling {@link EbmlEventHandler#onStringElement(int, String)}.
-   */
-  private byte[] stringBytes;
-
-  @Override
-  public void setEventHandler(EbmlEventHandler eventHandler) {
-    this.eventHandler = eventHandler;
-  }
-
-  @Override
-  public int read(NonBlockingInputStream inputStream) throws ParserException {
-    Assertions.checkState(eventHandler != null);
-    while (true) {
-      while (!masterElementsStack.isEmpty()
-          && bytesRead >= masterElementsStack.peek().elementEndOffsetBytes) {
-        eventHandler.onMasterElementEnd(masterElementsStack.pop().elementId);
-        return READ_RESULT_CONTINUE;
-      }
-
-      if (state == STATE_BEGIN_READING) {
-        int idResult = readElementId(inputStream);
-        if (idResult != READ_RESULT_CONTINUE) {
-          return idResult;
-        }
-        int sizeResult = readElementContentSize(inputStream);
-        if (sizeResult != READ_RESULT_CONTINUE) {
-          return sizeResult;
-        }
-        state = STATE_READ_CONTENTS;
-        bytesState = 0;
-      }
-
-      int type = eventHandler.getElementType(elementId);
-      switch (type) {
-        case TYPE_MASTER:
-          int masterHeaderSize = (int) (bytesRead - elementOffset); // Header size is 12 bytes max.
-          masterElementsStack.add(new MasterElement(elementId, bytesRead + elementContentSize));
-          eventHandler.onMasterElementStart(elementId, elementOffset, masterHeaderSize,
-              elementContentSize);
-          prepareForNextElement();
-          return READ_RESULT_CONTINUE;
-        case TYPE_UNSIGNED_INT:
-          if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
-            throw new IllegalStateException("Invalid integer size " + elementContentSize);
-          }
-          int intResult =
-              readBytesInternal(inputStream, tempByteArray, (int) elementContentSize);
-          if (intResult != READ_RESULT_CONTINUE) {
-            return intResult;
-          }
-          long intValue = getTempByteArrayValue((int) elementContentSize, false);
-          eventHandler.onIntegerElement(elementId, intValue);
-          prepareForNextElement();
-          return READ_RESULT_CONTINUE;
-        case TYPE_FLOAT:
-          if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES
-              && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
-            throw new IllegalStateException("Invalid float size " + elementContentSize);
-          }
-          int floatResult =
-              readBytesInternal(inputStream, tempByteArray, (int) elementContentSize);
-          if (floatResult != READ_RESULT_CONTINUE) {
-            return floatResult;
-          }
-          long valueBits = getTempByteArrayValue((int) elementContentSize, false);
-          double floatValue;
-          if (elementContentSize == VALID_FLOAT32_ELEMENT_SIZE_BYTES) {
-            floatValue = Float.intBitsToFloat((int) valueBits);
-          } else {
-            floatValue = Double.longBitsToDouble(valueBits);
-          }
-          eventHandler.onFloatElement(elementId, floatValue);
-          prepareForNextElement();
-          return READ_RESULT_CONTINUE;
-        case TYPE_STRING:
-          if (elementContentSize > Integer.MAX_VALUE) {
-            throw new IllegalStateException(
-                "String element size " + elementContentSize + " is larger than MAX_INT");
-          }
-          if (stringBytes == null) {
-            stringBytes = new byte[(int) elementContentSize];
-          }
-          int stringResult =
-              readBytesInternal(inputStream, stringBytes, (int) elementContentSize);
-          if (stringResult != READ_RESULT_CONTINUE) {
-            return stringResult;
-          }
-          String stringValue = new String(stringBytes, Charset.forName(C.UTF8_NAME));
-          stringBytes = null;
-          eventHandler.onStringElement(elementId, stringValue);
-          prepareForNextElement();
-          return READ_RESULT_CONTINUE;
-        case TYPE_BINARY:
-          if (elementContentSize > Integer.MAX_VALUE) {
-            throw new IllegalStateException(
-                "Binary element size " + elementContentSize + " is larger than MAX_INT");
-          }
-          if (inputStream.getAvailableByteCount() < elementContentSize) {
-            return READ_RESULT_NEED_MORE_DATA;
-          }
-          int binaryHeaderSize = (int) (bytesRead - elementOffset); // Header size is 12 bytes max.
-          boolean consumed = eventHandler.onBinaryElement(
-              elementId, elementOffset, binaryHeaderSize, (int) elementContentSize, inputStream);
-          if (consumed) {
-            long expectedBytesRead = elementOffset + binaryHeaderSize + elementContentSize;
-            if (expectedBytesRead != bytesRead) {
-              throw new IllegalStateException("Incorrect total bytes read. Expected "
-                  + expectedBytesRead + " but actually " + bytesRead);
-            }
-            prepareForNextElement();
-          }
-          return READ_RESULT_CONTINUE;
-        case TYPE_UNKNOWN:
-          if (elementContentSize > Integer.MAX_VALUE) {
-            throw new IllegalStateException(
-                "Unknown element size " + elementContentSize + " is larger than MAX_INT");
-          }
-          int skipResult = skipBytesInternal(inputStream, (int) elementContentSize);
-          if (skipResult != READ_RESULT_CONTINUE) {
-            return skipResult;
-          }
-          prepareForNextElement();
-          break;
-        default:
-          throw new IllegalStateException("Invalid element type " + type);
-      }
-    }
-  }
-
-  @Override
-  public long getBytesRead() {
-    return bytesRead;
-  }
-
-  @Override
-  public void reset() {
-    prepareForNextElement();
-    masterElementsStack.clear();
-    bytesRead = 0;
-  }
-
-  @Override
-  public long readVarint(NonBlockingInputStream inputStream) {
-    varintBytesState = STATE_BEGIN_READING;
-    int result = readVarintBytes(inputStream);
-    if (result != READ_RESULT_CONTINUE) {
-      throw new IllegalStateException("Couldn't read varint");
-    }
-    return getTempByteArrayValue(varintBytesLength, true);
-  }
-
-  @Override
-  public void readBytes(NonBlockingInputStream inputStream, ByteBuffer byteBuffer, int totalBytes) {
-    bytesState = 0;
-    int result = readBytesInternal(inputStream, byteBuffer, totalBytes);
-    if (result != READ_RESULT_CONTINUE) {
-      throw new IllegalStateException("Couldn't read bytes into buffer");
-    }
-  }
-
-  @Override
-  public void readBytes(NonBlockingInputStream inputStream, byte[] byteArray, int totalBytes) {
-    bytesState = 0;
-    int result = readBytesInternal(inputStream, byteArray, totalBytes);
-    if (result != READ_RESULT_CONTINUE) {
-      throw new IllegalStateException("Couldn't read bytes into array");
-    }
-  }
-
-  @Override
-  public void skipBytes(NonBlockingInputStream inputStream, int totalBytes) {
-    bytesState = 0;
-    int result = skipBytesInternal(inputStream, totalBytes);
-    if (result != READ_RESULT_CONTINUE) {
-      throw new IllegalStateException("Couldn't skip bytes");
-    }
-  }
-
-  /**
-   * Resets the internal state of {@link #read(NonBlockingInputStream)} so that it can start
-   * reading a new element from scratch.
-   */
-  private void prepareForNextElement() {
-    state = STATE_BEGIN_READING;
-    elementIdState = STATE_BEGIN_READING;
-    elementContentSizeState = STATE_BEGIN_READING;
-    elementOffset = bytesRead;
-  }
-
-  /**
-   * Reads an element ID such that reading can be stopped and started again in a later call
-   * if not enough bytes are available. Returns {@link #READ_RESULT_CONTINUE} if a full element ID
-   * has been read into {@link #elementId}. Reset {@link #elementIdState} to
-   * {@link #STATE_BEGIN_READING} before calling to indicate a new element ID should be read.
-   *
-   * @param inputStream The input stream from which an element ID should be read
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int readElementId(NonBlockingInputStream inputStream) {
-    if (elementIdState == STATE_FINISHED_READING) {
-      return READ_RESULT_CONTINUE;
-    }
-    if (elementIdState == STATE_BEGIN_READING) {
-      varintBytesState = STATE_BEGIN_READING;
-      elementIdState = STATE_READ_CONTENTS;
-    }
-    int result = readVarintBytes(inputStream);
-    if (result != READ_RESULT_CONTINUE) {
-      return result;
-    }
-    // Element IDs are at most 4 bytes so cast to int now.
-    elementId = (int) getTempByteArrayValue(varintBytesLength, false);
-    elementIdState = STATE_FINISHED_READING;
-    return READ_RESULT_CONTINUE;
-  }
-
-  /**
-   * Reads an element's content size such that reading can be stopped and started again in a later
-   * call if not enough bytes are available.
-   *
-   * <p>Returns {@link #READ_RESULT_CONTINUE} if an entire element size has been
-   * read into {@link #elementContentSize}. Reset {@link #elementContentSizeState} to
-   * {@link #STATE_BEGIN_READING} before calling to indicate a new element size should be read.
-   *
-   * @param inputStream The input stream from which an element size should be read
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int readElementContentSize(NonBlockingInputStream inputStream) {
-    if (elementContentSizeState == STATE_FINISHED_READING) {
-      return READ_RESULT_CONTINUE;
-    }
-    if (elementContentSizeState == STATE_BEGIN_READING) {
-      varintBytesState = STATE_BEGIN_READING;
-      elementContentSizeState = STATE_READ_CONTENTS;
-    }
-    int result = readVarintBytes(inputStream);
-    if (result != READ_RESULT_CONTINUE) {
-      return result;
-    }
-    elementContentSize = getTempByteArrayValue(varintBytesLength, true);
-    elementContentSizeState = STATE_FINISHED_READING;
-    return READ_RESULT_CONTINUE;
-  }
-
-  /**
-   * Reads an EBML variable-length integer (varint) such that reading can be stopped and started
-   * again in a later call if not enough bytes are available.
-   *
-   * <p>Returns {@link #READ_RESULT_CONTINUE} if an entire varint has been read into
-   * {@link #tempByteArray} and the length of the varint is in {@link #varintBytesLength}.
-   * Reset {@link #varintBytesState} to {@link #STATE_BEGIN_READING} before calling to indicate
-   * a new varint should be read.
-   *
-   * @param inputStream The input stream from which a varint should be read
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int readVarintBytes(NonBlockingInputStream inputStream) {
-    if (varintBytesState == STATE_FINISHED_READING) {
-      return READ_RESULT_CONTINUE;
-    }
-
-    // Read first byte to get length.
-    if (varintBytesState == STATE_BEGIN_READING) {
-      bytesState = 0;
-      int result = readBytesInternal(inputStream, tempByteArray, 1);
-      if (result != READ_RESULT_CONTINUE) {
-        return result;
-      }
-      varintBytesState = STATE_READ_CONTENTS;
-
-      int firstByte = tempByteArray[0] & 0xff;
-      varintBytesLength = -1;
-      for (int i = 0; i < VARINT_LENGTH_MASKS.length; i++) {
-        if ((VARINT_LENGTH_MASKS[i] & firstByte) != 0) {
-          varintBytesLength = i + 1;
-          break;
-        }
-      }
-      if (varintBytesLength == -1) {
-        throw new IllegalStateException(
-            "No valid varint length mask found at bytesRead = " + bytesRead);
-      }
-    }
-
-    // Read remaining bytes.
-    int result = readBytesInternal(inputStream, tempByteArray, varintBytesLength);
-    if (result != READ_RESULT_CONTINUE) {
-      return result;
-    }
-
-    // All bytes have been read.
-    return READ_RESULT_CONTINUE;
-  }
-
-  /**
-   * Reads a set amount of bytes into a {@link ByteBuffer} such that reading can be stopped
-   * and started again later if not enough bytes are available.
-   *
-   * <p>Returns {@link #READ_RESULT_CONTINUE} if all bytes have been read. Reset
-   * {@link #bytesState} to {@code 0} before calling to indicate a new set of bytes should be read.
-   *
-   * @param inputStream The input stream from which bytes should be read
-   * @param byteBuffer The {@link ByteBuffer} into which bytes should be read
-   * @param totalBytes The total size of bytes to be read
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int readBytesInternal(
-      NonBlockingInputStream inputStream, ByteBuffer byteBuffer, int totalBytes) {
-    if (bytesState == STATE_BEGIN_READING && totalBytes > byteBuffer.capacity()) {
-      throw new IllegalArgumentException("Byte buffer not large enough");
-    }
-    if (bytesState >= totalBytes) {
-      return READ_RESULT_CONTINUE;
-    }
-    int remainingBytes = totalBytes - bytesState;
-    int additionalBytesRead = inputStream.read(byteBuffer, remainingBytes);
-    return updateBytesState(additionalBytesRead, totalBytes);
-  }
-
-  /**
-   * Reads a set amount of bytes into a {@code byte[]} such that reading can be stopped
-   * and started again later if not enough bytes are available.
-   *
-   * <p>Returns {@link #READ_RESULT_CONTINUE} if all bytes have been read. Reset
-   * {@link #bytesState} to {@code 0} before calling to indicate a new set of bytes should be read.
-   *
-   * @param inputStream The input stream from which bytes should be read
-   * @param byteArray The {@code byte[]} into which bytes should be read
-   * @param totalBytes The total size of bytes to be read
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int readBytesInternal(
-      NonBlockingInputStream inputStream, byte[] byteArray, int totalBytes) {
-    if (bytesState == STATE_BEGIN_READING && totalBytes > byteArray.length) {
-      throw new IllegalArgumentException("Byte array not large enough");
-    }
-    if (bytesState >= totalBytes) {
-      return READ_RESULT_CONTINUE;
-    }
-    int remainingBytes = totalBytes - bytesState;
-    int additionalBytesRead = inputStream.read(byteArray, bytesState, remainingBytes);
-    return updateBytesState(additionalBytesRead, totalBytes);
-  }
-
-  /**
-   * Skips a set amount of bytes such that reading can be stopped and started again later if
-   * not enough bytes are available.
-   *
-   * <p>Returns {@link #READ_RESULT_CONTINUE} if all bytes have been skipped. Reset
-   * {@link #bytesState} to {@code 0} before calling to indicate a new set of bytes
-   * should be skipped.
-   *
-   * @param inputStream The input stream from which bytes should be skipped
-   * @param totalBytes The total size of bytes to be skipped
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int skipBytesInternal(NonBlockingInputStream inputStream, int totalBytes) {
-    if (bytesState >= totalBytes) {
-      return READ_RESULT_CONTINUE;
-    }
-    int remainingBytes = totalBytes - bytesState;
-    int additionalBytesRead = inputStream.skip(remainingBytes);
-    return updateBytesState(additionalBytesRead, totalBytes);
-  }
-
-  /**
-   * Updates {@link #bytesState} and {@link #bytesRead} after reading bytes in one of the
-   * {@code verbBytesInternal} methods.
-   *
-   * @param additionalBytesRead The number of additional bytes read to be accounted for
-   * @param totalBytes The total size of bytes to be read or skipped
-   * @return One of the {@code RESULT_*} flags defined in this class
-   */
-  private int updateBytesState(int additionalBytesRead, int totalBytes) {
-    if (additionalBytesRead == -1) {
-      return READ_RESULT_END_OF_STREAM;
-    }
-    bytesState += additionalBytesRead;
-    bytesRead += additionalBytesRead;
-    if (bytesState < totalBytes) {
-      return READ_RESULT_NEED_MORE_DATA;
-    } else {
-      return READ_RESULT_CONTINUE;
-    }
-  }
-
-  /**
-   * Parses and returns the integer value currently read into the first {@code byteLength} bytes
-   * of {@link #tempByteArray}. EBML varint length masks can optionally be removed.
-   *
-   * @param byteLength The number of bytes to parse from {@link #tempByteArray}
-   * @param removeLengthMask Removes the variable-length integer length mask from the value
-   * @return The resulting integer value. This value could be up to 8-bytes so a Java long is used
-   */
-  private long getTempByteArrayValue(int byteLength, boolean removeLengthMask) {
-    if (removeLengthMask) {
-      tempByteArray[0] &= ~VARINT_LENGTH_MASKS[varintBytesLength - 1];
-    }
-    long varint = 0;
-    for (int i = 0; i < byteLength; i++) {
-      // Shift all existing bits up one byte and add the next byte at the bottom.
-      varint = (varint << 8) | (tempByteArray[i] & 0xff);
-    }
-    return varint;
-  }
-
-  /**
-   * Used in {@link #masterElementsStack} to track when the current master element ends so that
-   * {@link EbmlEventHandler#onMasterElementEnd(int)} is called.
-   */
-  private static final class MasterElement {
-
-    private final int elementId;
-    private final long elementEndOffsetBytes;
-
-    private MasterElement(int elementId, long elementEndOffsetBytes) {
-      this.elementId = elementId;
-      this.elementEndOffsetBytes = elementEndOffsetBytes;
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java
deleted file mode 100644
index 53631f1a86..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlEventHandler.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser.webm;
-
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-
-import java.nio.ByteBuffer;
-
-/**
- * Defines EBML element IDs/types and reacts to events.
- */
-/* package */ interface EbmlEventHandler {
-
-  /**
-   * Retrieves the type of an element ID.
-   *
-   * <p>If {@link EbmlReader#TYPE_UNKNOWN} is returned then the element is skipped.
-   * Note that all children of a skipped master element are also skipped.
-   *
-   * @param id The integer ID of this element
-   * @return One of the {@code TYPE_} constants defined in this class
-   */
-  public int getElementType(int id);
-
-  /**
-   * Called when a master element is encountered in the {@link NonBlockingInputStream}.
-   *
-   * <p>Following events should be considered as taking place "within" this element until a
-   * matching call to {@link #onMasterElementEnd(int)} is made. Note that it is possible for
-   * another master element of the same ID to be nested within itself.
-   *
-   * @param id The integer ID of this element
-   * @param elementOffsetBytes The byte offset where this element starts
-   * @param headerSizeBytes The byte length of this element's ID and size header
-   * @param contentsSizeBytes The byte length of this element's children
-   * @throws ParserException If a parsing error occurs.
-   */
-  public void onMasterElementStart(
-      int id, long elementOffsetBytes, int headerSizeBytes,
-      long contentsSizeBytes) throws ParserException;
-
-  /**
-   * Called when a master element has finished reading in all of its children from the
-   * {@link NonBlockingInputStream}.
-   *
-   * @param id The integer ID of this element
-   * @throws ParserException If a parsing error occurs.
-   */
-  public void onMasterElementEnd(int id) throws ParserException;
-
-  /**
-   * Called when an integer element is encountered in the {@link NonBlockingInputStream}.
-   *
-   * @param id The integer ID of this element
-   * @param value The integer value this element contains
-   * @throws ParserException If a parsing error occurs.
-   */
-  public void onIntegerElement(int id, long value) throws ParserException;
-
-  /**
-   * Called when a float element is encountered in the {@link NonBlockingInputStream}.
-   *
-   * @param id The integer ID of this element
-   * @param value The float value this element contains
-   * @throws ParserException If a parsing error occurs.
-   */
-  public void onFloatElement(int id, double value) throws ParserException;
-
-  /**
-   * Called when a string element is encountered in the {@link NonBlockingInputStream}.
-   *
-   * @param id The integer ID of this element
-   * @param value The string value this element contains
-   * @throws ParserException If a parsing error occurs.
-   */
-  public void onStringElement(int id, String value) throws ParserException;
-
-  /**
-   * Called when a binary element is encountered in the {@link NonBlockingInputStream}.
-   *
-   * <p>The element header (containing element ID and content size) will already have been read.
-   * Subclasses must either read nothing and return {@code false}, or exactly read the entire
-   * contents of the element, which is {@code contentsSizeBytes} in length, and return {@code true}.
-   *
-   * <p>It's guaranteed that the full element contents will be immediately available from
-   * {@code inputStream}.
-   *
-   * <p>Several methods in {@link EbmlReader} are available for reading the contents of a
-   * binary element:
-   * <ul>
-   * <li>{@link EbmlReader#readVarint(NonBlockingInputStream)}.
-   * <li>{@link EbmlReader#readBytes(NonBlockingInputStream, byte[], int)}.
-   * <li>{@link EbmlReader#readBytes(NonBlockingInputStream, ByteBuffer, int)}.
-   * <li>{@link EbmlReader#skipBytes(NonBlockingInputStream, int)}.
-   * <li>{@link EbmlReader#getBytesRead()}.
-   * </ul>
-   *
-   * @param id The integer ID of this element
-   * @param elementOffsetBytes The byte offset where this element starts
-   * @param headerSizeBytes The byte length of this element's ID and size header
-   * @param contentsSizeBytes The byte length of this element's contents
-   * @param inputStream The {@link NonBlockingInputStream} from which this
-   *        element's contents should be read
-   * @return True if the element was read. False otherwise.
-   * @throws ParserException If a parsing error occurs.
-   */
-  public boolean onBinaryElement(
-      int id, long elementOffsetBytes, int headerSizeBytes, int contentsSizeBytes,
-      NonBlockingInputStream inputStream) throws ParserException;
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java
deleted file mode 100644
index 1c6dd0178c..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/EbmlReader.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser.webm;
-
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-
-import java.nio.ByteBuffer;
-
-/**
- * Basic event-driven incremental EBML parser which needs an {@link EbmlEventHandler} to
- * define IDs/types and react to events.
- *
- * <p>EBML can be summarized as a binary XML format somewhat similar to Protocol Buffers.
- * It was originally designed for the Matroska container format. More information about EBML and
- * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
- */
-/* package */ interface EbmlReader {
-
-  // Element Types
-  /** Undefined element. */
-  public static final int TYPE_UNKNOWN = 0;
-  /** Contains child elements. */
-  public static final int TYPE_MASTER = 1;
-  /** Unsigned integer value of up to 8 bytes. */
-  public static final int TYPE_UNSIGNED_INT = 2;
-  public static final int TYPE_STRING = 3;
-  public static final int TYPE_BINARY = 4;
-  /** IEEE floating point value of either 4 or 8 bytes. */
-  public static final int TYPE_FLOAT = 5;
-
-  // Return values for reading methods.
-  public static final int READ_RESULT_CONTINUE = 0;
-  public static final int READ_RESULT_NEED_MORE_DATA = 1;
-  public static final int READ_RESULT_END_OF_STREAM = 2;
-
-  public void setEventHandler(EbmlEventHandler eventHandler);
-
-  /**
-   * Reads from a {@link NonBlockingInputStream}, invoking an event callback if possible.
-   *
-   * @param inputStream The input stream from which data should be read
-   * @return One of the {@code RESULT_*} flags defined in this interface
-   * @throws ParserException If parsing fails.
-   */
-  public int read(NonBlockingInputStream inputStream) throws ParserException;
-
-  /**
-   * The total number of bytes consumed by the reader since first created or last {@link #reset()}.
-   */
-  public long getBytesRead();
-
-  /**
-   * Resets the entire state of the reader so that it will read a new EBML structure from scratch.
-   *
-   * <p>This includes resetting the value returned from {@link #getBytesRead()} to 0 and discarding
-   * all pending {@link EbmlEventHandler#onMasterElementEnd(int)} events.
-   */
-  public void reset();
-
-  /**
-   * Reads, parses, and returns an EBML variable-length integer (varint) from the contents
-   * of a binary element.
-   *
-   * @param inputStream The input stream from which data should be read
-   * @return The varint value at the current position of the contents of a binary element
-   */
-  public long readVarint(NonBlockingInputStream inputStream);
-
-  /**
-   * Reads a fixed number of bytes from the contents of a binary element into a {@link ByteBuffer}.
-   *
-   * @param inputStream The input stream from which data should be read
-   * @param byteBuffer The {@link ByteBuffer} to which data should be written
-   * @param totalBytes The fixed number of bytes to be read and written
-   */
-  public void readBytes(NonBlockingInputStream inputStream, ByteBuffer byteBuffer, int totalBytes);
-
-  /**
-   * Reads a fixed number of bytes from the contents of a binary element into a {@code byte[]}.
-   *
-   * @param inputStream The input stream from which data should be read
-   * @param byteArray The byte array to which data should be written
-   * @param totalBytes The fixed number of bytes to be read and written
-   */
-  public void readBytes(NonBlockingInputStream inputStream, byte[] byteArray, int totalBytes);
-
-  /**
-   * Skips a fixed number of bytes from the contents of a binary element.
-   *
-   * @param inputStream The input stream from which data should be skipped
-   * @param totalBytes The fixed number of bytes to be skipped
-   */
-  public void skipBytes(NonBlockingInputStream inputStream, int totalBytes);
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java
deleted file mode 100644
index ddf15e5610..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/webm/WebmExtractor.java
+++ /dev/null
@@ -1,645 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk.parser.webm;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.chunk.parser.Extractor;
-import com.google.android.exoplayer.chunk.parser.SegmentIndex;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
-import com.google.android.exoplayer.util.LongArray;
-import com.google.android.exoplayer.util.MimeTypes;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-
-/**
- * An extractor to facilitate data retrieval from the WebM container format.
- *
- * <p>WebM is a subset of the EBML elements defined for Matroska. More information about EBML and
- * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
- * More info about WebM is <a href="http://www.webmproject.org/code/specs/container/">here</a>.
- */
-public final class WebmExtractor implements Extractor {
-
-  private static final String DOC_TYPE_WEBM = "webm";
-  private static final String CODEC_ID_VP9 = "V_VP9";
-  private static final String CODEC_ID_VORBIS = "A_VORBIS";
-  private static final String CODEC_ID_OPUS = "A_OPUS";
-  private static final int VORBIS_MAX_INPUT_SIZE = 8192;
-  private static final int OPUS_MAX_INPUT_SIZE = 5760;
-  private static final int UNKNOWN = -1;
-
-  // Element IDs
-  private static final int ID_EBML = 0x1A45DFA3;
-  private static final int ID_EBML_READ_VERSION = 0x42F7;
-  private static final int ID_DOC_TYPE = 0x4282;
-  private static final int ID_DOC_TYPE_READ_VERSION = 0x4285;
-
-  private static final int ID_SEGMENT = 0x18538067;
-
-  private static final int ID_INFO = 0x1549A966;
-  private static final int ID_TIMECODE_SCALE = 0x2AD7B1;
-  private static final int ID_DURATION = 0x4489;
-
-  private static final int ID_CLUSTER = 0x1F43B675;
-  private static final int ID_TIME_CODE = 0xE7;
-  private static final int ID_SIMPLE_BLOCK = 0xA3;
-  private static final int ID_BLOCK_GROUP = 0xA0;
-  private static final int ID_BLOCK = 0xA1;
-
-  private static final int ID_TRACKS = 0x1654AE6B;
-  private static final int ID_TRACK_ENTRY = 0xAE;
-  private static final int ID_CODEC_ID = 0x86;
-  private static final int ID_CODEC_PRIVATE = 0x63A2;
-  private static final int ID_CODEC_DELAY = 0x56AA;
-  private static final int ID_SEEK_PRE_ROLL = 0x56BB;
-  private static final int ID_VIDEO = 0xE0;
-  private static final int ID_PIXEL_WIDTH = 0xB0;
-  private static final int ID_PIXEL_HEIGHT = 0xBA;
-  private static final int ID_AUDIO = 0xE1;
-  private static final int ID_CHANNELS = 0x9F;
-  private static final int ID_SAMPLING_FREQUENCY = 0xB5;
-
-  private static final int ID_CUES = 0x1C53BB6B;
-  private static final int ID_CUE_POINT = 0xBB;
-  private static final int ID_CUE_TIME = 0xB3;
-  private static final int ID_CUE_TRACK_POSITIONS = 0xB7;
-  private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
-
-  // SimpleBlock Lacing Values
-  private static final int LACING_NONE = 0;
-  private static final int LACING_XIPH = 1;
-  private static final int LACING_FIXED = 2;
-  private static final int LACING_EBML = 3;
-
-  private static final int READ_TERMINATING_RESULTS = RESULT_NEED_MORE_DATA | RESULT_END_OF_STREAM
-      | RESULT_READ_SAMPLE | RESULT_NEED_SAMPLE_HOLDER;
-
-  private final EbmlReader reader;
-  private final byte[] simpleBlockTimecodeAndFlags = new byte[3];
-
-  private SampleHolder sampleHolder;
-  private int readResults;
-
-  private long segmentStartOffsetBytes = UNKNOWN;
-  private long segmentEndOffsetBytes = UNKNOWN;
-  private long timecodeScale = 1000000L;
-  private long durationUs = UNKNOWN;
-  private int pixelWidth = UNKNOWN;
-  private int pixelHeight = UNKNOWN;
-  private int channelCount = UNKNOWN;
-  private int sampleRate = UNKNOWN;
-  private byte[] codecPrivate;
-  private String codecId;
-  private long codecDelayNs;
-  private long seekPreRollNs;
-  private boolean seenAudioTrack;
-  private long cuesSizeBytes = UNKNOWN;
-  private long clusterTimecodeUs = UNKNOWN;
-  private long simpleBlockTimecodeUs = UNKNOWN;
-  private MediaFormat format;
-  private SegmentIndex cues;
-  private LongArray cueTimesUs;
-  private LongArray cueClusterPositions;
-
-  public WebmExtractor() {
-    this(new DefaultEbmlReader());
-  }
-
-  /* package */ WebmExtractor(EbmlReader reader) {
-    this.reader = reader;
-    this.reader.setEventHandler(new InnerEbmlEventHandler());
-  }
-
-  @Override
-  public int read(
-      NonBlockingInputStream inputStream, SampleHolder sampleHolder) throws ParserException {
-    this.sampleHolder = sampleHolder;
-    this.readResults = 0;
-    while ((readResults & READ_TERMINATING_RESULTS) == 0) {
-      int ebmlReadResult = reader.read(inputStream);
-      if (ebmlReadResult == EbmlReader.READ_RESULT_NEED_MORE_DATA) {
-        readResults |= WebmExtractor.RESULT_NEED_MORE_DATA;
-      } else if (ebmlReadResult == EbmlReader.READ_RESULT_END_OF_STREAM) {
-        readResults |= WebmExtractor.RESULT_END_OF_STREAM;
-      }
-    }
-    this.sampleHolder = null;
-    return readResults;
-  }
-
-  @Override
-  public boolean seekTo(long seekTimeUs, boolean allowNoop) {
-    if (allowNoop
-        && cues != null
-        && clusterTimecodeUs != UNKNOWN
-        && simpleBlockTimecodeUs != UNKNOWN
-        && seekTimeUs >= simpleBlockTimecodeUs) {
-      int clusterIndex = Arrays.binarySearch(cues.timesUs, clusterTimecodeUs);
-      if (clusterIndex >= 0 && seekTimeUs < clusterTimecodeUs + cues.durationsUs[clusterIndex]) {
-        return false;
-      }
-    }
-    clusterTimecodeUs = UNKNOWN;
-    simpleBlockTimecodeUs = UNKNOWN;
-    reader.reset();
-    return true;
-  }
-
-  @Override
-  public SegmentIndex getIndex() {
-    return cues;
-  }
-
-  @Override
-  public boolean hasRelativeIndexOffsets() {
-    return false;
-  }
-
-  @Override
-  public MediaFormat getFormat() {
-    return format;
-  }
-
-  @Override
-  public long getDurationUs() {
-    return durationUs == UNKNOWN ? C.UNKNOWN_TIME_US : durationUs;
-  }
-
-  @Override
-  public Map<UUID, byte[]> getPsshInfo() {
-    // TODO: Parse pssh data from Webm streams.
-    return null;
-  }
-
-  /* package */ int getElementType(int id) {
-    switch (id) {
-      case ID_EBML:
-      case ID_SEGMENT:
-      case ID_INFO:
-      case ID_CLUSTER:
-      case ID_TRACKS:
-      case ID_TRACK_ENTRY:
-      case ID_AUDIO:
-      case ID_VIDEO:
-      case ID_CUES:
-      case ID_CUE_POINT:
-      case ID_CUE_TRACK_POSITIONS:
-      case ID_BLOCK_GROUP:
-        return EbmlReader.TYPE_MASTER;
-      case ID_EBML_READ_VERSION:
-      case ID_DOC_TYPE_READ_VERSION:
-      case ID_TIMECODE_SCALE:
-      case ID_TIME_CODE:
-      case ID_PIXEL_WIDTH:
-      case ID_PIXEL_HEIGHT:
-      case ID_CODEC_DELAY:
-      case ID_SEEK_PRE_ROLL:
-      case ID_CHANNELS:
-      case ID_CUE_TIME:
-      case ID_CUE_CLUSTER_POSITION:
-        return EbmlReader.TYPE_UNSIGNED_INT;
-      case ID_DOC_TYPE:
-      case ID_CODEC_ID:
-        return EbmlReader.TYPE_STRING;
-      case ID_SIMPLE_BLOCK:
-      case ID_BLOCK:
-      case ID_CODEC_PRIVATE:
-        return EbmlReader.TYPE_BINARY;
-      case ID_DURATION:
-      case ID_SAMPLING_FREQUENCY:
-        return EbmlReader.TYPE_FLOAT;
-      default:
-        return EbmlReader.TYPE_UNKNOWN;
-    }
-  }
-
-  /* package */ boolean onMasterElementStart(
-      int id, long elementOffsetBytes, int headerSizeBytes,
-      long contentsSizeBytes) throws ParserException {
-    switch (id) {
-      case ID_SEGMENT:
-        if (segmentStartOffsetBytes != UNKNOWN || segmentEndOffsetBytes != UNKNOWN) {
-          throw new ParserException("Multiple Segment elements not supported");
-        }
-        segmentStartOffsetBytes = elementOffsetBytes + headerSizeBytes;
-        segmentEndOffsetBytes = elementOffsetBytes + headerSizeBytes + contentsSizeBytes;
-        break;
-      case ID_CUES:
-        cuesSizeBytes = headerSizeBytes + contentsSizeBytes;
-        cueTimesUs = new LongArray();
-        cueClusterPositions = new LongArray();
-        break;
-      default:
-        // pass
-    }
-    return true;
-  }
-
-  /* package */ boolean onMasterElementEnd(int id) throws ParserException {
-    switch (id) {
-      case ID_CUES:
-        buildCues();
-        return false;
-      case ID_VIDEO:
-        buildVideoFormat();
-        return true;
-      case ID_AUDIO:
-        seenAudioTrack = true;
-        return true;
-      case ID_TRACK_ENTRY:
-        if (seenAudioTrack) {
-          // Audio format has to be built here since codec private may not be available at the end
-          // of ID_AUDIO.
-          buildAudioFormat();
-        }
-        return true;
-      default:
-        return true;
-    }
-  }
-
-  /* package */ boolean onIntegerElement(int id, long value) throws ParserException {
-    switch (id) {
-      case ID_EBML_READ_VERSION:
-        // Validate that EBMLReadVersion is supported. This extractor only supports v1.
-        if (value != 1) {
-          throw new ParserException("EBMLReadVersion " + value + " not supported");
-        }
-        break;
-      case ID_DOC_TYPE_READ_VERSION:
-        // Validate that DocTypeReadVersion is supported. This extractor only supports up to v2.
-        if (value < 1 || value > 2) {
-          throw new ParserException("DocTypeReadVersion " + value + " not supported");
-        }
-        break;
-      case ID_TIMECODE_SCALE:
-        timecodeScale = value;
-        break;
-      case ID_PIXEL_WIDTH:
-        pixelWidth = (int) value;
-        break;
-      case ID_PIXEL_HEIGHT:
-        pixelHeight = (int) value;
-        break;
-      case ID_CODEC_DELAY:
-        codecDelayNs = value;
-        break;
-      case ID_SEEK_PRE_ROLL:
-        seekPreRollNs = value;
-        break;
-      case ID_CHANNELS:
-        channelCount = (int) value;
-        break;
-      case ID_CUE_TIME:
-        cueTimesUs.add(scaleTimecodeToUs(value));
-        break;
-      case ID_CUE_CLUSTER_POSITION:
-        cueClusterPositions.add(value);
-        break;
-      case ID_TIME_CODE:
-        clusterTimecodeUs = scaleTimecodeToUs(value);
-        break;
-      default:
-        // pass
-    }
-    return true;
-  }
-
-  /* package */ boolean onFloatElement(int id, double value) {
-    switch (id) {
-      case ID_DURATION:
-        durationUs = scaleTimecodeToUs((long) value);
-        break;
-      case ID_SAMPLING_FREQUENCY:
-        sampleRate = (int) value;
-        break;
-      default:
-        // pass
-    }
-    return true;
-  }
-
-  /* package */ boolean onStringElement(int id, String value) throws ParserException {
-    switch (id) {
-      case ID_DOC_TYPE:
-        // Validate that DocType is supported. This extractor only supports "webm".
-        if (!DOC_TYPE_WEBM.equals(value)) {
-          throw new ParserException("DocType " + value + " not supported");
-        }
-        break;
-      case ID_CODEC_ID:
-        // Validate that CodecID is supported. This extractor only supports "V_VP9" and "A_VORBIS".
-        if (!isCodecSupported(value)) {
-          throw new ParserException("CodecID " + value + " not supported");
-        }
-        codecId = value;
-        break;
-      default:
-        // pass
-    }
-    return true;
-  }
-
-  /* package */ boolean onBinaryElement(
-      int id, long elementOffsetBytes, int headerSizeBytes, int contentsSizeBytes,
-      NonBlockingInputStream inputStream) throws ParserException {
-    switch (id) {
-      case ID_SIMPLE_BLOCK:
-      case ID_BLOCK:
-        // Please refer to http://www.matroska.org/technical/specs/index.html#simpleblock_structure
-        // and http://matroska.org/technical/specs/index.html#block_structure
-        // for info about how data is organized in SimpleBlock and Block elements respectively. They
-        // differ only in the way flags are specified.
-
-        // If we don't have a sample holder then don't consume the data.
-        if (sampleHolder == null) {
-          readResults |= RESULT_NEED_SAMPLE_HOLDER;
-          return false;
-        }
-
-        // Value of trackNumber is not used but needs to be read.
-        reader.readVarint(inputStream);
-
-        // Next three bytes have timecode and flags.
-        reader.readBytes(inputStream, simpleBlockTimecodeAndFlags, 3);
-
-        // First two bytes of the three are the relative timecode.
-        int timecode =
-            (simpleBlockTimecodeAndFlags[0] << 8) | (simpleBlockTimecodeAndFlags[1] & 0xff);
-        long timecodeUs = scaleTimecodeToUs(timecode);
-
-        // Last byte of the three has some flags and the lacing value.
-        boolean keyframe;
-        if (id == ID_BLOCK) {
-          // Matroska Block element does not self-sufficiently say whether it is a key frame or not.
-          // It depends on the existence of another element (ReferenceBlock) which may occur after
-          // the Block element. Since this extractor uses Block element only for Opus, we set the
-          // keyframe to be true always since all Opus frames are key frames.
-          keyframe = true;
-        } else {
-          keyframe = (simpleBlockTimecodeAndFlags[2] & 0x80) == 0x80;
-        }
-        boolean invisible = (simpleBlockTimecodeAndFlags[2] & 0x08) == 0x08;
-        int lacing = (simpleBlockTimecodeAndFlags[2] & 0x06) >> 1;
-
-        // Validate lacing and set info into sample holder.
-        switch (lacing) {
-          case LACING_NONE:
-            long elementEndOffsetBytes = elementOffsetBytes + headerSizeBytes + contentsSizeBytes;
-            simpleBlockTimecodeUs = clusterTimecodeUs + timecodeUs;
-            sampleHolder.flags = keyframe ? C.SAMPLE_FLAG_SYNC : 0;
-            sampleHolder.decodeOnly = invisible;
-            sampleHolder.timeUs = clusterTimecodeUs + timecodeUs;
-            sampleHolder.size = (int) (elementEndOffsetBytes - reader.getBytesRead());
-            break;
-          case LACING_EBML:
-          case LACING_FIXED:
-          case LACING_XIPH:
-          default:
-            throw new ParserException("Lacing mode " + lacing + " not supported");
-        }
-
-        if (sampleHolder.data == null || sampleHolder.data.capacity() < sampleHolder.size) {
-          sampleHolder.replaceBuffer(sampleHolder.size);
-        }
-
-        ByteBuffer outputData = sampleHolder.data;
-        if (outputData == null) {
-          reader.skipBytes(inputStream, sampleHolder.size);
-          sampleHolder.size = 0;
-        } else {
-          reader.readBytes(inputStream, outputData, sampleHolder.size);
-        }
-        readResults |= RESULT_READ_SAMPLE;
-        break;
-      case ID_CODEC_PRIVATE:
-        codecPrivate = new byte[contentsSizeBytes];
-        reader.readBytes(inputStream, codecPrivate, contentsSizeBytes);
-        break;
-      default:
-        // pass
-    }
-    return true;
-  }
-
-  private long scaleTimecodeToUs(long unscaledTimecode) {
-    return TimeUnit.NANOSECONDS.toMicros(unscaledTimecode * timecodeScale);
-  }
-
-  private boolean isCodecSupported(String codecId) {
-    return CODEC_ID_VP9.equals(codecId)
-        || CODEC_ID_OPUS.equals(codecId)
-        || CODEC_ID_VORBIS.equals(codecId);
-  }
-
-  /**
-   * Build a video {@link MediaFormat} containing recently gathered Video information, if needed.
-   *
-   * <p>Replaces the previous {@link #format} only if video width/height have changed.
-   * {@link #format} is guaranteed to not be null after calling this method. In
-   * the event that it can't be built, an {@link ParserException} will be thrown.
-   */
-  private void buildVideoFormat() throws ParserException {
-    if (pixelWidth != UNKNOWN && pixelHeight != UNKNOWN
-        && (format == null || format.width != pixelWidth || format.height != pixelHeight)) {
-      format = MediaFormat.createVideoFormat(
-          MimeTypes.VIDEO_VP9, MediaFormat.NO_VALUE, pixelWidth, pixelHeight, null);
-      readResults |= RESULT_READ_INIT;
-    } else if (format == null) {
-      throw new ParserException("Unable to build format");
-    }
-  }
-
-  /**
-   * Build an audio {@link MediaFormat} containing recently gathered Audio information, if needed.
-   *
-   * <p>Replaces the previous {@link #format} only if audio channel count/sample rate have changed.
-   * {@link #format} is guaranteed to not be null after calling this method.
-   *
-   * @throws ParserException If an error occurs when parsing codec's private data or if the format
-   *    can't be built.
-   */
-  private void buildAudioFormat() throws ParserException {
-    if (channelCount != UNKNOWN && sampleRate != UNKNOWN
-        && (format == null || format.channelCount != channelCount
-            || format.sampleRate != sampleRate)) {
-      if (CODEC_ID_VORBIS.equals(codecId)) {
-        format = MediaFormat.createAudioFormat(
-            MimeTypes.AUDIO_VORBIS, VORBIS_MAX_INPUT_SIZE,
-            channelCount, sampleRate, parseVorbisCodecPrivate());
-      } else if (CODEC_ID_OPUS.equals(codecId)) {
-        ArrayList<byte[]> opusInitializationData = new ArrayList<byte[]>(3);
-        opusInitializationData.add(codecPrivate);
-        opusInitializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(codecDelayNs).array());
-        opusInitializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(seekPreRollNs).array());
-        format = MediaFormat.createAudioFormat(
-            MimeTypes.AUDIO_OPUS, OPUS_MAX_INPUT_SIZE, channelCount, sampleRate,
-            opusInitializationData);
-      }
-      readResults |= RESULT_READ_INIT;
-    } else if (format == null) {
-      throw new ParserException("Unable to build format");
-    }
-  }
-
-  /**
-   * Build a {@link SegmentIndex} containing recently gathered Cues information.
-   *
-   * <p>{@link #cues} is guaranteed to not be null after calling this method. In
-   * the event that it can't be built, an {@link ParserException} will be thrown.
-   */
-  private void buildCues() throws ParserException {
-    if (segmentStartOffsetBytes == UNKNOWN) {
-      throw new ParserException("Segment start/end offsets unknown");
-    } else if (durationUs == UNKNOWN) {
-      throw new ParserException("Duration unknown");
-    } else if (cuesSizeBytes == UNKNOWN) {
-      throw new ParserException("Cues size unknown");
-    } else if (cueTimesUs == null || cueClusterPositions == null
-        || cueTimesUs.size() == 0 || cueTimesUs.size() != cueClusterPositions.size()) {
-      throw new ParserException("Invalid/missing cue points");
-    }
-    int cuePointsSize = cueTimesUs.size();
-    int[] sizes = new int[cuePointsSize];
-    long[] offsets = new long[cuePointsSize];
-    long[] durationsUs = new long[cuePointsSize];
-    long[] timesUs = new long[cuePointsSize];
-    for (int i = 0; i < cuePointsSize; i++) {
-      timesUs[i] = cueTimesUs.get(i);
-      offsets[i] = segmentStartOffsetBytes + cueClusterPositions.get(i);
-    }
-    for (int i = 0; i < cuePointsSize - 1; i++) {
-      sizes[i] = (int) (offsets[i + 1] - offsets[i]);
-      durationsUs[i] = timesUs[i + 1] - timesUs[i];
-    }
-    sizes[cuePointsSize - 1] = (int) (segmentEndOffsetBytes - offsets[cuePointsSize - 1]);
-    durationsUs[cuePointsSize - 1] = durationUs - timesUs[cuePointsSize - 1];
-    cues = new SegmentIndex((int) cuesSizeBytes, sizes, offsets, durationsUs, timesUs);
-    cueTimesUs = null;
-    cueClusterPositions = null;
-    readResults |= RESULT_READ_INDEX;
-  }
-
-  /**
-   * Parses Vorbis Codec Private data and adds it as initialization data to the {@link #format}.
-   * WebM Vorbis Codec Private data specification can be found
-   * <a href="http://matroska.org/technical/specs/codecid/index.html">here</a>.
-   *
-   * @return ArrayList of byte arrays containing the initialization data on success.
-   * @throws ParserException If parsing codec private data fails.
-   */
-  private ArrayList<byte[]> parseVorbisCodecPrivate() throws ParserException {
-    try {
-      if (codecPrivate[0] != 0x02) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      int offset = 1;
-      int vorbisInfoLength = 0;
-      while (codecPrivate[offset] == (byte) 0xFF) {
-        vorbisInfoLength += 0xFF;
-        offset++;
-      }
-      vorbisInfoLength += codecPrivate[offset++];
-
-      int vorbisSkipLength = 0;
-      while (codecPrivate[offset] == (byte) 0xFF) {
-        vorbisSkipLength += 0xFF;
-        offset++;
-      }
-      vorbisSkipLength += codecPrivate[offset++];
-
-      if (codecPrivate[offset] != 0x01) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      byte[] vorbisInfo = new byte[vorbisInfoLength];
-      System.arraycopy(codecPrivate, offset, vorbisInfo, 0, vorbisInfoLength);
-      offset += vorbisInfoLength;
-      if (codecPrivate[offset] != 0x03) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      offset += vorbisSkipLength;
-      if (codecPrivate[offset] != 0x05) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      byte[] vorbisBooks = new byte[codecPrivate.length - offset];
-      System.arraycopy(codecPrivate, offset, vorbisBooks, 0, codecPrivate.length - offset);
-      ArrayList<byte[]> initializationData = new ArrayList<byte[]>(2);
-      initializationData.add(vorbisInfo);
-      initializationData.add(vorbisBooks);
-      return initializationData;
-    } catch (ArrayIndexOutOfBoundsException e) {
-      throw new ParserException("Error parsing vorbis codec private");
-    }
-  }
-
-  /**
-   * Passes events through to {@link WebmExtractor} as
-   * callbacks from {@link EbmlReader} are received.
-   */
-  private final class InnerEbmlEventHandler implements EbmlEventHandler {
-
-    @Override
-    public int getElementType(int id) {
-      return WebmExtractor.this.getElementType(id);
-    }
-
-    @Override
-    public void onMasterElementStart(
-        int id, long elementOffsetBytes, int headerSizeBytes,
-        long contentsSizeBytes) throws ParserException {
-      WebmExtractor.this.onMasterElementStart(
-          id, elementOffsetBytes, headerSizeBytes, contentsSizeBytes);
-    }
-
-    @Override
-    public void onMasterElementEnd(int id) throws ParserException {
-      WebmExtractor.this.onMasterElementEnd(id);
-    }
-
-    @Override
-    public void onIntegerElement(int id, long value) throws ParserException {
-      WebmExtractor.this.onIntegerElement(id, value);
-    }
-
-    @Override
-    public void onFloatElement(int id, double value) {
-      WebmExtractor.this.onFloatElement(id, value);
-    }
-
-    @Override
-    public void onStringElement(int id, String value) throws ParserException {
-      WebmExtractor.this.onStringElement(id, value);
-    }
-
-    @Override
-    public boolean onBinaryElement(
-        int id, long elementOffsetBytes, int headerSizeBytes, int contentsSizeBytes,
-        NonBlockingInputStream inputStream) throws ParserException {
-      return WebmExtractor.this.onBinaryElement(
-          id, elementOffsetBytes, headerSizeBytes, contentsSizeBytes, inputStream);
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 2a1d768048..226c1237c3 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -17,10 +17,10 @@
 
 import com.google.android.exoplayer.BehindLiveWindowException;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.Chunk;
+import com.google.android.exoplayer.chunk.ChunkExtractorWrapper;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.ChunkSource;
 import com.google.android.exoplayer.chunk.ContainerMediaChunk;
@@ -28,34 +28,33 @@
 import com.google.android.exoplayer.chunk.Format.DecreasingBandwidthComparator;
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.Evaluation;
+import com.google.android.exoplayer.chunk.InitializationChunk;
 import com.google.android.exoplayer.chunk.MediaChunk;
 import com.google.android.exoplayer.chunk.SingleSampleMediaChunk;
-import com.google.android.exoplayer.chunk.parser.Extractor;
-import com.google.android.exoplayer.chunk.parser.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer.chunk.parser.webm.WebmExtractor;
 import com.google.android.exoplayer.dash.mpd.AdaptationSet;
 import com.google.android.exoplayer.dash.mpd.ContentProtection;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
 import com.google.android.exoplayer.dash.mpd.Period;
 import com.google.android.exoplayer.dash.mpd.RangedUri;
 import com.google.android.exoplayer.dash.mpd.Representation;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ChunkIndex;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
 import com.google.android.exoplayer.text.webvtt.WebvttParser;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
+import com.google.android.exoplayer.util.Clock;
 import com.google.android.exoplayer.util.ManifestFetcher;
 import com.google.android.exoplayer.util.MimeTypes;
-
-import android.net.Uri;
-import android.os.SystemClock;
+import com.google.android.exoplayer.util.SystemClock;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.UUID;
 
 /**
  * An {@link ChunkSource} for DASH streams.
@@ -84,8 +83,10 @@ public NoAdaptationSetException(String message) {
   private final DataSource dataSource;
   private final FormatEvaluator evaluator;
   private final Evaluation evaluation;
+  private final Clock systemClock;
   private final StringBuilder headerBuilder;
   private final long liveEdgeLatencyUs;
+  private final long elapsedRealtimeOffsetUs;
   private final int maxWidth;
   private final int maxHeight;
 
@@ -95,8 +96,8 @@ public NoAdaptationSetException(String message) {
   private final ManifestFetcher<MediaPresentationDescription> manifestFetcher;
   private final int adaptationSetIndex;
   private final int[] representationIndices;
-  private final Map<UUID, byte[]> psshInfo;
 
+  private DrmInitData drmInitData;
   private MediaPresentationDescription currentManifest;
   private boolean finishedCurrentManifest;
 
@@ -140,7 +141,8 @@ public DashChunkSource(DataSource dataSource, FormatEvaluator formatEvaluator,
    */
   public DashChunkSource(MediaPresentationDescription manifest, int adaptationSetIndex,
       int[] representationIndices, DataSource dataSource, FormatEvaluator formatEvaluator) {
-    this(null, manifest, adaptationSetIndex, representationIndices, dataSource, formatEvaluator, 0);
+    this(null, manifest, adaptationSetIndex, representationIndices, dataSource, formatEvaluator,
+        new SystemClock(), 0, 0);
   }
 
   /**
@@ -162,29 +164,35 @@ public DashChunkSource(MediaPresentationDescription manifest, int adaptationSetI
    *     manifest). Choosing a small value will minimize latency introduced by the player, however
    *     note that the value sets an upper bound on the length of media that the player can buffer.
    *     Hence a small value may increase the probability of rebuffering and playback failures.
+   * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
+   *    server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
+   *    as the server's unix time minus the local elapsed time. It unknown, set to 0.
    */
   public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       int adaptationSetIndex, int[] representationIndices, DataSource dataSource,
-      FormatEvaluator formatEvaluator, long liveEdgeLatencyMs) {
+      FormatEvaluator formatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs) {
     this(manifestFetcher, manifestFetcher.getManifest(), adaptationSetIndex, representationIndices,
-        dataSource, formatEvaluator, liveEdgeLatencyMs * 1000);
+        dataSource, formatEvaluator, new SystemClock(), liveEdgeLatencyMs * 1000,
+        elapsedRealtimeOffsetMs * 1000);
   }
 
-  private DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
+  /* package */ DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       MediaPresentationDescription initialManifest, int adaptationSetIndex,
       int[] representationIndices, DataSource dataSource, FormatEvaluator formatEvaluator,
-      long liveEdgeLatencyUs) {
+      Clock systemClock, long liveEdgeLatencyUs, long elapsedRealtimeOffsetUs) {
     this.manifestFetcher = manifestFetcher;
     this.currentManifest = initialManifest;
     this.adaptationSetIndex = adaptationSetIndex;
     this.representationIndices = representationIndices;
     this.dataSource = dataSource;
     this.evaluator = formatEvaluator;
+    this.systemClock = systemClock;
     this.liveEdgeLatencyUs = liveEdgeLatencyUs;
+    this.elapsedRealtimeOffsetUs = elapsedRealtimeOffsetUs;
     this.evaluation = new Evaluation();
     this.headerBuilder = new StringBuilder();
 
-    psshInfo = getPsshInfo(currentManifest, adaptationSetIndex);
+    drmInitData = getDrmInitData(currentManifest, adaptationSetIndex);
     Representation[] representations = getFilteredRepresentations(currentManifest,
         adaptationSetIndex, representationIndices);
     long periodDurationUs = (representations[0].periodDurationMs == TrackRenderer.UNKNOWN_TIME_US)
@@ -202,7 +210,7 @@ private DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFe
       Extractor extractor = mimeTypeIsWebm(formats[i].mimeType) ? new WebmExtractor()
           : new FragmentedMp4Extractor();
       representationHolders.put(formats[i].id,
-          new RepresentationHolder(representations[i], extractor));
+          new RepresentationHolder(representations[i], new ChunkExtractorWrapper(extractor)));
     }
     this.maxWidth = maxWidth;
     this.maxHeight = maxHeight;
@@ -271,7 +279,7 @@ public void continueBuffering(long playbackPositionUs) {
       minUpdatePeriod = 5000;
     }
 
-    if (finishedCurrentManifest && (SystemClock.elapsedRealtime()
+    if (finishedCurrentManifest && (android.os.SystemClock.elapsedRealtime()
         > manifestFetcher.getManifestLoadTimestamp() + minUpdatePeriod)) {
       manifestFetcher.requestRefresh();
     }
@@ -296,7 +304,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       out.chunk = null;
       return;
     } else if (out.queueSize == queue.size() && out.chunk != null
-        && out.chunk.format.id.equals(selectedFormat.id)) {
+        && out.chunk.format.equals(selectedFormat)) {
       // We already have a chunk, and the evaluation hasn't changed either the format or the size
       // of the queue. Leave unchanged.
       return;
@@ -305,12 +313,12 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
     RepresentationHolder representationHolder = representationHolders.get(selectedFormat.id);
     Representation selectedRepresentation = representationHolder.representation;
     DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
-    Extractor extractor = representationHolder.extractor;
+    ChunkExtractorWrapper extractorWrapper = representationHolder.extractorWrapper;
 
     RangedUri pendingInitializationUri = null;
     RangedUri pendingIndexUri = null;
 
-    if (extractor.getFormat() == null) {
+    if (representationHolder.format == null) {
       pendingInitializationUri = selectedRepresentation.getInitializationUri();
     }
     if (segmentIndex == null) {
@@ -320,14 +328,18 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
     if (pendingInitializationUri != null || pendingIndexUri != null) {
       // We have initialization and/or index requests to make.
       Chunk initializationChunk = newInitializationChunk(pendingInitializationUri, pendingIndexUri,
-          selectedRepresentation, extractor, dataSource, evaluation.trigger);
+          selectedRepresentation, extractorWrapper, dataSource, evaluation.trigger);
       lastChunkWasInitialization = true;
       out.chunk = initializationChunk;
       return;
     }
 
-    // TODO: Use UtcTimingElement where possible.
-    long nowUs = System.currentTimeMillis() * 1000;
+    long nowUs;
+    if (elapsedRealtimeOffsetUs != 0) {
+      nowUs = (systemClock.elapsedRealtime() * 1000) + elapsedRealtimeOffsetUs;
+    } else {
+      nowUs = System.currentTimeMillis() * 1000;
+    }
 
     int firstAvailableSegmentNum = segmentIndex.getFirstSegmentNum();
     int lastAvailableSegmentNum = segmentIndex.getLastSegmentNum();
@@ -353,8 +365,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       }
       segmentNum = segmentIndex.getSegmentNum(seekPositionUs);
     } else {
-      segmentNum = queue.get(out.queueSize - 1).nextChunkIndex
-          - representationHolder.segmentNumShift;
+      MediaChunk previous = queue.get(out.queueSize - 1);
+      segmentNum = previous.isLastChunk ? -1
+          : previous.chunkIndex + 1 - representationHolder.segmentNumShift;
     }
 
     if (currentManifest.dynamic) {
@@ -392,46 +405,54 @@ public IOException getError() {
         : (manifestFetcher != null ? manifestFetcher.getError() : null);
   }
 
+  @Override
+  public void onChunkLoadCompleted(Chunk chunk) {
+    if (chunk instanceof InitializationChunk) {
+      InitializationChunk initializationChunk = (InitializationChunk) chunk;
+      String formatId = initializationChunk.format.id;
+      RepresentationHolder representationHolder = representationHolders.get(formatId);
+      if (initializationChunk.hasFormat()) {
+        representationHolder.format = initializationChunk.getFormat();
+      }
+      if (initializationChunk.hasSeekMap()) {
+        representationHolder.segmentIndex = new DashWrappingSegmentIndex(
+            (ChunkIndex) initializationChunk.getSeekMap(),
+            initializationChunk.dataSpec.uri.toString());
+      }
+      // The null check avoids overwriting drmInitData obtained from the manifest with drmInitData
+      // obtained from the stream, as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
+      if (drmInitData == null && initializationChunk.hasDrmInitData()) {
+        drmInitData = initializationChunk.getDrmInitData();
+      }
+    }
+  }
+
   @Override
   public void onChunkLoadError(Chunk chunk, Exception e) {
     // Do nothing.
   }
 
-  private boolean mimeTypeIsWebm(String mimeType) {
+  private static boolean mimeTypeIsWebm(String mimeType) {
     return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
   }
 
   private Chunk newInitializationChunk(RangedUri initializationUri, RangedUri indexUri,
-      Representation representation, Extractor extractor, DataSource dataSource,
+      Representation representation, ChunkExtractorWrapper extractor, DataSource dataSource,
       int trigger) {
-    int expectedExtractorResult = Extractor.RESULT_END_OF_STREAM;
-    long indexAnchor = 0;
     RangedUri requestUri;
     if (initializationUri != null) {
       // It's common for initialization and index data to be stored adjacently. Attempt to merge
       // the two requests together to request both at once.
-      expectedExtractorResult |= Extractor.RESULT_READ_INIT;
       requestUri = initializationUri.attemptMerge(indexUri);
-      if (requestUri != null) {
-        expectedExtractorResult |= Extractor.RESULT_READ_INDEX;
-        if (extractor.hasRelativeIndexOffsets()) {
-          indexAnchor = indexUri.start + indexUri.length;
-        }
-      } else {
+      if (requestUri == null) {
         requestUri = initializationUri;
       }
     } else {
       requestUri = indexUri;
-      if (extractor.hasRelativeIndexOffsets()) {
-        indexAnchor = indexUri.start + indexUri.length;
-      }
-      expectedExtractorResult |= Extractor.RESULT_READ_INDEX;
     }
     DataSpec dataSpec = new DataSpec(requestUri.getUri(), requestUri.start, requestUri.length,
         representation.getCacheKey());
-
-    return new InitializationLoadable(dataSource, dataSpec, trigger, representation.format,
-        extractor, expectedExtractorResult, indexAnchor);
+    return new InitializationChunk(dataSource, dataSpec, trigger, representation.format, extractor);
   }
 
   private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSource dataSource,
@@ -442,10 +463,9 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
     long startTimeUs = segmentIndex.getTimeUs(segmentNum);
     long endTimeUs = startTimeUs + segmentIndex.getDurationUs(segmentNum);
 
+    int absoluteSegmentNum = segmentNum + representationHolder.segmentNumShift;
     boolean isLastSegment = !currentManifest.dynamic
         && segmentNum == segmentIndex.getLastSegmentNum();
-    int nextAbsoluteSegmentNum = isLastSegment ? -1
-        : (representationHolder.segmentNumShift + segmentNum + 1);
 
     RangedUri segmentUri = segmentIndex.getSegmentUrl(segmentNum);
     DataSpec dataSpec = new DataSpec(segmentUri.getUri(), segmentUri.start, segmentUri.length,
@@ -461,12 +481,13 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
         representationHolder.vttHeader = headerBuilder.toString().getBytes();
         representationHolder.vttHeaderOffsetUs = presentationTimeOffsetUs;
       }
-      return new SingleSampleMediaChunk(dataSource, dataSpec, representation.format, 0,
-          startTimeUs, endTimeUs, nextAbsoluteSegmentNum, null, representationHolder.vttHeader);
+      return new SingleSampleMediaChunk(dataSource, dataSpec, Chunk.TRIGGER_INITIAL,
+          representation.format, startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment, null,
+          null, representationHolder.vttHeader);
     } else {
-      return new ContainerMediaChunk(dataSource, dataSpec, representation.format, trigger,
-          startTimeUs, endTimeUs, nextAbsoluteSegmentNum, representationHolder.extractor, psshInfo,
-          false, presentationTimeOffsetUs);
+      return new ContainerMediaChunk(dataSource, dataSpec, trigger, representation.format,
+          startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment, 0,
+          representationHolder.extractorWrapper, representationHolder.format, drmInitData, true);
     }
   }
 
@@ -519,19 +540,24 @@ private long getLiveSeekPosition(long nowUs, boolean indexUnbounded, boolean ind
     }
   }
 
-  private static Map<UUID, byte[]> getPsshInfo(MediaPresentationDescription manifest,
+  private static DrmInitData getDrmInitData(MediaPresentationDescription manifest,
       int adaptationSetIndex) {
     AdaptationSet adaptationSet = manifest.periods.get(0).adaptationSets.get(adaptationSetIndex);
+    String drmInitMimeType = mimeTypeIsWebm(adaptationSet.representations.get(0).format.mimeType)
+        ? MimeTypes.VIDEO_WEBM : MimeTypes.VIDEO_MP4;
     if (adaptationSet.contentProtections.isEmpty()) {
       return null;
     } else {
-      Map<UUID, byte[]> psshInfo = new HashMap<UUID, byte[]>();
+      DrmInitData.Mapped drmInitData = null;
       for (ContentProtection contentProtection : adaptationSet.contentProtections) {
         if (contentProtection.uuid != null && contentProtection.data != null) {
-          psshInfo.put(contentProtection.uuid, contentProtection.data);
+          if (drmInitData == null) {
+            drmInitData = new DrmInitData.Mapped(drmInitMimeType);
+          }
+          drmInitData.put(contentProtection.uuid, contentProtection.data);
         }
       }
-      return psshInfo.isEmpty() ? null : psshInfo;
+      return drmInitData;
     }
   }
 
@@ -545,52 +571,22 @@ private static MediaPresentationDescription buildManifest(List<Representation> r
         Collections.singletonList(period));
   }
 
-  private class InitializationLoadable extends Chunk {
-
-    private final Extractor extractor;
-    private final int expectedExtractorResult;
-    private final long indexAnchor;
-    private final Uri uri;
-
-    public InitializationLoadable(DataSource dataSource, DataSpec dataSpec, int trigger,
-        Format format, Extractor extractor, int expectedExtractorResult,
-        long indexAnchor) {
-      super(dataSource, dataSpec, format, trigger);
-      this.extractor = extractor;
-      this.expectedExtractorResult = expectedExtractorResult;
-      this.indexAnchor = indexAnchor;
-      this.uri = dataSpec.uri;
-    }
-
-    @Override
-    protected void consumeStream(NonBlockingInputStream stream) throws IOException {
-      int result = extractor.read(stream, null);
-      if (result != expectedExtractorResult) {
-        throw new ParserException("Invalid extractor result. Expected "
-            + expectedExtractorResult + ", got " + result);
-      }
-      if ((result & Extractor.RESULT_READ_INDEX) != 0) {
-        representationHolders.get(format.id).segmentIndex =
-            new DashWrappingSegmentIndex(extractor.getIndex(), uri, indexAnchor);
-      }
-    }
-
-  }
-
   private static class RepresentationHolder {
 
     public final Representation representation;
-    public final Extractor extractor;
+    public final ChunkExtractorWrapper extractorWrapper;
 
     public DashSegmentIndex segmentIndex;
-    public int segmentNumShift;
+    public MediaFormat format;
 
+    public int segmentNumShift;
     public long vttHeaderOffsetUs;
     public byte[] vttHeader;
 
-    public RepresentationHolder(Representation representation, Extractor extractor) {
+    public RepresentationHolder(Representation representation,
+        ChunkExtractorWrapper extractorWrapper) {
       this.representation = representation;
-      this.extractor = extractor;
+      this.extractorWrapper = extractorWrapper;
       this.segmentIndex = representation.getIndex();
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
index 44648469af..8856b9e438 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
@@ -15,32 +15,25 @@
  */
 package com.google.android.exoplayer.dash;
 
-import com.google.android.exoplayer.chunk.parser.SegmentIndex;
 import com.google.android.exoplayer.dash.mpd.RangedUri;
-import com.google.android.exoplayer.util.Util;
-
-import android.net.Uri;
+import com.google.android.exoplayer.extractor.ChunkIndex;
 
 /**
- * An implementation of {@link DashSegmentIndex} that wraps a {@link SegmentIndex} parsed from a
+ * An implementation of {@link DashSegmentIndex} that wraps a {@link ChunkIndex} parsed from a
  * media stream.
  */
 public class DashWrappingSegmentIndex implements DashSegmentIndex {
 
-  private final SegmentIndex segmentIndex;
-  private final Uri uri;
-  private final long indexAnchor;
+  private final ChunkIndex chunkIndex;
+  private final String uri;
 
   /**
-   * @param segmentIndex The {@link SegmentIndex} to wrap.
-   * @param uri The {@link Uri} where the data is located.
-   * @param indexAnchor The index anchor point. This value is added to the byte offsets specified
-   *     in the wrapped {@link SegmentIndex}.
+   * @param chunkIndex The {@link ChunkIndex} to wrap.
+   * @param uri The URI where the data is located.
    */
-  public DashWrappingSegmentIndex(SegmentIndex segmentIndex, Uri uri, long indexAnchor) {
-    this.segmentIndex = segmentIndex;
+  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri) {
+    this.chunkIndex = chunkIndex;
     this.uri = uri;
-    this.indexAnchor = indexAnchor;
   }
 
   @Override
@@ -50,28 +43,27 @@ public int getFirstSegmentNum() {
 
   @Override
   public int getLastSegmentNum() {
-    return segmentIndex.length - 1;
+    return chunkIndex.length - 1;
   }
 
   @Override
   public long getTimeUs(int segmentNum) {
-    return segmentIndex.timesUs[segmentNum];
+    return chunkIndex.timesUs[segmentNum];
   }
 
   @Override
   public long getDurationUs(int segmentNum) {
-    return segmentIndex.durationsUs[segmentNum];
+    return chunkIndex.durationsUs[segmentNum];
   }
 
   @Override
   public RangedUri getSegmentUrl(int segmentNum) {
-    return new RangedUri(uri, null, indexAnchor + segmentIndex.offsets[segmentNum],
-        segmentIndex.sizes[segmentNum]);
+    return new RangedUri(uri, null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
   }
 
   @Override
   public int getSegmentNum(long timeUs) {
-    return Util.binarySearchFloor(segmentIndex.timesUs, timeUs, true, true);
+    return chunkIndex.getChunkIndex(timeUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
index d0aec44861..8f02fdc6f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.dash.mpd;
 
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
 import java.util.Arrays;
@@ -46,7 +47,7 @@
    * @param data Protection scheme specific initialization data. May be null.
    */
   public ContentProtection(String schemeUriId, UUID uuid, byte[] data) {
-    this.schemeUriId = schemeUriId;
+    this.schemeUriId = Assertions.checkNotNull(schemeUriId);
     this.uuid = uuid;
     this.data = data;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index 7135b77829..e509ffeefe 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -21,13 +21,15 @@
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTemplate;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTimelineElement;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer.upstream.UriLoadable;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.ManifestParser;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.UriUtil;
 import com.google.android.exoplayer.util.Util;
 
-import android.net.Uri;
 import android.text.TextUtils;
+import android.util.Base64;
 
 import org.xml.sax.helpers.DefaultHandler;
 import org.xmlpull.v1.XmlPullParser;
@@ -41,16 +43,35 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * A parser of media presentation description files.
  */
 public class MediaPresentationDescriptionParser extends DefaultHandler
-    implements ManifestParser<MediaPresentationDescription> {
+    implements UriLoadable.Parser<MediaPresentationDescription> {
 
+  private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))??");
+
+  private final String contentId;
   private final XmlPullParserFactory xmlParserFactory;
 
+  /**
+   * Equivalent to calling {@code new MediaPresentationDescriptionParser(null)}.
+   */
   public MediaPresentationDescriptionParser() {
+    this(null);
+  }
+
+  /**
+   * @param contentId An optional content identifier to include in the parsed manifest.
+   */
+  // TODO: Remove the need to inject a content identifier here, by not including it in the parsed
+  // manifest. Instead, it should be injected directly where needed (i.e. DashChunkSource).
+  public MediaPresentationDescriptionParser(String contentId) {
+    this.contentId = contentId;
     try {
       xmlParserFactory = XmlPullParserFactory.newInstance();
     } catch (XmlPullParserException e) {
@@ -61,17 +82,17 @@ public MediaPresentationDescriptionParser() {
   // MPD parsing.
 
   @Override
-  public MediaPresentationDescription parse(InputStream inputStream, String inputEncoding,
-      String contentId, Uri baseUrl) throws IOException, ParserException {
+  public MediaPresentationDescription parse(String connectionUrl, InputStream inputStream)
+      throws IOException, ParserException {
     try {
       XmlPullParser xpp = xmlParserFactory.newPullParser();
-      xpp.setInput(inputStream, inputEncoding);
+      xpp.setInput(inputStream, null);
       int eventType = xpp.next();
       if (eventType != XmlPullParser.START_TAG || !"MPD".equals(xpp.getName())) {
         throw new ParserException(
             "inputStream does not contain a valid media presentation description");
       }
-      return parseMediaPresentationDescription(xpp, contentId, baseUrl);
+      return parseMediaPresentationDescription(xpp, connectionUrl);
     } catch (XmlPullParserException e) {
       throw new ParserException(e);
     } catch (ParseException e) {
@@ -80,7 +101,7 @@ public MediaPresentationDescription parse(InputStream inputStream, String inputE
   }
 
   protected MediaPresentationDescription parseMediaPresentationDescription(XmlPullParser xpp,
-      String contentId, Uri baseUrl) throws XmlPullParserException, IOException, ParseException {
+      String baseUrl) throws XmlPullParserException, IOException, ParseException {
     long availabilityStartTime = parseDateTime(xpp, "availabilityStartTime", -1);
     long durationMs = parseDuration(xpp, "mediaPresentationDuration", -1);
     long minBufferTimeMs = parseDuration(xpp, "minBufferTime", -1);
@@ -99,7 +120,7 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
       } else if (isStartTag(xpp, "UTCTiming")) {
         utcTiming = parseUtcTiming(xpp);
       } else if (isStartTag(xpp, "Period")) {
-        periods.add(parsePeriod(xpp, contentId, baseUrl, durationMs));
+        periods.add(parsePeriod(xpp, baseUrl, durationMs));
       }
     } while (!isEndTag(xpp, "MPD"));
 
@@ -125,7 +146,7 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
     return new UtcTimingElement(schemeIdUri, value);
   }
 
-  protected Period parsePeriod(XmlPullParser xpp, String contentId, Uri baseUrl, long mpdDurationMs)
+  protected Period parsePeriod(XmlPullParser xpp, String baseUrl, long mpdDurationMs)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     long startMs = parseDuration(xpp, "start", 0);
@@ -137,7 +158,7 @@ protected Period parsePeriod(XmlPullParser xpp, String contentId, Uri baseUrl, l
       if (isStartTag(xpp, "BaseURL")) {
         baseUrl = parseBaseUrl(xpp, baseUrl);
       } else if (isStartTag(xpp, "AdaptationSet")) {
-        adaptationSets.add(parseAdaptationSet(xpp, contentId, baseUrl, startMs, durationMs,
+        adaptationSets.add(parseAdaptationSet(xpp, baseUrl, startMs, durationMs,
             segmentBase));
       } else if (isStartTag(xpp, "SegmentBase")) {
         segmentBase = parseSegmentBase(xpp, baseUrl, null);
@@ -158,9 +179,8 @@ protected Period buildPeriod(
 
   // AdaptationSet parsing.
 
-  protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String contentId, Uri baseUrl,
-      long periodStartMs, long periodDurationMs, SegmentBase segmentBase)
-      throws XmlPullParserException, IOException {
+  protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl, long periodStartMs,
+      long periodDurationMs, SegmentBase segmentBase) throws XmlPullParserException, IOException {
 
     String mimeType = xpp.getAttributeValue(null, "mimeType");
     String language = xpp.getAttributeValue(null, "lang");
@@ -180,7 +200,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String contentId,
         contentType = checkAdaptationSetTypeConsistency(contentType,
             parseAdaptationSetType(xpp.getAttributeValue(null, "contentType")));
       } else if (isStartTag(xpp, "Representation")) {
-        Representation representation = parseRepresentation(xpp, contentId, baseUrl, periodStartMs,
+        Representation representation = parseRepresentation(xpp, baseUrl, periodStartMs,
             periodDurationMs, mimeType, language, segmentBase, contentProtectionsBuilder);
         contentProtectionsBuilder.endRepresentation();
         contentType = checkAdaptationSetTypeConsistency(contentType,
@@ -253,11 +273,27 @@ private int checkAdaptationSetTypeConsistency(int firstType, int secondType) {
   protected ContentProtection parseContentProtection(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
-    return buildContentProtection(schemeIdUri);
+    UUID uuid = null;
+    byte[] data = null;
+    do {
+      xpp.next();
+      // The cenc:pssh element is defined in 23001-7:2015
+      if (isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
+        byte[] decodedData = Base64.decode(xpp.getText(), Base64.DEFAULT);
+        ParsableByteArray psshAtom = new ParsableByteArray(decodedData);
+        psshAtom.skipBytes(12);
+        uuid = new UUID(psshAtom.readLong(), psshAtom.readLong());
+        int dataSize = psshAtom.readInt();
+        data = new byte[dataSize];
+        psshAtom.readBytes(data, 0, dataSize);
+      }
+    } while (!isEndTag(xpp, "ContentProtection"));
+
+    return buildContentProtection(schemeIdUri, uuid, data);
   }
 
-  protected ContentProtection buildContentProtection(String schemeIdUri) {
-    return new ContentProtection(schemeIdUri, null, null);
+  protected ContentProtection buildContentProtection(String schemeIdUri, UUID uuid, byte[] data) {
+    return new ContentProtection(schemeIdUri, uuid, data);
   }
 
   /**
@@ -274,7 +310,7 @@ protected void parseAdaptationSetChild(XmlPullParser xpp)
 
   // Representation parsing.
 
-  protected Representation parseRepresentation(XmlPullParser xpp, String contentId, Uri baseUrl,
+  protected Representation parseRepresentation(XmlPullParser xpp, String baseUrl,
       long periodStartMs, long periodDurationMs, String mimeType, String language,
       SegmentBase segmentBase, ContentProtectionsBuilder contentProtectionsBuilder)
       throws XmlPullParserException, IOException {
@@ -283,6 +319,22 @@ protected Representation parseRepresentation(XmlPullParser xpp, String contentId
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate");
     int width = parseInt(xpp, "width");
     int height = parseInt(xpp, "height");
+
+    float frameRate = -1;
+    String frameRateAttribute = xpp.getAttributeValue(null, "frameRate");
+    if (frameRateAttribute != null) {
+      Matcher frameRateMatcher = FRAME_RATE_PATTERN.matcher(frameRateAttribute);
+      if (frameRateMatcher.matches()) {
+        int numerator = Integer.parseInt(frameRateMatcher.group(1));
+        String denominatorString = frameRateMatcher.group(2);
+        if (!TextUtils.isEmpty(denominatorString)) {
+          frameRate = (float) numerator / Integer.parseInt(denominatorString);
+        } else {
+          frameRate = numerator;
+        }
+      }
+    }
+
     mimeType = parseString(xpp, "mimeType", mimeType);
     String codecs = parseString(xpp, "codecs", null);
 
@@ -305,16 +357,16 @@ protected Representation parseRepresentation(XmlPullParser xpp, String contentId
       }
     } while (!isEndTag(xpp, "Representation"));
 
-    Format format = buildFormat(id, mimeType, width, height, numChannels, audioSamplingRate,
-        bandwidth, language, codecs);
+    Format format = buildFormat(id, mimeType, width, height, frameRate, numChannels,
+        audioSamplingRate, bandwidth, language, codecs);
     return buildRepresentation(periodStartMs, periodDurationMs, contentId, -1, format,
         segmentBase != null ? segmentBase : new SingleSegmentBase(baseUrl));
   }
 
-  protected Format buildFormat(String id, String mimeType, int width, int height, int numChannels,
-      int audioSamplingRate, int bandwidth, String language, String codecs) {
-    return new Format(id, mimeType, width, height, numChannels, audioSamplingRate, bandwidth,
-        language, codecs);
+  protected Format buildFormat(String id, String mimeType, int width, int height, float frameRate,
+      int numChannels, int audioSamplingRate, int bandwidth, String language, String codecs) {
+    return new Format(id, mimeType, width, height, frameRate, numChannels, audioSamplingRate,
+        bandwidth, language, codecs);
   }
 
   protected Representation buildRepresentation(long periodStartMs, long periodDurationMs,
@@ -325,7 +377,7 @@ protected Representation buildRepresentation(long periodStartMs, long periodDura
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
 
-  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, Uri baseUrl,
+  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, String baseUrl,
       SingleSegmentBase parent) throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
@@ -354,12 +406,12 @@ protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, Uri baseUrl,
   }
 
   protected SingleSegmentBase buildSingleSegmentBase(RangedUri initialization, long timescale,
-      long presentationTimeOffset, Uri baseUrl, long indexStart, long indexLength) {
+      long presentationTimeOffset, String baseUrl, long indexStart, long indexLength) {
     return new SingleSegmentBase(initialization, timescale, presentationTimeOffset, baseUrl,
         indexStart, indexLength);
   }
 
-  protected SegmentList parseSegmentList(XmlPullParser xpp, Uri baseUrl, SegmentList parent,
+  protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, SegmentList parent,
       long periodDurationMs) throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
@@ -403,7 +455,7 @@ protected SegmentList buildSegmentList(RangedUri initialization, long timescale,
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, Uri baseUrl,
+  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl,
       SegmentTemplate parent, long periodDurationMs) throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
@@ -440,7 +492,7 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, Uri baseUrl,
   protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long timescale,
       long presentationTimeOffset, long periodDurationMs, int startNumber, long duration,
       List<SegmentTimelineElement> timeline, UrlTemplate initializationTemplate,
-      UrlTemplate mediaTemplate, Uri baseUrl) {
+      UrlTemplate mediaTemplate, String baseUrl) {
     return new SegmentTemplate(initialization, timescale, presentationTimeOffset, periodDurationMs,
         startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
   }
@@ -477,15 +529,15 @@ protected UrlTemplate parseUrlTemplate(XmlPullParser xpp, String name,
     return defaultValue;
   }
 
-  protected RangedUri parseInitialization(XmlPullParser xpp, Uri baseUrl) {
+  protected RangedUri parseInitialization(XmlPullParser xpp, String baseUrl) {
     return parseRangedUrl(xpp, baseUrl, "sourceURL", "range");
   }
 
-  protected RangedUri parseSegmentUrl(XmlPullParser xpp, Uri baseUrl) {
+  protected RangedUri parseSegmentUrl(XmlPullParser xpp, String baseUrl) {
     return parseRangedUrl(xpp, baseUrl, "media", "mediaRange");
   }
 
-  protected RangedUri parseRangedUrl(XmlPullParser xpp, Uri baseUrl, String urlAttribute,
+  protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String urlAttribute,
       String rangeAttribute) {
     String urlText = xpp.getAttributeValue(null, urlAttribute);
     long rangeStart = 0;
@@ -499,7 +551,7 @@ protected RangedUri parseRangedUrl(XmlPullParser xpp, Uri baseUrl, String urlAtt
     return buildRangedUri(baseUrl, urlText, rangeStart, rangeLength);
   }
 
-  protected RangedUri buildRangedUri(Uri baseUrl, String urlText, long rangeStart,
+  protected RangedUri buildRangedUri(String baseUrl, String urlText, long rangeStart,
       long rangeLength) {
     return new RangedUri(baseUrl, urlText, rangeStart, rangeLength);
   }
@@ -538,15 +590,10 @@ protected static long parseDateTime(XmlPullParser xpp, String name, long default
     }
   }
 
-  protected static Uri parseBaseUrl(XmlPullParser xpp, Uri parentBaseUrl)
+  protected static String parseBaseUrl(XmlPullParser xpp, String parentBaseUrl)
       throws XmlPullParserException, IOException {
     xpp.next();
-    String newBaseUrlText = xpp.getText();
-    Uri newBaseUri = Uri.parse(newBaseUrlText);
-    if (!newBaseUri.isAbsolute()) {
-      newBaseUri = Uri.withAppendedPath(parentBaseUrl, newBaseUrlText);
-    }
-    return newBaseUri;
+    return UriUtil.resolve(parentBaseUrl, xpp.getText());
   }
 
   protected static int parseInt(XmlPullParser xpp, String name) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
index 2ce5ad3092..22a8bfdee5 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/RangedUri.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer.dash.mpd;
 
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.Util;
+import com.google.android.exoplayer.util.UriUtil;
 
 import android.net.Uri;
 
@@ -35,31 +35,28 @@
    */
   public final long length;
 
-  // The {@link Uri} is stored internally in two parts, {@link #baseUri} and {@link uriString}.
-  // This helps optimize memory usage in the same way that DASH manifests allow many URLs to be
-  // expressed concisely in the form of a single BaseURL and many relative paths. Note that this
-  // optimization relies on the same {@code Uri} being passed as the {@link #baseUri} to many
+  // The URI is stored internally in two parts: reference URI and a base URI to use when
+  // resolving it. This helps optimize memory usage in the same way that DASH manifests allow many
+  // URLs to be expressed concisely in the form of a single BaseURL and many relative paths. Note
+  // that this optimization relies on the same object being passed as the base URI to many
   // instances of this class.
-  private final Uri baseUri;
-  private final String stringUri;
+  private final String baseUri;
+  private final String referenceUri;
 
   private int hashCode;
 
   /**
    * Constructs an ranged uri.
-   * <p>
-   * See {@link Util#getMergedUri(Uri, String)} for a description of how {@code baseUri} and
-   * {@code stringUri} are merged.
    *
    * @param baseUri A uri that can form the base of the uri defined by the instance.
-   * @param stringUri A relative or absolute uri in string form.
+   * @param referenceUri A reference uri that should be resolved with respect to {@code baseUri}.
    * @param start The (zero based) index of the first byte of the range.
    * @param length The length of the range, or -1 to indicate that the range is unbounded.
    */
-  public RangedUri(Uri baseUri, String stringUri, long start, long length) {
-    Assertions.checkArgument(baseUri != null || stringUri != null);
+  public RangedUri(String baseUri, String referenceUri, long start, long length) {
+    Assertions.checkArgument(baseUri != null || referenceUri != null);
     this.baseUri = baseUri;
-    this.stringUri = stringUri;
+    this.referenceUri = referenceUri;
     this.start = start;
     this.length = length;
   }
@@ -70,7 +67,16 @@ public RangedUri(Uri baseUri, String stringUri, long start, long length) {
    * @return The {@link Uri} represented by the instance.
    */
   public Uri getUri() {
-    return Util.getMergedUri(baseUri, stringUri);
+    return UriUtil.resolveToUri(baseUri, referenceUri);
+  }
+
+  /**
+   * Returns the uri represented by the instance as a string.
+   *
+   * @return The uri represented by the instance.
+   */
+  public String getUriString() {
+    return UriUtil.resolve(baseUri, referenceUri);
   }
 
   /**
@@ -85,13 +91,13 @@ public Uri getUri() {
    * @return The merged {@link RangedUri} if the merge was successful. Null otherwise.
    */
   public RangedUri attemptMerge(RangedUri other) {
-    if (other == null || !getUri().equals(other.getUri())) {
+    if (other == null || !getUriString().equals(other.getUriString())) {
       return null;
     } else if (length != -1 && start + length == other.start) {
-      return new RangedUri(baseUri, stringUri, start,
+      return new RangedUri(baseUri, referenceUri, start,
           other.length == -1 ? -1 : length + other.length);
     } else if (other.length != -1 && other.start + other.length == start) {
-      return new RangedUri(baseUri, stringUri, other.start,
+      return new RangedUri(baseUri, referenceUri, other.start,
           length == -1 ? -1 : other.length + length);
     } else {
       return null;
@@ -104,7 +110,7 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (int) start;
       result = 31 * result + (int) length;
-      result = 31 * result + getUri().hashCode();
+      result = 31 * result + getUriString().hashCode();
       hashCode = result;
     }
     return hashCode;
@@ -121,7 +127,7 @@ public boolean equals(Object obj) {
     RangedUri other = (RangedUri) obj;
     return this.start == other.start
         && this.length == other.length
-        && getUri().equals(other.getUri());
+        && getUriString().equals(other.getUriString());
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index afae71de23..d63dd77f14 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.dash.mpd;
 
 import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.chunk.FormatWrapper;
 import com.google.android.exoplayer.dash.DashSegmentIndex;
 import com.google.android.exoplayer.dash.DashSingleSegmentIndex;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.MultiSegmentBase;
@@ -26,7 +27,7 @@
 /**
  * A DASH representation.
  */
-public abstract class Representation {
+public abstract class Representation implements FormatWrapper {
 
   /**
    * Identifies the piece of content to which this {@link Representation} belongs.
@@ -105,6 +106,11 @@ private Representation(long periodStartMs, long periodDurationMs, String content
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
 
+  @Override
+  public Format getFormat() {
+    return format;
+  }
+
   /**
    * Gets a {@link RangedUri} defining the location of the representation's initialization data.
    * May be null if no initialization data exists.
@@ -147,7 +153,7 @@ public String getCacheKey() {
   public static class SingleSegmentRepresentation extends Representation {
 
     /**
-     * The {@link Uri} of the single segment.
+     * The uri of the single segment.
      */
     public final Uri uri;
 
@@ -174,7 +180,7 @@ public String getCacheKey() {
      * @param contentLength The content length, or -1 if unknown.
      */
     public static SingleSegmentRepresentation newInstance(long periodStartMs, long periodDurationMs,
-        String contentId, long revisionId, Format format, Uri uri, long initializationStart,
+        String contentId, long revisionId, Format format, String uri, long initializationStart,
         long initializationEnd, long indexStart, long indexEnd, long contentLength) {
       RangedUri rangedUri = new RangedUri(uri, null, initializationStart,
           initializationEnd - initializationStart + 1);
@@ -197,13 +203,13 @@ public static SingleSegmentRepresentation newInstance(long periodStartMs, long p
     public SingleSegmentRepresentation(long periodStartMs, long periodDurationMs, String contentId,
         long revisionId, Format format, SingleSegmentBase segmentBase, long contentLength) {
       super(periodStartMs, periodDurationMs, contentId, revisionId, format, segmentBase);
-      this.uri = segmentBase.uri;
+      this.uri = Uri.parse(segmentBase.uri);
       this.indexUri = segmentBase.getIndex();
       this.contentLength = contentLength;
       // If we have an index uri then the index is defined externally, and we shouldn't return one
       // directly. If we don't, then we can't do better than an index defining a single segment.
       segmentIndex = indexUri != null ? null : new DashSingleSegmentIndex(periodStartMs * 1000,
-          periodDurationMs * 1000, new RangedUri(uri, null, 0, -1));
+          periodDurationMs * 1000, new RangedUri(segmentBase.uri, null, 0, -1));
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
index f93ce33743..6d55a01393 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/SegmentBase.java
@@ -19,8 +19,6 @@
 import com.google.android.exoplayer.dash.DashSegmentIndex;
 import com.google.android.exoplayer.util.Util;
 
-import android.net.Uri;
-
 import java.util.List;
 
 /**
@@ -73,7 +71,7 @@ public long getPresentationTimeOffsetUs() {
     /**
      * The uri of the segment.
      */
-    public final Uri uri;
+    public final String uri;
 
     /* package */ final long indexStart;
     /* package */ final long indexLength;
@@ -89,7 +87,7 @@ public long getPresentationTimeOffsetUs() {
      * @param indexLength The length of the index data in bytes.
      */
     public SingleSegmentBase(RangedUri initialization, long timescale, long presentationTimeOffset,
-        Uri uri, long indexStart, long indexLength) {
+        String uri, long indexStart, long indexLength) {
       super(initialization, timescale, presentationTimeOffset);
       this.uri = uri;
       this.indexStart = indexStart;
@@ -99,7 +97,7 @@ public SingleSegmentBase(RangedUri initialization, long timescale, long presenta
     /**
      * @param uri The uri of the segment.
      */
-    public SingleSegmentBase(Uri uri) {
+    public SingleSegmentBase(String uri) {
       this(null, 1, 0, uri, 0, -1);
     }
 
@@ -148,7 +146,8 @@ public MultiSegmentBase(RangedUri initialization, long timescale, long presentat
      * @see DashSegmentIndex#getSegmentNum(long)
      */
     public int getSegmentNum(long timeUs) {
-      int lowIndex = getFirstSegmentNum();
+      final int firstSegmentNum = getFirstSegmentNum();
+      int lowIndex = firstSegmentNum;
       int highIndex = getLastSegmentNum();
       if (segmentTimeline == null) {
         // All segments are of equal duration (with the possible exception of the last one).
@@ -171,7 +170,7 @@ public int getSegmentNum(long timeUs) {
             return midIndex;
           }
         }
-        return lowIndex - 1;
+        return lowIndex == firstSegmentNum ? lowIndex : highIndex;
       }
     }
 
@@ -288,7 +287,7 @@ public boolean isExplicit() {
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
 
-    private final Uri baseUrl;
+    private final String baseUrl;
 
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
@@ -314,7 +313,7 @@ public boolean isExplicit() {
     public SegmentTemplate(RangedUri initialization, long timescale, long presentationTimeOffset,
         long periodDurationMs, int startNumber, long duration,
         List<SegmentTimelineElement> segmentTimeline, UrlTemplate initializationTemplate,
-        UrlTemplate mediaTemplate, Uri baseUrl) {
+        UrlTemplate mediaTemplate, String baseUrl) {
       super(initialization, timescale, presentationTimeOffset, periodDurationMs, startNumber,
           duration, segmentTimeline);
       this.initializationTemplate = initializationTemplate;
@@ -354,7 +353,7 @@ public int getLastSegmentNum() {
         return DashSegmentIndex.INDEX_UNBOUNDED;
       } else {
         long durationMs = (duration * 1000) / timescale;
-        return startNumber + (int) ((periodDurationMs + durationMs - 1) / durationMs) - 1;
+        return startNumber + (int) Util.ceilDivide(periodDurationMs, durationMs) - 1;
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
index cbcc30de7e..e2f452b543 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
@@ -28,4 +28,9 @@ public UtcTimingElement(String schemeIdUri, String value) {
     this.value = value;
   }
 
+  @Override
+  public String toString() {
+    return schemeIdUri + ", " + value;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
new file mode 100644
index 0000000000..c530bafe84
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash.mpd;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.upstream.Loader;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+import com.google.android.exoplayer.upstream.UriDataSource;
+import com.google.android.exoplayer.upstream.UriLoadable;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import android.os.SystemClock;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.CancellationException;
+
+/**
+ * Resolves a {@link UtcTimingElement}.
+ */
+public class UtcTimingElementResolver implements Loader.Callback {
+
+  /**
+   * Callback for timing element resolution.
+   */
+  public interface UtcTimingCallback {
+
+    /**
+     * Invoked when the element has been resolved.
+     *
+     * @param utcTiming The element that was resolved.
+     * @param elapsedRealtimeOffset The offset between the resolved UTC time and
+     *     {@link SystemClock#elapsedRealtime()} in milliseconds, specified as the UTC time minus
+     *     the local elapsed time.
+     */
+    void onTimestampResolved(UtcTimingElement utcTiming, long elapsedRealtimeOffset);
+
+    /**
+     * Invoked when the element was not successfully resolved.
+     *
+     * @param utcTiming The element that was not resolved.
+     * @param e The cause of the failure.
+     */
+    void onTimestampError(UtcTimingElement utcTiming, IOException e);
+  }
+
+  private final UriDataSource uriDataSource;
+  private final UtcTimingElement timingElement;
+  private final long timingElementElapsedRealtime;
+  private final UtcTimingCallback callback;
+
+  private Loader singleUseLoader;
+  private UriLoadable<Long> singleUseLoadable;
+
+  /**
+   * Resolves a {@link UtcTimingElement}.
+   *
+   * @param uriDataSource A source to use should loading from a URI be necessary.
+   * @param timingElement The element to resolve.
+   * @param timingElementElapsedRealtime The {@link SystemClock#elapsedRealtime()} timestamp at
+   *     which the element was obtained. Used if the element contains a timestamp directly.
+   * @param callback The callback to invoke on resolution or failure.
+   */
+  public static void resolveTimingElement(UriDataSource uriDataSource,
+      UtcTimingElement timingElement, long timingElementElapsedRealtime,
+      UtcTimingCallback callback) {
+    UtcTimingElementResolver resolver = new UtcTimingElementResolver(uriDataSource, timingElement,
+        timingElementElapsedRealtime, callback);
+    resolver.resolve();
+  }
+
+  private UtcTimingElementResolver(UriDataSource uriDataSource, UtcTimingElement timingElement,
+      long timingElementElapsedRealtime, UtcTimingCallback callback) {
+    this.uriDataSource = uriDataSource;
+    this.timingElement = Assertions.checkNotNull(timingElement);
+    this.timingElementElapsedRealtime = timingElementElapsedRealtime;
+    this.callback = Assertions.checkNotNull(callback);
+  }
+
+  private void resolve() {
+    String scheme = timingElement.schemeIdUri;
+    if (Util.areEqual(scheme, "urn:mpeg:dash:utc:direct:2012")) {
+      resolveDirect();
+    } else if (Util.areEqual(scheme, "urn:mpeg:dash:utc:http-iso:2014")) {
+      resolveHttp(new Iso8601Parser());
+    } else if (Util.areEqual(scheme, "urn:mpeg:dash:utc:http-xsdate:2012")
+        || Util.areEqual(scheme, "urn:mpeg:dash:utc:http-xsdate:2014")) {
+      resolveHttp(new XsDateTimeParser());
+    } else {
+      // Unsupported scheme.
+      callback.onTimestampError(timingElement, new IOException("Unsupported utc timing scheme"));
+    }
+  }
+
+  private void resolveDirect() {
+    try {
+      long utcTimestamp = Util.parseXsDateTime(timingElement.value);
+      long elapsedRealtimeOffset = utcTimestamp - timingElementElapsedRealtime;
+      callback.onTimestampResolved(timingElement, elapsedRealtimeOffset);
+    } catch (ParseException e) {
+      callback.onTimestampError(timingElement, new ParserException(e));
+    }
+  }
+
+  private void resolveHttp(UriLoadable.Parser<Long> parser) {
+    singleUseLoader = new Loader("utctiming");
+    singleUseLoadable = new UriLoadable<Long>(timingElement.value, uriDataSource, parser);
+    singleUseLoader.startLoading(singleUseLoadable, this);
+  }
+
+  @Override
+  public void onLoadCanceled(Loadable loadable) {
+    onLoadError(loadable, new IOException("Load cancelled", new CancellationException()));
+  }
+
+  @Override
+  public void onLoadCompleted(Loadable loadable) {
+    releaseLoader();
+    long elapsedRealtimeOffset = singleUseLoadable.getResult() - SystemClock.elapsedRealtime();
+    callback.onTimestampResolved(timingElement, elapsedRealtimeOffset);
+  }
+
+  @Override
+  public void onLoadError(Loadable loadable, IOException exception) {
+    releaseLoader();
+    callback.onTimestampError(timingElement, exception);
+  }
+
+  private void releaseLoader() {
+    singleUseLoader.release();
+  }
+
+  private static class XsDateTimeParser implements UriLoadable.Parser<Long> {
+
+    @Override
+    public Long parse(String connectionUrl, InputStream inputStream) throws ParserException,
+        IOException {
+      String firstLine = new BufferedReader(new InputStreamReader(inputStream)).readLine();
+      try {
+        return Util.parseXsDateTime(firstLine);
+      } catch (ParseException e) {
+        throw new ParserException(e);
+      }
+    }
+
+  }
+
+  private static class Iso8601Parser implements UriLoadable.Parser<Long> {
+
+    @Override
+    public Long parse(String connectionUrl, InputStream inputStream) throws ParserException,
+        IOException {
+      String firstLine = new BufferedReader(new InputStreamReader(inputStream)).readLine();
+      try {
+        // TODO: It may be necessary to handle timestamp offsets from UTC.
+        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
+        format.setTimeZone(TimeZone.getTimeZone("UTC"));
+        return format.parse(firstLine).getTime();
+      } catch (ParseException e) {
+        throw new ParserException(e);
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
new file mode 100644
index 0000000000..ae862d0bc9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.drm;
+
+import android.media.MediaDrm;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * Encapsulates initialization data required by a {@link MediaDrm} instance.
+ */
+public abstract class DrmInitData {
+
+  /**
+   * The container mime type.
+   */
+  public final String mimeType;
+
+  public DrmInitData(String mimeType) {
+    this.mimeType = mimeType;
+  }
+
+  /**
+   * Retrieves initialization data for a given DRM scheme, specified by its UUID.
+   *
+   * @param schemeUuid The DRM scheme's UUID.
+   * @return The initialization data for the scheme, or null if the scheme is not supported.
+   */
+  public abstract byte[] get(UUID schemeUuid);
+
+  /**
+   * A {@link DrmInitData} implementation that maps UUID onto scheme specific data.
+   */
+  public static final class Mapped extends DrmInitData {
+
+    private final Map<UUID, byte[]> schemeData;
+
+    public Mapped(String mimeType) {
+      super(mimeType);
+      schemeData = new HashMap<UUID, byte[]>();
+    }
+
+    @Override
+    public byte[] get(UUID schemeUuid) {
+      return schemeData.get(schemeUuid);
+    }
+
+    /**
+     * Inserts scheme specific initialization data.
+     *
+     * @param schemeUuid The scheme UUID.
+     * @param data The corresponding initialization data.
+     */
+    public void put(UUID schemeUuid, byte[] data) {
+      schemeData.put(schemeUuid, data);
+    }
+
+    /**
+     * Inserts scheme specific initialization data.
+     *
+     * @param data A mapping from scheme UUID to initialization data.
+     */
+    public void putAll(Map<UUID, byte[]> data) {
+      schemeData.putAll(data);
+    }
+
+  }
+
+  /**
+   * A {@link DrmInitData} implementation that returns the same initialization data for all schemes.
+   */
+  public static final class Universal extends DrmInitData {
+
+    private byte[] data;
+
+    public Universal(String mimeType, byte[] data) {
+      super(mimeType);
+      this.data = data;
+    }
+
+    @Override
+    public byte[] get(UUID schemeUuid) {
+      return data;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/DrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer/drm/DrmSessionManager.java
index 3bdfae9d12..a5e78ab008 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/DrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/DrmSessionManager.java
@@ -18,9 +18,6 @@
 import android.annotation.TargetApi;
 import android.media.MediaCrypto;
 
-import java.util.Map;
-import java.util.UUID;
-
 /**
  * Manages a DRM session.
  */
@@ -36,7 +33,7 @@
    */
   public static final int STATE_CLOSED = 1;
   /**
-   * The session is being opened (i.e. {@link #open(Map, String)} has been called, but the session
+   * The session is being opened (i.e. {@link #open(DrmInitData)} has been called, but the session
    * is not yet open).
    */
   public static final int STATE_OPENING = 2;
@@ -52,11 +49,9 @@
   /**
    * Opens the session, possibly asynchronously.
    *
-   * @param drmInitData Initialization data for the drm schemes supported by the media, keyed by
-   *     scheme UUID.
-   * @param mimeType The mimeType of the media.
+   * @param drmInitData DRM initialization data.
    */
-  void open(Map<UUID, byte[]> drmInitData, String mimeType);
+  void open(DrmInitData drmInitData);
 
   /**
    * Closes the session.
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/KeysExpiredException.java b/library/src/main/java/com/google/android/exoplayer/drm/KeysExpiredException.java
new file mode 100644
index 0000000000..75945a7ec1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/drm/KeysExpiredException.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.drm;
+
+/**
+ * Thrown when the drm keys loaded into an open session expire.
+ */
+public final class KeysExpiredException extends Exception {
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
index 866c5f96ef..2855678b5f 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
@@ -29,9 +29,9 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
+import android.text.TextUtils;
 
 import java.util.HashMap;
-import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -56,6 +56,24 @@
 
   }
 
+  /**
+   * UUID for the Widevine DRM scheme.
+   */
+  public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+
+  /**
+   * UUID for the PlayReady DRM scheme.
+   * <p>
+   * Note that PlayReady is unsupported by most Android devices, with the exception of Android TV
+   * devices, which do provide support.
+   */
+  public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
+
+  /**
+   * The key to use when passing CustomData to a PlayReady instance in an optional parameter map.
+   */
+  public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
+
   private static final int MSG_PROVISION = 0;
   private static final int MSG_KEYS = 1;
 
@@ -82,12 +100,52 @@
   private byte[] sessionId;
 
   /**
-   * @deprecated Use the other constructor, passing null as {@code optionalKeyRequestParameters}.
+   * Instantiates a new instance using the Widevine scheme.
+   *
+   * @param playbackLooper The looper associated with the media playback thread. Should usually be
+   *     obtained using {@link com.google.android.exoplayer.ExoPlayer#getPlaybackLooper()}.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @throws UnsupportedSchemeException If the specified DRM scheme is not supported.
    */
-  @Deprecated
-  public StreamingDrmSessionManager(UUID uuid, Looper playbackLooper, MediaDrmCallback callback,
+  public static StreamingDrmSessionManager newWidevineInstance(Looper playbackLooper,
+      MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedSchemeException {
-    this(uuid, playbackLooper, callback, null, eventHandler, eventListener);
+    return new StreamingDrmSessionManager(WIDEVINE_UUID, playbackLooper, callback,
+        optionalKeyRequestParameters, eventHandler, eventListener);
+  }
+
+  /**
+   * Instantiates a new instance using the PlayReady scheme.
+   * <p>
+   * Note that PlayReady is unsupported by most Android devices, with the exception of Android TV
+   * devices, which do provide support.
+   *
+   * @param playbackLooper The looper associated with the media playback thread. Should usually be
+   *     obtained using {@link com.google.android.exoplayer.ExoPlayer#getPlaybackLooper()}.
+   * @param callback Performs key and provisioning requests.
+   * @param customData Optional custom data to include in requests generated by the instance.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @throws UnsupportedSchemeException If the specified DRM scheme is not supported.
+   */
+  public static StreamingDrmSessionManager newPlayReadyInstance(Looper playbackLooper,
+      MediaDrmCallback callback, String customData, Handler eventHandler,
+      EventListener eventListener) throws UnsupportedSchemeException {
+    HashMap<String, String> optionalKeyRequestParameters;
+    if (!TextUtils.isEmpty(customData)) {
+      optionalKeyRequestParameters = new HashMap<String, String>();
+      optionalKeyRequestParameters.put(PLAYREADY_CUSTOM_DATA_KEY, customData);
+    } else {
+      optionalKeyRequestParameters = null;
+    }
+    return new StreamingDrmSessionManager(PLAYREADY_UUID, playbackLooper, callback,
+        optionalKeyRequestParameters, eventHandler, eventListener);
   }
 
   /**
@@ -168,7 +226,7 @@ public final String getPropertyString(String key) {
   }
 
   @Override
-  public void open(Map<UUID, byte[]> psshData, String mimeType) {
+  public void open(DrmInitData drmInitData) {
     if (++openCount != 1) {
       return;
     }
@@ -178,8 +236,8 @@ public void open(Map<UUID, byte[]> psshData, String mimeType) {
       postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
     }
     if (this.schemePsshData == null) {
-      this.mimeType = mimeType;
-      schemePsshData = psshData.get(uuid);
+      mimeType = drmInitData.mimeType;
+      schemePsshData = drmInitData.get(uuid);
       if (schemePsshData == null) {
         onError(new IllegalStateException("Media does not support uuid: " + uuid));
         return;
@@ -332,7 +390,7 @@ public void handleMessage(Message msg) {
           return;
         case MediaDrm.EVENT_KEY_EXPIRED:
           state = STATE_OPENED;
-          postKeyRequest();
+          onError(new KeysExpiredException());
           return;
         case MediaDrm.EVENT_PROVISION_REQUIRED:
           state = STATE_OPENED;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ChunkIndex.java b/library/src/main/java/com/google/android/exoplayer/extractor/ChunkIndex.java
new file mode 100644
index 0000000000..a54b71f7f4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ChunkIndex.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.util.Util;
+
+/**
+ * Defines chunks of samples within a media stream.
+ */
+public final class ChunkIndex implements SeekMap {
+
+  /**
+   * The number of chunks.
+   */
+  public final int length;
+
+  /**
+   * The chunk sizes, in bytes.
+   */
+  public final int[] sizes;
+
+  /**
+   * The chunk byte offsets.
+   */
+  public final long[] offsets;
+
+  /**
+   * The chunk durations, in microseconds.
+   */
+  public final long[] durationsUs;
+
+  /**
+   * The start time of each chunk, in microseconds.
+   */
+  public final long[] timesUs;
+
+  /**
+   * @param sizes The chunk sizes, in bytes.
+   * @param offsets The chunk byte offsets.
+   * @param durationsUs The chunk durations, in microseconds.
+   * @param timesUs The start time of each chunk, in microseconds.
+   */
+  public ChunkIndex(int[] sizes, long[] offsets, long[] durationsUs, long[] timesUs) {
+    this.length = sizes.length;
+    this.sizes = sizes;
+    this.offsets = offsets;
+    this.durationsUs = durationsUs;
+    this.timesUs = timesUs;
+  }
+
+  /**
+   * Obtains the index of the chunk corresponding to a given time.
+   *
+   * @param timeUs The time, in microseconds.
+   * @return The index of the corresponding chunk.
+   */
+  public int getChunkIndex(long timeUs) {
+    return Util.binarySearchFloor(timesUs, timeUs, true, true);
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return offsets[getChunkIndex(timeUs)];
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
new file mode 100644
index 0000000000..0fb9008afc
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.DataSource;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * An {@link ExtractorInput} that wraps a {@link DataSource}.
+ */
+public final class DefaultExtractorInput implements ExtractorInput {
+
+  private static final byte[] SCRATCH_SPACE = new byte[4096];
+
+  private final DataSource dataSource;
+
+  private long position;
+  private long length;
+
+  /**
+   * @param dataSource The wrapped {@link DataSource}.
+   * @param position The initial position in the stream.
+   * @param length The length of the stream, or {@link C#LENGTH_UNBOUNDED} if it is unknown.
+   */
+  public DefaultExtractorInput(DataSource dataSource, long position, long length) {
+    this.dataSource = dataSource;
+    this.position = position;
+    this.length = length;
+  }
+
+  @Override
+  public int read(byte[] target, int offset, int length) throws IOException, InterruptedException {
+    if (Thread.interrupted()) {
+      throw new InterruptedException();
+    }
+    int bytesRead = dataSource.read(target, offset, length);
+    if (bytesRead == C.RESULT_END_OF_INPUT) {
+      return C.RESULT_END_OF_INPUT;
+    }
+    position += bytesRead;
+    return bytesRead;
+  }
+
+  @Override
+  public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    int remaining = length;
+    while (remaining > 0) {
+      if (Thread.interrupted()) {
+        throw new InterruptedException();
+      }
+      int bytesRead = dataSource.read(target, offset, remaining);
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        if (allowEndOfInput && remaining == length) {
+          return false;
+        }
+        throw new EOFException();
+      }
+      offset += bytesRead;
+      remaining -= bytesRead;
+    }
+    position += length;
+    return true;
+  }
+
+  @Override
+  public void readFully(byte[] target, int offset, int length)
+      throws IOException, InterruptedException {
+    readFully(target, offset, length, false);
+  }
+
+  @Override
+  public void skipFully(int length) throws IOException, InterruptedException {
+    int remaining = length;
+    while (remaining > 0) {
+      if (Thread.interrupted()) {
+        throw new InterruptedException();
+      }
+      int bytesRead = dataSource.read(SCRATCH_SPACE, 0, Math.min(SCRATCH_SPACE.length, remaining));
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        throw new EOFException();
+      }
+      remaining -= bytesRead;
+    }
+    position += length;
+  }
+
+  @Override
+  public long getPosition() {
+    return position;
+  }
+
+  @Override
+  public long getLength() {
+    return length;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
similarity index 57%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
index 348a2cd843..330f320d22 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/SampleQueue.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
@@ -13,20 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor;
 
-import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import java.io.IOException;
+
 /**
- * Wraps a {@link RollingSampleBuffer}, adding higher level functionality such as enforcing that
- * the first sample returned from the queue is a keyframe, allowing splicing to another queue, and
- * so on.
+ * A {@link TrackOutput} that buffers extracted samples in a queue, and allows for consumption from
+ * that queue.
  */
-/* package */ abstract class SampleQueue {
+public class DefaultTrackOutput implements TrackOutput {
 
   private final RollingSampleBuffer rollingBuffer;
   private final SampleHolder sampleInfoHolder;
@@ -36,15 +37,15 @@
   private long lastReadTimeUs;
   private long spliceOutTimeUs;
 
-  // Accessed only by the loading thread.
-  private boolean writingSample;
-
   // Accessed by both the loading and consuming threads.
-  private volatile MediaFormat mediaFormat;
   private volatile long largestParsedTimestampUs;
+  private volatile MediaFormat format;
 
-  protected SampleQueue(BufferPool bufferPool) {
-    rollingBuffer = new RollingSampleBuffer(bufferPool);
+  /**
+   * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
+   */
+  public DefaultTrackOutput(Allocator allocator) {
+    rollingBuffer = new RollingSampleBuffer(allocator);
     sampleInfoHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DISABLED);
     needKeyframe = true;
     lastReadTimeUs = Long.MIN_VALUE;
@@ -52,24 +53,71 @@ protected SampleQueue(BufferPool bufferPool) {
     largestParsedTimestampUs = Long.MIN_VALUE;
   }
 
-  public void release() {
-    rollingBuffer.release();
+  // Called by the consuming thread, but only when there is no loading thread.
+
+  /**
+   * Clears the queue, returning all allocations to the allocator.
+   */
+  public void clear() {
+    rollingBuffer.clear();
+    needKeyframe = true;
+    lastReadTimeUs = Long.MIN_VALUE;
+    spliceOutTimeUs = Long.MIN_VALUE;
+    largestParsedTimestampUs = Long.MIN_VALUE;
+  }
+
+  /**
+   * Returns the current absolute write index.
+   */
+  public int getWriteIndex() {
+    return rollingBuffer.getWriteIndex();
+  }
+
+  /**
+   * Discards samples from the write side of the queue.
+   *
+   * @param discardFromIndex The absolute index of the first sample to be discarded.
+   */
+  public void discardUpstreamSamples(int discardFromIndex) {
+    rollingBuffer.discardUpstreamSamples(discardFromIndex);
+    largestParsedTimestampUs = rollingBuffer.peekSample(sampleInfoHolder) ? sampleInfoHolder.timeUs
+        : Long.MIN_VALUE;
   }
 
   // Called by the consuming thread.
 
-  public long getLargestParsedTimestampUs() {
-    return largestParsedTimestampUs;
+  /**
+   * Returns the current absolute read index.
+   */
+  public int getReadIndex() {
+    return rollingBuffer.getReadIndex();
   }
 
-  public boolean hasMediaFormat() {
-    return mediaFormat != null;
+  /**
+   * True if the output has received a format. False otherwise.
+   */
+  public boolean hasFormat() {
+    return format != null;
   }
 
-  public MediaFormat getMediaFormat() {
-    return mediaFormat;
+  /**
+   * The format most recently received by the output, or null if a format has yet to be received.
+   */
+  public MediaFormat getFormat() {
+    return format;
+  }
+
+  /**
+   * The largest timestamp of any sample received by the output, or {@link Long#MIN_VALUE} if a
+   * sample has yet to be received.
+   */
+  public long getLargestParsedTimestampUs() {
+    return largestParsedTimestampUs;
   }
 
+  /**
+   * True if at least one sample can be read from the queue. False otherwise.
+   */
   public boolean isEmpty() {
     return !advanceToEligibleSample();
   }
@@ -109,13 +157,23 @@ public void discardUntil(long timeUs) {
     lastReadTimeUs = Long.MIN_VALUE;
   }
 
+  /**
+   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+   *
+   * @param timeUs The seek time.
+   * @return True if the skip was successful. False otherwise.
+   */
+  public boolean skipToKeyframeBefore(long timeUs) {
+    return rollingBuffer.skipToKeyframeBefore(timeUs);
+  }
+
   /**
    * Attempts to configure a splice from this queue to the next.
    *
    * @param nextQueue The queue being spliced to.
    * @return Whether the splice was configured successfully.
    */
-  public boolean configureSpliceTo(SampleQueue nextQueue) {
+  public boolean configureSpliceTo(DefaultTrackOutput nextQueue) {
     if (spliceOutTimeUs != Long.MIN_VALUE) {
       // We've already configured the splice.
       return true;
@@ -128,8 +186,7 @@ public boolean configureSpliceTo(SampleQueue nextQueue) {
     }
     RollingSampleBuffer nextRollingBuffer = nextQueue.rollingBuffer;
     while (nextRollingBuffer.peekSample(sampleInfoHolder)
-        && (sampleInfoHolder.timeUs < firstPossibleSpliceTime
-            || (sampleInfoHolder.flags & C.SAMPLE_FLAG_SYNC) == 0)) {
+        && (sampleInfoHolder.timeUs < firstPossibleSpliceTime || !sampleInfoHolder.isSyncFrame())) {
       // Discard samples from the next queue for as long as they are before the earliest possible
       // splice time, or not keyframes.
       nextRollingBuffer.skipSample();
@@ -152,7 +209,7 @@ public boolean configureSpliceTo(SampleQueue nextQueue) {
   private boolean advanceToEligibleSample() {
     boolean haveNext = rollingBuffer.peekSample(sampleInfoHolder);
     if (needKeyframe) {
-      while (haveNext && (sampleInfoHolder.flags & C.SAMPLE_FLAG_SYNC) == 0) {
+      while (haveNext && !sampleInfoHolder.isSyncFrame()) {
         rollingBuffer.skipSample();
         haveNext = rollingBuffer.peekSample(sampleInfoHolder);
       }
@@ -168,35 +225,32 @@ private boolean advanceToEligibleSample() {
 
   // Called by the loading thread.
 
-  protected boolean writingSample() {
-    return writingSample;
+  public int sampleData(DataSource dataSource, int length) throws IOException {
+    return rollingBuffer.appendData(dataSource, length);
   }
 
-  protected void setMediaFormat(MediaFormat mediaFormat) {
-    this.mediaFormat = mediaFormat;
-  }
+  // TrackOutput implementation. Called by the loading thread.
 
-  protected void startSample(long sampleTimeUs) {
-    startSample(sampleTimeUs, 0);
+  @Override
+  public void format(MediaFormat format) {
+    this.format = format;
   }
 
-  protected void startSample(long sampleTimeUs, int offset) {
-    writingSample = true;
-    largestParsedTimestampUs = Math.max(largestParsedTimestampUs, sampleTimeUs);
-    rollingBuffer.startSample(sampleTimeUs, offset);
+  @Override
+  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
+    return rollingBuffer.appendData(input, length);
   }
 
-  protected void appendData(ParsableByteArray buffer, int length) {
+  @Override
+  public void sampleData(ParsableByteArray buffer, int length) {
     rollingBuffer.appendData(buffer, length);
   }
 
-  protected void commitSample(boolean isKeyframe) {
-    commitSample(isKeyframe, 0);
-  }
-
-  protected void commitSample(boolean isKeyframe, int offset) {
-    rollingBuffer.commitSample(isKeyframe, offset);
-    writingSample = false;
+  @Override
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    largestParsedTimestampUs = Math.max(largestParsedTimestampUs, timeUs);
+    rollingBuffer.commitSample(timeUs, flags, rollingBuffer.getWritePosition() - size - offset,
+        size, encryptionKey);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
new file mode 100644
index 0000000000..c38a62a688
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+
+import java.io.IOException;
+
+/**
+ * Facilitates extraction of data from a container format.
+ */
+public interface Extractor {
+
+  /**
+   * Returned by {@link #read(ExtractorInput, PositionHolder)} if the {@link ExtractorInput} passed
+   * to the next {@link #read(ExtractorInput, PositionHolder)} is required to provide data
+   * continuing from the position in the stream reached by the returning call.
+   */
+  public static final int RESULT_CONTINUE = 0;
+  /**
+   * Returned by {@link #read(ExtractorInput, PositionHolder)} if the {@link ExtractorInput} passed
+   * to the next {@link #read(ExtractorInput, PositionHolder)} is required to provide data starting
+   * from a specified position in the stream.
+   */
+  public static final int RESULT_SEEK = 1;
+  /**
+   * Returned by {@link #read(ExtractorInput, PositionHolder)} if the end of the
+   * {@link ExtractorInput} was reached. Equal to {@link C#RESULT_END_OF_INPUT}.
+   */
+  public static final int RESULT_END_OF_INPUT = C.RESULT_END_OF_INPUT;
+
+  /**
+   * Initializes the extractor with an {@link ExtractorOutput}.
+   *
+   * @param output An {@link ExtractorOutput} to receive extracted data.
+   */
+  void init(ExtractorOutput output);
+
+  /**
+   * Extracts data read from a provided {@link ExtractorInput}.
+   * <p>
+   * Each read will extract at most one sample from the stream before returning.
+   * <p>
+   * In the common case, {@link #RESULT_CONTINUE} is returned to indicate that
+   * {@link ExtractorInput} passed to the next read is required to provide data continuing from the
+   * position in the stream reached by the returning call. If the extractor requires data to be
+   * provided from a different position, then that position is set in {@code seekPosition} and
+   * {@link #RESULT_SEEK} is returned. If the extractor reached the end of the data provided by the
+   * {@link ExtractorInput}, then {@link #RESULT_END_OF_INPUT} is returned.
+   *
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @param seekPosition If {@link #RESULT_SEEK} is returned, this holder is updated to hold the
+   *     position of the required data.
+   * @return One of the {@code RESULT_} values defined in this interface.
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException;
+
+  /**
+   * Notifies the extractor that a seek has occurred.
+   * <p>
+   * Following a call to this method, the {@link ExtractorInput} passed to the next invocation of
+   * {@link #read(ExtractorInput, PositionHolder)} is required to provide data starting from any
+   * random access position in the stream. Random access positions can be obtained from a
+   * {@link SeekMap} that has been extracted and passed to the {@link ExtractorOutput}.
+   */
+  void seek();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
new file mode 100644
index 0000000000..63c09aab3d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * Provides data to be consumed by an {@link Extractor}.
+ */
+public interface ExtractorInput {
+
+  /**
+   * Reads up to {@code length} bytes from the input.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the input is
+   * detected, or an exception is thrown.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The maximum number of bytes to read from the input.
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the input has ended.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  int read(byte[] target, int offset, int length) throws IOException, InterruptedException;
+
+  /**
+   * Like {@link #read(byte[], int, int)}, but reads the requested {@code length} in full.
+   * <p>
+   * If the end of the input is found having read no data, then behavior is dependent on
+   * {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is returned.
+   * Otherwise an {@link EOFException} is thrown.
+   * <p>
+   * Encountering the end of input having partially satisfied the read is always considered an
+   * error, and will result in an {@link EOFException} being thrown.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The number of bytes to read from the input.
+   * @param allowEndOfInput True if encountering the end of the input having read no data is
+   *     allowed, and should result in {@code false} being returned. False if it should be
+   *     considered an error, causing an {@link EOFException} to be thrown.
+   * @return True if the read was successful. False if the end of the input was encountered having
+   *     read no data.
+   * @throws EOFException If the end of input was encountered having partially satisfied the read
+   *     (i.e. having read at least one byte, but fewer than {@code length}), or if no bytes were
+   *     read and {@code allowEndOfInput} is false.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException;
+
+  /**
+   * Equivalent to {@code readFully(target, offset, length, false)}.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The number of bytes to read from the input.
+   * @throws EOFException If the end of input was encountered.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void readFully(byte[] target, int offset, int length) throws IOException, InterruptedException;
+
+  /**
+   * Like {@link #readFully(byte[], int, int)}, except the data is skipped instead of read.
+   * <p>
+   * Encountering the end of input is always considered an error, and will result in an
+   * {@link EOFException} being thrown.
+   *
+   * @param length The number of bytes to skip from the input.
+   * @throws EOFException If the end of input was encountered.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void skipFully(int length) throws IOException, InterruptedException;
+
+  /**
+   * The current position (byte offset) in the stream.
+   *
+   * @return The position (byte offset) in the stream.
+   */
+  long getPosition();
+
+  /**
+   * Returns the length of the source stream, or {@link C#LENGTH_UNBOUNDED} if it is unknown.
+   *
+   * @return The length of the source stream, or {@link C#LENGTH_UNBOUNDED}.
+   */
+  long getLength();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java
new file mode 100644
index 0000000000..683d8d6ea9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.drm.DrmInitData;
+
+/**
+ * Receives stream level data extracted by an {@link Extractor}.
+ */
+public interface ExtractorOutput {
+
+  /**
+   * Invoked when the {@link Extractor} identifies the existence of a track in the stream.
+   * <p>
+   * Returns a {@link TrackOutput} that will receive track level data belonging to the track.
+   *
+   * @param trackId A track identifier.
+   * @return The {@link TrackOutput} that should receive track level data belonging to the track.
+   */
+  TrackOutput track(int trackId);
+
+  /**
+   * Invoked when all tracks have been identified, meaning that {@link #track(int)} will not be
+   * invoked again.
+   */
+  void endTracks();
+
+  /**
+   * Invoked when a {@link SeekMap} has been extracted from the stream.
+   *
+   * @param seekMap The extracted {@link SeekMap}.
+   */
+  void seekMap(SeekMap seekMap);
+
+  /**
+   * Invoked when {@link DrmInitData} has been extracted from the stream.
+   *
+   * @param drmInitData The extracted {@link DrmInitData}.
+   */
+  void drmInitData(DrmInitData drmInitData);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
new file mode 100644
index 0000000000..b84401eb76
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -0,0 +1,631 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackInfo;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.Loader;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.net.Uri;
+import android.os.SystemClock;
+import android.util.SparseArray;
+
+import java.io.IOException;
+
+/**
+ * A {@link SampleSource} that extracts sample data using an {@link Extractor}
+ */
+public class ExtractorSampleSource implements SampleSource, ExtractorOutput, Loader.Callback {
+
+  /**
+   * The default minimum number of times to retry loading prior to failing for on-demand streams.
+   */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND = 3;
+
+  /**
+   * The default minimum number of times to retry loading prior to failing for live streams.
+   */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE = 6;
+
+  private static final int BUFFER_FRAGMENT_LENGTH = 256 * 1024;
+  private static final int MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA = -1;
+  private static final int NO_RESET_PENDING = -1;
+
+  private final Extractor extractor;
+  private final DefaultAllocator allocator;
+  private final int requestedBufferSize;
+  private final SparseArray<InternalTrackOutput> sampleQueues;
+  private final int minLoadableRetryCount;
+  private final boolean frameAccurateSeeking;
+  private final Uri uri;
+  private final DataSource dataSource;
+
+  private volatile boolean tracksBuilt;
+  private volatile SeekMap seekMap;
+  private volatile DrmInitData drmInitData;
+
+  private boolean prepared;
+  private int enabledTrackCount;
+  private TrackInfo[] trackInfos;
+  private long maxTrackDurationUs;
+  private boolean[] pendingMediaFormat;
+  private boolean[] pendingDiscontinuities;
+  private boolean[] trackEnabledStates;
+
+  private int remainingReleaseCount;
+  private long downstreamPositionUs;
+  private long lastSeekPositionUs;
+  private long pendingResetPositionUs;
+
+  private boolean havePendingNextSampleUs;
+  private long pendingNextSampleUs;
+  private long sampleTimeOffsetUs;
+
+  private Loader loader;
+  private ExtractingLoadable loadable;
+  private IOException currentLoadableException;
+  private boolean currentLoadableExceptionFatal;
+  // TODO: Set this back to 0 in the correct place (some place indicative of making progress).
+  private int currentLoadableExceptionCount;
+  private long currentLoadableExceptionTimestamp;
+  private boolean loadingFinished;
+
+  private int extractedSampleCount;
+  private int extractedSampleCountAtStartOfLoad;
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param extractor An {@link Extractor} to extract the media stream.
+   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   */
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
+      int downstreamRendererCount, int requestedBufferSize) {
+    this(uri, dataSource, extractor, downstreamRendererCount, requestedBufferSize,
+        MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param extractor An {@link Extractor} to extract the media stream.
+   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param minLoadableRetryCount The minimum number of times that the sample source will retry
+   *     if a loading error occurs.
+   */
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
+      int downstreamRendererCount, int requestedBufferSize, int minLoadableRetryCount) {
+    this.uri = uri;
+    this.dataSource = dataSource;
+    this.extractor = extractor;
+    this.remainingReleaseCount = downstreamRendererCount;
+    this.requestedBufferSize = requestedBufferSize;
+    this.minLoadableRetryCount = minLoadableRetryCount;
+    sampleQueues = new SparseArray<InternalTrackOutput>();
+    allocator = new DefaultAllocator(BUFFER_FRAGMENT_LENGTH);
+    pendingResetPositionUs = NO_RESET_PENDING;
+    frameAccurateSeeking = true;
+    extractor.init(this);
+  }
+
+  @Override
+  public boolean prepare(long positionUs) throws IOException {
+    if (prepared) {
+      return true;
+    }
+    if (loader == null) {
+      loader = new Loader("Loader:ExtractorSampleSource");
+    }
+
+    continueBufferingInternal();
+
+    // TODO: Support non-seekable content? Or at least avoid getting stuck here if a seekMap doesn't
+    // arrive (we may end up filling the sample buffers whilst we're still not prepared, and then
+    // getting stuck).
+    if (seekMap != null && tracksBuilt && haveFormatsForAllTracks()) {
+      int trackCount = sampleQueues.size();
+      trackEnabledStates = new boolean[trackCount];
+      pendingDiscontinuities = new boolean[trackCount];
+      pendingMediaFormat = new boolean[trackCount];
+      trackInfos = new TrackInfo[trackCount];
+      maxTrackDurationUs = C.UNKNOWN_TIME_US;
+      for (int i = 0; i < trackCount; i++) {
+        MediaFormat format = sampleQueues.valueAt(i).getFormat();
+        trackInfos[i] = new TrackInfo(format.mimeType, format.durationUs);
+        if (format.durationUs != C.UNKNOWN_TIME_US && format.durationUs > maxTrackDurationUs) {
+          maxTrackDurationUs = format.durationUs;
+        }
+      }
+      prepared = true;
+      return true;
+    } else {
+      maybeThrowLoadableException();
+      return false;
+    }
+  }
+
+  @Override
+  public int getTrackCount() {
+    return sampleQueues.size();
+  }
+
+  @Override
+  public TrackInfo getTrackInfo(int track) {
+    Assertions.checkState(prepared);
+    return trackInfos[track];
+  }
+
+  @Override
+  public void enable(int track, long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(!trackEnabledStates[track]);
+    enabledTrackCount++;
+    trackEnabledStates[track] = true;
+    pendingMediaFormat[track] = true;
+    if (enabledTrackCount == 1) {
+      seekToUs(positionUs);
+    }
+  }
+
+  @Override
+  public void disable(int track) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(trackEnabledStates[track]);
+    enabledTrackCount--;
+    trackEnabledStates[track] = false;
+    pendingDiscontinuities[track] = false;
+    if (enabledTrackCount == 0) {
+      if (loader.isLoading()) {
+        loader.cancelLoading();
+      } else {
+        clearState();
+        allocator.trim(0);
+      }
+    }
+  }
+
+  @Override
+  public boolean continueBuffering(long playbackPositionUs) throws IOException {
+    Assertions.checkState(prepared);
+    Assertions.checkState(enabledTrackCount > 0);
+    downstreamPositionUs = playbackPositionUs;
+    discardSamplesForDisabledTracks(downstreamPositionUs);
+    return loadingFinished || continueBufferingInternal();
+  }
+
+  @Override
+  public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+    downstreamPositionUs = playbackPositionUs;
+
+    if (pendingDiscontinuities[track]) {
+      pendingDiscontinuities[track] = false;
+      return DISCONTINUITY_READ;
+    }
+
+    if (onlyReadDiscontinuity || isPendingReset()) {
+      maybeThrowLoadableException();
+      return NOTHING_READ;
+    }
+
+    InternalTrackOutput sampleQueue = sampleQueues.valueAt(track);
+    if (pendingMediaFormat[track]) {
+      formatHolder.format = sampleQueue.getFormat();
+      formatHolder.drmInitData = drmInitData;
+      pendingMediaFormat[track] = false;
+      return FORMAT_READ;
+    }
+
+    if (sampleQueue.getSample(sampleHolder)) {
+      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
+      if (havePendingNextSampleUs) {
+        // Set the offset to make the timestamp of this sample equal to pendingNextSampleUs.
+        sampleTimeOffsetUs = pendingNextSampleUs - sampleHolder.timeUs;
+        havePendingNextSampleUs = false;
+      }
+      sampleHolder.timeUs += sampleTimeOffsetUs;
+      return SAMPLE_READ;
+    }
+
+    if (loadingFinished) {
+      return END_OF_STREAM;
+    }
+
+    maybeThrowLoadableException();
+    return NOTHING_READ;
+  }
+
+  @Override
+  public void seekToUs(long positionUs) {
+    Assertions.checkState(prepared);
+    Assertions.checkState(enabledTrackCount > 0);
+    if (!seekMap.isSeekable()) {
+      // Treat all seeks into non-seekable media as seeks to the start.
+      positionUs = 0;
+    }
+
+    lastSeekPositionUs = positionUs;
+    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
+      return;
+    }
+
+    downstreamPositionUs = positionUs;
+
+    // If we're not pending a reset, see if we can seek within the sample queues.
+    boolean seekInsideBuffer = !isPendingReset();
+    for (int i = 0; seekInsideBuffer && i < sampleQueues.size(); i++) {
+      seekInsideBuffer &= sampleQueues.valueAt(i).skipToKeyframeBefore(positionUs);
+    }
+
+    // If we failed to seek within the sample queues, we need to restart.
+    if (!seekInsideBuffer) {
+      restartFrom(positionUs);
+    }
+
+    // Either way, we need to send discontinuities to the downstream components.
+    for (int i = 0; i < pendingDiscontinuities.length; i++) {
+      pendingDiscontinuities[i] = true;
+    }
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    if (loadingFinished) {
+      return TrackRenderer.END_OF_TRACK_US;
+    } else if (isPendingReset()) {
+      return pendingResetPositionUs;
+    } else {
+      long largestParsedTimestampUs = Long.MIN_VALUE;
+      for (int i = 0; i < sampleQueues.size(); i++) {
+        largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
+            sampleQueues.valueAt(i).getLargestParsedTimestampUs());
+      }
+      return largestParsedTimestampUs == Long.MIN_VALUE ? downstreamPositionUs
+          : largestParsedTimestampUs;
+    }
+  }
+
+  @Override
+  public void release() {
+    Assertions.checkState(remainingReleaseCount > 0);
+    if (--remainingReleaseCount == 0 && loader != null) {
+      loader.release();
+      loader = null;
+    }
+  }
+
+  // Loader.Callback implementation.
+
+  @Override
+  public void onLoadCompleted(Loadable loadable) {
+    loadingFinished = true;
+  }
+
+  @Override
+  public void onLoadCanceled(Loadable loadable) {
+    if (enabledTrackCount > 0) {
+      restartFrom(pendingResetPositionUs);
+    } else {
+      clearState();
+      allocator.trim(0);
+    }
+  }
+
+  @Override
+  public void onLoadError(Loadable ignored, IOException e) {
+    currentLoadableException = e;
+    currentLoadableExceptionCount = extractedSampleCount > extractedSampleCountAtStartOfLoad ? 1
+        : currentLoadableExceptionCount + 1;
+    currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    maybeStartLoading();
+  }
+
+  // ExtractorOutput implementation.
+
+  @Override
+  public TrackOutput track(int id) {
+    InternalTrackOutput sampleQueue = sampleQueues.get(id);
+    if (sampleQueue == null) {
+      sampleQueue = new InternalTrackOutput(allocator);
+      sampleQueues.put(id, sampleQueue);
+    }
+    return sampleQueue;
+  }
+
+  @Override
+  public void endTracks() {
+    tracksBuilt = true;
+  }
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    this.seekMap = seekMap;
+  }
+
+  @Override
+  public void drmInitData(DrmInitData drmInitData) {
+    this.drmInitData = drmInitData;
+  }
+
+  // Internal stuff.
+
+  private boolean continueBufferingInternal() throws IOException {
+    maybeStartLoading();
+    if (isPendingReset()) {
+      return false;
+    }
+    boolean haveSamples = prepared && haveSampleForOneEnabledTrack();
+    if (!haveSamples) {
+      maybeThrowLoadableException();
+    }
+    return haveSamples;
+  }
+
+  private void restartFrom(long positionUs) {
+    pendingResetPositionUs = positionUs;
+    loadingFinished = false;
+    if (loader.isLoading()) {
+      loader.cancelLoading();
+    } else {
+      clearState();
+      maybeStartLoading();
+    }
+  }
+
+  private void maybeStartLoading() {
+    if (currentLoadableExceptionFatal || loadingFinished || loader.isLoading()) {
+      return;
+    }
+
+    if (currentLoadableException != null) {
+      Assertions.checkState(loadable != null);
+      long elapsedMillis = SystemClock.elapsedRealtime() - currentLoadableExceptionTimestamp;
+      if (elapsedMillis >= getRetryDelayMillis(currentLoadableExceptionCount)) {
+        currentLoadableException = null;
+        if (!prepared) {
+          // We don't know whether we're playing an on-demand or a live stream. For a live stream
+          // we need to load from the start, as outlined below. Since we might be playing a live
+          // stream, play it safe and load from the start.
+          for (int i = 0; i < sampleQueues.size(); i++) {
+            sampleQueues.valueAt(i).clear();
+          }
+          loadable = createLoadableFromStart();
+        } else if (!seekMap.isSeekable()) {
+          // We're playing a non-seekable stream. Assume it's live, and therefore that the data at
+          // the uri is a continuously shifting window of the latest available media. For this case
+          // there's no way to continue loading from where a previous load finished, and hence it's
+          // necessary to load from the start whenever commencing a new load.
+          for (int i = 0; i < sampleQueues.size(); i++) {
+            sampleQueues.valueAt(i).clear();
+          }
+          loadable = createLoadableFromStart();
+          // To avoid introducing a discontinuity, we shift the sample timestamps so that they will
+          // continue from the current downstream position.
+          pendingNextSampleUs = downstreamPositionUs;
+          havePendingNextSampleUs = true;
+        } else {
+          // We're playing a seekable on-demand stream. Resume the current loadable, which will
+          // request data starting from the point it left off.
+        }
+        extractedSampleCountAtStartOfLoad = extractedSampleCount;
+        loader.startLoading(loadable, this);
+      }
+      return;
+    }
+
+    // We're not retrying, so we're either starting a playback or responding to an explicit seek.
+    // In both cases sampleTimeOffsetUs should be reset to zero, and any pending adjustment to
+    // sample timestamps should be discarded.
+    sampleTimeOffsetUs = 0;
+    havePendingNextSampleUs = false;
+
+    if (!prepared) {
+      loadable = createLoadableFromStart();
+    } else {
+      Assertions.checkState(isPendingReset());
+      if (maxTrackDurationUs != C.UNKNOWN_TIME_US && pendingResetPositionUs >= maxTrackDurationUs) {
+        loadingFinished = true;
+        pendingResetPositionUs = NO_RESET_PENDING;
+        return;
+      }
+      loadable = createLoadableFromPositionUs(pendingResetPositionUs);
+      pendingResetPositionUs = NO_RESET_PENDING;
+    }
+    extractedSampleCountAtStartOfLoad = extractedSampleCount;
+    loader.startLoading(loadable, this);
+  }
+
+  private void maybeThrowLoadableException() throws IOException {
+    if (currentLoadableException == null) {
+      return;
+    }
+    if (currentLoadableExceptionFatal) {
+      throw currentLoadableException;
+    }
+    int minLoadableRetryCountForMedia;
+    if (minLoadableRetryCount != MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
+      minLoadableRetryCountForMedia = minLoadableRetryCount;
+    } else {
+      minLoadableRetryCountForMedia = seekMap != null && !seekMap.isSeekable()
+          ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE
+          : DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND;
+    }
+    if (currentLoadableExceptionCount > minLoadableRetryCountForMedia) {
+      throw currentLoadableException;
+    }
+  }
+
+  private ExtractingLoadable createLoadableFromStart() {
+    return new ExtractingLoadable(uri, dataSource, extractor, allocator, requestedBufferSize, 0);
+  }
+
+  private ExtractingLoadable createLoadableFromPositionUs(long positionUs) {
+    return new ExtractingLoadable(uri, dataSource, extractor, allocator, requestedBufferSize,
+        seekMap.getPosition(positionUs));
+  }
+
+  private boolean haveFormatsForAllTracks() {
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      if (!sampleQueues.valueAt(i).hasFormat()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private boolean haveSampleForOneEnabledTrack() {
+    for (int i = 0; i < trackEnabledStates.length; i++) {
+      if (trackEnabledStates[i] && !sampleQueues.valueAt(i).isEmpty()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private void discardSamplesForDisabledTracks(long timeUs) {
+    for (int i = 0; i < trackEnabledStates.length; i++) {
+      if (!trackEnabledStates[i]) {
+        sampleQueues.valueAt(i).discardUntil(timeUs);
+      }
+    }
+  }
+
+  private void clearState() {
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      sampleQueues.valueAt(i).clear();
+    }
+    loadable = null;
+    currentLoadableException = null;
+    currentLoadableExceptionCount = 0;
+    currentLoadableExceptionFatal = false;
+  }
+
+  private boolean isPendingReset() {
+    return pendingResetPositionUs != NO_RESET_PENDING;
+  }
+
+  private long getRetryDelayMillis(long errorCount) {
+    return Math.min((errorCount - 1) * 1000, 5000);
+  }
+
+  /**
+   * Extension of {@link DefaultTrackOutput} that increments a shared counter of the total number
+   * of extracted samples.
+   */
+  private class InternalTrackOutput extends DefaultTrackOutput {
+
+    public InternalTrackOutput(Allocator allocator) {
+      super(allocator);
+    }
+
+    @Override
+    public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+      super.sampleMetadata(timeUs, flags, size, offset, encryptionKey);
+      extractedSampleCount++;
+    }
+
+  }
+
+  /**
+   * Loads the media stream and extracts sample data from it.
+   */
+  private static class ExtractingLoadable implements Loadable {
+
+    private final Uri uri;
+    private final DataSource dataSource;
+    private final Extractor extractor;
+    private final DefaultAllocator allocator;
+    private final int requestedBufferSize;
+    private final PositionHolder positionHolder;
+
+    private volatile boolean loadCanceled;
+
+    private boolean pendingExtractorSeek;
+
+    public ExtractingLoadable(Uri uri, DataSource dataSource, Extractor extractor,
+        DefaultAllocator allocator, int requestedBufferSize, long position) {
+      this.uri = Assertions.checkNotNull(uri);
+      this.dataSource = Assertions.checkNotNull(dataSource);
+      this.extractor = Assertions.checkNotNull(extractor);
+      this.allocator = Assertions.checkNotNull(allocator);
+      this.requestedBufferSize = requestedBufferSize;
+      positionHolder = new PositionHolder();
+      positionHolder.position = position;
+      pendingExtractorSeek = true;
+    }
+
+    @Override
+    public void cancelLoad() {
+      loadCanceled = true;
+    }
+
+    @Override
+    public boolean isLoadCanceled() {
+      return loadCanceled;
+    }
+
+    @Override
+    public void load() throws IOException, InterruptedException {
+      if (pendingExtractorSeek) {
+        extractor.seek();
+        pendingExtractorSeek = false;
+      }
+      int result = Extractor.RESULT_CONTINUE;
+      while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+        ExtractorInput input = null;
+        try {
+          long position = positionHolder.position;
+          long length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNBOUNDED, null));
+          if (length != C.LENGTH_UNBOUNDED) {
+            length += position;
+          }
+          input = new DefaultExtractorInput(dataSource, position, length);
+          while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+            allocator.blockWhileTotalBytesAllocatedExceeds(requestedBufferSize);
+            result = extractor.read(input, positionHolder);
+            // TODO: Implement throttling to stop us from buffering data too often.
+          }
+        } finally {
+          if (result == Extractor.RESULT_SEEK) {
+            result = Extractor.RESULT_CONTINUE;
+          } else if (input != null) {
+            positionHolder.position = input.getPosition();
+          }
+          dataSource.close();
+        }
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/PositionHolder.java b/library/src/main/java/com/google/android/exoplayer/extractor/PositionHolder.java
new file mode 100644
index 0000000000..2c947323b7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/PositionHolder.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+/**
+ * Holds a position in the stream.
+ */
+public final class PositionHolder {
+
+  /**
+   * The held position.
+   */
+  public long position;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
new file mode 100644
index 0000000000..a2926d275e
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -0,0 +1,665 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.upstream.Allocation;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.LinkedBlockingDeque;
+
+/**
+ * A rolling buffer of sample data and corresponding sample information.
+ */
+/* package */ final class RollingSampleBuffer {
+
+  private static final int INITIAL_SCRATCH_SIZE = 32;
+
+  private final Allocator allocator;
+  private final int allocationLength;
+
+  private final InfoQueue infoQueue;
+  private final LinkedBlockingDeque<Allocation> dataQueue;
+  private final SampleExtrasHolder extrasHolder;
+  private final ParsableByteArray scratch;
+
+  // Accessed only by the consuming thread.
+  private long totalBytesDropped;
+
+  // Accessed only by the loading thread.
+  private long totalBytesWritten;
+  private Allocation lastAllocation;
+  private int lastAllocationOffset;
+
+  /**
+   * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
+   */
+  public RollingSampleBuffer(Allocator allocator) {
+    this.allocator = allocator;
+    allocationLength = allocator.getIndividualAllocationLength();
+    infoQueue = new InfoQueue();
+    dataQueue = new LinkedBlockingDeque<Allocation>();
+    extrasHolder = new SampleExtrasHolder();
+    scratch = new ParsableByteArray(INITIAL_SCRATCH_SIZE);
+    lastAllocationOffset = allocationLength;
+  }
+
+  // Called by the consuming thread, but only when there is no loading thread.
+
+  /**
+   * Clears the buffer, returning all allocations to the allocator.
+   */
+  public void clear() {
+    infoQueue.clear();
+    while (!dataQueue.isEmpty()) {
+      allocator.release(dataQueue.remove());
+    }
+    totalBytesDropped = 0;
+    totalBytesWritten = 0;
+    lastAllocation = null;
+    lastAllocationOffset = allocationLength;
+  }
+
+  /**
+   * Returns the current absolute write index.
+   */
+  public int getWriteIndex() {
+    return infoQueue.getWriteIndex();
+  }
+
+  /**
+   * Discards samples from the write side of the buffer.
+   *
+   * @param discardFromIndex The absolute index of the first sample to be discarded.
+   */
+  public void discardUpstreamSamples(int discardFromIndex) {
+    totalBytesWritten = infoQueue.discardUpstreamSamples(discardFromIndex);
+    dropUpstreamFrom(totalBytesWritten);
+  }
+
+  /**
+   * Discards data from the write side of the buffer. Data is discarded from the specified absolute
+   * position. Any allocations that are fully discarded are returned to the allocator.
+   *
+   * @param absolutePosition The absolute position (inclusive) from which to discard data.
+   */
+  private void dropUpstreamFrom(long absolutePosition) {
+    int relativePosition = (int) (absolutePosition - totalBytesDropped);
+    // Calculate the index of the allocation containing the position, and the offset within it.
+    int allocationIndex = relativePosition / allocationLength;
+    int allocationOffset = relativePosition % allocationLength;
+    // We want to discard any allocations after the one at allocationIdnex.
+    int allocationDiscardCount = dataQueue.size() - allocationIndex - 1;
+    if (allocationOffset == 0) {
+      // If the allocation at allocationIndex is empty, we should discard that one too.
+      allocationDiscardCount++;
+    }
+    // Discard the allocations.
+    for (int i = 0; i < allocationDiscardCount; i++) {
+      allocator.release(dataQueue.removeLast());
+    }
+    // Update lastAllocation and lastAllocationOffset to reflect the new position.
+    lastAllocation = dataQueue.peekLast();
+    lastAllocationOffset = allocationOffset == 0 ? allocationLength : allocationOffset;
+  }
+
+  // Called by the consuming thread.
+
+  /**
+   * Returns the current absolute read index.
+   */
+  public int getReadIndex() {
+    return infoQueue.getReadIndex();
+  }
+
+  /**
+   * Fills {@code holder} with information about the current sample, but does not write its data.
+   * <p>
+   * The fields set are {@link SampleHolder#size}, {@link SampleHolder#timeUs} and
+   * {@link SampleHolder#flags}.
+   *
+   * @param holder The holder into which the current sample information should be written.
+   * @return True if the holder was filled. False if there is no current sample.
+   */
+  public boolean peekSample(SampleHolder holder) {
+    return infoQueue.peekSample(holder, extrasHolder);
+  }
+
+  /**
+   * Skips the current sample.
+   */
+  public void skipSample() {
+    long nextOffset = infoQueue.moveToNextSample();
+    dropDownstreamTo(nextOffset);
+  }
+
+  /**
+   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+   *
+   * @param timeUs The seek time.
+   * @return True if the skip was successful. False otherwise.
+   */
+  public boolean skipToKeyframeBefore(long timeUs) {
+    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
+    if (nextOffset == -1) {
+      return false;
+    }
+    dropDownstreamTo(nextOffset);
+    return true;
+  }
+
+  /**
+   * Reads the current sample, advancing the read index to the next sample.
+   *
+   * @param sampleHolder The holder into which the current sample should be written.
+   * @return True if a sample was read. False if there is no current sample.
+   */
+  public boolean readSample(SampleHolder sampleHolder) {
+    // Write the sample information into the holder and extrasHolder.
+    boolean haveSample = infoQueue.peekSample(sampleHolder, extrasHolder);
+    if (!haveSample) {
+      return false;
+    }
+
+    // Read encryption data if the sample is encrypted.
+    if (sampleHolder.isEncrypted()) {
+      readEncryptionData(sampleHolder, extrasHolder);
+    }
+    // Write the sample data into the holder.
+    if (sampleHolder.data == null || sampleHolder.data.capacity() < sampleHolder.size) {
+      sampleHolder.replaceBuffer(sampleHolder.size);
+    }
+    if (sampleHolder.data != null) {
+      readData(extrasHolder.offset, sampleHolder.data, sampleHolder.size);
+    }
+    // Advance the read head.
+    long nextOffset = infoQueue.moveToNextSample();
+    dropDownstreamTo(nextOffset);
+    return true;
+  }
+
+  /**
+   * Reads encryption data for the current sample.
+   * <p>
+   * The encryption data is written into {@code sampleHolder.cryptoInfo}, and
+   * {@code sampleHolder.size} is adjusted to subtract the number of bytes that were read. The
+   * same value is added to {@code extrasHolder.offset}.
+   *
+   * @param sampleHolder The holder into which the encryption data should be written.
+   * @param extrasHolder The extras holder whose offset should be read and subsequently adjusted.
+   */
+  private void readEncryptionData(SampleHolder sampleHolder, SampleExtrasHolder extrasHolder) {
+    long offset = extrasHolder.offset;
+
+    // Read the signal byte.
+    readData(offset, scratch.data, 1);
+    offset++;
+    byte signalByte = scratch.data[0];
+    boolean subsampleEncryption = (signalByte & 0x80) != 0;
+    int ivSize = signalByte & 0x7F;
+
+    // Read the initialization vector.
+    if (sampleHolder.cryptoInfo.iv == null) {
+      sampleHolder.cryptoInfo.iv = new byte[16];
+    }
+    readData(offset, sampleHolder.cryptoInfo.iv, ivSize);
+    offset += ivSize;
+
+    // Read the subsample count, if present.
+    int subsampleCount;
+    if (subsampleEncryption) {
+      readData(offset, scratch.data, 2);
+      offset += 2;
+      scratch.setPosition(0);
+      subsampleCount = scratch.readUnsignedShort();
+    } else {
+      subsampleCount = 1;
+    }
+
+    // Write the clear and encrypted subsample sizes.
+    int[] clearDataSizes = sampleHolder.cryptoInfo.numBytesOfClearData;
+    if (clearDataSizes == null || clearDataSizes.length < subsampleCount) {
+      clearDataSizes = new int[subsampleCount];
+    }
+    int[] encryptedDataSizes = sampleHolder.cryptoInfo.numBytesOfEncryptedData;
+    if (encryptedDataSizes == null || encryptedDataSizes.length < subsampleCount) {
+      encryptedDataSizes = new int[subsampleCount];
+    }
+    if (subsampleEncryption) {
+      int subsampleDataLength = 6 * subsampleCount;
+      ensureCapacity(scratch, subsampleDataLength);
+      readData(offset, scratch.data, subsampleDataLength);
+      offset += subsampleDataLength;
+      scratch.setPosition(0);
+      for (int i = 0; i < subsampleCount; i++) {
+        clearDataSizes[i] = scratch.readUnsignedShort();
+        encryptedDataSizes[i] = scratch.readUnsignedIntToInt();
+      }
+    } else {
+      clearDataSizes[0] = 0;
+      encryptedDataSizes[0] = sampleHolder.size - (int) (offset - extrasHolder.offset);
+    }
+
+    // Populate the cryptoInfo.
+    sampleHolder.cryptoInfo.set(subsampleCount, clearDataSizes, encryptedDataSizes,
+        extrasHolder.encryptionKeyId, sampleHolder.cryptoInfo.iv, C.CRYPTO_MODE_AES_CTR);
+
+    // Adjust the offset and size to take into account the bytes read.
+    int bytesRead = (int) (offset - extrasHolder.offset);
+    extrasHolder.offset += bytesRead;
+    sampleHolder.size -= bytesRead;
+  }
+
+  /**
+   * Reads data from the front of the rolling buffer.
+   *
+   * @param absolutePosition The absolute position from which data should be read.
+   * @param target The buffer into which data should be written.
+   * @param length The number of bytes to read.
+   */
+  private void readData(long absolutePosition, ByteBuffer target, int length) {
+    int remaining = length;
+    while (remaining > 0) {
+      dropDownstreamTo(absolutePosition);
+      int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
+      int toCopy = Math.min(remaining, allocationLength - positionInAllocation);
+      Allocation allocation = dataQueue.peek();
+      target.put(allocation.data, allocation.translateOffset(positionInAllocation), toCopy);
+      absolutePosition += toCopy;
+      remaining -= toCopy;
+    }
+  }
+
+  /**
+   * Reads data from the front of the rolling buffer.
+   *
+   * @param absolutePosition The absolute position from which data should be read.
+   * @param target The array into which data should be written.
+   * @param length The number of bytes to read.
+   */
+  // TODO: Consider reducing duplication of this method and the one above.
+  private void readData(long absolutePosition, byte[] target, int length) {
+    int bytesRead = 0;
+    while (bytesRead < length) {
+      dropDownstreamTo(absolutePosition);
+      int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
+      int toCopy = Math.min(length - bytesRead, allocationLength - positionInAllocation);
+      Allocation allocation = dataQueue.peek();
+      System.arraycopy(allocation.data, allocation.translateOffset(positionInAllocation), target,
+          bytesRead, toCopy);
+      absolutePosition += toCopy;
+      bytesRead += toCopy;
+    }
+  }
+
+  /**
+   * Discard any allocations that hold data prior to the specified absolute position, returning
+   * them to the allocator.
+   *
+   * @param absolutePosition The absolute position up to which allocations can be discarded.
+   */
+  private void dropDownstreamTo(long absolutePosition) {
+    int relativePosition = (int) (absolutePosition - totalBytesDropped);
+    int allocationIndex = relativePosition / allocationLength;
+    for (int i = 0; i < allocationIndex; i++) {
+      allocator.release(dataQueue.remove());
+      totalBytesDropped += allocationLength;
+    }
+  }
+
+  /**
+   * Ensure that the passed {@link ParsableByteArray} is of at least the specified limit.
+   */
+  private static void ensureCapacity(ParsableByteArray byteArray, int limit) {
+    if (byteArray.limit() < limit) {
+      byteArray.reset(new byte[limit], limit);
+    }
+  }
+
+  // Called by the loading thread.
+
+  /**
+   * Returns the current write position in the rolling buffer.
+   *
+   * @return The current write position.
+   */
+  public long getWritePosition() {
+    return totalBytesWritten;
+  }
+
+  /**
+   * Appends data to the rolling buffer.
+   *
+   * @param dataSource The source from which to read.
+   * @param length The maximum length of the read, or {@link C#LENGTH_UNBOUNDED} if the caller does
+   *     not wish to impose a limit.
+   * @return The number of bytes appended.
+   * @throws IOException If an error occurs reading from the source.
+   */
+  public int appendData(DataSource dataSource, int length) throws IOException {
+    ensureSpaceForWrite();
+    int remainingAllocationCapacity = allocationLength - lastAllocationOffset;
+    length = length != C.LENGTH_UNBOUNDED ? Math.min(length, remainingAllocationCapacity)
+        : remainingAllocationCapacity;
+
+    int bytesRead = dataSource.read(lastAllocation.data,
+        lastAllocation.translateOffset(lastAllocationOffset), length);
+    if (bytesRead == C.RESULT_END_OF_INPUT) {
+      return C.RESULT_END_OF_INPUT;
+    }
+
+    lastAllocationOffset += bytesRead;
+    totalBytesWritten += bytesRead;
+    return bytesRead;
+  }
+
+  /**
+   * Appends data to the rolling buffer.
+   *
+   * @param input The source from which to read.
+   * @param length The maximum length of the read.
+   * @return The number of bytes appended.
+   * @throws IOException If an error occurs reading from the source.
+   */
+  public int appendData(ExtractorInput input, int length) throws IOException, InterruptedException {
+    ensureSpaceForWrite();
+    int thisWriteLength = Math.min(length, allocationLength - lastAllocationOffset);
+    input.readFully(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
+        thisWriteLength);
+    lastAllocationOffset += thisWriteLength;
+    totalBytesWritten += thisWriteLength;
+    return thisWriteLength;
+  }
+
+  /**
+   * Appends data to the rolling buffer.
+   *
+   * @param buffer A buffer containing the data to append.
+   * @param length The length of the data to append.
+   */
+  public void appendData(ParsableByteArray buffer, int length) {
+    int remainingWriteLength = length;
+    while (remainingWriteLength > 0) {
+      ensureSpaceForWrite();
+      int thisWriteLength = Math.min(remainingWriteLength, allocationLength - lastAllocationOffset);
+      buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
+          thisWriteLength);
+      lastAllocationOffset += thisWriteLength;
+      remainingWriteLength -= thisWriteLength;
+    }
+    totalBytesWritten += length;
+  }
+
+  /**
+   * Indicates the end point for the current sample, making it available for consumption.
+   *
+   * @param sampleTimeUs The sample timestamp.
+   * @param flags Flags that accompany the sample. See {@link SampleHolder#flags}.
+   * @param position The position of the sample data in the rolling buffer.
+   * @param size The size of the sample, in bytes.
+   * @param encryptionKey The encryption key associated with the sample, or null.
+   */
+  public void commitSample(long sampleTimeUs, int flags, long position, int size,
+      byte[] encryptionKey) {
+    infoQueue.commitSample(sampleTimeUs, flags, position, size, encryptionKey);
+  }
+
+  /**
+   * Ensures at least one byte can be written, obtaining an additional allocation if necessary.
+   */
+  private void ensureSpaceForWrite() {
+    if (lastAllocationOffset == allocationLength) {
+      lastAllocationOffset = 0;
+      lastAllocation = allocator.allocate();
+      dataQueue.add(lastAllocation);
+    }
+  }
+
+  /**
+   * Holds information about the samples in the rolling buffer.
+   */
+  private static final class InfoQueue {
+
+    private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
+
+    private int capacity;
+
+    private long[] offsets;
+    private int[] sizes;
+    private int[] flags;
+    private long[] timesUs;
+    private byte[][] encryptionKeys;
+
+    private int queueSize;
+    private int absoluteReadIndex;
+    private int relativeReadIndex;
+    private int relativeWriteIndex;
+
+    public InfoQueue() {
+      capacity = SAMPLE_CAPACITY_INCREMENT;
+      offsets = new long[capacity];
+      timesUs = new long[capacity];
+      flags = new int[capacity];
+      sizes = new int[capacity];
+      encryptionKeys = new byte[capacity][];
+    }
+
+    // Called by the consuming thread, but only when there is no loading thread.
+
+    /**
+     * Clears the queue.
+     */
+    public void clear() {
+      absoluteReadIndex = 0;
+      relativeReadIndex = 0;
+      relativeWriteIndex = 0;
+      queueSize = 0;
+    }
+
+    /**
+     * Returns the current absolute write index.
+     */
+    public int getWriteIndex() {
+      return absoluteReadIndex + queueSize;
+    }
+
+    /**
+     * Discards samples from the write side of the buffer.
+     *
+     * @param discardFromIndex The absolute index of the first sample to be discarded.
+     * @return The reduced total number of bytes written, after the samples have been discarded.
+     */
+    public long discardUpstreamSamples(int discardFromIndex) {
+      int discardCount = getWriteIndex() - discardFromIndex;
+      Assertions.checkArgument(0 <= discardCount && discardCount <= queueSize);
+
+      if (discardCount == 0) {
+        if (absoluteReadIndex == 0) {
+          // queueSize == absoluteReadIndex == 0, so nothing has been written to the queue.
+          return 0;
+        }
+        int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
+        return offsets[lastWriteIndex] + sizes[lastWriteIndex];
+      }
+
+      queueSize -= discardCount;
+      relativeWriteIndex = (relativeWriteIndex + capacity - discardCount) % capacity;
+      return offsets[relativeWriteIndex];
+    }
+
+    // Called by the consuming thread.
+
+    /**
+     * Returns the current absolute read index.
+     */
+    public int getReadIndex() {
+      return absoluteReadIndex;
+    }
+
+    /**
+     * Fills {@code holder} with information about the current sample, but does not write its data.
+     * The first entry in {@code offsetHolder} is filled with the absolute position of the sample's
+     * data in the rolling buffer.
+     * <p>
+     * The fields set are {SampleHolder#size}, {SampleHolder#timeUs}, {SampleHolder#flags} and
+     * {@code offsetHolder[0]}.
+     *
+     * @param holder The holder into which the current sample information should be written.
+     * @param extrasHolder The holder into which extra sample information should be written.
+     * @return True if the holders were filled. False if there is no current sample.
+     */
+    public synchronized boolean peekSample(SampleHolder holder, SampleExtrasHolder extrasHolder) {
+      if (queueSize == 0) {
+        return false;
+      }
+      holder.timeUs = timesUs[relativeReadIndex];
+      holder.size = sizes[relativeReadIndex];
+      holder.flags = flags[relativeReadIndex];
+      extrasHolder.offset = offsets[relativeReadIndex];
+      extrasHolder.encryptionKeyId = encryptionKeys[relativeReadIndex];
+      return true;
+    }
+
+    /**
+     * Advances the read index to the next sample.
+     *
+     * @return The absolute position of the first byte in the rolling buffer that may still be
+     *     required after advancing the index. Data prior to this position can be dropped.
+     */
+    public synchronized long moveToNextSample() {
+      queueSize--;
+      int lastReadIndex = relativeReadIndex++;
+      absoluteReadIndex++;
+      if (relativeReadIndex == capacity) {
+        // Wrap around.
+        relativeReadIndex = 0;
+      }
+      return queueSize > 0 ? offsets[relativeReadIndex]
+          : (sizes[lastReadIndex] + offsets[lastReadIndex]);
+    }
+
+    /**
+     * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+     *
+     * @param timeUs The seek time.
+     * @return The offset of the keyframe's data if the keyframe was present. -1 otherwise.
+     */
+    public synchronized long skipToKeyframeBefore(long timeUs) {
+      if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
+        return -1;
+      }
+
+      int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
+      long lastTimeUs = timesUs[lastWriteIndex];
+      if (timeUs > lastTimeUs) {
+        return -1;
+      }
+
+      // TODO: This can be optimized further using binary search, although the fact that the array
+      // is cyclic means we'd need to implement the binary search ourselves.
+      int sampleCount = 0;
+      int sampleCountToKeyframe = -1;
+      int searchIndex = relativeReadIndex;
+      while (searchIndex != relativeWriteIndex) {
+        if (timesUs[searchIndex] > timeUs) {
+          // We've gone too far.
+          break;
+        } else if ((flags[searchIndex] & C.SAMPLE_FLAG_SYNC) != 0) {
+          // We've found a keyframe, and we're still before the seek position.
+          sampleCountToKeyframe = sampleCount;
+        }
+        searchIndex = (searchIndex + 1) % capacity;
+        sampleCount++;
+      }
+
+      if (sampleCountToKeyframe == -1) {
+        return -1;
+      }
+
+      queueSize -= sampleCountToKeyframe;
+      relativeReadIndex = (relativeReadIndex + sampleCountToKeyframe) % capacity;
+      absoluteReadIndex += sampleCountToKeyframe;
+      return offsets[relativeReadIndex];
+    }
+
+    // Called by the loading thread.
+
+    public synchronized void commitSample(long timeUs, int sampleFlags, long offset, int size,
+        byte[] encryptionKey) {
+      timesUs[relativeWriteIndex] = timeUs;
+      offsets[relativeWriteIndex] = offset;
+      sizes[relativeWriteIndex] = size;
+      flags[relativeWriteIndex] = sampleFlags;
+      encryptionKeys[relativeWriteIndex] = encryptionKey;
+      // Increment the write index.
+      queueSize++;
+      if (queueSize == capacity) {
+        // Increase the capacity.
+        int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
+        long[] newOffsets = new long[newCapacity];
+        long[] newTimesUs = new long[newCapacity];
+        int[] newFlags = new int[newCapacity];
+        int[] newSizes = new int[newCapacity];
+        byte[][] newEncryptionKeys = new byte[newCapacity][];
+        int beforeWrap = capacity - relativeReadIndex;
+        System.arraycopy(offsets, relativeReadIndex, newOffsets, 0, beforeWrap);
+        System.arraycopy(timesUs, relativeReadIndex, newTimesUs, 0, beforeWrap);
+        System.arraycopy(flags, relativeReadIndex, newFlags, 0, beforeWrap);
+        System.arraycopy(sizes, relativeReadIndex, newSizes, 0, beforeWrap);
+        System.arraycopy(encryptionKeys, relativeReadIndex, newEncryptionKeys, 0, beforeWrap);
+        int afterWrap = relativeReadIndex;
+        System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
+        System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
+        System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
+        System.arraycopy(sizes, 0, newSizes, beforeWrap, afterWrap);
+        System.arraycopy(encryptionKeys, 0, newEncryptionKeys, beforeWrap, afterWrap);
+        offsets = newOffsets;
+        timesUs = newTimesUs;
+        flags = newFlags;
+        sizes = newSizes;
+        encryptionKeys = newEncryptionKeys;
+        relativeReadIndex = 0;
+        relativeWriteIndex = capacity;
+        queueSize = capacity;
+        capacity = newCapacity;
+      } else {
+        relativeWriteIndex++;
+        if (relativeWriteIndex == capacity) {
+          // Wrap around.
+          relativeWriteIndex = 0;
+        }
+      }
+    }
+
+  }
+
+  /**
+   * Holds additional sample information not held by {@link SampleHolder}.
+   */
+  private static final class SampleExtrasHolder {
+
+    public long offset;
+    public byte[] encryptionKeyId;
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java b/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java
new file mode 100644
index 0000000000..20b333c4a5
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+/**
+ * Maps seek positions (in microseconds) to corresponding positions (byte offsets) in the stream.
+ */
+public interface SeekMap {
+
+  /**
+   * Whether or not the seeking is supported.
+   * <p>
+   * If seeking is not supported then the only valid seek position is the start of the file, and so
+   * {@link #getPosition(long)} will return 0 for all input values.
+   *
+   * @return True if seeking is supported. False otherwise.
+   */
+  boolean isSeekable();
+
+  /**
+   * Maps a seek position in microseconds to a corresponding position (byte offset) in the stream
+   * from which data can be provided to the extractor.
+   *
+   * @param timeUs A seek position in microseconds.
+   * @return The corresponding position (byte offset) in the stream from which data can be provided
+   *     to the extractor, or 0 if {@code #isSeekable()} returns false.
+   */
+  long getPosition(long timeUs);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java
new file mode 100644
index 0000000000..fa639d75ba
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Receives track level data extracted by an {@link Extractor}.
+ */
+public interface TrackOutput {
+
+  /**
+   * Invoked when the {@link MediaFormat} of the track has been extracted from the stream.
+   *
+   * @param format The extracted {@link MediaFormat}.
+   */
+  void format(MediaFormat format);
+
+  /**
+   * Invoked to write sample data to the output.
+   *
+   * @param input An {@link ExtractorInput} from which to read the sample data.
+   * @param length The maximum length to read from the input.
+   * @return The number of bytes appended.
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException;
+
+  /**
+   * Invoked to write sample data to the output.
+   *
+   * @param data A {@link ParsableByteArray} from which to read the sample data.
+   * @param length The number of bytes to read.
+   */
+  void sampleData(ParsableByteArray data, int length);
+
+  /**
+   * Invoked when metadata associated with a sample has been extracted from the stream.
+   * <p>
+   * The corresponding sample data will have already been passed to the output via calls to
+   * {@link #sampleData(ExtractorInput, int)} or {@link #sampleData(ParsableByteArray, int)}.
+   *
+   * @param timeUs The media timestamp associated with the sample, in microseconds.
+   * @param flags Flags associated with the sample. See {@link SampleHolder#flags}.
+   * @param size The size of the sample data, in bytes.
+   * @param offset The number of bytes that have been passed to
+   *     {@link #sampleData(ExtractorInput, int)} or {@link #sampleData(ParsableByteArray, int)}
+   *     since the last byte belonging to the sample whose metadata is being passed.
+   * @param encryptionKey The encryption key associated with the sample. May be null.
+   */
+  void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java
new file mode 100644
index 0000000000..f628b70de3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/BufferingInput.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.BufferOverflowException;
+
+/**
+ * Buffers bytes read from an {@link ExtractorInput} to allow re-reading buffered bytes within a
+ * window starting at a marked position.
+ */
+/* package */ final class BufferingInput {
+
+  private final ParsableByteArray buffer;
+  private final int capacity;
+
+  private int readPosition;
+  private int writePosition;
+  private int markPosition;
+
+  /**
+   * Constructs a new buffer for reading from extractor inputs that can store up to {@code capacity}
+   * bytes.
+   *
+   * @param capacity Number of bytes that can be stored in the buffer.
+   */
+  public BufferingInput(int capacity) {
+    this.capacity = capacity;
+    buffer = new ParsableByteArray(capacity * 2);
+  }
+
+  /** Discards any pending data in the buffer and returns the writing position to zero. */
+  public void reset() {
+    readPosition = 0;
+    writePosition = 0;
+    markPosition = 0;
+  }
+
+  /**
+   * Moves the mark to be at the reading position. Any data before the reading position is
+   * discarded. After calling this method, calling {@link #returnToMark} will move the reading
+   * position back to the mark position.
+   */
+  public void mark() {
+    if (readPosition > capacity) {
+      System.arraycopy(buffer.data, readPosition, buffer.data, 0, writePosition - readPosition);
+      writePosition -= readPosition;
+      readPosition = 0;
+    }
+    markPosition = readPosition;
+  }
+
+  /** Moves the reading position back to the mark position. */
+  public void returnToMark() {
+    readPosition = markPosition;
+  }
+
+  /** Returns the number of bytes available for reading from the current position. */
+  public int getAvailableByteCount() {
+    return writePosition - readPosition;
+  }
+
+  /**
+   * Buffers any more data required to read {@code length} bytes from the reading position, and
+   * returns a {@link ParsableByteArray} that wraps the buffer's byte array, with its position set
+   * to the current reading position. The read position is then updated for having read
+   * {@code length} bytes.
+   *
+   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
+   * @param length Number of bytes that will be readable in the returned array.
+   * @return {@link ParsableByteArray} from which {@code length} bytes can be read.
+   * @throws IOException Thrown if there was an error reading from the stream.
+   * @throws InterruptedException Thrown if reading from the stream was interrupted.
+   */
+  public ParsableByteArray getParsableByteArray(ExtractorInput extractorInput, int length)
+      throws IOException, InterruptedException {
+    if (!ensureLoaded(extractorInput, length)) {
+      throw new EOFException();
+    }
+    ParsableByteArray parsableByteArray = new ParsableByteArray(buffer.data, writePosition);
+    parsableByteArray.setPosition(readPosition);
+    readPosition += length;
+    return parsableByteArray;
+  }
+
+  /**
+   * Drains as much buffered data as possible up to {@code length} bytes to {@code trackOutput}.
+   *
+   * @param trackOutput Track output to populate with up to {@code length} bytes of sample data.
+   * @param length Number of bytes to try to read from the buffer.
+   * @return The number of buffered bytes written.
+   */
+  public int drainToOutput(TrackOutput trackOutput, int length) {
+    if (length == 0) {
+      return 0;
+    }
+    buffer.setPosition(readPosition);
+    int bytesToDrain = Math.min(writePosition - readPosition, length);
+    trackOutput.sampleData(buffer, bytesToDrain);
+    readPosition += bytesToDrain;
+    return bytesToDrain;
+  }
+
+  /**
+   * Skips {@code length} bytes from the reading position, reading from {@code extractorInput} to
+   * populate the buffer if required.
+   *
+   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
+   * @param length Number of bytes to skip.
+   * @throws IOException Thrown if there was an error reading from the stream.
+   * @throws InterruptedException Thrown if reading from the stream was interrupted.
+   */
+  public void skip(ExtractorInput extractorInput, int length)
+      throws IOException, InterruptedException {
+    if (!readInternal(extractorInput, null, 0, length)) {
+      throw new EOFException();
+    }
+  }
+
+  /**
+   * Reads {@code length} bytes from the reading position, reading from {@code extractorInput} to
+   * populate the buffer if required.
+   *
+   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
+   * @param length Number of bytes to read.
+   * @throws IOException Thrown if there was an error reading from the stream.
+   * @throws InterruptedException Thrown if reading from the stream was interrupted.
+   * @throws EOFException Thrown if the end of the file was reached.
+   */
+  public void read(ExtractorInput extractorInput, byte[] target, int offset, int length)
+      throws IOException, InterruptedException {
+    if (!readInternal(extractorInput, target, offset, length)) {
+      throw new EOFException();
+    }
+  }
+
+  /**
+   * Reads {@code length} bytes from the reading position, reading from {@code extractorInput} to
+   * populate the buffer if required.
+   *
+   * <p>Returns {@code false} if the end of the stream has been reached. Throws {@link EOFException}
+   * if the read request could only be partially satisfied. Returns {@code true} otherwise.
+   *
+   * @param extractorInput {@link ExtractorInput} from which additional data should be read.
+   * @param length Number of bytes to read.
+   * @return Whether the extractor input is at the end of the stream.
+   * @throws IOException Thrown if there was an error reading from the stream.
+   * @throws InterruptedException Thrown if reading from the stream was interrupted.
+   * @throws EOFException Thrown if the end of the file was reached.
+   */
+  public boolean readAllowingEndOfInput(ExtractorInput extractorInput, byte[] target, int offset,
+      int length) throws IOException, InterruptedException {
+    return readInternal(extractorInput, target, offset, length);
+  }
+
+  private boolean readInternal(ExtractorInput extractorInput, byte[] target, int offset, int length)
+      throws InterruptedException, IOException {
+    if (!ensureLoaded(extractorInput, length)) {
+      return false;
+    }
+    if (target != null) {
+      System.arraycopy(buffer.data, readPosition, target, offset, length);
+    }
+    readPosition += length;
+    return true;
+  }
+
+  /** Ensures the buffer contains enough data to read {@code length} bytes. */
+  private boolean ensureLoaded(ExtractorInput extractorInput, int length)
+      throws InterruptedException, IOException {
+    if (length + readPosition - markPosition > capacity) {
+      throw new BufferOverflowException();
+    }
+
+    int bytesToLoad = length - (writePosition - readPosition);
+    if (bytesToLoad > 0) {
+      if (!extractorInput.readFully(buffer.data, writePosition, bytesToLoad, true)) {
+        return false;
+      }
+      writePosition += bytesToLoad;
+    }
+    return true;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
new file mode 100644
index 0000000000..90fdfce85e
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.C;
+
+/**
+ * MP3 seeker that doesn't rely on metadata and seeks assuming the source has a constant bitrate.
+ */
+/* package */ final class ConstantBitrateSeeker implements Mp3Extractor.Seeker {
+
+  private static final int MICROSECONDS_PER_SECOND = 1000000;
+  private static final int BITS_PER_BYTE = 8;
+
+  private final long firstFramePosition;
+  private final int bitrate;
+  private final long durationUs;
+
+  public ConstantBitrateSeeker(long firstFramePosition, int bitrate, long inputLength) {
+    this.firstFramePosition = firstFramePosition;
+    this.bitrate = bitrate;
+    durationUs = inputLength == C.LENGTH_UNBOUNDED ? C.UNKNOWN_TIME_US : getTimeUs(inputLength);
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return durationUs != C.UNKNOWN_TIME_US;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return durationUs == C.UNKNOWN_TIME_US ? 0
+        : firstFramePosition + (timeUs * bitrate) / (MICROSECONDS_PER_SECOND * BITS_PER_BYTE);
+  }
+
+  @Override
+  public long getTimeUs(long position) {
+    return ((position - firstFramePosition) * MICROSECONDS_PER_SECOND * BITS_PER_BYTE) / bitrate;
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
new file mode 100644
index 0000000000..5842b19ce3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Collections;
+
+/**
+ * Extracts data from an MP3 file.
+ */
+public final class Mp3Extractor implements Extractor {
+
+  /** The maximum number of bytes to search when synchronizing, before giving up. */
+  private static final int MAX_BYTES_TO_SEARCH = 128 * 1024;
+
+  /** Mask that includes the audio header values that must match between frames. */
+  private static final int HEADER_MASK = 0xFFFE0C00;
+  private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
+  private static final String[] MIME_TYPE_BY_LAYER =
+      new String[] {MimeTypes.AUDIO_MPEG_L1, MimeTypes.AUDIO_MPEG_L2, MimeTypes.AUDIO_MPEG};
+
+  /**
+   * Theoretical maximum frame size for an MPEG audio stream, which occurs when playing a Layer 2
+   * MPEG 2.5 audio stream at 16 kb/s (with padding). The size is 1152 sample/frame *
+   * 160000 bit/s / (8000 sample/s * 8 bit/byte) + 1 padding byte/frame = 2881 byte/frame.
+   * The next power of two size is 4 KiB.
+   */
+  private static final int MAX_FRAME_SIZE_BYTES = 4096;
+
+  private final BufferingInput inputBuffer;
+  private final ParsableByteArray scratch;
+  private final MpegAudioHeader synchronizedHeader;
+
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+  private TrackOutput trackOutput;
+
+  private int synchronizedHeaderData;
+
+  private Seeker seeker;
+  private long basisTimeUs;
+  private int samplesRead;
+  private int sampleBytesRemaining;
+
+  /** Constructs a new {@link Mp3Extractor}. */
+  public Mp3Extractor() {
+    inputBuffer = new BufferingInput(MAX_FRAME_SIZE_BYTES * 3);
+    scratch = new ParsableByteArray(4);
+    synchronizedHeader = new MpegAudioHeader();
+  }
+
+  @Override
+  public void init(ExtractorOutput extractorOutput) {
+    this.extractorOutput = extractorOutput;
+    trackOutput = extractorOutput.track(0);
+    extractorOutput.endTracks();
+  }
+
+  @Override
+  public void seek() {
+    synchronizedHeaderData = 0;
+    samplesRead = 0;
+    basisTimeUs = -1;
+    sampleBytesRemaining = 0;
+    inputBuffer.reset();
+  }
+
+  @Override
+  public int read(ExtractorInput extractorInput, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    if (synchronizedHeaderData == 0
+        && synchronizeCatchingEndOfInput(extractorInput) == RESULT_END_OF_INPUT) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    return readSample(extractorInput);
+  }
+
+  private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
+    if (sampleBytesRemaining == 0) {
+      long headerPosition = maybeResynchronize(extractorInput);
+      if (headerPosition == RESULT_END_OF_INPUT) {
+        return RESULT_END_OF_INPUT;
+      }
+      if (basisTimeUs == -1) {
+        basisTimeUs = seeker.getTimeUs(getPosition(extractorInput, inputBuffer));
+      }
+      sampleBytesRemaining = synchronizedHeader.frameSize;
+    }
+
+    long timeUs = basisTimeUs + (samplesRead * 1000000L / synchronizedHeader.sampleRate);
+
+    // Start by draining any buffered bytes, then read directly from the extractor input.
+    sampleBytesRemaining -= inputBuffer.drainToOutput(trackOutput, sampleBytesRemaining);
+    if (sampleBytesRemaining > 0) {
+      inputBuffer.mark();
+
+      // Return if we still need more data.
+      sampleBytesRemaining -= trackOutput.sampleData(extractorInput, sampleBytesRemaining);
+      if (sampleBytesRemaining > 0) {
+        return RESULT_CONTINUE;
+      }
+    }
+
+    trackOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, synchronizedHeader.frameSize, 0, null);
+    samplesRead += synchronizedHeader.samplesPerFrame;
+    sampleBytesRemaining = 0;
+    return RESULT_CONTINUE;
+  }
+
+  /** Attempts to read an MPEG audio header at the current offset, resynchronizing if necessary. */
+  private long maybeResynchronize(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    inputBuffer.mark();
+    if (!inputBuffer.readAllowingEndOfInput(extractorInput, scratch.data, 0, 4)) {
+      return RESULT_END_OF_INPUT;
+    }
+    inputBuffer.returnToMark();
+
+    scratch.setPosition(0);
+    int sampleHeaderData = scratch.readInt();
+    if ((sampleHeaderData & HEADER_MASK) == (synchronizedHeaderData & HEADER_MASK)) {
+      int frameSize = MpegAudioHeader.getFrameSize(sampleHeaderData);
+      if (frameSize != -1) {
+        MpegAudioHeader.populateHeader(sampleHeaderData, synchronizedHeader);
+        return RESULT_CONTINUE;
+      }
+    }
+
+    synchronizedHeaderData = 0;
+    inputBuffer.skip(extractorInput, 1);
+    return synchronizeCatchingEndOfInput(extractorInput);
+  }
+
+  private long synchronizeCatchingEndOfInput(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    // An EOFException will be raised if any read operation was partially satisfied. If a seek
+    // operation resulted in reading from within the last frame, we may try to read past the end of
+    // the file in a partially-satisfied read operation, so we need to catch the exception.
+    try {
+      return synchronize(extractorInput);
+    } catch (EOFException e) {
+      return RESULT_END_OF_INPUT;
+    }
+  }
+
+  private long synchronize(ExtractorInput extractorInput) throws IOException, InterruptedException {
+    long startPosition = getPosition(extractorInput, inputBuffer);
+
+    // Skip any ID3 header at the start of the file.
+    if (startPosition == 0) {
+      inputBuffer.read(extractorInput, scratch.data, 0, 3);
+      scratch.setPosition(0);
+      if (scratch.readUnsignedInt24() == ID3_TAG) {
+        extractorInput.skipFully(3);
+        extractorInput.readFully(scratch.data, 0, 4);
+        int headerLength = ((scratch.data[0] & 0x7F) << 21) | ((scratch.data[1] & 0x7F) << 14)
+            | ((scratch.data[2] & 0x7F) << 7) | (scratch.data[3] & 0x7F);
+        extractorInput.skipFully(headerLength);
+        inputBuffer.reset();
+        startPosition = getPosition(extractorInput, inputBuffer);
+      } else {
+        inputBuffer.returnToMark();
+      }
+    }
+
+    // Try to find four consecutive valid MPEG audio frames.
+    inputBuffer.mark();
+    long headerPosition = startPosition;
+    int validFrameCount = 0;
+    while (true) {
+      if (headerPosition - startPosition >= MAX_BYTES_TO_SEARCH) {
+        throw new ParserException("Searched too many bytes while resynchronizing.");
+      }
+
+      if (!inputBuffer.readAllowingEndOfInput(extractorInput, scratch.data, 0, 4)) {
+        return RESULT_END_OF_INPUT;
+      }
+
+      scratch.setPosition(0);
+      int headerData = scratch.readInt();
+      int frameSize;
+      if ((synchronizedHeaderData != 0
+          && (headerData & HEADER_MASK) != (synchronizedHeaderData & HEADER_MASK))
+          || (frameSize = MpegAudioHeader.getFrameSize(headerData)) == -1) {
+        validFrameCount = 0;
+        synchronizedHeaderData = 0;
+
+        // Try reading a header starting at the next byte.
+        inputBuffer.returnToMark();
+        inputBuffer.skip(extractorInput, 1);
+        inputBuffer.mark();
+        headerPosition++;
+        continue;
+      }
+
+      if (validFrameCount == 0) {
+        MpegAudioHeader.populateHeader(headerData, synchronizedHeader);
+        synchronizedHeaderData = headerData;
+      }
+
+      // The header was valid and matching (if appropriate). Check another or end synchronization.
+      validFrameCount++;
+      if (validFrameCount == 4) {
+        break;
+      }
+
+      // Look for more headers.
+      inputBuffer.skip(extractorInput, frameSize - 4);
+    }
+
+    // The input buffer read position is now synchronized.
+    inputBuffer.returnToMark();
+    if (seeker == null) {
+      ParsableByteArray frame =
+          inputBuffer.getParsableByteArray(extractorInput, synchronizedHeader.frameSize);
+      seeker = XingSeeker.create(synchronizedHeader, frame, headerPosition,
+          extractorInput.getLength());
+      if (seeker == null) {
+        seeker = VbriSeeker.create(synchronizedHeader, frame, headerPosition);
+      }
+      if (seeker == null) {
+        inputBuffer.returnToMark();
+        seeker = new ConstantBitrateSeeker(headerPosition, synchronizedHeader.bitrate * 1000,
+            extractorInput.getLength());
+      } else {
+        // Discard the frame that was parsed for seeking metadata.
+        inputBuffer.mark();
+      }
+      extractorOutput.seekMap(seeker);
+      trackOutput.format(MediaFormat.createAudioFormat(
+          MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], MAX_FRAME_SIZE_BYTES,
+          seeker.getDurationUs(), synchronizedHeader.channels, synchronizedHeader.sampleRate,
+          Collections.<byte[]>emptyList()));
+    }
+
+    return headerPosition;
+  }
+
+  /** Returns the reading position of {@code bufferingInput} relative to the extractor's stream. */
+  private static long getPosition(ExtractorInput extractorInput, BufferingInput bufferingInput) {
+    return extractorInput.getPosition() - bufferingInput.getAvailableByteCount();
+  }
+
+  /**
+   * {@link SeekMap} that also allows mapping from position (byte offset) back to time, which can be
+   * used to work out the new sample basis timestamp after seeking and resynchronization.
+   */
+  /* package */ interface Seeker extends SeekMap {
+
+    /**
+     * Maps a position (byte offset) to a corresponding sample timestamp.
+     *
+     * @param position A seek position (byte offset) relative to the start of the stream.
+     * @return The corresponding timestamp of the next sample to be read, in microseconds.
+     */
+    long getTimeUs(long position);
+
+    /** Returns the duration of the source, in microseconds. */
+    long getDurationUs();
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java
new file mode 100644
index 0000000000..9f05d0e3a6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+/** Parsed MPEG audio frame header. */
+/* package */ final class MpegAudioHeader {
+
+  private static final int[] SAMPLING_RATE_V1 = {44100, 48000, 32000};
+  private static final int[] BITRATE_V1_L1 =
+      {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448};
+  private static final int[] BITRATE_V2_L1 =
+      {32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256};
+  private static final int[] BITRATE_V1_L2 =
+      {32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384};
+  private static final int[] BITRATE_V1_L3 =
+      {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320};
+  private static final int[] BITRATE_V2 =
+      {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160};
+
+  /** Returns the size of the frame associated with {@code header}, or -1 if it is invalid. */
+  public static int getFrameSize(int header) {
+    if ((header & 0xFFE00000) != 0xFFE00000) {
+      return -1;
+    }
+
+    int version = (header >>> 19) & 3;
+    if (version == 1) {
+      return -1;
+    }
+
+    int layer = (header >>> 17) & 3;
+    if (layer == 0) {
+      return -1;
+    }
+
+    int bitrateIndex = (header >>> 12) & 15;
+    if (bitrateIndex == 0 || bitrateIndex == 0xF) {
+      // Disallow "free" bitrate.
+      return -1;
+    }
+
+    int samplingRateIndex = (header >>> 10) & 3;
+    if (samplingRateIndex == 3) {
+      return -1;
+    }
+
+    int samplingRate = SAMPLING_RATE_V1[samplingRateIndex];
+    if (version == 2) {
+      // Version 2
+      samplingRate /= 2;
+    } else if (version == 0) {
+      // Version 2.5
+      samplingRate /= 4;
+    }
+
+    int bitrate;
+    int padding = (header >>> 9) & 1;
+    if (layer == 3) {
+      // Layer I (layer == 3)
+      bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
+      return (12000 * bitrate / samplingRate + padding) * 4;
+    } else {
+      // Layer II (layer == 2) or III (layer == 1)
+      if (version == 3) {
+        bitrate = layer == 2 ? BITRATE_V1_L2[bitrateIndex - 1] : BITRATE_V1_L3[bitrateIndex - 1];
+      } else {
+        // Version 2 or 2.5.
+        bitrate = BITRATE_V2[bitrateIndex - 1];
+      }
+    }
+
+    if (version == 3) {
+      // Version 1
+      return 144000 * bitrate / samplingRate + padding;
+    } else {
+      // Version 2 or 2.5
+      return (layer == 1 ? 72000 : 144000) * bitrate / samplingRate + padding;
+    }
+  }
+
+  /**
+   * Returns the header represented by {@code header}, if it is valid; {@code null} otherwise.
+   *
+   * @param headerData Header data to parse.
+   * @param header Header to populate with data from {@code headerData}.
+   */
+  public static void populateHeader(int headerData, MpegAudioHeader header) {
+    if ((headerData & 0xFFE00000) != 0xFFE00000) {
+      return;
+    }
+
+    int version = (headerData >>> 19) & 3;
+    if (version == 1) {
+      return;
+    }
+
+    int layer = (headerData >>> 17) & 3;
+    if (layer == 0) {
+      return;
+    }
+
+    int bitrateIndex = (headerData >>> 12) & 15;
+    if (bitrateIndex == 0 || bitrateIndex == 0xF) {
+      // Disallow "free" bitrate.
+      return;
+    }
+
+    int samplingRateIndex = (headerData >>> 10) & 3;
+    if (samplingRateIndex == 3) {
+      return;
+    }
+
+    int sampleRate = SAMPLING_RATE_V1[samplingRateIndex];
+    if (version == 2) {
+      // Version 2
+      sampleRate /= 2;
+    } else if (version == 0) {
+      // Version 2.5
+      sampleRate /= 4;
+    }
+
+    int padding = (headerData >>> 9) & 1;
+    int bitrate, frameSize, samplesPerFrame;
+    if (layer == 3) {
+      // Layer I (layer == 3)
+      bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
+      frameSize = (12000 * bitrate / sampleRate + padding) * 4;
+      samplesPerFrame = 384;
+    } else {
+      // Layer II (layer == 2) or III (layer == 1)
+      if (version == 3) {
+        // Version 1
+        bitrate = layer == 2 ? BITRATE_V1_L2[bitrateIndex - 1] : BITRATE_V1_L3[bitrateIndex - 1];
+        samplesPerFrame = 1152;
+        frameSize = 144000 * bitrate / sampleRate + padding;
+      } else {
+        // Version 2 or 2.5.
+        bitrate = BITRATE_V2[bitrateIndex - 1];
+        samplesPerFrame = layer == 1 ? 576 : 1152;
+        frameSize = (layer == 1 ? 72000 : 144000) * bitrate / sampleRate + padding;
+      }
+    }
+
+    int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
+    int layerIndex = 3 - layer;
+    header.setValues(
+        version, layerIndex, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
+  }
+
+  /** MPEG audio header version. */
+  public int version;
+  /** MPEG audio layer index, starting at zero. */
+  public int layerIndex;
+  /** Size of the frame associated with this header, in bytes. */
+  public int frameSize;
+  /** Sample rate in samples per second. */
+  public int sampleRate;
+  /** Number of audio channels in the frame. */
+  public int channels;
+  /** Bitrate of the frame in kbit/s. */
+  public int bitrate;
+  /** Number of samples stored in the frame. */
+  public int samplesPerFrame;
+
+  private void setValues(int version, int layerIndex, int frameSize, int sampleRate, int channels,
+      int bitrate, int samplesPerFrame) {
+    this.version = version;
+    this.layerIndex = layerIndex;
+    this.frameSize = frameSize;
+    this.sampleRate = sampleRate;
+    this.channels = channels;
+    this.bitrate = bitrate;
+    this.samplesPerFrame = samplesPerFrame;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
new file mode 100644
index 0000000000..4413edaaa7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+/**
+ * MP3 seeker that uses metadata from a VBRI header.
+ */
+/* package */ final class VbriSeeker implements Mp3Extractor.Seeker {
+
+  private static final int VBRI_HEADER = Util.getIntegerCodeForString("VBRI");
+
+  /**
+   * If {@code frame} contains a VBRI header and it is usable for seeking, returns a
+   * {@link VbriSeeker} for seeking in the containing stream. Otherwise, returns {@code null}, which
+   * indicates that the information in the frame was not a VBRI header, or was unusable for seeking.
+   */
+  public static VbriSeeker create(
+      MpegAudioHeader mpegAudioHeader, ParsableByteArray frame, long position) {
+    long basePosition = position + mpegAudioHeader.frameSize;
+
+    // Read the VBRI header.
+    frame.skipBytes(32);
+    int headerData = frame.readInt();
+    if (headerData != VBRI_HEADER) {
+      return null;
+    }
+    frame.skipBytes(10);
+    int numFrames = frame.readInt();
+    if (numFrames <= 0) {
+      return null;
+    }
+    int sampleRate = mpegAudioHeader.sampleRate;
+    long durationUs = Util.scaleLargeTimestamp(
+        numFrames, 1000000L * (sampleRate >= 32000 ? 1152 : 576), sampleRate);
+    int numEntries = frame.readUnsignedShort();
+    int scale = frame.readUnsignedShort();
+    int entrySize = frame.readUnsignedShort();
+
+    // Read entries in the VBRI header.
+    long[] timesUs = new long[numEntries];
+    long[] offsets = new long[numEntries];
+    long segmentDurationUs = durationUs / numEntries;
+    long now = 0;
+    int segmentIndex = 0;
+    while (segmentIndex < numEntries) {
+      int numBytes;
+      switch (entrySize) {
+        case 1:
+          numBytes = frame.readUnsignedByte();
+          break;
+        case 2:
+          numBytes = frame.readUnsignedShort();
+          break;
+        case 3:
+          numBytes = frame.readUnsignedInt24();
+          break;
+        case 4:
+          numBytes = frame.readUnsignedIntToInt();
+          break;
+        default:
+          return null;
+      }
+      now += segmentDurationUs;
+      timesUs[segmentIndex] = now;
+      position += numBytes * scale;
+      offsets[segmentIndex] = position;
+
+      segmentIndex++;
+    }
+    return new VbriSeeker(timesUs, offsets, basePosition, durationUs);
+  }
+
+  private final long[] timesUs;
+  private final long[] positions;
+  private final long basePosition;
+  private final long durationUs;
+
+  private VbriSeeker(long[] timesUs, long[] positions, long basePosition, long durationUs) {
+    this.timesUs = timesUs;
+    this.positions = positions;
+    this.basePosition = basePosition;
+    this.durationUs = durationUs;
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    int index = Util.binarySearchFloor(timesUs, timeUs, false, false);
+    return basePosition + (index == -1 ? 0L : positions[index]);
+  }
+
+  @Override
+  public long getTimeUs(long position) {
+    return timesUs[Util.binarySearchFloor(positions, position, true, true)];
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
new file mode 100644
index 0000000000..bbc3ae4c8a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+/**
+ * MP3 seeker that uses metadata from a XING header.
+ */
+/* package */ final class XingSeeker implements Mp3Extractor.Seeker {
+
+  private static final int XING_HEADER = Util.getIntegerCodeForString("Xing");
+  private static final int INFO_HEADER = Util.getIntegerCodeForString("Info");
+
+  /**
+   * If {@code frame} contains a XING header and it is usable for seeking, returns a
+   * {@link XingSeeker} for seeking in the containing stream. Otherwise, returns {@code null}, which
+   * indicates that the information in the frame was not a XING header, or was unusable for seeking.
+   */
+  public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArray frame,
+      long position, long inputLength) {
+    int samplesPerFrame = mpegAudioHeader.samplesPerFrame;
+    int sampleRate = mpegAudioHeader.sampleRate;
+    long firstFramePosition = position + mpegAudioHeader.frameSize;
+
+    // Skip to the XING header.
+    int xingBase;
+    if ((mpegAudioHeader.version & 1) == 1) {
+      // MPEG 1.
+      if (mpegAudioHeader.channels != 1) {
+        xingBase = 32;
+      } else {
+        xingBase = 17;
+      }
+    } else {
+      // MPEG 2 or 2.5.
+      if (mpegAudioHeader.channels != 1) {
+        xingBase = 17;
+      } else {
+        xingBase = 9;
+      }
+    }
+    frame.skipBytes(4 + xingBase);
+    int headerData = frame.readInt();
+    if (headerData != XING_HEADER && headerData != INFO_HEADER) {
+      return null;
+    }
+
+    int flags = frame.readInt();
+    // Frame count, size and table of contents are required to use this header.
+    if ((flags & 0x07) != 0x07) {
+      return null;
+    }
+
+    // Read frame count, as (flags & 1) == 1.
+    int frameCount = frame.readUnsignedIntToInt();
+    if (frameCount == 0) {
+      return null;
+    }
+    long durationUs =
+        Util.scaleLargeTimestamp(frameCount, samplesPerFrame * 1000000L, sampleRate);
+
+    // Read size in bytes, as (flags & 2) == 2.
+    long sizeBytes = frame.readUnsignedIntToInt();
+
+    // Read table-of-contents as (flags & 4) == 4.
+    frame.skipBytes(1);
+    long[] tableOfContents = new long[99];
+    for (int i = 0; i < 99; i++) {
+      tableOfContents[i] = frame.readUnsignedByte();
+    }
+
+    // TODO: Handle encoder delay and padding in 3 bytes offset by xingBase + 213 bytes:
+    // delay = ((frame.readUnsignedByte() & 0xFF) << 4) + ((frame.readUnsignedByte() & 0xFF) >>> 4);
+    // padding = ((frame.readUnsignedByte() & 0x0F) << 8) + (frame.readUnsignedByte() & 0xFF);
+    return new XingSeeker(tableOfContents, firstFramePosition, sizeBytes, durationUs, inputLength);
+  }
+
+  /** Entries are in the range [0, 255], but are stored as long integers for convenience. */
+  private final long[] tableOfContents;
+  private final long firstFramePosition;
+  private final long sizeBytes;
+  private final long durationUs;
+  private final long inputLength;
+
+  private XingSeeker(long[] tableOfContents, long firstFramePosition, long sizeBytes,
+      long durationUs, long inputLength) {
+    this.tableOfContents = tableOfContents;
+    this.firstFramePosition = firstFramePosition;
+    this.sizeBytes = sizeBytes;
+    this.durationUs = durationUs;
+    this.inputLength = inputLength;
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    float percent = timeUs * 100f / durationUs;
+    float fx;
+    if (percent <= 0f) {
+      fx = 0f;
+    } else if (percent >= 100f) {
+      fx = 256f;
+    } else {
+      int a = (int) percent;
+      float fa, fb;
+      if (a == 0) {
+        fa = 0f;
+      } else {
+        fa = tableOfContents[a - 1];
+      }
+      if (a < 99) {
+        fb = tableOfContents[a];
+      } else {
+        fb = 256f;
+      }
+      fx = fa + (fb - fa) * (percent - a);
+    }
+
+    long position = (long) ((1f / 256) * fx * sizeBytes) + firstFramePosition;
+    return inputLength != C.LENGTH_UNBOUNDED ? Math.min(position, inputLength - 1) : position;
+  }
+
+  @Override
+  public long getTimeUs(long position) {
+    long offsetByte = 256 * (position - firstFramePosition) / sizeBytes;
+    int previousIndex = Util.binarySearchFloor(tableOfContents, offsetByte, true, false);
+    long previousTime = getTimeUsForTocIndex(previousIndex);
+    if (previousIndex == 98) {
+      return previousTime;
+    }
+
+    // Linearly interpolate the time taking into account the next entry.
+    long previousByte = previousIndex == -1 ? 0 : tableOfContents[previousIndex];
+    long nextByte = tableOfContents[previousIndex + 1];
+    long nextTime = getTimeUsForTocIndex(previousIndex + 1);
+    long timeOffset =
+        (nextTime - previousTime) * (offsetByte - previousByte) / (nextByte - previousByte);
+    return previousTime + timeOffset;
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  /** Returns the time in microseconds corresponding to an index in the table of contents. */
+  private long getTimeUsForTocIndex(int tocIndex) {
+    return durationUs * (tocIndex + 1) / 100;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
new file mode 100644
index 0000000000..e87f71f885
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/* package*/ abstract class Atom {
+
+  /** Size of an atom header, in bytes. */
+  public static final int HEADER_SIZE = 8;
+
+  /** Size of a full atom header, in bytes. */
+  public static final int FULL_HEADER_SIZE = 12;
+
+  /** Size of a long atom header, in bytes. */
+  public static final int LONG_HEADER_SIZE = 16;
+
+  /** Value for the first 32 bits of atomSize when the atom size is actually a long value. */
+  public static final int LONG_SIZE_PREFIX = 1;
+
+  public static final int TYPE_ftyp = Util.getIntegerCodeForString("ftyp");
+  public static final int TYPE_avc1 = Util.getIntegerCodeForString("avc1");
+  public static final int TYPE_avc3 = Util.getIntegerCodeForString("avc3");
+  public static final int TYPE_esds = Util.getIntegerCodeForString("esds");
+  public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
+  public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+  public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
+  public static final int TYPE_dac3 = Util.getIntegerCodeForString("dac3");
+  public static final int TYPE_ec_3 = Util.getIntegerCodeForString("ec-3");
+  public static final int TYPE_dec3 = Util.getIntegerCodeForString("dec3");
+  public static final int TYPE_tfdt = Util.getIntegerCodeForString("tfdt");
+  public static final int TYPE_tfhd = Util.getIntegerCodeForString("tfhd");
+  public static final int TYPE_trex = Util.getIntegerCodeForString("trex");
+  public static final int TYPE_trun = Util.getIntegerCodeForString("trun");
+  public static final int TYPE_sidx = Util.getIntegerCodeForString("sidx");
+  public static final int TYPE_moov = Util.getIntegerCodeForString("moov");
+  public static final int TYPE_mvhd = Util.getIntegerCodeForString("mvhd");
+  public static final int TYPE_trak = Util.getIntegerCodeForString("trak");
+  public static final int TYPE_mdia = Util.getIntegerCodeForString("mdia");
+  public static final int TYPE_minf = Util.getIntegerCodeForString("minf");
+  public static final int TYPE_stbl = Util.getIntegerCodeForString("stbl");
+  public static final int TYPE_avcC = Util.getIntegerCodeForString("avcC");
+  public static final int TYPE_moof = Util.getIntegerCodeForString("moof");
+  public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
+  public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
+  public static final int TYPE_tkhd = Util.getIntegerCodeForString("tkhd");
+  public static final int TYPE_mdhd = Util.getIntegerCodeForString("mdhd");
+  public static final int TYPE_hdlr = Util.getIntegerCodeForString("hdlr");
+  public static final int TYPE_stsd = Util.getIntegerCodeForString("stsd");
+  public static final int TYPE_pssh = Util.getIntegerCodeForString("pssh");
+  public static final int TYPE_sinf = Util.getIntegerCodeForString("sinf");
+  public static final int TYPE_schm = Util.getIntegerCodeForString("schm");
+  public static final int TYPE_schi = Util.getIntegerCodeForString("schi");
+  public static final int TYPE_tenc = Util.getIntegerCodeForString("tenc");
+  public static final int TYPE_encv = Util.getIntegerCodeForString("encv");
+  public static final int TYPE_enca = Util.getIntegerCodeForString("enca");
+  public static final int TYPE_frma = Util.getIntegerCodeForString("frma");
+  public static final int TYPE_saiz = Util.getIntegerCodeForString("saiz");
+  public static final int TYPE_uuid = Util.getIntegerCodeForString("uuid");
+  public static final int TYPE_senc = Util.getIntegerCodeForString("senc");
+  public static final int TYPE_pasp = Util.getIntegerCodeForString("pasp");
+  public static final int TYPE_TTML = Util.getIntegerCodeForString("TTML");
+  public static final int TYPE_vmhd = Util.getIntegerCodeForString("vmhd");
+  public static final int TYPE_smhd = Util.getIntegerCodeForString("smhd");
+  public static final int TYPE_mp4v = Util.getIntegerCodeForString("mp4v");
+  public static final int TYPE_stts = Util.getIntegerCodeForString("stts");
+  public static final int TYPE_stss = Util.getIntegerCodeForString("stss");
+  public static final int TYPE_ctts = Util.getIntegerCodeForString("ctts");
+  public static final int TYPE_stsc = Util.getIntegerCodeForString("stsc");
+  public static final int TYPE_stsz = Util.getIntegerCodeForString("stsz");
+  public static final int TYPE_stco = Util.getIntegerCodeForString("stco");
+  public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
+
+  public final int type;
+
+  Atom(int type) {
+    this.type = type;
+  }
+
+  @Override
+  public String toString() {
+    return getAtomTypeString(type);
+  }
+
+  /** An MP4 atom that is a leaf. */
+  public static final class LeafAtom extends Atom {
+
+    public final ParsableByteArray data;
+
+    public LeafAtom(int type, ParsableByteArray data) {
+      super(type);
+      this.data = data;
+    }
+
+  }
+
+  /** An MP4 atom that has child atoms. */
+  public static final class ContainerAtom extends Atom {
+
+    public final long endByteOffset;
+    public final List<LeafAtom> leafChildren;
+    public final List<ContainerAtom> containerChildren;
+
+    public ContainerAtom(int type, long endByteOffset) {
+      super(type);
+
+      leafChildren = new ArrayList<LeafAtom>();
+      containerChildren = new ArrayList<ContainerAtom>();
+      this.endByteOffset = endByteOffset;
+    }
+
+    public void add(LeafAtom atom) {
+      leafChildren.add(atom);
+    }
+
+    public void add(ContainerAtom atom) {
+      containerChildren.add(atom);
+    }
+
+    public LeafAtom getLeafAtomOfType(int type) {
+      int childrenSize = leafChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        LeafAtom atom = leafChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    public ContainerAtom getContainerAtomOfType(int type) {
+      int childrenSize = containerChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        ContainerAtom atom = containerChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    @Override
+    public String toString() {
+      return getAtomTypeString(type)
+          + " leaves: " + Arrays.toString(leafChildren.toArray(new LeafAtom[0]))
+          + " containers: " + Arrays.toString(containerChildren.toArray(new ContainerAtom[0]));
+    }
+
+  }
+
+  /**
+   * Parses the version number out of the additional integer component of a full atom.
+   */
+  public static int parseFullAtomVersion(int fullAtomInt) {
+    return 0x000000FF & (fullAtomInt >> 24);
+  }
+
+  /**
+   * Parses the atom flags out of the additional integer component of a full atom.
+   */
+  public static int parseFullAtomFlags(int fullAtomInt) {
+    return 0x00FFFFFF & fullAtomInt;
+  }
+
+  /**
+   * Converts a numeric atom type to the corresponding four character string.
+   *
+   * @param type The numeric atom type.
+   * @return The corresponding four character string.
+   */
+  public static String getAtomTypeString(int type) {
+    return "" + (char) (type >> 24)
+        + (char) ((type >> 16) & 0xFF)
+        + (char) ((type >> 8) & 0xFF)
+        + (char) (type & 0xFF);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
similarity index 68%
rename from library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 4443e573c9..42c3f2e70e 100644
--- a/library/src/main/java/com/google/android/exoplayer/mp4/CommonMp4AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
+import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.H264Util;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
@@ -31,26 +32,22 @@
 import java.util.List;
 
 /** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
-public final class CommonMp4AtomParsers {
-
-  /** Channel counts for AC-3 audio, indexed by acmod. (See ETSI TS 102 366.) */
-  private static final int[] AC3_CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
-  /** Nominal bitrates for AC-3 audio in kbps, indexed by bit_rate_code. (See ETSI TS 102 366.) */
-  private static final int[] AC3_BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
-      192, 224, 256, 320, 384, 448, 512, 576, 640};
+/* package */ final class AtomParsers {
 
   /**
-   * Parses a trak atom (defined in 14496-12)
+   * Parses a trak atom (defined in 14496-12).
    *
    * @param trak Atom to parse.
    * @param mvhd Movie header atom, used to get the timescale.
-   * @return A {@link Track} instance.
+   * @return A {@link Track} instance, or {@code null} if the track's type isn't supported.
    */
   public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
-    Assertions.checkState(trackType == Track.TYPE_AUDIO || trackType == Track.TYPE_VIDEO
-        || trackType == Track.TYPE_TEXT || trackType == Track.TYPE_TIME_CODE);
+    if (trackType != Track.TYPE_AUDIO && trackType != Track.TYPE_VIDEO
+        && trackType != Track.TYPE_TEXT && trackType != Track.TYPE_TIME_CODE) {
+      return null;
+    }
 
     Pair<Integer, Long> header = parseTkhd(trak.getLeafAtomOfType(Atom.TYPE_tkhd).data);
     int id = header.first;
@@ -66,10 +63,9 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
         .getContainerAtomOfType(Atom.TYPE_stbl);
 
     long mediaTimescale = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
-    Pair<MediaFormat, TrackEncryptionBox[]> sampleDescriptions =
-        parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data);
-    return new Track(id, trackType, mediaTimescale, durationUs, sampleDescriptions.first,
-          sampleDescriptions.second);
+    StsdDataHolder stsdData = parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data, durationUs);
+    return new Track(id, trackType, mediaTimescale, durationUs, stsdData.mediaFormat,
+        stsdData.trackEncryptionBoxes, stsdData.nalUnitLengthFieldLength);
   }
 
   /**
@@ -79,7 +75,7 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
    * @param stblAtom stbl (sample table) atom to parse.
    * @return Sample table described by the stbl atom.
    */
-  public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom) {
+  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom) {
     // Array of sample sizes.
     ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
 
@@ -102,7 +98,7 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
     ParsableByteArray ctts = cttsAtom != null ? cttsAtom.data : null;
 
     // Skip full atom.
-    stsz.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    stsz.setPosition(Atom.FULL_HEADER_SIZE);
     int fixedSampleSize = stsz.readUnsignedIntToInt();
     int sampleCount = stsz.readUnsignedIntToInt();
 
@@ -112,14 +108,14 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
     int[] flags = new int[sampleCount];
 
     // Prepare to read chunk offsets.
-    chunkOffsets.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
     int chunkCount = chunkOffsets.readUnsignedIntToInt();
 
-    stsc.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    stsc.setPosition(Atom.FULL_HEADER_SIZE);
     int remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt() - 1;
     Assertions.checkState(stsc.readInt() == 1, "stsc first chunk must be 1");
     int samplesPerChunk = stsc.readUnsignedIntToInt();
-    stsc.skip(4); // Skip the sample description index.
+    stsc.skipBytes(4); // Skip the sample description index.
     int nextSamplesPerChunkChangeChunkIndex = -1;
     if (remainingSamplesPerChunkChanges > 0) {
       // Store the chunk index when the samples-per-chunk will next change.
@@ -130,28 +126,31 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
     int remainingSamplesInChunk = samplesPerChunk;
 
     // Prepare to read sample timestamps.
-    stts.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+    stts.setPosition(Atom.FULL_HEADER_SIZE);
     int remainingTimestampDeltaChanges = stts.readUnsignedIntToInt() - 1;
     int remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
     int timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
 
     // Prepare to read sample timestamp offsets, if ctts is present.
-    boolean cttsHasSignedOffsets = false;
     int remainingSamplesAtTimestampOffset = 0;
     int remainingTimestampOffsetChanges = 0;
     int timestampOffset = 0;
     if (ctts != null) {
-      ctts.setPosition(Mp4Util.ATOM_HEADER_SIZE);
-      cttsHasSignedOffsets = Mp4Util.parseFullAtomVersion(ctts.readInt()) == 1;
+      ctts.setPosition(Atom.FULL_HEADER_SIZE);
       remainingTimestampOffsetChanges = ctts.readUnsignedIntToInt() - 1;
       remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
-      timestampOffset = cttsHasSignedOffsets ? ctts.readInt() : ctts.readUnsignedIntToInt();
+      // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers in
+      // version 0 ctts boxes, however some streams violate the spec and use signed integers
+      // instead. It's safe to always parse sample offsets as signed integers here, because
+      // unsigned integers will still be parsed correctly (unless their top bit is set, which
+      // is never true in practice because sample offsets are always small).
+      timestampOffset = ctts.readInt();
     }
 
     int nextSynchronizationSampleIndex = -1;
     int remainingSynchronizationSamples = 0;
     if (stss != null) {
-      stss.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+      stss.setPosition(Atom.FULL_HEADER_SIZE);
       remainingSynchronizationSamples = stss.readUnsignedIntToInt();
       nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
     }
@@ -194,7 +193,8 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
         remainingSamplesAtTimestampOffset--;
         if (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
           remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
-          timestampOffset = cttsHasSignedOffsets ? ctts.readInt() : ctts.readUnsignedIntToInt();
+          // Read a signed offset even for version 0 ctts boxes (see comment above).
+          timestampOffset = ctts.readInt();
           remainingTimestampOffsetChanges--;
         }
       }
@@ -214,7 +214,7 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
         // Change the samples-per-chunk if required.
         if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
           samplesPerChunk = stsc.readUnsignedIntToInt();
-          stsc.skip(4); // Skip the sample description index.
+          stsc.skipBytes(4); // Skip the sample description index.
           remainingSamplesPerChunkChanges--;
           if (remainingSamplesPerChunkChanges > 0) {
             nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
@@ -239,7 +239,7 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
     Assertions.checkArgument(remainingSamplesInChunk == 0);
     Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
     Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
-    return new Mp4TrackSampleTable(offsets, sizes, timestamps, flags);
+    return new TrackSampleTable(offsets, sizes, timestamps, flags);
   }
 
   /**
@@ -249,12 +249,12 @@ public static Mp4TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stbl
    * @return Timescale for the movie.
    */
   private static long parseMvhd(ParsableByteArray mvhd) {
-    mvhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    mvhd.setPosition(Atom.HEADER_SIZE);
 
     int fullAtom = mvhd.readInt();
-    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+    int version = Atom.parseFullAtomVersion(fullAtom);
 
-    mvhd.skip(version == 0 ? 8 : 16);
+    mvhd.skipBytes(version == 0 ? 8 : 16);
 
     return mvhd.readUnsignedInt();
   }
@@ -266,14 +266,14 @@ private static long parseMvhd(ParsableByteArray mvhd) {
    *     the movie header box). The duration is set to -1 if the duration is unspecified.
    */
   private static Pair<Integer, Long> parseTkhd(ParsableByteArray tkhd) {
-    tkhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    tkhd.setPosition(Atom.HEADER_SIZE);
     int fullAtom = tkhd.readInt();
-    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+    int version = Atom.parseFullAtomVersion(fullAtom);
 
-    tkhd.skip(version == 0 ? 8 : 16);
+    tkhd.skipBytes(version == 0 ? 8 : 16);
 
     int trackId = tkhd.readInt();
-    tkhd.skip(4);
+    tkhd.skipBytes(4);
 
     boolean durationUnknown = true;
     int durationPosition = tkhd.getPosition();
@@ -286,7 +286,7 @@ private static long parseMvhd(ParsableByteArray mvhd) {
     }
     long duration;
     if (durationUnknown) {
-      tkhd.skip(durationByteCount);
+      tkhd.skipBytes(durationByteCount);
       duration = -1;
     } else {
       duration = version == 0 ? tkhd.readUnsignedInt() : tkhd.readUnsignedLongToLong();
@@ -302,7 +302,7 @@ private static long parseMvhd(ParsableByteArray mvhd) {
    * @return The track type.
    */
   private static int parseHdlr(ParsableByteArray hdlr) {
-    hdlr.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE + 4);
+    hdlr.setPosition(Atom.FULL_HEADER_SIZE + 4);
     return hdlr.readInt();
   }
 
@@ -313,19 +313,18 @@ private static int parseHdlr(ParsableByteArray hdlr) {
    * @return The media timescale, defined as the number of time units that pass in one second.
    */
   private static long parseMdhd(ParsableByteArray mdhd) {
-    mdhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    mdhd.setPosition(Atom.HEADER_SIZE);
     int fullAtom = mdhd.readInt();
-    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+    int version = Atom.parseFullAtomVersion(fullAtom);
 
-    mdhd.skip(version == 0 ? 8 : 16);
+    mdhd.skipBytes(version == 0 ? 8 : 16);
     return mdhd.readUnsignedInt();
   }
 
-  private static Pair<MediaFormat, TrackEncryptionBox[]> parseStsd(ParsableByteArray stsd) {
-    stsd.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+  private static StsdDataHolder parseStsd(ParsableByteArray stsd, long durationUs) {
+    stsd.setPosition(Atom.FULL_HEADER_SIZE);
     int numberOfEntries = stsd.readInt();
-    MediaFormat mediaFormat = null;
-    TrackEncryptionBox[] trackEncryptionBoxes = new TrackEncryptionBox[numberOfEntries];
+    StsdDataHolder holder = new StsdDataHolder(numberOfEntries);
     for (int i = 0; i < numberOfEntries; i++) {
       int childStartPosition = stsd.getPosition();
       int childAtomSize = stsd.readInt();
@@ -333,39 +332,34 @@ private static long parseMdhd(ParsableByteArray mdhd) {
       int childAtomType = stsd.readInt();
       if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
           || childAtomType == Atom.TYPE_encv) {
-        Pair<MediaFormat, TrackEncryptionBox> avc =
-            parseAvcFromParent(stsd, childStartPosition, childAtomSize);
-        mediaFormat = avc.first;
-        trackEncryptionBoxes[i] = avc.second;
+        parseAvcFromParent(stsd, childStartPosition, childAtomSize, durationUs, holder, i);
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3) {
-        Pair<MediaFormat, TrackEncryptionBox> audioSampleEntry =
-            parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize);
-        mediaFormat = audioSampleEntry.first;
-        trackEncryptionBoxes[i] = audioSampleEntry.second;
+        parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, durationUs,
+            holder, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
-        mediaFormat = MediaFormat.createTtmlFormat();
+        holder.mediaFormat = MediaFormat.createTtmlFormat();
       } else if (childAtomType == Atom.TYPE_mp4v) {
-        mediaFormat = parseMp4vFromParent(stsd, childStartPosition, childAtomSize);
+        holder.mediaFormat = parseMp4vFromParent(stsd, childStartPosition, childAtomSize,
+            durationUs);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
-    return Pair.create(mediaFormat, trackEncryptionBoxes);
+    return holder;
   }
 
   /** Returns the media format for an avc1 box. */
-  private static Pair<MediaFormat, TrackEncryptionBox> parseAvcFromParent(ParsableByteArray parent,
-      int position, int size) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+  private static void parseAvcFromParent(ParsableByteArray parent, int position, int size,
+      long durationUs, StsdDataHolder out, int entryIndex) {
+    parent.setPosition(position + Atom.HEADER_SIZE);
 
-    parent.skip(24);
+    parent.skipBytes(24);
     int width = parent.readUnsignedShort();
     int height = parent.readUnsignedShort();
     float pixelWidthHeightRatio = 1;
-    parent.skip(50);
+    parent.skipBytes(50);
 
     List<byte[]> initializationData = null;
-    TrackEncryptionBox trackEncryptionBox = null;
     int childPosition = parent.getPosition();
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
@@ -378,27 +372,28 @@ private static long parseMdhd(ParsableByteArray mdhd) {
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
       if (childAtomType == Atom.TYPE_avcC) {
-        initializationData = parseAvcCFromParent(parent, childStartPosition);
+        Pair<List<byte[]>, Integer> avcCData = parseAvcCFromParent(parent, childStartPosition);
+        initializationData = avcCData.first;
+        out.nalUnitLengthFieldLength = avcCData.second;
       } else if (childAtomType == Atom.TYPE_sinf) {
-        trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
+        out.trackEncryptionBoxes[entryIndex] =
+            parseSinfFromParent(parent, childStartPosition, childAtomSize);
       } else if (childAtomType == Atom.TYPE_pasp) {
         pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
       }
       childPosition += childAtomSize;
     }
 
-    MediaFormat format = MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        width, height, pixelWidthHeightRatio, initializationData);
-    return Pair.create(format, trackEncryptionBox);
+    out.mediaFormat = MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
+        durationUs, width, height, pixelWidthHeightRatio, initializationData);
   }
 
-  private static List<byte[]> parseAvcCFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE + 4);
+  private static Pair<List<byte[]>, Integer> parseAvcCFromParent(ParsableByteArray parent,
+      int position) {
+    parent.setPosition(position + Atom.HEADER_SIZE + 4);
     // Start of the AVCDecoderConfigurationRecord (defined in 14496-15)
-    int nalUnitLength = (parent.readUnsignedByte() & 0x3) + 1;
-    if (nalUnitLength != 4) {
-      // readSample currently relies on a nalUnitLength of 4.
-      // TODO: Consider handling the case where it isn't.
+    int nalUnitLengthFieldLength = (parent.readUnsignedByte() & 0x3) + 1;
+    if (nalUnitLengthFieldLength == 3) {
       throw new IllegalStateException();
     }
     List<byte[]> initializationData = new ArrayList<byte[]>();
@@ -406,18 +401,18 @@ private static long parseMdhd(ParsableByteArray mdhd) {
     // expose the AVC profile and level somewhere useful; Most likely in MediaFormat.
     int numSequenceParameterSets = parent.readUnsignedByte() & 0x1F;
     for (int j = 0; j < numSequenceParameterSets; j++) {
-      initializationData.add(Mp4Util.parseChildNalUnit(parent));
+      initializationData.add(H264Util.parseChildNalUnit(parent));
     }
     int numPictureParameterSets = parent.readUnsignedByte();
     for (int j = 0; j < numPictureParameterSets; j++) {
-      initializationData.add(Mp4Util.parseChildNalUnit(parent));
+      initializationData.add(H264Util.parseChildNalUnit(parent));
     }
-    return initializationData;
+    return Pair.create(initializationData, nalUnitLengthFieldLength);
   }
 
   private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
       int size) {
-    int childPosition = position + Mp4Util.ATOM_HEADER_SIZE;
+    int childPosition = position + Atom.HEADER_SIZE;
 
     TrackEncryptionBox trackEncryptionBox = null;
     while (childPosition - position < size) {
@@ -427,7 +422,7 @@ private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent,
       if (childAtomType == Atom.TYPE_frma) {
         parent.readInt(); // dataFormat.
       } else if (childAtomType == Atom.TYPE_schm) {
-        parent.skip(4);
+        parent.skipBytes(4);
         parent.readInt(); // schemeType. Expect cenc
         parent.readInt(); // schemeVersion. Expect 0x00010000
       } else if (childAtomType == Atom.TYPE_schi) {
@@ -440,7 +435,7 @@ private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent,
   }
 
   private static float parsePaspFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+    parent.setPosition(position + Atom.HEADER_SIZE);
     int hSpacing = parent.readUnsignedIntToInt();
     int vSpacing = parent.readUnsignedIntToInt();
     return (float) hSpacing / vSpacing;
@@ -448,13 +443,13 @@ private static float parsePaspFromParent(ParsableByteArray parent, int position)
 
   private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
       int size) {
-    int childPosition = position + Mp4Util.ATOM_HEADER_SIZE;
+    int childPosition = position + Atom.HEADER_SIZE;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
       int childAtomSize = parent.readInt();
       int childAtomType = parent.readInt();
       if (childAtomType == Atom.TYPE_tenc) {
-        parent.skip(4);
+        parent.skipBytes(4);
         int firstInt = parent.readInt();
         boolean defaultIsEncrypted = (firstInt >> 8) == 1;
         int defaultInitVectorSize = firstInt & 0xFF;
@@ -468,14 +463,14 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
   }
 
   /** Returns the media format for an mp4v box. */
-  private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
-      int position, int size) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
+  private static MediaFormat parseMp4vFromParent(ParsableByteArray parent, int position, int size,
+      long durationUs) {
+    parent.setPosition(position + Atom.HEADER_SIZE);
 
-    parent.skip(24);
+    parent.skipBytes(24);
     int width = parent.readUnsignedShort();
     int height = parent.readUnsignedShort();
-    parent.skip(50);
+    parent.skipBytes(50);
 
     List<byte[]> initializationData = new ArrayList<byte[]>(1);
     int childPosition = parent.getPosition();
@@ -492,21 +487,19 @@ private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
     }
 
     return MediaFormat.createVideoFormat(
-        MimeTypes.VIDEO_MP4V, MediaFormat.NO_VALUE, width, height, initializationData);
+        MimeTypes.VIDEO_MP4V, MediaFormat.NO_VALUE, durationUs, width, height, initializationData);
   }
 
-  private static Pair<MediaFormat, TrackEncryptionBox> parseAudioSampleEntry(
-      ParsableByteArray parent, int atomType, int position, int size) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
-    parent.skip(16);
+  private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int size, long durationUs, StsdDataHolder out, int entryIndex) {
+    parent.setPosition(position + Atom.HEADER_SIZE);
+    parent.skipBytes(16);
     int channelCount = parent.readUnsignedShort();
     int sampleSize = parent.readUnsignedShort();
-    parent.skip(4);
+    parent.skipBytes(4);
     int sampleRate = parent.readUnsignedFixedPoint1616();
-    int bitrate = MediaFormat.NO_VALUE;
 
     byte[] initializationData = null;
-    TrackEncryptionBox trackEncryptionBox = null;
     int childPosition = parent.getPosition();
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
@@ -524,27 +517,24 @@ private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
           sampleRate = audioSpecificConfig.first;
           channelCount = audioSpecificConfig.second;
         } else if (childAtomType == Atom.TYPE_sinf) {
-          trackEncryptionBox = parseSinfFromParent(parent, childStartPosition, childAtomSize);
+          out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childStartPosition,
+              childAtomSize);
         }
       } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
         // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
-        Ac3Format ac3Format =
-            parseAc3SpecificBoxFromParent(parent, childStartPosition);
-        if (ac3Format != null) {
-          sampleRate = ac3Format.sampleRate;
-          channelCount = ac3Format.channelCount;
-          bitrate = ac3Format.bitrate;
-        }
-
-        // TODO: Add support for encrypted AC-3.
-        trackEncryptionBox = null;
-      } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
-        sampleRate = parseEc3SpecificBoxFromParent(parent, childStartPosition);
-        trackEncryptionBox = null;
+        // TODO: Add support for encryption (by setting out.trackEncryptionBoxes).
+        parent.setPosition(Atom.HEADER_SIZE + childStartPosition);
+        out.mediaFormat = Ac3Util.parseAnnexFAc3Format(parent);
+        return;
+      } else if  (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
+        parent.setPosition(Atom.HEADER_SIZE + childStartPosition);
+        out.mediaFormat = Ac3Util.parseAnnexFEAc3Format(parent);
+        return;
       }
       childPosition += childAtomSize;
     }
 
+    // Set the MIME type for ac-3/ec-3 atoms even if the dac3/dec3 child atom is missing.
     String mimeType;
     if (atomType == Atom.TYPE_ac_3) {
       mimeType = MimeTypes.AUDIO_AC3;
@@ -554,44 +544,43 @@ private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
       mimeType = MimeTypes.AUDIO_AAC;
     }
 
-    MediaFormat format = MediaFormat.createAudioFormat(
-        mimeType, sampleSize, channelCount, sampleRate, bitrate,
+    out.mediaFormat = MediaFormat.createAudioFormat(mimeType, sampleSize, durationUs, channelCount,
+        sampleRate,
         initializationData == null ? null : Collections.singletonList(initializationData));
-    return Pair.create(format, trackEncryptionBox);
   }
 
   /** Returns codec-specific initialization data contained in an esds box. */
   private static byte[] parseEsdsFromParent(ParsableByteArray parent, int position) {
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE + 4);
+    parent.setPosition(position + Atom.HEADER_SIZE + 4);
     // Start of the ES_Descriptor (defined in 14496-1)
-    parent.skip(1); // ES_Descriptor tag
+    parent.skipBytes(1); // ES_Descriptor tag
     int varIntByte = parent.readUnsignedByte();
     while (varIntByte > 127) {
       varIntByte = parent.readUnsignedByte();
     }
-    parent.skip(2); // ES_ID
+    parent.skipBytes(2); // ES_ID
 
     int flags = parent.readUnsignedByte();
     if ((flags & 0x80 /* streamDependenceFlag */) != 0) {
-      parent.skip(2);
+      parent.skipBytes(2);
     }
     if ((flags & 0x40 /* URL_Flag */) != 0) {
-      parent.skip(parent.readUnsignedShort());
+      parent.skipBytes(parent.readUnsignedShort());
     }
     if ((flags & 0x20 /* OCRstreamFlag */) != 0) {
-      parent.skip(2);
+      parent.skipBytes(2);
     }
 
     // Start of the DecoderConfigDescriptor (defined in 14496-1)
-    parent.skip(1); // DecoderConfigDescriptor tag
+    parent.skipBytes(1); // DecoderConfigDescriptor tag
     varIntByte = parent.readUnsignedByte();
     while (varIntByte > 127) {
       varIntByte = parent.readUnsignedByte();
     }
-    parent.skip(13);
+    parent.skipBytes(13);
 
     // Start of AudioSpecificConfig (defined in 14496-3)
-    parent.skip(1); // AudioSpecificConfig tag
+    parent.skipBytes(1); // AudioSpecificConfig tag
     varIntByte = parent.readUnsignedByte();
     int varInt = varIntByte & 0x7F;
     while (varIntByte > 127) {
@@ -604,66 +593,23 @@ private static MediaFormat parseMp4vFromParent(ParsableByteArray parent,
     return initializationData;
   }
 
-  private static Ac3Format parseAc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
-    // Start of the dac3 atom (defined in ETSI TS 102 366)
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
-
-    // fscod (sample rate code)
-    int fscod = (parent.readUnsignedByte() & 0xC0) >> 6;
-    int sampleRate;
-    switch (fscod) {
-      case 0:
-        sampleRate = 48000;
-        break;
-      case 1:
-        sampleRate = 44100;
-        break;
-      case 2:
-        sampleRate = 32000;
-        break;
-      default:
-        // TODO: The decoder should not use this stream.
-        return null;
-    }
-
-    int nextByte = parent.readUnsignedByte();
-
-    // Map acmod (audio coding mode) onto a channel count.
-    int channelCount = AC3_CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
-
-    // lfeon (low frequency effects on)
-    if ((nextByte & 0x04) != 0) {
-      channelCount++;
-    }
-
-    // Map bit_rate_code onto a bitrate in kbit/s.
-    int bitrate = AC3_BITRATES[((nextByte & 0x03) << 3) + (parent.readUnsignedByte() >> 5)];
-
-    return new Ac3Format(channelCount, sampleRate, bitrate);
-  }
-
-  private static int parseEc3SpecificBoxFromParent(ParsableByteArray parent, int position) {
-    // Start of the dec3 atom (defined in ETSI TS 102 366)
-    parent.setPosition(position + Mp4Util.ATOM_HEADER_SIZE);
-    // TODO: Implement parsing for enhanced AC-3 with multiple sub-streams.
-    return 0;
-  }
-
-  private CommonMp4AtomParsers() {
+  private AtomParsers() {
     // Prevent instantiation.
   }
 
-  /** Represents the format for AC-3 audio. */
-  private static final class Ac3Format {
+  /**
+   * Holds data parsed from an stsd atom and its children.
+   */
+  private static final class StsdDataHolder {
+
+    public final TrackEncryptionBox[] trackEncryptionBoxes;
 
-    public final int channelCount;
-    public final int sampleRate;
-    public final int bitrate;
+    public MediaFormat mediaFormat;
+    public int nalUnitLengthFieldLength;
 
-    public Ac3Format(int channelCount, int sampleRate, int bitrate) {
-      this.channelCount = channelCount;
-      this.sampleRate = sampleRate;
-      this.bitrate = bitrate;
+    public StsdDataHolder(int numberOfEntries) {
+      trackEncryptionBoxes = new TrackEncryptionBox[numberOfEntries];
+      nalUnitLengthFieldLength = -1;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/DefaultSampleValues.java
similarity index 94%
rename from library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/DefaultSampleValues.java
index da20828100..528d643811 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/DefaultSampleValues.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/DefaultSampleValues.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.chunk.parser.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 /* package */ final class DefaultSampleValues {
 
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
similarity index 53%
rename from library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index d6229cf805..92543f3493 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -13,36 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.chunk.parser.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.ParserException;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.chunk.parser.Extractor;
-import com.google.android.exoplayer.chunk.parser.SegmentIndex;
-import com.google.android.exoplayer.mp4.Atom;
-import com.google.android.exoplayer.mp4.Atom.ContainerAtom;
-import com.google.android.exoplayer.mp4.Atom.LeafAtom;
-import com.google.android.exoplayer.mp4.CommonMp4AtomParsers;
-import com.google.android.exoplayer.mp4.Mp4Util;
-import com.google.android.exoplayer.mp4.Track;
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ChunkIndex;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
+import com.google.android.exoplayer.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.H264Util;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
-import android.annotation.SuppressLint;
-import android.media.MediaCodec;
-import android.media.MediaExtractor;
-
-import java.nio.ByteBuffer;
+import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import java.util.Stack;
 import java.util.UUID;
 
@@ -62,8 +53,6 @@
    */
   public static final int WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME = 1;
 
-  private static final int READ_TERMINATING_RESULTS = RESULT_NEED_MORE_DATA | RESULT_END_OF_STREAM
-      | RESULT_READ_SAMPLE | RESULT_NEED_SAMPLE_HOLDER;
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
 
@@ -71,61 +60,16 @@
   private static final int STATE_READING_ATOM_HEADER = 0;
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_ENCRYPTION_DATA = 2;
-  private static final int STATE_READING_SAMPLE = 3;
-
-  // Atoms that the parser cares about
-  private static final Set<Integer> PARSED_ATOMS;
-  static {
-    HashSet<Integer> parsedAtoms = new HashSet<Integer>();
-    parsedAtoms.add(Atom.TYPE_avc1);
-    parsedAtoms.add(Atom.TYPE_avc3);
-    parsedAtoms.add(Atom.TYPE_esds);
-    parsedAtoms.add(Atom.TYPE_hdlr);
-    parsedAtoms.add(Atom.TYPE_mdat);
-    parsedAtoms.add(Atom.TYPE_mdhd);
-    parsedAtoms.add(Atom.TYPE_moof);
-    parsedAtoms.add(Atom.TYPE_moov);
-    parsedAtoms.add(Atom.TYPE_mp4a);
-    parsedAtoms.add(Atom.TYPE_mvhd);
-    parsedAtoms.add(Atom.TYPE_sidx);
-    parsedAtoms.add(Atom.TYPE_stsd);
-    parsedAtoms.add(Atom.TYPE_tfdt);
-    parsedAtoms.add(Atom.TYPE_tfhd);
-    parsedAtoms.add(Atom.TYPE_tkhd);
-    parsedAtoms.add(Atom.TYPE_traf);
-    parsedAtoms.add(Atom.TYPE_trak);
-    parsedAtoms.add(Atom.TYPE_trex);
-    parsedAtoms.add(Atom.TYPE_trun);
-    parsedAtoms.add(Atom.TYPE_mvex);
-    parsedAtoms.add(Atom.TYPE_mdia);
-    parsedAtoms.add(Atom.TYPE_minf);
-    parsedAtoms.add(Atom.TYPE_stbl);
-    parsedAtoms.add(Atom.TYPE_pssh);
-    parsedAtoms.add(Atom.TYPE_saiz);
-    parsedAtoms.add(Atom.TYPE_uuid);
-    parsedAtoms.add(Atom.TYPE_senc);
-    parsedAtoms.add(Atom.TYPE_pasp);
-    PARSED_ATOMS = Collections.unmodifiableSet(parsedAtoms);
-  }
-
-  // Atoms that the parser considers to be containers
-  private static final Set<Integer> CONTAINER_TYPES;
-  static {
-    HashSet<Integer> atomContainerTypes = new HashSet<Integer>();
-    atomContainerTypes.add(Atom.TYPE_moov);
-    atomContainerTypes.add(Atom.TYPE_trak);
-    atomContainerTypes.add(Atom.TYPE_mdia);
-    atomContainerTypes.add(Atom.TYPE_minf);
-    atomContainerTypes.add(Atom.TYPE_stbl);
-    atomContainerTypes.add(Atom.TYPE_avcC);
-    atomContainerTypes.add(Atom.TYPE_moof);
-    atomContainerTypes.add(Atom.TYPE_traf);
-    atomContainerTypes.add(Atom.TYPE_mvex);
-    CONTAINER_TYPES = Collections.unmodifiableSet(atomContainerTypes);
-  }
+  private static final int STATE_READING_SAMPLE_START = 3;
+  private static final int STATE_READING_SAMPLE_CONTINUE = 4;
 
   private final int workaroundFlags;
 
+  // Temporary arrays.
+  private final ParsableByteArray nalStartCode;
+  private final ParsableByteArray nalLength;
+  private final ParsableByteArray encryptionSignalByte;
+
   // Parser state
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
@@ -133,23 +77,24 @@
   private final TrackFragment fragmentRun;
 
   private int parserState;
-  private int atomBytesRead;
   private int rootAtomBytesRead;
   private int atomType;
   private int atomSize;
   private ParsableByteArray atomData;
 
-  private int pendingSeekTimeMs;
   private int sampleIndex;
-  private int pendingSeekSyncSampleIndex;
-  private int lastSyncSampleIndex;
+  private int sampleSize;
+  private int sampleBytesWritten;
+  private int sampleCurrentNalBytesRemaining;
 
-  // Data parsed from moov and sidx atoms
-  private final HashMap<UUID, byte[]> psshData;
-  private SegmentIndex segmentIndex;
+  // Data parsed from moov atom.
   private Track track;
   private DefaultSampleValues extendsDefaults;
 
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+  private TrackOutput trackOutput;
+
   public FragmentedMp4Extractor() {
     this(0);
   }
@@ -160,16 +105,22 @@ public FragmentedMp4Extractor() {
    */
   public FragmentedMp4Extractor(int workaroundFlags) {
     this.workaroundFlags = workaroundFlags;
-    parserState = STATE_READING_ATOM_HEADER;
-    atomHeader = new ParsableByteArray(Mp4Util.ATOM_HEADER_SIZE);
+    atomHeader = new ParsableByteArray(Atom.HEADER_SIZE);
+    nalStartCode = new ParsableByteArray(H264Util.NAL_START_CODE);
+    nalLength = new ParsableByteArray(4);
+    encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<ContainerAtom>();
     fragmentRun = new TrackFragment();
-    psshData = new HashMap<UUID, byte[]>();
+    parserState = STATE_READING_ATOM_HEADER;
   }
 
   /**
    * Sideloads track information into the extractor.
+   * <p>
+   * Should be called before {@link #read(ExtractorInput, PositionHolder)} in the case that the
+   * extractor will not receive a moov atom in the input data, from which track information would
+   * normally be parsed.
    *
    * @param track The track to sideload.
    */
@@ -179,234 +130,161 @@ public void setTrack(Track track) {
   }
 
   @Override
-  public Map<UUID, byte[]> getPsshInfo() {
-    return psshData.isEmpty() ? null : psshData;
-  }
-
-  @Override
-  public SegmentIndex getIndex() {
-    return segmentIndex;
-  }
-
-  @Override
-  public boolean hasRelativeIndexOffsets() {
-    return true;
-  }
-
-  @Override
-  public MediaFormat getFormat() {
-    return track == null ? null : track.mediaFormat;
-  }
-
-  @Override
-  public long getDurationUs() {
-    return track == null ? C.UNKNOWN_TIME_US : track.durationUs;
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+    trackOutput = output.track(0);
+    extractorOutput.endTracks();
   }
 
   @Override
-  public int read(NonBlockingInputStream inputStream, SampleHolder out)
-      throws ParserException {
-    try {
-      int results = 0;
-      while ((results & READ_TERMINATING_RESULTS) == 0) {
-        switch (parserState) {
-          case STATE_READING_ATOM_HEADER:
-            results |= readAtomHeader(inputStream);
-            break;
-          case STATE_READING_ATOM_PAYLOAD:
-            results |= readAtomPayload(inputStream);
-            break;
-          case STATE_READING_ENCRYPTION_DATA:
-            results |= readEncryptionData(inputStream);
-            break;
-          default:
-            results |= readOrSkipSample(inputStream, out);
-            break;
-        }
-      }
-      return results;
-    } catch (Exception e) {
-      throw new ParserException(e);
-    }
+  public void seek() {
+    containerAtoms.clear();
+    rootAtomBytesRead = 0;
+    parserState = STATE_READING_ATOM_HEADER;
   }
 
   @Override
-  public boolean seekTo(long seekTimeUs, boolean allowNoop) {
-    pendingSeekTimeMs = (int) (seekTimeUs / 1000);
-    if (allowNoop && fragmentRun != null && fragmentRun.length > 0
-        && pendingSeekTimeMs >= fragmentRun.getSamplePresentationTime(0)
-        && pendingSeekTimeMs <= fragmentRun.getSamplePresentationTime(fragmentRun.length - 1)) {
-      int sampleIndexFound = 0;
-      int syncSampleIndexFound = 0;
-      for (int i = 0; i < fragmentRun.length; i++) {
-        if (fragmentRun.getSamplePresentationTime(i) <= pendingSeekTimeMs) {
-          if (fragmentRun.sampleIsSyncFrameTable[i]) {
-            syncSampleIndexFound = i;
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    while (true) {
+      switch (parserState) {
+        case STATE_READING_ATOM_HEADER:
+          if (!readAtomHeader(input)) {
+            return Extractor.RESULT_END_OF_INPUT;
+          }
+          break;
+        case STATE_READING_ATOM_PAYLOAD:
+          readAtomPayload(input);
+          break;
+        case STATE_READING_ENCRYPTION_DATA:
+          readEncryptionData(input);
+          break;
+        default:
+          if (readSample(input)) {
+            return RESULT_CONTINUE;
           }
-          sampleIndexFound = i;
-        }
-      }
-      if (syncSampleIndexFound == lastSyncSampleIndex && sampleIndexFound >= sampleIndex) {
-        pendingSeekTimeMs = 0;
-        return false;
       }
     }
-    containerAtoms.clear();
-    enterState(STATE_READING_ATOM_HEADER);
-    return true;
   }
 
-  private void enterState(int state) {
-    switch (state) {
-      case STATE_READING_ATOM_HEADER:
-        atomBytesRead = 0;
-        if (containerAtoms.isEmpty()) {
-          rootAtomBytesRead = 0;
-        }
-        break;
-    }
-    parserState = state;
-  }
-
-  private int readAtomHeader(NonBlockingInputStream inputStream) {
-    int remainingBytes = Mp4Util.ATOM_HEADER_SIZE - atomBytesRead;
-    int bytesRead = inputStream.read(atomHeader.data, atomBytesRead, remainingBytes);
-    if (bytesRead == -1) {
-      return RESULT_END_OF_STREAM;
-    }
-    rootAtomBytesRead += bytesRead;
-    atomBytesRead += bytesRead;
-    if (atomBytesRead != Mp4Util.ATOM_HEADER_SIZE) {
-      return RESULT_NEED_MORE_DATA;
+  private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
+    if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
+      return false;
     }
 
+    rootAtomBytesRead += Atom.HEADER_SIZE;
     atomHeader.setPosition(0);
     atomSize = atomHeader.readInt();
     atomType = atomHeader.readInt();
 
     if (atomType == Atom.TYPE_mdat) {
       if (fragmentRun.sampleEncryptionDataNeedsFill) {
-        enterState(STATE_READING_ENCRYPTION_DATA);
+        parserState = STATE_READING_ENCRYPTION_DATA;
       } else {
-        enterState(STATE_READING_SAMPLE);
+        parserState = STATE_READING_SAMPLE_START;
       }
-      return 0;
+      return true;
     }
 
-    Integer atomTypeInteger = atomType; // Avoids boxing atomType twice.
-    if (PARSED_ATOMS.contains(atomTypeInteger)) {
-      if (CONTAINER_TYPES.contains(atomTypeInteger)) {
-        enterState(STATE_READING_ATOM_HEADER);
+    if (shouldParseAtom(atomType)) {
+      if (shouldParseContainerAtom(atomType)) {
+        parserState = STATE_READING_ATOM_HEADER;
         containerAtoms.add(new ContainerAtom(atomType,
-            rootAtomBytesRead + atomSize - Mp4Util.ATOM_HEADER_SIZE));
+            rootAtomBytesRead + atomSize - Atom.HEADER_SIZE));
       } else {
         atomData = new ParsableByteArray(atomSize);
-        System.arraycopy(atomHeader.data, 0, atomData.data, 0, Mp4Util.ATOM_HEADER_SIZE);
-        enterState(STATE_READING_ATOM_PAYLOAD);
+        System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
+        parserState = STATE_READING_ATOM_PAYLOAD;
       }
     } else {
       atomData = null;
-      enterState(STATE_READING_ATOM_PAYLOAD);
+      parserState = STATE_READING_ATOM_PAYLOAD;
     }
 
-    return 0;
+    return true;
   }
 
-  private int readAtomPayload(NonBlockingInputStream inputStream) {
-    int bytesRead;
+  private void readAtomPayload(ExtractorInput input) throws IOException, InterruptedException {
+    int payloadLength = atomSize - Atom.HEADER_SIZE;
     if (atomData != null) {
-      bytesRead = inputStream.read(atomData.data, atomBytesRead, atomSize - atomBytesRead);
+      input.readFully(atomData.data, Atom.HEADER_SIZE, payloadLength);
+      rootAtomBytesRead += payloadLength;
+      onLeafAtomRead(new LeafAtom(atomType, atomData), input.getPosition());
     } else {
-      bytesRead = inputStream.skip(atomSize - atomBytesRead);
-    }
-    if (bytesRead == -1) {
-      return RESULT_END_OF_STREAM;
-    }
-    rootAtomBytesRead += bytesRead;
-    atomBytesRead += bytesRead;
-    if (atomBytesRead != atomSize) {
-      return RESULT_NEED_MORE_DATA;
-    }
-
-    int results = 0;
-    if (atomData != null) {
-      results |= onLeafAtomRead(new LeafAtom(atomType, atomData));
+      input.skipFully(payloadLength);
+      rootAtomBytesRead += payloadLength;
     }
-
     while (!containerAtoms.isEmpty() && containerAtoms.peek().endByteOffset == rootAtomBytesRead) {
-      results |= onContainerAtomRead(containerAtoms.pop());
+      onContainerAtomRead(containerAtoms.pop());
     }
-
-    enterState(STATE_READING_ATOM_HEADER);
-    return results;
+    if (containerAtoms.isEmpty()) {
+      rootAtomBytesRead = 0;
+    }
+    parserState = STATE_READING_ATOM_HEADER;
   }
 
-  private int onLeafAtomRead(LeafAtom leaf) {
+  private void onLeafAtomRead(LeafAtom leaf, long inputPosition) {
     if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(leaf);
     } else if (leaf.type == Atom.TYPE_sidx) {
-      segmentIndex = parseSidx(leaf.data);
-      return RESULT_READ_INDEX;
+      ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
+      extractorOutput.seekMap(segmentIndex);
     }
-    return 0;
   }
 
-  private int onContainerAtomRead(ContainerAtom container) {
+  private void onContainerAtomRead(ContainerAtom container) {
     if (container.type == Atom.TYPE_moov) {
       onMoovContainerAtomRead(container);
-      return RESULT_READ_INIT;
     } else if (container.type == Atom.TYPE_moof) {
       onMoofContainerAtomRead(container);
     } else if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(container);
     }
-    return 0;
   }
 
   private void onMoovContainerAtomRead(ContainerAtom moov) {
     List<Atom.LeafAtom> moovChildren = moov.leafChildren;
     int moovChildrenSize = moovChildren.size();
+
+    DrmInitData.Mapped drmInitData = null;
     for (int i = 0; i < moovChildrenSize; i++) {
       LeafAtom child = moovChildren.get(i);
       if (child.type == Atom.TYPE_pssh) {
         ParsableByteArray psshAtom = child.data;
-        psshAtom.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE);
+        psshAtom.setPosition(Atom.FULL_HEADER_SIZE);
         UUID uuid = new UUID(psshAtom.readLong(), psshAtom.readLong());
         int dataSize = psshAtom.readInt();
         byte[] data = new byte[dataSize];
         psshAtom.readBytes(data, 0, dataSize);
-        psshData.put(uuid, data);
+        if (drmInitData == null) {
+          drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
+        }
+        drmInitData.put(uuid, data);
       }
     }
+    if (drmInitData != null) {
+      extractorOutput.drmInitData(drmInitData);
+    }
+
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
     extendsDefaults = parseTrex(mvex.getLeafAtomOfType(Atom.TYPE_trex).data);
-    track = CommonMp4AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
+    track = AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
         moov.getLeafAtomOfType(Atom.TYPE_mvhd));
+    Assertions.checkState(track != null);
+    trackOutput.format(track.mediaFormat);
   }
 
   private void onMoofContainerAtomRead(ContainerAtom moof) {
     fragmentRun.reset();
     parseMoof(track, extendsDefaults, moof, fragmentRun, workaroundFlags, extendedTypeScratch);
     sampleIndex = 0;
-    lastSyncSampleIndex = 0;
-    pendingSeekSyncSampleIndex = 0;
-    if (pendingSeekTimeMs != 0) {
-      for (int i = 0; i < fragmentRun.length; i++) {
-        if (fragmentRun.sampleIsSyncFrameTable[i]) {
-          if (fragmentRun.getSamplePresentationTime(i) <= pendingSeekTimeMs) {
-            pendingSeekSyncSampleIndex = i;
-          }
-        }
-      }
-      pendingSeekTimeMs = 0;
-    }
   }
 
   /**
    * Parses a trex atom (defined in 14496-12).
    */
   private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
-    trex.setPosition(Mp4Util.FULL_ATOM_HEADER_SIZE + 4);
+    trex.setPosition(Atom.FULL_HEADER_SIZE + 4);
     int defaultSampleDescriptionIndex = trex.readUnsignedIntToInt() - 1;
     int defaultSampleDuration = trex.readUnsignedIntToInt();
     int defaultSampleSize = trex.readUnsignedIntToInt();
@@ -460,11 +338,11 @@ private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
   private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArray saiz,
       TrackFragment out) {
     int vectorSize = encryptionBox.initializationVectorSize;
-    saiz.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    saiz.setPosition(Atom.HEADER_SIZE);
     int fullAtom = saiz.readInt();
-    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
+    int flags = Atom.parseFullAtomFlags(fullAtom);
     if ((flags & 0x01) == 1) {
-      saiz.skip(8);
+      saiz.skipBytes(8);
     }
     int defaultSampleInfoSize = saiz.readUnsignedByte();
 
@@ -497,24 +375,24 @@ private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArra
    */
   private static DefaultSampleValues parseTfhd(DefaultSampleValues extendsDefaults,
       ParsableByteArray tfhd) {
-    tfhd.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    tfhd.setPosition(Atom.HEADER_SIZE);
     int fullAtom = tfhd.readInt();
-    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
+    int flags = Atom.parseFullAtomFlags(fullAtom);
 
-    tfhd.skip(4); // trackId
+    tfhd.skipBytes(4); // trackId
     if ((flags & 0x01 /* base_data_offset_present */) != 0) {
-      tfhd.skip(8);
+      tfhd.skipBytes(8);
     }
 
     int defaultSampleDescriptionIndex =
-        ((flags & 0x02 /* default_sample_description_index_present */) != 0) ?
-        tfhd.readUnsignedIntToInt() - 1 : extendsDefaults.sampleDescriptionIndex;
-    int defaultSampleDuration = ((flags & 0x08 /* default_sample_duration_present */) != 0) ?
-        tfhd.readUnsignedIntToInt() : extendsDefaults.duration;
-    int defaultSampleSize = ((flags & 0x10 /* default_sample_size_present */) != 0) ?
-        tfhd.readUnsignedIntToInt() : extendsDefaults.size;
-    int defaultSampleFlags = ((flags & 0x20 /* default_sample_flags_present */) != 0) ?
-        tfhd.readUnsignedIntToInt() : extendsDefaults.flags;
+        ((flags & 0x02 /* default_sample_description_index_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() - 1 : extendsDefaults.sampleDescriptionIndex;
+    int defaultSampleDuration = ((flags & 0x08 /* default_sample_duration_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : extendsDefaults.duration;
+    int defaultSampleSize = ((flags & 0x10 /* default_sample_size_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : extendsDefaults.size;
+    int defaultSampleFlags = ((flags & 0x20 /* default_sample_flags_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : extendsDefaults.flags;
     return new DefaultSampleValues(defaultSampleDescriptionIndex, defaultSampleDuration,
         defaultSampleSize, defaultSampleFlags);
   }
@@ -526,9 +404,9 @@ private static DefaultSampleValues parseTfhd(DefaultSampleValues extendsDefaults
    *     media, expressed in the media's timescale.
    */
   private static long parseTfdt(ParsableByteArray tfdt) {
-    tfdt.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    tfdt.setPosition(Atom.HEADER_SIZE);
     int fullAtom = tfdt.readInt();
-    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+    int version = Atom.parseFullAtomVersion(fullAtom);
     return version == 1 ? tfdt.readUnsignedLongToLong() : tfdt.readUnsignedInt();
   }
 
@@ -543,13 +421,13 @@ private static long parseTfdt(ParsableByteArray tfdt) {
    */
   private static void parseTrun(Track track, DefaultSampleValues defaultSampleValues,
       long decodeTime, int workaroundFlags, ParsableByteArray trun, TrackFragment out) {
-    trun.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    trun.setPosition(Atom.HEADER_SIZE);
     int fullAtom = trun.readInt();
-    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
+    int flags = Atom.parseFullAtomFlags(fullAtom);
 
     int sampleCount = trun.readUnsignedIntToInt();
     if ((flags & 0x01 /* data_offset_present */) != 0) {
-      trun.skip(4);
+      trun.skipBytes(4);
     }
 
     boolean firstSampleFlagsPresent = (flags & 0x04 /* first_sample_flags_present */) != 0;
@@ -603,7 +481,7 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
 
   private static void parseUuid(ParsableByteArray uuid, TrackFragment out,
       byte[] extendedTypeScratch) {
-    uuid.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+    uuid.setPosition(Atom.HEADER_SIZE);
     uuid.readBytes(extendedTypeScratch, 0, 16);
 
     // Currently this parser only supports Microsoft's PIFF SampleEncryptionBox.
@@ -622,9 +500,9 @@ private static void parseSenc(ParsableByteArray senc, TrackFragment out) {
   }
 
   private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment out) {
-    senc.setPosition(Mp4Util.ATOM_HEADER_SIZE + offset);
+    senc.setPosition(Atom.HEADER_SIZE + offset);
     int fullAtom = senc.readInt();
-    int flags = Mp4Util.parseFullAtomFlags(fullAtom);
+    int flags = Atom.parseFullAtomFlags(fullAtom);
 
     if ((flags & 0x01 /* override_track_encryption_box_parameters */) != 0) {
       // TODO: Implement this.
@@ -645,24 +523,24 @@ private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment
   /**
    * Parses a sidx atom (defined in 14496-12).
    */
-  private static SegmentIndex parseSidx(ParsableByteArray atom) {
-    atom.setPosition(Mp4Util.ATOM_HEADER_SIZE);
+  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition) {
+    atom.setPosition(Atom.HEADER_SIZE);
     int fullAtom = atom.readInt();
-    int version = Mp4Util.parseFullAtomVersion(fullAtom);
+    int version = Atom.parseFullAtomVersion(fullAtom);
 
-    atom.skip(4);
+    atom.skipBytes(4);
     long timescale = atom.readUnsignedInt();
     long earliestPresentationTime;
-    long firstOffset;
+    long offset = inputPosition;
     if (version == 0) {
       earliestPresentationTime = atom.readUnsignedInt();
-      firstOffset = atom.readUnsignedInt();
+      offset += atom.readUnsignedInt();
     } else {
       earliestPresentationTime = atom.readUnsignedLongToLong();
-      firstOffset = atom.readUnsignedLongToLong();
+      offset += atom.readUnsignedLongToLong();
     }
 
-    atom.skip(2);
+    atom.skipBytes(2);
 
     int referenceCount = atom.readUnsignedShort();
     int[] sizes = new int[referenceCount];
@@ -670,7 +548,6 @@ private static SegmentIndex parseSidx(ParsableByteArray atom) {
     long[] durationsUs = new long[referenceCount];
     long[] timesUs = new long[referenceCount];
 
-    long offset = firstOffset;
     long time = earliestPresentationTime;
     long timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);
     for (int i = 0; i < referenceCount; i++) {
@@ -692,150 +569,143 @@ private static SegmentIndex parseSidx(ParsableByteArray atom) {
       timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);
       durationsUs[i] = timeUs - timesUs[i];
 
-      atom.skip(4);
+      atom.skipBytes(4);
       offset += sizes[i];
     }
 
-    return new SegmentIndex(atom.limit(), sizes, offsets, durationsUs, timesUs);
+    return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
   }
 
-  private int readEncryptionData(NonBlockingInputStream inputStream) {
-    boolean success = fragmentRun.fillEncryptionData(inputStream);
-    if (!success) {
-      return RESULT_NEED_MORE_DATA;
-    }
-    enterState(STATE_READING_SAMPLE);
-    return 0;
+  private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
+    fragmentRun.fillEncryptionData(input);
+    parserState = STATE_READING_SAMPLE_START;
   }
 
   /**
-   * Attempts to read or skip the next sample in the current mdat atom.
+   * Attempts to extract the next sample in the current mdat atom.
    * <p>
    * If there are no more samples in the current mdat atom then the parser state is transitioned
-   * to {@link #STATE_READING_ATOM_HEADER} and 0 is returned.
+   * to {@link #STATE_READING_ATOM_HEADER} and {@code false} is returned.
    * <p>
-   * If there's a pending seek to a sync frame, and if the next sample is before that frame, then
-   * the sample is skipped. Otherwise it is read.
-   * <p>
-   * It is possible for a sample to be read or skipped in part if there is insufficent data
-   * available from the {@link NonBlockingInputStream}. In this case the remainder of the sample
-   * can be read in a subsequent call passing the same {@link SampleHolder}.
+   * It is possible for a sample to be extracted in part in the case that an exception is thrown. In
+   * this case the method can be called again to extract the remainder of the sample.
    *
-   * @param inputStream The stream from which to read the sample.
-   * @param out The holder into which to write the sample.
-   * @return A combination of RESULT_* flags indicating the result of the call.
+   * @param input The {@link ExtractorInput} from which to read data.
+   * @return True if a sample was extracted. False otherwise.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
    */
-  private int readOrSkipSample(NonBlockingInputStream inputStream, SampleHolder out) {
+  private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
     if (sampleIndex >= fragmentRun.length) {
       // We've run out of samples in the current mdat atom.
-      enterState(STATE_READING_ATOM_HEADER);
-      return 0;
-    }
-    int sampleSize = fragmentRun.sampleSizeTable[sampleIndex];
-    if (inputStream.getAvailableByteCount() < sampleSize) {
-      return RESULT_NEED_MORE_DATA;
+      parserState = STATE_READING_ATOM_HEADER;
+      return false;
     }
-    if (sampleIndex < pendingSeekSyncSampleIndex) {
-      return skipSample(inputStream, sampleSize);
-    }
-    return readSample(inputStream, sampleSize, out);
-  }
 
-  private int skipSample(NonBlockingInputStream inputStream, int sampleSize) {
-    if (fragmentRun.definesEncryptionData) {
-      ParsableByteArray sampleEncryptionData = fragmentRun.sampleEncryptionData;
-      TrackEncryptionBox encryptionBox =
-          track.sampleDescriptionEncryptionBoxes[fragmentRun.sampleDescriptionIndex];
-      int vectorSize = encryptionBox.initializationVectorSize;
-      boolean subsampleEncryption = fragmentRun.sampleHasSubsampleEncryptionTable[sampleIndex];
-      sampleEncryptionData.skip(vectorSize);
-      int subsampleCount = subsampleEncryption ? sampleEncryptionData.readUnsignedShort() : 1;
-      if (subsampleEncryption) {
-        sampleEncryptionData.skip((2 + 4) * subsampleCount);
+    if (parserState == STATE_READING_SAMPLE_START) {
+      sampleSize = fragmentRun.sampleSizeTable[sampleIndex];
+      if (fragmentRun.definesEncryptionData) {
+        sampleBytesWritten = appendSampleEncryptionData(fragmentRun.sampleEncryptionData);
+        sampleSize += sampleBytesWritten;
+      } else {
+        sampleBytesWritten = 0;
+      }
+      sampleCurrentNalBytesRemaining = 0;
+      parserState = STATE_READING_SAMPLE_CONTINUE;
+    }
+
+    if (track.nalUnitLengthFieldLength != -1) {
+      // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
+      // they're only 1 or 2 bytes long.
+      byte[] nalLengthData = nalLength.data;
+      nalLengthData[0] = 0;
+      nalLengthData[1] = 0;
+      nalLengthData[2] = 0;
+      int nalUnitLengthFieldLength = track.nalUnitLengthFieldLength;
+      int nalUnitLengthFieldLengthDiff = 4 - track.nalUnitLengthFieldLength;
+      // NAL units are length delimited, but the decoder requires start code delimited units.
+      // Loop until we've written the sample to the track output, replacing length delimiters with
+      // start codes as we encounter them.
+      while (sampleBytesWritten < sampleSize) {
+        if (sampleCurrentNalBytesRemaining == 0) {
+          // Read the NAL length so that we know where we find the next one.
+          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          nalLength.setPosition(0);
+          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          // Write a start code for the current NAL unit.
+          nalStartCode.setPosition(0);
+          trackOutput.sampleData(nalStartCode, 4);
+          sampleBytesWritten += 4;
+          sampleSize += nalUnitLengthFieldLengthDiff;
+        } else {
+          // Write the payload of the NAL unit.
+          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining);
+          sampleBytesWritten += writtenBytes;
+          sampleCurrentNalBytesRemaining -= writtenBytes;
+        }
       }
-    }
-
-    inputStream.skip(sampleSize);
-
-    sampleIndex++;
-    enterState(STATE_READING_SAMPLE);
-    return 0;
-  }
-
-  private int readSample(NonBlockingInputStream inputStream, int sampleSize, SampleHolder out) {
-    if (out == null) {
-      return RESULT_NEED_SAMPLE_HOLDER;
-    }
-    out.timeUs = fragmentRun.getSamplePresentationTime(sampleIndex) * 1000L;
-    out.flags = 0;
-    if (fragmentRun.sampleIsSyncFrameTable[sampleIndex]) {
-      out.flags |= C.SAMPLE_FLAG_SYNC;
-      lastSyncSampleIndex = sampleIndex;
-    }
-    if (out.data == null || out.data.capacity() < sampleSize) {
-      out.replaceBuffer(sampleSize);
-    }
-    if (fragmentRun.definesEncryptionData) {
-      readSampleEncryptionData(fragmentRun.sampleEncryptionData, out);
-    }
-
-    ByteBuffer outputData = out.data;
-    if (outputData == null) {
-      inputStream.skip(sampleSize);
-      out.size = 0;
     } else {
-      inputStream.read(outputData, sampleSize);
-      if (track.type == Track.TYPE_VIDEO) {
-        // The mp4 file contains length-prefixed NAL units, but the decoder wants start code
-        // delimited content.
-        Mp4Util.replaceLengthPrefixesWithAvcStartCodes(outputData, sampleSize);
+      while (sampleBytesWritten < sampleSize) {
+        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten);
+        sampleBytesWritten += writtenBytes;
       }
-      out.size = sampleSize;
     }
 
+    long sampleTimeUs = fragmentRun.getSamplePresentationTime(sampleIndex) * 1000L;
+    int sampleFlags = (fragmentRun.definesEncryptionData ? C.SAMPLE_FLAG_ENCRYPTED : 0)
+        | (fragmentRun.sampleIsSyncFrameTable[sampleIndex] ? C.SAMPLE_FLAG_SYNC : 0);
+    byte[] encryptionKey = fragmentRun.definesEncryptionData
+        ? track.sampleDescriptionEncryptionBoxes[fragmentRun.sampleDescriptionIndex].keyId : null;
+    trackOutput.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
+
     sampleIndex++;
-    enterState(STATE_READING_SAMPLE);
-    return RESULT_READ_SAMPLE;
+    parserState = STATE_READING_SAMPLE_START;
+    return true;
   }
 
-  @SuppressLint("InlinedApi")
-  private void readSampleEncryptionData(ParsableByteArray sampleEncryptionData, SampleHolder out) {
+  private int appendSampleEncryptionData(ParsableByteArray sampleEncryptionData) {
     TrackEncryptionBox encryptionBox =
         track.sampleDescriptionEncryptionBoxes[fragmentRun.sampleDescriptionIndex];
-    byte[] keyId = encryptionBox.keyId;
-    boolean isEncrypted = encryptionBox.isEncrypted;
     int vectorSize = encryptionBox.initializationVectorSize;
     boolean subsampleEncryption = fragmentRun.sampleHasSubsampleEncryptionTable[sampleIndex];
 
-    byte[] vector = out.cryptoInfo.iv;
-    if (vector == null || vector.length != 16) {
-      vector = new byte[16];
-    }
-    sampleEncryptionData.readBytes(vector, 0, vectorSize);
-
-    int subsampleCount = subsampleEncryption ? sampleEncryptionData.readUnsignedShort() : 1;
-    int[] clearDataSizes = out.cryptoInfo.numBytesOfClearData;
-    if (clearDataSizes == null || clearDataSizes.length < subsampleCount) {
-      clearDataSizes = new int[subsampleCount];
-    }
-    int[] encryptedDataSizes = out.cryptoInfo.numBytesOfEncryptedData;
-    if (encryptedDataSizes == null || encryptedDataSizes.length < subsampleCount) {
-      encryptedDataSizes = new int[subsampleCount];
-    }
-    if (subsampleEncryption) {
-      for (int i = 0; i < subsampleCount; i++) {
-        clearDataSizes[i] = sampleEncryptionData.readUnsignedShort();
-        encryptedDataSizes[i] = sampleEncryptionData.readUnsignedIntToInt();
-      }
-    } else {
-      clearDataSizes[0] = 0;
-      encryptedDataSizes[0] = fragmentRun.sampleSizeTable[sampleIndex];
-    }
-    out.cryptoInfo.set(subsampleCount, clearDataSizes, encryptedDataSizes, keyId, vector,
-        isEncrypted ? MediaCodec.CRYPTO_MODE_AES_CTR : MediaCodec.CRYPTO_MODE_UNENCRYPTED);
-    if (isEncrypted) {
-      out.flags |= MediaExtractor.SAMPLE_FLAG_ENCRYPTED;
-    }
+    // Write the signal byte, containing the vector size and the subsample encryption flag.
+    encryptionSignalByte.data[0] = (byte) (vectorSize | (subsampleEncryption ? 0x80 : 0));
+    encryptionSignalByte.setPosition(0);
+    trackOutput.sampleData(encryptionSignalByte, 1);
+    // Write the vector.
+    trackOutput.sampleData(sampleEncryptionData, vectorSize);
+    // If we don't have subsample encryption data, we're done.
+    if (!subsampleEncryption) {
+      return 1 + vectorSize;
+    }
+    // Write the subsample encryption data.
+    int subsampleCount = sampleEncryptionData.readUnsignedShort();
+    sampleEncryptionData.skipBytes(-2);
+    int subsampleDataLength = 2 + 6 * subsampleCount;
+    trackOutput.sampleData(sampleEncryptionData, subsampleDataLength);
+    return 1 + vectorSize + subsampleDataLength;
+  }
+
+  /** Returns whether the extractor should parse an atom with type {@code atom}. */
+  private static boolean shouldParseAtom(int atom) {
+    return atom == Atom.TYPE_avc1 || atom == Atom.TYPE_avc3 || atom == Atom.TYPE_esds
+        || atom == Atom.TYPE_hdlr || atom == Atom.TYPE_mdat || atom == Atom.TYPE_mdhd
+        || atom == Atom.TYPE_moof || atom == Atom.TYPE_moov || atom == Atom.TYPE_mp4a
+        || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_sidx || atom == Atom.TYPE_stsd
+        || atom == Atom.TYPE_tfdt || atom == Atom.TYPE_tfhd || atom == Atom.TYPE_tkhd
+        || atom == Atom.TYPE_traf || atom == Atom.TYPE_trak || atom == Atom.TYPE_trex
+        || atom == Atom.TYPE_trun || atom == Atom.TYPE_mvex || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_pssh
+        || atom == Atom.TYPE_saiz || atom == Atom.TYPE_uuid || atom == Atom.TYPE_senc
+        || atom == Atom.TYPE_pasp;
+  }
+
+  /** Returns whether the extractor should parse a container atom with type {@code atom}. */
+  private static boolean shouldParseContainerAtom(int atom) {
+    return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_avcC
+        || atom == Atom.TYPE_moof || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
new file mode 100644
index 0000000000..06e333d9b6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.H264Util;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+
+/**
+ * Extracts data from an unfragmented MP4 file.
+ */
+public final class Mp4Extractor implements Extractor, SeekMap {
+
+  // Parser states.
+  private static final int STATE_READING_ATOM_HEADER = 0;
+  private static final int STATE_READING_ATOM_PAYLOAD = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  /**
+   * When seeking within the source, if the offset is greater than or equal to this value (or the
+   * offset is negative), the source will be reloaded.
+   */
+  private static final int RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
+
+  // Temporary arrays.
+  private final ParsableByteArray nalStartCode;
+  private final ParsableByteArray nalLength;
+
+  private final ParsableByteArray atomHeader;
+  private final Stack<ContainerAtom> containerAtoms;
+
+  private int parserState;
+  private long rootAtomBytesRead;
+  private int atomType;
+  private long atomSize;
+  private int atomBytesRead;
+  private ParsableByteArray atomData;
+
+  private int sampleSize;
+  private int sampleBytesWritten;
+  private int sampleCurrentNalBytesRemaining;
+
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+  private Mp4Track[] tracks;
+
+  public Mp4Extractor() {
+    atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
+    containerAtoms = new Stack<Atom.ContainerAtom>();
+    nalStartCode = new ParsableByteArray(H264Util.NAL_START_CODE);
+    nalLength = new ParsableByteArray(4);
+    parserState = STATE_READING_ATOM_HEADER;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+  }
+
+  @Override
+  public void seek() {
+    rootAtomBytesRead = 0;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    while (true) {
+      switch (parserState) {
+        case STATE_READING_ATOM_HEADER:
+          if (!readAtomHeader(input)) {
+            return RESULT_END_OF_INPUT;
+          }
+          break;
+        case STATE_READING_ATOM_PAYLOAD:
+          if (readAtomPayload(input, seekPosition)) {
+            return RESULT_SEEK;
+          }
+          break;
+        default:
+          return readSample(input, seekPosition);
+      }
+    }
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    long earliestSamplePosition = Long.MAX_VALUE;
+    for (int trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
+      TrackSampleTable sampleTable = tracks[trackIndex].sampleTable;
+      int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+      if (sampleIndex == TrackSampleTable.NO_SAMPLE) {
+        sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+      }
+      tracks[trackIndex].sampleIndex = sampleIndex;
+
+      long offset = sampleTable.offsets[tracks[trackIndex].sampleIndex];
+      if (offset < earliestSamplePosition) {
+        earliestSamplePosition = offset;
+      }
+    }
+    return earliestSamplePosition;
+  }
+
+  // Private methods.
+
+  private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
+    if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
+      return false;
+    }
+
+    atomHeader.setPosition(0);
+    atomSize = atomHeader.readUnsignedInt();
+    atomType = atomHeader.readInt();
+    if (atomSize == Atom.LONG_SIZE_PREFIX) {
+      // The extended atom size is contained in the next 8 bytes, so try to read it now.
+      input.readFully(atomHeader.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
+      atomSize = atomHeader.readLong();
+      rootAtomBytesRead += Atom.LONG_HEADER_SIZE;
+      atomBytesRead = Atom.LONG_HEADER_SIZE;
+    } else {
+      rootAtomBytesRead += Atom.HEADER_SIZE;
+      atomBytesRead = Atom.HEADER_SIZE;
+    }
+
+    if (shouldParseContainerAtom(atomType)) {
+      if (atomSize == Atom.LONG_SIZE_PREFIX) {
+        containerAtoms.add(
+            new ContainerAtom(atomType, rootAtomBytesRead + atomSize - atomBytesRead));
+      } else {
+        containerAtoms.add(
+            new ContainerAtom(atomType, rootAtomBytesRead + atomSize - atomBytesRead));
+      }
+      parserState = STATE_READING_ATOM_HEADER;
+    } else if (shouldParseLeafAtom(atomType)) {
+      Assertions.checkState(atomSize < Integer.MAX_VALUE);
+      atomData = new ParsableByteArray((int) atomSize);
+      System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
+      parserState = STATE_READING_ATOM_PAYLOAD;
+    } else {
+      atomData = null;
+      parserState = STATE_READING_ATOM_PAYLOAD;
+    }
+
+    return true;
+  }
+
+  /**
+   * Processes the atom payload. If {@link #atomData} is null and the size is at or above the
+   * threshold {@link #RELOAD_MINIMUM_SEEK_DISTANCE}, {@code true} is returned and the caller should
+   * restart loading at the position in {@code positionHolder}. Otherwise, the atom is read/skipped.
+   */
+  private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHolder)
+      throws IOException, InterruptedException {
+    parserState = STATE_READING_ATOM_HEADER;
+    rootAtomBytesRead += atomSize - atomBytesRead;
+    long atomRemainingBytes = atomSize - atomBytesRead;
+    boolean seekRequired = atomData == null
+        && (atomSize >= RELOAD_MINIMUM_SEEK_DISTANCE || atomSize > Integer.MAX_VALUE);
+    if (seekRequired) {
+      positionHolder.position = rootAtomBytesRead;
+    } else if (atomData != null) {
+      input.readFully(atomData.data, atomBytesRead, (int) atomRemainingBytes);
+      if (!containerAtoms.isEmpty()) {
+        containerAtoms.peek().add(new Atom.LeafAtom(atomType, atomData));
+      }
+    } else {
+      input.skipFully((int) atomRemainingBytes);
+    }
+
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endByteOffset == rootAtomBytesRead) {
+      Atom.ContainerAtom containerAtom = containerAtoms.pop();
+      if (containerAtom.type == Atom.TYPE_moov) {
+        processMoovAtom(containerAtom);
+      } else if (!containerAtoms.isEmpty()) {
+        containerAtoms.peek().add(containerAtom);
+      }
+    }
+
+    return seekRequired;
+  }
+
+  /** Updates the stored track metadata to reflect the contents of the specified moov atom. */
+  private void processMoovAtom(ContainerAtom moov) {
+    List<Mp4Track> tracks = new ArrayList<Mp4Track>();
+    long earliestSampleOffset = Long.MAX_VALUE;
+    for (int i = 0; i < moov.containerChildren.size(); i++) {
+      Atom.ContainerAtom atom = moov.containerChildren.get(i);
+      if (atom.type != Atom.TYPE_trak) {
+        continue;
+      }
+
+      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd));
+      if (track == null || (track.type != Track.TYPE_AUDIO && track.type != Track.TYPE_VIDEO)) {
+        continue;
+      }
+
+      Atom.ContainerAtom stblAtom = atom.getContainerAtomOfType(Atom.TYPE_mdia)
+          .getContainerAtomOfType(Atom.TYPE_minf).getContainerAtomOfType(Atom.TYPE_stbl);
+      TrackSampleTable trackSampleTable = AtomParsers.parseStbl(track, stblAtom);
+      if (trackSampleTable.sampleCount == 0) {
+        continue;
+      }
+
+      Mp4Track mp4Track = new Mp4Track(track, trackSampleTable, extractorOutput.track(i));
+      mp4Track.trackOutput.format(track.mediaFormat);
+      tracks.add(mp4Track);
+
+      long firstSampleOffset = trackSampleTable.offsets[0];
+      if (firstSampleOffset < earliestSampleOffset) {
+        earliestSampleOffset = firstSampleOffset;
+      }
+    }
+    this.tracks = tracks.toArray(new Mp4Track[0]);
+    extractorOutput.endTracks();
+    extractorOutput.seekMap(this);
+    parserState = STATE_READING_SAMPLE;
+  }
+
+  /**
+   * Attempts to extract the next sample in the current mdat atom for the specified track.
+   * <p>
+   * Returns {@link #RESULT_SEEK} if the source should be reloaded from the position in
+   * {@code positionHolder}.
+   * <p>
+   * Returns {@link #RESULT_END_OF_INPUT} if no samples are left. Otherwise, returns
+   * {@link #RESULT_CONTINUE}.
+   *
+   * @param input The {@link ExtractorInput} from which to read data.
+   * @param positionHolder If {@link #RESULT_SEEK} is returned, this holder is updated to hold the
+   *     position of the required data.
+   * @return One of the {@code RESULT_*} flags in {@link Extractor}.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private int readSample(ExtractorInput input, PositionHolder positionHolder)
+      throws IOException, InterruptedException {
+    int trackIndex = getTrackIndexOfEarliestCurrentSample();
+    if (trackIndex == TrackSampleTable.NO_SAMPLE) {
+      return RESULT_END_OF_INPUT;
+    }
+    Mp4Track track = tracks[trackIndex];
+    int sampleIndex = track.sampleIndex;
+    long position = track.sampleTable.offsets[sampleIndex];
+    long skipAmount = position - input.getPosition() + sampleBytesWritten;
+    if (skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE) {
+      positionHolder.position = position;
+      return RESULT_SEEK;
+    }
+    input.skipFully((int) skipAmount);
+    sampleSize = track.sampleTable.sizes[sampleIndex];
+    if (track.track.nalUnitLengthFieldLength != -1) {
+      // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
+      // they're only 1 or 2 bytes long.
+      byte[] nalLengthData = nalLength.data;
+      nalLengthData[0] = 0;
+      nalLengthData[1] = 0;
+      nalLengthData[2] = 0;
+      int nalUnitLengthFieldLength = track.track.nalUnitLengthFieldLength;
+      int nalUnitLengthFieldLengthDiff = 4 - track.track.nalUnitLengthFieldLength;
+      // NAL units are length delimited, but the decoder requires start code delimited units.
+      // Loop until we've written the sample to the track output, replacing length delimiters with
+      // start codes as we encounter them.
+      while (sampleBytesWritten < sampleSize) {
+        if (sampleCurrentNalBytesRemaining == 0) {
+          // Read the NAL length so that we know where we find the next one.
+          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          nalLength.setPosition(0);
+          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          // Write a start code for the current NAL unit.
+          nalStartCode.setPosition(0);
+          track.trackOutput.sampleData(nalStartCode, 4);
+          sampleBytesWritten += 4;
+          sampleSize += nalUnitLengthFieldLengthDiff;
+        } else {
+          // Write the payload of the NAL unit.
+          int writtenBytes = track.trackOutput.sampleData(input, sampleCurrentNalBytesRemaining);
+          sampleBytesWritten += writtenBytes;
+          sampleCurrentNalBytesRemaining -= writtenBytes;
+        }
+      }
+    } else {
+      while (sampleBytesWritten < sampleSize) {
+        int writtenBytes = track.trackOutput.sampleData(input, sampleSize - sampleBytesWritten);
+        sampleBytesWritten += writtenBytes;
+        sampleCurrentNalBytesRemaining -= writtenBytes;
+      }
+    }
+    track.trackOutput.sampleMetadata(track.sampleTable.timestampsUs[sampleIndex],
+        track.sampleTable.flags[sampleIndex], sampleSize, 0, null);
+    track.sampleIndex++;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+    return RESULT_CONTINUE;
+  }
+
+  /**
+   * Returns the index of the track that contains the earliest current sample, or
+   * {@link TrackSampleTable#NO_SAMPLE} if no samples remain.
+   */
+  private int getTrackIndexOfEarliestCurrentSample() {
+    int earliestSampleTrackIndex = TrackSampleTable.NO_SAMPLE;
+    long earliestSampleOffset = Long.MAX_VALUE;
+    for (int trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
+      Mp4Track track = tracks[trackIndex];
+      int sampleIndex = track.sampleIndex;
+      if (sampleIndex == track.sampleTable.sampleCount) {
+        continue;
+      }
+
+      long trackSampleOffset = track.sampleTable.offsets[sampleIndex];
+      if (trackSampleOffset < earliestSampleOffset) {
+        earliestSampleOffset = trackSampleOffset;
+        earliestSampleTrackIndex = trackIndex;
+      }
+    }
+
+    return earliestSampleTrackIndex;
+  }
+
+  /** Returns whether the extractor should parse a leaf atom with type {@code atom}. */
+  private static boolean shouldParseLeafAtom(int atom) {
+    return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
+        || atom == Atom.TYPE_vmhd || atom == Atom.TYPE_smhd || atom == Atom.TYPE_stsd
+        || atom == Atom.TYPE_avc1 || atom == Atom.TYPE_avcC || atom == Atom.TYPE_mp4a
+        || atom == Atom.TYPE_esds || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
+        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_stsc || atom == Atom.TYPE_stsz
+        || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd;
+  }
+
+  /** Returns whether the extractor should parse a container atom with type {@code atom}. */
+  private static boolean shouldParseContainerAtom(int atom) {
+    return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl;
+  }
+
+  private static final class Mp4Track {
+
+    public final Track track;
+    public final TrackSampleTable sampleTable;
+    public final TrackOutput trackOutput;
+
+    public int sampleIndex;
+
+    public Mp4Track(Track track, TrackSampleTable sampleTable, TrackOutput trackOutput) {
+      this.track = track;
+      this.sampleTable = sampleTable;
+      this.trackOutput = trackOutput;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
similarity index 86%
rename from library/src/main/java/com/google/android/exoplayer/mp4/Track.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
index 313e3272f6..c53a9760b2 100644
--- a/library/src/main/java/com/google/android/exoplayer/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
@@ -13,11 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
 
 /**
  * Encapsulates information describing an MP4 track.
@@ -80,14 +79,21 @@
    */
   public final TrackEncryptionBox[] sampleDescriptionEncryptionBoxes;
 
+  /**
+   * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. -1 for
+   * other track types.
+   */
+  public final int nalUnitLengthFieldLength;
+
   public Track(int id, int type, long timescale, long durationUs, MediaFormat mediaFormat,
-      TrackEncryptionBox[] sampleDescriptionEncryptionBoxes) {
+      TrackEncryptionBox[] sampleDescriptionEncryptionBoxes, int nalUnitLengthFieldLength) {
     this.id = id;
     this.type = type;
     this.timescale = timescale;
     this.durationUs = durationUs;
     this.mediaFormat = mediaFormat;
     this.sampleDescriptionEncryptionBoxes = sampleDescriptionEncryptionBoxes;
+    this.nalUnitLengthFieldLength = nalUnitLengthFieldLength;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
similarity index 96%
rename from library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
index 7615cdd041..074802924e 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackEncryptionBox.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackEncryptionBox.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.chunk.parser.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 /**
  * Encapsulates information parsed from a track encryption (tenc) box in an MP4 stream.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
similarity index 88%
rename from library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
index eb16a87650..7cb7badedd 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/parser/mp4/TrackFragment.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackFragment.java
@@ -13,11 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.chunk.parser.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
-import com.google.android.exoplayer.upstream.NonBlockingInputStream;
+import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import java.io.IOException;
+
 /**
  * A holder for information corresponding to a single fragment of an mp4 file.
  */
@@ -122,30 +124,25 @@ public void initEncryptionData(int length) {
   }
 
   /**
-   * Fills {@link #sampleEncryptionData} from the provided source.
+   * Fills {@link #sampleEncryptionData} from the provided input.
    *
-   * @param source A source from which to read the encryption data.
+   * @param input An {@link ExtractorInput} from which to read the encryption data.
    */
-  public void fillEncryptionData(ParsableByteArray source) {
-    source.readBytes(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
+  public void fillEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
+    input.readFully(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
     sampleEncryptionData.setPosition(0);
     sampleEncryptionDataNeedsFill = false;
   }
 
   /**
-   * Fills {@link #sampleEncryptionData} for the current run from the provided source.
+   * Fills {@link #sampleEncryptionData} from the provided source.
    *
    * @param source A source from which to read the encryption data.
-   * @return True if the encryption data was filled. False if the source had insufficient data.
    */
-  public boolean fillEncryptionData(NonBlockingInputStream source) {
-    if (source.getAvailableByteCount() < sampleEncryptionDataLength) {
-      return false;
-    }
-    source.read(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
+  public void fillEncryptionData(ParsableByteArray source) {
+    source.readBytes(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
     sampleEncryptionData.setPosition(0);
     sampleEncryptionDataNeedsFill = false;
-    return true;
   }
 
   public long getSamplePresentationTime(int index) {
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
similarity index 85%
rename from library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
index 9e60146140..1848185e97 100644
--- a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4TrackSampleTable.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
@@ -13,15 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.mp4;
+package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
 /** Sample table for a track in an MP4 file. */
-public final class Mp4TrackSampleTable {
+/* package */ final class TrackSampleTable {
 
+  /** Sample index when no sample is available. */
+  public static final int NO_SAMPLE = -1;
+
+  /** Number of samples. */
+  public final int sampleCount;
   /** Sample offsets in bytes. */
   public final long[] offsets;
   /** Sample sizes in bytes. */
@@ -31,7 +36,7 @@
   /** Sample flags. */
   public final int[] flags;
 
-  Mp4TrackSampleTable(
+  TrackSampleTable(
       long[] offsets, int[] sizes, long[] timestampsUs, int[] flags) {
     Assertions.checkArgument(sizes.length == timestampsUs.length);
     Assertions.checkArgument(offsets.length == timestampsUs.length);
@@ -41,11 +46,7 @@
     this.sizes = sizes;
     this.timestampsUs = timestampsUs;
     this.flags = flags;
-  }
-
-  /** Returns the number of samples in the table. */
-  public int getSampleCount() {
-    return sizes.length;
+    sampleCount = offsets.length;
   }
 
   /**
@@ -53,7 +54,7 @@ public int getSampleCount() {
    * timestamp, if one is available.
    *
    * @param timeUs Timestamp adjacent to which to find a synchronization sample.
-   * @return Index of the synchronization sample, or {@link Mp4Util#NO_SAMPLE} if none.
+   * @return Index of the synchronization sample, or {@link #NO_SAMPLE} if none.
    */
   public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
     int startIndex = Util.binarySearchFloor(timestampsUs, timeUs, true, false);
@@ -62,8 +63,7 @@ public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
         return i;
       }
     }
-
-    return Mp4Util.NO_SAMPLE;
+    return NO_SAMPLE;
   }
 
   /**
@@ -71,7 +71,7 @@ public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
    * if one is available.
    *
    * @param timeUs Timestamp adjacent to which to find a synchronization sample.
-   * @return index Index of the synchronization sample, or {@link Mp4Util#NO_SAMPLE} if none.
+   * @return index Index of the synchronization sample, or {@link #NO_SAMPLE} if none.
    */
   public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {
     int startIndex = Util.binarySearchCeil(timestampsUs, timeUs, true, false);
@@ -80,8 +80,7 @@ public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {
         return i;
       }
     }
-
-    return Mp4Util.NO_SAMPLE;
+    return NO_SAMPLE;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
new file mode 100644
index 0000000000..5c98a680e8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.Ac3Util;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Parses a continuous AC-3 byte stream and extracts individual samples.
+ */
+/* package */ final class Ac3Reader extends ElementaryStreamReader {
+
+  private static final int STATE_FINDING_SYNC = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  private static final int HEADER_SIZE = 8;
+
+  private final ParsableBitArray headerScratchBits;
+  private final ParsableByteArray headerScratchBytes;
+
+  private int state;
+  private int bytesRead;
+
+  // Used to find the header.
+  private boolean lastByteWas0B;
+
+  // Used when parsing the header.
+  private long frameDurationUs;
+  private MediaFormat mediaFormat;
+  private int sampleSize;
+  private int bitrate;
+
+  // Used when reading the samples.
+  private long timeUs;
+
+  public Ac3Reader(TrackOutput output) {
+    super(output);
+    headerScratchBits = new ParsableBitArray(new byte[HEADER_SIZE]);
+    headerScratchBytes = new ParsableByteArray(headerScratchBits.data);
+    state = STATE_FINDING_SYNC;
+  }
+
+  @Override
+  public void seek() {
+    state = STATE_FINDING_SYNC;
+    bytesRead = 0;
+    lastByteWas0B = false;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      timeUs = pesTimeUs;
+    }
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SYNC:
+          if (skipToNextSync(data)) {
+            state = STATE_READING_HEADER;
+            headerScratchBytes.data[0] = 0x0B;
+            headerScratchBytes.data[1] = 0x77;
+            bytesRead = 2;
+          }
+          break;
+        case STATE_READING_HEADER:
+          if (continueRead(data, headerScratchBytes.data, HEADER_SIZE)) {
+            parseHeader();
+            headerScratchBytes.setPosition(0);
+            output.sampleData(headerScratchBytes, HEADER_SIZE);
+            state = STATE_READING_SAMPLE;
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+          output.sampleData(data, bytesToRead);
+          bytesRead += bytesToRead;
+          if (bytesRead == sampleSize) {
+            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+            timeUs += frameDurationUs;
+            state = STATE_FINDING_SYNC;
+          }
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length was reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    source.readBytes(target, bytesRead, bytesToRead);
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  /**
+   * Locates the next sync word, advancing the position to the byte that immediately follows it.
+   * If a sync word was not located, the position is advanced to the limit.
+   *
+   * @param pesBuffer The buffer whose position should be advanced.
+   * @return True if a sync word position was found. False otherwise.
+   */
+  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
+    while (pesBuffer.bytesLeft() > 0) {
+      if (!lastByteWas0B) {
+        lastByteWas0B = pesBuffer.readUnsignedByte() == 0x0B;
+        continue;
+      }
+      int secondByte = pesBuffer.readUnsignedByte();
+      if (secondByte == 0x77) {
+        lastByteWas0B = false;
+        return true;
+      } else {
+        lastByteWas0B = secondByte == 0x0B;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Parses the sample header.
+   */
+  private void parseHeader() {
+    headerScratchBits.setPosition(0);
+    sampleSize = Ac3Util.parseFrameSize(headerScratchBits);
+    if (mediaFormat == null) {
+      headerScratchBits.setPosition(0);
+      mediaFormat = Ac3Util.parseFrameAc3Format(headerScratchBits);
+      output.format(mediaFormat);
+      bitrate = Ac3Util.getBitrate(sampleSize, mediaFormat.sampleRate);
+    }
+    frameDurationUs = (int) (1000L * 8 * sampleSize / bitrate);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
new file mode 100644
index 0000000000..4e3a5b3c46
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Facilitates the extraction of AAC samples from elementary audio files formatted as AAC with ADTS
+ * headers.
+ */
+public class AdtsExtractor implements Extractor, SeekMap {
+
+  private static final int MAX_PACKET_SIZE = 200;
+
+  private final long firstSampleTimestampUs;
+  private final ParsableByteArray packetBuffer;
+
+  // Accessed only by the loading thread.
+  private AdtsReader adtsReader;
+  private boolean firstPacket;
+
+  public AdtsExtractor() {
+    this(0);
+  }
+
+  public AdtsExtractor(long firstSampleTimestampUs) {
+    this.firstSampleTimestampUs = firstSampleTimestampUs;
+    packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
+    firstPacket = true;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    adtsReader = new AdtsReader(output.track(0));
+    output.endTracks();
+    output.seekMap(this);
+  }
+
+  @Override
+  public void seek() {
+    firstPacket = true;
+    adtsReader.seek();
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    int bytesRead = input.read(packetBuffer.data, 0, MAX_PACKET_SIZE);
+    if (bytesRead == -1) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    // Feed whatever data we have to the reader, regardless of whether the read finished or not.
+    packetBuffer.setPosition(0);
+    packetBuffer.setLimit(bytesRead);
+
+    // TODO: Make it possible for adtsReader to consume the dataSource directly, so that it becomes
+    // unnecessary to copy the data through packetBuffer.
+    adtsReader.consume(packetBuffer, firstSampleTimestampUs, firstPacket);
+    firstPacket = false;
+    return RESULT_CONTINUE;
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return false;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return 0;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
similarity index 89%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index 9dec6cc84a..fa4fd51dd2 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableBitArray;
@@ -48,19 +48,27 @@
   private boolean lastByteWasFF;
   private boolean hasCrc;
 
-  // Parsed from the header.
+  // Used when parsing the header.
+  private boolean hasOutputFormat;
   private long frameDurationUs;
   private int sampleSize;
 
   // Used when reading the samples.
   private long timeUs;
 
-  public AdtsReader(BufferPool bufferPool) {
-    super(bufferPool);
+  public AdtsReader(TrackOutput output) {
+    super(output);
     adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
     state = STATE_FINDING_SYNC;
   }
 
+  @Override
+  public void seek() {
+    state = STATE_FINDING_SYNC;
+    bytesRead = 0;
+    lastByteWasFF = false;
+  }
+
   @Override
   public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
     if (startOfPacket) {
@@ -76,19 +84,18 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
           break;
         case STATE_READING_HEADER:
           int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
-          if (continueRead(data, adtsScratch.getData(), targetLength)) {
+          if (continueRead(data, adtsScratch.data, targetLength)) {
             parseHeader();
-            startSample(timeUs);
             bytesRead = 0;
             state = STATE_READING_SAMPLE;
           }
           break;
         case STATE_READING_SAMPLE:
           int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
-          appendData(data, bytesToRead);
+          output.sampleData(data, bytesToRead);
           bytesRead += bytesToRead;
           if (bytesRead == sampleSize) {
-            commitSample(true);
+            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
             timeUs += frameDurationUs;
             bytesRead = 0;
             state = STATE_FINDING_SYNC;
@@ -152,7 +159,7 @@ private boolean skipToNextSync(ParsableByteArray pesBuffer) {
   private void parseHeader() {
     adtsScratch.setPosition(0);
 
-    if (!hasMediaFormat()) {
+    if (!hasOutputFormat) {
       int audioObjectType = adtsScratch.readBits(2) + 1;
       int sampleRateIndex = adtsScratch.readBits(4);
       adtsScratch.skipBits(1);
@@ -167,7 +174,8 @@ private void parseHeader() {
           MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
           Collections.singletonList(audioSpecificConfig));
       frameDurationUs = (C.MICROS_PER_SECOND * 1024L) / mediaFormat.sampleRate;
-      setMediaFormat(mediaFormat);
+      output.format(mediaFormat);
+      hasOutputFormat = true;
     } else {
       adtsScratch.skipBits(10);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/ElementaryStreamReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
similarity index 66%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/ElementaryStreamReader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
index a8c5c7b562..7bcdd1775a 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/ElementaryStreamReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
@@ -13,20 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
-import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
  * Extracts individual samples from an elementary media stream, preserving original order.
  */
-/* package */ abstract class ElementaryStreamReader extends SampleQueue {
+/* package */ abstract class ElementaryStreamReader {
 
-  protected ElementaryStreamReader(BufferPool bufferPool) {
-    super(bufferPool);
+  protected final TrackOutput output;
+
+  /**
+   * @param output A {@link TrackOutput} to which samples should be written.
+   */
+  protected ElementaryStreamReader(TrackOutput output) {
+    this.output = output;
   }
 
+  /**
+   * Notifies the reader that a seek has occurred.
+   * <p>
+   * Following a call to this method, the data passed to the next invocation of
+   * {@link #consume(ParsableByteArray, long, boolean)} will not be a continuation of the data that
+   * was previously passed. Hence the reader should reset any internal state.
+   */
+  public abstract void seek();
+
   /**
    * Consumes (possibly partial) payload data.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
similarity index 77%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index 7e94376c32..c8b023e8dc 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -13,16 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.mp4.Mp4Util;
-import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.H264Util;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Log;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -32,32 +35,77 @@
  */
 /* package */ class H264Reader extends ElementaryStreamReader {
 
+  private static final String TAG = "H264Reader";
+
   private static final int NAL_UNIT_TYPE_IDR = 5;
   private static final int NAL_UNIT_TYPE_SEI = 6;
   private static final int NAL_UNIT_TYPE_SPS = 7;
   private static final int NAL_UNIT_TYPE_PPS = 8;
   private static final int NAL_UNIT_TYPE_AUD = 9;
-
+  private static final int EXTENDED_SAR = 0xFF;
+  private static final float[] ASPECT_RATIO_IDC_VALUES = new float[] {
+    1f /* Unspecified. Assume square */,
+    1f,
+    12f / 11f,
+    10f / 11f,
+    16f / 11f,
+    40f / 33f,
+    24f / 11f,
+    20f / 11f,
+    32f / 11f,
+    80f / 33f,
+    18f / 11f,
+    15f / 11f,
+    64f / 33f,
+    160f / 99f,
+    4f / 3f,
+    3f / 2f,
+    2f
+  };
+
+  // State that should not be reset on seek.
+  private boolean hasOutputFormat;
+
+  // State that should be reset on seek.
   private final SeiReader seiReader;
   private final boolean[] prefixFlags;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer sei;
+  private boolean writingSample;
+  private long totalBytesWritten;
 
-  private int scratchEscapeCount;
-  private int[] scratchEscapePositions;
+  // Per sample state that gets reset at the start of each sample.
   private boolean isKeyframe;
+  private long samplePosition;
+  private long sampleTimeUs;
+
+  // Scratch variables to avoid allocations.
+  private final ParsableByteArray seiWrapper;
+  private int[] scratchEscapePositions;
 
-  public H264Reader(BufferPool bufferPool, SeiReader seiReader) {
-    super(bufferPool);
+  public H264Reader(TrackOutput output, SeiReader seiReader) {
+    super(output);
     this.seiReader = seiReader;
     prefixFlags = new boolean[3];
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
+    seiWrapper = new ParsableByteArray();
     scratchEscapePositions = new int[10];
   }
 
+  @Override
+  public void seek() {
+    seiReader.seek();
+    H264Util.clearPrefixFlags(prefixFlags);
+    sps.reset();
+    pps.reset();
+    sei.reset();
+    writingSample = false;
+    totalBytesWritten = 0;
+  }
+
   @Override
   public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
     while (data.bytesLeft() > 0) {
@@ -66,11 +114,12 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
       byte[] dataArray = data.data;
 
       // Append the data to the buffer.
-      appendData(data, data.bytesLeft());
+      totalBytesWritten += data.bytesLeft();
+      output.sampleData(data, data.bytesLeft());
 
       // Scan the appended data, processing NAL units as they are encountered
       while (offset < limit) {
-        int nextNalUnitOffset = Mp4Util.findNalUnit(dataArray, offset, limit, prefixFlags);
+        int nextNalUnitOffset = H264Util.findNalUnit(dataArray, offset, limit, prefixFlags);
         if (nextNalUnitOffset < limit) {
           // We've seen the start of a NAL unit.
 
@@ -81,17 +130,22 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
             feedNalUnitTargetBuffersData(dataArray, offset, nextNalUnitOffset);
           }
 
-          int nalUnitType = Mp4Util.getNalUnitType(dataArray, nextNalUnitOffset);
-          int nalUnitOffsetInData = nextNalUnitOffset - limit;
+          int nalUnitType = H264Util.getNalUnitType(dataArray, nextNalUnitOffset);
+          int bytesWrittenPastNalUnit = limit - nextNalUnitOffset;
           if (nalUnitType == NAL_UNIT_TYPE_AUD) {
-            if (writingSample()) {
-              if (isKeyframe && !hasMediaFormat() && sps.isCompleted() && pps.isCompleted()) {
+            if (writingSample) {
+              if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
                 parseMediaFormat(sps, pps);
               }
-              commitSample(isKeyframe, nalUnitOffsetInData);
+              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
+              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
+              writingSample = false;
             }
-            startSample(pesTimeUs, nalUnitOffsetInData);
+            writingSample = true;
             isKeyframe = false;
+            sampleTimeUs = pesTimeUs;
+            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
           } else if (nalUnitType == NAL_UNIT_TYPE_IDR) {
             isKeyframe = true;
           }
@@ -117,7 +171,7 @@ public void packetFinished() {
   }
 
   private void feedNalUnitTargetBuffersStart(int nalUnitType) {
-    if (!hasMediaFormat()) {
+    if (!hasOutputFormat) {
       sps.startNalUnit(nalUnitType);
       pps.startNalUnit(nalUnitType);
     }
@@ -125,7 +179,7 @@ private void feedNalUnitTargetBuffersStart(int nalUnitType) {
   }
 
   private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
-    if (!hasMediaFormat()) {
+    if (!hasOutputFormat) {
       sps.appendToNalUnit(dataArray, offset, limit);
       pps.appendToNalUnit(dataArray, offset, limit);
     }
@@ -137,7 +191,8 @@ private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
     pps.endNalUnit(discardPadding);
     if (sei.endNalUnit(discardPadding)) {
       int unescapedLength = unescapeStream(sei.nalData, sei.nalLength);
-      seiReader.read(sei.nalData, 0, unescapedLength, pesTimeUs);
+      seiWrapper.reset(sei.nalData, unescapedLength);
+      seiReader.consume(seiWrapper, pesTimeUs, true);
     }
   }
 
@@ -228,9 +283,29 @@ private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps)
       frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
     }
 
-    // Set the format.
-    setMediaFormat(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        frameWidth, frameHeight, initializationData));
+    float pixelWidthHeightRatio = 1;
+    boolean vuiParametersPresentFlag = bitArray.readBit();
+    if (vuiParametersPresentFlag) {
+      boolean aspectRatioInfoPresentFlag = bitArray.readBit();
+      if (aspectRatioInfoPresentFlag) {
+        int aspectRatioIdc = bitArray.readBits(8);
+        if (aspectRatioIdc == EXTENDED_SAR) {
+          int sarWidth = bitArray.readBits(16);
+          int sarHeight = bitArray.readBits(16);
+          if (sarWidth != 0 && sarHeight != 0) {
+            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
+          }
+        } else if (aspectRatioIdc < ASPECT_RATIO_IDC_VALUES.length) {
+          pixelWidthHeightRatio = ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
+        } else {
+          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
+        }
+      }
+    }
+
+    output.format(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
+        C.UNKNOWN_TIME_US, frameWidth, frameHeight, pixelWidthHeightRatio, initializationData));
+    hasOutputFormat = true;
   }
 
   private void skipScalingList(ParsableBitArray bitArray, int size) {
@@ -257,7 +332,7 @@ private void skipScalingList(ParsableBitArray bitArray, int size) {
    */
   private int unescapeStream(byte[] data, int limit) {
     int position = 0;
-    scratchEscapeCount = 0;
+    int scratchEscapeCount = 0;
     while (position < limit) {
       position = findNextUnescapeIndex(data, position, limit);
       if (position < limit) {
@@ -318,6 +393,17 @@ public NalUnitTargetBuffer(int targetType, int initialCapacity) {
       nalData[3] = (byte) targetType;
     }
 
+    /**
+     * Resets the buffer, clearing any data that it holds.
+     */
+    public void reset() {
+      isFilling = false;
+      isCompleted = false;
+    }
+
+    /**
+     * True if the buffer currently holds a complete NAL unit of the target type.
+     */
     public boolean isCompleted() {
       return isCompleted;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
similarity index 56%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 7de263d6da..04fe15481e 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.upstream.BufferPool;
+import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
@@ -24,24 +25,40 @@
  */
 /* package */ class Id3Reader extends ElementaryStreamReader {
 
-  public Id3Reader(BufferPool bufferPool) {
-    super(bufferPool);
-    setMediaFormat(MediaFormat.createId3Format());
+  // State that should be reset on seek.
+  private boolean writingSample;
+
+  // Per sample state that gets reset at the start of each sample.
+  private long sampleTimeUs;
+  private int sampleSize;
+
+  public Id3Reader(TrackOutput output) {
+    super(output);
+    output.format(MediaFormat.createId3Format());
+  }
+
+  @Override
+  public void seek() {
+    writingSample = false;
   }
 
   @Override
   public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
     if (startOfPacket) {
-      startSample(pesTimeUs);
+      writingSample = true;
+      sampleTimeUs = pesTimeUs;
+      sampleSize = 0;
     }
-    if (writingSample()) {
-      appendData(data, data.bytesLeft());
+    if (writingSample) {
+      sampleSize += data.bytesLeft();
+      output.sampleData(data, data.bytesLeft());
     }
   }
 
   @Override
   public void packetFinished() {
-    commitSample(true);
+    output.sampleMetadata(sampleTimeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+    writingSample = false;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
similarity index 65%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
index ba7a91aa7d..1bd169d544 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.text.eia608.Eia608Parser;
-import com.google.android.exoplayer.upstream.BufferPool;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
@@ -26,20 +27,22 @@
  * TODO: Technically, we shouldn't allow a sample to be read from the queue until we're sure that
  * a sample with an earlier timestamp won't be added to it.
  */
-/* package */ class SeiReader extends SampleQueue {
+/* package */ class SeiReader extends ElementaryStreamReader {
 
-  private final ParsableByteArray seiBuffer;
+  public SeiReader(TrackOutput output) {
+    super(output);
+    output.format(MediaFormat.createEia608Format());
+  }
 
-  public SeiReader(BufferPool bufferPool) {
-    super(bufferPool);
-    setMediaFormat(MediaFormat.createEia608Format());
-    seiBuffer = new ParsableByteArray();
+  @Override
+  public void seek() {
+    // Do nothing.
   }
 
-  public void read(byte[] data, int position, int limit, long pesTimeUs) {
-    seiBuffer.reset(data, limit);
+  @Override
+  public void consume(ParsableByteArray seiBuffer, long pesTimeUs, boolean startOfPacket) {
     // Skip the NAL prefix and type.
-    seiBuffer.setPosition(position + 4);
+    seiBuffer.skipBytes(4);
 
     int b;
     while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
@@ -56,14 +59,18 @@ public void read(byte[] data, int position, int limit, long pesTimeUs) {
         payloadSize += b;
       } while (b == 0xFF);
       // Process the payload. We only support EIA-608 payloads currently.
-      if (Eia608Parser.inspectSeiMessage(payloadType, payloadSize, seiBuffer)) {
-        startSample(pesTimeUs);
-        appendData(seiBuffer, payloadSize);
-        commitSample(true);
+      if (Eia608Parser.isSeiMessageEia608(payloadType, payloadSize, seiBuffer)) {
+        output.sampleData(seiBuffer, payloadSize);
+        output.sampleMetadata(pesTimeUs, C.SAMPLE_FLAG_SYNC, payloadSize, 0, null);
       } else {
-        seiBuffer.skip(payloadSize);
+        seiBuffer.skipBytes(payloadSize);
       }
     }
   }
 
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
similarity index 72%
rename from library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 8468254440..670f3ea8ec 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -13,26 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.hls.parser;
+package com.google.android.exoplayer.extractor.ts;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.BufferPool;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import android.util.Log;
 import android.util.SparseArray;
+import android.util.SparseBooleanArray;
 
 import java.io.IOException;
 
 /**
  * Facilitates the extraction of data from the MPEG-2 TS container format.
  */
-public final class TsExtractor extends HlsExtractor {
+public final class TsExtractor implements Extractor, SeekMap {
 
   private static final String TAG = "TsExtractor";
 
@@ -41,6 +43,8 @@
   private static final int TS_PAT_PID = 0;
 
   private static final int TS_STREAM_TYPE_AAC = 0x0F;
+  private static final int TS_STREAM_TYPE_ATSC_AC3 = 0x81;
+  private static final int TS_STREAM_TYPE_ATSC_E_AC3 = 0x87;
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
   private static final int TS_STREAM_TYPE_ID3 = 0x15;
   private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1
@@ -48,119 +52,61 @@
   private static final long MAX_PTS = 0x1FFFFFFFFL;
 
   private final ParsableByteArray tsPacketBuffer;
-  private final SparseArray<SampleQueue> sampleQueues; // Indexed by streamType
+  private final SparseBooleanArray streamTypes;
+  private final SparseBooleanArray allowedPassthroughStreamTypes;
   private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-  private final BufferPool bufferPool;
-  private final long firstSampleTimestamp;
+  private final long firstSampleTimestampUs;
   private final ParsableBitArray tsScratch;
 
   // Accessed only by the loading thread.
-  private int tsPacketBytesRead;
+  private ExtractorOutput output;
   private long timestampOffsetUs;
   private long lastPts;
 
-  // Accessed by both the loading and consuming threads.
-  private volatile boolean prepared;
+  public TsExtractor() {
+    this(0, null);
+  }
 
-  public TsExtractor(boolean shouldSpliceIn, long firstSampleTimestamp, BufferPool bufferPool) {
-    super(shouldSpliceIn);
-    this.firstSampleTimestamp = firstSampleTimestamp;
-    this.bufferPool = bufferPool;
+  public TsExtractor(long firstSampleTimestampUs, AudioCapabilities audioCapabilities) {
+    this.firstSampleTimestampUs = firstSampleTimestampUs;
     tsScratch = new ParsableBitArray(new byte[3]);
     tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
-    sampleQueues = new SparseArray<SampleQueue>();
+    streamTypes = new SparseBooleanArray();
+    allowedPassthroughStreamTypes = getPassthroughStreamTypes(audioCapabilities);
     tsPayloadReaders = new SparseArray<TsPayloadReader>();
     tsPayloadReaders.put(TS_PAT_PID, new PatReader());
     lastPts = Long.MIN_VALUE;
   }
 
-  @Override
-  public int getTrackCount() {
-    Assertions.checkState(prepared);
-    return sampleQueues.size();
-  }
-
-  @Override
-  public MediaFormat getFormat(int track) {
-    Assertions.checkState(prepared);
-    return sampleQueues.valueAt(track).getMediaFormat();
-  }
-
-  @Override
-  public boolean isPrepared() {
-    return prepared;
-  }
-
-  @Override
-  public void release() {
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      sampleQueues.valueAt(i).release();
-    }
-  }
-
-  @Override
-  public long getLargestSampleTimestamp() {
-    long largestParsedTimestampUs = Long.MIN_VALUE;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
-          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
-    }
-    return largestParsedTimestampUs;
-  }
-
-  @Override
-  public boolean getSample(int track, SampleHolder holder) {
-    Assertions.checkState(prepared);
-    return sampleQueues.valueAt(track).getSample(holder);
-  }
+  // Extractor implementation.
 
   @Override
-  public void discardUntil(int track, long timeUs) {
-    Assertions.checkState(prepared);
-    sampleQueues.valueAt(track).discardUntil(timeUs);
+  public void init(ExtractorOutput output) {
+    this.output = output;
+    output.seekMap(this);
   }
 
   @Override
-  public boolean hasSamples(int track) {
-    Assertions.checkState(prepared);
-    return !sampleQueues.valueAt(track).isEmpty();
-  }
-
-  private boolean checkPrepared() {
-    int pesPayloadReaderCount = sampleQueues.size();
-    if (pesPayloadReaderCount == 0) {
-      return false;
-    }
-    for (int i = 0; i < pesPayloadReaderCount; i++) {
-      if (!sampleQueues.valueAt(i).hasMediaFormat()) {
-        return false;
-      }
+  public void seek() {
+    timestampOffsetUs = 0;
+    lastPts = Long.MIN_VALUE;
+    for (int i = 0; i < tsPayloadReaders.size(); i++) {
+      tsPayloadReaders.valueAt(i).seek();
     }
-    return true;
   }
 
   @Override
-  public int read(DataSource dataSource) throws IOException {
-    int bytesRead = dataSource.read(tsPacketBuffer.data, tsPacketBytesRead,
-        TS_PACKET_SIZE - tsPacketBytesRead);
-    if (bytesRead == -1) {
-      return -1;
-    }
-
-    tsPacketBytesRead += bytesRead;
-    if (tsPacketBytesRead < TS_PACKET_SIZE) {
-      // We haven't read the whole packet yet.
-      return bytesRead;
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    if (!input.readFully(tsPacketBuffer.data, 0, TS_PACKET_SIZE, true)) {
+      return RESULT_END_OF_INPUT;
     }
 
-    // Reset before reading the packet.
-    tsPacketBytesRead = 0;
     tsPacketBuffer.setPosition(0);
     tsPacketBuffer.setLimit(TS_PACKET_SIZE);
-
     int syncByte = tsPacketBuffer.readUnsignedByte();
     if (syncByte != TS_SYNC_BYTE) {
-      return bytesRead;
+      return RESULT_CONTINUE;
     }
 
     tsPacketBuffer.readBytes(tsScratch, 3);
@@ -176,29 +122,34 @@ public int read(DataSource dataSource) throws IOException {
     // Skip the adaptation field.
     if (adaptationFieldExists) {
       int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-      tsPacketBuffer.skip(adaptationFieldLength);
+      tsPacketBuffer.skipBytes(adaptationFieldLength);
     }
 
     // Read the payload.
     if (payloadExists) {
       TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
       if (payloadReader != null) {
-        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator, output);
       }
     }
 
-    if (!prepared) {
-      prepared = checkPrepared();
-    }
+    return RESULT_CONTINUE;
+  }
+
+  // SeekMap implementation.
 
-    return bytesRead;
+  @Override
+  public boolean isSeekable() {
+    return false;
   }
 
   @Override
-  protected SampleQueue getSampleQueue(int track) {
-    return sampleQueues.valueAt(track);
+  public long getPosition(long timeUs) {
+    return 0;
   }
 
+  // Internals.
+
   /**
    * Adjusts a PTS value to the corresponding time in microseconds, accounting for PTS wraparound.
    *
@@ -219,19 +170,54 @@ protected SampleQueue getSampleQueue(int track) {
     long timeUs = (pts * C.MICROS_PER_SECOND) / 90000;
     // If we haven't done the initial timestamp adjustment, do it now.
     if (lastPts == Long.MIN_VALUE) {
-      timestampOffsetUs = firstSampleTimestamp - timeUs;
+      timestampOffsetUs = firstSampleTimestampUs - timeUs;
     }
     // Record the adjusted PTS to adjust for wraparound next time.
     lastPts = pts;
     return timeUs + timestampOffsetUs;
   }
 
+  /**
+   * Returns a sparse boolean array of stream types that can be played back based on
+   * {@code audioCapabilities}.
+   */
+  private static SparseBooleanArray getPassthroughStreamTypes(AudioCapabilities audioCapabilities) {
+    SparseBooleanArray streamTypes = new SparseBooleanArray();
+    if (audioCapabilities != null) {
+      if (audioCapabilities.supportsEncoding(C.ENCODING_AC3)) {
+        streamTypes.put(TS_STREAM_TYPE_ATSC_AC3, true);
+      }
+      if (audioCapabilities.supportsEncoding(C.ENCODING_E_AC3)) {
+        // TODO: Uncomment when Ac3Reader supports enhanced AC-3.
+        // streamTypes.put(TS_STREAM_TYPE_ATSC_E_AC3, true);
+      }
+    }
+    return streamTypes;
+  }
+
   /**
    * Parses TS packet payload data.
    */
   private abstract static class TsPayloadReader {
 
-    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);
+    /**
+     * Notifies the reader that a seek has occurred.
+     * <p>
+     * Following a call to this method, the data passed to the next invocation of
+     * {@link #consume(ParsableByteArray, boolean, ExtractorOutput)} will not be a continuation of
+     * the data that was previously passed. Hence the reader should reset any internal state.
+     */
+    public abstract void seek();
+
+    /**
+     * Consumes the payload of a TS packet.
+     *
+     * @param data The TS packet. The position will be set to the start of the payload.
+     * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
+     * @param output The output to which parsed data should be written.
+     */
+    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
+        ExtractorOutput output);
 
   }
 
@@ -247,11 +233,17 @@ public PatReader() {
     }
 
     @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+    public void seek() {
+      // Do nothing.
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
+        ExtractorOutput output) {
       // Skip pointer.
       if (payloadUnitStartIndicator) {
         int pointerField = data.readUnsignedByte();
-        data.skip(pointerField);
+        data.skipBytes(pointerField);
       }
 
       data.readBytes(patScratch, 3);
@@ -259,7 +251,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
       int sectionLength = patScratch.readBits(12);
       // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8)
-      data.skip(5);
+      data.skipBytes(5);
 
       int programCount = (sectionLength - 9) / 4;
       for (int i = 0; i < programCount; i++) {
@@ -286,11 +278,17 @@ public PmtReader() {
     }
 
     @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+    public void seek() {
+      // Do nothing.
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
+        ExtractorOutput output) {
       // Skip pointer.
       if (payloadUnitStartIndicator) {
         int pointerField = data.readUnsignedByte();
-        data.skip(pointerField);
+        data.skipBytes(pointerField);
       }
 
       data.readBytes(pmtScratch, 3);
@@ -300,14 +298,18 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
       // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
       // Skip the rest of the PMT header.
-      data.skip(7);
+      data.skipBytes(7);
 
       data.readBytes(pmtScratch, 2);
       pmtScratch.skipBits(4);
       int programInfoLength = pmtScratch.readBits(12);
 
       // Skip the descriptors.
-      data.skip(programInfoLength);
+      data.skipBytes(programInfoLength);
+
+      // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
+      // appears intermittently during playback. See b/20261500.
+      Id3Reader id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
 
       int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
           - programInfoLength - 4 /* CRC size */;
@@ -320,35 +322,42 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
         int esInfoLength = pmtScratch.readBits(12);
 
         // Skip the descriptors.
-        data.skip(esInfoLength);
+        data.skipBytes(esInfoLength);
         entriesSize -= esInfoLength + 5;
 
-        if (sampleQueues.get(streamType) != null) {
+        if (streamTypes.get(streamType)) {
           continue;
         }
 
+        // TODO: Detect and read DVB AC-3 streams with Ac3Reader.
         ElementaryStreamReader pesPayloadReader = null;
         switch (streamType) {
           case TS_STREAM_TYPE_AAC:
-            pesPayloadReader = new AdtsReader(bufferPool);
+            pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC));
+            break;
+          case TS_STREAM_TYPE_ATSC_E_AC3:
+          case TS_STREAM_TYPE_ATSC_AC3:
+            if (!allowedPassthroughStreamTypes.get(streamType)) {
+              continue;
+            }
+            pesPayloadReader = new Ac3Reader(output.track(streamType));
             break;
           case TS_STREAM_TYPE_H264:
-            SeiReader seiReader = new SeiReader(bufferPool);
-            sampleQueues.put(TS_STREAM_TYPE_EIA608, seiReader);
-            pesPayloadReader = new H264Reader(bufferPool, seiReader);
+            SeiReader seiReader = new SeiReader(output.track(TS_STREAM_TYPE_EIA608));
+            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264), seiReader);
             break;
           case TS_STREAM_TYPE_ID3:
-            pesPayloadReader = new Id3Reader(bufferPool);
+            pesPayloadReader = id3Reader;
             break;
         }
 
         if (pesPayloadReader != null) {
-          sampleQueues.put(streamType, pesPayloadReader);
+          streamTypes.put(streamType, true);
           tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
         }
       }
 
-      // Skip CRC_32.
+      output.endTracks();
     }
 
   }
@@ -375,9 +384,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
 
     private boolean ptsFlag;
     private int extendedHeaderLength;
-
     private int payloadSize;
-
     private long timeUs;
 
     public PesReader(ElementaryStreamReader pesPayloadReader) {
@@ -387,7 +394,16 @@ public PesReader(ElementaryStreamReader pesPayloadReader) {
     }
 
     @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+    public void seek() {
+      state = STATE_FINDING_HEADER;
+      bytesRead = 0;
+      bodyStarted = false;
+      pesPayloadReader.seek();
+    }
+
+    @Override
+    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
+        ExtractorOutput output) {
       if (payloadUnitStartIndicator) {
         switch (state) {
           case STATE_FINDING_HEADER:
@@ -417,17 +433,17 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
       while (data.bytesLeft() > 0) {
         switch (state) {
           case STATE_FINDING_HEADER:
-            data.skip(data.bytesLeft());
+            data.skipBytes(data.bytesLeft());
             break;
           case STATE_READING_HEADER:
-            if (continueRead(data, pesScratch.getData(), HEADER_SIZE)) {
+            if (continueRead(data, pesScratch.data, HEADER_SIZE)) {
               setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
             }
             break;
           case STATE_READING_HEADER_EXTENSION:
             int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
             // Read as much of the extended header as we're interested in, and skip the rest.
-            if (continueRead(data, pesScratch.getData(), readLength)
+            if (continueRead(data, pesScratch.data, readLength)
                 && continueRead(data, null, extendedHeaderLength)) {
               parseHeaderExtension();
               bodyStarted = false;
@@ -474,7 +490,7 @@ private boolean continueRead(ParsableByteArray source, byte[] target, int target
       if (bytesToRead <= 0) {
         return true;
       } else if (target == null) {
-        source.skip(bytesToRead);
+        source.skipBytes(bytesToRead);
       } else {
         source.readBytes(target, bytesRead, bytesToRead);
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
new file mode 100644
index 0000000000..f99c115ec9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.Stack;
+
+/**
+ * Default implementation of {@link EbmlReader}.
+ */
+/* package */ final class DefaultEbmlReader implements EbmlReader {
+
+  private static final int ELEMENT_STATE_READ_ID = 0;
+  private static final int ELEMENT_STATE_READ_CONTENT_SIZE = 1;
+  private static final int ELEMENT_STATE_READ_CONTENT = 2;
+
+  private static final int MAX_INTEGER_ELEMENT_SIZE_BYTES = 8;
+  private static final int VALID_FLOAT32_ELEMENT_SIZE_BYTES = 4;
+  private static final int VALID_FLOAT64_ELEMENT_SIZE_BYTES = 8;
+
+  private final byte[] scratch = new byte[8];
+  private final Stack<MasterElement> masterElementsStack = new Stack<MasterElement>();
+  private final VarintReader varintReader = new VarintReader();
+
+  private EbmlReaderOutput output;
+  private int elementState;
+  private int elementId;
+  private long elementContentSize;
+
+  @Override
+  public void init(EbmlReaderOutput eventHandler) {
+    this.output = eventHandler;
+  }
+
+  @Override
+  public void reset() {
+    elementState = ELEMENT_STATE_READ_ID;
+    masterElementsStack.clear();
+    varintReader.reset();
+  }
+
+  @Override
+  public boolean read(ExtractorInput input) throws IOException, InterruptedException {
+    Assertions.checkState(output != null);
+    while (true) {
+      if (!masterElementsStack.isEmpty()
+          && input.getPosition() >= masterElementsStack.peek().elementEndPosition) {
+        output.endMasterElement(masterElementsStack.pop().elementId);
+        return true;
+      }
+
+      if (elementState == ELEMENT_STATE_READ_ID) {
+        long result = varintReader.readUnsignedVarint(input, true, false);
+        if (result == -1) {
+          return false;
+        }
+        // Element IDs are at most 4 bytes, so we can cast to integers.
+        elementId = (int) result;
+        elementState = ELEMENT_STATE_READ_CONTENT_SIZE;
+      }
+
+      if (elementState == ELEMENT_STATE_READ_CONTENT_SIZE) {
+        elementContentSize = varintReader.readUnsignedVarint(input, false, true);
+        elementState = ELEMENT_STATE_READ_CONTENT;
+      }
+
+      int type = output.getElementType(elementId);
+      switch (type) {
+        case TYPE_MASTER:
+          long elementContentPosition = input.getPosition();
+          long elementEndPosition = elementContentPosition + elementContentSize;
+          masterElementsStack.add(new MasterElement(elementId, elementEndPosition));
+          output.startMasterElement(elementId, elementContentPosition, elementContentSize);
+          elementState = ELEMENT_STATE_READ_ID;
+          return true;
+        case TYPE_UNSIGNED_INT:
+          if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
+            throw new IllegalStateException("Invalid integer size: " + elementContentSize);
+          }
+          output.integerElement(elementId, readInteger(input, (int) elementContentSize));
+          elementState = ELEMENT_STATE_READ_ID;
+          return true;
+        case TYPE_FLOAT:
+          if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES
+              && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
+            throw new IllegalStateException("Invalid float size: " + elementContentSize);
+          }
+          output.floatElement(elementId, readFloat(input, (int) elementContentSize));
+          elementState = ELEMENT_STATE_READ_ID;
+          return true;
+        case TYPE_STRING:
+          if (elementContentSize > Integer.MAX_VALUE) {
+            throw new IllegalStateException("String element size: " + elementContentSize);
+          }
+          output.stringElement(elementId, readString(input, (int) elementContentSize));
+          elementState = ELEMENT_STATE_READ_ID;
+          return true;
+        case TYPE_BINARY:
+          output.binaryElement(elementId, (int) elementContentSize, input);
+          elementState = ELEMENT_STATE_READ_ID;
+          return true;
+        case TYPE_UNKNOWN:
+          input.skipFully((int) elementContentSize);
+          elementState = ELEMENT_STATE_READ_ID;
+          break;
+        default:
+          throw new IllegalStateException("Invalid element type " + type);
+      }
+    }
+  }
+
+  /**
+   * Reads and returns an integer of length {@code byteLength} from the {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @param byteLength The length of the integer being read.
+   * @return The read integer value.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private long readInteger(ExtractorInput input, int byteLength)
+      throws IOException, InterruptedException {
+    input.readFully(scratch, 0, byteLength);
+    long value = 0;
+    for (int i = 0; i < byteLength; i++) {
+      value = (value << 8) | (scratch[i] & 0xFF);
+    }
+    return value;
+  }
+
+  /**
+   * Reads and returns a float of length {@code byteLength} from the {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @param byteLength The length of the float being read.
+   * @return The read float value.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private double readFloat(ExtractorInput input, int byteLength)
+      throws IOException, InterruptedException {
+    long integerValue = readInteger(input, byteLength);
+    double floatValue;
+    if (byteLength == VALID_FLOAT32_ELEMENT_SIZE_BYTES) {
+      floatValue = Float.intBitsToFloat((int) integerValue);
+    } else {
+      floatValue = Double.longBitsToDouble(integerValue);
+    }
+    return floatValue;
+  }
+
+  /**
+   * Reads and returns a string of length {@code byteLength} from the {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @param byteLength The length of the float being read.
+   * @return The read string value.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private String readString(ExtractorInput input, int byteLength)
+      throws IOException, InterruptedException {
+    byte[] stringBytes = new byte[byteLength];
+    input.readFully(stringBytes, 0, byteLength);
+    return new String(stringBytes, Charset.forName(C.UTF8_NAME));
+  }
+
+  /**
+   * Used in {@link #masterElementsStack} to track when the current master element ends, so that
+   * {@link EbmlReaderOutput#endMasterElement(int)} can be called.
+   */
+  private static final class MasterElement {
+
+    private final int elementId;
+    private final long elementEndPosition;
+
+    private MasterElement(int elementId, long elementEndPosition) {
+      this.elementId = elementId;
+      this.elementEndPosition = elementEndPosition;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReader.java
new file mode 100644
index 0000000000..0ddbf4476f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReader.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import java.io.IOException;
+
+/**
+ * Event-driven EBML reader that delivers events to an {@link EbmlReaderOutput}.
+ * <p>
+ * EBML can be summarized as a binary XML format somewhat similar to Protocol Buffers. It was
+ * originally designed for the Matroska container format. More information about EBML and
+ * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
+ */
+/* package */ interface EbmlReader {
+
+  /**
+   * Type for unknown elements.
+   */
+  public static final int TYPE_UNKNOWN = 0;
+  /**
+   * Type for elements that contain child elements.
+   */
+  public static final int TYPE_MASTER = 1;
+  /**
+   * Type for integer value elements of up to 8 bytes.
+   */
+  public static final int TYPE_UNSIGNED_INT = 2;
+  /**
+   * Type for string elements.
+   */
+  public static final int TYPE_STRING = 3;
+  /**
+   * Type for binary elements.
+   */
+  public static final int TYPE_BINARY = 4;
+  /**
+   * Type for IEEE floating point value elements of either 4 or 8 bytes.
+   */
+  public static final int TYPE_FLOAT = 5;
+
+  /**
+   * Initializes the extractor with an {@link EbmlReaderOutput}.
+   *
+   * @param output An {@link EbmlReaderOutput} to receive events.
+   */
+  public void init(EbmlReaderOutput output);
+
+  /**
+   * Resets the state of the reader.
+   * <p>
+   * Subsequent calls to {@link #read(ExtractorInput)} will start reading a new EBML structure
+   * from scratch.
+   */
+  public void reset();
+
+  /**
+   * Reads from an {@link ExtractorInput}, invoking an event callback if possible.
+   *
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @return True if data can continue to be read. False if the end of the input was encountered.
+   * @throws ParserException If parsing fails.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  public boolean read(ExtractorInput input) throws ParserException, IOException,
+      InterruptedException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReaderOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReaderOutput.java
new file mode 100644
index 0000000000..d72f886f9b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/EbmlReaderOutput.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import java.io.IOException;
+
+/**
+ * Defines EBML element IDs/types and reacts to events.
+ */
+/* package */ interface EbmlReaderOutput {
+
+  /**
+   * Maps an element ID to a corresponding type.
+   * <p>
+   * If {@link EbmlReader#TYPE_UNKNOWN} is returned then the element is skipped. Note that all
+   * children of a skipped element are also skipped.
+   *
+   * @param id The element ID to map.
+   * @return One of the {@code TYPE_} constants defined in {@link EbmlReader}.
+   */
+  int getElementType(int id);
+
+  /**
+   * Called when the start of a master element is encountered.
+   * <p>
+   * Following events should be considered as taking place within this element until a matching call
+   * to {@link #endMasterElement(int)} is made.
+   * <p>
+   * Note that it is possible for another master element of the same element ID to be nested within
+   * itself.
+   *
+   * @param id The element ID.
+   * @param contentPosition The position of the start of the element's content in the stream.
+   * @param contentSize The size of the element's content in bytes.
+   * @throws ParserException If a parsing error occurs.
+   */
+  void startMasterElement(int id, long contentPosition, long contentSize) throws ParserException;
+
+  /**
+   * Called when the end of a master element is encountered.
+   *
+   * @param id The element ID.
+   * @throws ParserException If a parsing error occurs.
+   */
+  void endMasterElement(int id) throws ParserException;
+
+  /**
+   * Called when an integer element is encountered.
+   *
+   * @param id The element ID.
+   * @param value The integer value that the element contains.
+   * @throws ParserException If a parsing error occurs.
+   */
+  void integerElement(int id, long value) throws ParserException;
+
+  /**
+   * Called when a float element is encountered.
+   *
+   * @param id The element ID.
+   * @param value The float value that the element contains
+   * @throws ParserException If a parsing error occurs.
+   */
+  void floatElement(int id, double value) throws ParserException;
+
+  /**
+   * Called when a string element is encountered.
+   *
+   * @param id The element ID.
+   * @param value The string value that the element contains.
+   * @throws ParserException If a parsing error occurs.
+   */
+  void stringElement(int id, String value) throws ParserException;
+
+  /**
+   * Called when a binary element is encountered.
+   * <p>
+   * The element header (containing the element ID and content size) will already have been read.
+   * Implementations are required to consume the whole remainder of the element, which is
+   * {@code contentSize} bytes in length, before returning. Implementations are permitted to fail
+   * (by throwing an exception) having partially consumed the data, however if they do this, they
+   * must consume the remainder of the content when invoked again.
+   *
+   * @param id The element ID.
+   * @param contentsSize The element's content size.
+   * @param input The {@link ExtractorInput} from which data should be read.
+   * @throws ParserException If a parsing error occurs.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void binaryElement(int id, int contentsSize, ExtractorInput input)
+      throws ParserException, IOException, InterruptedException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
new file mode 100644
index 0000000000..07973732e8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
@@ -0,0 +1,107 @@
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * Reads EBML variable-length integers (varints) from an {@link ExtractorInput}.
+ */
+/* package */ class VarintReader {
+
+  private static final int STATE_BEGIN_READING = 0;
+  private static final int STATE_READ_CONTENTS = 1;
+
+  /**
+   * The first byte of a variable-length integer (varint) will have one of these bit masks
+   * indicating the total length in bytes.
+   *
+   * <p>{@code 0x80} is a one-byte integer, {@code 0x40} is two bytes, and so on up to eight bytes.
+   */
+  private static final int[] VARINT_LENGTH_MASKS = new int[] {
+    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
+  };
+
+  private final byte[] scratch;
+
+  private int state;
+  private int length;
+
+  public VarintReader() {
+    scratch = new byte[8];
+  }
+
+  /**
+   * Resets the reader to start reading a new variable-length integer.
+   */
+  public void reset() {
+    state = STATE_BEGIN_READING;
+    length = 0;
+  }
+
+  /**
+   * Reads an EBML variable-length integer (varint) from an {@link ExtractorInput} such that
+   * reading can be resumed later if an error occurs having read only some of it.
+   * <p>
+   * If an value is successfully read, then the reader will automatically reset itself ready to
+   * read another value.
+   * <p>
+   * If an {@link IOException} or {@link InterruptedException} is throw, the read can be resumed
+   * later by calling this method again, passing an {@link ExtractorInput} providing data starting
+   * where the previous one left off.
+   *
+   * @param input The {@link ExtractorInput} from which the integer should be read.
+   * @param allowEndOfInput True if encountering the end of the input having read no data is
+   *     allowed, and should result in {@code -1} being returned. False if it should be
+   *     considered an error, causing an {@link EOFException} to be thrown.
+   * @param removeLengthMask Removes the variable-length integer length mask from the value
+   * @return The read value, or -1 if {@code allowEndOfStream} is true and the end of the input was
+   *     encountered.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  public long readUnsignedVarint(ExtractorInput input, boolean allowEndOfInput,
+      boolean removeLengthMask) throws IOException, InterruptedException {
+    if (state == STATE_BEGIN_READING) {
+      // Read the first byte to establish the length.
+      if (!input.readFully(scratch, 0, 1, allowEndOfInput)) {
+        return -1;
+      }
+      int firstByte = scratch[0] & 0xFF;
+      length = -1;
+      for (int i = 0; i < VARINT_LENGTH_MASKS.length; i++) {
+        if ((VARINT_LENGTH_MASKS[i] & firstByte) != 0) {
+          length = i + 1;
+          break;
+        }
+      }
+      if (length == -1) {
+        throw new IllegalStateException("No valid varint length mask found");
+      }
+      state = STATE_READ_CONTENTS;
+    }
+
+    // Read the remaining bytes.
+    input.readFully(scratch, 1, length - 1);
+
+    // Parse the value.
+    if (removeLengthMask) {
+      scratch[0] &= ~VARINT_LENGTH_MASKS[length - 1];
+    }
+    long varint = 0;
+    for (int i = 0; i < length; i++) {
+      varint = (varint << 8) | (scratch[i] & 0xFF);
+    }
+    state = STATE_BEGIN_READING;
+    return varint;
+  }
+
+  /**
+   * Returns the number of bytes occupied by the most recently parsed varint.
+   */
+  public int getLastLength() {
+    return length;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
new file mode 100644
index 0000000000..f0ed882255
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -0,0 +1,875 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ChunkIndex;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.LongArray;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * An extractor to facilitate data retrieval from the WebM container format.
+ * <p>
+ * WebM is a subset of the EBML elements defined for Matroska. More information about EBML and
+ * Matroska is available <a href="http://www.matroska.org/technical/specs/index.html">here</a>.
+ * More info about WebM is <a href="http://www.webmproject.org/code/specs/container/">here</a>.
+ * RFC on encrypted WebM can be found
+ * <a href="http://wiki.webmproject.org/encryption/webm-encryption-rfc">here</a>.
+ */
+public final class WebmExtractor implements Extractor {
+
+  private static final int SAMPLE_STATE_START = 0;
+  private static final int SAMPLE_STATE_HEADER = 1;
+  private static final int SAMPLE_STATE_DATA = 2;
+
+  private static final int CUES_STATE_NOT_BUILT = 0;
+  private static final int CUES_STATE_BUILDING = 1;
+  private static final int CUES_STATE_BUILT = 2;
+
+  private static final String DOC_TYPE_WEBM = "webm";
+  private static final String CODEC_ID_VP8 = "V_VP8";
+  private static final String CODEC_ID_VP9 = "V_VP9";
+  private static final String CODEC_ID_VORBIS = "A_VORBIS";
+  private static final String CODEC_ID_OPUS = "A_OPUS";
+  private static final int VORBIS_MAX_INPUT_SIZE = 8192;
+  private static final int OPUS_MAX_INPUT_SIZE = 5760;
+  private static final int ENCRYPTION_IV_SIZE = 8;
+  private static final int TRACK_TYPE_AUDIO = 2;
+  private static final int TRACK_TYPE_VIDEO = 1;
+  private static final int UNKNOWN = -1;
+
+  private static final int ID_EBML = 0x1A45DFA3;
+  private static final int ID_EBML_READ_VERSION = 0x42F7;
+  private static final int ID_DOC_TYPE = 0x4282;
+  private static final int ID_DOC_TYPE_READ_VERSION = 0x4285;
+  private static final int ID_SEGMENT = 0x18538067;
+  private static final int ID_SEEK_HEAD = 0x114D9B74;
+  private static final int ID_SEEK = 0x4DBB;
+  private static final int ID_SEEK_ID = 0x53AB;
+  private static final int ID_SEEK_POSITION = 0x53AC;
+  private static final int ID_INFO = 0x1549A966;
+  private static final int ID_TIMECODE_SCALE = 0x2AD7B1;
+  private static final int ID_DURATION = 0x4489;
+  private static final int ID_CLUSTER = 0x1F43B675;
+  private static final int ID_TIME_CODE = 0xE7;
+  private static final int ID_SIMPLE_BLOCK = 0xA3;
+  private static final int ID_BLOCK_GROUP = 0xA0;
+  private static final int ID_BLOCK = 0xA1;
+  private static final int ID_REFERENCE_BLOCK = 0xFB;
+  private static final int ID_TRACKS = 0x1654AE6B;
+  private static final int ID_TRACK_ENTRY = 0xAE;
+  private static final int ID_TRACK_NUMBER = 0xD7;
+  private static final int ID_TRACK_TYPE = 0x83;
+  private static final int ID_CODEC_ID = 0x86;
+  private static final int ID_CODEC_PRIVATE = 0x63A2;
+  private static final int ID_CODEC_DELAY = 0x56AA;
+  private static final int ID_SEEK_PRE_ROLL = 0x56BB;
+  private static final int ID_VIDEO = 0xE0;
+  private static final int ID_PIXEL_WIDTH = 0xB0;
+  private static final int ID_PIXEL_HEIGHT = 0xBA;
+  private static final int ID_AUDIO = 0xE1;
+  private static final int ID_CHANNELS = 0x9F;
+  private static final int ID_SAMPLING_FREQUENCY = 0xB5;
+  private static final int ID_CONTENT_ENCODINGS = 0x6D80;
+  private static final int ID_CONTENT_ENCODING = 0x6240;
+  private static final int ID_CONTENT_ENCODING_ORDER = 0x5031;
+  private static final int ID_CONTENT_ENCODING_SCOPE = 0x5032;
+  private static final int ID_CONTENT_ENCODING_TYPE = 0x5033;
+  private static final int ID_CONTENT_ENCRYPTION = 0x5035;
+  private static final int ID_CONTENT_ENCRYPTION_ALGORITHM = 0x47E1;
+  private static final int ID_CONTENT_ENCRYPTION_KEY_ID = 0x47E2;
+  private static final int ID_CONTENT_ENCRYPTION_AES_SETTINGS = 0x47E7;
+  private static final int ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE = 0x47E8;
+  private static final int ID_CUES = 0x1C53BB6B;
+  private static final int ID_CUE_POINT = 0xBB;
+  private static final int ID_CUE_TIME = 0xB3;
+  private static final int ID_CUE_TRACK_POSITIONS = 0xB7;
+  private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
+
+  private static final int LACING_NONE = 0;
+
+  private final EbmlReader reader;
+  private final VarintReader varintReader;
+  private final ParsableByteArray sampleHeaderScratch;
+  private final ParsableByteArray vorbisNumPageSamples;
+  private final ParsableByteArray seekEntryIdBytes;
+
+  private long segmentContentPosition = UNKNOWN;
+  private long segmentContentSize = UNKNOWN;
+  private long timecodeScale = 1000000L;
+  private long durationUs = C.UNKNOWN_TIME_US;
+
+  private TrackFormat trackFormat;  // Used to store the last seen track.
+  private TrackFormat audioTrackFormat;
+  private TrackFormat videoTrackFormat;
+
+  private boolean sentDrmInitData;
+
+  // Master seek entry related elements.
+  private int seekEntryId;
+  private long seekEntryPosition;
+
+  // Cue related elements.
+  private boolean seekForCues;
+  private long cuesContentPosition = UNKNOWN;
+  private long seekPositionAfterBuildingCues = UNKNOWN;
+  private int cuesState = CUES_STATE_NOT_BUILT;
+  private long clusterTimecodeUs = UNKNOWN;
+  private LongArray cueTimesUs;
+  private LongArray cueClusterPositions;
+  private boolean seenClusterPositionForCurrentCuePoint;
+
+  // Sample reading state.
+  private int blockBytesRead;
+  private int sampleState;
+  private int sampleSize;
+  private int sampleTrackNumber;
+  private int sampleFlags;
+  private long sampleTimeUs;
+  private boolean sampleRead;
+  private boolean sampleSeenReferenceBlock;
+
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+
+  public WebmExtractor() {
+    this(new DefaultEbmlReader());
+  }
+
+  /* package */ WebmExtractor(EbmlReader reader) {
+    this.reader = reader;
+    this.reader.init(new InnerEbmlReaderOutput());
+    varintReader = new VarintReader();
+    sampleHeaderScratch = new ParsableByteArray(4);
+    vorbisNumPageSamples = new ParsableByteArray(ByteBuffer.allocate(4).putInt(-1).array());
+    seekEntryIdBytes = new ParsableByteArray(4);
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+  }
+
+  @Override
+  public void seek() {
+    clusterTimecodeUs = UNKNOWN;
+    sampleState = SAMPLE_STATE_START;
+    reader.reset();
+    varintReader.reset();
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
+      InterruptedException {
+    sampleRead = false;
+    boolean continueReading = true;
+    while (continueReading && !sampleRead) {
+      continueReading = reader.read(input);
+      if (continueReading && maybeSeekForCues(seekPosition, input.getPosition())) {
+        return Extractor.RESULT_SEEK;
+      }
+    }
+    return continueReading ? Extractor.RESULT_CONTINUE : Extractor.RESULT_END_OF_INPUT;
+  }
+
+  /* package */ int getElementType(int id) {
+    switch (id) {
+      case ID_EBML:
+      case ID_SEGMENT:
+      case ID_SEEK_HEAD:
+      case ID_SEEK:
+      case ID_INFO:
+      case ID_CLUSTER:
+      case ID_TRACKS:
+      case ID_TRACK_ENTRY:
+      case ID_AUDIO:
+      case ID_VIDEO:
+      case ID_CONTENT_ENCODINGS:
+      case ID_CONTENT_ENCODING:
+      case ID_CONTENT_ENCRYPTION:
+      case ID_CONTENT_ENCRYPTION_AES_SETTINGS:
+      case ID_CUES:
+      case ID_CUE_POINT:
+      case ID_CUE_TRACK_POSITIONS:
+      case ID_BLOCK_GROUP:
+        return EbmlReader.TYPE_MASTER;
+      case ID_EBML_READ_VERSION:
+      case ID_DOC_TYPE_READ_VERSION:
+      case ID_SEEK_POSITION:
+      case ID_TIMECODE_SCALE:
+      case ID_TIME_CODE:
+      case ID_PIXEL_WIDTH:
+      case ID_PIXEL_HEIGHT:
+      case ID_TRACK_NUMBER:
+      case ID_TRACK_TYPE:
+      case ID_CODEC_DELAY:
+      case ID_SEEK_PRE_ROLL:
+      case ID_CHANNELS:
+      case ID_CONTENT_ENCODING_ORDER:
+      case ID_CONTENT_ENCODING_SCOPE:
+      case ID_CONTENT_ENCODING_TYPE:
+      case ID_CONTENT_ENCRYPTION_ALGORITHM:
+      case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
+      case ID_CUE_TIME:
+      case ID_CUE_CLUSTER_POSITION:
+      case ID_REFERENCE_BLOCK:
+        return EbmlReader.TYPE_UNSIGNED_INT;
+      case ID_DOC_TYPE:
+      case ID_CODEC_ID:
+        return EbmlReader.TYPE_STRING;
+      case ID_SEEK_ID:
+      case ID_CONTENT_ENCRYPTION_KEY_ID:
+      case ID_SIMPLE_BLOCK:
+      case ID_BLOCK:
+      case ID_CODEC_PRIVATE:
+        return EbmlReader.TYPE_BINARY;
+      case ID_DURATION:
+      case ID_SAMPLING_FREQUENCY:
+        return EbmlReader.TYPE_FLOAT;
+      default:
+        return EbmlReader.TYPE_UNKNOWN;
+    }
+  }
+
+  /* package */ void startMasterElement(int id, long contentPosition, long contentSize)
+      throws ParserException {
+    switch (id) {
+      case ID_SEGMENT:
+        if (segmentContentPosition != UNKNOWN) {
+          throw new ParserException("Multiple Segment elements not supported");
+        }
+        segmentContentPosition = contentPosition;
+        segmentContentSize = contentSize;
+        return;
+      case ID_SEEK:
+        seekEntryId = UNKNOWN;
+        seekEntryPosition = UNKNOWN;
+        return;
+      case ID_CUES:
+        cueTimesUs = new LongArray();
+        cueClusterPositions = new LongArray();
+        return;
+      case ID_CUE_POINT:
+        seenClusterPositionForCurrentCuePoint = false;
+        return;
+      case ID_CLUSTER:
+        // If we encounter a Cluster before building Cues, then we should try to build cues first
+        // before parsing the Cluster.
+        if (cuesState == CUES_STATE_NOT_BUILT && cuesContentPosition != UNKNOWN) {
+          seekForCues = true;
+        }
+        return;
+      case ID_BLOCK_GROUP:
+        sampleSeenReferenceBlock = false;
+        return;
+      case ID_CONTENT_ENCODING:
+        // TODO: check and fail if more than one content encoding is present.
+        return;
+      case ID_CONTENT_ENCRYPTION:
+        trackFormat.hasContentEncryption = true;
+        return;
+      case ID_TRACK_ENTRY:
+        trackFormat = new TrackFormat();
+        return;
+      default:
+        return;
+    }
+  }
+
+  /* package */ void endMasterElement(int id) throws ParserException {
+    switch (id) {
+      case ID_SEEK:
+        if (seekEntryId == UNKNOWN || seekEntryPosition == UNKNOWN) {
+          throw new ParserException("Mandatory element SeekID or SeekPosition not found");
+        }
+        if (seekEntryId == ID_CUES) {
+          cuesContentPosition = seekEntryPosition;
+        }
+        return;
+      case ID_CUES:
+        if (cuesState != CUES_STATE_BUILT) {
+          extractorOutput.seekMap(buildCues());
+          cuesState = CUES_STATE_BUILT;
+        } else {
+          // We have already built the cues. Ignore.
+        }
+        return;
+      case ID_BLOCK_GROUP:
+        if (sampleState != SAMPLE_STATE_DATA) {
+          // We've skipped this sample (due to incompatible track number).
+          return;
+        }
+        // If the ReferenceBlock element was not found for this sample, then it is a keyframe.
+        if (!sampleSeenReferenceBlock) {
+          sampleFlags |= C.SAMPLE_FLAG_SYNC;
+        }
+        outputSampleMetadata(
+            (audioTrackFormat != null && sampleTrackNumber == audioTrackFormat.number)
+                ? audioTrackFormat.trackOutput : videoTrackFormat.trackOutput);
+        return;
+      case ID_CONTENT_ENCODING:
+        if (!trackFormat.hasContentEncryption) {
+          // We found a ContentEncoding other than Encryption.
+          throw new ParserException("Found an unsupported ContentEncoding");
+        }
+        if (trackFormat.encryptionKeyId == null) {
+          throw new ParserException("Encrypted Track found but ContentEncKeyID was not found");
+        }
+        if (!sentDrmInitData) {
+          extractorOutput.drmInitData(
+              new DrmInitData.Universal(MimeTypes.VIDEO_WEBM, trackFormat.encryptionKeyId));
+          sentDrmInitData = true;
+        }
+        return;
+      case ID_TRACK_ENTRY:
+        if (trackFormat.number == UNKNOWN || trackFormat.type == UNKNOWN) {
+          throw new ParserException("Mandatory element TrackNumber or TrackType not found");
+        }
+        if ((trackFormat.type == TRACK_TYPE_AUDIO && audioTrackFormat != null)
+            || (trackFormat.type == TRACK_TYPE_VIDEO && videoTrackFormat != null)) {
+          // There is more than 1 audio/video track. Ignore everything but the first.
+          trackFormat = null;
+          return;
+        }
+        if (trackFormat.type == TRACK_TYPE_AUDIO && isCodecSupported(trackFormat.codecId)) {
+          audioTrackFormat = trackFormat;
+          audioTrackFormat.trackOutput = extractorOutput.track(audioTrackFormat.number);
+          audioTrackFormat.trackOutput.format(buildAudioFormat());
+        } else if (trackFormat.type == TRACK_TYPE_VIDEO && isCodecSupported(trackFormat.codecId)) {
+          videoTrackFormat = trackFormat;
+          videoTrackFormat.trackOutput = extractorOutput.track(videoTrackFormat.number);
+          videoTrackFormat.trackOutput.format(buildVideoFormat());
+        } else {
+          // Unsupported track type. Do nothing.
+        }
+        trackFormat = null;
+        return;
+      case ID_TRACKS:
+        if (videoTrackFormat == null && audioTrackFormat == null) {
+          throw new ParserException("No valid tracks were found");
+        }
+        extractorOutput.endTracks();
+        return;
+      default:
+        return;
+    }
+  }
+
+  /* package */ void integerElement(int id, long value) throws ParserException {
+    switch (id) {
+      case ID_EBML_READ_VERSION:
+        // Validate that EBMLReadVersion is supported. This extractor only supports v1.
+        if (value != 1) {
+          throw new ParserException("EBMLReadVersion " + value + " not supported");
+        }
+        return;
+      case ID_DOC_TYPE_READ_VERSION:
+        // Validate that DocTypeReadVersion is supported. This extractor only supports up to v2.
+        if (value < 1 || value > 2) {
+          throw new ParserException("DocTypeReadVersion " + value + " not supported");
+        }
+        return;
+      case ID_SEEK_POSITION:
+        // Seek Position is the relative offset beginning from the Segment. So to get absolute
+        // offset from the beginning of the file, we need to add segmentContentPosition to it.
+        seekEntryPosition = value + segmentContentPosition;
+        return;
+      case ID_TIMECODE_SCALE:
+        timecodeScale = value;
+        return;
+      case ID_PIXEL_WIDTH:
+        trackFormat.pixelWidth = (int) value;
+        return;
+      case ID_PIXEL_HEIGHT:
+        trackFormat.pixelHeight = (int) value;
+        return;
+      case ID_TRACK_NUMBER:
+        trackFormat.number = (int) value;
+        return;
+      case ID_TRACK_TYPE:
+        trackFormat.type = (int) value;
+        return;
+      case ID_CODEC_DELAY:
+        trackFormat.codecDelayNs = value;
+        return;
+      case ID_SEEK_PRE_ROLL:
+        trackFormat.seekPreRollNs = value;
+        return;
+      case ID_CHANNELS:
+        trackFormat.channelCount = (int) value;
+        return;
+      case ID_REFERENCE_BLOCK:
+        sampleSeenReferenceBlock = true;
+        return;
+      case ID_CONTENT_ENCODING_ORDER:
+        // This extractor only supports one ContentEncoding element and hence the order has to be 0.
+        if (value != 0) {
+          throw new ParserException("ContentEncodingOrder " + value + " not supported");
+        }
+        return;
+      case ID_CONTENT_ENCODING_SCOPE:
+        // This extractor only supports the scope of all frames (since that's the only scope used
+        // for Encryption).
+        if (value != 1) {
+          throw new ParserException("ContentEncodingScope " + value + " not supported");
+        }
+        return;
+      case ID_CONTENT_ENCODING_TYPE:
+        // This extractor only supports Encrypted ContentEncodingType.
+        if (value != 1) {
+          throw new ParserException("ContentEncodingType " + value + " not supported");
+        }
+        return;
+      case ID_CONTENT_ENCRYPTION_ALGORITHM:
+        // Only the value 5 (AES) is allowed according to the WebM specification.
+        if (value != 5) {
+          throw new ParserException("ContentEncAlgo " + value + " not supported");
+        }
+        return;
+      case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
+        // Only the value 1 is allowed according to the WebM specification.
+        if (value != 1) {
+          throw new ParserException("AESSettingsCipherMode " + value + " not supported");
+        }
+        return;
+      case ID_CUE_TIME:
+        cueTimesUs.add(scaleTimecodeToUs(value));
+        return;
+      case ID_CUE_CLUSTER_POSITION:
+        if (!seenClusterPositionForCurrentCuePoint) {
+          // If there's more than one video/audio track, then there could be more than one
+          // CueTrackPositions within a single CuePoint. In such a case, ignore all but the first
+          // one (since the cluster position will be quite close for all the tracks).
+          cueClusterPositions.add(value);
+          seenClusterPositionForCurrentCuePoint = true;
+        }
+        return;
+      case ID_TIME_CODE:
+        clusterTimecodeUs = scaleTimecodeToUs(value);
+        return;
+      default:
+        return;
+    }
+  }
+
+  /* package */ void floatElement(int id, double value) {
+    switch (id) {
+      case ID_DURATION:
+        durationUs = scaleTimecodeToUs((long) value);
+        return;
+      case ID_SAMPLING_FREQUENCY:
+        trackFormat.sampleRate = (int) value;
+        return;
+      default:
+        return;
+    }
+  }
+
+  /* package */ void stringElement(int id, String value) throws ParserException {
+    switch (id) {
+      case ID_DOC_TYPE:
+        // Validate that DocType is supported. This extractor only supports "webm".
+        if (!DOC_TYPE_WEBM.equals(value)) {
+          throw new ParserException("DocType " + value + " not supported");
+        }
+        return;
+      case ID_CODEC_ID:
+        trackFormat.codecId = value;
+        return;
+      default:
+        return;
+    }
+  }
+
+  /* package */ void binaryElement(int id, int contentSize, ExtractorInput input)
+      throws IOException, InterruptedException {
+    switch (id) {
+      case ID_SEEK_ID:
+        Arrays.fill(seekEntryIdBytes.data, (byte) 0);
+        input.readFully(seekEntryIdBytes.data, 4 - contentSize, contentSize);
+        seekEntryIdBytes.setPosition(0);
+        seekEntryId = (int) seekEntryIdBytes.readUnsignedInt();
+        return;
+      case ID_CODEC_PRIVATE:
+        trackFormat.codecPrivate = new byte[contentSize];
+        input.readFully(trackFormat.codecPrivate, 0, contentSize);
+        return;
+      case ID_CONTENT_ENCRYPTION_KEY_ID:
+        trackFormat.encryptionKeyId = new byte[contentSize];
+        input.readFully(trackFormat.encryptionKeyId, 0, contentSize);
+        return;
+      case ID_SIMPLE_BLOCK:
+      case ID_BLOCK:
+        // Please refer to http://www.matroska.org/technical/specs/index.html#simpleblock_structure
+        // and http://matroska.org/technical/specs/index.html#block_structure
+        // for info about how data is organized in SimpleBlock and Block elements respectively. They
+        // differ only in the way flags are specified.
+
+        if (sampleState == SAMPLE_STATE_START) {
+          sampleTrackNumber = (int) varintReader.readUnsignedVarint(input, false, true);
+          blockBytesRead = varintReader.getLastLength();
+          sampleState = SAMPLE_STATE_HEADER;
+        }
+
+        // Ignore the frame if the track number equals neither the audio track nor the video track.
+        if ((audioTrackFormat != null && videoTrackFormat != null
+                && audioTrackFormat.number != sampleTrackNumber
+                && videoTrackFormat.number != sampleTrackNumber)
+            || (audioTrackFormat != null && videoTrackFormat == null
+                && audioTrackFormat.number != sampleTrackNumber)
+            || (audioTrackFormat == null && videoTrackFormat != null
+                && videoTrackFormat.number != sampleTrackNumber)) {
+          input.skipFully(contentSize - blockBytesRead);
+          sampleState = SAMPLE_STATE_START;
+          return;
+        }
+
+        TrackFormat sampleTrackFormat =
+            (audioTrackFormat != null && sampleTrackNumber == audioTrackFormat.number)
+                ? audioTrackFormat : videoTrackFormat;
+        TrackOutput trackOutput = sampleTrackFormat.trackOutput;
+
+        if (sampleState == SAMPLE_STATE_HEADER) {
+          byte[] sampleHeaderScratchData = sampleHeaderScratch.data;
+          // Next 3 bytes have timecode and flags. If encrypted, the 4th byte is a signal byte.
+          int remainingHeaderLength = sampleTrackFormat.hasContentEncryption ? 4 : 3;
+          input.readFully(sampleHeaderScratchData, 0, remainingHeaderLength);
+          blockBytesRead += remainingHeaderLength;
+
+          // First two bytes are the relative timecode.
+          int timecode = (sampleHeaderScratchData[0] << 8)
+              | (sampleHeaderScratchData[1] & 0xFF);
+          sampleTimeUs = clusterTimecodeUs + scaleTimecodeToUs(timecode);
+
+          // Third byte contains the lacing value and some flags.
+          int lacing = (sampleHeaderScratchData[2] & 0x06) >> 1;
+          if (lacing != LACING_NONE) {
+            throw new ParserException("Lacing mode not supported: " + lacing);
+          }
+          boolean isInvisible = (sampleHeaderScratchData[2] & 0x08) == 0x08;
+          boolean isKeyframe =
+              (id == ID_SIMPLE_BLOCK && (sampleHeaderScratchData[2] & 0x80) == 0x80);
+          boolean isEncrypted = false;
+
+          // If encrypted, the fourth byte is an encryption signal byte.
+          if (sampleTrackFormat.hasContentEncryption) {
+            if ((sampleHeaderScratchData[3] & 0x80) == 0x80) {
+              throw new ParserException("Extension bit is set in signal byte");
+            }
+            isEncrypted = (sampleHeaderScratchData[3] & 0x01) == 0x01;
+          }
+
+          sampleFlags = (isKeyframe ? C.SAMPLE_FLAG_SYNC : 0)
+              | (isInvisible ? C.SAMPLE_FLAG_DECODE_ONLY : 0)
+              | (isEncrypted ? C.SAMPLE_FLAG_ENCRYPTED : 0);
+          sampleSize = contentSize - blockBytesRead;
+          if (isEncrypted) {
+            // Write the vector size.
+            sampleHeaderScratch.data[0] = (byte) ENCRYPTION_IV_SIZE;
+            sampleHeaderScratch.setPosition(0);
+            trackOutput.sampleData(sampleHeaderScratch, 1);
+            sampleSize++;
+          }
+          sampleState = SAMPLE_STATE_DATA;
+        }
+
+        while (blockBytesRead < contentSize) {
+          blockBytesRead += trackOutput.sampleData(input, contentSize - blockBytesRead);
+        }
+
+        if (CODEC_ID_VORBIS.equals(sampleTrackFormat.codecId)) {
+          // Vorbis decoder in android MediaCodec [1] expects the last 4 bytes of the sample to be
+          // the number of samples in the current page. This definition holds good only for Ogg and
+          // irrelevant for WebM. So we always set this to -1 (the decoder will ignore this value if
+          // we set it to -1). The android platform media extractor [2] does the same.
+          // [1] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp#314
+          // [2] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/NuMediaExtractor.cpp#474
+          vorbisNumPageSamples.setPosition(0);
+          trackOutput.sampleData(vorbisNumPageSamples, 4);
+          sampleSize += 4;
+        }
+
+        // For SimpleBlock, we send the metadata here as we have all the information. For Block, we
+        // send the metadata at the end of the BlockGroup element since we'll know if the frame is a
+        // keyframe or not only at that point.
+        if (id == ID_SIMPLE_BLOCK) {
+          outputSampleMetadata(trackOutput);
+        }
+        return;
+      default:
+        throw new IllegalStateException("Unexpected id: " + id);
+    }
+  }
+
+  private void outputSampleMetadata(TrackOutput trackOutput) {
+    trackOutput.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, null);
+    sampleState = SAMPLE_STATE_START;
+    sampleRead = true;
+  }
+
+  /**
+   * Builds an video {@link MediaFormat} containing recently gathered Video information.
+   *
+   * @return The built {@link MediaFormat}.
+   * @throws ParserException If the codec is unsupported.
+   */
+  private MediaFormat buildVideoFormat() throws ParserException {
+    if (videoTrackFormat != null && CODEC_ID_VP8.equals(videoTrackFormat.codecId)) {
+      return MediaFormat.createVideoFormat(MimeTypes.VIDEO_VP8, MediaFormat.NO_VALUE, durationUs,
+          videoTrackFormat.pixelWidth, videoTrackFormat.pixelHeight, null);
+    } else if (videoTrackFormat != null && CODEC_ID_VP9.equals(videoTrackFormat.codecId)) {
+      return MediaFormat.createVideoFormat(MimeTypes.VIDEO_VP9, MediaFormat.NO_VALUE, durationUs,
+          videoTrackFormat.pixelWidth, videoTrackFormat.pixelHeight, null);
+    } else {
+      throw new ParserException("Unable to build format");
+    }
+  }
+
+  /**
+   * Builds an audio {@link MediaFormat} containing recently gathered Audio information.
+   *
+   * @return The built {@link MediaFormat}.
+   * @throws ParserException If the codec is unsupported.
+   */
+  private MediaFormat buildAudioFormat() throws ParserException {
+    if (audioTrackFormat != null && CODEC_ID_VORBIS.equals(audioTrackFormat.codecId)) {
+      return MediaFormat.createAudioFormat(MimeTypes.AUDIO_VORBIS, VORBIS_MAX_INPUT_SIZE,
+          durationUs, audioTrackFormat.channelCount, audioTrackFormat.sampleRate,
+          parseVorbisCodecPrivate());
+    } else if (audioTrackFormat != null && CODEC_ID_OPUS.equals(audioTrackFormat.codecId)) {
+      ArrayList<byte[]> opusInitializationData = new ArrayList<byte[]>(3);
+      opusInitializationData.add(audioTrackFormat.codecPrivate);
+      opusInitializationData.add(
+          ByteBuffer.allocate(Long.SIZE).putLong(audioTrackFormat.codecDelayNs).array());
+      opusInitializationData.add(
+          ByteBuffer.allocate(Long.SIZE).putLong(audioTrackFormat.seekPreRollNs).array());
+      return MediaFormat.createAudioFormat(MimeTypes.AUDIO_OPUS, OPUS_MAX_INPUT_SIZE,
+          durationUs, audioTrackFormat.channelCount, audioTrackFormat.sampleRate,
+          opusInitializationData);
+    } else {
+      throw new ParserException("Unable to build format");
+    }
+  }
+
+  /**
+   * Builds a {@link ChunkIndex} containing recently gathered Cues information.
+   *
+   * @return The built {@link ChunkIndex}.
+   * @throws ParserException If the index could not be built.
+   */
+  private ChunkIndex buildCues() throws ParserException {
+    if (segmentContentPosition == UNKNOWN) {
+      throw new ParserException("Segment start/end offsets unknown");
+    } else if (durationUs == C.UNKNOWN_TIME_US) {
+      throw new ParserException("Duration unknown");
+    } else if (cueTimesUs == null || cueClusterPositions == null
+        || cueTimesUs.size() == 0 || cueTimesUs.size() != cueClusterPositions.size()) {
+      throw new ParserException("Invalid/missing cue points");
+    }
+    int cuePointsSize = cueTimesUs.size();
+    int[] sizes = new int[cuePointsSize];
+    long[] offsets = new long[cuePointsSize];
+    long[] durationsUs = new long[cuePointsSize];
+    long[] timesUs = new long[cuePointsSize];
+    for (int i = 0; i < cuePointsSize; i++) {
+      timesUs[i] = cueTimesUs.get(i);
+      offsets[i] = segmentContentPosition + cueClusterPositions.get(i);
+    }
+    for (int i = 0; i < cuePointsSize - 1; i++) {
+      sizes[i] = (int) (offsets[i + 1] - offsets[i]);
+      durationsUs[i] = timesUs[i + 1] - timesUs[i];
+    }
+    sizes[cuePointsSize - 1] =
+        (int) (segmentContentPosition + segmentContentSize - offsets[cuePointsSize - 1]);
+    durationsUs[cuePointsSize - 1] = durationUs - timesUs[cuePointsSize - 1];
+    cueTimesUs = null;
+    cueClusterPositions = null;
+    return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
+  }
+
+  /**
+   * Builds initialization data for a {@link MediaFormat} from Vorbis codec private data.
+   *
+   * @return The initialization data for the {@link MediaFormat}.
+   * @throws ParserException If the initialization data could not be built.
+   */
+  private ArrayList<byte[]> parseVorbisCodecPrivate() throws ParserException {
+    try {
+      byte[] codecPrivate = audioTrackFormat.codecPrivate;
+      if (codecPrivate[0] != 0x02) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+      int offset = 1;
+      int vorbisInfoLength = 0;
+      while (codecPrivate[offset] == (byte) 0xFF) {
+        vorbisInfoLength += 0xFF;
+        offset++;
+      }
+      vorbisInfoLength += codecPrivate[offset++];
+
+      int vorbisSkipLength = 0;
+      while (codecPrivate[offset] == (byte) 0xFF) {
+        vorbisSkipLength += 0xFF;
+        offset++;
+      }
+      vorbisSkipLength += codecPrivate[offset++];
+
+      if (codecPrivate[offset] != 0x01) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+      byte[] vorbisInfo = new byte[vorbisInfoLength];
+      System.arraycopy(codecPrivate, offset, vorbisInfo, 0, vorbisInfoLength);
+      offset += vorbisInfoLength;
+      if (codecPrivate[offset] != 0x03) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+      offset += vorbisSkipLength;
+      if (codecPrivate[offset] != 0x05) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+      byte[] vorbisBooks = new byte[codecPrivate.length - offset];
+      System.arraycopy(codecPrivate, offset, vorbisBooks, 0, codecPrivate.length - offset);
+      ArrayList<byte[]> initializationData = new ArrayList<byte[]>(2);
+      initializationData.add(vorbisInfo);
+      initializationData.add(vorbisBooks);
+      return initializationData;
+    } catch (ArrayIndexOutOfBoundsException e) {
+      throw new ParserException("Error parsing vorbis codec private");
+    }
+  }
+
+  /**
+   * Updates the position of the holder to Cues element's position if the extractor configuration
+   * permits use of master seek entry. After building Cues sets the holder's position back to where
+   * it was before.
+   *
+   * @param seekPosition The holder whose position will be updated.
+   * @param currentPosition Current position of the input.
+   * @return true if the seek position was updated, false otherwise.
+   */
+  private boolean maybeSeekForCues(PositionHolder seekPosition, long currentPosition) {
+    if (seekForCues) {
+      seekPositionAfterBuildingCues = currentPosition;
+      seekPosition.position = cuesContentPosition;
+      cuesState = CUES_STATE_BUILDING;
+      seekForCues = false;
+      return true;
+    }
+    // After parsing Cues, Seek back to original position if available. We will not do this unless
+    // we seeked to get to the Cues in the first place.
+    if (cuesState == CUES_STATE_BUILT && seekPositionAfterBuildingCues != UNKNOWN) {
+      seekPosition.position = seekPositionAfterBuildingCues;
+      seekPositionAfterBuildingCues = UNKNOWN;
+      return true;
+    }
+    return false;
+  }
+
+  private long scaleTimecodeToUs(long unscaledTimecode) {
+    return TimeUnit.NANOSECONDS.toMicros(unscaledTimecode * timecodeScale);
+  }
+
+  private boolean isCodecSupported(String codecId) {
+    return CODEC_ID_VP8.equals(codecId)
+        || CODEC_ID_VP9.equals(codecId)
+        || CODEC_ID_OPUS.equals(codecId)
+        || CODEC_ID_VORBIS.equals(codecId);
+  }
+
+  /**
+   * Passes events through to the outer {@link WebmExtractor}.
+   */
+  private final class InnerEbmlReaderOutput implements EbmlReaderOutput {
+
+    @Override
+    public int getElementType(int id) {
+      return WebmExtractor.this.getElementType(id);
+    }
+
+    @Override
+    public void startMasterElement(int id, long contentPosition, long contentSize)
+        throws ParserException {
+      WebmExtractor.this.startMasterElement(id, contentPosition, contentSize);
+    }
+
+    @Override
+    public void endMasterElement(int id) throws ParserException {
+      WebmExtractor.this.endMasterElement(id);
+    }
+
+    @Override
+    public void integerElement(int id, long value) throws ParserException {
+      WebmExtractor.this.integerElement(id, value);
+    }
+
+    @Override
+    public void floatElement(int id, double value) {
+      WebmExtractor.this.floatElement(id, value);
+    }
+
+    @Override
+    public void stringElement(int id, String value) throws ParserException {
+      WebmExtractor.this.stringElement(id, value);
+    }
+
+    @Override
+    public void binaryElement(int id, int contentsSize, ExtractorInput input)
+        throws IOException, InterruptedException {
+      WebmExtractor.this.binaryElement(id, contentsSize, input);
+    }
+
+  }
+
+  private static final class TrackFormat {
+
+    // Common track elements.
+    public String codecId;
+    public int number = UNKNOWN;
+    public int type = UNKNOWN;
+    public boolean hasContentEncryption;
+    public byte[] encryptionKeyId;
+
+    // Video track related elements.
+    public int pixelWidth = UNKNOWN;
+    public int pixelHeight = UNKNOWN;
+
+    // Audio track related elements.
+    public int channelCount = UNKNOWN;
+    public int sampleRate = UNKNOWN;
+    public byte[] codecPrivate;
+    public long codecDelayNs = UNKNOWN;
+    public long seekPreRollNs = UNKNOWN;
+
+    public TrackOutput trackOutput;
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java
deleted file mode 100644
index 4fe1a18646..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunk.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.hls;
-
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSpec;
-import com.google.android.exoplayer.upstream.Loader.Loadable;
-import com.google.android.exoplayer.util.Assertions;
-
-import java.io.IOException;
-
-/**
- * An abstract base class for {@link Loadable} implementations that load chunks of data required
- * for the playback of HLS streams.
- */
-public abstract class HlsChunk implements Loadable {
-
-  protected final DataSource dataSource;
-  protected final DataSpec dataSpec;
-
-  /**
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
-   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
-   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
-   *     {@link Integer#MAX_VALUE}.
-   */
-  public HlsChunk(DataSource dataSource, DataSpec dataSpec) {
-    Assertions.checkState(dataSpec.length <= Integer.MAX_VALUE);
-    this.dataSource = Assertions.checkNotNull(dataSource);
-    this.dataSpec = Assertions.checkNotNull(dataSpec);
-  }
-
-  public abstract void consume() throws IOException;
-
-  public abstract boolean isLoadFinished();
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index dc70320f0d..2873dfcad0 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -17,20 +17,25 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.hls.parser.AdtsExtractor;
-import com.google.android.exoplayer.hls.parser.HlsExtractor;
-import com.google.android.exoplayer.hls.parser.TsExtractor;
-import com.google.android.exoplayer.upstream.Aes128DataSource;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+import com.google.android.exoplayer.chunk.BaseChunkSampleSourceEventListener;
+import com.google.android.exoplayer.chunk.Chunk;
+import com.google.android.exoplayer.chunk.DataChunk;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ts.AdtsExtractor;
+import com.google.android.exoplayer.extractor.ts.TsExtractor;
 import com.google.android.exoplayer.upstream.BandwidthMeter;
-import com.google.android.exoplayer.upstream.BufferPool;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.upstream.HttpDataSource.InvalidResponseCodeException;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.UriUtil;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
 import android.os.SystemClock;
+import android.text.TextUtils;
 import android.util.Log;
 
 import java.io.ByteArrayInputStream;
@@ -50,6 +55,11 @@
  */
 public class HlsChunkSource {
 
+  /**
+   * Interface definition for a callback to be notified of {@link HlsChunkSource} events.
+   */
+  public interface EventListener extends BaseChunkSampleSourceEventListener {}
+
   /**
    * Adaptive switching is disabled.
    * <p>
@@ -84,16 +94,6 @@
    */
   public static final int ADAPTIVE_MODE_ABRUPT = 3;
 
-  /**
-   * The default target buffer size in bytes.
-   */
-  public static final int DEFAULT_TARGET_BUFFER_SIZE = 18 * 1024 * 1024;
-
-  /**
-   * The default target buffer duration in milliseconds.
-   */
-  public static final long DEFAULT_TARGET_BUFFER_DURATION_MS = 40000;
-
   /**
    * The default minimum duration of media that needs to be buffered for a switch to a higher
    * quality variant to be considered.
@@ -106,42 +106,47 @@
    */
   public static final long DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS = 20000;
 
+  /**
+   * The default time for which a media playlist should be blacklisted.
+   */
+  public static final long DEFAULT_PLAYLIST_BLACKLIST_MS = 60000;
+
   private static final String TAG = "HlsChunkSource";
   private static final String AAC_FILE_EXTENSION = ".aac";
   private static final float BANDWIDTH_FRACTION = 0.8f;
 
-  private final BufferPool bufferPool;
-  private final DataSource upstreamDataSource;
+  private final DataSource dataSource;
   private final HlsPlaylistParser playlistParser;
-  private final Variant[] enabledVariants;
+  private final List<Variant> variants;
+  private final Format[] enabledFormats;
   private final BandwidthMeter bandwidthMeter;
   private final int adaptiveMode;
-  private final Uri baseUri;
+  private final String baseUri;
   private final int maxWidth;
   private final int maxHeight;
-  private final int targetBufferSize;
-  private final long targetBufferDurationUs;
   private final long minBufferDurationToSwitchUpUs;
   private final long maxBufferDurationToSwitchDownUs;
+  private final AudioCapabilities audioCapabilities;
 
   /* package */ byte[] scratchSpace;
   /* package */ final HlsMediaPlaylist[] mediaPlaylists;
-  /* package */ final boolean[] mediaPlaylistBlacklistFlags;
+  /* package */ final long[] mediaPlaylistBlacklistTimesMs;
   /* package */ final long[] lastMediaPlaylistLoadTimesMs;
   /* package */ boolean live;
   /* package */ long durationUs;
 
-  private int variantIndex;
-  private DataSource encryptedDataSource;
+  private int formatIndex;
   private Uri encryptionKeyUri;
-  private String encryptedDataSourceIv;
-  private byte[] encryptedDataSourceSecretKey;
+  private byte[] encryptionKey;
+  private String encryptionIvString;
+  private byte[] encryptionIv;
 
   public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
-      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode) {
+      BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode,
+      AudioCapabilities audioCapabilities) {
     this(dataSource, playlistUrl, playlist, bandwidthMeter, variantIndices, adaptiveMode,
-        DEFAULT_TARGET_BUFFER_SIZE, DEFAULT_TARGET_BUFFER_DURATION_MS,
-        DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS, DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
+        DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS, DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS,
+        audioCapabilities);
   }
 
   /**
@@ -149,60 +154,61 @@ public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist pla
    * @param playlistUrl The playlist URL.
    * @param playlist The hls playlist.
    * @param bandwidthMeter provides an estimate of the currently available bandwidth.
-   * @param variantIndices A subset of variant indices to consider, or null to consider all of the
-   *     variants in the master playlist.
+   * @param variantIndices If {@code playlist} is a {@link HlsMasterPlaylist}, the subset of variant
+   *     indices to consider, or null to consider all of the variants. For other playlist types
+   *     this parameter is ignored.
    * @param adaptiveMode The mode for switching from one variant to another. One of
    *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
    *     {@link #ADAPTIVE_MODE_SPLICE}.
-   * @param targetBufferSize The targeted buffer size in bytes. The buffer will not be filled more
-   *     than one chunk beyond this amount of data.
-   * @param targetBufferDurationMs The targeted duration of media to buffer ahead of the current
-   *     playback position. The buffer will not be filled more than one chunk beyond this position.
    * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be buffered
    *     for a switch to a higher quality variant to be considered.
    * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
    *     for a switch to a lower quality variant to be considered.
+   * @param audioCapabilities The audio capabilities for playback on this device, or {@code null} if
+   *     the default capabilities should be assumed.
    */
   public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist playlist,
       BandwidthMeter bandwidthMeter, int[] variantIndices, int adaptiveMode,
-      int targetBufferSize, long targetBufferDurationMs, long minBufferDurationToSwitchUpMs,
-      long maxBufferDurationToSwitchDownMs) {
-    this.upstreamDataSource = dataSource;
+      long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs,
+      AudioCapabilities audioCapabilities) {
+    this.dataSource = dataSource;
     this.bandwidthMeter = bandwidthMeter;
     this.adaptiveMode = adaptiveMode;
-    this.targetBufferSize = targetBufferSize;
-    targetBufferDurationUs = targetBufferDurationMs * 1000;
+    this.audioCapabilities = audioCapabilities;
     minBufferDurationToSwitchUpUs = minBufferDurationToSwitchUpMs * 1000;
     maxBufferDurationToSwitchDownUs = maxBufferDurationToSwitchDownMs * 1000;
     baseUri = playlist.baseUri;
     playlistParser = new HlsPlaylistParser();
-    bufferPool = new BufferPool(256 * 1024);
 
     if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
-      enabledVariants = new Variant[] {new Variant(0, playlistUrl, 0, null, -1, -1)};
+      variants = Collections.singletonList(new Variant(0, playlistUrl, 0, null, -1, -1));
+      variantIndices = null;
       mediaPlaylists = new HlsMediaPlaylist[1];
-      mediaPlaylistBlacklistFlags = new boolean[1];
+      mediaPlaylistBlacklistTimesMs = new long[1];
       lastMediaPlaylistLoadTimesMs = new long[1];
       setMediaPlaylist(0, (HlsMediaPlaylist) playlist);
     } else {
-      Assertions.checkState(playlist.type == HlsPlaylist.TYPE_MASTER);
-      enabledVariants = filterVariants((HlsMasterPlaylist) playlist, variantIndices);
-      mediaPlaylists = new HlsMediaPlaylist[enabledVariants.length];
-      mediaPlaylistBlacklistFlags = new boolean[enabledVariants.length];
-      lastMediaPlaylistLoadTimesMs = new long[enabledVariants.length];
+      variants = ((HlsMasterPlaylist) playlist).variants;
+      int variantCount = variants.size();
+      mediaPlaylists = new HlsMediaPlaylist[variantCount];
+      mediaPlaylistBlacklistTimesMs = new long[variantCount];
+      lastMediaPlaylistLoadTimesMs = new long[variantCount];
     }
 
+    enabledFormats = buildEnabledFormats(variants, variantIndices);
+
     int maxWidth = -1;
     int maxHeight = -1;
     // Select the first variant from the master playlist that's enabled.
-    long minOriginalVariantIndex = Integer.MAX_VALUE;
-    for (int i = 0; i < enabledVariants.length; i++) {
-      if (enabledVariants[i].index < minOriginalVariantIndex) {
-        minOriginalVariantIndex = enabledVariants[i].index;
-        variantIndex = i;
+    int minEnabledVariantIndex = Integer.MAX_VALUE;
+    for (int i = 0; i < enabledFormats.length; i++) {
+      int variantIndex = getVariantIndex(enabledFormats[i]);
+      if (variantIndex < minEnabledVariantIndex) {
+        minEnabledVariantIndex = variantIndex;
+        formatIndex = i;
       }
-      maxWidth = Math.max(enabledVariants[i].width, maxWidth);
-      maxHeight = Math.max(enabledVariants[i].height, maxHeight);
+      maxWidth = Math.max(enabledFormats[i].width, maxWidth);
+      maxHeight = Math.max(enabledFormats[i].height, maxHeight);
     }
     // TODO: We should allow the default values to be passed through the constructor.
     this.maxWidth = maxWidth > 0 ? maxWidth : 1920;
@@ -226,7 +232,7 @@ public void getMaxVideoDimensions(MediaFormat out) {
   }
 
   /**
-   * Returns the next {@link HlsChunk} that should be loaded.
+   * Returns the next {@link Chunk} that should be loaded.
    *
    * @param previousTsChunk The previously loaded chunk that the next chunk should follow.
    * @param seekPositionUs If there is no previous chunk, this parameter must specify the seek
@@ -234,33 +240,27 @@ public void getMaxVideoDimensions(MediaFormat out) {
    * @param playbackPositionUs The current playback position.
    * @return The next chunk to load.
    */
-  public HlsChunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
+  public Chunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
       long playbackPositionUs) {
-    if (previousTsChunk != null && (previousTsChunk.isLastChunk
-        || previousTsChunk.endTimeUs - playbackPositionUs >= targetBufferDurationUs)
-        || bufferPool.getAllocatedSize() >= targetBufferSize) {
-      // We're either finished, or we have the target amount of data or time buffered.
-      return null;
-    }
-
-    int nextVariantIndex = variantIndex;
-    boolean switchingVariant = false;
-    boolean switchingVariantSpliced = false;
+    int nextFormatIndex;
+    boolean switchingVariantSpliced;
     if (adaptiveMode == ADAPTIVE_MODE_NONE) {
-      // Do nothing.
+      nextFormatIndex = formatIndex;
+      switchingVariantSpliced = false;
     } else {
-      nextVariantIndex = getNextVariantIndex(previousTsChunk, playbackPositionUs);
-      switchingVariant = nextVariantIndex != variantIndex;
-      switchingVariantSpliced = switchingVariant && adaptiveMode == ADAPTIVE_MODE_SPLICE;
+      nextFormatIndex = getNextFormatIndex(previousTsChunk, playbackPositionUs);
+      switchingVariantSpliced = nextFormatIndex != formatIndex
+          && adaptiveMode == ADAPTIVE_MODE_SPLICE;
     }
 
-    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[nextVariantIndex];
+    int variantIndex = getVariantIndex(enabledFormats[nextFormatIndex]);
+    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
     if (mediaPlaylist == null) {
       // We don't have the media playlist for the next variant. Request it now.
-      return newMediaPlaylistChunk(nextVariantIndex);
+      return newMediaPlaylistChunk(variantIndex);
     }
 
-    variantIndex = nextVariantIndex;
+    formatIndex = nextFormatIndex;
     int chunkMediaSequence = 0;
     boolean liveDiscontinuity = false;
     if (live) {
@@ -296,25 +296,24 @@ public HlsChunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
     }
 
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
-    Uri chunkUri = Util.getMergedUri(mediaPlaylist.baseUri, segment.url);
+    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
 
     // Check if encryption is specified.
-    if (HlsMediaPlaylist.ENCRYPTION_METHOD_AES_128.equals(segment.encryptionMethod)) {
-      Uri keyUri = Util.getMergedUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
+    if (segment.isEncrypted) {
+      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
-        HlsChunk toReturn = newEncryptionKeyChunk(keyUri, segment.encryptionIV);
+        Chunk toReturn = newEncryptionKeyChunk(keyUri, segment.encryptionIV);
         return toReturn;
       }
-      if (!Util.areEqual(segment.encryptionIV, encryptedDataSourceIv)) {
-        initEncryptedDataSource(keyUri, segment.encryptionIV, encryptedDataSourceSecretKey);
+      if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
+        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
       }
     } else {
-      clearEncryptedDataSource();
+      clearEncryptionData();
     }
 
     // Configure the data source and spec for the chunk.
-    DataSource dataSource = encryptedDataSource != null ? encryptedDataSource : upstreamDataSource;
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
 
@@ -333,35 +332,62 @@ public HlsChunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
     }
     long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
     boolean isLastChunk = !mediaPlaylist.live && chunkIndex == mediaPlaylist.segments.size() - 1;
+    int trigger = Chunk.TRIGGER_UNSPECIFIED;
+    Format format = enabledFormats[formatIndex];
 
     // Configure the extractor that will read the chunk.
-    HlsExtractor extractor;
-    if (previousTsChunk == null || segment.discontinuity || switchingVariant || liveDiscontinuity) {
-      extractor = chunkUri.getLastPathSegment().endsWith(AAC_FILE_EXTENSION)
-          ? new AdtsExtractor(switchingVariantSpliced, startTimeUs, bufferPool)
-          : new TsExtractor(switchingVariantSpliced, startTimeUs, bufferPool);
+    HlsExtractorWrapper extractorWrapper;
+    if (previousTsChunk == null || segment.discontinuity || !format.equals(previousTsChunk.format)
+        || liveDiscontinuity) {
+      Extractor extractor = chunkUri.getLastPathSegment().endsWith(AAC_FILE_EXTENSION)
+          ? new AdtsExtractor(startTimeUs)
+          : new TsExtractor(startTimeUs, audioCapabilities);
+      extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
+          switchingVariantSpliced);
     } else {
-      extractor = previousTsChunk.extractor;
+      extractorWrapper = previousTsChunk.extractorWrapper;
     }
 
-    return new TsChunk(dataSource, dataSpec, extractor, enabledVariants[variantIndex].index,
-        startTimeUs, endTimeUs, chunkMediaSequence, isLastChunk);
+    return new TsChunk(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs,
+        chunkMediaSequence, isLastChunk, extractorWrapper, encryptionKey,
+        encryptionIv);
   }
 
   /**
-   * Invoked when an error occurs loading a chunk.
+   * Invoked when the {@link HlsSampleSource} has finished loading a chunk obtained from this
+   * source.
    *
-   * @param chunk The chunk whose load failed.
-   * @param e The failure.
+   * @param chunk The chunk whose load has been completed.
+   */
+  public void onChunkLoadCompleted(Chunk chunk) {
+    if (chunk instanceof MediaPlaylistChunk) {
+      MediaPlaylistChunk mediaPlaylistChunk = (MediaPlaylistChunk) chunk;
+      scratchSpace = mediaPlaylistChunk.getDataHolder();
+      setMediaPlaylist(mediaPlaylistChunk.variantIndex, mediaPlaylistChunk.getResult());
+    } else if (chunk instanceof EncryptionKeyChunk) {
+      EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
+      scratchSpace = encryptionKeyChunk.getDataHolder();
+      setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
+          encryptionKeyChunk.getResult());
+    }
+  }
+
+  /**
+   * Invoked when the {@link HlsSampleSource} encounters an error loading a chunk obtained from
+   * this source.
+   *
+   * @param chunk The chunk whose load encountered the error.
+   * @param e The error.
    * @return True if the error was handled by the source. False otherwise.
    */
-  public boolean onLoadError(HlsChunk chunk, IOException e) {
-    if ((chunk instanceof MediaPlaylistChunk) && (e instanceof InvalidResponseCodeException)) {
+  public boolean onChunkLoadError(Chunk chunk, IOException e) {
+    if (chunk.bytesLoaded() == 0 && (chunk instanceof MediaPlaylistChunk)
+        && (e instanceof InvalidResponseCodeException)) {
       InvalidResponseCodeException responseCodeException = (InvalidResponseCodeException) e;
       int responseCode = responseCodeException.responseCode;
       if (responseCode == 404 || responseCode == 410) {
         MediaPlaylistChunk playlistChunk = (MediaPlaylistChunk) chunk;
-        mediaPlaylistBlacklistFlags[playlistChunk.variantIndex] = true;
+        mediaPlaylistBlacklistTimesMs[playlistChunk.variantIndex] = SystemClock.elapsedRealtime();
         if (!allPlaylistsBlacklisted()) {
           // We've handled the 404/410 by blacklisting the playlist.
           Log.w(TAG, "Blacklisted playlist (" + responseCode + "): "
@@ -371,7 +397,7 @@ public boolean onLoadError(HlsChunk chunk, IOException e) {
           // This was the last non-blacklisted playlist. Don't blacklist it.
           Log.w(TAG, "Final playlist not blacklisted (" + responseCode + "): "
               + playlistChunk.dataSpec.uri);
-          mediaPlaylistBlacklistFlags[playlistChunk.variantIndex] = false;
+          mediaPlaylistBlacklistTimesMs[playlistChunk.variantIndex] = 0;
           return false;
         }
       }
@@ -379,40 +405,52 @@ public boolean onLoadError(HlsChunk chunk, IOException e) {
     return false;
   }
 
-  private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs) {
-    int idealVariantIndex = getVariantIndexForBandwdith(
-        (int) (bandwidthMeter.getBitrateEstimate() * BANDWIDTH_FRACTION));
-    if (idealVariantIndex == variantIndex) {
-      // We're already using the ideal variant.
-      return variantIndex;
+  private int getNextFormatIndex(TsChunk previousTsChunk, long playbackPositionUs) {
+    clearStaleBlacklistedPlaylists();
+    if (previousTsChunk == null) {
+      // Don't consider switching if we don't have a previous chunk.
+      return formatIndex;
+    }
+    long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
+    if (bitrateEstimate == BandwidthMeter.NO_ESTIMATE) {
+      // Don't consider switching if we don't have a bandwidth estimate.
+      return formatIndex;
     }
-    // We're not using the ideal variant for the available bandwidth, but only switch if the
+    int idealFormatIndex = getFormatIndexForBandwidth(
+        (int) (bitrateEstimate * BANDWIDTH_FRACTION));
+    if (idealFormatIndex == formatIndex) {
+      // We're already using the ideal format.
+      return formatIndex;
+    }
+    // We're not using the ideal format for the available bandwidth, but only switch if the
     // conditions are appropriate.
-    long bufferedPositionUs = previousTsChunk == null ? playbackPositionUs
-        : adaptiveMode == ADAPTIVE_MODE_SPLICE ? previousTsChunk.startTimeUs
+    long bufferedPositionUs = adaptiveMode == ADAPTIVE_MODE_SPLICE ? previousTsChunk.startTimeUs
         : previousTsChunk.endTimeUs;
     long bufferedUs = bufferedPositionUs - playbackPositionUs;
-    if (mediaPlaylistBlacklistFlags[variantIndex]
-        || (idealVariantIndex > variantIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
-        || (idealVariantIndex < variantIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
-      // Switch variant.
-      return idealVariantIndex;
-    }
-    // Stick with the current variant for now.
-    return variantIndex;
+    if (mediaPlaylistBlacklistTimesMs[formatIndex] != 0
+        || (idealFormatIndex > formatIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
+        || (idealFormatIndex < formatIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
+      // Switch format.
+      return idealFormatIndex;
+    }
+    // Stick with the current format for now.
+    return formatIndex;
   }
 
-  private int getVariantIndexForBandwdith(int bandwidth) {
-    int lowestQualityEnabledVariant = 0;
-    for (int i = 0; i < enabledVariants.length; i++) {
-      if (!mediaPlaylistBlacklistFlags[i]) {
-        if (enabledVariants[i].bandwidth <= bandwidth) {
+  private int getFormatIndexForBandwidth(int bitrate) {
+    int lowestQualityEnabledFormatIndex = -1;
+    for (int i = 0; i < enabledFormats.length; i++) {
+      int variantIndex = getVariantIndex(enabledFormats[i]);
+      if (mediaPlaylistBlacklistTimesMs[variantIndex] == 0) {
+        if (enabledFormats[i].bitrate <= bitrate) {
           return i;
         }
-        lowestQualityEnabledVariant = i;
+        lowestQualityEnabledFormatIndex = i;
       }
     }
-    return lowestQualityEnabledVariant;
+    // At least one format should always be enabled.
+    Assertions.checkState(lowestQualityEnabledFormatIndex != -1);
+    return lowestQualityEnabledFormatIndex;
   }
 
   private boolean shouldRerequestMediaPlaylist(int variantIndex) {
@@ -431,18 +469,19 @@ private int getLiveStartChunkMediaSequence(int variantIndex) {
   }
 
   private MediaPlaylistChunk newMediaPlaylistChunk(int variantIndex) {
-    Uri mediaPlaylistUri = Util.getMergedUri(baseUri, enabledVariants[variantIndex].url);
-    DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNBOUNDED, null);
-    Uri baseUri = Util.parseBaseUri(mediaPlaylistUri.toString());
-    return new MediaPlaylistChunk(variantIndex, upstreamDataSource, dataSpec, baseUri);
+    Uri mediaPlaylistUri = UriUtil.resolveToUri(baseUri, variants.get(variantIndex).url);
+    DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNBOUNDED, null,
+        DataSpec.FLAG_ALLOW_GZIP);
+    return new MediaPlaylistChunk(dataSource, dataSpec, scratchSpace, playlistParser, variantIndex,
+        mediaPlaylistUri.toString());
   }
 
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv) {
-    DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNBOUNDED, null);
-    return new EncryptionKeyChunk(upstreamDataSource, dataSpec, iv);
+    DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNBOUNDED, null, DataSpec.FLAG_ALLOW_GZIP);
+    return new EncryptionKeyChunk(dataSource, dataSpec, scratchSpace, iv);
   }
 
-  /* package */ void initEncryptedDataSource(Uri keyUri, String iv, byte[] secretKey) {
+  /* package */ void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     String trimmedIv;
     if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
       trimmedIv = iv.substring(2);
@@ -456,17 +495,17 @@ private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv) {
     System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
         + offset, ivData.length - offset);
 
-    encryptedDataSource = new Aes128DataSource(secretKey, ivDataWithPadding, upstreamDataSource);
     encryptionKeyUri = keyUri;
-    encryptedDataSourceIv = iv;
-    encryptedDataSourceSecretKey = secretKey;
+    encryptionKey = secretKey;
+    encryptionIvString = iv;
+    encryptionIv = ivDataWithPadding;
   }
 
-  private void clearEncryptedDataSource() {
+  private void clearEncryptionData() {
     encryptionKeyUri = null;
-    encryptedDataSource = null;
-    encryptedDataSourceIv = null;
-    encryptedDataSourceSecretKey = null;
+    encryptionKey = null;
+    encryptionIvString = null;
+    encryptionIv = null;
   }
 
   /* package */ void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist) {
@@ -476,23 +515,22 @@ private void clearEncryptedDataSource() {
     durationUs = mediaPlaylist.durationUs;
   }
 
-  private static Variant[] filterVariants(HlsMasterPlaylist masterPlaylist, int[] variantIndices) {
-    List<Variant> masterVariants = masterPlaylist.variants;
+  private static Format[] buildEnabledFormats(List<Variant> variants, int[] variantIndices) {
     ArrayList<Variant> enabledVariants = new ArrayList<Variant>();
     if (variantIndices != null) {
       for (int i = 0; i < variantIndices.length; i++) {
-        enabledVariants.add(masterVariants.get(variantIndices[i]));
+        enabledVariants.add(variants.get(variantIndices[i]));
       }
     } else {
       // If variantIndices is null then all variants are initially considered.
-      enabledVariants.addAll(masterVariants);
+      enabledVariants.addAll(variants);
     }
 
     ArrayList<Variant> definiteVideoVariants = new ArrayList<Variant>();
     ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<Variant>();
     for (int i = 0; i < enabledVariants.size(); i++) {
       Variant variant = enabledVariants.get(i);
-      if (variant.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
+      if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
         definiteVideoVariants.add(variant);
       } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
         definiteAudioOnlyVariants.add(variant);
@@ -512,20 +550,23 @@ private void clearEncryptedDataSource() {
       // Leave the enabled variants unchanged. They're likely either all video or all audio.
     }
 
-    Collections.sort(enabledVariants, new Variant.DecreasingBandwidthComparator());
+    Format[] enabledFormats = new Format[enabledVariants.size()];
+    for (int i = 0; i < enabledFormats.length; i++) {
+      enabledFormats[i] = enabledVariants.get(i).format;
+    }
 
-    Variant[] enabledVariantsArray = new Variant[enabledVariants.size()];
-    enabledVariants.toArray(enabledVariantsArray);
-    return enabledVariantsArray;
+    Arrays.sort(enabledFormats, new Format.DecreasingBandwidthComparator());
+    return enabledFormats;
   }
 
   private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String prefix) {
-    String[] codecs = variant.codecs;
-    if (codecs == null) {
+    String codecs = variant.format.codecs;
+    if (TextUtils.isEmpty(codecs)) {
       return false;
     }
-    for (int i = 0; i < codecs.length; i++) {
-      if (codecs[i].startsWith(prefix)) {
+    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
+    for (int i = 0; i < codecArray.length; i++) {
+      if (codecArray[i].startsWith(prefix)) {
         return true;
       }
     }
@@ -533,55 +574,83 @@ private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String
   }
 
   private boolean allPlaylistsBlacklisted() {
-    for (int i = 0; i < mediaPlaylistBlacklistFlags.length; i++) {
-      if (!mediaPlaylistBlacklistFlags[i]) {
+    for (int i = 0; i < mediaPlaylistBlacklistTimesMs.length; i++) {
+      if (mediaPlaylistBlacklistTimesMs[i] == 0) {
         return false;
       }
     }
     return true;
   }
 
-  private class MediaPlaylistChunk extends DataChunk {
+  private void clearStaleBlacklistedPlaylists() {
+    long currentTime = SystemClock.elapsedRealtime();
+    for (int i = 0; i < mediaPlaylistBlacklistTimesMs.length; i++) {
+      if (mediaPlaylistBlacklistTimesMs[i] != 0
+          && currentTime - mediaPlaylistBlacklistTimesMs[i] > DEFAULT_PLAYLIST_BLACKLIST_MS) {
+        mediaPlaylistBlacklistTimesMs[i] = 0;
+      }
+    }
+  }
+
+  private int getVariantIndex(Format format) {
+    for (int i = 0; i < variants.size(); i++) {
+      if (variants.get(i).format.equals(format)) {
+        return i;
+      }
+    }
+    // Should never happen.
+    throw new IllegalStateException("Invalid format: " + format);
+  }
+
+  private static class MediaPlaylistChunk extends DataChunk {
+
+    public final int variantIndex;
 
-    @SuppressWarnings("hiding")
-    /* package */ final int variantIndex;
+    private final HlsPlaylistParser playlistParser;
+    private final String playlistUrl;
 
-    private final Uri playlistBaseUri;
+    private HlsMediaPlaylist result;
 
-    public MediaPlaylistChunk(int variantIndex, DataSource dataSource, DataSpec dataSpec,
-        Uri playlistBaseUri) {
-      super(dataSource, dataSpec, scratchSpace);
+    public MediaPlaylistChunk(DataSource dataSource, DataSpec dataSpec, byte[] scratchSpace,
+        HlsPlaylistParser playlistParser, int variantIndex, String playlistUrl) {
+      super(dataSource, dataSpec, Chunk.TYPE_MANIFEST, Chunk.TRIGGER_UNSPECIFIED, null,
+          scratchSpace);
       this.variantIndex = variantIndex;
-      this.playlistBaseUri = playlistBaseUri;
+      this.playlistParser = playlistParser;
+      this.playlistUrl = playlistUrl;
     }
 
     @Override
     protected void consume(byte[] data, int limit) throws IOException {
-      HlsPlaylist playlist = playlistParser.parse(new ByteArrayInputStream(data, 0, limit),
-          null, null, playlistBaseUri);
-      Assertions.checkState(playlist.type == HlsPlaylist.TYPE_MEDIA);
-      HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
-      setMediaPlaylist(variantIndex, mediaPlaylist);
-      // Recycle the allocation.
-      scratchSpace = data;
+      result = (HlsMediaPlaylist) playlistParser.parse(playlistUrl,
+          new ByteArrayInputStream(data, 0, limit));
+    }
+
+    public HlsMediaPlaylist getResult() {
+      return result;
     }
 
   }
 
-  private class EncryptionKeyChunk extends DataChunk {
+  private static class EncryptionKeyChunk extends DataChunk {
+
+    public final String iv;
 
-    private final String iv;
+    private byte[] result;
 
-    public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, String iv) {
-      super(dataSource, dataSpec, scratchSpace);
+    public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, byte[] scratchSpace,
+        String iv) {
+      super(dataSource, dataSpec, Chunk.TYPE_DRM, Chunk.TRIGGER_UNSPECIFIED, null, scratchSpace);
       this.iv = iv;
     }
 
     @Override
     protected void consume(byte[] data, int limit) throws IOException {
-      initEncryptedDataSource(dataSpec.uri, iv, Arrays.copyOf(data, limit));
-      // Recycle the allocation.
-      scratchSpace = data;
+      result = Arrays.copyOf(data, limit);
+    }
+
+    public byte[] getResult() {
+      return result;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
new file mode 100644
index 0000000000..b189a12bd2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.DefaultTrackOutput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.util.SparseArray;
+
+import java.io.IOException;
+
+/**
+ * Wraps a {@link Extractor}, adding functionality to enable reading of the extracted samples.
+ */
+public final class HlsExtractorWrapper implements ExtractorOutput {
+
+  public final int trigger;
+  public final Format format;
+  public final long startTimeUs;
+
+  private final Extractor extractor;
+  private final SparseArray<DefaultTrackOutput> sampleQueues;
+  private final boolean shouldSpliceIn;
+
+  private Allocator allocator;
+
+  private volatile boolean tracksBuilt;
+
+  // Accessed only by the consuming thread.
+  private boolean prepared;
+  private boolean spliceConfigured;
+
+  public HlsExtractorWrapper(int trigger, Format format, long startTimeUs, Extractor extractor,
+      boolean shouldSpliceIn) {
+    this.trigger = trigger;
+    this.format = format;
+    this.startTimeUs = startTimeUs;
+    this.extractor = extractor;
+    this.shouldSpliceIn = shouldSpliceIn;
+    sampleQueues = new SparseArray<DefaultTrackOutput>();
+    extractor.init(this);
+  }
+
+  /**
+   * Initializes the wrapper for use.
+   *
+   * @param allocator An allocator for obtaining allocations into which extracted data is written.
+   */
+  public void init(Allocator allocator) {
+    this.allocator = allocator;
+  }
+
+  /**
+   * Attempts to configure a splice from this extractor to the next.
+   * <p>
+   * The splice is performed such that for each track the samples read from the next extractor
+   * start with a keyframe, and continue from where the samples read from this extractor finish.
+   * A successful splice may discard samples from either or both extractors.
+   * <p>
+   * Splice configuration may fail if the next extractor is not yet in a state that allows the
+   * splice to be performed. Calling this method is a noop if the splice has already been
+   * configured. Hence this method should be called repeatedly during the window within which a
+   * splice can be performed.
+   *
+   * @param nextExtractor The extractor being spliced to.
+   */
+  public final void configureSpliceTo(HlsExtractorWrapper nextExtractor) {
+    if (spliceConfigured || !nextExtractor.shouldSpliceIn || !nextExtractor.isPrepared()) {
+      // The splice is already configured, or the next extractor doesn't want to be spliced in, or
+      // the next extractor isn't ready to be spliced in.
+      return;
+    }
+    boolean spliceConfigured = true;
+    int trackCount = getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
+      DefaultTrackOutput currentSampleQueue = sampleQueues.valueAt(i);
+      DefaultTrackOutput nextSampleQueue = nextExtractor.sampleQueues.valueAt(i);
+      spliceConfigured &= currentSampleQueue.configureSpliceTo(nextSampleQueue);
+    }
+    this.spliceConfigured = spliceConfigured;
+    return;
+  }
+
+  /**
+   * Gets the number of available tracks.
+   * <p>
+   * This method should only be called after the extractor has been prepared.
+   *
+   * @return The number of available tracks.
+   */
+  public int getTrackCount() {
+    return sampleQueues.size();
+  }
+
+  /**
+   * Gets the {@link MediaFormat} of the specified track.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
+   *
+   * @param track The track index.
+   * @return The corresponding format.
+   */
+  public MediaFormat getMediaFormat(int track) {
+    return sampleQueues.valueAt(track).getFormat();
+  }
+
+  /**
+   * Whether the extractor is prepared.
+   *
+   * @return True if the extractor is prepared. False otherwise.
+   */
+  public boolean isPrepared() {
+    if (!prepared && tracksBuilt) {
+      for (int i = 0; i < sampleQueues.size(); i++) {
+        if (!sampleQueues.valueAt(i).hasFormat()) {
+          return false;
+        }
+      }
+      prepared = true;
+    }
+    return prepared;
+  }
+
+  /**
+   * Clears queues for all tracks, returning all allocations to the allocator.
+   */
+  public void clear() {
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      sampleQueues.valueAt(i).clear();
+    }
+  }
+
+  /**
+   * Gets the largest timestamp of any sample parsed by the extractor.
+   *
+   * @return The largest timestamp, or {@link Long#MIN_VALUE} if no samples have been parsed.
+   */
+  public long getLargestParsedTimestampUs() {
+    long largestParsedTimestampUs = Long.MIN_VALUE;
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
+          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
+    }
+    return largestParsedTimestampUs;
+  }
+
+  /**
+   * Gets the next sample for the specified track.
+   *
+   * @param track The track from which to read.
+   * @param holder A {@link SampleHolder} into which the sample should be read.
+   * @return True if a sample was read. False otherwise.
+   */
+  public boolean getSample(int track, SampleHolder holder) {
+    Assertions.checkState(isPrepared());
+    return sampleQueues.valueAt(track).getSample(holder);
+  }
+
+  /**
+   * Discards samples for the specified track up to the specified time.
+   *
+   * @param track The track from which samples should be discarded.
+   * @param timeUs The time up to which samples should be discarded, in microseconds.
+   */
+  public void discardUntil(int track, long timeUs) {
+    Assertions.checkState(isPrepared());
+    sampleQueues.valueAt(track).discardUntil(timeUs);
+  }
+
+  /**
+   * Whether samples are available for reading from {@link #getSample(int, SampleHolder)} for the
+   * specified track.
+   *
+   * @return True if samples are available for reading from {@link #getSample(int, SampleHolder)}
+   *     for the specified track. False otherwise.
+   */
+  public boolean hasSamples(int track) {
+    Assertions.checkState(isPrepared());
+    return !sampleQueues.valueAt(track).isEmpty();
+  }
+
+  /**
+   * Reads from the provided {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @return One of {@link Extractor#RESULT_CONTINUE} and {@link Extractor#RESULT_END_OF_INPUT}.
+   * @throws IOException If an error occurred reading from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  public int read(ExtractorInput input) throws IOException, InterruptedException {
+    int result = extractor.read(input, null);
+    Assertions.checkState(result != Extractor.RESULT_SEEK);
+    return result;
+  }
+
+  // ExtractorOutput implementation.
+
+  @Override
+  public TrackOutput track(int id) {
+    DefaultTrackOutput sampleQueue = new DefaultTrackOutput(allocator);
+    sampleQueues.put(id, sampleQueue);
+    return sampleQueue;
+  }
+
+  @Override
+  public void endTracks() {
+    this.tracksBuilt = true;
+  }
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    // Do nothing.
+  }
+
+  @Override
+  public void drmInitData(DrmInitData drmInit) {
+    // Do nothing.
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
index 7ce299df0d..15c4784d10 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer.hls;
 
-import android.net.Uri;
-
 import java.util.List;
 
 /**
@@ -25,10 +23,12 @@
 public final class HlsMasterPlaylist extends HlsPlaylist {
 
   public final List<Variant> variants;
+  public final List<Subtitle> subtitles;
 
-  public HlsMasterPlaylist(Uri baseUri, List<Variant> variants) {
+  public HlsMasterPlaylist(String baseUri, List<Variant> variants, List<Subtitle> subtitles) {
     super(baseUri, HlsPlaylist.TYPE_MASTER);
     this.variants = variants;
+    this.subtitles = subtitles;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
index 3e9f151c08..ec4c538155 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
@@ -17,8 +17,6 @@
 
 import com.google.android.exoplayer.C;
 
-import android.net.Uri;
-
 import java.util.List;
 
 /**
@@ -30,24 +28,25 @@
    * Media segment reference.
    */
   public static final class Segment implements Comparable<Long> {
+
     public final boolean discontinuity;
     public final double durationSecs;
     public final String url;
     public final long startTimeUs;
-    public final String encryptionMethod;
+    public final boolean isEncrypted;
     public final String encryptionKeyUri;
     public final String encryptionIV;
     public final int byterangeOffset;
     public final int byterangeLength;
 
     public Segment(String uri, double durationSecs, boolean discontinuity, long startTimeUs,
-        String encryptionMethod, String encryptionKeyUri, String encryptionIV,
-        int byterangeOffset, int byterangeLength) {
+        boolean isEncrypted, String encryptionKeyUri, String encryptionIV, int byterangeOffset,
+        int byterangeLength) {
       this.url = uri;
       this.durationSecs = durationSecs;
       this.discontinuity = discontinuity;
       this.startTimeUs = startTimeUs;
-      this.encryptionMethod = encryptionMethod;
+      this.isEncrypted = isEncrypted;
       this.encryptionKeyUri = encryptionKeyUri;
       this.encryptionIV = encryptionIV;
       this.byterangeOffset = byterangeOffset;
@@ -70,7 +69,7 @@ public int compareTo(Long startTimeUs) {
   public final boolean live;
   public final long durationUs;
 
-  public HlsMediaPlaylist(Uri baseUri, int mediaSequence, int targetDurationSecs, int version,
+  public HlsMediaPlaylist(String baseUri, int mediaSequence, int targetDurationSecs, int version,
       boolean live, List<Segment> segments) {
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
     this.mediaSequence = mediaSequence;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
index 366bab1178..7e5dd64367 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
@@ -23,7 +23,10 @@
 /**
  * Utility methods for HLS manifest parsing.
  */
-/* package */ class HlsParserUtil {
+/* package */ final class HlsParserUtil {
+
+  private static final String BOOLEAN_YES = "YES";
+  private static final String BOOLEAN_NO = "NO";
 
   private HlsParserUtil() {}
 
@@ -36,6 +39,16 @@ public static String parseStringAttr(String line, Pattern pattern, String tag)
     throw new ParserException(String.format("Couldn't match %s tag in %s", tag, line));
   }
 
+  public static int parseIntAttr(String line, Pattern pattern, String tag)
+      throws ParserException {
+    return Integer.parseInt(parseStringAttr(line, pattern, tag));
+  }
+
+  public static double parseDoubleAttr(String line, Pattern pattern, String tag)
+      throws ParserException {
+    return Double.parseDouble(parseStringAttr(line, pattern, tag));
+  }
+
   public static String parseOptionalStringAttr(String line, Pattern pattern) {
     Matcher matcher = pattern.matcher(line);
     if (matcher.find() && matcher.groupCount() == 1) {
@@ -44,14 +57,16 @@ public static String parseOptionalStringAttr(String line, Pattern pattern) {
     return null;
   }
 
-  public static int parseIntAttr(String line, Pattern pattern, String tag)
-      throws ParserException {
-    return Integer.parseInt(parseStringAttr(line, pattern, tag));
+  public static boolean parseOptionalBooleanAttr(String line, Pattern pattern) {
+    Matcher matcher = pattern.matcher(line);
+    if (matcher.find() && matcher.groupCount() == 1) {
+      return BOOLEAN_YES.equals(matcher.group(1));
+    }
+    return false;
   }
 
-  public static double parseDoubleAttr(String line, Pattern pattern, String tag)
-      throws ParserException {
-    return Double.parseDouble(parseStringAttr(line, pattern, tag));
+  public static Pattern compileBooleanAttrPattern(String attrName) {
+    return Pattern.compile(attrName + "=(" + BOOLEAN_YES + "|" + BOOLEAN_NO + ")");
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
index 3c86328ba6..b6cd9dac9a 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.hls;
 
-import android.net.Uri;
 
 /**
  * Represents an HLS playlist.
@@ -25,10 +24,10 @@
   public final static int TYPE_MASTER = 0;
   public final static int TYPE_MEDIA = 1;
 
-  public final Uri baseUri;
+  public final String baseUri;
   public final int type;
 
-  protected HlsPlaylist(Uri baseUri, int type) {
+  protected HlsPlaylist(String baseUri, int type) {
     this.baseUri = baseUri;
     this.type = type;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 0205364718..316f41a44d 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -18,9 +18,7 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.hls.HlsMediaPlaylist.Segment;
-import com.google.android.exoplayer.util.ManifestParser;
-
-import android.net.Uri;
+import com.google.android.exoplayer.upstream.UriLoadable;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -36,15 +34,11 @@
 /**
  * HLS playlists parsing logic.
  */
-public final class HlsPlaylistParser implements ManifestParser<HlsPlaylist> {
+public final class HlsPlaylistParser implements UriLoadable.Parser<HlsPlaylist> {
 
   private static final String VERSION_TAG = "#EXT-X-VERSION";
-
   private static final String STREAM_INF_TAG = "#EXT-X-STREAM-INF";
-  private static final String BANDWIDTH_ATTR = "BANDWIDTH";
-  private static final String CODECS_ATTR = "CODECS";
-  private static final String RESOLUTION_ATTR = "RESOLUTION";
-
+  private static final String MEDIA_TAG = "#EXT-X-MEDIA";
   private static final String DISCONTINUITY_TAG = "#EXT-X-DISCONTINUITY";
   private static final String MEDIA_DURATION_TAG = "#EXTINF";
   private static final String MEDIA_SEQUENCE_TAG = "#EXT-X-MEDIA-SEQUENCE";
@@ -53,17 +47,32 @@
   private static final String KEY_TAG = "#EXT-X-KEY";
   private static final String BYTERANGE_TAG = "#EXT-X-BYTERANGE";
 
+  private static final String BANDWIDTH_ATTR = "BANDWIDTH";
+  private static final String CODECS_ATTR = "CODECS";
+  private static final String RESOLUTION_ATTR = "RESOLUTION";
+  private static final String LANGUAGE_ATTR = "LANGUAGE";
+  private static final String NAME_ATTR = "NAME";
+  private static final String AUTOSELECT_ATTR = "AUTOSELECT";
+  private static final String DEFAULT_ATTR = "DEFAULT";
+  private static final String TYPE_ATTR = "TYPE";
   private static final String METHOD_ATTR = "METHOD";
   private static final String URI_ATTR = "URI";
   private static final String IV_ATTR = "IV";
 
+  private static final String AUDIO_TYPE = "AUDIO";
+  private static final String VIDEO_TYPE = "VIDEO";
+  private static final String SUBTITLES_TYPE = "SUBTITLES";
+  private static final String CLOSED_CAPTIONS_TYPE = "CLOSED-CAPTIONS";
+
+  private static final String METHOD_NONE = "NONE";
+  private static final String METHOD_AES128 = "AES-128";
+
   private static final Pattern BANDWIDTH_ATTR_REGEX =
       Pattern.compile(BANDWIDTH_ATTR + "=(\\d+)\\b");
   private static final Pattern CODECS_ATTR_REGEX =
       Pattern.compile(CODECS_ATTR + "=\"(.+?)\"");
   private static final Pattern RESOLUTION_ATTR_REGEX =
       Pattern.compile(RESOLUTION_ATTR + "=(\\d+x\\d+)");
-
   private static final Pattern MEDIA_DURATION_REGEX =
       Pattern.compile(MEDIA_DURATION_TAG + ":([\\d.]+),");
   private static final Pattern MEDIA_SEQUENCE_REGEX =
@@ -76,17 +85,27 @@
       Pattern.compile(BYTERANGE_TAG + ":(\\d+(?:@\\d+)?)\\b");
 
   private static final Pattern METHOD_ATTR_REGEX =
-      Pattern.compile(METHOD_ATTR + "=([^,.*]+)");
+      Pattern.compile(METHOD_ATTR + "=(" + METHOD_NONE + "|" + METHOD_AES128 + ")");
   private static final Pattern URI_ATTR_REGEX =
       Pattern.compile(URI_ATTR + "=\"(.+)\"");
   private static final Pattern IV_ATTR_REGEX =
       Pattern.compile(IV_ATTR + "=([^,.*]+)");
+  private static final Pattern TYPE_ATTR_REGEX =
+      Pattern.compile(TYPE_ATTR + "=(" + AUDIO_TYPE + "|" + VIDEO_TYPE + "|" + SUBTITLES_TYPE + "|"
+          + CLOSED_CAPTIONS_TYPE + ")");
+  private static final Pattern LANGUAGE_ATTR_REGEX =
+      Pattern.compile(LANGUAGE_ATTR + "=\"(.+?)\"");
+  private static final Pattern NAME_ATTR_REGEX =
+      Pattern.compile(NAME_ATTR + "=\"(.+?)\"");
+  private static final Pattern AUTOSELECT_ATTR_REGEX =
+      HlsParserUtil.compileBooleanAttrPattern(AUTOSELECT_ATTR);
+  private static final Pattern DEFAULT_ATTR_REGEX =
+      HlsParserUtil.compileBooleanAttrPattern(DEFAULT_ATTR);
 
   @Override
-  public HlsPlaylist parse(InputStream inputStream, String inputEncoding,
-      String contentId, Uri baseUri) throws IOException {
-    BufferedReader reader = new BufferedReader((inputEncoding == null)
-        ? new InputStreamReader(inputStream) : new InputStreamReader(inputStream, inputEncoding));
+  public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
+      throws IOException, ParserException {
+    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
     Queue<String> extraLines = new LinkedList<String>();
     String line;
     try {
@@ -96,7 +115,7 @@ public HlsPlaylist parse(InputStream inputStream, String inputEncoding,
           // Do nothing.
         } else if (line.startsWith(STREAM_INF_TAG)) {
           extraLines.add(line);
-          return parseMasterPlaylist(new LineIterator(extraLines, reader), baseUri);
+          return parseMasterPlaylist(new LineIterator(extraLines, reader), connectionUrl);
         } else if (line.startsWith(TARGET_DURATION_TAG)
             || line.startsWith(MEDIA_SEQUENCE_TAG)
             || line.startsWith(MEDIA_DURATION_TAG)
@@ -105,11 +124,9 @@ public HlsPlaylist parse(InputStream inputStream, String inputEncoding,
             || line.equals(DISCONTINUITY_TAG)
             || line.equals(ENDLIST_TAG)) {
           extraLines.add(line);
-          return parseMediaPlaylist(new LineIterator(extraLines, reader), baseUri);
-        } else if (line.startsWith(VERSION_TAG)) {
+          return parseMediaPlaylist(new LineIterator(extraLines, reader), connectionUrl);
+        } else {
           extraLines.add(line);
-        } else if (!line.startsWith("#")) {
-          throw new ParserException("Missing a tag before URL.");
         }
       }
     } finally {
@@ -118,26 +135,35 @@ public HlsPlaylist parse(InputStream inputStream, String inputEncoding,
     throw new ParserException("Failed to parse the playlist, could not identify any tags.");
   }
 
-  private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Uri baseUri)
+  private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
-    List<Variant> variants = new ArrayList<Variant>();
-    int bandwidth = 0;
-    String[] codecs = null;
+    ArrayList<Variant> variants = new ArrayList<Variant>();
+    ArrayList<Subtitle> subtitles = new ArrayList<Subtitle>();
+    int bitrate = 0;
+    String codecs = null;
     int width = -1;
     int height = -1;
-    int variantIndex = 0;
 
+    boolean expectingStreamInfUrl = false;
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-      if (line.startsWith(STREAM_INF_TAG)) {
-        bandwidth = HlsParserUtil.parseIntAttr(line, BANDWIDTH_ATTR_REGEX, BANDWIDTH_ATTR);
-        String codecsString = HlsParserUtil.parseOptionalStringAttr(line, CODECS_ATTR_REGEX);
-        if (codecsString != null) {
-          codecs = codecsString.split("(\\s*,\\s*)|(\\s*$)");
+      if (line.startsWith(MEDIA_TAG)) {
+        String type = HlsParserUtil.parseStringAttr(line, TYPE_ATTR_REGEX, TYPE_ATTR);
+        if (SUBTITLES_TYPE.equals(type)) {
+          // We assume all subtitles belong to the same group.
+          String name = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
+          String uri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX, URI_ATTR);
+          String language = HlsParserUtil.parseOptionalStringAttr(line, LANGUAGE_ATTR_REGEX);
+          boolean isDefault = HlsParserUtil.parseOptionalBooleanAttr(line, DEFAULT_ATTR_REGEX);
+          boolean autoSelect = HlsParserUtil.parseOptionalBooleanAttr(line, AUTOSELECT_ATTR_REGEX);
+          subtitles.add(new Subtitle(name, uri, language, isDefault, autoSelect));
         } else {
-          codecs = null;
+          // TODO: Support other types of media tag.
         }
+      } else if (line.startsWith(STREAM_INF_TAG)) {
+        bitrate = HlsParserUtil.parseIntAttr(line, BANDWIDTH_ATTR_REGEX, BANDWIDTH_ATTR);
+        codecs = HlsParserUtil.parseOptionalStringAttr(line, CODECS_ATTR_REGEX);
         String resolutionString = HlsParserUtil.parseOptionalStringAttr(line,
             RESOLUTION_ATTR_REGEX);
         if (resolutionString != null) {
@@ -148,18 +174,21 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Uri
           width = -1;
           height = -1;
         }
-      } else if (!line.startsWith("#")) {
-        variants.add(new Variant(variantIndex++, line, bandwidth, codecs, width, height));
-        bandwidth = 0;
+        expectingStreamInfUrl = true;
+      } else if (!line.startsWith("#") && expectingStreamInfUrl) {
+        variants.add(new Variant(variants.size(), line, bitrate, codecs, width, height));
+        bitrate = 0;
         codecs = null;
         width = -1;
         height = -1;
+        expectingStreamInfUrl = false;
       }
     }
-    return new HlsMasterPlaylist(baseUri, Collections.unmodifiableList(variants));
+    return new HlsMasterPlaylist(baseUri, Collections.unmodifiableList(variants),
+        Collections.unmodifiableList(subtitles));
   }
 
-  private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, Uri baseUri)
+  private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     int mediaSequence = 0;
     int targetDurationSecs = 0;
@@ -170,14 +199,14 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, Uri ba
     double segmentDurationSecs = 0.0;
     boolean segmentDiscontinuity = false;
     long segmentStartTimeUs = 0;
-    String segmentEncryptionMethod = null;
-    String segmentEncryptionKeyUri = null;
-    String segmentEncryptionIV = null;
     int segmentByterangeOffset = 0;
     int segmentByterangeLength = C.LENGTH_UNBOUNDED;
-
     int segmentMediaSequence = 0;
 
+    boolean isEncrypted = false;
+    String encryptionKeyUri = null;
+    String encryptionIV = null;
+
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
@@ -193,18 +222,14 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, Uri ba
         segmentDurationSecs = HlsParserUtil.parseDoubleAttr(line, MEDIA_DURATION_REGEX,
             MEDIA_DURATION_TAG);
       } else if (line.startsWith(KEY_TAG)) {
-        segmentEncryptionMethod = HlsParserUtil.parseStringAttr(line, METHOD_ATTR_REGEX,
-            METHOD_ATTR);
-        if (segmentEncryptionMethod.equals(HlsMediaPlaylist.ENCRYPTION_METHOD_NONE)) {
-          segmentEncryptionKeyUri = null;
-          segmentEncryptionIV = null;
+        String method = HlsParserUtil.parseStringAttr(line, METHOD_ATTR_REGEX, METHOD_ATTR);
+        isEncrypted = METHOD_AES128.equals(method);
+        if (isEncrypted) {
+          encryptionKeyUri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX, URI_ATTR);
+          encryptionIV = HlsParserUtil.parseOptionalStringAttr(line, IV_ATTR_REGEX);
         } else {
-          segmentEncryptionKeyUri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX,
-              URI_ATTR);
-          segmentEncryptionIV = HlsParserUtil.parseOptionalStringAttr(line, IV_ATTR_REGEX);
-          if (segmentEncryptionIV == null) {
-            segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
-          }
+          encryptionKeyUri = null;
+          encryptionIV = null;
         }
       } else if (line.startsWith(BYTERANGE_TAG)) {
         String byteRange = HlsParserUtil.parseStringAttr(line, BYTERANGE_REGEX, BYTERANGE_TAG);
@@ -216,13 +241,21 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, Uri ba
       } else if (line.equals(DISCONTINUITY_TAG)) {
         segmentDiscontinuity = true;
       } else if (!line.startsWith("#")) {
+        String segmentEncryptionIV;
+        if (!isEncrypted) {
+          segmentEncryptionIV = null;
+        } else if (encryptionIV != null) {
+          segmentEncryptionIV = encryptionIV;
+        } else {
+          segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
+        }
         segmentMediaSequence++;
         if (segmentByterangeLength == C.LENGTH_UNBOUNDED) {
           segmentByterangeOffset = 0;
         }
         segments.add(new Segment(line, segmentDurationSecs, segmentDiscontinuity,
-            segmentStartTimeUs, segmentEncryptionMethod, segmentEncryptionKeyUri,
-            segmentEncryptionIV, segmentByterangeOffset, segmentByterangeLength));
+            segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
+            segmentByterangeOffset, segmentByterangeLength));
         segmentStartTimeUs += (long) (segmentDurationSecs * C.MICROS_PER_SECOND);
         segmentDiscontinuity = false;
         segmentDurationSecs = 0.0;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index 9db6c4ccc0..d78b23be67 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -15,17 +15,23 @@
  */
 package com.google.android.exoplayer.hls;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.hls.parser.HlsExtractor;
+import com.google.android.exoplayer.chunk.BaseChunkSampleSourceEventListener;
+import com.google.android.exoplayer.chunk.Chunk;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.upstream.Allocator;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
 
+import android.os.Handler;
 import android.os.SystemClock;
 
 import java.io.IOException;
@@ -36,17 +42,30 @@
  */
 public class HlsSampleSource implements SampleSource, Loader.Callback {
 
+  /**
+   * Interface definition for a callback to be notified of {@link HlsSampleSource} events.
+   */
+  public interface EventListener extends BaseChunkSampleSourceEventListener {}
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
+  private static final int BUFFER_FRAGMENT_LENGTH = 256 * 1024;
   private static final int NO_RESET_PENDING = -1;
 
   private final HlsChunkSource chunkSource;
-  private final LinkedList<HlsExtractor> extractors;
+  private final LinkedList<HlsExtractorWrapper> extractors;
+  private final Allocator allocator;
   private final boolean frameAccurateSeeking;
   private final int minLoadableRetryCount;
+  private final int requestedBufferSize;
+  private final long requestedBufferDurationUs;
+
+  private final int eventSourceId;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
 
   private int remainingReleaseCount;
   private boolean prepared;
@@ -56,13 +75,14 @@
   private boolean[] pendingDiscontinuities;
   private TrackInfo[] trackInfos;
   private MediaFormat[] downstreamMediaFormats;
+  private Format downstreamFormat;
 
   private long downstreamPositionUs;
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
 
   private TsChunk previousTsLoadable;
-  private HlsChunk currentLoadable;
+  private Chunk currentLoadable;
   private boolean loadingFinished;
 
   private Loader loader;
@@ -70,33 +90,48 @@
   private boolean currentLoadableExceptionFatal;
   private int currentLoadableExceptionCount;
   private long currentLoadableExceptionTimestamp;
+  private long currentLoadStartTimeMs;
 
   public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
-      int downstreamRendererCount) {
-    this(chunkSource, frameAccurateSeeking, downstreamRendererCount,
+      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs) {
+    this(chunkSource, frameAccurateSeeking, downstreamRendererCount, requestedBufferSize,
+        requestedBufferDurationMs, null, null, 0);
+  }
+
+  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
+      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs,
+      Handler eventHandler, EventListener eventListener, int eventSourceId) {
+    this(chunkSource, frameAccurateSeeking, downstreamRendererCount, requestedBufferSize,
+        requestedBufferDurationMs, eventHandler, eventListener, eventSourceId,
         DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
   public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
-      int downstreamRendererCount, int minLoadableRetryCount) {
+      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs,
+      Handler eventHandler, EventListener eventListener,
+      int eventSourceId, int minLoadableRetryCount) {
     this.chunkSource = chunkSource;
     this.frameAccurateSeeking = frameAccurateSeeking;
     this.remainingReleaseCount = downstreamRendererCount;
+    this.requestedBufferSize = requestedBufferSize;
+    this.requestedBufferDurationUs = requestedBufferDurationMs * 1000;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    extractors = new LinkedList<HlsExtractor>();
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.eventSourceId = eventSourceId;
+    this.pendingResetPositionUs = NO_RESET_PENDING;
+    extractors = new LinkedList<HlsExtractorWrapper>();
+    allocator = new DefaultAllocator(BUFFER_FRAGMENT_LENGTH);
   }
 
   @Override
-  public boolean prepare() throws IOException {
+  public boolean prepare(long positionUs) throws IOException {
     if (prepared) {
       return true;
     }
-    if (loader == null) {
-      loader = new Loader("Loader:HLS");
-    }
-    continueBufferingInternal();
     if (!extractors.isEmpty()) {
-      HlsExtractor extractor = extractors.getFirst();
+      // We're not prepared, but we might have loaded what we need.
+      HlsExtractorWrapper extractor = extractors.getFirst();
       if (extractor.isPrepared()) {
         trackCount = extractor.getTrackCount();
         trackEnabledStates = new boolean[trackCount];
@@ -104,16 +139,27 @@ public boolean prepare() throws IOException {
         downstreamMediaFormats = new MediaFormat[trackCount];
         trackInfos = new TrackInfo[trackCount];
         for (int i = 0; i < trackCount; i++) {
-          MediaFormat format = extractor.getFormat(i);
+          MediaFormat format = extractor.getMediaFormat(i);
           trackInfos[i] = new TrackInfo(format.mimeType, chunkSource.getDurationUs());
         }
         prepared = true;
+        return true;
       }
     }
-    if (!prepared) {
-      maybeThrowLoadableException();
+    // We're not prepared and we haven't loaded what we need.
+    if (loader == null) {
+      loader = new Loader("Loader:HLS");
+    }
+    if (!loader.isLoading()) {
+      // We're going to have to start loading a chunk to get what we need for preparation. We should
+      // attempt to load the chunk at positionUs, so that we'll already be loading the correct chunk
+      // in the common case where the renderer is subsequently enabled at this position.
+      pendingResetPositionUs = positionUs;
+      downstreamPositionUs = positionUs;
     }
-    return prepared;
+    maybeStartLoading();
+    maybeThrowLoadableException();
+    return false;
   }
 
   @Override
@@ -135,6 +181,7 @@ public void enable(int track, long positionUs) {
     enabledTrackCount++;
     trackEnabledStates[track] = true;
     downstreamMediaFormats[track] = null;
+    downstreamFormat = null;
     if (enabledTrackCount == 1) {
       seekToUs(positionUs);
     }
@@ -152,6 +199,7 @@ public void disable(int track) {
         loader.cancelLoading();
       } else {
         clearState();
+        allocator.trim(0);
       }
     }
   }
@@ -190,12 +238,23 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       return DISCONTINUITY_READ;
     }
 
-    if (onlyReadDiscontinuity || isPendingReset() || extractors.isEmpty()) {
+    if (onlyReadDiscontinuity) {
+      return NOTHING_READ;
+    }
+
+    if (isPendingReset()) {
       maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
-    HlsExtractor extractor = getCurrentExtractor();
+    HlsExtractorWrapper extractor = getCurrentExtractor();
+
+    if (downstreamFormat == null || !downstreamFormat.equals(extractor.format)) {
+      // Notify a change in the downstream format.
+      notifyDownstreamFormatChanged(extractor.format, extractor.trigger, extractor.startTimeUs);
+      downstreamFormat = extractor.format;
+    }
+
     if (extractors.size() > 1) {
       // If there's more than one extractor, attempt to configure a seamless splice from the
       // current one to the next one.
@@ -214,7 +273,7 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       return NOTHING_READ;
     }
 
-    MediaFormat mediaFormat = extractor.getFormat(track);
+    MediaFormat mediaFormat = extractor.getMediaFormat(track);
     if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormats[track], true)) {
       chunkSource.getMaxVideoDimensions(mediaFormat);
       formatHolder.format = mediaFormat;
@@ -223,7 +282,8 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     if (extractor.getSample(track, sampleHolder)) {
-      sampleHolder.decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
       return SAMPLE_READ;
     }
 
@@ -240,10 +300,11 @@ public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
     Assertions.checkState(enabledTrackCount > 0);
     lastSeekPositionUs = positionUs;
-    if (pendingResetPositionUs == positionUs || downstreamPositionUs == positionUs) {
-      downstreamPositionUs = positionUs;
+    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
       return;
     }
+
+    // TODO: Optimize the seek for the case where the position is already buffered.
     downstreamPositionUs = positionUs;
     for (int i = 0; i < pendingDiscontinuities.length; i++) {
       pendingDiscontinuities[i] = true;
@@ -260,9 +321,9 @@ public long getBufferedPositionUs() {
     } else if (loadingFinished) {
       return TrackRenderer.END_OF_TRACK_US;
     } else {
-      long largestSampleTimestamp = extractors.getLast().getLargestSampleTimestamp();
-      return largestSampleTimestamp == Long.MIN_VALUE ? downstreamPositionUs
-          : largestSampleTimestamp;
+      long largestParsedTimestampUs = extractors.getLast().getLargestParsedTimestampUs();
+      return largestParsedTimestampUs == Long.MIN_VALUE ? downstreamPositionUs
+          : largestParsedTimestampUs;
     }
   }
 
@@ -277,37 +338,43 @@ public void release() {
 
   @Override
   public void onLoadCompleted(Loadable loadable) {
-    try {
-      currentLoadable.consume();
-    } catch (IOException e) {
-      currentLoadableException = e;
-      currentLoadableExceptionCount++;
-      currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
-      currentLoadableExceptionFatal = true;
-    } finally {
-      if (isTsChunk(currentLoadable)) {
-        TsChunk tsChunk = (TsChunk) loadable;
-        loadingFinished = tsChunk.isLastChunk;
-      }
-      if (!currentLoadableExceptionFatal) {
-        clearCurrentLoadable();
-      }
+    long now = SystemClock.elapsedRealtime();
+    long loadDurationMs = now - currentLoadStartTimeMs;
+    chunkSource.onChunkLoadCompleted(currentLoadable);
+    if (isTsChunk(currentLoadable)) {
+      TsChunk tsChunk = (TsChunk) loadable;
+      loadingFinished = tsChunk.isLastChunk;
+      notifyLoadCompleted(currentLoadable.bytesLoaded(), tsChunk.type, tsChunk.trigger,
+          tsChunk.format, tsChunk.startTimeUs, tsChunk.endTimeUs, now, loadDurationMs);
+    } else {
+      notifyLoadCompleted(currentLoadable.bytesLoaded(), currentLoadable.type,
+          currentLoadable.trigger, currentLoadable.format, -1, -1, now, loadDurationMs);
+    }
+    if (!currentLoadableExceptionFatal) {
+      clearCurrentLoadable();
+    }
+    if (enabledTrackCount > 0) {
       maybeStartLoading();
+    } else {
+      clearState();
+      allocator.trim(0);
     }
   }
 
   @Override
   public void onLoadCanceled(Loadable loadable) {
+    notifyLoadCanceled(currentLoadable.bytesLoaded());
     if (enabledTrackCount > 0) {
       restartFrom(pendingResetPositionUs);
     } else {
       clearState();
+      allocator.trim(0);
     }
   }
 
   @Override
   public void onLoadError(Loadable loadable, IOException e) {
-    if (chunkSource.onLoadError(currentLoadable, e)) {
+    if (chunkSource.onChunkLoadError(currentLoadable, e)) {
       // Error handled by source.
       clearCurrentLoadable();
     } else {
@@ -315,6 +382,7 @@ public void onLoadError(Loadable loadable, IOException e) {
       currentLoadableExceptionCount++;
       currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
     }
+    notifyLoadError(e);
     maybeStartLoading();
   }
 
@@ -328,17 +396,17 @@ public void onLoadError(Loadable loadable, IOException e) {
    *
    * @return The current extractor from which samples should be read. Guaranteed to be non-null.
    */
-  private HlsExtractor getCurrentExtractor() {
-    HlsExtractor extractor = extractors.getFirst();
+  private HlsExtractorWrapper getCurrentExtractor() {
+    HlsExtractorWrapper extractor = extractors.getFirst();
     while (extractors.size() > 1 && !haveSamplesForEnabledTracks(extractor)) {
       // We're finished reading from the extractor for all tracks, and so can discard it.
-      extractors.removeFirst().release();
+      extractors.removeFirst().clear();
       extractor = extractors.getFirst();
     }
     return extractor;
   }
 
-  private void discardSamplesForDisabledTracks(HlsExtractor extractor, long timeUs) {
+  private void discardSamplesForDisabledTracks(HlsExtractorWrapper extractor, long timeUs) {
     if (!extractor.isPrepared()) {
       return;
     }
@@ -349,7 +417,7 @@ private void discardSamplesForDisabledTracks(HlsExtractor extractor, long timeUs
     }
   }
 
-  private boolean haveSamplesForEnabledTracks(HlsExtractor extractor) {
+  private boolean haveSamplesForEnabledTracks(HlsExtractorWrapper extractor) {
     if (!extractor.isPrepared()) {
       return false;
     }
@@ -381,7 +449,7 @@ private void restartFrom(long positionUs) {
 
   private void clearState() {
     for (int i = 0; i < extractors.size(); i++) {
-      extractors.get(i).release();
+      extractors.get(i).clear();
     }
     extractors.clear();
     clearCurrentLoadable();
@@ -410,26 +478,42 @@ private void maybeStartLoading() {
       return;
     }
 
-    HlsChunk nextLoadable = chunkSource.getChunkOperation(previousTsLoadable,
+    if (previousTsLoadable != null
+        && (previousTsLoadable.endTimeUs - downstreamPositionUs >= requestedBufferDurationUs
+        || allocator.getTotalBytesAllocated() >= requestedBufferSize)) {
+      // We already have the target amount of data or time buffered.
+      return;
+    }
+
+    Chunk nextLoadable = chunkSource.getChunkOperation(previousTsLoadable,
         pendingResetPositionUs, downstreamPositionUs);
     if (nextLoadable == null) {
       return;
     }
 
+    currentLoadStartTimeMs = SystemClock.elapsedRealtime();
     currentLoadable = nextLoadable;
     if (isTsChunk(currentLoadable)) {
-      previousTsLoadable = (TsChunk) currentLoadable;
+      TsChunk tsChunk = (TsChunk) currentLoadable;
       if (isPendingReset()) {
         pendingResetPositionUs = NO_RESET_PENDING;
       }
-      if (extractors.isEmpty() || extractors.getLast() != previousTsLoadable.extractor) {
-        extractors.addLast(previousTsLoadable.extractor);
+      HlsExtractorWrapper extractorWrapper = tsChunk.extractorWrapper;
+      if (extractors.isEmpty() || extractors.getLast() != extractorWrapper) {
+        extractorWrapper.init(allocator);
+        extractors.addLast(extractorWrapper);
       }
+      notifyLoadStarted(tsChunk.dataSpec.length, tsChunk.type, tsChunk.trigger, tsChunk.format,
+          tsChunk.startTimeUs, tsChunk.endTimeUs);
+      previousTsLoadable = tsChunk;
+    } else {
+      notifyLoadStarted(currentLoadable.dataSpec.length, currentLoadable.type,
+          currentLoadable.trigger, currentLoadable.format, -1, -1);
     }
     loader.startLoading(currentLoadable, this);
   }
 
-  private boolean isTsChunk(HlsChunk chunk) {
+  private boolean isTsChunk(Chunk chunk) {
     return chunk instanceof TsChunk;
   }
 
@@ -445,4 +529,66 @@ protected final int usToMs(long timeUs) {
     return (int) (timeUs / 1000);
   }
 
+  private void notifyLoadStarted(final long length, final int type, final int trigger,
+      final Format format, final long mediaStartTimeUs, final long mediaEndTimeUs) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadStarted(eventSourceId, length, type, trigger, format,
+              usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs));
+        }
+      });
+    }
+  }
+
+  private void notifyLoadCompleted(final long bytesLoaded, final int type, final int trigger,
+      final Format format, final long mediaStartTimeUs, final long mediaEndTimeUs,
+      final long elapsedRealtimeMs, final long loadDurationMs) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadCompleted(eventSourceId, bytesLoaded, type, trigger, format,
+              usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs);
+        }
+      });
+    }
+  }
+
+  private void notifyLoadCanceled(final long bytesLoaded) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadCanceled(eventSourceId, bytesLoaded);
+        }
+      });
+    }
+  }
+
+  private void notifyLoadError(final IOException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadError(eventSourceId, e);
+        }
+      });
+    }
+  }
+
+  private void notifyDownstreamFormatChanged(final Format format, final int trigger,
+      final long positionUs) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onDownstreamFormatChanged(eventSourceId, format, trigger,
+              usToMs(positionUs));
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java b/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java
new file mode 100644
index 0000000000..082e86c21b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+/**
+ * Subtitle media tag.
+ */
+public final class Subtitle {
+
+  public final String name;
+  public final String uri;
+  public final String language;
+  public final boolean isDefault;
+  public final boolean autoSelect;
+
+  public Subtitle(String name, String uri, String language, boolean isDefault, boolean autoSelect) {
+    this.name = name;
+    this.uri = uri;
+    this.language = language;
+    this.autoSelect = autoSelect;
+    this.isDefault = isDefault;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
index a66330bb5c..f46f094097 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -15,77 +15,59 @@
  */
 package com.google.android.exoplayer.hls;
 
-import com.google.android.exoplayer.hls.parser.HlsExtractor;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.chunk.MediaChunk;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.upstream.Aes128DataSource;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.Util;
 
 import java.io.IOException;
 
 /**
- * A MPEG2TS chunk.
+ * An MPEG2TS chunk.
  */
-public final class TsChunk extends HlsChunk {
+public final class TsChunk extends MediaChunk {
 
-  private static final byte[] SCRATCH_SPACE = new byte[4096];
-
-  /**
-   * The index of the variant in the master playlist.
-   */
-  public final int variantIndex;
-  /**
-   * The start time of the media contained by the chunk.
-   */
-  public final long startTimeUs;
-  /**
-   * The end time of the media contained by the chunk.
-   */
-  public final long endTimeUs;
-  /**
-   * The chunk index.
-   */
-  public final int chunkIndex;
   /**
-   * True if this is the last chunk in the media. False otherwise.
+   * The wrapped extractor into which this chunk is being consumed.
    */
-  public final boolean isLastChunk;
-  /**
-   * The extractor into which this chunk is being consumed.
-   */
-  public final HlsExtractor extractor;
+  public final HlsExtractorWrapper extractorWrapper;
+
+  private final boolean isEncrypted;
 
-  private int loadPosition;
-  private volatile boolean loadFinished;
+  private int bytesLoaded;
   private volatile boolean loadCanceled;
 
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
-   * @param extractor An extractor to parse samples from the data.
-   * @param variantIndex The index of the variant in the master playlist.
+   * @param trigger The reason for this chunk being selected.
+   * @param format The format of the stream to which this chunk belongs.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
    * @param isLastChunk True if this is the last chunk in the media. False otherwise.
+   * @param extractorWrapper A wrapped extractor to parse samples from the data.
+   * @param encryptionKey For AES encryption chunks, the encryption key.
+   * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
    */
-  public TsChunk(DataSource dataSource, DataSpec dataSpec, HlsExtractor extractor,
-      int variantIndex, long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk) {
-    super(dataSource, dataSpec);
-    this.extractor = extractor;
-    this.variantIndex = variantIndex;
-    this.startTimeUs = startTimeUs;
-    this.endTimeUs = endTimeUs;
-    this.chunkIndex = chunkIndex;
-    this.isLastChunk = isLastChunk;
+  public TsChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
+      long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk,
+      HlsExtractorWrapper extractorWrapper, byte[] encryptionKey, byte[] encryptionIv) {
+    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, trigger, format,
+        startTimeUs, endTimeUs, chunkIndex, isLastChunk);
+    this.extractorWrapper = extractorWrapper;
+    // Note: this.dataSource and dataSource may be different.
+    this.isEncrypted = this.dataSource instanceof Aes128DataSource;
   }
 
   @Override
-  public void consume() throws IOException {
-    // Do nothing.
-  }
-
-  @Override
-  public boolean isLoadFinished() {
-    return loadFinished;
+  public long bytesLoaded() {
+    return bytesLoaded;
   }
 
   // Loadable implementation
@@ -102,33 +84,51 @@ public boolean isLoadCanceled() {
 
   @Override
   public void load() throws IOException, InterruptedException {
+    // If we previously fed part of this chunk to the extractor, we need to skip it this time. For
+    // encrypted content we need to skip the data by reading it through the source, so as to ensure
+    // correct decryption of the remainder of the chunk. For clear content, we can request the
+    // remainder of the chunk directly.
+    DataSpec loadDataSpec;
+    boolean skipLoadedBytes;
+    if (isEncrypted) {
+      loadDataSpec = dataSpec;
+      skipLoadedBytes = bytesLoaded != 0;
+    } else {
+      loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+      skipLoadedBytes = false;
+    }
+
     try {
-      dataSource.open(dataSpec);
-      int bytesRead = 0;
-      int bytesSkipped = 0;
-      // If we previously fed part of this chunk to the extractor, skip it this time.
-      // TODO: Ideally we'd construct a dataSpec that only loads the remainder of the data here,
-      // rather than loading the whole chunk again and then skipping data we previously loaded. To
-      // do this is straightforward for non-encrypted content, but more complicated for content
-      // encrypted with AES, for which we'll need to modify the way that decryption is performed.
-      while (bytesRead != -1 && !loadCanceled && bytesSkipped < loadPosition) {
-        int skipLength = Math.min(loadPosition - bytesSkipped, SCRATCH_SPACE.length);
-        bytesRead = dataSource.read(SCRATCH_SPACE, 0, skipLength);
-        if (bytesRead != -1) {
-          bytesSkipped += bytesRead;
-        }
+      ExtractorInput input = new DefaultExtractorInput(dataSource,
+          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+      if (skipLoadedBytes) {
+        input.skipFully(bytesLoaded);
       }
-      // Feed the remaining data into the extractor.
-      while (bytesRead != -1 && !loadCanceled) {
-        bytesRead = extractor.read(dataSource);
-        if (bytesRead != -1) {
-          loadPosition += bytesRead;
+      try {
+        int result = Extractor.RESULT_CONTINUE;
+        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+          result = extractorWrapper.read(input);
         }
+      } finally {
+        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
-      loadFinished = !loadCanceled;
     } finally {
       dataSource.close();
     }
   }
 
+  // Private methods
+
+  /**
+   * If the content is encrypted, returns an {@link Aes128DataSource} that wraps the original in
+   * order to decrypt the loaded data. Else returns the original.
+   */
+  private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
+      byte[] encryptionIv) {
+    if (encryptionKey == null || encryptionIv == null) {
+      return dataSource;
+    }
+    return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/Variant.java b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
index 47d0a450a9..61d6fb54ae 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
@@ -15,42 +15,27 @@
  */
 package com.google.android.exoplayer.hls;
 
-import java.util.Comparator;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.chunk.FormatWrapper;
+import com.google.android.exoplayer.util.MimeTypes;
 
 /**
  * Variant stream reference.
  */
-public final class Variant {
+public final class Variant implements FormatWrapper {
 
-  /**
-   * Sorts {@link Variant} objects in order of decreasing bandwidth.
-   * <p>
-   * When two {@link Variant}s have the same bandwidth, the one with the lowest index comes first.
-   */
-  public static final class DecreasingBandwidthComparator implements Comparator<Variant> {
-
-    @Override
-    public int compare(Variant a, Variant b) {
-      int bandwidthDifference = b.bandwidth - a.bandwidth;
-      return bandwidthDifference != 0 ? bandwidthDifference : a.index - b.index;
-    }
-
-  }
-
-  public final int index;
-  public final int bandwidth;
   public final String url;
-  public final String[] codecs;
-  public final int width;
-  public final int height;
+  public final Format format;
 
-  public Variant(int index, String url, int bandwidth, String[] codecs, int width, int height) {
-    this.index = index;
-    this.bandwidth = bandwidth;
+  public Variant(int index, String url, int bitrate, String codecs, int width, int height) {
     this.url = url;
-    this.codecs = codecs;
-    this.width = width;
-    this.height = height;
+    format = new Format(Integer.toString(index), MimeTypes.APPLICATION_M3U8, width, height, -1, -1,
+        -1, bitrate, null, codecs);
+  }
+
+  @Override
+  public Format getFormat() {
+    return format;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsExtractor.java
deleted file mode 100644
index af164a5f36..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/AdtsExtractor.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.hls.parser;
-
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.BufferPool;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.ParsableByteArray;
-
-import java.io.IOException;
-
-/**
- * Facilitates the extraction of AAC samples from elementary audio files formatted as AAC with ADTS
- * headers.
- */
-public class AdtsExtractor extends HlsExtractor {
-
-  private static final int MAX_PACKET_SIZE = 200;
-
-  private final long firstSampleTimestamp;
-  private final ParsableByteArray packetBuffer;
-  private final AdtsReader adtsReader;
-
-  // Accessed only by the loading thread.
-  private boolean firstPacket;
-  // Accessed by both the loading and consuming threads.
-  private volatile boolean prepared;
-
-  public AdtsExtractor(boolean shouldSpliceIn, long firstSampleTimestamp, BufferPool bufferPool) {
-    super(shouldSpliceIn);
-    this.firstSampleTimestamp = firstSampleTimestamp;
-    packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
-    adtsReader = new AdtsReader(bufferPool);
-    firstPacket = true;
-  }
-
-  @Override
-  public int getTrackCount() {
-    Assertions.checkState(prepared);
-    return 1;
-  }
-
-  @Override
-  public MediaFormat getFormat(int track) {
-    Assertions.checkState(prepared);
-    return adtsReader.getMediaFormat();
-  }
-
-  @Override
-  public boolean isPrepared() {
-    return prepared;
-  }
-
-  @Override
-  public void release() {
-    adtsReader.release();
-  }
-
-  @Override
-  public long getLargestSampleTimestamp() {
-    return adtsReader.getLargestParsedTimestampUs();
-  }
-
-  @Override
-  public boolean getSample(int track, SampleHolder holder) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(track == 0);
-    return adtsReader.getSample(holder);
-  }
-
-  @Override
-  public void discardUntil(int track, long timeUs) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(track == 0);
-    adtsReader.discardUntil(timeUs);
-  }
-
-  @Override
-  public boolean hasSamples(int track) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(track == 0);
-    return !adtsReader.isEmpty();
-  }
-
-  @Override
-  public int read(DataSource dataSource) throws IOException {
-    int bytesRead = dataSource.read(packetBuffer.data, 0, MAX_PACKET_SIZE);
-    if (bytesRead == -1) {
-      return -1;
-    }
-
-    packetBuffer.setPosition(0);
-    packetBuffer.setLimit(bytesRead);
-
-    // TODO: Make it possible for adtsReader to consume the dataSource directly, so that it becomes
-    // unnecessary to copy the data through packetBuffer.
-    adtsReader.consume(packetBuffer, firstSampleTimestamp, firstPacket);
-    firstPacket = false;
-    if (!prepared) {
-      prepared = adtsReader.hasMediaFormat();
-    }
-    return bytesRead;
-  }
-
-  @Override
-  protected SampleQueue getSampleQueue(int track) {
-    Assertions.checkState(track == 0);
-    return adtsReader;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/HlsExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/HlsExtractor.java
deleted file mode 100644
index 88aef4a0d6..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/HlsExtractor.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.hls.parser;
-
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.DataSource;
-
-import java.io.IOException;
-
-/**
- * Facilitates extraction of media samples for HLS playbacks.
- */
-// TODO: Consider consolidating more common logic in this base class.
-public abstract class HlsExtractor {
-
-  private final boolean shouldSpliceIn;
-
-  // Accessed only by the consuming thread.
-  private boolean spliceConfigured;
-
-  public HlsExtractor(boolean shouldSpliceIn) {
-    this.shouldSpliceIn = shouldSpliceIn;
-  }
-
-  /**
-   * Attempts to configure a splice from this extractor to the next.
-   * <p>
-   * The splice is performed such that for each track the samples read from the next extractor
-   * start with a keyframe, and continue from where the samples read from this extractor finish.
-   * A successful splice may discard samples from either or both extractors.
-   * <p>
-   * Splice configuration may fail if the next extractor is not yet in a state that allows the
-   * splice to be performed. Calling this method is a noop if the splice has already been
-   * configured. Hence this method should be called repeatedly during the window within which a
-   * splice can be performed.
-   *
-   * @param nextExtractor The extractor being spliced to.
-   */
-  public final void configureSpliceTo(HlsExtractor nextExtractor) {
-    if (spliceConfigured || !nextExtractor.shouldSpliceIn || !nextExtractor.isPrepared()) {
-      // The splice is already configured, or the next extractor doesn't want to be spliced in, or
-      // the next extractor isn't ready to be spliced in.
-      return;
-    }
-    boolean spliceConfigured = true;
-    int trackCount = getTrackCount();
-    for (int i = 0; i < trackCount; i++) {
-      spliceConfigured &= getSampleQueue(i).configureSpliceTo(nextExtractor.getSampleQueue(i));
-    }
-    this.spliceConfigured = spliceConfigured;
-    return;
-  }
-
-  /**
-   * Gets the number of available tracks.
-   * <p>
-   * This method should only be called after the extractor has been prepared.
-   *
-   * @return The number of available tracks.
-   */
-  public abstract int getTrackCount();
-
-  /**
-   * Gets the format of the specified track.
-   * <p>
-   * This method must only be called after the extractor has been prepared.
-   *
-   * @param track The track index.
-   * @return The corresponding format.
-   */
-  public abstract MediaFormat getFormat(int track);
-
-  /**
-   * Whether the extractor is prepared.
-   *
-   * @return True if the extractor is prepared. False otherwise.
-   */
-  public abstract boolean isPrepared();
-
-  /**
-   * Releases the extractor, recycling any pending or incomplete samples to the sample pool.
-   * <p>
-   * This method should not be called whilst {@link #read(DataSource)} is also being invoked.
-   */
-  public abstract void release();
-
-  /**
-   * Gets the largest timestamp of any sample parsed by the extractor.
-   *
-   * @return The largest timestamp, or {@link Long#MIN_VALUE} if no samples have been parsed.
-   */
-  public abstract long getLargestSampleTimestamp();
-
-  /**
-   * Gets the next sample for the specified track.
-   *
-   * @param track The track from which to read.
-   * @param holder A {@link SampleHolder} into which the sample should be read.
-   * @return True if a sample was read. False otherwise.
-   */
-  public abstract boolean getSample(int track, SampleHolder holder);
-
-  /**
-   * Discards samples for the specified track up to the specified time.
-   *
-   * @param track The track from which samples should be discarded.
-   * @param timeUs The time up to which samples should be discarded, in microseconds.
-   */
-  public abstract void discardUntil(int track, long timeUs);
-
-  /**
-   * Whether samples are available for reading from {@link #getSample(int, SampleHolder)} for the
-   * specified track.
-   *
-   * @return True if samples are available for reading from {@link #getSample(int, SampleHolder)}
-   *     for the specified track. False otherwise.
-   */
-  public abstract boolean hasSamples(int track);
-
-  /**
-   * Reads up to a single TS packet.
-   *
-   * @param dataSource The {@link DataSource} from which to read.
-   * @throws IOException If an error occurred reading from the source.
-   * @return The number of bytes read from the source.
-   */
-  public abstract int read(DataSource dataSource) throws IOException;
-
-  /**
-   * Gets the {@link SampleQueue} for the specified track.
-   *
-   * @param track The track index.
-   * @return The corresponding sample queue.
-   */
-  protected abstract SampleQueue getSampleQueue(int track);
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java
deleted file mode 100644
index 48a618edde..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/hls/parser/RollingSampleBuffer.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.hls.parser;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.upstream.BufferPool;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.ParsableByteArray;
-
-import java.nio.ByteBuffer;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-/**
- * A rolling buffer of sample data and corresponding sample information.
- */
-/* package */ final class RollingSampleBuffer {
-
-  private final BufferPool fragmentPool;
-  private final int fragmentLength;
-
-  private final InfoQueue infoQueue;
-  private final ConcurrentLinkedQueue<byte[]> dataQueue;
-  private final long[] dataOffsetHolder;
-
-  // Accessed only by the consuming thread.
-  private long totalBytesDropped;
-
-  // Accessed only by the loading thread.
-  private long totalBytesWritten;
-  private byte[] lastFragment;
-  private int lastFragmentOffset;
-  private long pendingSampleTimeUs;
-  private long pendingSampleOffset;
-
-  public RollingSampleBuffer(BufferPool bufferPool) {
-    this.fragmentPool = bufferPool;
-    fragmentLength = bufferPool.bufferLength;
-    infoQueue = new InfoQueue();
-    dataQueue = new ConcurrentLinkedQueue<byte[]>();
-    dataOffsetHolder = new long[1];
-  }
-
-  public void release() {
-    while (!dataQueue.isEmpty()) {
-      fragmentPool.releaseDirect(dataQueue.remove());
-    }
-  }
-
-  // Called by the consuming thread.
-
-  /**
-   * Fills {@code holder} with information about the current sample, but does not write its data.
-   * <p>
-   * The fields set are {SampleHolder#size}, {SampleHolder#timeUs} and {SampleHolder#flags}.
-   *
-   * @param holder The holder into which the current sample information should be written.
-   * @return True if the holder was filled. False if there is no current sample.
-   */
-  public boolean peekSample(SampleHolder holder) {
-    return infoQueue.peekSample(holder, dataOffsetHolder);
-  }
-
-  /**
-   * Skips the current sample.
-   */
-  public void skipSample() {
-    long nextOffset = infoQueue.moveToNextSample();
-    dropFragmentsTo(nextOffset);
-  }
-
-  /**
-   * Reads the current sample, advancing the read index to the next sample.
-   *
-   * @param holder The holder into which the current sample should be written.
-   */
-  public void readSample(SampleHolder holder) {
-    // Write the sample information into the holder.
-    infoQueue.peekSample(holder, dataOffsetHolder);
-    // Write the sample data into the holder.
-    if (holder.data == null || holder.data.capacity() < holder.size) {
-      holder.replaceBuffer(holder.size);
-    }
-    if (holder.data != null) {
-      readData(dataOffsetHolder[0], holder.data, holder.size);
-    }
-    // Advance the read head.
-    long nextOffset = infoQueue.moveToNextSample();
-    dropFragmentsTo(nextOffset);
-  }
-
-  /**
-   * Reads data from the front of the rolling buffer.
-   *
-   * @param absolutePosition The absolute position from which data should be read.
-   * @param target The buffer into which data should be written.
-   * @param length The number of bytes to read.
-   */
-  private void readData(long absolutePosition, ByteBuffer target, int length) {
-    int remaining = length;
-    while (remaining > 0) {
-      dropFragmentsTo(absolutePosition);
-      int positionInFragment = (int) (absolutePosition - totalBytesDropped);
-      int toCopy = Math.min(remaining, fragmentLength - positionInFragment);
-      target.put(dataQueue.peek(), positionInFragment, toCopy);
-      absolutePosition += toCopy;
-      remaining -= toCopy;
-    }
-  }
-
-  /**
-   * Discard any fragments that hold data prior to the specified absolute position, returning
-   * them to the pool.
-   *
-   * @param absolutePosition The absolute position up to which fragments can be discarded.
-   */
-  private void dropFragmentsTo(long absolutePosition) {
-    int relativePosition = (int) (absolutePosition - totalBytesDropped);
-    int fragmentIndex = relativePosition / fragmentLength;
-    for (int i = 0; i < fragmentIndex; i++) {
-      fragmentPool.releaseDirect(dataQueue.remove());
-      totalBytesDropped += fragmentLength;
-    }
-  }
-
-  // Called by the loading thread.
-
-  /**
-   * Indicates the start point for the next sample.
-   *
-   * @param sampleTimeUs The sample timestamp.
-   * @param offset The offset of the sample's data, relative to the total number of bytes written
-   *     to the buffer. Must be negative or zero.
-   */
-  public void startSample(long sampleTimeUs, int offset) {
-    Assertions.checkState(offset <= 0);
-    pendingSampleTimeUs = sampleTimeUs;
-    pendingSampleOffset = totalBytesWritten + offset;
-  }
-
-  /**
-   * Appends data to the rolling buffer.
-   *
-   * @param buffer A buffer containing the data to append.
-   * @param length The length of the data to append.
-   */
-  public void appendData(ParsableByteArray buffer, int length) {
-    int remainingWriteLength = length;
-    while (remainingWriteLength > 0) {
-      if (dataQueue.isEmpty() || lastFragmentOffset == fragmentLength) {
-        lastFragmentOffset = 0;
-        lastFragment = fragmentPool.allocateDirect();
-        dataQueue.add(lastFragment);
-      }
-      int thisWriteLength = Math.min(remainingWriteLength, fragmentLength - lastFragmentOffset);
-      buffer.readBytes(lastFragment, lastFragmentOffset, thisWriteLength);
-      lastFragmentOffset += thisWriteLength;
-      remainingWriteLength -= thisWriteLength;
-    }
-    totalBytesWritten += length;
-  }
-
-  /**
-   * Indicates the end point for the current sample, making it available for consumption.
-   *
-   * @param isKeyframe True if the sample being committed is a keyframe. False otherwise.
-   * @param offset The offset of the first byte after the end of the sample's data, relative to
-   *     the total number of bytes written to the buffer. Must be negative or zero.
-   */
-  public void commitSample(boolean isKeyframe, int offset) {
-    Assertions.checkState(offset <= 0);
-    int sampleSize = (int) (totalBytesWritten + offset - pendingSampleOffset);
-    infoQueue.commitSample(pendingSampleTimeUs, pendingSampleOffset, sampleSize,
-        isKeyframe ? C.SAMPLE_FLAG_SYNC : 0);
-  }
-
-  /**
-   * Holds information about the samples in the rolling buffer.
-   */
-  private static class InfoQueue {
-
-    private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
-
-    private int capacity;
-
-    private long[] offsets;
-    private int[] sizes;
-    private int[] flags;
-    private long[] timesUs;
-
-    private int queueSize;
-    private int readIndex;
-    private int writeIndex;
-
-    public InfoQueue() {
-      capacity = SAMPLE_CAPACITY_INCREMENT;
-      offsets = new long[capacity];
-      timesUs = new long[capacity];
-      flags = new int[capacity];
-      sizes = new int[capacity];
-    }
-
-    // Called by the consuming thread.
-
-    /**
-     * Fills {@code holder} with information about the current sample, but does not write its data.
-     * The first entry in {@code offsetHolder} is filled with the absolute position of the sample's
-     * data in the rolling buffer.
-     * <p>
-     * The fields set are {SampleHolder#size}, {SampleHolder#timeUs}, {SampleHolder#flags} and
-     * {@code offsetHolder[0]}.
-     *
-     * @param holder The holder into which the current sample information should be written.
-     * @param offsetHolder The holder into which the absolute position of the sample's data should
-     *     be written.
-     * @return True if the holders were filled. False if there is no current sample.
-     */
-    public synchronized boolean peekSample(SampleHolder holder, long[] offsetHolder) {
-      if (queueSize == 0) {
-        return false;
-      }
-      holder.timeUs = timesUs[readIndex];
-      holder.size = sizes[readIndex];
-      holder.flags = flags[readIndex];
-      offsetHolder[0] = offsets[readIndex];
-      return true;
-    }
-
-    /**
-     * Advances the read index to the next sample.
-     *
-     * @return The absolute position of the first byte in the rolling buffer that may still be
-     *     required after advancing the index. Data prior to this position can be dropped.
-     */
-    public synchronized long moveToNextSample() {
-      queueSize--;
-      int lastReadIndex = readIndex++;
-      if (readIndex == capacity) {
-        // Wrap around.
-        readIndex = 0;
-      }
-      return queueSize > 0 ? offsets[readIndex] : (sizes[lastReadIndex] + offsets[lastReadIndex]);
-    }
-
-    // Called by the loading thread.
-
-    public synchronized void commitSample(long timeUs, long offset, int size, int sampleFlags) {
-      timesUs[writeIndex] = timeUs;
-      offsets[writeIndex] = offset;
-      sizes[writeIndex] = size;
-      flags[writeIndex] = sampleFlags;
-      // Increment the write index.
-      queueSize++;
-      if (queueSize == capacity) {
-        // Increase the capacity.
-        int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
-        long[] newOffsets = new long[newCapacity];
-        long[] newTimesUs = new long[newCapacity];
-        int[] newFlags = new int[newCapacity];
-        int[] newSizes = new int[newCapacity];
-        int beforeWrap = capacity - readIndex;
-        System.arraycopy(offsets, readIndex, newOffsets, 0, beforeWrap);
-        System.arraycopy(timesUs, readIndex, newTimesUs, 0, beforeWrap);
-        System.arraycopy(flags, readIndex, newFlags, 0, beforeWrap);
-        System.arraycopy(sizes, readIndex, newSizes, 0, beforeWrap);
-        int afterWrap = readIndex;
-        System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
-        System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
-        System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
-        System.arraycopy(sizes, 0, newSizes, beforeWrap, afterWrap);
-        offsets = newOffsets;
-        timesUs = newTimesUs;
-        flags = newFlags;
-        sizes = newSizes;
-        readIndex = 0;
-        writeIndex = capacity;
-        queueSize = capacity;
-        capacity = newCapacity;
-      } else {
-        writeIndex++;
-        if (writeIndex == capacity) {
-          // Wrap around.
-          writeIndex = 0;
-        }
-      }
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
new file mode 100644
index 0000000000..1d4fcb4dee
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+/**
+ * A metadata that contains parsed ID3 GEOB (General Encapsulated Object) frame data associated
+ * with time indices.
+ */
+public class GeobMetadata {
+
+  public static final String TYPE = "GEOB";
+
+  public final String mimeType;
+  public final String filename;
+  public final String description;
+  public final byte[] data;
+
+  public GeobMetadata(String mimeType, String filename, String description, byte[] data) {
+    this.mimeType = mimeType;
+    this.filename = filename;
+    this.description = description;
+    this.data = data;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
index 1ec0e363dd..836ec7f8f6 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
@@ -29,6 +29,11 @@
  */
 public class Id3Parser implements MetadataParser<Map<String, Object>> {
 
+  private static final int ID3_TEXT_ENCODING_ISO_8859_1 = 0;
+  private static final int ID3_TEXT_ENCODING_UTF_16 = 1;
+  private static final int ID3_TEXT_ENCODING_UTF_16BE = 2;
+  private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
+
   @Override
   public boolean canParse(String mimeType) {
     return mimeType.equals(MimeTypes.APPLICATION_ID3);
@@ -52,7 +57,7 @@ public boolean canParse(String mimeType) {
       }
 
       // Skip frame flags.
-      id3Data.skip(2);
+      id3Data.skipBytes(2);
       // Check Frame ID == TXXX.
       if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
         int encoding = id3Data.readUnsignedByte();
@@ -60,13 +65,48 @@ public boolean canParse(String mimeType) {
         byte[] frame = new byte[frameSize - 1];
         id3Data.readBytes(frame, 0, frameSize - 1);
 
-        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
+        int firstZeroIndex = indexOfEOS(frame, 0, encoding);
         String description = new String(frame, 0, firstZeroIndex, charset);
-        int valueStartIndex = indexOfNot(frame, firstZeroIndex, (byte) 0);
-        int valueEndIndex = indexOf(frame, valueStartIndex, (byte) 0);
+        int valueStartIndex = firstZeroIndex + delimiterLength(encoding);
+        int valueEndIndex = indexOfEOS(frame, valueStartIndex, encoding);
         String value = new String(frame, valueStartIndex, valueEndIndex - valueStartIndex,
             charset);
         metadata.put(TxxxMetadata.TYPE, new TxxxMetadata(description, value));
+      } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
+        // Check frame ID == PRIV
+        byte[] frame = new byte[frameSize];
+        id3Data.readBytes(frame, 0, frameSize);
+
+        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
+        String owner = new String(frame, 0, firstZeroIndex, "ISO-8859-1");
+        byte[] privateData = new byte[frameSize - firstZeroIndex - 1];
+        System.arraycopy(frame, firstZeroIndex + 1, privateData, 0, frameSize - firstZeroIndex - 1);
+        metadata.put(PrivMetadata.TYPE, new PrivMetadata(owner, privateData));
+      } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
+        // Check frame ID == GEOB
+        int encoding = id3Data.readUnsignedByte();
+        String charset = getCharsetName(encoding);
+        byte[] frame = new byte[frameSize - 1];
+        id3Data.readBytes(frame, 0, frameSize - 1);
+
+        int firstZeroIndex = indexOf(frame, 0, (byte) 0);
+        String mimeType = new String(frame, 0, firstZeroIndex, "ISO-8859-1");
+        int filenameStartIndex = firstZeroIndex + 1;
+        int filenameEndIndex = indexOfEOS(frame, filenameStartIndex, encoding);
+        String filename = new String(frame, filenameStartIndex,
+            filenameEndIndex - filenameStartIndex, charset);
+        int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
+        int descriptionEndIndex = indexOfEOS(frame, descriptionStartIndex, encoding);
+        String description = new String(frame, descriptionStartIndex,
+            descriptionEndIndex - descriptionStartIndex, charset);
+
+        int objectDataSize = frameSize - 1 /* encoding byte */ - descriptionEndIndex
+            - delimiterLength(encoding);
+        byte[] objectData = new byte[objectDataSize];
+        System.arraycopy(frame, descriptionEndIndex + delimiterLength(encoding), objectData, 0,
+            objectDataSize);
+        metadata.put(GeobMetadata.TYPE, new GeobMetadata(mimeType, filename,
+            description, objectData));
       } else {
         String type = String.format("%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
         byte[] frame = new byte[frameSize];
@@ -89,15 +129,30 @@ private static int indexOf(byte[] data, int fromIndex, byte key) {
     return data.length;
   }
 
-  private static int indexOfNot(byte[] data, int fromIndex, byte key) {
-    for (int i = fromIndex; i < data.length; i++) {
-      if (data[i] != key) {
-        return i;
+  private static int indexOfEOS(byte[] data, int fromIndex, int encodingByte) {
+    int terminationPos = indexOf(data, fromIndex, (byte) 0);
+
+    // For single byte encoding charsets, we are done
+    if (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8) {
+      return terminationPos;
+    }
+
+    // Otherwise, look for a two zero bytes
+    while (terminationPos < data.length - 1) {
+      if (data[terminationPos + 1] == (byte) 0) {
+        return terminationPos;
       }
+      terminationPos = indexOf(data, terminationPos + 1, (byte) 0);
     }
+
     return data.length;
   }
 
+  private static int delimiterLength(int encodingByte) {
+    return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1
+        || encodingByte == ID3_TEXT_ENCODING_UTF_8) ? 1 : 2;
+  }
+
   /**
    * Parses an ID3 header.
    *
@@ -113,7 +168,7 @@ private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserExce
       throw new ParserException(String.format(
           "Unexpected ID3 file identifier, expected \"ID3\", actual \"%c%c%c\".", id1, id2, id3));
     }
-    id3Buffer.skip(2); // Skip version.
+    id3Buffer.skipBytes(2); // Skip version.
 
     int flags = id3Buffer.readUnsignedByte();
     int id3Size = id3Buffer.readSynchSafeInt();
@@ -122,7 +177,7 @@ private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserExce
     if ((flags & 0x2) != 0) {
       int extendedHeaderSize = id3Buffer.readSynchSafeInt();
       if (extendedHeaderSize > 4) {
-        id3Buffer.skip(extendedHeaderSize - 4);
+        id3Buffer.skipBytes(extendedHeaderSize - 4);
       }
       id3Size -= extendedHeaderSize;
     }
@@ -142,13 +197,13 @@ private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserExce
    */
   private static String getCharsetName(int encodingByte) {
     switch (encodingByte) {
-      case 0:
+      case ID3_TEXT_ENCODING_ISO_8859_1:
         return "ISO-8859-1";
-      case 1:
+      case ID3_TEXT_ENCODING_UTF_16:
         return "UTF-16";
-      case 2:
+      case ID3_TEXT_ENCODING_UTF_16BE:
         return "UTF-16BE";
-      case 3:
+      case ID3_TEXT_ENCODING_UTF_8:
         return "UTF-8";
       default:
         return "ISO-8859-1";
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
index 147a222c4f..c6cd9aa458 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
@@ -90,9 +90,9 @@ public MetadataTrackRenderer(SampleSource source, MetadataParser<T> metadataPars
   }
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     try {
-      boolean sourcePrepared = source.prepare();
+      boolean sourcePrepared = source.prepare(positionUs);
       if (!sourcePrepared) {
         return TrackRenderer.STATE_UNPREPARED;
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
new file mode 100644
index 0000000000..8573b25906
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+/**
+ * A metadata that contains parsed ID3 PRIV (Private) frame data associated
+ * with time indices.
+ */
+public class PrivMetadata {
+
+  public static final String TYPE = "PRIV";
+
+  public final String owner;
+  public final byte[] privateData;
+
+  public PrivMetadata(String owner, byte[] privateData) {
+    this.owner = owner;
+    this.privateData = privateData;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java
deleted file mode 100644
index 292c231087..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/mp4/Atom.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.mp4;
-
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.ParsableByteArray;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public abstract class Atom {
-
-  public static final int TYPE_avc1 = getAtomTypeInteger("avc1");
-  public static final int TYPE_avc3 = getAtomTypeInteger("avc3");
-  public static final int TYPE_esds = getAtomTypeInteger("esds");
-  public static final int TYPE_mdat = getAtomTypeInteger("mdat");
-  public static final int TYPE_mp4a = getAtomTypeInteger("mp4a");
-  public static final int TYPE_ac_3 = getAtomTypeInteger("ac-3");
-  public static final int TYPE_dac3 = getAtomTypeInteger("dac3");
-  public static final int TYPE_ec_3 = getAtomTypeInteger("ec-3");
-  public static final int TYPE_dec3 = getAtomTypeInteger("dec3");
-  public static final int TYPE_tfdt = getAtomTypeInteger("tfdt");
-  public static final int TYPE_tfhd = getAtomTypeInteger("tfhd");
-  public static final int TYPE_trex = getAtomTypeInteger("trex");
-  public static final int TYPE_trun = getAtomTypeInteger("trun");
-  public static final int TYPE_sidx = getAtomTypeInteger("sidx");
-  public static final int TYPE_moov = getAtomTypeInteger("moov");
-  public static final int TYPE_mvhd = getAtomTypeInteger("mvhd");
-  public static final int TYPE_trak = getAtomTypeInteger("trak");
-  public static final int TYPE_mdia = getAtomTypeInteger("mdia");
-  public static final int TYPE_minf = getAtomTypeInteger("minf");
-  public static final int TYPE_stbl = getAtomTypeInteger("stbl");
-  public static final int TYPE_avcC = getAtomTypeInteger("avcC");
-  public static final int TYPE_moof = getAtomTypeInteger("moof");
-  public static final int TYPE_traf = getAtomTypeInteger("traf");
-  public static final int TYPE_mvex = getAtomTypeInteger("mvex");
-  public static final int TYPE_tkhd = getAtomTypeInteger("tkhd");
-  public static final int TYPE_mdhd = getAtomTypeInteger("mdhd");
-  public static final int TYPE_hdlr = getAtomTypeInteger("hdlr");
-  public static final int TYPE_stsd = getAtomTypeInteger("stsd");
-  public static final int TYPE_pssh = getAtomTypeInteger("pssh");
-  public static final int TYPE_sinf = getAtomTypeInteger("sinf");
-  public static final int TYPE_schm = getAtomTypeInteger("schm");
-  public static final int TYPE_schi = getAtomTypeInteger("schi");
-  public static final int TYPE_tenc = getAtomTypeInteger("tenc");
-  public static final int TYPE_encv = getAtomTypeInteger("encv");
-  public static final int TYPE_enca = getAtomTypeInteger("enca");
-  public static final int TYPE_frma = getAtomTypeInteger("frma");
-  public static final int TYPE_saiz = getAtomTypeInteger("saiz");
-  public static final int TYPE_uuid = getAtomTypeInteger("uuid");
-  public static final int TYPE_senc = getAtomTypeInteger("senc");
-  public static final int TYPE_pasp = getAtomTypeInteger("pasp");
-  public static final int TYPE_TTML = getAtomTypeInteger("TTML");
-  public static final int TYPE_vmhd = getAtomTypeInteger("vmhd");
-  public static final int TYPE_smhd = getAtomTypeInteger("smhd");
-  public static final int TYPE_mp4v = getAtomTypeInteger("mp4v");
-  public static final int TYPE_stts = getAtomTypeInteger("stts");
-  public static final int TYPE_stss = getAtomTypeInteger("stss");
-  public static final int TYPE_ctts = getAtomTypeInteger("ctts");
-  public static final int TYPE_stsc = getAtomTypeInteger("stsc");
-  public static final int TYPE_stsz = getAtomTypeInteger("stsz");
-  public static final int TYPE_stco = getAtomTypeInteger("stco");
-  public static final int TYPE_co64 = getAtomTypeInteger("co64");
-
-  public final int type;
-
-  Atom(int type) {
-    this.type = type;
-  }
-
-  @Override
-  public String toString() {
-    return getAtomTypeString(type);
-  }
-
-  /** An MP4 atom that is a leaf. */
-  public static final class LeafAtom extends Atom {
-
-    public final ParsableByteArray data;
-
-    public LeafAtom(int type, ParsableByteArray data) {
-      super(type);
-      this.data = data;
-    }
-
-  }
-
-  /** An MP4 atom that has child atoms. */
-  public static final class ContainerAtom extends Atom {
-
-    public final long endByteOffset;
-    public final List<LeafAtom> leafChildren;
-    public final List<ContainerAtom> containerChildren;
-
-    public ContainerAtom(int type, long endByteOffset) {
-      super(type);
-
-      leafChildren = new ArrayList<LeafAtom>();
-      containerChildren = new ArrayList<ContainerAtom>();
-      this.endByteOffset = endByteOffset;
-    }
-
-    public void add(LeafAtom atom) {
-      leafChildren.add(atom);
-    }
-
-    public void add(ContainerAtom atom) {
-      containerChildren.add(atom);
-    }
-
-    public LeafAtom getLeafAtomOfType(int type) {
-      int childrenSize = leafChildren.size();
-      for (int i = 0; i < childrenSize; i++) {
-        LeafAtom atom = leafChildren.get(i);
-        if (atom.type == type) {
-          return atom;
-        }
-      }
-      return null;
-    }
-
-    public ContainerAtom getContainerAtomOfType(int type) {
-      int childrenSize = containerChildren.size();
-      for (int i = 0; i < childrenSize; i++) {
-        ContainerAtom atom = containerChildren.get(i);
-        if (atom.type == type) {
-          return atom;
-        }
-      }
-      return null;
-    }
-
-    @Override
-    public String toString() {
-      return getAtomTypeString(type)
-          + " leaves: " + Arrays.toString(leafChildren.toArray(new LeafAtom[0]))
-          + " containers: " + Arrays.toString(containerChildren.toArray(new ContainerAtom[0]));
-    }
-
-  }
-
-  private static String getAtomTypeString(int type) {
-    return "" + (char) (type >> 24)
-        + (char) ((type >> 16) & 0xFF)
-        + (char) ((type >> 8) & 0xFF)
-        + (char) (type & 0xFF);
-  }
-
-  private static int getAtomTypeInteger(String typeName) {
-    Assertions.checkArgument(typeName.length() == 4);
-    int result = 0;
-    for (int i = 0; i < 4; i++) {
-      result <<= 8;
-      result |= typeName.charAt(i);
-    }
-    return result;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 6e04658ef9..14292cbb67 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.chunk.Chunk;
+import com.google.android.exoplayer.chunk.ChunkExtractorWrapper;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.ChunkSource;
 import com.google.android.exoplayer.chunk.ContainerMediaChunk;
@@ -27,10 +28,10 @@
 import com.google.android.exoplayer.chunk.FormatEvaluator;
 import com.google.android.exoplayer.chunk.FormatEvaluator.Evaluation;
 import com.google.android.exoplayer.chunk.MediaChunk;
-import com.google.android.exoplayer.chunk.parser.Extractor;
-import com.google.android.exoplayer.chunk.parser.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer.chunk.parser.mp4.TrackEncryptionBox;
-import com.google.android.exoplayer.mp4.Track;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer.extractor.mp4.Track;
+import com.google.android.exoplayer.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
@@ -38,6 +39,7 @@
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.ManifestFetcher;
+import com.google.android.exoplayer.util.MimeTypes;
 
 import android.net.Uri;
 import android.os.SystemClock;
@@ -48,8 +50,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.UUID;
 
 /**
  * An {@link ChunkSource} for SmoothStreaming.
@@ -70,9 +70,10 @@
   private final int maxWidth;
   private final int maxHeight;
 
-  private final SparseArray<FragmentedMp4Extractor> extractors;
-  private final Map<UUID, byte[]> psshInfo;
-  private final SmoothStreamingFormat[] formats;
+  private final SparseArray<ChunkExtractorWrapper> extractorWrappers;
+  private final SparseArray<MediaFormat> mediaFormats;
+  private final DrmInitData drmInitData;
+  private final Format[] formats;
 
   private SmoothStreamingManifest currentManifest;
   private int currentManifestChunkOffset;
@@ -134,7 +135,7 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
     this.liveEdgeLatencyUs = liveEdgeLatencyMs * 1000;
 
     StreamElement streamElement = getElement(initialManifest);
-    trackInfo = new TrackInfo(streamElement.tracks[0].mimeType, initialManifest.durationUs);
+    trackInfo = new TrackInfo(streamElement.tracks[0].format.mimeType, initialManifest.durationUs);
     evaluation = new Evaluation();
 
     TrackEncryptionBox[] trackEncryptionBoxes = null;
@@ -143,24 +144,24 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
       byte[] keyId = getKeyId(protectionElement.data);
       trackEncryptionBoxes = new TrackEncryptionBox[1];
       trackEncryptionBoxes[0] = new TrackEncryptionBox(true, INITIALIZATION_VECTOR_SIZE, keyId);
-      psshInfo = Collections.singletonMap(protectionElement.uuid, protectionElement.data);
+      DrmInitData.Mapped drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
+      drmInitData.put(protectionElement.uuid, protectionElement.data);
+      this.drmInitData = drmInitData;
     } else {
-      psshInfo = null;
+      drmInitData = null;
     }
 
     int trackCount = trackIndices != null ? trackIndices.length : streamElement.tracks.length;
-    formats = new SmoothStreamingFormat[trackCount];
-    extractors = new SparseArray<FragmentedMp4Extractor>();
+    formats = new Format[trackCount];
+    extractorWrappers = new SparseArray<ChunkExtractorWrapper>();
+    mediaFormats = new SparseArray<MediaFormat>();
     int maxWidth = 0;
     int maxHeight = 0;
     for (int i = 0; i < trackCount; i++) {
       int trackIndex = trackIndices != null ? trackIndices[i] : i;
-      TrackElement trackElement = streamElement.tracks[trackIndex];
-      formats[i] = new SmoothStreamingFormat(String.valueOf(trackIndex), trackElement.mimeType,
-          trackElement.maxWidth, trackElement.maxHeight, trackElement.numChannels,
-          trackElement.sampleRate, trackElement.bitrate, trackIndex);
-      maxWidth = Math.max(maxWidth, trackElement.maxWidth);
-      maxHeight = Math.max(maxHeight, trackElement.maxHeight);
+      formats[i] = streamElement.tracks[trackIndex].format;
+      maxWidth = Math.max(maxWidth, formats[i].width);
+      maxHeight = Math.max(maxHeight, formats[i].height);
 
       MediaFormat mediaFormat = getMediaFormat(streamElement, trackIndex);
       int trackType = streamElement.type == StreamElement.TYPE_VIDEO ? Track.TYPE_VIDEO
@@ -168,8 +169,10 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
       FragmentedMp4Extractor extractor = new FragmentedMp4Extractor(
           FragmentedMp4Extractor.WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME);
       extractor.setTrack(new Track(trackIndex, trackType, streamElement.timescale,
-          initialManifest.durationUs, mediaFormat, trackEncryptionBoxes));
-      extractors.put(trackIndex, extractor);
+          initialManifest.durationUs, mediaFormat, trackEncryptionBoxes,
+          trackType == Track.TYPE_VIDEO ? 4 : -1));
+      extractorWrappers.put(trackIndex, new ChunkExtractorWrapper(extractor));
+      mediaFormats.put(trackIndex, mediaFormat);
     }
     this.maxHeight = maxHeight;
     this.maxWidth = maxWidth;
@@ -238,14 +241,14 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
 
     evaluation.queueSize = queue.size();
     formatEvaluator.evaluate(queue, playbackPositionUs, formats, evaluation);
-    SmoothStreamingFormat selectedFormat = (SmoothStreamingFormat) evaluation.format;
+    Format selectedFormat = evaluation.format;
     out.queueSize = evaluation.queueSize;
 
     if (selectedFormat == null) {
       out.chunk = null;
       return;
     } else if (out.queueSize == queue.size() && out.chunk != null
-        && out.chunk.format.id.equals(evaluation.format.id)) {
+        && out.chunk.format.equals(evaluation.format)) {
       // We already have a chunk, and the evaluation hasn't changed either the format or the size
       // of the queue. Do nothing.
       return;
@@ -269,7 +272,8 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       }
       chunkIndex = streamElement.getChunkIndex(seekPositionUs);
     } else {
-      chunkIndex = queue.get(out.queueSize - 1).nextChunkIndex - currentManifestChunkOffset;
+      MediaChunk previous = queue.get(out.queueSize - 1);
+      chunkIndex = previous.isLastChunk ? -1 : previous.chunkIndex + 1 - currentManifestChunkOffset;
     }
 
     if (currentManifest.isLive) {
@@ -293,14 +297,15 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
 
     boolean isLastChunk = !currentManifest.isLive && chunkIndex == streamElement.chunkCount - 1;
     long chunkStartTimeUs = streamElement.getStartTimeUs(chunkIndex);
-    long nextChunkStartTimeUs = isLastChunk ? -1
+    long chunkEndTimeUs = isLastChunk ? -1
         : chunkStartTimeUs + streamElement.getChunkDurationUs(chunkIndex);
     int currentAbsoluteChunkIndex = chunkIndex + currentManifestChunkOffset;
 
-    Uri uri = streamElement.buildRequestUri(selectedFormat.trackIndex, chunkIndex);
-    Chunk mediaChunk = newMediaChunk(selectedFormat, uri, null,
-        extractors.get(Integer.parseInt(selectedFormat.id)), psshInfo, dataSource,
-        currentAbsoluteChunkIndex, isLastChunk, chunkStartTimeUs, nextChunkStartTimeUs, 0);
+    int trackIndex = getTrackIndex(selectedFormat);
+    Uri uri = streamElement.buildRequestUri(trackIndex, chunkIndex);
+    Chunk mediaChunk = newMediaChunk(selectedFormat, uri, null, extractorWrappers.get(trackIndex),
+        drmInitData, dataSource, currentAbsoluteChunkIndex, isLastChunk, chunkStartTimeUs,
+        chunkEndTimeUs, evaluation.trigger, mediaFormats.get(trackIndex));
     out.chunk = mediaChunk;
   }
 
@@ -310,6 +315,11 @@ public IOException getError() {
         : (manifestFetcher != null ? manifestFetcher.getError() : null);
   }
 
+  @Override
+  public void onChunkLoadCompleted(Chunk chunk) {
+    // Do nothing.
+  }
+
   @Override
   public void onChunkLoadError(Chunk chunk, Exception e) {
     // Do nothing.
@@ -339,12 +349,24 @@ private StreamElement getElement(SmoothStreamingManifest manifest) {
     return manifest.streamElements[streamElementIndex];
   }
 
+  private int getTrackIndex(Format format) {
+    TrackElement[] tracks = currentManifest.streamElements[streamElementIndex].tracks;
+    for (int i = 0; i < tracks.length; i++) {
+      if (tracks[i].format.equals(format)) {
+        return i;
+      }
+    }
+    // Should never happen.
+    throw new IllegalStateException("Invalid format: " + format);
+  }
+
   private static MediaFormat getMediaFormat(StreamElement streamElement, int trackIndex) {
     TrackElement trackElement = streamElement.tracks[trackIndex];
-    String mimeType = trackElement.mimeType;
+    Format trackFormat = trackElement.format;
+    String mimeType = trackFormat.mimeType;
     if (streamElement.type == StreamElement.TYPE_VIDEO) {
       MediaFormat format = MediaFormat.createVideoFormat(mimeType, MediaFormat.NO_VALUE,
-          trackElement.maxWidth, trackElement.maxHeight, Arrays.asList(trackElement.csd));
+          trackFormat.width, trackFormat.height, Arrays.asList(trackElement.csd));
       format.setMaxVideoDimensions(streamElement.maxWidth, streamElement.maxHeight);
       return format;
     } else if (streamElement.type == StreamElement.TYPE_AUDIO) {
@@ -353,28 +375,28 @@ private static MediaFormat getMediaFormat(StreamElement streamElement, int track
         csd = Arrays.asList(trackElement.csd);
       } else {
         csd = Collections.singletonList(CodecSpecificDataUtil.buildAudioSpecificConfig(
-            trackElement.sampleRate, trackElement.numChannels));
+            trackFormat.audioSamplingRate, trackFormat.numChannels));
       }
       MediaFormat format = MediaFormat.createAudioFormat(mimeType, MediaFormat.NO_VALUE,
-          trackElement.numChannels, trackElement.sampleRate, csd);
+          trackFormat.numChannels, trackFormat.audioSamplingRate, csd);
       return format;
     } else if (streamElement.type == StreamElement.TYPE_TEXT) {
-      return MediaFormat.createFormatForMimeType(streamElement.tracks[trackIndex].mimeType);
+      return MediaFormat.createFormatForMimeType(trackFormat.mimeType);
     }
     return null;
   }
 
   private static MediaChunk newMediaChunk(Format formatInfo, Uri uri, String cacheKey,
-      Extractor extractor, Map<UUID, byte[]> psshInfo, DataSource dataSource, int chunkIndex,
-      boolean isLast, long chunkStartTimeUs, long nextChunkStartTimeUs, int trigger) {
-    int nextChunkIndex = isLast ? -1 : chunkIndex + 1;
-    long nextStartTimeUs = isLast ? -1 : nextChunkStartTimeUs;
+      ChunkExtractorWrapper extractorWrapper, DrmInitData drmInitData, DataSource dataSource,
+      int chunkIndex, boolean isLast, long chunkStartTimeUs, long chunkEndTimeUs,
+      int trigger, MediaFormat mediaFormat) {
     long offset = 0;
     DataSpec dataSpec = new DataSpec(uri, offset, -1, cacheKey);
     // In SmoothStreaming each chunk contains sample timestamps relative to the start of the chunk.
     // To convert them the absolute timestamps, we need to set sampleOffsetUs to -chunkStartTimeUs.
-    return new ContainerMediaChunk(dataSource, dataSpec, formatInfo, trigger, chunkStartTimeUs,
-        nextStartTimeUs, nextChunkIndex, extractor, psshInfo, false, -chunkStartTimeUs);
+    return new ContainerMediaChunk(dataSource, dataSpec, trigger, formatInfo, chunkStartTimeUs,
+        chunkEndTimeUs, chunkIndex, isLast, chunkStartTimeUs, extractorWrapper, mediaFormat,
+        drmInitData, true);
   }
 
   private static byte[] getKeyId(byte[] initData) {
@@ -399,16 +421,4 @@ private static void swap(byte[] data, int firstPosition, int secondPosition) {
     data[secondPosition] = temp;
   }
 
-  private static final class SmoothStreamingFormat extends Format {
-
-    public final int trackIndex;
-
-    public SmoothStreamingFormat(String id, String mimeType, int width, int height,
-        int numChannels, int audioSamplingRate, int bitrate, int trackIndex) {
-      super(id, mimeType, width, height, numChannels, audioSamplingRate, bitrate);
-      this.trackIndex = trackIndex;
-    }
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
index d7e6ee1358..34c3880fa8 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifest.java
@@ -16,7 +16,10 @@
 package com.google.android.exoplayer.smoothstreaming;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.chunk.FormatWrapper;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.UriUtil;
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
@@ -123,50 +126,21 @@ public ProtectionElement(UUID uuid, byte[] data) {
   /**
    * Represents a QualityLevel element.
    */
-  public static class TrackElement {
+  public static class TrackElement implements FormatWrapper {
 
-    // Required for all
-    public final int index;
-    public final int bitrate;
-
-    // Audio-video
+    public final Format format;
     public final byte[][] csd;
-    public final int profile;
-    public final int level;
-    public final String mimeType;
-
-    // Video-only
-    public final int maxWidth;
-    public final int maxHeight;
 
-    // Audio-only
-    public final int sampleRate;
-    public final int numChannels;
-    public final int packetSize;
-    public final int audioTag;
-    public final int bitPerSample;
-
-    public final int nalUnitLengthField;
-    public final String content;
-
-    public TrackElement(int index, int bitrate, String mimeType, byte[][] csd, int profile,
-        int level, int maxWidth, int maxHeight, int sampleRate, int channels, int packetSize,
-        int audioTag, int bitPerSample, int nalUnitLengthField, String content) {
-      this.index = index;
-      this.bitrate = bitrate;
-      this.mimeType = mimeType;
+    public TrackElement(int index, int bitrate, String mimeType, byte[][] csd, int maxWidth,
+        int maxHeight, int sampleRate, int numChannels) {
       this.csd = csd;
-      this.profile = profile;
-      this.level = level;
-      this.maxWidth = maxWidth;
-      this.maxHeight = maxHeight;
-      this.sampleRate = sampleRate;
-      this.numChannels = channels;
-      this.packetSize = packetSize;
-      this.audioTag = audioTag;
-      this.bitPerSample = bitPerSample;
-      this.nalUnitLengthField = nalUnitLengthField;
-      this.content = content;
+      format = new Format(String.valueOf(index), mimeType, maxWidth, maxHeight, -1, numChannels,
+          sampleRate, bitrate);
+    }
+
+    @Override
+    public Format getFormat() {
+      return format;
     }
 
   }
@@ -197,14 +171,14 @@ public TrackElement(int index, int bitrate, String mimeType, byte[][] csd, int p
     public final TrackElement[] tracks;
     public final int chunkCount;
 
-    private final Uri baseUri;
+    private final String baseUri;
     private final String chunkTemplate;
 
     private final List<Long> chunkStartTimes;
     private final long[] chunkStartTimesUs;
     private final long lastChunkDurationUs;
 
-    public StreamElement(Uri baseUri, String chunkTemplate, int type, String subType,
+    public StreamElement(String baseUri, String chunkTemplate, int type, String subType,
         long timescale, String name, int qualityLevels, int maxWidth, int maxHeight,
         int displayWidth, int displayHeight, String language, TrackElement[] tracks,
         List<Long> chunkStartTimes, long lastChunkDuration) {
@@ -272,9 +246,9 @@ public Uri buildRequestUri(int track, int chunkIndex) {
       Assertions.checkState(chunkStartTimes != null);
       Assertions.checkState(chunkIndex < chunkStartTimes.size());
       String chunkUrl = chunkTemplate
-          .replace(URL_PLACEHOLDER_BITRATE, Integer.toString(tracks[track].bitrate))
+          .replace(URL_PLACEHOLDER_BITRATE, Integer.toString(tracks[track].format.bitrate))
           .replace(URL_PLACEHOLDER_START_TIME, chunkStartTimes.get(chunkIndex).toString());
-      return Util.getMergedUri(baseUri, chunkUrl);
+      return UriUtil.resolveToUri(baseUri, chunkUrl);
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
index 20aea8ad32..c2b4e567eb 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
@@ -19,12 +19,11 @@
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
+import com.google.android.exoplayer.upstream.UriLoadable;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.ManifestParser;
 import com.google.android.exoplayer.util.MimeTypes;
 
-import android.net.Uri;
 import android.util.Base64;
 import android.util.Pair;
 
@@ -45,7 +44,7 @@
  * @see <a href="http://msdn.microsoft.com/en-us/library/ee673436(v=vs.90).aspx">
  * IIS Smooth Streaming Client Manifest Format</a>
  */
-public class SmoothStreamingManifestParser implements ManifestParser<SmoothStreamingManifest> {
+public class SmoothStreamingManifestParser implements UriLoadable.Parser<SmoothStreamingManifest> {
 
   private final XmlPullParserFactory xmlParserFactory;
 
@@ -58,12 +57,13 @@ public SmoothStreamingManifestParser() {
   }
 
   @Override
-  public SmoothStreamingManifest parse(InputStream inputStream, String inputEncoding,
-      String contentId, Uri baseUri) throws IOException, ParserException {
+  public SmoothStreamingManifest parse(String connectionUrl, InputStream inputStream)
+      throws IOException, ParserException {
     try {
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
-      xmlParser.setInput(inputStream, inputEncoding);
-      SmoothStreamMediaParser smoothStreamMediaParser = new SmoothStreamMediaParser(null, baseUri);
+      xmlParser.setInput(inputStream, null);
+      SmoothStreamMediaParser smoothStreamMediaParser =
+          new SmoothStreamMediaParser(null, connectionUrl);
       return (SmoothStreamingManifest) smoothStreamMediaParser.parse(xmlParser);
     } catch (XmlPullParserException e) {
       throw new ParserException(e);
@@ -86,13 +86,13 @@ public MissingFieldException(String fieldName) {
    */
   private static abstract class ElementParser {
 
-    private final Uri baseUri;
+    private final String baseUri;
     private final String tag;
 
     private final ElementParser parent;
     private final List<Pair<String, Object>> normalizedAttributes;
 
-    public ElementParser(ElementParser parent, Uri baseUri, String tag) {
+    public ElementParser(ElementParser parent, String baseUri, String tag) {
       this.parent = parent;
       this.baseUri = baseUri;
       this.tag = tag;
@@ -155,7 +155,7 @@ public final Object parse(XmlPullParser xmlParser) throws XmlPullParserException
       }
     }
 
-    private ElementParser newChildParser(ElementParser parent, String name, Uri baseUri) {
+    private ElementParser newChildParser(ElementParser parent, String name, String baseUri) {
       if (TrackElementParser.TAG.equals(name)) {
         return new TrackElementParser(parent, baseUri);
       } else if (ProtectionElementParser.TAG.equals(name)) {
@@ -339,7 +339,7 @@ protected final boolean parseBoolean(XmlPullParser parser, String key, boolean d
     private ProtectionElement protectionElement;
     private List<StreamElement> streamElements;
 
-    public SmoothStreamMediaParser(ElementParser parent, Uri baseUri) {
+    public SmoothStreamMediaParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
       lookAheadCount = -1;
       protectionElement = null;
@@ -389,7 +389,7 @@ public Object build() {
     private UUID uuid;
     private byte[] initData;
 
-    public ProtectionElementParser(ElementParser parent, Uri baseUri) {
+    public ProtectionElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
     }
 
@@ -452,7 +452,7 @@ public Object build() {
     private static final String KEY_FRAGMENT_START_TIME = "t";
     private static final String KEY_FRAGMENT_REPEAT_COUNT = "r";
 
-    private final Uri baseUri;
+    private final String baseUri;
     private final List<TrackElement> tracks;
 
     private int type;
@@ -470,7 +470,7 @@ public Object build() {
 
     private long lastChunkDuration;
 
-    public StreamElementParser(ElementParser parent, Uri baseUri) {
+    public StreamElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
       this.baseUri = baseUri;
       tracks = new LinkedList<TrackElement>();
@@ -585,11 +585,7 @@ public Object build() {
     private static final String KEY_CODEC_PRIVATE_DATA = "CodecPrivateData";
     private static final String KEY_SAMPLING_RATE = "SamplingRate";
     private static final String KEY_CHANNELS = "Channels";
-    private static final String KEY_BITS_PER_SAMPLE = "BitsPerSample";
-    private static final String KEY_PACKET_SIZE = "PacketSize";
-    private static final String KEY_AUDIO_TAG = "AudioTag";
     private static final String KEY_FOUR_CC = "FourCC";
-    private static final String KEY_NAL_UNIT_LENGTH_FIELD = "NALUnitLengthField";
     private static final String KEY_TYPE = "Type";
     private static final String KEY_MAX_WIDTH = "MaxWidth";
     private static final String KEY_MAX_HEIGHT = "MaxHeight";
@@ -599,20 +595,12 @@ public Object build() {
     private int index;
     private int bitrate;
     private String mimeType;
-    private int profile;
-    private int level;
     private int maxWidth;
     private int maxHeight;
     private int samplingRate;
     private int channels;
-    private int packetSize;
-    private int audioTag;
-    private int bitPerSample;
 
-    private int nalUnitLengthField;
-    private String content;
-
-    public TrackElementParser(ElementParser parent, Uri baseUri) {
+    public TrackElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
       this.csd = new LinkedList<byte[]>();
     }
@@ -620,12 +608,10 @@ public TrackElementParser(ElementParser parent, Uri baseUri) {
     @Override
     public void parseStartTag(XmlPullParser parser) throws ParserException {
       int type = (Integer) getNormalizedAttribute(KEY_TYPE);
-      content = null;
       String value;
 
       index = parseInt(parser, KEY_INDEX, -1);
       bitrate = parseRequiredInt(parser, KEY_BITRATE);
-      nalUnitLengthField = parseInt(parser, KEY_NAL_UNIT_LENGTH_FIELD, 4);
 
       if (type == StreamElement.TYPE_VIDEO) {
         maxHeight = parseRequiredInt(parser, KEY_MAX_HEIGHT);
@@ -643,15 +629,9 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
       if (type == StreamElement.TYPE_AUDIO) {
         samplingRate = parseRequiredInt(parser, KEY_SAMPLING_RATE);
         channels = parseRequiredInt(parser, KEY_CHANNELS);
-        bitPerSample = parseRequiredInt(parser, KEY_BITS_PER_SAMPLE);
-        packetSize = parseRequiredInt(parser, KEY_PACKET_SIZE);
-        audioTag = parseRequiredInt(parser, KEY_AUDIO_TAG);
       } else {
         samplingRate = -1;
         channels = -1;
-        bitPerSample = -1;
-        packetSize = -1;
-        audioTag = -1;
       }
 
       value = parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA);
@@ -662,22 +642,12 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
           csd.add(codecPrivateData);
         } else {
           for (int i = 0; i < split.length; i++) {
-            Pair<Integer, Integer> spsParameters = CodecSpecificDataUtil.parseSpsNalUnit(split[i]);
-            if (spsParameters != null) {
-              profile = spsParameters.first;
-              level = spsParameters.second;
-            }
             csd.add(split[i]);
           }
         }
       }
     }
 
-    @Override
-    public void parseText(XmlPullParser parser) {
-      content = parser.getText();
-    }
-
     @Override
     public Object build() {
       byte[][] csdArray = null;
@@ -685,9 +655,8 @@ public Object build() {
         csdArray = new byte[csd.size()][];
         csd.toArray(csdArray);
       }
-      return new TrackElement(index, bitrate, mimeType, csdArray, profile, level, maxWidth,
-          maxHeight, samplingRate, channels, packetSize, audioTag, bitPerSample, nalUnitLengthField,
-          content);
+      return new TrackElement(index, bitrate, mimeType, csdArray, maxWidth, maxHeight, samplingRate,
+          channels);
     }
 
     private static String fourCCToMimeType(String fourCC) {
diff --git a/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java b/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java
deleted file mode 100644
index ccad721abb..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/source/DefaultSampleSource.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.source;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormatHolder;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.TrackInfo;
-import com.google.android.exoplayer.util.Assertions;
-
-import java.io.IOException;
-
-/** {@link SampleSource} that extracts sample data using a {@link SampleExtractor} */
-public final class DefaultSampleSource implements SampleSource {
-
-  private static final int TRACK_STATE_DISABLED = 0;
-  private static final int TRACK_STATE_ENABLED = 1;
-  private static final int TRACK_STATE_FORMAT_SENT = 2;
-
-  private final SampleExtractor sampleExtractor;
-
-  private TrackInfo[] trackInfos;
-  private boolean prepared;
-  private int remainingReleaseCount;
-  private int[] trackStates;
-  private boolean[] pendingDiscontinuities;
-
-  private long seekPositionUs;
-
-  /**
-   * Creates a new sample source that extracts samples using {@code sampleExtractor}. Specify the
-   * {@code downstreamRendererCount} to ensure that the sample source is released only when all
-   * downstream renderers have been released.
-   *
-   * @param sampleExtractor Sample extractor for accessing media samples.
-   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
-   */
-  public DefaultSampleSource(SampleExtractor sampleExtractor, int downstreamRendererCount) {
-    this.sampleExtractor = Assertions.checkNotNull(sampleExtractor);
-    this.remainingReleaseCount = downstreamRendererCount;
-  }
-
-  @Override
-  public boolean prepare() throws IOException {
-    if (prepared) {
-      return true;
-    }
-
-    if (sampleExtractor.prepare()) {
-      prepared = true;
-      trackInfos = sampleExtractor.getTrackInfos();
-      trackStates = new int[trackInfos.length];
-      pendingDiscontinuities = new boolean[trackInfos.length];
-    }
-
-    return prepared;
-  }
-
-  @Override
-  public int getTrackCount() {
-    Assertions.checkState(prepared);
-    return trackInfos.length;
-  }
-
-  @Override
-  public TrackInfo getTrackInfo(int track) {
-    Assertions.checkState(prepared);
-    return trackInfos[track];
-  }
-
-  @Override
-  public void enable(int track, long positionUs) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] == TRACK_STATE_DISABLED);
-    trackStates[track] = TRACK_STATE_ENABLED;
-    sampleExtractor.selectTrack(track);
-    seekToUsInternal(positionUs, positionUs != 0);
-  }
-
-  @Override
-  public void disable(int track) {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
-    sampleExtractor.deselectTrack(track);
-    pendingDiscontinuities[track] = false;
-    trackStates[track] = TRACK_STATE_DISABLED;
-  }
-
-  @Override
-  public boolean continueBuffering(long positionUs) throws IOException {
-    // Do nothing.
-    return true;
-  }
-
-  @Override
-  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
-    Assertions.checkState(prepared);
-    Assertions.checkState(trackStates[track] != TRACK_STATE_DISABLED);
-    if (pendingDiscontinuities[track]) {
-      pendingDiscontinuities[track] = false;
-      return DISCONTINUITY_READ;
-    }
-    if (onlyReadDiscontinuity) {
-      return NOTHING_READ;
-    }
-    if (trackStates[track] != TRACK_STATE_FORMAT_SENT) {
-      sampleExtractor.getTrackMediaFormat(track, formatHolder);
-      trackStates[track] = TRACK_STATE_FORMAT_SENT;
-      return FORMAT_READ;
-    }
-
-    seekPositionUs = C.UNKNOWN_TIME_US;
-    return sampleExtractor.readSample(track, sampleHolder);
-  }
-
-  @Override
-  public void seekToUs(long positionUs) {
-    Assertions.checkState(prepared);
-    seekToUsInternal(positionUs, false);
-  }
-
-  @Override
-  public long getBufferedPositionUs() {
-    Assertions.checkState(prepared);
-    return sampleExtractor.getBufferedPositionUs();
-  }
-
-  @Override
-  public void release() {
-    Assertions.checkState(remainingReleaseCount > 0);
-    if (--remainingReleaseCount == 0) {
-      sampleExtractor.release();
-    }
-  }
-
-  private void seekToUsInternal(long positionUs, boolean force) {
-    // Unless forced, avoid duplicate calls to the underlying extractor's seek method in the case
-    // that there have been no interleaving calls to readSample.
-    if (force || seekPositionUs != positionUs) {
-      seekPositionUs = positionUs;
-      sampleExtractor.seekTo(positionUs);
-      for (int i = 0; i < trackStates.length; ++i) {
-        if (trackStates[i] != TRACK_STATE_DISABLED) {
-          pendingDiscontinuities[i] = true;
-        }
-      }
-    }
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java b/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java
deleted file mode 100644
index e4ab4805c6..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/source/FrameworkSampleExtractor.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.source;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.MediaFormatHolder;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.TrackInfo;
-import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.Util;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.media.MediaExtractor;
-import android.net.Uri;
-
-import java.io.FileDescriptor;
-import java.io.IOException;
-import java.util.Map;
-import java.util.UUID;
-
-/** {@link SampleExtractor} that extracts samples from a stream using {@link MediaExtractor}. */
-// TODO: This implementation needs to be fixed so that its methods are non-blocking (either
-// through use of a background thread, or through changes to the framework's MediaExtractor API).
-@TargetApi(16)
-public final class FrameworkSampleExtractor implements SampleExtractor {
-
-  // Parameters for a Uri data source.
-  private final Context context;
-  private final Uri uri;
-  private final Map<String, String> headers;
-
-  // Parameters for a FileDescriptor data source.
-  private final FileDescriptor fileDescriptor;
-  private final long fileDescriptorOffset;
-  private final long fileDescriptorLength;
-
-  private final MediaExtractor mediaExtractor;
-
-  private TrackInfo[] trackInfos;
-
-  /**
-   * Instantiates a new sample extractor reading from the specified {@code uri}.
-   *
-   * @param context Context for resolving {@code uri}.
-   * @param uri The content URI from which to extract data.
-   * @param headers Headers to send with requests for data.
-   */
-  public FrameworkSampleExtractor(Context context, Uri uri, Map<String, String> headers) {
-    Assertions.checkState(Util.SDK_INT >= 16);
-
-    this.context = Assertions.checkNotNull(context);
-    this.uri = Assertions.checkNotNull(uri);
-    this.headers = headers;
-
-    fileDescriptor = null;
-    fileDescriptorOffset = 0;
-    fileDescriptorLength = 0;
-
-    mediaExtractor = new MediaExtractor();
-  }
-
-  /**
-   * Instantiates a new sample extractor reading from the specified seekable {@code fileDescriptor}.
-   * The caller is responsible for releasing the file descriptor.
-   *
-   * @param fileDescriptor File descriptor from which to read.
-   * @param offset The offset in bytes into the file where the data to be extracted starts.
-   * @param length The length in bytes of the data to be extracted.
-   */
-  public FrameworkSampleExtractor(FileDescriptor fileDescriptor, long offset, long length) {
-    Assertions.checkState(Util.SDK_INT >= 16);
-
-    context = null;
-    uri = null;
-    headers = null;
-
-    this.fileDescriptor = Assertions.checkNotNull(fileDescriptor);
-    fileDescriptorOffset = offset;
-    fileDescriptorLength = length;
-
-    mediaExtractor = new MediaExtractor();
-  }
-
-  @Override
-  public boolean prepare() throws IOException {
-    if (context != null) {
-      mediaExtractor.setDataSource(context, uri, headers);
-    } else {
-      mediaExtractor.setDataSource(fileDescriptor, fileDescriptorOffset, fileDescriptorLength);
-    }
-
-    int trackCount = mediaExtractor.getTrackCount();
-    trackInfos = new TrackInfo[trackCount];
-    for (int i = 0; i < trackCount; i++) {
-      android.media.MediaFormat format = mediaExtractor.getTrackFormat(i);
-      long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
-          ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
-      String mime = format.getString(android.media.MediaFormat.KEY_MIME);
-      trackInfos[i] = new TrackInfo(mime, durationUs);
-    }
-
-    return true;
-  }
-
-  @Override
-  public TrackInfo[] getTrackInfos() {
-    return trackInfos;
-  }
-
-  @Override
-  public void selectTrack(int index) {
-    mediaExtractor.selectTrack(index);
-  }
-
-  @Override
-  public void deselectTrack(int index) {
-    mediaExtractor.unselectTrack(index);
-  }
-
-  @Override
-  public long getBufferedPositionUs() {
-    long bufferedDurationUs = mediaExtractor.getCachedDuration();
-    if (bufferedDurationUs == -1) {
-      return TrackRenderer.UNKNOWN_TIME_US;
-    } else {
-      long sampleTime = mediaExtractor.getSampleTime();
-      return sampleTime == -1 ? TrackRenderer.END_OF_TRACK_US : sampleTime + bufferedDurationUs;
-    }
-  }
-
-  @Override
-  public void seekTo(long positionUs) {
-    mediaExtractor.seekTo(positionUs, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-  }
-
-  @Override
-  public void getTrackMediaFormat(int track, MediaFormatHolder mediaFormatHolder) {
-    mediaFormatHolder.format =
-        MediaFormat.createFromFrameworkMediaFormatV16(mediaExtractor.getTrackFormat(track));
-    mediaFormatHolder.drmInitData = Util.SDK_INT >= 18 ? getPsshInfoV18() : null;
-  }
-
-  @Override
-  public int readSample(int track, SampleHolder sampleHolder) {
-    int sampleTrack = mediaExtractor.getSampleTrackIndex();
-    if (sampleTrack != track) {
-      return sampleTrack < 0 ? SampleSource.END_OF_STREAM : SampleSource.NOTHING_READ;
-    }
-
-    if (sampleHolder.data != null) {
-      int offset = sampleHolder.data.position();
-      sampleHolder.size = mediaExtractor.readSampleData(sampleHolder.data, offset);
-      sampleHolder.data.position(offset + sampleHolder.size);
-    } else {
-      sampleHolder.size = 0;
-    }
-    sampleHolder.timeUs = mediaExtractor.getSampleTime();
-    sampleHolder.flags = mediaExtractor.getSampleFlags();
-    if ((sampleHolder.flags & MediaExtractor.SAMPLE_FLAG_ENCRYPTED) != 0) {
-      sampleHolder.cryptoInfo.setFromExtractorV16(mediaExtractor);
-    }
-
-    mediaExtractor.advance();
-
-    return SampleSource.SAMPLE_READ;
-  }
-
-  @Override
-  public void release() {
-    mediaExtractor.release();
-  }
-
-  @TargetApi(18)
-  private Map<UUID, byte[]> getPsshInfoV18() {
-    Map<UUID, byte[]> psshInfo = mediaExtractor.getPsshInfo();
-    return (psshInfo == null || psshInfo.isEmpty()) ? null : psshInfo;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java b/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java
deleted file mode 100644
index 383aa80ce2..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/source/SampleExtractor.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.source;
-
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.MediaFormatHolder;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.TrackInfo;
-import com.google.android.exoplayer.TrackRenderer;
-
-import java.io.IOException;
-
-/**
- * Extractor for reading track metadata and samples stored in tracks.
- *
- * <p>Call {@link #prepare} until it returns {@code true}, then access track metadata via
- * {@link #getTrackInfos} and {@link #getTrackMediaFormat}.
- *
- * <p>Pass indices of tracks to read from to {@link #selectTrack}. A track can later be deselected
- * by calling {@link #deselectTrack}. It is safe to select/deselect tracks after reading sample
- * data or seeking. Initially, all tracks are deselected.
- *
- * <p>Call {@link #release()} when the extractor is no longer needed to free resources.
- */
-public interface SampleExtractor {
-
-  /**
-   * Prepares the extractor for reading track metadata and samples.
-   *
-   * @return Whether the source is ready; if {@code false}, {@link #prepare()} must be called again.
-   * @throws IOException Thrown if the source can't be read.
-   */
-  boolean prepare() throws IOException;
-
-  /** Returns track information about all tracks that can be selected. */
-  TrackInfo[] getTrackInfos();
-
-  /** Selects the track at {@code index} for reading sample data. */
-  void selectTrack(int index);
-
-  /** Deselects the track at {@code index}, so no more samples will be read from that track. */
-  void deselectTrack(int index);
-
-  /**
-   * Returns an estimate of the position up to which data is buffered.
-   *
-   * <p>This method should not be called until after the extractor has been successfully prepared.
-   *
-   * @return An estimate of the absolute position in microseconds up to which data is buffered,
-   *     or {@link TrackRenderer#END_OF_TRACK_US} if data is buffered to the end of the stream, or
-   *     {@link TrackRenderer#UNKNOWN_TIME_US} if no estimate is available.
-   */
-  long getBufferedPositionUs();
-
-  /**
-   * Seeks to the specified time in microseconds.
-   *
-   * <p>This method should not be called until after the extractor has been successfully prepared.
-   *
-   * @param positionUs The seek position in microseconds.
-   */
-  void seekTo(long positionUs);
-
-  /** Stores the {@link MediaFormat} of {@code track}. */
-  void getTrackMediaFormat(int track, MediaFormatHolder mediaFormatHolder);
-
-  /**
-   * Reads the next sample in the track at index {@code track} into {@code sampleHolder}, returning
-   * {@link SampleSource#SAMPLE_READ} if it is available.
-   *
-   * <p>Advances to the next sample if a sample was read.
-   *
-   * @param track The index of the track from which to read a sample.
-   * @param sampleHolder The holder for read sample data, if {@link SampleSource#SAMPLE_READ} is
-   *     returned.
-   * @return {@link SampleSource#SAMPLE_READ} if a sample was read into {@code sampleHolder}, or
-   *     {@link SampleSource#END_OF_STREAM} if the last samples in all tracks have been read, or
-   *     {@link SampleSource#NOTHING_READ} if the sample cannot be read immediately as it is not
-   *     loaded.
-   * @throws IOException Thrown if the source can't be read.
-   */
-  int readSample(int track, SampleHolder sampleHolder) throws IOException;
-
-  /** Releases resources associated with this extractor. */
-  void release();
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index e2452102d1..3827e88a26 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -80,9 +80,9 @@ public TextTrackRenderer(SampleSource source, TextRenderer textRenderer,
   }
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     try {
-      boolean sourcePrepared = source.prepare();
+      boolean sourcePrepared = source.prepare(positionUs);
       if (!sourcePrepared) {
         return TrackRenderer.STATE_UNPREPARED;
       }
@@ -179,7 +179,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
         SampleHolder sampleHolder = parserHelper.getSampleHolder();
         sampleHolder.clearData();
         int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
-        if (result == SampleSource.SAMPLE_READ && !sampleHolder.decodeOnly) {
+        if (result == SampleSource.SAMPLE_READ) {
           parserHelper.startParseOperation();
           textRendererNeedsUpdate = false;
         } else if (result == SampleSource.END_OF_STREAM) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
index c784f50cd9..0fd1b1fcb6 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
@@ -57,6 +57,8 @@
   public static final byte CARRIAGE_RETURN = 0x2D;
   public static final byte ERASE_NON_DISPLAYED_MEMORY = 0x2E;
 
+  public static final byte BACKSPACE = 0x21;
+
 
   public static final byte MID_ROW_CHAN_1 = 0x11;
   public static final byte MID_ROW_CHAN_2 = 0x19;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
index dd34e504cc..4beede6eed 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
@@ -82,6 +82,26 @@
     0xFB     // 3F: 251 'û' "Latin small letter U with circumflex"
   };
 
+  // Extended Spanish/Miscellaneous and French char set.
+  private static final int[] SPECIAL_ES_FR_CHARACTER_SET = new int[] {
+    // Spanish and misc.
+    0xC1, 0xC9, 0xD3, 0xDA, 0xDC, 0xFC, 0x2018, 0xA1,
+    0x2A, 0x27, 0x2014, 0xA9, 0x2120, 0x2022, 0x201C, 0x201D,
+    // French.
+    0xC0, 0xC2, 0xC7, 0xC8, 0xCA, 0xCB, 0xEB, 0xCE,
+    0xCF, 0xEF, 0xD4, 0xD9, 0xF9, 0xDB, 0xAB, 0xBB
+  };
+
+  //Extended Portuguese and German/Danish char set.
+  private static final int[] SPECIAL_PT_DE_CHARACTER_SET = new int[] {
+    // Portuguese.
+    0xC3, 0xE3, 0xCD, 0xCC, 0xEC, 0xD2, 0xF2, 0xD5,
+    0xF5, 0x7B, 0x7D, 0x5C, 0x5E, 0x5F, 0x7C, 0x7E,
+    // German/Danish.
+    0xC4, 0xE4, 0xD6, 0xF6, 0xDF, 0xA5, 0xA4, 0x2502,
+    0xC5, 0xE5, 0xD8, 0xF8, 0x250C, 0x2510, 0x2514, 0x2518
+  };
+
   private final ParsableBitArray seiBuffer;
   private final StringBuilder stringBuilder;
   private final ArrayList<ClosedCaption> captions;
@@ -134,31 +154,45 @@
       }
 
       // Special North American character set.
-      if ((ccData1 == 0x11) && ((ccData2 & 0x70) == 0x30)) {
+      // ccData2 - P|0|1|1|X|X|X|X
+      if ((ccData1 == 0x11 || ccData1 == 0x19)
+          && ((ccData2 & 0x70) == 0x30)) {
         stringBuilder.append(getSpecialChar(ccData2));
         continue;
       }
 
+      // Extended Spanish/Miscellaneous and French character set.
+      // ccData2 - P|0|1|X|X|X|X|X
+      if ((ccData1 == 0x12 || ccData1 == 0x1A)
+          && ((ccData2 & 0x60) == 0x20)) {
+        backspace(); // Remove standard equivalent of the special extended char.
+        stringBuilder.append(getExtendedEsFrChar(ccData2));
+        continue;
+      }
+
+      // Extended Portuguese and German/Danish character set.
+      // ccData2 - P|0|1|X|X|X|X|X
+      if ((ccData1 == 0x13 || ccData1 == 0x1B)
+          && ((ccData2 & 0x60) == 0x20)) {
+        backspace(); // Remove standard equivalent of the special extended char.
+        stringBuilder.append(getExtendedPtDeChar(ccData2));
+        continue;
+      }
+
       // Control character.
       if (ccData1 < 0x20) {
-        if (stringBuilder.length() > 0) {
-          captions.add(new ClosedCaptionText(stringBuilder.toString()));
-          stringBuilder.setLength(0);
-        }
-        captions.add(new ClosedCaptionCtrl(ccData1, ccData2));
+        addCtrl(ccData1, ccData2);
         continue;
       }
 
       // Basic North American character set.
       stringBuilder.append(getChar(ccData1));
-      if (ccData2 != 0) {
+      if (ccData2 >= 0x20) {
         stringBuilder.append(getChar(ccData2));
       }
     }
 
-    if (stringBuilder.length() > 0) {
-      captions.add(new ClosedCaptionText(stringBuilder.toString()));
-    }
+    addBufferedText();
 
     if (captions.isEmpty()) {
       return null;
@@ -166,7 +200,7 @@
 
     ClosedCaption[] captionArray = new ClosedCaption[captions.size()];
     captions.toArray(captionArray);
-    return new ClosedCaptionList(sampleHolder.timeUs, sampleHolder.decodeOnly, captionArray);
+    return new ClosedCaptionList(sampleHolder.timeUs, sampleHolder.isDecodeOnly(), captionArray);
   }
 
   private static char getChar(byte ccData) {
@@ -179,6 +213,32 @@ private static char getSpecialChar(byte ccData) {
     return (char) SPECIAL_CHARACTER_SET[index];
   }
 
+  private static char getExtendedEsFrChar(byte ccData) {
+    int index = ccData & 0x1F;
+    return (char) SPECIAL_ES_FR_CHARACTER_SET[index];
+  }
+
+  private static char getExtendedPtDeChar(byte ccData) {
+    int index = ccData & 0x1F;
+    return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
+  }
+
+  private void addBufferedText() {
+    if (stringBuilder.length() > 0) {
+      captions.add(new ClosedCaptionText(stringBuilder.toString()));
+      stringBuilder.setLength(0);
+    }
+  }
+
+  private void addCtrl(byte ccData1, byte ccData2) {
+    addBufferedText();
+    captions.add(new ClosedCaptionCtrl(ccData1, ccData2));
+  }
+
+  private void backspace() {
+    addCtrl((byte) 0x14, ClosedCaptionCtrl.BACKSPACE);
+  }
+
   /**
    * Inspects an sei message to determine whether it contains EIA-608.
    * <p>
@@ -189,7 +249,7 @@ private static char getSpecialChar(byte ccData) {
    * @param payload A {@link ParsableByteArray} containing the payload.
    * @return True if the sei message contains EIA-608. False otherwise.
    */
-  public static boolean inspectSeiMessage(int payloadType, int payloadLength,
+  public static boolean isSeiMessageEia608(int payloadType, int payloadLength,
       ParsableByteArray payload) {
     if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
       return false;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
index 8e855bf730..48438ce1b4 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -90,9 +90,9 @@ public Eia608TrackRenderer(SampleSource source, TextRenderer textRenderer,
   }
 
   @Override
-  protected int doPrepare() throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
     try {
-      boolean sourcePrepared = source.prepare();
+      boolean sourcePrepared = source.prepare(positionUs);
       if (!sourcePrepared) {
         return TrackRenderer.STATE_UNPREPARED;
       }
@@ -317,6 +317,11 @@ private void handleMiscCode(ClosedCaptionCtrl captionCtrl) {
       case ClosedCaptionCtrl.CARRIAGE_RETURN:
         maybeAppendNewline();
         return;
+      case ClosedCaptionCtrl.BACKSPACE:
+        if (captionStringBuilder.length() > 0) {
+          captionStringBuilder.setLength(captionStringBuilder.length() - 1);
+        }
+        return;
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index 758a0e9b38..46fd26cd01 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -232,8 +232,8 @@ private static boolean isSupportedTag(String tag) {
    * <a href="http://www.w3.org/TR/ttaf1-dfxp/#timing-value-timeExpression">timeExpression</a>
    *
    * @param time A string that includes the time expression.
-   * @param frameRate The framerate of the stream.
-   * @param subframeRate The sub-framerate of the stream
+   * @param frameRate The frame rate of the stream.
+   * @param subframeRate The sub-frame rate of the stream
    * @param tickRate The tick rate of the stream.
    * @return The parsed timestamp in microseconds.
    * @throws ParserException If the given string does not contain a valid time expression.
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
index 938dd70ef1..2115e5b0bc 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
@@ -34,20 +34,24 @@
 /**
  * A {@link DataSource} that decrypts the data read from an upstream source, encrypted with AES-128
  * with a 128-bit key and PKCS7 padding.
- *
  */
 public class Aes128DataSource implements DataSource {
 
   private final DataSource upstream;
-  private final byte[] secretKey;
-  private final byte[] iv;
+  private final byte[] encryptionKey;
+  private final byte[] encryptionIv;
 
   private CipherInputStream cipherInputStream;
 
-  public Aes128DataSource(byte[] secretKey, byte[] iv, DataSource upstream) {
+  /**
+   * @param upstream The upstream {@link DataSource}.
+   * @param encryptionKey The encryption key.
+   * @param encryptionIv The encryption initialization vector.
+   */
+  public Aes128DataSource(DataSource upstream, byte[] encryptionKey, byte[] encryptionIv) {
     this.upstream = upstream;
-    this.secretKey = secretKey;
-    this.iv = iv;
+    this.encryptionKey = encryptionKey;
+    this.encryptionIv = encryptionIv;
   }
 
   @Override
@@ -61,8 +65,8 @@ public long open(DataSpec dataSpec) throws IOException {
       throw new RuntimeException(e);
     }
 
-    Key cipherKey = new SecretKeySpec(secretKey, "AES");
-    AlgorithmParameterSpec cipherIV = new IvParameterSpec(iv);
+    Key cipherKey = new SecretKeySpec(encryptionKey, "AES");
+    AlgorithmParameterSpec cipherIV = new IvParameterSpec(encryptionIv);
 
     try {
       cipher.init(Cipher.DECRYPT_MODE, cipherKey, cipherIV);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Allocation.java b/library/src/main/java/com/google/android/exoplayer/upstream/Allocation.java
index b3fb38921a..22de92dc13 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Allocation.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Allocation.java
@@ -16,62 +16,38 @@
 package com.google.android.exoplayer.upstream;
 
 /**
- * An {@link Allocation}, defined to consist of a set of fragments of underlying byte arrays.
+ * An allocation within a byte array.
  * <p>
- * The byte arrays in which the fragments are located are obtained by {@link #getBuffers}. For
- * each, the offset and length of the fragment within the byte array are obtained using
- * {@link #getFragmentOffset} and {@link #getFragmentLength} respectively.
+ * The allocation's length is obtained by calling {@link Allocator#getIndividualAllocationLength()}
+ * on the {@link Allocator} from which it was obtained.
  */
-public interface Allocation {
+public final class Allocation {
 
   /**
-   * Ensures the allocation has a capacity greater than or equal to the specified size in bytes.
-   * <p>
-   * If {@code size} is greater than the current capacity of the allocation, then it will grow
-   * to have a capacity of at least {@code size}. The allocation is grown by adding new fragments.
-   * Existing fragments remain unchanged, and any data that has been written to them will be
-   * preserved.
-   * <p>
-   * If {@code size} is less than or equal to the capacity of the allocation, then the call is a
-   * no-op.
-   *
-   * @param size The minimum required capacity, in bytes.
-   */
-  public void ensureCapacity(int size);
-
-  /**
-   * Gets the capacity of the allocation, in bytes.
-   *
-   * @return The capacity of the allocation, in bytes.
+   * The array containing the allocated space. The allocated space may not be at the start of the
+   * array, and so {@link #translateOffset(int)} method must be used when indexing into it.
    */
-  public int capacity();
+  public final byte[] data;
 
-  /**
-   * Gets the buffers in which the fragments are allocated.
-   *
-   * @return The buffers in which the fragments are allocated.
-   */
-  public byte[][] getBuffers();
+  private final int offset;
 
   /**
-   * The offset of the fragment in the buffer at the specified index.
-   *
-   * @param index The index of the buffer.
-   * @return The offset of the fragment in the buffer.
+   * @param data The array containing the allocated space.
+   * @param offset The offset of the allocated space within the array.
    */
-  public int getFragmentOffset(int index);
+  public Allocation(byte[] data, int offset) {
+    this.data = data;
+    this.offset = offset;
+  }
 
   /**
-   * The length of the fragment in the buffer at the specified index.
+   * Translates a zero-based offset into the allocation to the corresponding {@link #data} offset.
    *
-   * @param index The index of the buffer.
-   * @return The length of the fragment in the buffer.
-   */
-  public int getFragmentLength(int index);
-
-  /**
-   * Releases the allocation.
+   * @param offset The zero-based offset to translate.
+   * @return The corresponding offset in {@link #data}.
    */
-  public void release();
+  public int translateOffset(int offset) {
+    return this.offset + offset;
+  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
index 9d07265cfc..b51217f591 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
@@ -16,32 +16,43 @@
 package com.google.android.exoplayer.upstream;
 
 /**
- * A source of {@link Allocation}s.
+ * A source of allocations.
  */
 public interface Allocator {
 
   /**
-   * Obtains an allocation of at least the specified size.
+   * Obtain an {@link Allocation}.
+   * <p>
+   * When the caller has finished with the {@link Allocation}, it should be returned by calling
+   * {@link #release(Allocation)}.
    *
-   * @param size The size of the required allocation, in bytes.
-   * @return The allocation.
+   * @return The {@link Allocation}.
    */
-  public Allocation allocate(int size);
+  Allocation allocate();
+
+  /**
+   * Return an {@link Allocation}.
+   *
+   * @param allocation The {@link Allocation} being returned.
+   */
+  void release(Allocation allocation);
 
   /**
    * Hints to the {@link Allocator} that it should make a best effort to release any memory that it
-   * has allocated for the purpose of backing {@link Allocation}s, beyond the specified target
-   * number of bytes.
+   * has allocated, beyond the specified target number of bytes.
    *
    * @param targetSize The target size in bytes.
    */
-  public void trim(int targetSize);
+  void trim(int targetSize);
 
   /**
-   * Returns the number of bytes currently allocated in the form of {@link Allocation}s.
-   *
-   * @return The number of allocated bytes.
+   * Returns the total number of bytes currently allocated.
+   */
+  int getTotalBytesAllocated();
+
+  /**
+   * Returns the length of each individual {@link Allocation}.
    */
-  public int getAllocatedSize();
+  int getIndividualAllocationLength();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java
new file mode 100644
index 0000000000..77bff359e1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.C;
+
+import android.content.res.AssetManager;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A local asset {@link DataSource}.
+ */
+public final class AssetDataSource implements DataSource {
+
+  /**
+   * Thrown when IOException is encountered during local asset read operation.
+   */
+  public static class AssetDataSourceException extends IOException {
+
+    public AssetDataSourceException(IOException cause) {
+      super(cause);
+    }
+
+  }
+
+  private final AssetManager assetManager;
+  private final TransferListener listener;
+
+  private InputStream assetInputStream;
+  private long bytesRemaining;
+  private boolean opened;
+
+  /**
+   * Constructs a new {@link DataSource} that retrieves data from a local asset.
+   */
+  public AssetDataSource(AssetManager assetManager) {
+    this(assetManager, null);
+  }
+
+  /**
+   * Constructs a new {@link DataSource} that retrieves data from a local asset.
+   *
+   * @param listener An optional listener. Specify {@code null} for no listener.
+   */
+  public AssetDataSource(AssetManager assetManager, TransferListener listener) {
+    this.assetManager = assetManager;
+    this.listener = listener;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws AssetDataSourceException {
+    try {
+      // Lose the '/' prefix in the path or else AssetManager won't find our file
+      assetInputStream = assetManager.open(dataSpec.uri.getPath().substring(1),
+          AssetManager.ACCESS_RANDOM);
+      assetInputStream.skip(dataSpec.position);
+      bytesRemaining = dataSpec.length == C.LENGTH_UNBOUNDED ? assetInputStream.available()
+          : dataSpec.length;
+      if (bytesRemaining < 0) {
+        throw new EOFException();
+      }
+    } catch (IOException e) {
+      throw new AssetDataSourceException(e);
+    }
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart();
+    }
+    return bytesRemaining;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws AssetDataSourceException {
+    if (bytesRemaining == 0) {
+      return -1;
+    } else {
+      int bytesRead = 0;
+      try {
+        bytesRead = assetInputStream.read(buffer, offset,
+            (int) Math.min(bytesRemaining, readLength));
+      } catch (IOException e) {
+        throw new AssetDataSourceException(e);
+      }
+
+      if (bytesRead > 0) {
+        bytesRemaining -= bytesRead;
+        if (listener != null) {
+          listener.onBytesTransferred(bytesRead);
+        }
+      }
+
+      return bytesRead;
+    }
+  }
+
+  @Override
+  public void close() throws AssetDataSourceException {
+    if (assetInputStream != null) {
+      try {
+        assetInputStream.close();
+      } catch (IOException e) {
+        throw new AssetDataSourceException(e);
+      } finally {
+        assetInputStream = null;
+        if (opened) {
+          opened = false;
+          if (listener != null) {
+            listener.onTransferEnd();
+          }
+        }
+      }
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/BandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer/upstream/BandwidthMeter.java
index 5bbffb6c1f..f8f7eb24af 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/BandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/BandwidthMeter.java
@@ -18,7 +18,24 @@
 /**
  * Provides estimates of the currently available bandwidth.
  */
-public interface BandwidthMeter {
+public interface BandwidthMeter extends TransferListener {
+
+  /**
+   * Interface definition for a callback to be notified of {@link BandwidthMeter} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked periodically to indicate that bytes have been transferred.
+     *
+     * @param elapsedMs The time taken to transfer the bytes, in milliseconds.
+     * @param bytes The number of bytes transferred.
+     * @param bitrate The estimated bitrate in bits/sec, or {@link #NO_ESTIMATE} if no estimate
+     *     is available. Note that this estimate is typically derived from more information than
+     *     {@code bytes} and {@code elapsedMs}.
+     */
+    void onBandwidthSample(int elapsedMs, long bytes, long bitrate);
+  }
 
   /**
    * Indicates no bandwidth estimate is available.
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java b/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java
deleted file mode 100644
index af2ce03a20..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/upstream/BufferPool.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.upstream;
-
-import com.google.android.exoplayer.util.Assertions;
-
-import java.util.Arrays;
-
-/**
- * An {@link Allocator} that maintains a pool of fixed length byte arrays (buffers).
- * <p>
- * An {@link Allocation} obtained from a {@link BufferPool} consists of the whole number of these
- * buffers. When an {@link Allocation} is released, the underlying buffers are returned to the pool
- * for re-use.
- */
-public final class BufferPool implements Allocator {
-
-  private static final int INITIAL_RECYCLED_BUFFERS_CAPACITY = 100;
-
-  /**
-   * The length in bytes of each individual buffer in the pool.
-   */
-  public final int bufferLength;
-
-  private int allocatedBufferCount;
-  private int recycledBufferCount;
-  private byte[][] recycledBuffers;
-
-  /**
-   * Constructs an empty pool.
-   *
-   * @param bufferLength The length of each buffer in the pool.
-   */
-  public BufferPool(int bufferLength) {
-    Assertions.checkArgument(bufferLength > 0);
-    this.bufferLength = bufferLength;
-    this.recycledBuffers = new byte[INITIAL_RECYCLED_BUFFERS_CAPACITY][];
-  }
-
-  @Override
-  public synchronized int getAllocatedSize() {
-    return allocatedBufferCount * bufferLength;
-  }
-
-  @Override
-  public synchronized void trim(int targetSize) {
-    int targetBufferCount = (targetSize + bufferLength - 1) / bufferLength;
-    int targetRecycledBufferCount = Math.max(0, targetBufferCount - allocatedBufferCount);
-    if (targetRecycledBufferCount < recycledBufferCount) {
-      Arrays.fill(recycledBuffers, targetRecycledBufferCount, recycledBufferCount, null);
-      recycledBufferCount = targetRecycledBufferCount;
-    }
-  }
-
-  @Override
-  public synchronized Allocation allocate(int size) {
-    return new AllocationImpl(allocate(size, null));
-  }
-
-  /**
-   * Allocates byte arrays whose combined length is at least {@code size}.
-   * <p>
-   * An existing array of byte arrays may be provided to form the start of the allocation.
-   *
-   * @param size The total size required, in bytes.
-   * @param existing Existing byte arrays to use as the start of the allocation. May be null.
-   * @return The allocated byte arrays.
-   */
-  /* package */ synchronized byte[][] allocate(int size, byte[][] existing) {
-    int requiredBufferCount = requiredBufferCount(size);
-    if (existing != null && requiredBufferCount <= existing.length) {
-      // The existing buffers are sufficient.
-      return existing;
-    }
-    // We need to allocate additional buffers.
-    byte[][] buffers = new byte[requiredBufferCount][];
-    int firstNewBufferIndex = 0;
-    if (existing != null) {
-      firstNewBufferIndex = existing.length;
-      System.arraycopy(existing, 0, buffers, 0, firstNewBufferIndex);
-    }
-    // Allocate the new buffers
-    allocatedBufferCount += requiredBufferCount - firstNewBufferIndex;
-    for (int i = firstNewBufferIndex; i < requiredBufferCount; i++) {
-      // Use a recycled buffer if one is available. Else instantiate a new one.
-      buffers[i] = nextBuffer();
-    }
-    return buffers;
-  }
-
-  /**
-   * Obtain a single buffer directly from the pool.
-   * <p>
-   * When the caller has finished with the buffer, it should be returned to the pool by calling
-   * {@link #releaseDirect(byte[])}.
-   *
-   * @return The allocated buffer.
-   */
-  public synchronized byte[] allocateDirect() {
-    allocatedBufferCount++;
-    return nextBuffer();
-  }
-
-  /**
-   * Return a single buffer to the pool.
-   *
-   * @param buffer The buffer being returned.
-   */
-  public synchronized void releaseDirect(byte[] buffer) {
-    // Weak sanity check that the buffer probably originated from this pool.
-    Assertions.checkArgument(buffer.length == bufferLength);
-    allocatedBufferCount--;
-
-    ensureRecycledBufferCapacity(recycledBufferCount + 1);
-    recycledBuffers[recycledBufferCount++] = buffer;
-  }
-
-  /**
-   * Returns the buffers belonging to an allocation to the pool.
-   *
-   * @param allocation The allocation to return.
-   */
-  /* package */ synchronized void release(AllocationImpl allocation) {
-    byte[][] buffers = allocation.getBuffers();
-    allocatedBufferCount -= buffers.length;
-
-    int newRecycledBufferCount = recycledBufferCount + buffers.length;
-    ensureRecycledBufferCapacity(newRecycledBufferCount);
-    System.arraycopy(buffers, 0, recycledBuffers, recycledBufferCount, buffers.length);
-    recycledBufferCount = newRecycledBufferCount;
-  }
-
-  private int requiredBufferCount(long size) {
-    return (int) ((size + bufferLength - 1) / bufferLength);
-  }
-
-  private byte[] nextBuffer() {
-    return recycledBufferCount > 0 ? recycledBuffers[--recycledBufferCount]
-        : new byte[bufferLength];
-  }
-
-  private void ensureRecycledBufferCapacity(int requiredCapacity) {
-    if (recycledBuffers.length < requiredCapacity) {
-      // Expand the capacity of the recycled buffers array.
-      byte[][] newRecycledBuffers = new byte[requiredCapacity * 2][];
-      if (recycledBufferCount > 0) {
-        System.arraycopy(recycledBuffers, 0, newRecycledBuffers, 0, recycledBufferCount);
-      }
-      recycledBuffers = newRecycledBuffers;
-    }
-  }
-
-  private class AllocationImpl implements Allocation {
-
-    private byte[][] buffers;
-
-    public AllocationImpl(byte[][] buffers) {
-      this.buffers = buffers;
-    }
-
-    @Override
-    public void ensureCapacity(int size) {
-      buffers = allocate(size, buffers);
-    }
-
-    @Override
-    public int capacity() {
-      return bufferLength * buffers.length;
-    }
-
-    @Override
-    public byte[][] getBuffers() {
-      return buffers;
-    }
-
-    @Override
-    public int getFragmentOffset(int index) {
-      return 0;
-    }
-
-    @Override
-    public int getFragmentLength(int index) {
-      return bufferLength;
-    }
-
-    @Override
-    public void release() {
-      if (buffers != null) {
-        BufferPool.this.release(this);
-        buffers = null;
-      }
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayNonBlockingInputStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayNonBlockingInputStream.java
deleted file mode 100644
index b73a21a4bd..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayNonBlockingInputStream.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.upstream;
-
-import com.google.android.exoplayer.util.Assertions;
-
-import java.nio.ByteBuffer;
-
-/**
- * An implementation of {@link NonBlockingInputStream} for reading data from a byte array.
- */
-public final class ByteArrayNonBlockingInputStream implements NonBlockingInputStream {
-
-  private final byte[] data;
-
-  private int position;
-
-  public ByteArrayNonBlockingInputStream(byte[] data) {
-    this.data = Assertions.checkNotNull(data);
-  }
-
-  @Override
-  public int skip(int length) {
-    int skipLength = getReadLength(length);
-    position += skipLength;
-    return skipLength;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int length) {
-    if (isEndOfStream()) {
-      return -1;
-    }
-    int readLength = getReadLength(length);
-    System.arraycopy(data, position, buffer, offset, readLength);
-    position += readLength;
-    return readLength;
-  }
-
-  @Override
-  public int read(ByteBuffer buffer, int length) {
-    if (isEndOfStream()) {
-      return -1;
-    }
-    int readLength = getReadLength(length);
-    buffer.put(data, position, readLength);
-    position += readLength;
-    return readLength;
-  }
-
-  @Override
-  public long getAvailableByteCount() {
-    return data.length - position;
-  }
-
-  @Override
-  public boolean isEndOfStream() {
-    return position == data.length;
-  }
-
-  @Override
-  public void close() {
-    // Do nothing.
-  }
-
-  private int getReadLength(int requestedLength) {
-    return Math.min(requestedLength, data.length - position);
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSource.java
index 624e42a111..002fda19ea 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSource.java
@@ -41,7 +41,7 @@
    *     unresolved. For all other requests, the value returned will be equal to the request's
    *     {@link DataSpec#length}.
    */
-  public long open(DataSpec dataSpec) throws IOException;
+  long open(DataSpec dataSpec) throws IOException;
 
   /**
    * Closes the {@link DataSource}.
@@ -51,19 +51,22 @@
    *
    * @throws IOException If an error occurs closing the source.
    */
-  public void close() throws IOException;
+  void close() throws IOException;
 
   /**
    * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
-   * index {@code offset}. This method blocks until at least one byte of data can be read, the end
-   * of the opened range is detected, or an exception is thrown.
+   * index {@code offset}.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the opened range is
+   * detected, or an exception is thrown.
    *
    * @param buffer The buffer into which the read data should be stored.
    * @param offset The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
-   * @return The actual number of bytes read, or -1 if the end of the opened range is reached.
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
+   *     range is reached.
    * @throws IOException If an error occurs reading from the source.
    */
-  public int read(byte[] buffer, int offset, int readLength) throws IOException;
+  int read(byte[] buffer, int offset, int readLength) throws IOException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
index e0a01f3a9a..75bcf72b88 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
@@ -43,9 +43,25 @@ public DataSourceInputStream(DataSource dataSource, DataSpec dataSpec) {
     singleByteArray = new byte[1];
   }
 
+  /**
+   * Optional call to open the underlying {@link DataSource}.
+   * <p>
+   * Calling this method does nothing if the {@link DataSource} is already open. Calling this
+   * method is optional, since the read and skip methods will automatically open the underlying
+   * {@link DataSource} if it's not open already.
+   *
+   * @throws IOException If an error occurs opening the {@link DataSource}.
+   */
+  public void open() throws IOException {
+    checkOpened();
+  }
+
   @Override
   public int read() throws IOException {
-    read(singleByteArray);
+    int length = read(singleByteArray);
+    if (length == -1) {
+      return -1;
+    }
     return singleByteArray[0] & 0xFF;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceStream.java
deleted file mode 100644
index 5c4dcd65b2..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceStream.java
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.upstream;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.upstream.Loader.Loadable;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.Util;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * Loads data from a {@link DataSource} into an in-memory {@link Allocation}. The loaded data
- * can be consumed by treating the instance as a non-blocking {@link NonBlockingInputStream}.
- */
-public final class DataSourceStream implements Loadable, NonBlockingInputStream {
-
-  /**
-   * Thrown when an error is encountered trying to load data into a {@link DataSourceStream}.
-   */
-  public static class DataSourceStreamLoadException extends IOException {
-
-    public DataSourceStreamLoadException(IOException cause) {
-      super(cause);
-    }
-
-  }
-
-  private static final int CHUNKED_ALLOCATION_INCREMENT = 256 * 1024;
-
-  private final DataSource dataSource;
-  private final DataSpec dataSpec;
-  private final Allocator allocator;
-  private final ReadHead readHead;
-
-  private Allocation allocation;
-
-  private volatile boolean loadCanceled;
-  private volatile long loadPosition;
-  private volatile long resolvedLength;
-
-  private int writeFragmentIndex;
-  private int writeFragmentOffset;
-  private int writeFragmentRemainingLength;
-
-  /**
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded. {@code dataSpec.length} must not exceed
-   *     {@link Integer#MAX_VALUE}. If {@code dataSpec.length == C.LENGTH_UNBOUNDED} then
-   *     the length resolved by {@code dataSource.open(dataSpec)} must not exceed
-   *     {@link Integer#MAX_VALUE}.
-   * @param allocator Used to obtain an {@link Allocation} for holding the data.
-   */
-  public DataSourceStream(DataSource dataSource, DataSpec dataSpec, Allocator allocator) {
-    Assertions.checkState(dataSpec.length <= Integer.MAX_VALUE);
-    this.dataSource = dataSource;
-    this.dataSpec = dataSpec;
-    this.allocator = allocator;
-    resolvedLength = C.LENGTH_UNBOUNDED;
-    readHead = new ReadHead();
-  }
-
-  /**
-   * Resets the read position to the start of the data.
-   */
-  public void resetReadPosition() {
-    readHead.reset();
-  }
-
-  /**
-   * Returns the current read position for data being read out of the source.
-   *
-   * @return The current read position.
-   */
-  public long getReadPosition() {
-    return readHead.position;
-  }
-
-  /**
-   * Returns the number of bytes of data that have been loaded.
-   *
-   * @return The number of bytes of data that have been loaded.
-   */
-  public long getLoadPosition() {
-    return loadPosition;
-  }
-
-  /**
-   * Returns the length of the stream in bytes, or {@value C#LENGTH_UNBOUNDED} if the length has
-   * yet to be determined.
-   *
-   * @return The length of the stream in bytes, or {@value C#LENGTH_UNBOUNDED} if the length has
-   *     yet to be determined.
-   */
-  public long getLength() {
-    return resolvedLength != C.LENGTH_UNBOUNDED ? resolvedLength : dataSpec.length;
-  }
-
-  /**
-   * Whether the stream has finished loading.
-   *
-   * @return True if the stream has finished loading. False otherwise.
-   */
-  public boolean isLoadFinished() {
-    return resolvedLength != C.LENGTH_UNBOUNDED && loadPosition == resolvedLength;
-  }
-
-  // {@link NonBlockingInputStream} implementation.
-
-  @Override
-  public long getAvailableByteCount() {
-    return loadPosition - readHead.position;
-  }
-
-  @Override
-  public boolean isEndOfStream() {
-    return resolvedLength != C.LENGTH_UNBOUNDED && readHead.position == resolvedLength;
-  }
-
-  @Override
-  public void close() {
-    if (allocation != null) {
-      allocation.release();
-      allocation = null;
-    }
-  }
-
-  @Override
-  public int skip(int skipLength) {
-    return read(null, null, 0, readHead, skipLength);
-  }
-
-  @Override
-  public int read(ByteBuffer target1, int readLength) {
-    return read(target1, null, 0, readHead, readLength);
-  }
-
-  @Override
-  public int read(byte[] target, int offset, int readLength) {
-    return read(null, target, offset, readHead, readLength);
-  }
-
-  /**
-   * Reads data to either a target {@link ByteBuffer}, or to a target byte array at a specified
-   * offset. The {@code readHead} is updated to reflect the read that was performed.
-   */
-  private int read(ByteBuffer target, byte[] targetArray, int targetArrayOffset,
-      ReadHead readHead, int readLength) {
-    if (isEndOfStream()) {
-      return -1;
-    }
-    int bytesToRead = (int) Math.min(loadPosition - readHead.position, readLength);
-    if (bytesToRead == 0) {
-      return 0;
-    }
-    if (readHead.position == 0) {
-      readHead.fragmentIndex = 0;
-      readHead.fragmentOffset = allocation.getFragmentOffset(0);
-      readHead.fragmentRemaining = allocation.getFragmentLength(0);
-    }
-    int bytesRead = 0;
-    byte[][] buffers = allocation.getBuffers();
-    while (bytesRead < bytesToRead) {
-      if (readHead.fragmentRemaining == 0) {
-        readHead.fragmentIndex++;
-        readHead.fragmentOffset = allocation.getFragmentOffset(readHead.fragmentIndex);
-        readHead.fragmentRemaining = allocation.getFragmentLength(readHead.fragmentIndex);
-      }
-      int bufferReadLength = Math.min(readHead.fragmentRemaining, bytesToRead - bytesRead);
-      if (target != null) {
-        target.put(buffers[readHead.fragmentIndex], readHead.fragmentOffset, bufferReadLength);
-      } else if (targetArray != null) {
-        System.arraycopy(buffers[readHead.fragmentIndex], readHead.fragmentOffset, targetArray,
-            targetArrayOffset, bufferReadLength);
-        targetArrayOffset += bufferReadLength;
-      }
-      readHead.position += bufferReadLength;
-      bytesRead += bufferReadLength;
-      readHead.fragmentOffset += bufferReadLength;
-      readHead.fragmentRemaining -= bufferReadLength;
-    }
-
-    return bytesRead;
-  }
-
-  // {@link Loadable} implementation.
-
-  @Override
-  public void cancelLoad() {
-    loadCanceled = true;
-  }
-
-  @Override
-  public boolean isLoadCanceled() {
-    return loadCanceled;
-  }
-
-  @Override
-  public void load() throws IOException, InterruptedException {
-    if (loadCanceled || isLoadFinished()) {
-      // The load was canceled, or is already complete.
-      return;
-    }
-
-    try {
-      DataSpec loadDataSpec;
-      if (loadPosition == 0 && resolvedLength == C.LENGTH_UNBOUNDED) {
-        loadDataSpec = dataSpec;
-        long resolvedLength = dataSource.open(loadDataSpec);
-        if (resolvedLength > Integer.MAX_VALUE) {
-          throw new DataSourceStreamLoadException(
-              new UnexpectedLengthException(dataSpec.length, resolvedLength));
-        }
-        this.resolvedLength = resolvedLength;
-      } else {
-        long remainingLength = resolvedLength != C.LENGTH_UNBOUNDED
-            ? resolvedLength - loadPosition : C.LENGTH_UNBOUNDED;
-        loadDataSpec = new DataSpec(dataSpec.uri, dataSpec.position + loadPosition,
-            remainingLength, dataSpec.key);
-        dataSource.open(loadDataSpec);
-      }
-
-      if (allocation == null) {
-        int initialAllocationSize = resolvedLength != C.LENGTH_UNBOUNDED
-            ? (int) resolvedLength : CHUNKED_ALLOCATION_INCREMENT;
-        allocation = allocator.allocate(initialAllocationSize);
-      }
-      int allocationCapacity = allocation.capacity();
-
-      if (loadPosition == 0) {
-        writeFragmentIndex = 0;
-        writeFragmentOffset = allocation.getFragmentOffset(0);
-        writeFragmentRemainingLength = allocation.getFragmentLength(0);
-      }
-
-      int read = Integer.MAX_VALUE;
-      byte[][] buffers = allocation.getBuffers();
-      while (!loadCanceled && read > 0 && maybeMoreToLoad()) {
-        if (Thread.interrupted()) {
-          throw new InterruptedException();
-        }
-        read = dataSource.read(buffers[writeFragmentIndex], writeFragmentOffset,
-            writeFragmentRemainingLength);
-        if (read > 0) {
-          loadPosition += read;
-          writeFragmentOffset += read;
-          writeFragmentRemainingLength -= read;
-          if (writeFragmentRemainingLength == 0 && maybeMoreToLoad()) {
-            writeFragmentIndex++;
-            if (loadPosition == allocationCapacity) {
-              allocation.ensureCapacity(allocationCapacity + CHUNKED_ALLOCATION_INCREMENT);
-              allocationCapacity = allocation.capacity();
-              buffers = allocation.getBuffers();
-            }
-            writeFragmentOffset = allocation.getFragmentOffset(writeFragmentIndex);
-            writeFragmentRemainingLength = allocation.getFragmentLength(writeFragmentIndex);
-          }
-        } else if (resolvedLength == C.LENGTH_UNBOUNDED) {
-          resolvedLength = loadPosition;
-        } else if (resolvedLength != loadPosition) {
-          throw new DataSourceStreamLoadException(
-              new UnexpectedLengthException(resolvedLength, loadPosition));
-        }
-      }
-    } finally {
-      Util.closeQuietly(dataSource);
-    }
-  }
-
-  private boolean maybeMoreToLoad() {
-    return resolvedLength == C.LENGTH_UNBOUNDED || loadPosition < resolvedLength;
-  }
-
-  private static class ReadHead {
-
-    private int position;
-    private int fragmentIndex;
-    private int fragmentOffset;
-    private int fragmentRemaining;
-
-    public void reset() {
-      position = 0;
-      fragmentIndex = 0;
-      fragmentOffset = 0;
-      fragmentRemaining = 0;
-    }
-
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
index ff3b7dda0d..072ba82294 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
@@ -26,21 +26,31 @@
 public final class DataSpec {
 
   /**
-   * Identifies the source from which data should be read.
+   * Permits an underlying network stack to request that the server use gzip compression.
+   * <p>
+   * Should not typically be set if the data being requested is already compressed (e.g. most audio
+   * and video requests). May be set when requesting other data.
+   * <p>
+   * When a {@link DataSource} is used to request data with this flag set, and if the
+   * {@link DataSource} does make a network request, then the value returned from
+   * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNBOUNDED}. The data read
+   * from {@link DataSource#read(byte[], int, int)} will be the decompressed data.
    */
-  public final Uri uri;
+  public static final int FLAG_ALLOW_GZIP = 1;
+
   /**
-   * True if the data at {@link #uri} is the full stream. False otherwise. An example where this
-   * may be false is if {@link #uri} defines the location of a cached part of the stream.
+   * Identifies the source from which data should be read.
    */
-  public final boolean uriIsFullStream;
+  public final Uri uri;
   /**
    * The absolute position of the data in the full stream.
    */
   public final long absoluteStreamPosition;
   /**
-   * The position of the data when read from {@link #uri}. Always equal to
-   * {@link #absoluteStreamPosition} if {@link #uriIsFullStream}.
+   * The position of the data when read from {@link #uri}.
+   * <p>
+   * Always equal to {@link #absoluteStreamPosition} unless the {@link #uri} defines the location
+   * of a subset of the underyling data.
    */
   public final long position;
   /**
@@ -52,6 +62,10 @@
    * {@link DataSpec} is not intended to be used in conjunction with a cache.
    */
   public final String key;
+  /**
+   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} is the only supported flag.
+   */
+  public final int flags;
 
   /**
    * Construct a {@link DataSpec} for the given uri and with {@link #key} set to null.
@@ -59,11 +73,21 @@
    * @param uri {@link #uri}.
    */
   public DataSpec(Uri uri) {
-    this(uri, 0, C.LENGTH_UNBOUNDED, null);
+    this(uri, 0);
   }
 
   /**
-   * Construct a {@link DataSpec} for which {@link #uriIsFullStream} is true.
+   * Construct a {@link DataSpec} for the given uri and with {@link #key} set to null.
+   *
+   * @param uri {@link #uri}.
+   * @param flags {@link #flags}.
+   */
+  public DataSpec(Uri uri, int flags) {
+    this(uri, 0, C.LENGTH_UNBOUNDED, null, flags);
+  }
+
+  /**
+   * Construct a {@link DataSpec} where {@link #position} equals {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
@@ -71,50 +95,50 @@ public DataSpec(Uri uri) {
    * @param key {@link #key}.
    */
   public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key) {
-    this(uri, absoluteStreamPosition, length, key, absoluteStreamPosition, true);
+    this(uri, absoluteStreamPosition, absoluteStreamPosition, length, key, 0);
   }
 
   /**
-   * Construct a {@link DataSpec} for which {@link #uriIsFullStream} is false.
+   * Construct a {@link DataSpec} where {@link #position} equals {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
-   * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
    * @param length {@link #length}.
    * @param key {@link #key}.
-   * @param position {@link #position}.
+   * @param flags {@link #flags}.
    */
-  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, long position) {
-    this(uri, absoluteStreamPosition, length, key, position, false);
+  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, int flags) {
+    this(uri, absoluteStreamPosition, absoluteStreamPosition, length, key, flags);
   }
 
   /**
-   * Construct a {@link DataSpec}.
+   * Construct a {@link DataSpec} where {@link #position} may differ from
+   * {@link #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
+   * @param position {@link #position}.
    * @param length {@link #length}.
    * @param key {@link #key}.
-   * @param position {@link #position}.
-   * @param uriIsFullStream {@link #uriIsFullStream}.
+   * @param flags {@link #flags}.
    */
-  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, long position,
-      boolean uriIsFullStream) {
+  public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length, String key,
+      int flags) {
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNBOUNDED);
-    Assertions.checkArgument(absoluteStreamPosition == position || !uriIsFullStream);
     this.uri = uri;
-    this.uriIsFullStream = uriIsFullStream;
     this.absoluteStreamPosition = absoluteStreamPosition;
     this.position = position;
     this.length = length;
     this.key = key;
+    this.flags = flags;
   }
 
   @Override
   public String toString() {
-    return "DataSpec[" + uri + ", " + uriIsFullStream + ", " + absoluteStreamPosition + ", " +
-        position + ", " + length + ", " + key + "]";
+    return "DataSpec[" + uri + ", " + absoluteStreamPosition + ", " + position + ", " + length
+        + ", " + key + ", " + flags + "]";
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
new file mode 100644
index 0000000000..1d1b8f4054
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import java.util.Arrays;
+
+/**
+ * Default implementation of {@link Allocator}.
+ */
+public final class DefaultAllocator implements Allocator {
+
+  private static final int INITIAL_RECYCLED_ALLOCATION_CAPACITY = 100;
+
+  private final int individualAllocationSize;
+
+  private int allocatedCount;
+  private int recycledCount;
+  private Allocation[] recycledAllocations;
+
+  /**
+   * Constructs an empty pool.
+   *
+   * @param individualAllocationSize The length of each individual allocation.
+   */
+  public DefaultAllocator(int individualAllocationSize) {
+    Assertions.checkArgument(individualAllocationSize > 0);
+    this.individualAllocationSize = individualAllocationSize;
+    this.recycledAllocations = new Allocation[INITIAL_RECYCLED_ALLOCATION_CAPACITY];
+  }
+
+  @Override
+  public synchronized Allocation allocate() {
+    allocatedCount++;
+    return recycledCount > 0 ? recycledAllocations[--recycledCount]
+        : new Allocation(new byte[individualAllocationSize], 0);
+  }
+
+  @Override
+  public synchronized void release(Allocation allocation) {
+    // Weak sanity check that the allocation probably originated from this pool.
+    Assertions.checkArgument(allocation.data.length == individualAllocationSize);
+    allocatedCount--;
+    if (recycledCount == recycledAllocations.length) {
+      recycledAllocations = Arrays.copyOf(recycledAllocations, recycledAllocations.length * 2);
+    }
+    recycledAllocations[recycledCount++] = allocation;
+    // Wake up threads waiting for the allocated size to drop.
+    notifyAll();
+  }
+
+  @Override
+  public synchronized void trim(int targetSize) {
+    int targetAllocationCount = Util.ceilDivide(targetSize, individualAllocationSize);
+    int targetRecycledAllocationCount = Math.max(0, targetAllocationCount - allocatedCount);
+    if (targetRecycledAllocationCount < recycledCount) {
+      Arrays.fill(recycledAllocations, targetRecycledAllocationCount, recycledCount, null);
+      recycledCount = targetRecycledAllocationCount;
+    }
+  }
+
+  @Override
+  public synchronized int getTotalBytesAllocated() {
+    return allocatedCount * individualAllocationSize;
+  }
+
+  @Override
+  public int getIndividualAllocationLength() {
+    return individualAllocationSize;
+  }
+
+  /**
+   * Blocks execution until the allocated number of bytes allocated is not greater than the
+   * threshold, or the thread is interrupted.
+   */
+  public synchronized void blockWhileTotalBytesAllocatedExceeds(int limit)
+      throws InterruptedException {
+    while (getTotalBytesAllocated() > limit) {
+      wait();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
index ce2197e2cf..f2c7ec49b1 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
@@ -26,25 +26,7 @@
  * Counts transferred bytes while transfers are open and creates a bandwidth sample and updated
  * bandwidth estimate each time a transfer ends.
  */
-public class DefaultBandwidthMeter implements BandwidthMeter, TransferListener {
-
-  /**
-   * Interface definition for a callback to be notified of {@link DefaultBandwidthMeter} events.
-   */
-  public interface EventListener {
-
-    /**
-     * Invoked periodically to indicate that bytes have been transferred.
-     *
-     * @param elapsedMs The time taken to transfer the bytes, in milliseconds.
-     * @param bytes The number of bytes transferred.
-     * @param bitrate The estimated bitrate in bits/sec, or {@link #NO_ESTIMATE} if no estimate
-     *     is available. Note that this estimate is typically derived from more information than
-     *     {@code bytes} and {@code elapsedMs}.
-     */
-    void onBandwidthSample(int elapsedMs, long bytes, long bitrate);
-
-  }
+public class DefaultBandwidthMeter implements BandwidthMeter {
 
   private static final int DEFAULT_MAX_WEIGHT = 2000;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
new file mode 100644
index 0000000000..621c49b32a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
@@ -0,0 +1,556 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Predicate;
+import com.google.android.exoplayer.util.Util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.net.NoRouteToHostException;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A {@link HttpDataSource} that uses Android's {@link HttpURLConnection}.
+ * <p>
+ * By default this implementation will not follow cross-protocol redirects (i.e. redirects from
+ * HTTP to HTTPS or vice versa). Cross-protocol redirects can be enabled by using the
+ * {@link #DefaultHttpDataSource(String, Predicate, TransferListener, int, int, boolean)}
+ * constructor and passing {@code true} as the final argument.
+ */
+public class DefaultHttpDataSource implements HttpDataSource {
+
+  /**
+   * The default connection timeout, in milliseconds.
+   */
+  public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
+  /**
+   * The default read timeout, in milliseconds.
+   */
+  public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
+
+  private static final int MAX_REDIRECTS = 20; // Same limit as okhttp.
+  private static final String TAG = "HttpDataSource";
+  private static final Pattern CONTENT_RANGE_HEADER =
+      Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
+  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<byte[]>();
+
+  private final boolean allowCrossProtocolRedirects;
+  private final int connectTimeoutMillis;
+  private final int readTimeoutMillis;
+  private final String userAgent;
+  private final Predicate<String> contentTypePredicate;
+  private final HashMap<String, String> requestProperties;
+  private final TransferListener listener;
+
+  private DataSpec dataSpec;
+  private HttpURLConnection connection;
+  private InputStream inputStream;
+  private boolean opened;
+
+  private long bytesToSkip;
+  private long bytesToRead;
+
+  private long bytesSkipped;
+  private long bytesRead;
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
+   *     rejected by the predicate then a {@link HttpDataSource.InvalidContentTypeException} is
+   *     thrown from {@link #open(DataSpec)}.
+   */
+  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
+    this(userAgent, contentTypePredicate, null);
+  }
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
+   *     rejected by the predicate then a {@link HttpDataSource.InvalidContentTypeException} is
+   *     thrown from {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   */
+  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+      TransferListener listener) {
+    this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS);
+  }
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
+   *     rejected by the predicate then a {@link HttpDataSource.InvalidContentTypeException} is
+   *     thrown from {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
+   *     interpreted as an infinite timeout.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
+   *     as an infinite timeout.
+   */
+  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+      TransferListener listener, int connectTimeoutMillis, int readTimeoutMillis) {
+    this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false);
+  }
+
+  /**
+   * @param userAgent The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
+   *     rejected by the predicate then a {@link HttpDataSource.InvalidContentTypeException} is
+   *     thrown from {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
+   *     interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
+   *     the default value.
+   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
+   *     as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled.
+   */
+  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+      TransferListener listener, int connectTimeoutMillis, int readTimeoutMillis,
+      boolean allowCrossProtocolRedirects) {
+    this.userAgent = Assertions.checkNotEmpty(userAgent);
+    this.contentTypePredicate = contentTypePredicate;
+    this.listener = listener;
+    this.requestProperties = new HashMap<String, String>();
+    this.connectTimeoutMillis = connectTimeoutMillis;
+    this.readTimeoutMillis = readTimeoutMillis;
+    this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
+  }
+
+  @Override
+  public String getUri() {
+    return connection == null ? null : connection.getURL().toString();
+  }
+
+  @Override
+  public void setRequestProperty(String name, String value) {
+    Assertions.checkNotNull(name);
+    Assertions.checkNotNull(value);
+    synchronized (requestProperties) {
+      requestProperties.put(name, value);
+    }
+  }
+
+  @Override
+  public void clearRequestProperty(String name) {
+    Assertions.checkNotNull(name);
+    synchronized (requestProperties) {
+      requestProperties.remove(name);
+    }
+  }
+
+  @Override
+  public void clearAllRequestProperties() {
+    synchronized (requestProperties) {
+      requestProperties.clear();
+    }
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    this.dataSpec = dataSpec;
+    this.bytesRead = 0;
+    this.bytesSkipped = 0;
+    try {
+      connection = makeConnection(dataSpec);
+    } catch (IOException e) {
+      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+          dataSpec);
+    }
+
+    int responseCode;
+    try {
+      responseCode = connection.getResponseCode();
+    } catch (IOException e) {
+      closeConnection();
+      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+          dataSpec);
+    }
+
+    // Check for a valid response code.
+    if (responseCode < 200 || responseCode > 299) {
+      Map<String, List<String>> headers = connection.getHeaderFields();
+      closeConnection();
+      throw new InvalidResponseCodeException(responseCode, headers, dataSpec);
+    }
+
+    // Check for a valid content type.
+    String contentType = connection.getContentType();
+    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+      closeConnection();
+      throw new InvalidContentTypeException(contentType, dataSpec);
+    }
+
+    // If we requested a range starting from a non-zero position and received a 200 rather than a
+    // 206, then the server does not support partial requests. We'll need to manually skip to the
+    // requested position.
+    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+    // Determine the length of the data to be read, after skipping.
+    if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
+      long contentLength = getContentLength(connection);
+      bytesToRead = dataSpec.length != C.LENGTH_UNBOUNDED ? dataSpec.length
+          : contentLength != C.LENGTH_UNBOUNDED ? contentLength - bytesToSkip
+          : C.LENGTH_UNBOUNDED;
+    } else {
+      // Gzip is enabled. If the server opts to use gzip then the content length in the response
+      // will be that of the compressed data, which isn't what we want. Furthermore, there isn't a
+      // reliable way to determine whether the gzip was used or not. Always use the dataSpec length
+      // in this case.
+      bytesToRead = dataSpec.length;
+    }
+
+    try {
+      inputStream = connection.getInputStream();
+    } catch (IOException e) {
+      closeConnection();
+      throw new HttpDataSourceException(e, dataSpec);
+    }
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart();
+    }
+
+    return bytesToRead;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
+    try {
+      skipInternal();
+      return readInternal(buffer, offset, readLength);
+    } catch (IOException e) {
+      throw new HttpDataSourceException(e, dataSpec);
+    }
+  }
+
+  @Override
+  public void close() throws HttpDataSourceException {
+    try {
+      if (inputStream != null) {
+        Util.maybeTerminateInputStream(connection, bytesRemaining());
+        try {
+          inputStream.close();
+        } catch (IOException e) {
+          throw new HttpDataSourceException(e, dataSpec);
+        }
+        inputStream = null;
+      }
+    } finally {
+      if (opened) {
+        opened = false;
+        if (listener != null) {
+          listener.onTransferEnd();
+        }
+        closeConnection();
+      }
+    }
+  }
+
+  /**
+   * Returns the current connection, or null if the source is not currently opened.
+   *
+   * @return The current open connection, or null.
+   */
+  protected final HttpURLConnection getConnection() {
+    return connection;
+  }
+
+  /**
+   * Returns the number of bytes that have been skipped since the most recent call to
+   * {@link #open(DataSpec)}.
+   *
+   * @return The number of bytes skipped.
+   */
+  protected final long bytesSkipped() {
+    return bytesSkipped;
+  }
+
+  /**
+   * Returns the number of bytes that have been read since the most recent call to
+   * {@link #open(DataSpec)}.
+   *
+   * @return The number of bytes read.
+   */
+  protected final long bytesRead() {
+    return bytesRead;
+  }
+
+  /**
+   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
+   * <p>
+   * If the total length of the data being read is known, then this length minus {@code bytesRead()}
+   * is returned. If the total length is unknown, {@link C#LENGTH_UNBOUNDED} is returned.
+   *
+   * @return The remaining length, or {@link C#LENGTH_UNBOUNDED}.
+   */
+  protected final long bytesRemaining() {
+    return bytesToRead == C.LENGTH_UNBOUNDED ? bytesToRead : bytesToRead - bytesRead;
+  }
+
+  /**
+   * Establishes a connection, following redirects to do so where permitted.
+   */
+  private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
+    URL url = new URL(dataSpec.uri.toString());
+    long position = dataSpec.position;
+    long length = dataSpec.length;
+    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+
+    if (!allowCrossProtocolRedirects) {
+      // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
+      // automatically. This is the behavior we want, so use it.
+      HttpURLConnection connection = configureConnection(url, position, length, allowGzip);
+      connection.connect();
+      return connection;
+    }
+
+    // We need to handle redirects ourselves to allow cross-protocol redirects.
+    int redirectCount = 0;
+    while (redirectCount++ <= MAX_REDIRECTS) {
+      HttpURLConnection connection = configureConnection(url, position, length, allowGzip);
+      connection.setInstanceFollowRedirects(false);
+      connection.connect();
+      int responseCode = connection.getResponseCode();
+      if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
+          || responseCode == HttpURLConnection.HTTP_MOVED_PERM
+          || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
+          || responseCode == HttpURLConnection.HTTP_SEE_OTHER
+          || responseCode == 307 /* HTTP_TEMP_REDIRECT */
+          || responseCode == 308 /* HTTP_PERM_REDIRECT */) {
+        String location = connection.getHeaderField("Location");
+        connection.disconnect();
+        url = handleRedirect(url, location);
+      } else {
+        return connection;
+      }
+    }
+
+    // If we get here we've been redirected more times than are permitted.
+    throw new NoRouteToHostException("Too many redirects: " + redirectCount);
+  }
+
+  /**
+   * Configures a connection, but does not open it.
+   *
+   * @param url The url to connect to.
+   * @param position The byte offset of the requested data.
+   * @param length The length of the requested data, or {@link C#LENGTH_UNBOUNDED}.
+   * @param allowGzip Whether to allow the use of gzip.
+   */
+  private HttpURLConnection configureConnection(URL url, long position, long length,
+      boolean allowGzip) throws IOException {
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setConnectTimeout(connectTimeoutMillis);
+    connection.setReadTimeout(readTimeoutMillis);
+    connection.setDoOutput(false);
+    synchronized (requestProperties) {
+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+        connection.setRequestProperty(property.getKey(), property.getValue());
+      }
+    }
+    if (!(position == 0 && length == C.LENGTH_UNBOUNDED)) {
+      String rangeRequest = "bytes=" + position + "-";
+      if (length != C.LENGTH_UNBOUNDED) {
+        rangeRequest += (position + length - 1);
+      }
+      connection.setRequestProperty("Range", rangeRequest);
+    }
+    connection.setRequestProperty("User-Agent", userAgent);
+    if (!allowGzip) {
+      connection.setRequestProperty("Accept-Encoding", "identity");
+    }
+    return connection;
+  }
+
+  /**
+   * Handles a redirect.
+   *
+   * @param originalUrl The original URL.
+   * @param location The Location header in the response.
+   * @return The next URL.
+   * @throws IOException If redirection isn't possible.
+   */
+  private static URL handleRedirect(URL originalUrl, String location) throws IOException {
+    if (location == null) {
+      throw new ProtocolException("Null location redirect");
+    }
+    // Form the new url.
+    URL url = new URL(originalUrl, location);
+    // Check that the protocol of the new url is supported.
+    String protocol = url.getProtocol();
+    if (!"https".equals(protocol) && !"http".equals(protocol)) {
+      throw new ProtocolException("Unsupported protocol redirect: " + protocol);
+    }
+    // Currently this method is only called if allowCrossProtocolRedirects is true, and so the code
+    // below isn't required. If we ever decide to handle redirects ourselves when cross-protocol
+    // redirects are disabled, we'll need to uncomment this block of code.
+    // if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {
+    //   throw new ProtocolException("Disallowed cross-protocol redirect ("
+    //       + originalUrl.getProtocol() + " to " + protocol + ")");
+    // }
+    return url;
+  }
+
+  /**
+   * Attempts to extract the length of the content from the response headers of an open connection.
+   *
+   * @param connection The open connection.
+   * @return The extracted length, or {@link C#LENGTH_UNBOUNDED}.
+   */
+  private static long getContentLength(HttpURLConnection connection) {
+    long contentLength = C.LENGTH_UNBOUNDED;
+    String contentLengthHeader = connection.getHeaderField("Content-Length");
+    if (!TextUtils.isEmpty(contentLengthHeader)) {
+      try {
+        contentLength = Long.parseLong(contentLengthHeader);
+      } catch (NumberFormatException e) {
+        Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
+      }
+    }
+    String contentRangeHeader = connection.getHeaderField("Content-Range");
+    if (!TextUtils.isEmpty(contentRangeHeader)) {
+      Matcher matcher = CONTENT_RANGE_HEADER.matcher(contentRangeHeader);
+      if (matcher.find()) {
+        try {
+          long contentLengthFromRange =
+              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+          if (contentLength < 0) {
+            // Some proxy servers strip the Content-Length header. Fall back to the length
+            // calculated here in this case.
+            contentLength = contentLengthFromRange;
+          } else if (contentLength != contentLengthFromRange) {
+            // If there is a discrepancy between the Content-Length and Content-Range headers,
+            // assume the one with the larger value is correct. We have seen cases where carrier
+            // change one of them to reduce the size of a request, but it is unlikely anybody would
+            // increase it.
+            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
+                + "]");
+            contentLength = Math.max(contentLength, contentLengthFromRange);
+          }
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
+        }
+      }
+    }
+    return contentLength;
+  }
+
+  /**
+   * Skips any bytes that need skipping. Else does nothing.
+   * <p>
+   * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
+   *
+   * @throws InterruptedIOException If the thread is interrupted during the operation.
+   * @throws EOFException If the end of the input stream is reached before the bytes are skipped.
+   */
+  private void skipInternal() throws IOException {
+    if (bytesSkipped == bytesToSkip) {
+      return;
+    }
+
+    // Acquire the shared skip buffer.
+    byte[] skipBuffer = skipBufferReference.getAndSet(null);
+    if (skipBuffer == null) {
+      skipBuffer = new byte[4096];
+    }
+
+    while (bytesSkipped != bytesToSkip) {
+      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
+      int read = inputStream.read(skipBuffer, 0, readLength);
+      if (Thread.interrupted()) {
+        throw new InterruptedIOException();
+      }
+      if (read == -1) {
+        throw new EOFException();
+      }
+      bytesSkipped += read;
+      if (listener != null) {
+        listener.onBytesTransferred(read);
+      }
+    }
+
+    // Release the shared skip buffer.
+    skipBufferReference.set(skipBuffer);
+  }
+
+  /**
+   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+   * index {@code offset}.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the opened range is
+   * detected, or an exception is thrown.
+   *
+   * @param buffer The buffer into which the read data should be stored.
+   * @param offset The start offset into {@code buffer} at which data should be written.
+   * @param readLength The maximum number of bytes to read.
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
+   *     range is reached.
+   * @throws IOException If an error occurs reading from the source.
+   */
+  private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
+    readLength = bytesToRead == C.LENGTH_UNBOUNDED ? readLength
+        : (int) Math.min(readLength, bytesToRead - bytesRead);
+    if (readLength == 0) {
+      // We've read all of the requested data.
+      return C.RESULT_END_OF_INPUT;
+    }
+
+    int read = inputStream.read(buffer, offset, readLength);
+    if (read == -1) {
+      if (bytesToRead != C.LENGTH_UNBOUNDED && bytesToRead != bytesRead) {
+        // The server closed the connection having not sent sufficient data.
+        throw new EOFException();
+      }
+      return C.RESULT_END_OF_INPUT;
+    }
+
+    bytesRead += read;
+    if (listener != null) {
+      listener.onBytesTransferred(read);
+    }
+    return read;
+  }
+
+  /**
+   * Closes the current connection, if there is one.
+   */
+  private void closeConnection() {
+    if (connection != null) {
+      connection.disconnect();
+      connection = null;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java
new file mode 100644
index 0000000000..fa225bf266
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+
+/**
+ * A data source that fetches data from a local or remote {@link DataSpec}.
+ */
+public final class DefaultUriDataSource implements UriDataSource {
+
+  private static final String FILE_URI_SCHEME = "file";
+
+  private final UriDataSource fileDataSource;
+  private final UriDataSource httpDataSource;
+
+  /**
+   * {@code null} if no data source is open. Otherwise, equal to {@link #fileDataSource} if the open
+   * data source is a file, or {@link #httpDataSource} otherwise.
+   */
+  private UriDataSource dataSource;
+
+  /**
+   * Constructs a new data source that delegates to a {@link FileDataSource} for file URIs and a
+   * {@link DefaultHttpDataSource} for other URIs.
+   * <p>
+   * The constructed instance will not follow cross-protocol redirects (i.e. redirects from HTTP to
+   * HTTPS or vice versa) when fetching remote data. Cross-protocol redirects can be enabled by
+   * using the {@link #DefaultUriDataSource(String, TransferListener, boolean)} constructor and
+   * passing {@code true} as the final argument.
+   *
+   * @param userAgent The User-Agent string that should be used when requesting remote data.
+   * @param transferListener An optional listener.
+   */
+  public DefaultUriDataSource(String userAgent, TransferListener transferListener) {
+    this(userAgent, transferListener, false);
+  }
+
+  /**
+   * Constructs a new data source that delegates to a {@link FileDataSource} for file URIs and a
+   * {@link DefaultHttpDataSource} for other URIs.
+   *
+   * @param userAgent The User-Agent string that should be used when requesting remote data.
+   * @param transferListener An optional listener.
+   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+   *     to HTTPS and vice versa) are enabled when fetching remote data..
+   */
+  public DefaultUriDataSource(String userAgent, TransferListener transferListener,
+      boolean allowCrossProtocolRedirects) {
+    this(new FileDataSource(transferListener),
+        new DefaultHttpDataSource(userAgent, null, transferListener,
+            DefaultHttpDataSource.DEFAULT_CONNECT_TIMEOUT_MILLIS,
+            DefaultHttpDataSource.DEFAULT_READ_TIMEOUT_MILLIS, allowCrossProtocolRedirects));
+  }
+
+  /**
+   * Constructs a new data source using {@code fileDataSource} for file URIs, and
+   * {@code httpDataSource} for non-file URIs.
+   *
+   * @param fileDataSource {@link UriDataSource} to use for file URIs.
+   * @param httpDataSource {@link UriDataSource} to use for non-file URIs.
+   */
+  public DefaultUriDataSource(UriDataSource fileDataSource, UriDataSource httpDataSource) {
+    this.fileDataSource = Assertions.checkNotNull(fileDataSource);
+    this.httpDataSource = Assertions.checkNotNull(httpDataSource);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    Assertions.checkState(dataSource == null);
+    dataSource = FILE_URI_SCHEME.equals(dataSpec.uri.getScheme()) ? fileDataSource : httpDataSource;
+    return dataSource.open(dataSpec);
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    return dataSource.read(buffer, offset, readLength);
+  }
+
+  @Override
+  public String getUri() {
+    return dataSource == null ? null : dataSource.getUri();
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (dataSource != null) {
+      dataSource.close();
+      dataSource = null;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/FileDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/FileDataSource.java
index ec9a3b9ade..bd890b38d2 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/FileDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/FileDataSource.java
@@ -17,13 +17,14 @@
 
 import com.google.android.exoplayer.C;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 
 /**
  * A local file {@link DataSource}.
  */
-public final class FileDataSource implements DataSource {
+public final class FileDataSource implements UriDataSource {
 
   /**
    * Thrown when IOException is encountered during local file read operation.
@@ -39,6 +40,7 @@ public FileDataSourceException(IOException cause) {
   private final TransferListener listener;
 
   private RandomAccessFile file;
+  private String uri;
   private long bytesRemaining;
   private boolean opened;
 
@@ -61,10 +63,14 @@ public FileDataSource(TransferListener listener) {
   @Override
   public long open(DataSpec dataSpec) throws FileDataSourceException {
     try {
+      uri = dataSpec.uri.toString();
       file = new RandomAccessFile(dataSpec.uri.getPath(), "r");
       file.seek(dataSpec.position);
       bytesRemaining = dataSpec.length == C.LENGTH_UNBOUNDED ? file.length() - dataSpec.position
           : dataSpec.length;
+      if (bytesRemaining < 0) {
+        throw new EOFException();
+      }
     } catch (IOException e) {
       throw new FileDataSourceException(e);
     }
@@ -100,6 +106,11 @@ public int read(byte[] buffer, int offset, int readLength) throws FileDataSource
     }
   }
 
+  @Override
+  public String getUri() {
+    return uri;
+  }
+
   @Override
   public void close() throws FileDataSourceException {
     if (file != null) {
@@ -109,6 +120,7 @@ public void close() throws FileDataSourceException {
         throw new FileDataSourceException(e);
       } finally {
         file = null;
+        uri = null;
 
         if (opened) {
           opened = false;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
index fd2f345e4c..2944616a09 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
@@ -15,28 +15,19 @@
  */
 package com.google.android.exoplayer.upstream;
 
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Predicate;
 import com.google.android.exoplayer.util.Util;
 
 import android.text.TextUtils;
-import android.util.Log;
 
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
- * An http {@link DataSource}.
+ * An HTTP specific extension to {@link DataSource}.
  */
-public class HttpDataSource implements DataSource {
+public interface HttpDataSource extends UriDataSource {
 
   /**
    * A {@link Predicate} that rejects content types often used for pay-walls.
@@ -54,7 +45,7 @@ public boolean evaluate(String contentType) {
   };
 
   /**
-   * Thrown when an error is encountered when trying to read from HTTP data source.
+   * Thrown when an error is encountered when trying to read from a {@link HttpDataSource}.
    */
   public static class HttpDataSourceException extends IOException {
 
@@ -123,71 +114,14 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
 
   }
 
-  public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
-  public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
-
-  private static final String TAG = "HttpDataSource";
-  private static final Pattern CONTENT_RANGE_HEADER =
-      Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
-
-  private final int connectTimeoutMillis;
-  private final int readTimeoutMillis;
-  private final String userAgent;
-  private final Predicate<String> contentTypePredicate;
-  private final HashMap<String, String> requestProperties;
-  private final TransferListener listener;
-
-  private DataSpec dataSpec;
-  private HttpURLConnection connection;
-  private InputStream inputStream;
-  private boolean opened;
-
-  private long dataLength;
-  private long bytesRead;
-
-  /**
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
-   *     rejected by the predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   */
-  public HttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
-    this(userAgent, contentTypePredicate, null);
-  }
+  @Override
+  long open(DataSpec dataSpec) throws HttpDataSourceException;
 
-  /**
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
-   *     rejected by the predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   */
-  public HttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener listener) {
-    this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-        DEFAULT_READ_TIMEOUT_MILLIS);
-  }
+  @Override
+  void close() throws HttpDataSourceException;
 
-  /**
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is
-   *     rejected by the predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
-   *     interpreted as an infinite timeout.
-   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout.
-   */
-  public HttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener listener, int connectTimeoutMillis, int readTimeoutMillis) {
-    this.userAgent = Assertions.checkNotEmpty(userAgent);
-    this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
-    this.requestProperties = new HashMap<String, String>();
-    this.connectTimeoutMillis = connectTimeoutMillis;
-    this.readTimeoutMillis = readTimeoutMillis;
-  }
+  @Override
+  int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException;
 
   /**
    * Sets the value of a request header field. The value will be used for subsequent connections
@@ -196,13 +130,7 @@ public HttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
    * @param name The name of the header field.
    * @param value The value of the field.
    */
-  public void setRequestProperty(String name, String value) {
-    Assertions.checkNotNull(name);
-    Assertions.checkNotNull(value);
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
-    }
-  }
+  void setRequestProperty(String name, String value);
 
   /**
    * Clears the value of a request header field. The change will apply to subsequent connections
@@ -210,243 +138,11 @@ public void setRequestProperty(String name, String value) {
    *
    * @param name The name of the header field.
    */
-  public void clearRequestProperty(String name) {
-    Assertions.checkNotNull(name);
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
-    }
-  }
+  void clearRequestProperty(String name);
 
   /**
    * Clears all request header fields that were set by {@link #setRequestProperty(String, String)}.
    */
-  public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
-    }
-  }
-
-  /*
-   * TODO: If the server uses gzip compression when serving the response, this may end up returning
-   * the size of the compressed response, where-as it should be returning the decompressed size or
-   * -1. See: developer.android.com/reference/java/net/HttpURLConnection.html
-   *
-   * To fix this we should:
-   *
-   * 1. Explicitly require no compression for media requests (since media should be compressed
-   *    already) by setting the Accept-Encoding header to "identity"
-   * 2. In other cases, for example when requesting manifests, we don't want to disable compression.
-   *    For these cases we should ensure that we return -1 here (and avoid performing any sanity
-   *    checks on the content length).
-   */
-  @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-    this.dataSpec = dataSpec;
-    this.bytesRead = 0;
-    try {
-      connection = makeConnection(dataSpec);
-    } catch (IOException e) {
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec);
-    }
-
-    // Check for a valid response code.
-    int responseCode;
-    try {
-      responseCode = connection.getResponseCode();
-    } catch (IOException e) {
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec);
-    }
-    if (responseCode < 200 || responseCode > 299) {
-      Map<String, List<String>> headers = connection.getHeaderFields();
-      closeConnection();
-      throw new InvalidResponseCodeException(responseCode, headers, dataSpec);
-    }
-
-    // Check for a valid content type.
-    String contentType = connection.getContentType();
-    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
-      closeConnection();
-      throw new InvalidContentTypeException(contentType, dataSpec);
-    }
-
-    long contentLength = getContentLength(connection);
-    dataLength = dataSpec.length == C.LENGTH_UNBOUNDED ? contentLength : dataSpec.length;
-
-    if (dataSpec.length != C.LENGTH_UNBOUNDED && contentLength != C.LENGTH_UNBOUNDED
-        && contentLength != dataSpec.length) {
-      // The DataSpec specified a length and we resolved a length from the response headers, but
-      // the two lengths do not match.
-      closeConnection();
-      throw new HttpDataSourceException(
-          new UnexpectedLengthException(dataSpec.length, contentLength), dataSpec);
-    }
-
-    try {
-      inputStream = connection.getInputStream();
-    } catch (IOException e) {
-      closeConnection();
-      throw new HttpDataSourceException(e, dataSpec);
-    }
-
-    opened = true;
-    if (listener != null) {
-      listener.onTransferStart();
-    }
-
-    return dataLength;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    int read = 0;
-    try {
-      read = inputStream.read(buffer, offset, readLength);
-    } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec);
-    }
-
-    if (read > 0) {
-      bytesRead += read;
-      if (listener != null) {
-        listener.onBytesTransferred(read);
-      }
-    } else if (dataLength != C.LENGTH_UNBOUNDED && dataLength != bytesRead) {
-      // Check for cases where the server closed the connection having not sent the correct amount
-      // of data. We can only do this if we know the length of the data we were expecting.
-      throw new HttpDataSourceException(new UnexpectedLengthException(dataLength, bytesRead),
-          dataSpec);
-    }
-
-    return read;
-  }
-
-  @Override
-  public void close() throws HttpDataSourceException {
-    try {
-      if (inputStream != null) {
-        try {
-          inputStream.close();
-        } catch (IOException e) {
-          throw new HttpDataSourceException(e, dataSpec);
-        }
-        inputStream = null;
-      }
-    } finally {
-      if (opened) {
-        opened = false;
-        if (listener != null) {
-          listener.onTransferEnd();
-        }
-        closeConnection();
-      }
-    }
-  }
-
-  private void closeConnection() {
-    if (connection != null) {
-      connection.disconnect();
-      connection = null;
-    }
-  }
-
-  /**
-   * Returns the current connection, or null if the source is not currently opened.
-   *
-   * @return The current open connection, or null.
-   */
-  protected final HttpURLConnection getConnection() {
-    return connection;
-  }
-
-  /**
-   * Returns the number of bytes that have been read since the most recent call to
-   * {@link #open(DataSpec)}.
-   *
-   * @return The number of bytes read.
-   */
-  protected final long bytesRead() {
-    return bytesRead;
-  }
-
-  /**
-   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
-   * <p>
-   * If the total length of the data being read is known, then this length minus {@code bytesRead()}
-   * is returned. If the total length is unknown, {@link C#LENGTH_UNBOUNDED} is returned.
-   *
-   * @return The remaining length, or {@link C#LENGTH_UNBOUNDED}.
-   */
-  protected final long bytesRemaining() {
-    return dataLength == C.LENGTH_UNBOUNDED ? dataLength : dataLength - bytesRead;
-  }
-
-  private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
-    URL url = new URL(dataSpec.uri.toString());
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setConnectTimeout(connectTimeoutMillis);
-    connection.setReadTimeout(readTimeoutMillis);
-    connection.setDoOutput(false);
-    synchronized (requestProperties) {
-      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
-        connection.setRequestProperty(property.getKey(), property.getValue());
-      }
-    }
-    setRangeHeader(connection, dataSpec);
-    connection.setRequestProperty("User-Agent", userAgent);
-    connection.connect();
-    return connection;
-  }
-
-  private void setRangeHeader(HttpURLConnection connection, DataSpec dataSpec) {
-    if (dataSpec.position == 0 && dataSpec.length == C.LENGTH_UNBOUNDED) {
-      // Not required.
-      return;
-    }
-    String rangeRequest = "bytes=" + dataSpec.position + "-";
-    if (dataSpec.length != C.LENGTH_UNBOUNDED) {
-      rangeRequest += (dataSpec.position + dataSpec.length - 1);
-    }
-    connection.setRequestProperty("Range", rangeRequest);
-  }
-
-  private long getContentLength(HttpURLConnection connection) {
-    long contentLength = C.LENGTH_UNBOUNDED;
-    String contentLengthHeader = connection.getHeaderField("Content-Length");
-    if (!TextUtils.isEmpty(contentLengthHeader)) {
-      try {
-        contentLength = Long.parseLong(contentLengthHeader);
-      } catch (NumberFormatException e) {
-        Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
-      }
-    }
-    String contentRangeHeader = connection.getHeaderField("Content-Range");
-    if (!TextUtils.isEmpty(contentRangeHeader)) {
-      Matcher matcher = CONTENT_RANGE_HEADER.matcher(contentRangeHeader);
-      if (matcher.find()) {
-        try {
-          long contentLengthFromRange =
-              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
-          if (contentLength < 0) {
-            // Some proxy servers strip the Content-Length header. Fall back to the length
-            // calculated here in this case.
-            contentLength = contentLengthFromRange;
-          } else if (contentLength != contentLengthFromRange) {
-            // If there is a discrepancy between the Content-Length and Content-Range headers,
-            // assume the one with the larger value is correct. We have seen cases where carrier
-            // change one of them to reduce the size of a request, but it is unlikely anybody would
-            // increase it.
-            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader +
-                "]");
-            contentLength = Math.max(contentLength, contentLengthFromRange);
-          }
-        } catch (NumberFormatException e) {
-          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
-        }
-      }
-    }
-    return contentLength;
-  }
+  void clearAllRequestProperties();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
index eb420c8f12..6eb477fd0d 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
@@ -99,7 +99,8 @@ public UnexpectedLoaderException(Exception cause) {
   }
 
   private static final int MSG_END_OF_SOURCE = 0;
-  private static final int MSG_ERROR = 1;
+  private static final int MSG_IO_EXCEPTION = 1;
+  private static final int MSG_FATAL_ERROR = 2;
 
   private final ExecutorService downloadExecutorService;
 
@@ -127,6 +128,21 @@ public void startLoading(Loadable loadable, Callback callback) {
     startLoading(myLooper, loadable, callback);
   }
 
+  /**
+   * Invokes {@link #startLoading(Looper, Loadable, Callback)}, using the {@link Looper}
+   * associated with the calling thread. Loading is delayed by {@code delayMs}.
+   *
+   * @param loadable The {@link Loadable} to load.
+   * @param callback A callback to invoke when the load ends.
+   * @param delayMs Number of milliseconds to wait before calling {@link Loadable#load()}.
+   * @throws IllegalStateException If the calling thread does not have an associated {@link Looper}.
+   */
+  public void startLoading(Loadable loadable, Callback callback, int delayMs) {
+    Looper myLooper = Looper.myLooper();
+    Assertions.checkState(myLooper != null);
+    startLoading(myLooper, loadable, callback, delayMs);
+  }
+
   /**
    * Start loading a {@link Loadable}.
    * <p>
@@ -138,9 +154,24 @@ public void startLoading(Loadable loadable, Callback callback) {
    * @param callback A callback to invoke when the load ends.
    */
   public void startLoading(Looper looper, Loadable loadable, Callback callback) {
+    startLoading(looper, loadable, callback, 0);
+  }
+
+  /**
+   * Start loading a {@link Loadable} after {@code delayMs} has elapsed.
+   * <p>
+   * A {@link Loader} instance can only load one {@link Loadable} at a time, and so this method
+   * must not be called when another load is in progress.
+   *
+   * @param looper The looper of the thread on which the callback should be invoked.
+   * @param loadable The {@link Loadable} to load.
+   * @param callback A callback to invoke when the load ends.
+   * @param delayMs Number of milliseconds to wait before calling {@link Loadable#load()}.
+   */
+  public void startLoading(Looper looper, Loadable loadable, Callback callback, int delayMs) {
     Assertions.checkState(!loading);
     loading = true;
-    currentTask = new LoadTask(looper, loadable, callback);
+    currentTask = new LoadTask(looper, loadable, callback, delayMs);
     downloadExecutorService.submit(currentTask);
   }
 
@@ -182,13 +213,15 @@ public void release() {
 
     private final Loadable loadable;
     private final Loader.Callback callback;
+    private final int delayMs;
 
     private volatile Thread executorThread;
 
-    public LoadTask(Looper looper, Loadable loadable, Loader.Callback callback) {
+    public LoadTask(Looper looper, Loadable loadable, Loader.Callback callback, int delayMs) {
       super(looper);
       this.loadable = loadable;
       this.callback = callback;
+      this.delayMs = delayMs;
     }
 
     public void quit() {
@@ -202,25 +235,38 @@ public void quit() {
     public void run() {
       try {
         executorThread = Thread.currentThread();
+        if (delayMs > 0) {
+          Thread.sleep(delayMs);
+        }
         if (!loadable.isLoadCanceled()) {
           loadable.load();
         }
         sendEmptyMessage(MSG_END_OF_SOURCE);
       } catch (IOException e) {
-        obtainMessage(MSG_ERROR, e).sendToTarget();
+        obtainMessage(MSG_IO_EXCEPTION, e).sendToTarget();
       } catch (InterruptedException e) {
         // The load was canceled.
         Assertions.checkState(loadable.isLoadCanceled());
         sendEmptyMessage(MSG_END_OF_SOURCE);
       } catch (Exception e) {
         // This should never happen, but handle it anyway.
+        Log.e(TAG, "Unexpected exception loading stream", e);
+        obtainMessage(MSG_IO_EXCEPTION, new UnexpectedLoaderException(e)).sendToTarget();
+      } catch (Error e) {
+        // We'd hope that the platform would kill the process if an Error is thrown here, but the
+        // executor may catch the error (b/20616433). Throw it here, but also pass and throw it from
+        // the handler thread so that the process dies even if the executor behaves in this way.
         Log.e(TAG, "Unexpected error loading stream", e);
-        obtainMessage(MSG_ERROR, new UnexpectedLoaderException(e)).sendToTarget();
+        obtainMessage(MSG_FATAL_ERROR, e).sendToTarget();
+        throw e;
       }
     }
 
     @Override
     public void handleMessage(Message msg) {
+      if (msg.what == MSG_FATAL_ERROR) {
+        throw (Error) msg.obj;
+      }
       onFinished();
       if (loadable.isLoadCanceled()) {
         callback.onLoadCanceled(loadable);
@@ -230,7 +276,7 @@ public void handleMessage(Message msg) {
         case MSG_END_OF_SOURCE:
           callback.onLoadCompleted(loadable);
           break;
-        case MSG_ERROR:
+        case MSG_IO_EXCEPTION:
           callback.onLoadError(loadable, (IOException) msg.obj);
           break;
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/NonBlockingInputStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/NonBlockingInputStream.java
deleted file mode 100644
index f9e1dffe2d..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/upstream/NonBlockingInputStream.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.upstream;
-
-import java.nio.ByteBuffer;
-
-/**
- * Represents a source of bytes that can be consumed by downstream components.
- * <p>
- * The read and skip methods are non-blocking, and hence return 0 (indicating that no data has
- * been read) in the case that data is not yet available to be consumed.
- */
-public interface NonBlockingInputStream {
-
-  /**
-   * Skips over and discards up to {@code length} bytes of data. This method may skip over some
-   * smaller number of bytes, possibly 0.
-   *
-   * @param length The maximum number of bytes to skip.
-   * @return The actual number of bytes skipped, or -1 if the end of the data is reached.
-   */
-  int skip(int length);
-
-  /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
-   * index {@code offset}. This method may read fewer bytes, possibly 0.
-   *
-   * @param buffer The buffer into which the read data should be stored.
-   * @param offset The start offset into {@code buffer} at which data should be written.
-   * @param length The maximum number of bytes to read.
-   * @return The actual number of bytes read, or -1 if the end of the data is reached.
-   */
-  int read(byte[] buffer, int offset, int length);
-
-  /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}. This method may
-   * read fewer bytes, possibly 0.
-   *
-   * @param buffer The buffer into which the read data should be stored.
-   * @param length The maximum number of bytes to read.
-   * @return The actual number of bytes read, or -1 if the end of the data is reached.
-   */
-  int read(ByteBuffer buffer, int length);
-
-  /**
-   * Returns the number of bytes currently available for reading or skipping. Calls to the read()
-   * and skip() methods are guaranteed to be satisfied in full if they request less than or
-   * equal to the value returned.
-   *
-   * @return The number of bytes currently available.
-   */
-  long getAvailableByteCount();
-
-  /**
-   * Whether the end of the data has been reached.
-   *
-   * @return True if the end of the data has been reached, false otherwise.
-   */
-  boolean isEndOfStream();
-
-  /**
-   * Closes the input stream.
-   */
-  void close();
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/TeeDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/TeeDataSource.java
index cbb571f308..2623e8ce7f 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/TeeDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/TeeDataSource.java
@@ -42,8 +42,8 @@ public long open(DataSpec dataSpec) throws IOException {
     long dataLength = upstream.open(dataSpec);
     if (dataSpec.length == C.LENGTH_UNBOUNDED && dataLength != C.LENGTH_UNBOUNDED) {
       // Reconstruct dataSpec in order to provide the resolved length to the sink.
-      dataSpec = new DataSpec(dataSpec.uri, dataSpec.absoluteStreamPosition, dataLength,
-          dataSpec.key, dataSpec.position, dataSpec.uriIsFullStream);
+      dataSpec = new DataSpec(dataSpec.uri, dataSpec.absoluteStreamPosition, dataSpec.position,
+          dataLength, dataSpec.key, dataSpec.flags);
     }
     dataSink.open(dataSpec);
     return dataLength;
@@ -61,8 +61,11 @@ public int read(byte[] buffer, int offset, int max) throws IOException {
 
   @Override
   public void close() throws IOException {
-    upstream.close();
-    dataSink.close();
+    try {
+      upstream.close();
+    } finally {
+      dataSink.close();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/UnexpectedLengthException.java b/library/src/main/java/com/google/android/exoplayer/upstream/UnexpectedLengthException.java
index c7bc6c303d..6c91601485 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/UnexpectedLengthException.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/UnexpectedLengthException.java
@@ -20,6 +20,7 @@
 /**
  * Thrown when the length of some data does not match an expected length.
  */
+@Deprecated
 public final class UnexpectedLengthException extends IOException {
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/UriDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/UriDataSource.java
index 0655381191..61da0520ba 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/UriDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/UriDataSource.java
@@ -15,68 +15,18 @@
  */
 package com.google.android.exoplayer.upstream;
 
-import com.google.android.exoplayer.util.Assertions;
-
-import java.io.IOException;
-
 /**
- * A data source that fetches data from a local or remote {@link DataSpec}.
+ * A component that provides media data from a URI.
  */
-public final class UriDataSource implements DataSource {
-
-  private static final String FILE_URI_SCHEME = "file";
-
-  private final DataSource fileDataSource;
-  private final DataSource httpDataSource;
-
-  /**
-   * {@code null} if no data source is open. Otherwise, equal to {@link #fileDataSource} if the open
-   * data source is a file, or {@link #httpDataSource} otherwise.
-   */
-  private DataSource dataSource;
+public interface UriDataSource extends DataSource {
 
   /**
-   * Constructs a new data source that delegates to a {@link FileDataSource} for file URIs and an
-   * {@link HttpDataSource} for other URIs.
+   * When the source is open, returns the URI from which data is being read.
+   * <p>
+   * If redirection occurred, the URI after redirection is the one returned.
    *
-   * @param userAgent The User-Agent string that should be used when requesting remote data.
-   * @param transferListener An optional listener.
+   * @return When the source is open, the URI from which data is being read. Null otherwise.
    */
-  public UriDataSource(String userAgent, TransferListener transferListener) {
-    this(new FileDataSource(transferListener),
-        new HttpDataSource(userAgent, null, transferListener));
-  }
-
-  /**
-   * Constructs a new data source using {@code fileDataSource} for file URIs, and
-   * {@code httpDataSource} for non-file URIs.
-   *
-   * @param fileDataSource {@link DataSource} to use for file URIs.
-   * @param httpDataSource {@link DataSource} to use for non-file URIs.
-   */
-  public UriDataSource(DataSource fileDataSource, DataSource httpDataSource) {
-    this.fileDataSource = Assertions.checkNotNull(fileDataSource);
-    this.httpDataSource = Assertions.checkNotNull(httpDataSource);
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    Assertions.checkState(dataSource == null);
-    dataSource = FILE_URI_SCHEME.equals(dataSpec.uri.getScheme()) ? fileDataSource : httpDataSource;
-    return dataSource.open(dataSpec);
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    return dataSource.read(buffer, offset, readLength);
-  }
-
-  @Override
-  public void close() throws IOException {
-    if (dataSource != null) {
-      dataSource.close();
-      dataSource = null;
-    }
-  }
+  String getUri();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/UriLoadable.java b/library/src/main/java/com/google/android/exoplayer/upstream/UriLoadable.java
new file mode 100644
index 0000000000..cce6f9347e
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/UriLoadable.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+
+import android.net.Uri;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A {@link Loadable} for loading an object from a URI.
+ *
+ * @param <T> The type of the object being loaded.
+ */
+public final class UriLoadable<T> implements Loadable {
+
+  /**
+   * Parses an object from loaded data.
+   */
+  public interface Parser<T> {
+
+    /**
+     * Parses an object from a response.
+     *
+     * @param connectionUrl The source of the response, after any redirection.
+     * @param inputStream An {@link InputStream} from which the response data can be read.
+     * @return The parsed object.
+     * @throws ParserException If an error occurs parsing the data.
+     * @throws IOException If an error occurs reading data from the stream.
+     */
+    T parse(String connectionUrl, InputStream inputStream) throws ParserException, IOException;
+
+  }
+
+  private final DataSpec dataSpec;
+  private final UriDataSource uriDataSource;
+  private final Parser<T> parser;
+
+  private volatile T result;
+  private volatile boolean isCanceled;
+
+  /**
+   * @param url The url from which the object should be loaded.
+   * @param uriDataSource A {@link UriDataSource} to use when loading the data.
+   * @param parser Parses the object from the response.
+   */
+  public UriLoadable(String url, UriDataSource uriDataSource, Parser<T> parser) {
+    this.uriDataSource = uriDataSource;
+    this.parser = parser;
+    dataSpec = new DataSpec(Uri.parse(url), DataSpec.FLAG_ALLOW_GZIP);
+  }
+
+  /**
+   * Returns the loaded object, or null if an object has not been loaded.
+   */
+  public final T getResult() {
+    return result;
+  }
+
+  @Override
+  public final void cancelLoad() {
+    // We don't actually cancel anything, but we need to record the cancellation so that
+    // isLoadCanceled can return the correct value.
+    isCanceled = true;
+  }
+
+  @Override
+  public final boolean isLoadCanceled() {
+    return isCanceled;
+  }
+
+  @Override
+  public final void load() throws IOException, InterruptedException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(uriDataSource, dataSpec);
+    try {
+      inputStream.open();
+      result = parser.parse(uriDataSource.getUri(), inputStream);
+    } finally {
+      inputStream.close();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
index 942a29f0c7..01e06b5158 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.upstream.DataSink;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -115,11 +116,23 @@ private void openNextOutputStream() throws FileNotFoundException {
   }
 
   private void closeCurrentOutputStream() throws IOException {
-    if (outputStream != null) {
+    if (outputStream == null) {
+      return;
+    }
+
+    boolean success = false;
+    try {
       outputStream.flush();
-      outputStream.close();
+      outputStream.getFD().sync();
+      success = true;
+    } finally {
+      Util.closeQuietly(outputStream);
+      if (success) {
+        cache.commitFile(file);
+      } else {
+        file.delete();
+      }
       outputStream = null;
-      cache.commitFile(file);
       file = null;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
index 5842d742ab..63a3763133 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
@@ -22,7 +22,6 @@
 import com.google.android.exoplayer.upstream.FileDataSource;
 import com.google.android.exoplayer.upstream.TeeDataSource;
 import com.google.android.exoplayer.upstream.cache.CacheDataSink.CacheDataSinkException;
-import com.google.android.exoplayer.util.Assertions;
 
 import android.net.Uri;
 import android.util.Log;
@@ -64,6 +63,7 @@
 
   private DataSource currentDataSource;
   private Uri uri;
+  private int flags;
   private String key;
   private long readPosition;
   private long bytesRemaining;
@@ -125,9 +125,9 @@ public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDat
 
   @Override
   public long open(DataSpec dataSpec) throws IOException {
-    Assertions.checkState(dataSpec.uriIsFullStream);
     try {
       uri = dataSpec.uri;
+      flags = dataSpec.flags;
       key = dataSpec.key;
       readPosition = dataSpec.position;
       bytesRemaining = dataSpec.length;
@@ -201,19 +201,19 @@ private void openNextSource() throws IOException {
         // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
         // from upstream.
         currentDataSource = upstreamDataSource;
-        dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key);
+        dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
       } else if (span.isCached) {
         // Data is cached, read from cache.
         Uri fileUri = Uri.fromFile(span.file);
         long filePosition = readPosition - span.position;
         long length = Math.min(span.length - filePosition, bytesRemaining);
-        dataSpec = new DataSpec(fileUri, readPosition, length, key, filePosition);
+        dataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
         currentDataSource = cacheReadDataSource;
       } else {
         // Data is not cached, and data is not locked, read from upstream with cache backing.
         lockedSpan = span;
         long length = span.isOpenEnded() ? bytesRemaining : Math.min(span.length, bytesRemaining);
-        dataSpec = new DataSpec(uri, readPosition, length, key);
+        dataSpec = new DataSpec(uri, readPosition, length, key, flags);
         currentDataSource = cacheWriteDataSource != null ? cacheWriteDataSource
             : upstreamDataSource;
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
new file mode 100644
index 0000000000..e96db51361
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import com.google.android.exoplayer.MediaFormat;
+
+import java.util.Collections;
+
+/**
+ * Utility methods for parsing AC-3 headers.
+ */
+public final class Ac3Util {
+
+  /** Sample rates, indexed by fscod. */
+  private static final int[] SAMPLE_RATES = new int[] {48000, 44100, 32000};
+  /** Channel counts, indexed by acmod. */
+  private static final int[] CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
+  /** Nominal bitrates in kbps, indexed by bit_rate_code. */
+  private static final int[] BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,
+      224, 256, 320, 384, 448, 512, 576, 640};
+  /** 16-bit words per sync frame, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.) */
+  private static final int[] FRMSIZECOD_TO_FRAME_SIZE_44_1 = new int[] {69, 87, 104, 121, 139, 174,
+    208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};
+
+  /**
+   * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to
+   * ETSI TS 102 366 Annex F.
+   */
+  public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data) {
+    // fscod (sample rate code)
+    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
+    int sampleRate = SAMPLE_RATES[fscod];
+    int nextByte = data.readUnsignedByte();
+    // Map acmod (audio coding mode) onto a channel count.
+    int channelCount = CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
+    // lfeon (low frequency effects on)
+    if ((nextByte & 0x04) != 0) {
+      channelCount++;
+    }
+    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, channelCount, sampleRate, Collections.<byte[]>emptyList());
+  }
+
+  /**
+   * Returns the AC-3 format given {@code data} containing the EC3SpecificBox according to
+   * ETSI TS 102 366 Annex F.
+   */
+  public static MediaFormat parseAnnexFEAc3Format(ParsableByteArray data) {
+    data.skipBytes(2); // Skip data_rate and num_ind_sub.
+
+    // Read only the first substream.
+    // TODO: Read later substreams?
+    // fscod (sample rate code)
+    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
+    int sampleRate = SAMPLE_RATES[fscod];
+    int nextByte = data.readUnsignedByte();
+    // Map acmod (audio coding mode) onto a channel count.
+    int channelCount = CHANNEL_COUNTS[(nextByte & 0x0E) >> 1];
+    // lfeon (low frequency effects on)
+    if ((nextByte & 0x01) != 0) {
+      channelCount++;
+    }
+    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_EC3, MediaFormat.NO_VALUE,
+        channelCount, sampleRate, Collections.<byte[]>emptyList());
+  }
+
+  /**
+   * Returns the AC-3 format given {@code data} containing the frame header starting from the sync
+   * word.
+   *
+   * @param data Data to parse, positioned at the start of the syncword.
+   * @return AC-3 format parsed from data in the header.
+   */
+  public static MediaFormat parseFrameAc3Format(ParsableBitArray data) {
+    // Skip syncword and crc1.
+    data.skipBits(4 * 8);
+
+    int fscod = data.readBits(2);
+    data.skipBits(14); // frmsizecod(6) + bsid (5 bits) + bsmod (3 bits)
+    int acmod = data.readBits(3);
+    if ((acmod & 0x01) != 0 && acmod != 1) {
+      data.skipBits(2); // cmixlev
+    }
+    if ((acmod & 0x04) != 0) {
+      data.skipBits(2); // surmixlev
+    }
+    if (acmod == 0x02) {
+      data.skipBits(2); // dsurmod
+    }
+    boolean lfeon = data.readBit();
+    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0), SAMPLE_RATES[fscod],
+        Collections.<byte[]>emptyList());
+  }
+
+  /**
+   * Returns the AC-3 frame size in bytes given {@code data} containing the frame header starting
+   * from the sync word.
+   *
+   * @param data Data to parse, positioned at the start of the syncword.
+   * @return The frame size parsed from data in the header.
+   */
+  public static int parseFrameSize(ParsableBitArray data) {
+    // Skip syncword and crc1.
+    data.skipBits(4 * 8);
+
+    int fscod = data.readBits(2);
+    int frmsizecod = data.readBits(6);
+    int sampleRate = SAMPLE_RATES[fscod];
+    int bitrate = BITRATES[frmsizecod / 2];
+    if (sampleRate == 32000) {
+      return 6 * bitrate;
+    } else if (sampleRate == 44100) {
+      return 2 * (FRMSIZECOD_TO_FRAME_SIZE_44_1[frmsizecod / 2] + (frmsizecod % 2));
+    } else { // sampleRate == 48000
+      return 4 * bitrate;
+    }
+  }
+
+  /**
+   * Returns the bitrate of AC-3 audio given the size of a buffer and the sample rate.
+   *
+   * @param bufferSize Size in bytes of a full buffer of samples.
+   * @param sampleRate Sample rate in hz.
+   * @return Bitrate of the audio stream in kbit/s.
+   */
+  public static int getBitrate(int bufferSize, int sampleRate) {
+    // Each AC-3 buffer contains 1536 frames of audio, so the AudioTrack playback position
+    // advances by 1536 per buffer (32 ms at 48 kHz).
+    int unscaledBitrate = bufferSize * 8 * sampleRate;
+    int divisor = 1000 * 1536;
+    return (unscaledBitrate + divisor / 2) / divisor;
+  }
+
+  private Ac3Util() {
+    // Prevent instantiation.
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java b/library/src/main/java/com/google/android/exoplayer/util/H264Util.java
similarity index 54%
rename from library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java
rename to library/src/main/java/com/google/android/exoplayer/util/H264Util.java
index ea41e3a2cf..0cde8b472f 100644
--- a/library/src/main/java/com/google/android/exoplayer/mp4/Mp4Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/H264Util.java
@@ -13,67 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.mp4;
-
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.ParsableByteArray;
+package com.google.android.exoplayer.util;
 
 import java.nio.ByteBuffer;
 
 /**
- * Utility methods and constants for parsing fragmented and unfragmented MP4 files.
+ * Utility methods for handling H264 data.
  */
-public final class Mp4Util {
-
-  /** Size of an atom header, in bytes. */
-  public static final int ATOM_HEADER_SIZE = 8;
-
-  /** Size of a long atom header, in bytes. */
-  public static final int LONG_ATOM_HEADER_SIZE = 16;
-
-  /** Size of a full atom header, in bytes. */
-  public static final int FULL_ATOM_HEADER_SIZE = 12;
-
-  /** Value for the first 32 bits of atomSize when the atom size is actually a long value. */
-  public static final int LONG_ATOM_SIZE = 1;
-
-  /** Sample index when no sample is available. */
-  public static final int NO_SAMPLE = -1;
-
-  /** Track index when no track is selected. */
-  public static final int NO_TRACK = -1;
+public final class H264Util {
 
   /** Four initial bytes that must prefix H.264/AVC NAL units for decoding. */
-  private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
-
-  /** Parses the version number out of the additional integer component of a full atom. */
-  public static int parseFullAtomVersion(int fullAtomInt) {
-    return 0x000000FF & (fullAtomInt >> 24);
-  }
-
-  /** Parses the atom flags out of the additional integer component of a full atom. */
-  public static int parseFullAtomFlags(int fullAtomInt) {
-    return 0x00FFFFFF & fullAtomInt;
-  }
-
-  /**
-   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
-   * assumed that the top bit will always be set to zero.
-   *
-   * @throws IllegalArgumentException If the top bit of the input data is set.
-   */
-  public static int readUnsignedIntToInt(ByteBuffer data) {
-    int result = 0xFF & data.get();
-    for (int i = 1; i < 4; i++) {
-      result <<= 8;
-      result |= 0xFF & data.get();
-    }
-    if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
-    }
-    return result;
-  }
+  public static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
   /**
    * Replaces length prefixes of NAL units in {@code buffer} with start code prefixes, within the
@@ -92,52 +42,50 @@ public static void replaceLengthPrefixesWithAvcStartCodes(ByteBuffer buffer, int
     buffer.position(sampleOffset + size);
   }
 
-  /** Constructs and returns a NAL unit with a start code followed by the data in {@code atom}. */
+  /**
+   * Constructs and returns a NAL unit with a start code followed by the data in {@code atom}.
+   */
   public static byte[] parseChildNalUnit(ParsableByteArray atom) {
     int length = atom.readUnsignedShort();
     int offset = atom.getPosition();
-    atom.skip(length);
+    atom.skipBytes(length);
     return CodecSpecificDataUtil.buildNalUnit(atom.data, offset, length);
   }
 
   /**
-   * Finds the first NAL unit in {@code data}.
-   * <p>
-   * For a NAL unit to be found, its first four bytes must be contained within the part of the
-   * array being searched.
+   * Gets the type of the NAL unit in {@code data} that starts at {@code offset}.
    *
    * @param data The data to search.
-   * @param startOffset The offset (inclusive) in the data to start the search.
-   * @param endOffset The offset (exclusive) in the data to end the search.
-   * @param type The type of the NAL unit to search for, or -1 for any NAL unit.
-   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
+   * @param offset The start offset of a NAL unit. Must lie between {@code -3} (inclusive) and
+   *     {@code data.length - 3} (exclusive).
+   * @return The type of the unit.
    */
-  public static int findNalUnit(byte[] data, int startOffset, int endOffset, int type) {
-    return findNalUnit(data, startOffset, endOffset, type, null);
+  public static int getNalUnitType(byte[] data, int offset) {
+    return data[offset + 3] & 0x1F;
   }
 
   /**
-   * Like {@link #findNalUnit(byte[], int, int, int)}, but supports finding of NAL units across
-   * array boundaries.
+   * Finds the first NAL unit in {@code data}.
    * <p>
-   * To use this method, pass the same {@code prefixFlags} parameter to successive calls where the
-   * data passed represents a contiguous stream. The state maintained in this parameter allows the
-   * detection of NAL units where the NAL unit prefix spans array boundaries.
+   * If {@code prefixFlags} is null then the first four bytes of a NAL unit must be entirely
+   * contained within the part of the array being searched in order for it to be found.
    * <p>
-   * Note that when using {@code prefixFlags} the return value may be 3, 2 or 1 less than
-   * {@code startOffset}, to indicate a NAL unit starting 3, 2 or 1 bytes before the first byte in
-   * the current array.
+   * When {@code prefixFlags} is non-null, this method supports finding NAL units whose first four
+   * bytes span {@code data} arrays passed to successive calls. To use this feature, pass the same
+   * {@code prefixFlags} parameter to successive calls. State maintained in this parameter enables
+   * the detection of such NAL units. Note that when using this feature, the return value may be 3,
+   * 2 or 1 less than {@code startOffset}, to indicate a NAL unit starting 3, 2 or 1 bytes before
+   * the first byte in the current array.
    *
    * @param data The data to search.
    * @param startOffset The offset (inclusive) in the data to start the search.
    * @param endOffset The offset (exclusive) in the data to end the search.
-   * @param type The type of the NAL unit to search for, or -1 for any NAL unit.
    * @param prefixFlags A boolean array whose first three elements are used to store the state
    *     required to detect NAL units where the NAL unit prefix spans array boundaries. The array
    *     must be at least 3 elements long.
    * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
    */
-  public static int findNalUnit(byte[] data, int startOffset, int endOffset, int type,
+  public static int findNalUnit(byte[] data, int startOffset, int endOffset,
       boolean[] prefixFlags) {
     int length = endOffset - startOffset;
 
@@ -147,15 +95,14 @@ public static int findNalUnit(byte[] data, int startOffset, int endOffset, int t
     }
 
     if (prefixFlags != null) {
-      if (prefixFlags[0] && matchesType(data, startOffset, type)) {
+      if (prefixFlags[0]) {
         clearPrefixFlags(prefixFlags);
         return startOffset - 3;
-      } else if (length > 1 && prefixFlags[1] && data[startOffset] == 1
-          && matchesType(data, startOffset + 1, type)) {
+      } else if (length > 1 && prefixFlags[1] && data[startOffset] == 1) {
         clearPrefixFlags(prefixFlags);
         return startOffset - 2;
       } else if (length > 2 && prefixFlags[2] && data[startOffset] == 0
-          && data[startOffset + 1] == 1 && matchesType(data, startOffset + 2, type)) {
+          && data[startOffset + 1] == 1) {
         clearPrefixFlags(prefixFlags);
         return startOffset - 1;
       }
@@ -169,8 +116,7 @@ public static int findNalUnit(byte[] data, int startOffset, int endOffset, int t
       if ((data[i] & 0xFE) != 0) {
         // There isn't a NAL prefix here, or at the next two positions. Do nothing and let the
         // loop advance the index by three.
-      } else if (data[i - 2] == 0 && data[i - 1] == 0 && data[i] == 1
-          && matchesType(data, i + 1, type)) {
+      } else if (data[i - 2] == 0 && data[i - 1] == 0 && data[i] == 1) {
         if (prefixFlags != null) {
           clearPrefixFlags(prefixFlags);
         }
@@ -199,59 +145,36 @@ public static int findNalUnit(byte[] data, int startOffset, int endOffset, int t
   }
 
   /**
-   * Like {@link #findNalUnit(byte[], int, int, int)} with {@code type == -1}.
-   *
-   * @param data The data to search.
-   * @param startOffset The offset (inclusive) in the data to start the search.
-   * @param endOffset The offset (exclusive) in the data to end the search.
-   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
-   */
-  public static int findNalUnit(byte[] data, int startOffset, int endOffset) {
-    return findNalUnit(data, startOffset, endOffset, null);
-  }
-
-  /**
-   * Like {@link #findNalUnit(byte[], int, int, int, boolean[])} with {@code type == -1}.
-   *
-   * @param data The data to search.
-   * @param startOffset The offset (inclusive) in the data to start the search.
-   * @param endOffset The offset (exclusive) in the data to end the search.
-   * @param prefixFlags A boolean array of length at least 3.
-   * @return The offset of the NAL unit, or {@code endOffset} if a NAL unit was not found.
-   */
-  public static int findNalUnit(byte[] data, int startOffset, int endOffset,
-      boolean[] prefixFlags) {
-    return findNalUnit(data, startOffset, endOffset, -1, prefixFlags);
-  }
-
-  /**
-   * Gets the type of the NAL unit in {@code data} that starts at {@code offset}.
-   *
-   * @param data The data to search.
-   * @param offset The start offset of a NAL unit. Must lie between {@code -3} (inclusive) and
-   *     {@code data.length - 3} (exclusive).
-   * @return The type of the unit.
-   */
-  public static int getNalUnitType(byte[] data, int offset) {
-    return data[offset + 3] & 0x1F;
-  }
-
-  /**
-   * Clears prefix flags, as used by {@link #findNalUnit(byte[], int, int, int, boolean[])}.
+   * Clears prefix flags, as used by {@link #findNalUnit(byte[], int, int, boolean[])}.
    *
    * @param prefixFlags The flags to clear.
    */
-  private static void clearPrefixFlags(boolean[] prefixFlags) {
+  public static void clearPrefixFlags(boolean[] prefixFlags) {
     prefixFlags[0] = false;
     prefixFlags[1] = false;
     prefixFlags[2] = false;
   }
 
   /**
-   * Returns true if the type at {@code offset} is equal to {@code type}, or if {@code type == -1}.
+   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
+   * assumed that the top bit will always be set to zero.
+   *
+   * @throws IllegalArgumentException If the top bit of the input data is set.
    */
-  private static boolean matchesType(byte[] data, int offset, int type) {
-    return type == -1 || (data[offset] & 0x1F) == type;
+  private static int readUnsignedIntToInt(ByteBuffer data) {
+    int result = 0xFF & data.get();
+    for (int i = 1; i < 4; i++) {
+      result <<= 8;
+      result |= 0xFF & data.get();
+    }
+    if (result < 0) {
+      throw new IllegalArgumentException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
+  private H264Util() {
+    // Prevent instantiation.
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
index 9aed794b22..a626ec20c3 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
@@ -17,6 +17,8 @@
 
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
+import com.google.android.exoplayer.upstream.UriDataSource;
+import com.google.android.exoplayer.upstream.UriLoadable;
 
 import android.os.Handler;
 import android.os.Looper;
@@ -24,13 +26,22 @@
 import android.util.Pair;
 
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.net.URLConnection;
 import java.util.concurrent.CancellationException;
 
 /**
  * Performs both single and repeated loads of media manifests.
+ * <p>
+ * Client code is responsible for ensuring that only one load is taking place at any one time.
+ * Typical usage of this class is as follows:
+ * <ol>
+ * <li>Create an instance.</li>
+ * <li>Obtain an initial manifest by calling {@link #singleLoad(Looper, ManifestCallback)} and
+ *     waiting for the callback to be invoked.</li>
+ * <li>For on-demand playbacks, the loader is no longer required. For live playbacks, the loader
+ *     may be required to periodically refresh the manifest. In this case it is injected into any
+ *     components that require it. These components will call {@link #requestRefresh()} on the
+ *     loader whenever a refresh is required.</li>
+ * </ol>
  *
  * @param <T> The type of manifest.
  */
@@ -59,24 +70,21 @@
     /**
      * Invoked when the load has successfully completed.
      *
-     * @param contentId The content id of the media.
      * @param manifest The loaded manifest.
      */
-    void onManifest(String contentId, T manifest);
+    void onSingleManifest(T manifest);
 
     /**
      * Invoked when the load has failed.
      *
-     * @param contentId The content id of the media.
      * @param e The cause of the failure.
      */
-    void onManifestError(String contentId, IOException e);
+    void onSingleManifestError(IOException e);
 
   }
 
-  /* package */ final ManifestParser<T> parser;
-  /* package */ final String contentId;
-  /* package */ final String userAgent;
+  private final UriLoadable.Parser<T> parser;
+  private final UriDataSource uriDataSource;
   private final Handler eventHandler;
   private final EventListener eventListener;
 
@@ -84,7 +92,7 @@
 
   private int enabledCount;
   private Loader loader;
-  private ManifestLoadable currentLoadable;
+  private UriLoadable<T> currentLoadable;
 
   private int loadExceptionCount;
   private long loadExceptionTimestamp;
@@ -93,23 +101,29 @@
   private volatile T manifest;
   private volatile long manifestLoadTimestamp;
 
-  public ManifestFetcher(ManifestParser<T> parser, String contentId, String manifestUrl,
-      String userAgent) {
-    this(parser, contentId, manifestUrl, userAgent, null, null);
+  /**
+   * @param manifestUrl The manifest location.
+   * @param uriDataSource The {@link UriDataSource} to use when loading the manifest.
+   * @param parser A parser to parse the loaded manifest data.
+   */
+  public ManifestFetcher(String manifestUrl, UriDataSource uriDataSource,
+      UriLoadable.Parser<T> parser) {
+    this(manifestUrl, uriDataSource, parser, null, null);
   }
 
   /**
-   * @param parser A parser to parse the loaded manifest data.
-   * @param contentId The content id of the content being loaded. May be null.
    * @param manifestUrl The manifest location.
-   * @param userAgent The User-Agent string that should be used.
+   * @param uriDataSource The {@link UriDataSource} to use when loading the manifest.
+   * @param parser A parser to parse the loaded manifest data.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public ManifestFetcher(ManifestParser<T> parser, String contentId, String manifestUrl,
-      String userAgent, Handler eventHandler, EventListener eventListener) {
+  public ManifestFetcher(String manifestUrl, UriDataSource uriDataSource,
+      UriLoadable.Parser<T> parser, Handler eventHandler, EventListener eventListener) {
     this.parser = parser;
-    this.contentId = contentId;
     this.manifestUrl = manifestUrl;
-    this.userAgent = userAgent;
+    this.uriDataSource = uriDataSource;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
   }
@@ -131,7 +145,8 @@ public void updateManifestUrl(String manifestUrl) {
    * @param callback The callback to receive the result.
    */
   public void singleLoad(Looper callbackLooper, final ManifestCallback<T> callback) {
-    SingleFetchHelper fetchHelper = new SingleFetchHelper(callbackLooper, callback);
+    SingleFetchHelper fetchHelper = new SingleFetchHelper(
+        new UriLoadable<T>(manifestUrl, uriDataSource, parser), callbackLooper, callback);
     fetchHelper.startLoading();
   }
 
@@ -204,7 +219,7 @@ public void requestRefresh() {
       loader = new Loader("manifestLoader");
     }
     if (!loader.isLoading()) {
-      currentLoadable = new ManifestLoadable();
+      currentLoadable = new UriLoadable<T>(manifestUrl, uriDataSource, parser);
       loader.startLoading(currentLoadable, this);
       notifyManifestRefreshStarted();
     }
@@ -217,7 +232,7 @@ public void onLoadCompleted(Loadable loadable) {
       return;
     }
 
-    manifest = currentLoadable.result;
+    manifest = currentLoadable.getResult();
     manifestLoadTimestamp = SystemClock.elapsedRealtime();
     loadExceptionCount = 0;
     loadException = null;
@@ -244,6 +259,11 @@ public void onLoadError(Loadable loadable, IOException exception) {
     notifyManifestError(loadException);
   }
 
+  /* package */ void onSingleFetchCompleted(T result) {
+    manifest = result;
+    manifestLoadTimestamp = SystemClock.elapsedRealtime();
+  }
+
   private long getRetryDelayMillis(long errorCount) {
     return Math.min((errorCount - 1) * 1000, 5000);
   }
@@ -283,16 +303,17 @@ public void run() {
 
   private class SingleFetchHelper implements Loader.Callback {
 
+    private final UriLoadable<T> singleUseLoadable;
     private final Looper callbackLooper;
     private final ManifestCallback<T> wrappedCallback;
     private final Loader singleUseLoader;
-    private final ManifestLoadable singleUseLoadable;
 
-    public SingleFetchHelper(Looper callbackLooper, ManifestCallback<T> wrappedCallback) {
+    public SingleFetchHelper(UriLoadable<T> singleUseLoadable, Looper callbackLooper,
+        ManifestCallback<T> wrappedCallback) {
+      this.singleUseLoadable = singleUseLoadable;
       this.callbackLooper = callbackLooper;
       this.wrappedCallback = wrappedCallback;
       singleUseLoader = new Loader("manifestLoader:single");
-      singleUseLoadable = new ManifestLoadable();
     }
 
     public void startLoading() {
@@ -302,9 +323,9 @@ public void startLoading() {
     @Override
     public void onLoadCompleted(Loadable loadable) {
       try {
-        manifest = singleUseLoadable.result;
-        manifestLoadTimestamp = SystemClock.elapsedRealtime();
-        wrappedCallback.onManifest(contentId, singleUseLoadable.result);
+        T result = singleUseLoadable.getResult();
+        onSingleFetchCompleted(result);
+        wrappedCallback.onSingleManifest(result);
       } finally {
         releaseLoader();
       }
@@ -315,7 +336,7 @@ public void onLoadCanceled(Loadable loadable) {
       // This shouldn't ever happen, but handle it anyway.
       try {
         IOException exception = new IOException("Load cancelled", new CancellationException());
-        wrappedCallback.onManifestError(contentId, exception);
+        wrappedCallback.onSingleManifestError(exception);
       } finally {
         releaseLoader();
       }
@@ -324,7 +345,7 @@ public void onLoadCanceled(Loadable loadable) {
     @Override
     public void onLoadError(Loadable loadable, IOException exception) {
       try {
-        wrappedCallback.onManifestError(contentId, exception);
+        wrappedCallback.onSingleManifestError(exception);
       } finally {
         releaseLoader();
       }
@@ -336,52 +357,4 @@ private void releaseLoader() {
 
   }
 
-  private class ManifestLoadable implements Loadable {
-
-    private static final int TIMEOUT_MILLIS = 10000;
-
-    /* package */ volatile T result;
-    private volatile boolean isCanceled;
-
-    @Override
-    public void cancelLoad() {
-      // We don't actually cancel anything, but we need to record the cancellation so that
-      // isLoadCanceled can return the correct value.
-      isCanceled = true;
-    }
-
-    @Override
-    public boolean isLoadCanceled() {
-      return isCanceled;
-    }
-
-    @Override
-    public void load() throws IOException, InterruptedException {
-      String inputEncoding;
-      InputStream inputStream = null;
-      try {
-        URLConnection connection = configureConnection(new URL(manifestUrl));
-        inputStream = connection.getInputStream();
-        inputEncoding = connection.getContentEncoding();
-        result = parser.parse(inputStream, inputEncoding, contentId,
-            Util.parseBaseUri(connection.getURL().toString()));
-      } finally {
-        if (inputStream != null) {
-          inputStream.close();
-        }
-      }
-    }
-
-    private URLConnection configureConnection(URL url) throws IOException {
-      URLConnection connection = url.openConnection();
-      connection.setConnectTimeout(TIMEOUT_MILLIS);
-      connection.setReadTimeout(TIMEOUT_MILLIS);
-      connection.setDoOutput(false);
-      connection.setRequestProperty("User-Agent", userAgent);
-      connection.connect();
-      return connection;
-    }
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestParser.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestParser.java
deleted file mode 100644
index ba997a9f77..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestParser.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.util;
-
-import com.google.android.exoplayer.ParserException;
-
-import android.net.Uri;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Parses a manifest from an {@link InputStream}.
- *
- * @param <T> The type of the manifest being parsed.
- */
-public interface ManifestParser<T> {
-
-  /**
-   * Parses a manifest from an {@link InputStream}.
-   *
-   * @param inputStream The input stream to consume.
-   * @param inputEncoding The encoding of the input stream. May be null if the input encoding is
-   *     unknown.
-   * @param contentId The content id to which the manifest corresponds. May be null.
-   * @param baseUri If the manifest contains relative uris, this is the uri they are relative to.
-   *     May be null.
-   * @return The parsed manifest.
-   * @throws IOException If an error occurs reading the data.
-   * @throws ParserException If an error occurs parsing the data.
-   */
-  T parse(InputStream inputStream, String inputEncoding, String contentId, Uri baseUri)
-      throws IOException, ParserException;
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 11d49103e7..3a6ea01c6f 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -15,6 +15,11 @@
  */
 package com.google.android.exoplayer.util;
 
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.audio.AudioCapabilities;
+
+import android.media.AudioFormat;
+
 /**
  * Defines common MIME types and helper methods.
  */
@@ -28,14 +33,21 @@
   public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
   public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
   public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
+  public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
   public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
 
   public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
   public static final String AUDIO_AAC = BASE_TYPE_AUDIO + "/mp4a-latm";
+  public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
+  public static final String AUDIO_MPEG = BASE_TYPE_AUDIO + "/mpeg";
+  public static final String AUDIO_MPEG_L1 = BASE_TYPE_AUDIO + "/mpeg-L1";
+  public static final String AUDIO_MPEG_L2 = BASE_TYPE_AUDIO + "/mpeg-L2";
+
+  public static final String AUDIO_RAW = BASE_TYPE_AUDIO + "/raw";
   public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
   public static final String AUDIO_EC3 = BASE_TYPE_AUDIO + "/eac3";
-  public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
+
   public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
   public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
 
@@ -44,6 +56,7 @@
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_EIA608 = BASE_TYPE_APPLICATION + "/eia-608";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
+  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
 
   private MimeTypes() {}
 
@@ -111,4 +124,37 @@ public static boolean isTtml(String mimeType) {
     return mimeType.equals(APPLICATION_TTML);
   }
 
+  /**
+   * Returns the output audio encoding that will result from processing input in {@code mimeType}.
+   * For non-passthrough audio formats, this is always {@link AudioFormat#ENCODING_PCM_16BIT}. For
+   * passthrough formats it will be one of {@link AudioFormat}'s other {@code ENCODING_*} constants.
+   * For non-audio formats, {@link AudioFormat#ENCODING_INVALID} will be returned.
+   *
+   * @param mimeType The MIME type of media that will be decoded (or passed through).
+   * @return The corresponding {@link AudioFormat} encoding.
+   */
+  public static int getEncodingForMimeType(String mimeType) {
+    if (AUDIO_AC3.equals(mimeType)) {
+      return C.ENCODING_AC3;
+    }
+    if (AUDIO_EC3.equals(mimeType)) {
+      return C.ENCODING_E_AC3;
+    }
+
+    // All other audio formats will be decoded to 16-bit PCM.
+    return isAudio(mimeType) ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_INVALID;
+  }
+
+  /**
+   * Returns whether the specified {@code mimeType} represents audio that can be played via
+   * passthrough if the device supports it.
+   *
+   * @param mimeType The MIME type of input media.
+   * @return Whether the audio can be played via passthrough. If this method returns {@code true},
+   *     it is still necessary to check the {@link AudioCapabilities} for device support.
+   */
+  public static boolean isPassthroughAudio(String mimeType) {
+    return AUDIO_AC3.equals(mimeType) || AUDIO_EC3.equals(mimeType);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
index a1f224a1f0..98e4cc7160 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
@@ -20,7 +20,7 @@
  */
 public final class ParsableBitArray {
 
-  private byte[] data;
+  public byte[] data;
 
   // The offset within the data, stored as the current byte offset, and the bit offset within that
   // byte (from 0 to 7).
@@ -50,15 +50,6 @@ public void reset(byte[] data) {
     bitOffset = 0;
   }
 
-  /**
-   * Gets the backing byte array.
-   *
-   * @return The backing byte array.
-   */
-  public byte[] getData() {
-    return data;
-  }
-
   /**
    * Gets the current bit offset.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 72b2552722..563b9ebe13 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -37,6 +37,12 @@ public ParsableByteArray(int length) {
     limit = data.length;
   }
 
+  /** Creates a new instance wrapping {@code data}. */
+  public ParsableByteArray(byte[] data) {
+    this.data = data;
+    limit = data.length;
+  }
+
   /**
    * Creates a new instance that wraps an existing array.
    *
@@ -117,9 +123,7 @@ public void setPosition(int position) {
    * @throws IllegalArgumentException Thrown if the new position is neither in nor at the end of the
    *     array.
    */
-  // TODO: Rename to skipBytes so that it's clearer how much data is being skipped in code where
-  // both ParsableBitArray and ParsableByteArray are in use.
-  public void skip(int bytes) {
+  public void skipBytes(int bytes) {
     setPosition(position + bytes);
   }
 
@@ -130,10 +134,8 @@ public void skip(int bytes) {
    * @param bitArray The {@link ParsableBitArray} into which the bytes should be read.
    * @param length The number of bytes to write.
    */
-  // TODO: It's possible to have bitArray directly index into the same array as is being wrapped
-  // by this instance. Decide whether it's worth doing this.
   public void readBytes(ParsableBitArray bitArray, int length) {
-    readBytes(bitArray.getData(), 0, length);
+    readBytes(bitArray.data, 0, length);
     bitArray.setPosition(0);
   }
 
@@ -159,43 +161,55 @@ public void readBytes(ByteBuffer buffer, int length) {
 
   /** Reads the next byte as an unsigned value. */
   public int readUnsignedByte() {
-    int result = shiftIntoInt(data, position, 1);
-    position += 1;
-    return result;
+    return (data[position++] & 0xFF);
   }
 
   /** Reads the next two bytes as an unsigned value. */
   public int readUnsignedShort() {
-    int result = shiftIntoInt(data, position, 2);
-    position += 2;
-    return result;
+    return (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF);
+  }
+
+  /** Reads the next three bytes as an unsigned value. */
+  public int readUnsignedInt24() {
+    return (data[position++] & 0xFF) << 16
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF);
   }
 
   /** Reads the next four bytes as an unsigned value. */
   public long readUnsignedInt() {
-    long result = shiftIntoLong(data, position, 4);
-    position += 4;
-    return result;
+    return (data[position++] & 0xFFL) << 24
+        | (data[position++] & 0xFFL) << 16
+        | (data[position++] & 0xFFL) << 8
+        | (data[position++] & 0xFFL);
   }
 
   /** Reads the next four bytes as a signed value. */
   public int readInt() {
-    int result = shiftIntoInt(data, position, 4);
-    position += 4;
-    return result;
+    return (data[position++] & 0xFF) << 24
+        | (data[position++] & 0xFF) << 16
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF);
   }
 
   /** Reads the next eight bytes as a signed value. */
   public long readLong() {
-    long result = shiftIntoLong(data, position, 8);
-    position += 8;
-    return result;
+    return (data[position++] & 0xFFL) << 56
+        | (data[position++] & 0xFFL) << 48
+        | (data[position++] & 0xFFL) << 40
+        | (data[position++] & 0xFFL) << 32
+        | (data[position++] & 0xFFL) << 24
+        | (data[position++] & 0xFFL) << 16
+        | (data[position++] & 0xFFL) << 8
+        | (data[position++] & 0xFFL);
   }
 
   /** Reads the next four bytes, returning the integer portion of the fixed point 16.16 integer. */
   public int readUnsignedFixedPoint1616() {
-    int result = shiftIntoInt(data, position, 2);
-    position += 4;
+    int result = (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF);
+    position += 2; // Skip the non-integer portion.
     return result;
   }
 
@@ -218,13 +232,12 @@ public int readSynchSafeInt() {
   /**
    * Reads the next four bytes as an unsigned integer into an integer, if the top bit is a zero.
    *
-   * @throws IllegalArgumentException Thrown if the top bit of the input data is set.
+   * @throws IllegalStateException Thrown if the top bit of the input data is set.
    */
   public int readUnsignedIntToInt() {
-    int result = shiftIntoInt(data, position, 4);
-    position += 4;
+    int result = readInt();
     if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
+      throw new IllegalStateException("Top bit not zero: " + result);
     }
     return result;
   }
@@ -232,33 +245,12 @@ public int readUnsignedIntToInt() {
   /**
    * Reads the next eight bytes as an unsigned long into a long, if the top bit is a zero.
    *
-   * @throws IllegalArgumentException Thrown if the top bit of the input data is set.
+   * @throws IllegalStateException Thrown if the top bit of the input data is set.
    */
   public long readUnsignedLongToLong() {
-    long result = shiftIntoLong(data, position, 8);
-    position += 8;
+    long result = readLong();
     if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
-    }
-    return result;
-  }
-
-  /** Reads {@code length} bytes into an int at {@code offset} in {@code bytes}. */
-  private static int shiftIntoInt(byte[] bytes, int offset, int length) {
-    int result = 0xFF & bytes[offset];
-    for (int i = offset + 1; i < offset + length; i++) {
-      result <<= 8;
-      result |= 0xFF & bytes[i];
-    }
-    return result;
-  }
-
-  /** Reads {@code length} bytes into a long at {@code offset} in {@code bytes}. */
-  private static long shiftIntoLong(byte[] bytes, int offset, int length) {
-    long result = 0xFF & bytes[offset];
-    for (int i = offset + 1; i < offset + length; i++) {
-      result <<= 8;
-      result |= 0xFF & bytes[i];
+      throw new IllegalStateException("Top bit not zero: " + result);
     }
     return result;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/UriUtil.java b/library/src/main/java/com/google/android/exoplayer/util/UriUtil.java
new file mode 100644
index 0000000000..61eb8fa0a4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/UriUtil.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import android.net.Uri;
+import android.text.TextUtils;
+
+/**
+ * Utility methods for manipulating URIs.
+ */
+public final class UriUtil {
+
+  /**
+   * The length of arrays returned by {@link #getUriIndices(String)}.
+   */
+  private static final int INDEX_COUNT = 4;
+  /**
+   * An index into an array returned by {@link #getUriIndices(String)}.
+   * <p>
+   * The value at this position in the array is the index of the ':' after the scheme. Equals -1 if
+   * the URI is a relative reference (no scheme). The hier-part starts at (schemeColon + 1),
+   * including when the URI has no scheme.
+   */
+  private static final int SCHEME_COLON = 0;
+  /**
+   * An index into an array returned by {@link #getUriIndices(String)}.
+   * <p>
+   * The value at this position in the array is the index of the path part. Equals (schemeColon + 1)
+   * if no authority part, (schemeColon + 3) if the authority part consists of just "//", and
+   * (query) if no path part. The characters starting at this index can be "//" only if the
+   * authority part is non-empty (in this case the double-slash means the first segment is empty).
+   */
+  private static final int PATH = 1;
+  /**
+   * An index into an array returned by {@link #getUriIndices(String)}.
+   * <p>
+   * The value at this position in the array is the index of the query part, including the '?'
+   * before the query. Equals fragment if no query part, and (fragment - 1) if the query part is a
+   * single '?' with no data.
+   */
+  private static final int QUERY = 2;
+  /**
+   * An index into an array returned by {@link #getUriIndices(String)}.
+   * <p>
+   * The value at this position in the array is the index of the fragment part, including the '#'
+   * before the fragment. Equal to the length of the URI if no fragment part, and (length - 1) if
+   * the fragment part is a single '#' with no data.
+   */
+  private static final int FRAGMENT = 3;
+
+  private UriUtil() {}
+
+  /**
+   * Like {@link #resolve(String, String)}, but returns a {@link Uri} instead of a {@link String}.
+   *
+   * @param baseUri The base URI.
+   * @param referenceUri The reference URI to resolve.
+   */
+  public static Uri resolveToUri(String baseUri, String referenceUri) {
+    return Uri.parse(resolve(baseUri, referenceUri));
+  }
+
+  /**
+   * Performs relative resolution of a {@code referenceUri} with respect to a {@code baseUri}.
+   * <p>
+   * The resolution is performed as specified by RFC-3986.
+   *
+   * @param baseUri The base URI.
+   * @param referenceUri The reference URI to resolve.
+   */
+  public static String resolve(String baseUri, String referenceUri) {
+    StringBuilder uri = new StringBuilder();
+
+    // Map null onto empty string, to make the following logic simpler.
+    baseUri = baseUri == null ? "" : baseUri;
+    referenceUri = referenceUri == null ? "" : referenceUri;
+
+    int[] refIndices = getUriIndices(referenceUri);
+    if (refIndices[SCHEME_COLON] != -1) {
+      // The reference is absolute. The target Uri is the reference.
+      uri.append(referenceUri);
+      removeDotSegments(uri, refIndices[PATH], refIndices[QUERY]);
+      return uri.toString();
+    }
+
+    int[] baseIndices = getUriIndices(baseUri);
+    if (refIndices[FRAGMENT] == 0) {
+      // The reference is empty or contains just the fragment part, then the target Uri is the
+      // concatenation of the base Uri without its fragment, and the reference.
+      return uri.append(baseUri, 0, baseIndices[FRAGMENT]).append(referenceUri).toString();
+    }
+
+    if (refIndices[QUERY] == 0) {
+      // The reference starts with the query part. The target is the base up to (but excluding) the
+      // query, plus the reference.
+      return uri.append(baseUri, 0, baseIndices[QUERY]).append(referenceUri).toString();
+    }
+
+    if (refIndices[PATH] != 0) {
+      // The reference has authority. The target is the base scheme plus the reference.
+      int baseLimit = baseIndices[SCHEME_COLON] + 1;
+      uri.append(baseUri, 0, baseLimit).append(referenceUri);
+      return removeDotSegments(uri, baseLimit + refIndices[PATH], baseLimit + refIndices[QUERY]);
+    }
+
+    if (refIndices[PATH] != refIndices[QUERY] && referenceUri.charAt(refIndices[PATH]) == '/') {
+      // The reference path is rooted. The target is the base scheme and authority (if any), plus
+      // the reference.
+      uri.append(baseUri, 0, baseIndices[PATH]).append(referenceUri);
+      return removeDotSegments(uri, baseIndices[PATH], baseIndices[PATH] + refIndices[QUERY]);
+    }
+
+    // The target Uri is the concatenation of the base Uri up to (but excluding) the last segment,
+    // and the reference. This can be split into 2 cases:
+    if (baseIndices[SCHEME_COLON] + 2 < baseIndices[PATH]
+        && baseIndices[PATH] == baseIndices[QUERY]) {
+      // Case 1: The base hier-part is just the authority, with an empty path. An additional '/' is
+      // needed after the authority, before appending the reference.
+      uri.append(baseUri, 0, baseIndices[PATH]).append('/').append(referenceUri);
+      return removeDotSegments(uri, baseIndices[PATH], baseIndices[PATH] + refIndices[QUERY] + 1);
+    } else {
+      // Case 2: Otherwise, find the last '/' in the base hier-part and append the reference after
+      // it. If base hier-part has no '/', it could only mean that it is completely empty or
+      // contains only one segment, in which case the whole hier-part is excluded and the reference
+      // is appended right after the base scheme colon without an added '/'.
+      int lastSlashIndex = baseUri.lastIndexOf('/', baseIndices[QUERY] - 1);
+      int baseLimit = lastSlashIndex == -1 ? baseIndices[PATH] : lastSlashIndex + 1;
+      uri.append(baseUri, 0, baseLimit).append(referenceUri);
+      return removeDotSegments(uri, baseIndices[PATH], baseLimit + refIndices[QUERY]);
+    }
+  }
+
+  /**
+   * Removes dot segments from the path of a URI.
+   *
+   * @param uri A {@link StringBuilder} containing the URI.
+   * @param offset The index of the start of the path in {@code uri}.
+   * @param limit The limit (exclusive) of the path in {@code uri}.
+   */
+  private static String removeDotSegments(StringBuilder uri, int offset, int limit) {
+    if (offset >= limit) {
+      // Nothing to do.
+      return uri.toString();
+    }
+    if (uri.charAt(offset) == '/') {
+      // If the path starts with a /, always retain it.
+      offset++;
+    }
+    // The first character of the current path segment.
+    int segmentStart = offset;
+    int i = offset;
+    while (i <= limit) {
+      int nextSegmentStart = -1;
+      if (i == limit) {
+        nextSegmentStart = i;
+      } else if (uri.charAt(i) == '/') {
+        nextSegmentStart = i + 1;
+      } else {
+        i++;
+        continue;
+      }
+      // We've encountered the end of a segment or the end of the path. If the final segment was
+      // "." or "..", remove the appropriate segments of the path.
+      if (i == segmentStart + 1 && uri.charAt(segmentStart) == '.') {
+        // Given "abc/def/./ghi", remove "./" to get "abc/def/ghi".
+        uri.delete(segmentStart, nextSegmentStart);
+        limit -= nextSegmentStart - segmentStart;
+        i = segmentStart;
+      } else if (i == segmentStart + 2 && uri.charAt(segmentStart) == '.'
+          && uri.charAt(segmentStart + 1) == '.') {
+        // Given "abc/def/../ghi", remove "def/../" to get "abc/ghi".
+        int prevSegmentStart = uri.lastIndexOf("/", segmentStart - 2) + 1;
+        int removeFrom = prevSegmentStart > offset ? prevSegmentStart : offset;
+        uri.delete(removeFrom, nextSegmentStart);
+        limit -= nextSegmentStart - removeFrom;
+        segmentStart = prevSegmentStart;
+        i = prevSegmentStart;
+      } else {
+        i++;
+        segmentStart = i;
+      }
+    }
+    return uri.toString();
+  }
+
+  /**
+   * Calculates indices of the constituent components of a URI.
+   *
+   * @param uriString The URI as a string.
+   * @return The corresponding indices.
+   */
+  private static int[] getUriIndices(String uriString) {
+    int[] indices = new int[INDEX_COUNT];
+    if (TextUtils.isEmpty(uriString)) {
+      indices[SCHEME_COLON] = -1;
+      return indices;
+    }
+
+    // Determine outer structure from right to left.
+    // Uri = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
+    int length = uriString.length();
+    int fragmentIndex = uriString.indexOf('#');
+    if (fragmentIndex == -1) {
+      fragmentIndex = length;
+    }
+    int queryIndex = uriString.indexOf('?');
+    if (queryIndex == -1 || queryIndex > fragmentIndex) {
+      // '#' before '?': '?' is within the fragment.
+      queryIndex = fragmentIndex;
+    }
+    // Slashes are allowed only in hier-part so any colon after the first slash is part of the
+    // hier-part, not the scheme colon separator.
+    int schemeIndexLimit = uriString.indexOf('/');
+    if (schemeIndexLimit == -1 || schemeIndexLimit > queryIndex) {
+      schemeIndexLimit = queryIndex;
+    }
+    int schemeIndex = uriString.indexOf(':');
+    if (schemeIndex > schemeIndexLimit) {
+      // '/' before ':'
+      schemeIndex = -1;
+    }
+
+    // Determine hier-part structure: hier-part = "//" authority path / path
+    // This block can also cope with schemeIndex == -1.
+    boolean hasAuthority = schemeIndex + 2 < queryIndex
+        && uriString.charAt(schemeIndex + 1) == '/'
+        && uriString.charAt(schemeIndex + 2) == '/';
+    int pathIndex;
+    if (hasAuthority) {
+      pathIndex = uriString.indexOf('/', schemeIndex + 3); // find first '/' after "://"
+      if (pathIndex == -1 || pathIndex > queryIndex) {
+        pathIndex = queryIndex;
+      }
+    } else {
+      pathIndex = schemeIndex + 1;
+    }
+
+    indices[SCHEME_COLON] = schemeIndex;
+    indices[PATH] = pathIndex;
+    indices[QUERY] = queryIndex;
+    indices[FRAGMENT] = fragmentIndex;
+    return indices;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 7e096cfa1b..c2b19c6d99 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -15,13 +15,23 @@
  */
 package com.google.android.exoplayer.util;
 
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
 
-import android.net.Uri;
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.os.Build;
 import android.text.TextUtils;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
 import java.math.BigDecimal;
+import java.net.HttpURLConnection;
 import java.net.URL;
 import java.text.ParseException;
 import java.util.Arrays;
@@ -58,6 +68,8 @@
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
 
+  private static final long MAX_BYTES_TO_DRAIN = 2048;
+
   private Util() {}
 
   /**
@@ -81,6 +93,25 @@ public static boolean areEqual(Object o1, Object o2) {
     return o1 == null ? o2 == null : o1.equals(o2);
   }
 
+  /**
+   * Tests whether an {@code items} array contains an object equal to {@code item}, according to
+   * {@link Object#equals(Object)}.
+   * <p>
+   * If {@code item} is null then true is returned if and only if {@code items} contains null.
+   *
+   * @param items The array of items to search.
+   * @param item The item to search for.
+   * @return True if the array contains an object equal to the item being searched for.
+   */
+  public static boolean contains(Object[] items, Object item) {
+    for (int i = 0; i < items.length; i++) {
+      if (Util.areEqual(items[i], item)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Instantiates a new single threaded executor whose thread has the specified name.
    *
@@ -124,6 +155,19 @@ public static void closeQuietly(DataSource dataSource) {
     }
   }
 
+  /**
+   * Closes an {@link OutputStream}, suppressing any {@link IOException} that may occur.
+   *
+   * @param outputStream The {@link OutputStream} to close.
+   */
+  public static void closeQuietly(OutputStream outputStream) {
+    try {
+      outputStream.close();
+    } catch (IOException e) {
+      // Ignore.
+    }
+  }
+
   /**
    * Converts text to lower case using {@link Locale#US}.
    *
@@ -135,51 +179,25 @@ public static String toLowerInvariant(String text) {
   }
 
   /**
-   * Like {@link Uri#parse(String)}, but discards the part of the uri that follows the final
-   * forward slash.
+   * Divides a {@code numerator} by a {@code denominator}, returning the ceiled result.
    *
-   * @param uriString An RFC 2396-compliant, encoded uri.
-   * @return The parsed base uri.
+   * @param numerator The numerator to divide.
+   * @param denominator The denominator to divide by.
+   * @return The ceiled result of the division.
    */
-  public static Uri parseBaseUri(String uriString) {
-    return Uri.parse(uriString.substring(0, uriString.lastIndexOf('/')));
+  public static int ceilDivide(int numerator, int denominator) {
+    return (numerator + denominator - 1) / denominator;
   }
 
   /**
-   * Merges a uri and a string to produce a new uri.
-   * <p>
-   * The uri is built according to the following rules:
-   * <ul>
-   * <li>If {@code baseUri} is null or if {@code stringUri} is absolute, then {@code baseUri} is
-   * ignored and the uri consists solely of {@code stringUri}.
-   * <li>If {@code stringUri} is null, then the uri consists solely of {@code baseUrl}.
-   * <li>Otherwise, the uri consists of the concatenation of {@code baseUri} and {@code stringUri}.
-   * </ul>
+   * Divides a {@code numerator} by a {@code denominator}, returning the ceiled result.
    *
-   * @param baseUri A uri that can form the base of the merged uri.
-   * @param stringUri A relative or absolute uri in string form.
-   * @return The merged uri.
+   * @param numerator The numerator to divide.
+   * @param denominator The denominator to divide by.
+   * @return The ceiled result of the division.
    */
-  public static Uri getMergedUri(Uri baseUri, String stringUri) {
-    if (stringUri == null) {
-      return baseUri;
-    }
-    if (baseUri == null) {
-      return Uri.parse(stringUri);
-    }
-    if (stringUri.startsWith("/")) {
-      stringUri = stringUri.substring(1);
-      return new Uri.Builder()
-          .scheme(baseUri.getScheme())
-          .authority(baseUri.getAuthority())
-          .appendEncodedPath(stringUri)
-          .build();
-    }
-    Uri uri = Uri.parse(stringUri);
-    if (uri.isAbsolute()) {
-      return uri;
-    }
-    return Uri.withAppendedPath(baseUri, stringUri);
+  public static long ceilDivide(long numerator, long denominator) {
+    return (numerator + denominator - 1) / denominator;
   }
 
   /**
@@ -445,4 +463,102 @@ public static void scaleLargeTimestampsInPlace(long[] timestamps, long multiplie
     return intArray;
   }
 
+  /**
+   * On platform API levels 19 and 20, okhttp's implementation of {@link InputStream#close} can
+   * block for a long time if the stream has a lot of data remaining. Call this method before
+   * closing the input stream to make a best effort to cause the input stream to encounter an
+   * unexpected end of input, working around this issue. On other platform API levels, the method
+   * does nothing.
+   *
+   * @param connection The connection whose {@link InputStream} should be terminated.
+   * @param bytesRemaining The number of bytes remaining to be read from the input stream if its
+   *     length is known. {@link C#LENGTH_UNBOUNDED} otherwise.
+   */
+  public static void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {
+    if (SDK_INT != 19 && SDK_INT != 20) {
+      return;
+    }
+
+    try {
+      InputStream inputStream = connection.getInputStream();
+      if (bytesRemaining == C.LENGTH_UNBOUNDED) {
+        // If the input stream has already ended, do nothing. The socket may be re-used.
+        if (inputStream.read() == -1) {
+          return;
+        }
+      } else if (bytesRemaining <= MAX_BYTES_TO_DRAIN) {
+        // There isn't much data left. Prefer to allow it to drain, which may allow the socket to be
+        // re-used.
+        return;
+      }
+      String className = inputStream.getClass().getName();
+      if (className.equals("com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream")
+          || className.equals(
+              "com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream")) {
+        Class<?> superclass = inputStream.getClass().getSuperclass();
+        Method unexpectedEndOfInput = superclass.getDeclaredMethod("unexpectedEndOfInput");
+        unexpectedEndOfInput.setAccessible(true);
+        unexpectedEndOfInput.invoke(inputStream);
+      }
+    } catch (IOException e) {
+      // The connection didn't ever have an input stream, or it was closed already.
+    } catch (Exception e) {
+      // Something went wrong. The device probably isn't using okhttp.
+    }
+  }
+
+  /**
+   * Given a {@link DataSpec} and a number of bytes already loaded, returns a {@link DataSpec}
+   * that represents the remainder of the data.
+   *
+   * @param dataSpec The original {@link DataSpec}.
+   * @param bytesLoaded The number of bytes already loaded.
+   * @return A {@link DataSpec} that represents the remainder of the data.
+   */
+  public static DataSpec getRemainderDataSpec(DataSpec dataSpec, int bytesLoaded) {
+    if (bytesLoaded == 0) {
+      return dataSpec;
+    } else {
+      long remainingLength = dataSpec.length == C.LENGTH_UNBOUNDED ? C.LENGTH_UNBOUNDED
+          : dataSpec.length - bytesLoaded;
+      return new DataSpec(dataSpec.uri, dataSpec.position + bytesLoaded, remainingLength,
+          dataSpec.key, dataSpec.flags);
+    }
+  }
+
+  /**
+   * Returns the integer equal to the big-endian concatenation of the characters in {@code string}
+   * as bytes. {@code string} must contain four or fewer characters.
+   */
+  public static int getIntegerCodeForString(String string) {
+    int length = string.length();
+    Assertions.checkArgument(length <= 4);
+    int result = 0;
+    for (int i = 0; i < length; i++) {
+      result <<= 8;
+      result |= string.charAt(i);
+    }
+    return result;
+  }
+
+  /**
+   * Returns a user agent string based on the given application name and the library version.
+   *
+   * @param context A valid context of the calling application.
+   * @param applicationName String that will be prefix'ed to the generated user agent.
+   * @return A user agent string generated using the applicationName and the library version.
+   */
+  public static String getUserAgent(Context context, String applicationName) {
+    String versionName;
+    try {
+      String packageName = context.getPackageName();
+      PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
+      versionName = info.versionName;
+    } catch (NameNotFoundException e) {
+      versionName = "?";
+    }
+    return applicationName + "/" + versionName + " (Linux;Android " + Build.VERSION.RELEASE
+        + ") " + "ExoPlayerLib/" + ExoPlayerLibraryInfo.VERSION;
+  }
+
 }
diff --git a/library/src/main/project.properties b/library/src/main/project.properties
index b756f4487f..95228a4fc6 100644
--- a/library/src/main/project.properties
+++ b/library/src/main/project.properties
@@ -8,5 +8,5 @@
 # project structure.
 
 # Project target.
-target=android-21
+target=android-22
 android.library=true
diff --git a/library/src/test/.classpath b/library/src/test/.classpath
new file mode 100644
index 0000000000..171a8c3ec8
--- /dev/null
+++ b/library/src/test/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/ExoPlayerDemo"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/library/src/test/.project b/library/src/test/.project
new file mode 100644
index 0000000000..d63886b065
--- /dev/null
+++ b/library/src/test/.project
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerTests</name>
+	<comment></comment>
+	<projects>
+		<project>ExoPlayerLib</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<linkedResources>
+		<link>
+			<name>libs/dexmaker-1.2.jar</name>
+			<type>1</type>
+			<locationURI>$%7BPARENT-3-PROJECT_LOC%7D/third_party/dexmaker/dexmaker-1.2.jar</locationURI>
+		</link>
+		<link>
+			<name>libs/dexmaker-mockito-1.2.jar</name>
+			<type>1</type>
+			<locationURI>$%7BPARENT-3-PROJECT_LOC%7D/third_party/dexmaker/dexmaker-mockito-1.2.jar</locationURI>
+		</link>
+		<link>
+			<name>libs/mockito-all-1.9.5.jar</name>
+			<type>1</type>
+			<locationURI>$%7BPARENT-3-PROJECT_LOC%7D/third_party/mockito/mockito-all-1.9.5.jar</locationURI>
+		</link>
+	</linkedResources>
+	<filteredResources>
+		<filter>
+			<id>1425657306619</id>
+			<name></name>
+			<type>14</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-true-false-BUILD</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/library/src/test/AndroidManifest.xml b/library/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..71bb5c3a66
--- /dev/null
+++ b/library/src/test/AndroidManifest.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.tests">
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+
+  <application>
+    <uses-library android:name="android.test.runner"/>
+  </application>
+
+  <instrumentation
+      android:targetPackage="com.google.android.exoplayer.demo"
+      android:name="android.test.InstrumentationTestRunner"/>
+
+</manifest>
diff --git a/library/src/test/assets/dash/sample_mpd_1 b/library/src/test/assets/dash/sample_mpd_1
new file mode 100755
index 0000000000..07bcdd4f50
--- /dev/null
+++ b/library/src/test/assets/dash/sample_mpd_1
@@ -0,0 +1,99 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    availabilityStartTime="2014-06-19T23:07:42"
+    minBufferTime="PT1.500S"
+    minimumUpdatePeriod="PT5.000S"
+    profiles="urn:mpeg:dash:profile:isoff-main:2011"
+    timeShiftBufferDepth="PT129600.000S"
+    type="dynamic"
+    xmlns="urn:mpeg:DASH:schema:MPD:2011"
+    xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"
+    yt:earliestMediaSequence="1266404" >
+    <Period start="PT6462826.784S" >
+        <SegmentList
+            presentationTimeOffset="34740095"
+            startNumber="1292317"
+            timescale="1000" >
+            <SegmentTimeline>
+                <S d="4804" />
+                <S d="5338" />
+                <S d="4938" />
+            </SegmentTimeline>
+        </SegmentList>
+        <AdaptationSet
+            mimeType="audio/mp4"
+            subsegmentAlignment="true" >
+            <Role
+                schemeIdUri="urn:mpeg:DASH:role:2011"
+                value="main" />
+            <Representation
+                id="141"
+                audioSamplingRate="48000"
+                bandwidth="272000"
+                codecs="mp4a.40.2"
+                startWithSAP="1" >
+                <AudioChannelConfiguration
+                    schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011"
+                    value="2" />
+                <BaseURL>
+http://www.test.com/141
+                </BaseURL>
+                <SegmentList>
+                    <Initialization
+                        range="0-591"
+                        sourceURL="sq/0/clen/79480/lmt/1403219262956762/dur/4.805" />
+                    <SegmentURL media="sq/1292317/clen/77447/lmt/1409671169987621/dur/4.805" />
+                    <SegmentURL media="sq/1292318/clen/86958/lmt/1409671174832549/dur/5.339" />
+                    <SegmentURL media="sq/1292319/clen/85018/lmt/1409671179719956/dur/4.938" />
+                </SegmentList>
+            </Representation>
+        </AdaptationSet>
+        <AdaptationSet
+            mimeType="video/mp4"
+            subsegmentAlignment="true" >
+            <Role
+                schemeIdUri="urn:mpeg:DASH:role:2011"
+                value="main" />
+            <Representation
+                id="135"
+                bandwidth="1116000"
+                codecs="avc1.42c01f"
+                height="480"
+                startWithSAP="1"
+                width="854" >
+                <BaseURL>
+http://www.test.com/135
+                </BaseURL>
+                <SegmentList>
+                    <Initialization
+                        range="0-671"
+                        sourceURL="sq/0/clen/1221137/lmt/1403219262956762/dur/4.805" />
+                    <SegmentURL media="sq/1292317/clen/1279915/lmt/1409671169987621/dur/4.805" />
+                    <SegmentURL media="sq/1292318/clen/1310650/lmt/1409671174832549/dur/5.339" />
+                    <SegmentURL media="sq/1292319/clen/1486558/lmt/1409671179719956/dur/4.938" />
+                </SegmentList>
+            </Representation>
+        </AdaptationSet>
+        <AdaptationSet
+            lang="en"
+            mimeType="text/vtt" >
+            <Role
+                schemeIdUri="urn:mpeg:DASH:role:2011"
+                value="caption" />
+            <Representation
+                id="en"
+                bandwidth="0"
+                codecs="" >
+                <BaseURL>
+http://www.test.com/vtt
+                </BaseURL>
+                <SegmentList>
+                    <SegmentURL media="sq/1292317" />
+                    <SegmentURL media="sq/1292318" />
+                    <SegmentURL media="sq/1292319" />
+                </SegmentList>
+            </Representation>
+        </AdaptationSet>
+    </Period>
+</MPD>
+
diff --git a/library/src/test/assets/webm/vorbis_codec_private b/library/src/test/assets/webm/vorbis_codec_private
new file mode 100644
index 0000000000..6a613449a7
Binary files /dev/null and b/library/src/test/assets/webm/vorbis_codec_private differ
diff --git a/library/src/test/assets/webvtt/empty b/library/src/test/assets/webvtt/empty
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/library/src/test/assets/webvtt/empty
@@ -0,0 +1 @@
+
diff --git a/library/src/test/assets/webvtt/typical b/library/src/test/assets/webvtt/typical
new file mode 100644
index 0000000000..d1395efe1b
--- /dev/null
+++ b/library/src/test/assets/webvtt/typical
@@ -0,0 +1,8 @@
+WEBVTT
+X-TIMESTAMP-MAP=LOCAL:00:00.000,MPEGTS:450000
+
+00:00.000 --> 00:01.234
+This is the first subtitle.
+
+00:02.345 --> 00:03.456
+This is the second subtitle.
diff --git a/library/src/test/assets/webvtt/typical_with_identifiers b/library/src/test/assets/webvtt/typical_with_identifiers
new file mode 100644
index 0000000000..e2c5df065b
--- /dev/null
+++ b/library/src/test/assets/webvtt/typical_with_identifiers
@@ -0,0 +1,10 @@
+WEBVTT
+X-TIMESTAMP-MAP=LOCAL:00:00.000,MPEGTS:450000
+
+1
+00:00.000 --> 00:01.234
+This is the first subtitle.
+
+2
+00:02.345 --> 00:03.456
+This is the second subtitle.
diff --git a/library/src/test/assets/webvtt/typical_with_tags b/library/src/test/assets/webvtt/typical_with_tags
new file mode 100644
index 0000000000..36e630e240
--- /dev/null
+++ b/library/src/test/assets/webvtt/typical_with_tags
@@ -0,0 +1,14 @@
+WEBVTT
+X-TIMESTAMP-MAP=LOCAL:00:00.000,MPEGTS:450000
+
+00:00.000 --> 00:01.234
+This is the <i>first</i> subtitle.
+
+00:02.345 --> 00:03.456
+This is the <b><i>second</b></i> subtitle.
+
+00:04.000 --> 00:05.000
+This is the <c.red.caps>third</c> subtitle.
+
+00:06.000 --> 00:07.000
+This is&nbsp;the &lt;fourth&gt; &amp;subtitle.
diff --git a/library/src/test/java/com/google/android/exoplayer/CTest.java b/library/src/test/java/com/google/android/exoplayer/CTest.java
new file mode 100644
index 0000000000..3aa97464a3
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/CTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import android.annotation.SuppressLint;
+import android.media.MediaCodec;
+import android.media.MediaExtractor;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link C}.
+ */
+public class CTest extends TestCase {
+
+  @SuppressLint("InlinedApi")
+  public static final void testContants() {
+    // Sanity check that constant values match those defined by the platform.
+    assertEquals(MediaExtractor.SAMPLE_FLAG_SYNC, C.SAMPLE_FLAG_SYNC);
+    assertEquals(MediaExtractor.SAMPLE_FLAG_ENCRYPTED, C.SAMPLE_FLAG_ENCRYPTED);
+    assertEquals(MediaCodec.CRYPTO_MODE_AES_CTR, C.CRYPTO_MODE_AES_CTR);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
new file mode 100644
index 0000000000..6da52e50f9
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+
+import junit.framework.TestCase;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Unit test for {@link MediaFormat}.
+ */
+public class MediaFormatTest extends TestCase {
+
+  public void testConversionToFrameworkFormat() {
+    if (Util.SDK_INT < 16) {
+      // Test doesn't apply.
+      return;
+    }
+
+    byte[] initData1 = new byte[] {1, 2, 3};
+    byte[] initData2 = new byte[] {4, 5, 6};
+    List<byte[]> initData = new ArrayList<byte[]>();
+    initData.add(initData1);
+    initData.add(initData2);
+
+    testConversionToFrameworkFormatV16(
+        MediaFormat.createVideoFormat("video/xyz", 102400, 1000L, 1280, 720, 1.5f, initData));
+    testConversionToFrameworkFormatV16(
+        MediaFormat.createAudioFormat("audio/xyz", 102400, 1000L, 5, 44100, initData));
+  }
+
+  @TargetApi(16)
+  private void testConversionToFrameworkFormatV16(MediaFormat format) {
+    // Convert to a framework MediaFormat and back again.
+    MediaFormat convertedFormat = MediaFormat.createFromFrameworkMediaFormatV16(
+        format.getFrameworkMediaFormatV16());
+    // Assert that we end up with an equivalent object to the one we started with.
+    assertEquals(format.hashCode(), convertedFormat.hashCode());
+    assertEquals(format, convertedFormat);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
new file mode 100644
index 0000000000..fc343bbc41
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash;
+
+import static org.mockito.Mockito.when;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.chunk.ChunkOperationHolder;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.chunk.FormatEvaluator;
+import com.google.android.exoplayer.chunk.FormatEvaluator.FixedEvaluator;
+import com.google.android.exoplayer.chunk.MediaChunk;
+import com.google.android.exoplayer.dash.mpd.AdaptationSet;
+import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
+import com.google.android.exoplayer.dash.mpd.Period;
+import com.google.android.exoplayer.dash.mpd.RangedUri;
+import com.google.android.exoplayer.dash.mpd.Representation;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.MultiSegmentBase;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentList;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTemplate;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTimelineElement;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer.dash.mpd.UrlTemplate;
+import com.google.android.exoplayer.testutil.Util;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.util.FakeClock;
+import com.google.android.exoplayer.util.ManifestFetcher;
+
+import android.test.InstrumentationTestCase;
+
+import org.mockito.Mock;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Tests {@link DashChunkSource}.
+ */
+public class DashChunkSourceTest extends InstrumentationTestCase {
+
+  private static final FormatEvaluator EVALUATOR = new FixedEvaluator();
+
+  private static final long AVAILABILITY_START_TIME = 0;
+  private static final long AVAILABILITY_LATENCY = 5000;
+  private static final long AVAILABILITY_REALTIME_OFFSET = 1000;
+  private static final long AVAILABILITY_CURRENT_TIME =
+      AVAILABILITY_START_TIME + AVAILABILITY_LATENCY - AVAILABILITY_REALTIME_OFFSET;
+  private static final FakeClock AVAILABILITY_CLOCK = new FakeClock(AVAILABILITY_CURRENT_TIME);
+
+  private static final int TALL_HEIGHT = 200;
+  private static final int WIDE_WIDTH = 400;
+
+  private static final Format REGULAR_VIDEO =
+      new Format("1", "video/mp4", 480, 240, -1, -1, -1, 1000);
+  private static final Format TALL_VIDEO =
+      new Format("2", "video/mp4", 100, TALL_HEIGHT, -1, -1, -1, 1000);
+  private static final Format WIDE_VIDEO =
+      new Format("3", "video/mp4", WIDE_WIDTH, 50, -1, -1, -1, 1000);
+
+  @Mock private DataSource mockDataSource;
+  @Mock private ManifestFetcher<MediaPresentationDescription> mockManifestFetcher;
+
+  @Override
+  public void setUp() throws Exception {
+    Util.setUpMockito(this);
+  }
+
+  public void testMaxVideoDimensions() {
+    DashChunkSource chunkSource = new DashChunkSource(generateVodMpd(), AdaptationSet.TYPE_VIDEO,
+        null, null, null);
+    MediaFormat out = MediaFormat.createVideoFormat("video/h264", 1, 1, 1, 1, null);
+    chunkSource.getMaxVideoDimensions(out);
+
+    assertEquals(WIDE_WIDTH, out.getMaxVideoWidth());
+    assertEquals(TALL_HEIGHT, out.getMaxVideoHeight());
+  }
+
+  public void testMaxVideoDimensionsLegacy() {
+    SingleSegmentBase segmentBase1 = new SingleSegmentBase("https://example.com/1.mp4");
+    Representation representation1 =
+        Representation.newInstance(0, 0, null, 0, TALL_VIDEO, segmentBase1);
+
+    SingleSegmentBase segmentBase2 = new SingleSegmentBase("https://example.com/2.mp4");
+    Representation representation2 =
+        Representation.newInstance(0, 0, null, 0, WIDE_VIDEO, segmentBase2);
+
+    DashChunkSource chunkSource = new DashChunkSource(null, null, representation1, representation2);
+    MediaFormat out = MediaFormat.createVideoFormat("video/h264", 1, 1, 1, 1, null);
+    chunkSource.getMaxVideoDimensions(out);
+
+    assertEquals(WIDE_WIDTH, out.getMaxVideoWidth());
+    assertEquals(TALL_HEIGHT, out.getMaxVideoHeight());
+  }
+
+  public void testLiveEdgeNoLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(0L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge500msLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(500L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge1000msLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(1000L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge1001msLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(1001L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(3000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(4000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge2500msLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(2500L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(2000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(3000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdgeVeryHighLatencyWithTimeline() {
+    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(10000L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(0L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(1000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdgeNoLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(0L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    // this should actually return the "5th" segment, but it currently returns the "6th", which
+    // doesn't actually exist yet; this will be resolved in a subsequent cl (cl/87518875).
+    //assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    //assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdgeAlmostNoLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge500msLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(500L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge1000msLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1000L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge1001msLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1001L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(3000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(4000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdge2500msLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(2500L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(2000000L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(3000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  public void testLiveEdgeVeryHighLatencyWithTemplate() {
+    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(10000L);
+    List<MediaChunk> queue = new ArrayList<MediaChunk>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    chunkSource.getChunkOperation(queue, 0, 0, out);
+
+    assertEquals(0L, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(1000000L, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  private static MediaPresentationDescription generateMpd(boolean live,
+      List<Representation> representations) {
+    Representation firstRepresentation = representations.get(0);
+    AdaptationSet adaptationSet = new AdaptationSet(0, AdaptationSet.TYPE_UNKNOWN, representations);
+    Period period = new Period(null, firstRepresentation.periodStartMs,
+        firstRepresentation.periodDurationMs, Collections.singletonList(adaptationSet));
+    long duration = (live) ? TrackRenderer.UNKNOWN_TIME_US
+        : firstRepresentation.periodDurationMs - firstRepresentation.periodStartMs;
+    return new MediaPresentationDescription(AVAILABILITY_START_TIME, duration, -1, live, -1, -1,
+        null, Collections.singletonList(period));
+  }
+
+  private static MediaPresentationDescription generateVodMpd() {
+    List<Representation> representations = new ArrayList<Representation>();
+
+    SingleSegmentBase segmentBase1 = new SingleSegmentBase("https://example.com/1.mp4");
+    Representation representation1 =
+        Representation.newInstance(0, 0, null, 0, TALL_VIDEO, segmentBase1);
+    representations.add(representation1);
+
+    SingleSegmentBase segmentBase2 = new SingleSegmentBase("https://example.com/2.mp4");
+    Representation representation2 =
+        Representation.newInstance(0, 0, null, 0, WIDE_VIDEO, segmentBase2);
+    representations.add(representation2);
+
+    return generateMpd(false, representations);
+  }
+
+  private static MediaPresentationDescription generateLiveMpdWithTimeline() {
+    List<Representation> representations = new ArrayList<Representation>();
+
+    List<SegmentTimelineElement> segmentTimeline = new ArrayList<SegmentTimelineElement>();
+    segmentTimeline.add(new SegmentTimelineElement(0L, 1000L));
+    segmentTimeline.add(new SegmentTimelineElement(1000L, 1000L));
+    segmentTimeline.add(new SegmentTimelineElement(2000L, 1000L));
+    segmentTimeline.add(new SegmentTimelineElement(3000L, 1000L));
+    segmentTimeline.add(new SegmentTimelineElement(4000L, 1000L));
+    List<RangedUri> mediaSegments = new ArrayList<RangedUri>();
+    mediaSegments.add(new RangedUri("", "", 0L, 500L));
+    mediaSegments.add(new RangedUri("", "", 500L, 500L));
+    mediaSegments.add(new RangedUri("", "", 1000L, 500L));
+    mediaSegments.add(new RangedUri("", "", 1500L, 500L));
+    mediaSegments.add(new RangedUri("", "", 2000L, 500L));
+
+    MultiSegmentBase segmentBase = new SegmentList(null, 1000, 0,
+        TrackRenderer.UNKNOWN_TIME_US, 1, TrackRenderer.UNKNOWN_TIME_US, segmentTimeline,
+        mediaSegments);
+    Representation representation = Representation.newInstance(0, TrackRenderer.UNKNOWN_TIME_US,
+        null, 0, REGULAR_VIDEO, segmentBase);
+    representations.add(representation);
+
+    return generateMpd(true, representations);
+  }
+
+  private static MediaPresentationDescription generateLiveMpdWithTemplate() {
+    List<Representation> representations = new ArrayList<Representation>();
+
+    UrlTemplate initializationTemplate = null;
+    UrlTemplate mediaTemplate = UrlTemplate.compile("$RepresentationID$/$Number$");
+    MultiSegmentBase segmentBase = new SegmentTemplate(null, 1000, 0,
+        TrackRenderer.UNKNOWN_TIME_US, 1, 1000, null,
+        initializationTemplate, mediaTemplate, "http://www.youtube.com");
+    Representation representation = Representation.newInstance(0, TrackRenderer.UNKNOWN_TIME_US,
+        null, 0, REGULAR_VIDEO, segmentBase);
+    representations.add(representation);
+
+    return generateMpd(true, representations);
+  }
+
+  private DashChunkSource setupLiveEdgeTimelineTest(long liveEdgeLatencyMs) {
+    MediaPresentationDescription manifest = generateLiveMpdWithTimeline();
+    when(mockManifestFetcher.getManifest()).thenReturn(manifest);
+    return new DashChunkSource(mockManifestFetcher, manifest, AdaptationSet.TYPE_VIDEO, null,
+        mockDataSource, EVALUATOR, AVAILABILITY_CLOCK, liveEdgeLatencyMs * 1000,
+        AVAILABILITY_REALTIME_OFFSET * 1000);
+  }
+
+  private DashChunkSource setupLiveEdgeTemplateTest(long liveEdgeLatencyMs) {
+    MediaPresentationDescription manifest = generateLiveMpdWithTemplate();
+    when(mockManifestFetcher.getManifest()).thenReturn(manifest);
+    return new DashChunkSource(mockManifestFetcher, manifest, AdaptationSet.TYPE_VIDEO, null,
+        mockDataSource, EVALUATOR, AVAILABILITY_CLOCK, liveEdgeLatencyMs * 1000,
+        AVAILABILITY_REALTIME_OFFSET * 1000);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java b/library/src/test/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
new file mode 100644
index 0000000000..7aa65564a0
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash.mpd;
+
+import android.test.InstrumentationTestCase;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Unit tests for {@link MediaPresentationDescriptionParser}.
+ */
+public class MediaPresentationDescriptionParserTest extends InstrumentationTestCase {
+
+  private static final String SAMPLE_MPD_1 = "dash/sample_mpd_1";
+
+  public void testParseMediaPresentationDescription() throws IOException {
+    MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(SAMPLE_MPD_1);
+    // Simple test to ensure that the sample manifest parses without throwing any exceptions.
+    parser.parse("https://example.com/test.mpd", inputStream);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java b/library/src/test/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
new file mode 100644
index 0000000000..52d5c1dd07
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash.mpd;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link RangedUri}.
+ */
+public class RangedUriTest extends TestCase {
+
+  private static final String FULL_URI = "http://www.test.com/path/file.ext";
+
+  public void testMerge() {
+    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, 10);
+    RangedUri expected = new RangedUri(null, FULL_URI, 0, 20);
+    assertMerge(rangeA, rangeB, expected);
+  }
+
+  public void testMergeUnbounded() {
+    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, -1);
+    RangedUri expected = new RangedUri(null, FULL_URI, 0, -1);
+    assertMerge(rangeA, rangeB, expected);
+  }
+
+  public void testNonMerge() {
+    // A and B do not overlap, so should not merge
+    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(null, FULL_URI, 11, 10);
+    assertNonMerge(rangeA, rangeB);
+
+    // A and B do not overlap, so should not merge
+    rangeA = new RangedUri(null, FULL_URI, 0, 10);
+    rangeB = new RangedUri(null, FULL_URI, 11, -1);
+    assertNonMerge(rangeA, rangeB);
+
+    // A and B are bounded but overlap, so should not merge
+    rangeA = new RangedUri(null, FULL_URI, 0, 11);
+    rangeB = new RangedUri(null, FULL_URI, 10, 10);
+    assertNonMerge(rangeA, rangeB);
+
+    // A and B overlap due to unboundedness, so should not merge
+    rangeA = new RangedUri(null, FULL_URI, 0, -1);
+    rangeB = new RangedUri(null, FULL_URI, 10, -1);
+    assertNonMerge(rangeA, rangeB);
+
+  }
+
+  private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected) {
+    RangedUri merged = rangeA.attemptMerge(rangeB);
+    assertEquals(expected, merged);
+    merged = rangeB.attemptMerge(rangeA);
+    assertEquals(expected, merged);
+  }
+
+  private void assertNonMerge(RangedUri rangeA, RangedUri rangeB) {
+    RangedUri merged = rangeA.attemptMerge(rangeB);
+    assertNull(merged);
+    merged = rangeB.attemptMerge(rangeA);
+    assertNull(merged);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java b/library/src/test/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
new file mode 100644
index 0000000000..dc0ca5047b
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash.mpd;
+
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link Representation}.
+ */
+public class RepresentationTest extends TestCase {
+
+  public void testGetCacheKey() {
+    String uri = "http://www.google.com";
+    SegmentBase base = new SingleSegmentBase(new RangedUri(uri, null, 0, 1), 1, 0, uri, 1, 1);
+    Format format = new Format("0", MimeTypes.VIDEO_MP4, 1920, 1080, -1, 0, 0, 2500000);
+    Representation representation = Representation.newInstance(-1, -1, "test_stream_1", 3,
+        format, base);
+    assertEquals("test_stream_1.0.3", representation.getCacheKey());
+
+    format = new Format("150", MimeTypes.VIDEO_MP4, 1920, 1080, -1, 0, 0, 2500000);
+    representation = Representation.newInstance(-1, -1, "test_stream_1", -1, format, base);
+    assertEquals("test_stream_1.150.-1", representation.getCacheKey());
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java b/library/src/test/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java
new file mode 100644
index 0000000000..96143b6373
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.dash.mpd;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link UrlTemplate}.
+ */
+public class UrlTemplateTest extends TestCase {
+
+  public void testRealExamples() {
+    String template = "QualityLevels($Bandwidth$)/Fragments(video=$Time$,format=mpd-time-csf)";
+    UrlTemplate urlTemplate = UrlTemplate.compile(template);
+    String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
+    assertEquals("QualityLevels(650000)/Fragments(video=5000,format=mpd-time-csf)", url);
+
+    template = "$RepresentationID$/$Number$";
+    urlTemplate = UrlTemplate.compile(template);
+    url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
+    assertEquals("abc1/10", url);
+
+    template = "chunk_ctvideo_cfm4s_rid$RepresentationID$_cn$Number$_w2073857842_mpd.m4s";
+    urlTemplate = UrlTemplate.compile(template);
+    url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
+    assertEquals("chunk_ctvideo_cfm4s_ridabc1_cn10_w2073857842_mpd.m4s", url);
+  }
+
+  public void testFull() {
+    String template = "$Bandwidth$_a_$RepresentationID$_b_$Time$_c_$Number$";
+    UrlTemplate urlTemplate = UrlTemplate.compile(template);
+    String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
+    assertEquals("650000_a_abc1_b_5000_c_10", url);
+  }
+
+  public void testFullWithDollarEscaping() {
+    String template = "$$$Bandwidth$$$_a$$_$RepresentationID$_b_$Time$_c_$Number$$$";
+    UrlTemplate urlTemplate = UrlTemplate.compile(template);
+    String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
+    assertEquals("$650000$_a$_abc1_b_5000_c_10$", url);
+  }
+
+  public void testInvalidSubstitution() {
+    String template = "$IllegalId$";
+    try {
+      UrlTemplate.compile(template);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
new file mode 100644
index 0000000000..4e901a5210
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.testutil.FakeDataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import android.net.Uri;
+
+import junit.framework.TestCase;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Test for {@link DefaultExtractorInput}.
+ */
+public class DefaultExtractorInputTest extends TestCase {
+
+  private static final String TEST_URI = "http://www.google.com";
+  private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8};
+
+  public void testInitialPosition() throws IOException {
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input =
+        new DefaultExtractorInput(testDataSource, 123, C.LENGTH_UNBOUNDED);
+    assertEquals(123, input.getPosition());
+  }
+
+  public void testRead() throws IOException, InterruptedException {
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    byte[] target = new byte[TEST_DATA.length];
+    // We expect to perform three reads of three bytes, as setup in buildTestDataSource.
+    int bytesRead = 0;
+    bytesRead += input.read(target, 0, TEST_DATA.length);
+    assertEquals(3, bytesRead);
+    bytesRead += input.read(target, 3, TEST_DATA.length);
+    assertEquals(6, bytesRead);
+    bytesRead += input.read(target, 6, TEST_DATA.length);
+    assertEquals(9, bytesRead);
+    // Check the read data is correct.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+    // Check we're now indicated that the end of input is reached.
+    int expectedEndOfInput = input.read(target, 0, TEST_DATA.length);
+    assertEquals(-1, expectedEndOfInput);
+  }
+
+  public void testReadFullyOnce() throws IOException, InterruptedException {
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    byte[] target = new byte[TEST_DATA.length];
+    input.readFully(target, 0, TEST_DATA.length);
+    // Check that we read the whole of TEST_DATA.
+    assertTrue(Arrays.equals(TEST_DATA, target));
+    assertEquals(TEST_DATA.length, input.getPosition());
+    // Check that we see end of input if we read again with allowEndOfInput set.
+    boolean result = input.readFully(target, 0, 1, true);
+    assertFalse(result);
+    // Check that we fail with EOFException we read again with allowEndOfInput unset.
+    try {
+      input.readFully(target, 0, 1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testReadFullyTwice() throws IOException, InterruptedException {
+    // Read TEST_DATA in two parts.
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    byte[] target = new byte[5];
+    input.readFully(target, 0, 5);
+    assertTrue(Arrays.equals(Arrays.copyOf(TEST_DATA, 5), target));
+    assertEquals(5, input.getPosition());
+    target = new byte[4];
+    input.readFully(target, 0, 4);
+    assertTrue(Arrays.equals(Arrays.copyOfRange(TEST_DATA, 5, 9), target));
+    assertEquals(5 + 4, input.getPosition());
+  }
+
+  public void testReadFullyTooMuch() throws IOException, InterruptedException {
+    // Read more than TEST_DATA. Should fail with an EOFException. Position should not update.
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    try {
+      byte[] target = new byte[TEST_DATA.length + 1];
+      input.readFully(target, 0, TEST_DATA.length + 1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+    assertEquals(0, input.getPosition());
+
+    // Read more than TEST_DATA with allowEndOfInput set. Should fail with an EOFException because
+    // the end of input isn't encountered immediately. Position should not update.
+    testDataSource = buildDataSource();
+    input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    try {
+      byte[] target = new byte[TEST_DATA.length + 1];
+      input.readFully(target, 0, TEST_DATA.length + 1, true);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+    assertEquals(0, input.getPosition());
+  }
+
+  public void testReadFullyWithFailingDataSource() throws IOException, InterruptedException {
+    FakeDataSource testDataSource = buildFailingDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    try {
+      byte[] target = new byte[TEST_DATA.length];
+      input.readFully(target, 0, TEST_DATA.length);
+      fail();
+    } catch (IOException e) {
+      // Expected.
+    }
+    // The position should not have advanced.
+    assertEquals(0, input.getPosition());
+  }
+
+  public void testSkipFullyOnce() throws IOException, InterruptedException {
+    // Skip TEST_DATA.
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    input.skipFully(TEST_DATA.length);
+    assertEquals(TEST_DATA.length, input.getPosition());
+    // Check that we fail with EOFException we skip again.
+    try {
+      input.skipFully(1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testSkipFullyTwice() throws IOException, InterruptedException {
+    // Skip TEST_DATA in two parts.
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    input.skipFully(5);
+    assertEquals(5, input.getPosition());
+    input.skipFully(4);
+    assertEquals(5 + 4, input.getPosition());
+  }
+
+  public void testSkipFullyTooMuch() throws IOException, InterruptedException {
+    // Skip more than TEST_DATA. Should fail with an EOFException. Position should not update.
+    FakeDataSource testDataSource = buildDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    try {
+      input.skipFully(TEST_DATA.length + 1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+    assertEquals(0, input.getPosition());
+  }
+
+  public void testSkipFullyWithFailingDataSource() throws IOException, InterruptedException {
+    FakeDataSource testDataSource = buildFailingDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    try {
+      input.skipFully(TEST_DATA.length);
+      fail();
+    } catch (IOException e) {
+      // Expected.
+    }
+    // The position should not have advanced.
+    assertEquals(0, input.getPosition());
+  }
+
+  public void testSkipFullyLarge() throws IOException, InterruptedException {
+    // Tests skipping an amount of data that's larger than any internal scratch space.
+    int largeSkipSize = 1024 * 1024;
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(new byte[largeSkipSize]);
+    FakeDataSource testDataSource = builder.build();
+    testDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    input.skipFully(largeSkipSize);
+    assertEquals(largeSkipSize, input.getPosition());
+    // Check that we fail with EOFException we skip again.
+    try {
+      input.skipFully(1);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  private static FakeDataSource buildDataSource() throws IOException {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 3));
+    builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 3, 6));
+    builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 6, 9));
+    FakeDataSource testDataSource = builder.build();
+    testDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    return testDataSource;
+  }
+
+  private static FakeDataSource buildFailingDataSource() throws IOException {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 6));
+    builder.appendReadError(new IOException());
+    builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 6, 9));
+    FakeDataSource testDataSource = builder.build();
+    testDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    return testDataSource;
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/ExtractorTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/ExtractorTest.java
new file mode 100644
index 0000000000..e7ffdae63d
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/ExtractorTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import com.google.android.exoplayer.C;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link Extractor}.
+ */
+public class ExtractorTest extends TestCase {
+
+  public static final void testContants() {
+    // Sanity check that constant values match those defined by {@link C}.
+    assertEquals(C.RESULT_END_OF_INPUT, Extractor.RESULT_END_OF_INPUT);
+    // Sanity check that the other constant values don't overlap.
+    assertTrue(C.RESULT_END_OF_INPUT != Extractor.RESULT_CONTINUE);
+    assertTrue(C.RESULT_END_OF_INPUT != Extractor.RESULT_SEEK);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
new file mode 100644
index 0000000000..d6668f94c6
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp3;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.testutil.FakeDataSource;
+import com.google.android.exoplayer.testutil.Util;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.net.Uri;
+import android.test.InstrumentationTestCase;
+
+import org.mockito.Mock;
+
+import java.nio.BufferOverflowException;
+import java.util.Arrays;
+
+/**
+ * Tests for {@link BufferingInput}.
+ */
+public class BufferingInputTest extends InstrumentationTestCase {
+
+  private static final String TEST_URI = "http://www.google.com";
+  private static final byte[] STREAM_DATA = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  private ExtractorInput fakeExtractorInput;
+
+  /** Used for verifying interactions. */
+  @Mock private ExtractorInput mockExtractorInput;
+  @Mock private TrackOutput mockTrackOutput;
+
+  @Override
+  public void setUp() throws Exception {
+    Util.setUpMockito(this);
+
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(STREAM_DATA);
+    FakeDataSource fakeDataSource = builder.build();
+    fakeDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    fakeExtractorInput = new DefaultExtractorInput(fakeDataSource, 0, STREAM_DATA.length);
+  }
+
+  public void testReadFromExtractor() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[4];
+    input.read(fakeExtractorInput, target, 0, 4);
+    assertMatchesStreamData(target, 0, 4);
+  }
+
+  public void testReadCapacityFromExtractor() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 5);
+    assertMatchesStreamData(target, 0, 5);
+  }
+
+  public void testReadOverCapacityFromExtractorFails() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[6];
+    try {
+      input.read(fakeExtractorInput, target, 0, 6);
+      fail();
+    } catch (BufferOverflowException e) {
+      // Expected.
+    }
+  }
+
+  public void testReadFromBuffer() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 5);
+
+    // When reading already-buffered data
+    input.returnToMark();
+    input.read(mockExtractorInput, target, 0, 5);
+    assertMatchesStreamData(target, 0, 5);
+
+    // There is no interaction with the extractor input.
+    verifyZeroInteractions(mockExtractorInput);
+  }
+
+  public void testReadFromBufferPartially() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 5);
+
+    // When reading already-buffered data
+    input.returnToMark();
+    input.read(mockExtractorInput, target, 0, 4);
+    assertMatchesStreamData(target, 0, 4);
+
+    // There is no interaction with the extractor input.
+    verifyZeroInteractions(mockExtractorInput);
+  }
+
+  public void testResetDiscardsData() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 5);
+
+    // When the buffer is reset
+    input.reset();
+
+    // Then it is possible to read up to the capacity again.
+    input.read(fakeExtractorInput, target, 0, 5);
+    assertMatchesStreamData(target, 5, 5);
+  }
+
+  public void testGetAvailableByteCountAtWritePosition() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 5);
+    assertEquals(0, input.getAvailableByteCount());
+  }
+
+  public void testGetAvailableByteCountBeforeWritePosition() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    byte[] target = new byte[5];
+    input.read(fakeExtractorInput, target, 0, 3);
+    input.mark();
+    input.read(fakeExtractorInput, target, 0, 3);
+    input.mark();
+    input.read(fakeExtractorInput, target, 0, 2);
+    input.returnToMark();
+
+    // The reading position is calculated correctly.
+    assertEquals(2, input.getAvailableByteCount());
+    assertEquals(8, fakeExtractorInput.getPosition());
+  }
+
+  public void testGetParsableByteArray() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    input.skip(fakeExtractorInput, 4);
+    input.mark();
+    input.skip(fakeExtractorInput, 3);
+    input.returnToMark();
+    ParsableByteArray parsableByteArray = input.getParsableByteArray(fakeExtractorInput, 4);
+
+    // The returned array matches the input's internal buffer.
+    assertMatchesStreamData(parsableByteArray.data, 0, 7);
+  }
+
+  public void testGetParsableByteArrayPastCapacity() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    input.skip(fakeExtractorInput, 4);
+    input.mark();
+    input.skip(fakeExtractorInput, 3);
+    input.mark();
+    input.skip(fakeExtractorInput, 1);
+    input.returnToMark();
+    ParsableByteArray parsableByteArray = input.getParsableByteArray(fakeExtractorInput, 2);
+
+    // The second call to mark() copied the buffer data to the start.
+    assertMatchesStreamData(parsableByteArray.data, 7, 2);
+  }
+
+  public void testDrainEntireBuffer() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    input.skip(fakeExtractorInput, 3);
+    input.returnToMark();
+
+    // When draining the first three bytes
+    input.drainToOutput(mockTrackOutput, 3);
+
+    // They are appended as sample data.
+    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(3));
+  }
+
+  public void testDrainTwice() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    input.skip(fakeExtractorInput, 3);
+    input.returnToMark();
+
+    // When draining one then two bytes
+    input.drainToOutput(mockTrackOutput, 1);
+    assertEquals(2, input.drainToOutput(mockTrackOutput, 3));
+
+    // They are appended as sample data.
+    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(1));
+    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(2));
+  }
+
+  public void testDrainPastCapacity() throws Exception {
+    BufferingInput input = new BufferingInput(5);
+    input.skip(fakeExtractorInput, 4);
+    input.mark();
+    input.skip(fakeExtractorInput, 5);
+    input.returnToMark();
+
+    // When draining the entire buffer
+    input.drainToOutput(mockTrackOutput, 5);
+
+    // The sample data is appended as one whole buffer.
+    verify(mockTrackOutput).sampleData(any(ParsableByteArray.class), eq(5));
+  }
+
+  private static void assertMatchesStreamData(byte[] read, int offset, int length) {
+    assertTrue(Arrays.equals(Arrays.copyOfRange(STREAM_DATA, offset, offset + length),
+        Arrays.copyOfRange(read, 0, length)));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
new file mode 100644
index 0000000000..9e6c290bec
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
@@ -0,0 +1,633 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.upstream.ByteArrayDataSource;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import junit.framework.TestCase;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Tests for {@link Mp4Extractor}.
+ */
+@TargetApi(16)
+public class Mp4ExtractorTest extends TestCase {
+
+  /** String of hexadecimal bytes containing the video stsd payload from an AVC video. */
+  private static final byte[] VIDEO_STSD_PAYLOAD = getByteArray(
+      "00000000000000010000009961766331000000000000000100000000000000000000000000000000050002"
+      + "d00048000000480000000000000001000000000000000000000000000000000000000000000000000000"
+      + "00000000000018ffff0000002f617663430164001fffe100186764001facb402802dd808800000030080"
+      + "00001e078c195001000468ee3cb000000014627472740000e35c0042a61000216cb8");
+  private static final byte[] VIDEO_HDLR_PAYLOAD = getByteArray("000000000000000076696465");
+  private static final byte[] VIDEO_MDHD_PAYLOAD =
+      getByteArray("0000000000000000cf6c48890000001e00001c8a55c40000");
+  private static final int TIMESCALE = 30;
+  private static final int VIDEO_WIDTH = 1280;
+  private static final int VIDEO_HEIGHT = 720;
+
+  /** String of hexadecimal bytes containing the video stsd payload for an mp4v track. */
+  private static final byte[] VIDEO_STSD_MP4V_PAYLOAD = getByteArray(
+      "0000000000000001000000A36D703476000000000000000100000000000000000000000000000000014000"
+      + "B40048000000480000000000000001000000000000000000000000000000000000000000000000000000"
+      + "00000000000018FFFF0000004D6573647300000000033F00000004372011001A400004CF280002F11805"
+      + "28000001B001000001B58913000001000000012000C48D8800F50A04169463000001B2476F6F676C6506"
+      + "0102");
+  private static final int VIDEO_MP4V_WIDTH = 320;
+  private static final int VIDEO_MP4V_HEIGHT = 180;
+
+  /** String of hexadecimal bytes containing the audio stsd payload from an AAC track. */
+  private static final byte[] AUDIO_STSD_PAYLOAD = getByteArray(
+      "0000000000000001000000596d703461000000000000000100000000000000000001001000000000ac4400"
+      + "000000003565736473000000000327000000041f401500023e00024bc000023280051012080000000000"
+      + "000000000000000000060102");
+  private static final byte[] AUDIO_HDLR_PAYLOAD = getByteArray("0000000000000000736f756e");
+  private static final byte[] AUDIO_MDHD_PAYLOAD =
+      getByteArray("00000000cf6c4889cf6c488a0000ac4400a3e40055c40000");
+
+  /** String of hexadecimal bytes containing an mvhd payload from an AVC/AAC video. */
+  private static final byte[] MVHD_PAYLOAD = getByteArray(
+      "00000000cf6c4888cf6c48880000025800023ad40001000001000000000000000000000000010000000000"
+      + "000000000000000000000100000000000000000000000000004000000000000000000000000000000000"
+      + "000000000000000000000000000003");
+
+  /** String of hexadecimal bytes containing a tkhd payload with an unknown duration. */
+  private static final byte[] TKHD_PAYLOAD =
+      getByteArray("0000000000000000000000000000000000000000FFFFFFFF");
+
+  /** Video frame timestamps in time units. */
+  private static final int[] SAMPLE_TIMESTAMPS = {0, 2, 3, 5, 6, 7};
+  /** Video frame sizes in bytes, including a very large sample. */
+  private static final int[] SAMPLE_SIZES = {100, 20, 20, 44, 100, 1 * 1024 * 1024};
+  /** Indices of key-frames. */
+  private static final int[] SYNCHRONIZATION_SAMPLE_INDICES = {0, 4, 5};
+  /** Indices of video frame chunk offsets. */
+  private static final int[] CHUNK_OFFSETS = {1080, 2000, 3000, 4000};
+  /** Numbers of video frames in each chunk. */
+  private static final int[] SAMPLES_IN_CHUNK = {2, 2, 1, 1};
+  /** The mdat box must be large enough to avoid reading chunk sample data out of bounds. */
+  private static final int MDAT_SIZE = 10 * 1024 * 1024;
+  /** Fake HTTP URI that can't be opened. */
+  private static final Uri FAKE_URI = Uri.parse("http://");
+  /** Empty byte array. */
+  private static final byte[] EMPTY = new byte[0];
+
+  public void testParsesValidMp4File() throws Exception {
+    // Given an extractor with an AVC/AAC file
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
+
+    // The MIME type and metadata are set correctly.
+    assertEquals(MimeTypes.VIDEO_H264, extractor.mediaFormats[0].mimeType);
+    assertEquals(MimeTypes.AUDIO_AAC, extractor.mediaFormats[1].mimeType);
+
+    assertEquals(VIDEO_WIDTH, extractor.selectedTrackMediaFormat.width);
+    assertEquals(VIDEO_HEIGHT, extractor.selectedTrackMediaFormat.height);
+  }
+
+  public void testParsesValidMp4vFile() throws Exception {
+    // Given an extractor with an mp4v file
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, true /* mp4vFormat */));
+
+    // The MIME type and metadata are set correctly.
+    assertEquals(MimeTypes.VIDEO_MP4V, extractor.selectedTrackMediaFormat.mimeType);
+    assertEquals(VIDEO_MP4V_WIDTH, extractor.selectedTrackMediaFormat.width);
+    assertEquals(VIDEO_MP4V_HEIGHT, extractor.selectedTrackMediaFormat.height);
+  }
+
+  public void testSampleTimestampsMatch() throws Exception {
+    // Given an extractor
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
+
+    // The timestamps are set correctly.
+    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+    for (int i = 0; i < SAMPLE_TIMESTAMPS.length; i++) {
+      extractor.readSample(0, sampleHolder);
+      assertEquals(getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]), sampleHolder.timeUs);
+    }
+    assertEquals(SampleSource.END_OF_STREAM, extractor.readSample(0, sampleHolder));
+  }
+
+  public void testSeekToStart() throws Exception {
+    // When seeking to the start
+    int timestampTimeUnits = SAMPLE_TIMESTAMPS[0];
+    long sampleTimestampUs =
+        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits));
+
+    // The timestamp is at the start.
+    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
+  }
+
+  public void testSeekToEnd() throws Exception {
+    // When seeking to the end
+    int timestampTimeUnits = SAMPLE_TIMESTAMPS[SAMPLE_TIMESTAMPS.length - 1];
+    long sampleTimestampUs =
+        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits));
+
+    // The timestamp is at the end.
+    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
+  }
+
+  public void testSeekToNearStart() throws Exception {
+    // When seeking to just after the start
+    int timestampTimeUnits = SAMPLE_TIMESTAMPS[0];
+    long sampleTimestampUs =
+        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits) + 1);
+
+    // The timestamp is at the start.
+    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
+  }
+
+  public void testSeekToBeforeLastSynchronizationSample() throws Exception {
+    // When seeking to just after the start
+    long sampleTimestampUs =
+        getTimestampUsResultingFromSeek(getVideoTimestampUs(SAMPLE_TIMESTAMPS[4]) - 1);
+
+    // The timestamp is at the start.
+    assertEquals(getVideoTimestampUs(SAMPLE_TIMESTAMPS[0]), sampleTimestampUs);
+  }
+
+  public void testAllSamplesAreSynchronizationSamplesWhenStssIsMissing() throws Exception {
+    // Given an extractor without an stss box
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(false /* includeStss */, false /* mp4vFormat */));
+    // All samples are synchronization samples.
+    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+    int sampleIndex = 0;
+    while (true) {
+      int result = extractor.readSample(0, sampleHolder);
+      if (result == SampleSource.SAMPLE_READ) {
+        assertTrue(sampleHolder.isSyncFrame());
+        sampleHolder.clearData();
+        sampleIndex++;
+      } else if (result == SampleSource.END_OF_STREAM) {
+        break;
+      }
+    }
+    assertTrue(sampleIndex == SAMPLE_SIZES.length);
+  }
+
+  public void testReadAllSamplesSucceeds() throws Exception {
+    // Given an extractor
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
+
+    // The sample sizes are set correctly.
+    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+    int sampleIndex = 0;
+    while (true) {
+      int result = extractor.readSample(0, sampleHolder);
+      if (result == SampleSource.SAMPLE_READ) {
+        assertEquals(SAMPLE_SIZES[sampleIndex], sampleHolder.size);
+        sampleHolder.clearData();
+        sampleIndex++;
+      } else if (result == SampleSource.END_OF_STREAM) {
+        break;
+      }
+    }
+    assertEquals(SAMPLE_SIZES.length, sampleIndex);
+  }
+
+  /** Returns the sample time read after seeking to {@code timestampTimeUnits}. */
+  private static long getTimestampUsResultingFromSeek(long timestampTimeUnits) throws Exception {
+    Mp4ExtractorWrapper extractor =
+        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
+
+    extractor.seekTo(timestampTimeUnits);
+
+    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+    while (true) {
+      int result = extractor.readSample(0, sampleHolder);
+      if (result == SampleSource.SAMPLE_READ) {
+        return sampleHolder.timeUs;
+      } else if (result == SampleSource.END_OF_STREAM) {
+        return -1;
+      }
+    }
+  }
+
+  private static Mp4ExtractorWrapper prepareSampleExtractor(DataSource dataSource)
+      throws Exception {
+    Mp4ExtractorWrapper extractor = new Mp4ExtractorWrapper(dataSource);
+    extractor.prepare();
+    return extractor;
+  }
+
+  /** Returns a video timestamp in microseconds corresponding to {@code timeUnits}. */
+  private static long getVideoTimestampUs(int timeUnits) {
+    return Util.scaleLargeTimestamp(timeUnits, C.MICROS_PER_SECOND, TIMESCALE);
+  }
+
+  private static byte[] getStco() {
+    byte[] result = new byte[4 + 4 + 4 * CHUNK_OFFSETS.length];
+    ByteBuffer buffer = ByteBuffer.wrap(result);
+    buffer.putInt(0); // Version (skipped)
+    buffer.putInt(CHUNK_OFFSETS.length);
+    for (int chunkOffset : CHUNK_OFFSETS) {
+      buffer.putInt(chunkOffset);
+    }
+    return result;
+  }
+
+  private static byte[] getStsc() {
+    int samplesPerChunk = -1;
+    List<Integer> samplesInChunkChangeIndices = new ArrayList<Integer>();
+    for (int i = 0; i < SAMPLES_IN_CHUNK.length; i++) {
+      if (SAMPLES_IN_CHUNK[i] != samplesPerChunk) {
+        samplesInChunkChangeIndices.add(i);
+        samplesPerChunk = SAMPLES_IN_CHUNK[i];
+      }
+    }
+
+    byte[] result = new byte[4 + 4 + 3 * 4 * samplesInChunkChangeIndices.size()];
+    ByteBuffer buffer = ByteBuffer.wrap(result);
+    buffer.putInt(0); // Version (skipped)
+    buffer.putInt(samplesInChunkChangeIndices.size());
+    for (int index : samplesInChunkChangeIndices) {
+      buffer.putInt(index + 1);
+      buffer.putInt(SAMPLES_IN_CHUNK[index]);
+      buffer.putInt(0); // Sample description index (skipped)
+    }
+    return result;
+  }
+
+  private static byte[] getStsz() {
+    byte[] result = new byte[4 + 4 + 4 + 4 * SAMPLE_SIZES.length];
+    ByteBuffer buffer = ByteBuffer.wrap(result);
+    buffer.putInt(0); // Version (skipped)
+    buffer.putInt(0); // No fixed sample size.
+    buffer.putInt(SAMPLE_SIZES.length);
+    for (int size : SAMPLE_SIZES) {
+      buffer.putInt(size);
+    }
+    return result;
+  }
+
+  private static byte[] getStss() {
+    byte[] result = new byte[4 + 4 + 4 * SYNCHRONIZATION_SAMPLE_INDICES.length];
+    ByteBuffer buffer = ByteBuffer.wrap(result);
+    buffer.putInt(0); // Version (skipped)
+    buffer.putInt(SYNCHRONIZATION_SAMPLE_INDICES.length);
+    for (int synchronizationSampleIndex : SYNCHRONIZATION_SAMPLE_INDICES) {
+      buffer.putInt(synchronizationSampleIndex + 1);
+    }
+    return result;
+  }
+
+  private static byte[] getStts() {
+    int sampleTimestampDeltaChanges = 0;
+    int currentSampleTimestampDelta = -1;
+    for (int i = 1; i < SAMPLE_TIMESTAMPS.length; i++) {
+      int timestampDelta = SAMPLE_TIMESTAMPS[i] - SAMPLE_TIMESTAMPS[i - 1];
+      if (timestampDelta != currentSampleTimestampDelta) {
+        sampleTimestampDeltaChanges++;
+        currentSampleTimestampDelta = timestampDelta;
+      }
+    }
+
+    byte[] result = new byte[4 + 4 + 2 * 4 * sampleTimestampDeltaChanges];
+    ByteBuffer buffer = ByteBuffer.wrap(result);
+    buffer.putInt(0); // Version (skipped);
+    buffer.putInt(sampleTimestampDeltaChanges);
+    int lastTimestampDeltaChangeIndex = 1;
+    currentSampleTimestampDelta = SAMPLE_TIMESTAMPS[1] - SAMPLE_TIMESTAMPS[0];
+    for (int i = 2; i < SAMPLE_TIMESTAMPS.length; i++) {
+      int timestampDelta = SAMPLE_TIMESTAMPS[i] - SAMPLE_TIMESTAMPS[i - 1];
+      if (timestampDelta != currentSampleTimestampDelta) {
+        buffer.putInt(i - lastTimestampDeltaChangeIndex);
+        lastTimestampDeltaChangeIndex = i;
+        buffer.putInt(currentSampleTimestampDelta);
+        currentSampleTimestampDelta = timestampDelta;
+      }
+    }
+    // The last sample also has a duration, so the number of entries is the number of samples.
+    buffer.putInt(SAMPLE_TIMESTAMPS.length - lastTimestampDeltaChangeIndex + 1);
+    buffer.putInt(currentSampleTimestampDelta);
+    return result;
+  }
+
+  private static byte[] getMdat(int mdatOffset) {
+    ByteBuffer mdat = ByteBuffer.allocate(MDAT_SIZE);
+    int sampleIndex = 0;
+    for (int chunk = 0; chunk < CHUNK_OFFSETS.length; chunk++) {
+      int sampleOffset = CHUNK_OFFSETS[chunk];
+      for (int sample = 0; sample < SAMPLES_IN_CHUNK[chunk]; sample++) {
+        int sampleSize = SAMPLE_SIZES[sampleIndex++];
+        mdat.putInt(sampleOffset - mdatOffset, sampleSize);
+        sampleOffset += sampleSize;
+      }
+    }
+    return mdat.array();
+  }
+
+  private static final DataSource getFakeDataSource(boolean includeStss, boolean mp4vFormat) {
+    return new ByteArrayDataSource(includeStss
+        ? getTestMp4File(mp4vFormat) : getTestMp4FileWithoutSynchronizationData(mp4vFormat));
+  }
+
+  /** Gets a valid MP4 file with audio/video tracks and synchronization data. */
+  private static byte[] getTestMp4File(boolean mp4vFormat) {
+    return Mp4Atom.serialize(
+        atom(Atom.TYPE_ftyp, EMPTY),
+        atom(Atom.TYPE_moov,
+            atom(Atom.TYPE_mvhd, MVHD_PAYLOAD),
+            atom(Atom.TYPE_trak,
+                atom(Atom.TYPE_tkhd, TKHD_PAYLOAD),
+                atom(Atom.TYPE_mdia,
+                    atom(Atom.TYPE_mdhd, VIDEO_MDHD_PAYLOAD),
+                    atom(Atom.TYPE_hdlr, VIDEO_HDLR_PAYLOAD),
+                    atom(Atom.TYPE_minf,
+                        atom(Atom.TYPE_vmhd, EMPTY),
+                        atom(Atom.TYPE_stbl,
+                            atom(Atom.TYPE_stsd,
+                                mp4vFormat ? VIDEO_STSD_MP4V_PAYLOAD : VIDEO_STSD_PAYLOAD),
+                            atom(Atom.TYPE_stts, getStts()),
+                            atom(Atom.TYPE_stss, getStss()),
+                            atom(Atom.TYPE_stsc, getStsc()),
+                            atom(Atom.TYPE_stsz, getStsz()),
+                            atom(Atom.TYPE_stco, getStco()))))),
+            atom(Atom.TYPE_trak,
+                atom(Atom.TYPE_tkhd, TKHD_PAYLOAD),
+                atom(Atom.TYPE_mdia,
+                    atom(Atom.TYPE_mdhd, AUDIO_MDHD_PAYLOAD),
+                    atom(Atom.TYPE_hdlr, AUDIO_HDLR_PAYLOAD),
+                    atom(Atom.TYPE_minf,
+                        atom(Atom.TYPE_vmhd, EMPTY),
+                        atom(Atom.TYPE_stbl,
+                            atom(Atom.TYPE_stsd, AUDIO_STSD_PAYLOAD),
+                            atom(Atom.TYPE_stts, getStts()),
+                            atom(Atom.TYPE_stss, getStss()),
+                            atom(Atom.TYPE_stsc, getStsc()),
+                            atom(Atom.TYPE_stsz, getStsz()),
+                            atom(Atom.TYPE_stco, getStco())))))),
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1048 : 1038)));
+  }
+
+  /** Gets a valid MP4 file with audio/video tracks and without a synchronization table. */
+  private static byte[] getTestMp4FileWithoutSynchronizationData(boolean mp4vFormat) {
+    return Mp4Atom.serialize(
+        atom(Atom.TYPE_ftyp, EMPTY),
+        atom(Atom.TYPE_moov,
+            atom(Atom.TYPE_mvhd, MVHD_PAYLOAD),
+            atom(Atom.TYPE_trak,
+                atom(Atom.TYPE_tkhd, TKHD_PAYLOAD),
+                atom(Atom.TYPE_mdia,
+                    atom(Atom.TYPE_mdhd, VIDEO_MDHD_PAYLOAD),
+                    atom(Atom.TYPE_hdlr, VIDEO_HDLR_PAYLOAD),
+                    atom(Atom.TYPE_minf,
+                        atom(Atom.TYPE_vmhd, EMPTY),
+                        atom(Atom.TYPE_stbl,
+                            atom(Atom.TYPE_stsd,
+                                mp4vFormat ? VIDEO_STSD_MP4V_PAYLOAD : VIDEO_STSD_PAYLOAD),
+                            atom(Atom.TYPE_stts, getStts()),
+                            atom(Atom.TYPE_stsc, getStsc()),
+                            atom(Atom.TYPE_stsz, getStsz()),
+                            atom(Atom.TYPE_stco, getStco()))))),
+            atom(Atom.TYPE_trak,
+                atom(Atom.TYPE_tkhd, TKHD_PAYLOAD),
+                atom(Atom.TYPE_mdia,
+                    atom(Atom.TYPE_mdhd, AUDIO_MDHD_PAYLOAD),
+                    atom(Atom.TYPE_hdlr, AUDIO_HDLR_PAYLOAD),
+                    atom(Atom.TYPE_minf,
+                        atom(Atom.TYPE_vmhd, EMPTY),
+                        atom(Atom.TYPE_stbl,
+                            atom(Atom.TYPE_stsd, AUDIO_STSD_PAYLOAD),
+                            atom(Atom.TYPE_stts, getStts()),
+                            atom(Atom.TYPE_stsc, getStsc()),
+                            atom(Atom.TYPE_stsz, getStsz()),
+                            atom(Atom.TYPE_stco, getStco())))))),
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 992 : 982)));
+  }
+
+  private static Mp4Atom atom(int type, Mp4Atom... containedMp4Atoms) {
+    return new Mp4Atom(type, containedMp4Atoms);
+  }
+
+  private static Mp4Atom atom(int type, byte[] payload) {
+    return new Mp4Atom(type, payload);
+  }
+
+  private static byte[] getByteArray(String hexBytes) {
+    byte[] result = new byte[hexBytes.length() / 2];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = (byte) ((Character.digit(hexBytes.charAt(i * 2), 16) << 4)
+          + Character.digit(hexBytes.charAt(i * 2 + 1), 16));
+    }
+    return result;
+  }
+
+  /** MP4 atom that can be serialized as a byte array. */
+  private static final class Mp4Atom {
+
+    public static byte[] serialize(Mp4Atom... atoms) {
+      int size = 0;
+      for (Mp4Atom atom : atoms) {
+        size += atom.getSize();
+      }
+      ByteBuffer buffer = ByteBuffer.allocate(size);
+      for (Mp4Atom atom : atoms) {
+        atom.getData(buffer);
+      }
+      return buffer.array();
+    }
+
+    private static final int HEADER_SIZE = 8;
+
+    private final int type;
+    private final Mp4Atom[] containedMp4Atoms;
+    private final byte[] payload;
+
+    private Mp4Atom(int type, Mp4Atom... containedMp4Atoms) {
+      this.type = type;
+      this.containedMp4Atoms = containedMp4Atoms;
+      payload = null;
+    }
+
+    private Mp4Atom(int type, byte[] payload) {
+      this.type = type;
+      this.payload = payload;
+      containedMp4Atoms = null;
+    }
+
+    private int getSize() {
+      int size = HEADER_SIZE;
+      if (payload != null) {
+        size += payload.length;
+      } else {
+        for (Mp4Atom atom : containedMp4Atoms) {
+          size += atom.getSize();
+        }
+      }
+      return size;
+    }
+
+    private void getData(ByteBuffer byteBuffer) {
+      byteBuffer.putInt(getSize());
+      byteBuffer.putInt(type);
+
+      if (payload != null) {
+        byteBuffer.put(payload);
+      } else {
+        for (Mp4Atom atom : containedMp4Atoms) {
+          atom.getData(byteBuffer);
+        }
+      }
+    }
+
+  }
+
+  /**
+   * Creates a {@link Mp4Extractor} on a separate thread with a looper, so that it can use a handler
+   * for loading, and provides blocking operations like {@link #seekTo} and {@link #readSample}.
+   */
+  private static final class Mp4ExtractorWrapper extends Thread {
+
+    private static final int MSG_PREPARE = 0;
+    private static final int MSG_SEEK_TO = 1;
+    private static final int MSG_READ_SAMPLE = 2;
+    private final DataSource dataSource;
+
+    // Written by the handler's thread and read by the main thread.
+    public volatile MediaFormat[] mediaFormats;
+    public volatile MediaFormat selectedTrackMediaFormat;
+    private volatile Handler handler;
+    private volatile int readSampleResult;
+    private volatile Exception exception;
+    private volatile CountDownLatch pendingOperationLatch;
+
+    public Mp4ExtractorWrapper(DataSource dataSource) {
+      super("Mp4ExtractorTest");
+      this.dataSource = Assertions.checkNotNull(dataSource);
+      pendingOperationLatch = new CountDownLatch(1);
+      start();
+    }
+
+    public void prepare() throws Exception {
+      // Block until the handler has been created.
+      pendingOperationLatch.await();
+
+      // Block until the extractor has been prepared.
+      pendingOperationLatch = new CountDownLatch(1);
+      handler.sendEmptyMessage(MSG_PREPARE);
+      pendingOperationLatch.await();
+      if (exception != null) {
+        throw exception;
+      }
+    }
+
+    public void seekTo(long timestampUs) {
+      handler.obtainMessage(MSG_SEEK_TO, timestampUs).sendToTarget();
+    }
+
+    public int readSample(int trackIndex, SampleHolder sampleHolder) throws Exception {
+      // Block until the extractor has completed readSample.
+      pendingOperationLatch = new CountDownLatch(1);
+      handler.obtainMessage(MSG_READ_SAMPLE, trackIndex, 0, sampleHolder).sendToTarget();
+      pendingOperationLatch.await();
+      if (exception != null) {
+        throw exception;
+      }
+      return readSampleResult;
+    }
+
+    @SuppressLint("HandlerLeak")
+    @Override
+    public void run() {
+      final ExtractorSampleSource source = new ExtractorSampleSource(FAKE_URI, dataSource,
+          new Mp4Extractor(), 1, 2 * 1024 * 1024);
+      Looper.prepare();
+      handler = new Handler() {
+
+        @Override
+        public void handleMessage(Message message) {
+          try {
+            switch (message.what) {
+              case MSG_PREPARE:
+                if (!source.prepare(0)) {
+                  sendEmptyMessage(MSG_PREPARE);
+                } else {
+                  // Select the video track and get its metadata.
+                  mediaFormats = new MediaFormat[source.getTrackCount()];
+                  MediaFormatHolder mediaFormatHolder = new MediaFormatHolder();
+                  for (int track = 0; track < source.getTrackCount(); track++) {
+                    source.enable(track, 0);
+                    source.readData(track, 0, mediaFormatHolder, null, false);
+                    MediaFormat mediaFormat = mediaFormatHolder.format;
+                    mediaFormats[track] = mediaFormat;
+                    if (MimeTypes.isVideo(mediaFormat.mimeType)) {
+                      selectedTrackMediaFormat = mediaFormat;
+                    } else {
+                      source.disable(track);
+                    }
+                  }
+                  pendingOperationLatch.countDown();
+                }
+                break;
+              case MSG_SEEK_TO:
+                long timestampUs = (Long) message.obj;
+                source.seekToUs(timestampUs);
+                break;
+              case MSG_READ_SAMPLE:
+                int trackIndex = message.arg1;
+                SampleHolder sampleHolder = (SampleHolder) message.obj;
+                sampleHolder.clearData();
+                readSampleResult = source.readData(trackIndex, 0, null, sampleHolder, false);
+                if (readSampleResult == SampleSource.NOTHING_READ) {
+                  Message.obtain(message).sendToTarget();
+                  return;
+                }
+                pendingOperationLatch.countDown();
+                break;
+            }
+          } catch (Exception e) {
+            exception = e;
+            pendingOperationLatch.countDown();
+          }
+        }
+      };
+
+      // Unblock waiting for the handler.
+      pendingOperationLatch.countDown();
+
+      Looper.loop();
+    }
+
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
new file mode 100644
index 0000000000..2642c71360
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.testutil.FakeDataSource;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import android.net.Uri;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Tests {@link DefaultEbmlReader}.
+ */
+public class DefaultEbmlReaderTest extends TestCase {
+
+  public void testMasterElement() throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(0x1A, 0x45, 0xDF, 0xA3, 0x84, 0x42, 0x85, 0x81, 0x01);
+    TestOutput expected = new TestOutput();
+    expected.startMasterElement(TestOutput.ID_EBML, 5, 4);
+    expected.integerElement(TestOutput.ID_DOC_TYPE_READ_VERSION, 1);
+    expected.endMasterElement(TestOutput.ID_EBML);
+    assertEvents(input, expected.events);
+  }
+
+  public void testMasterElementEmpty() throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(0x18, 0x53, 0x80, 0x67, 0x80);
+    TestOutput expected = new TestOutput();
+    expected.startMasterElement(TestOutput.ID_SEGMENT, 5, 0);
+    expected.endMasterElement(TestOutput.ID_SEGMENT);
+    assertEvents(input, expected.events);
+  }
+
+  public void testUnsignedIntegerElement() throws IOException, InterruptedException {
+    // 0xFE is chosen because for signed integers it should be interpreted as -2
+    ExtractorInput input = createTestInput(0x42, 0xF7, 0x81, 0xFE);
+    TestOutput expected = new TestOutput();
+    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, 254);
+    assertEvents(input, expected.events);
+  }
+
+  public void testUnsignedIntegerElementLarge() throws IOException, InterruptedException {
+    ExtractorInput input =
+        createTestInput(0x42, 0xF7, 0x88, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
+    TestOutput expected = new TestOutput();
+    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, Long.MAX_VALUE);
+    assertEvents(input, expected.events);
+  }
+
+  public void testUnsignedIntegerElementTooLargeBecomesNegative()
+      throws IOException, InterruptedException {
+    ExtractorInput input =
+        createTestInput(0x42, 0xF7, 0x88, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
+    TestOutput expected = new TestOutput();
+    expected.integerElement(TestOutput.ID_EBML_READ_VERSION, -1);
+    assertEvents(input, expected.events);
+  }
+
+  public void testStringElement() throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(0x42, 0x82, 0x86, 0x41, 0x62, 0x63, 0x31, 0x32, 0x33);
+    TestOutput expected = new TestOutput();
+    expected.stringElement(TestOutput.ID_DOC_TYPE, "Abc123");
+    assertEvents(input, expected.events);
+  }
+
+  public void testStringElementEmpty() throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(0x42, 0x82, 0x80);
+    TestOutput expected = new TestOutput();
+    expected.stringElement(TestOutput.ID_DOC_TYPE, "");
+    assertEvents(input, expected.events);
+  }
+
+  public void testFloatElementFourBytes() throws IOException, InterruptedException {
+    ExtractorInput input =
+        createTestInput(0x44, 0x89, 0x84, 0x3F, 0x80, 0x00, 0x00);
+    TestOutput expected = new TestOutput();
+    expected.floatElement(TestOutput.ID_DURATION, 1.0);
+    assertEvents(input, expected.events);
+  }
+
+  public void testFloatElementEightBytes() throws IOException, InterruptedException {
+    ExtractorInput input =
+        createTestInput(0x44, 0x89, 0x88, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+    TestOutput expected = new TestOutput();
+    expected.floatElement(TestOutput.ID_DURATION, -2.0);
+    assertEvents(input, expected.events);
+  }
+
+  public void testBinaryElement() throws IOException, InterruptedException {
+    ExtractorInput input =
+        createTestInput(0xA3, 0x88, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08);
+    TestOutput expected = new TestOutput();
+    expected.binaryElement(TestOutput.ID_SIMPLE_BLOCK, 8,
+        createTestInput(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08));
+    assertEvents(input, expected.events);
+  }
+
+  private static void assertEvents(ExtractorInput input, List<String> expectedEvents)
+      throws IOException, InterruptedException {
+    DefaultEbmlReader reader = new DefaultEbmlReader();
+    TestOutput output = new TestOutput();
+    reader.init(output);
+
+    // We expect the number of successful reads to equal the number of expected events.
+    for (int i = 0; i < expectedEvents.size(); i++) {
+      assertTrue(reader.read(input));
+    }
+    // The next read should be unsuccessful.
+    assertFalse(reader.read(input));
+    // Check that we really did get to the end of input.
+    assertFalse(input.readFully(new byte[1], 0, 1, true));
+
+    assertEquals(expectedEvents.size(), output.events.size());
+    for (int i = 0; i < expectedEvents.size(); i++) {
+      assertEquals(expectedEvents.get(i), output.events.get(i));
+    }
+  }
+
+  /**
+   * Helper to build an {@link ExtractorInput} from byte data.
+   * <p>
+   * Each argument must be able to cast to a byte value.
+   *
+   * @param data Zero or more integers with values between {@code 0x00} and {@code 0xFF}.
+   * @return An {@link ExtractorInput} from which the data can be read.
+   * @throws IOException If an error occurs creating the input.
+   */
+  private static ExtractorInput createTestInput(int... data) throws IOException {
+    byte[] bytes = new byte[data.length];
+    for (int i = 0; i < data.length; i++) {
+      bytes[i] = (byte) data[i];
+    }
+    DataSource dataSource = new FakeDataSource.Builder().appendReadData(bytes).build();
+    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
+    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    return input;
+  }
+
+  /**
+   * An {@link EbmlReaderOutput} that records each event callback.
+   */
+  private static final class TestOutput implements EbmlReaderOutput {
+
+    // Element IDs
+    private static final int ID_EBML = 0x1A45DFA3;
+    private static final int ID_EBML_READ_VERSION = 0x42F7;
+    private static final int ID_DOC_TYPE = 0x4282;
+    private static final int ID_DOC_TYPE_READ_VERSION = 0x4285;
+
+    private static final int ID_SEGMENT = 0x18538067;
+    private static final int ID_DURATION = 0x4489;
+    private static final int ID_SIMPLE_BLOCK = 0xA3;
+
+    private final List<String> events = new ArrayList<String>();
+
+    @Override
+    public int getElementType(int id) {
+      switch (id) {
+        case ID_EBML:
+        case ID_SEGMENT:
+          return EbmlReader.TYPE_MASTER;
+        case ID_EBML_READ_VERSION:
+        case ID_DOC_TYPE_READ_VERSION:
+          return EbmlReader.TYPE_UNSIGNED_INT;
+        case ID_DOC_TYPE:
+          return EbmlReader.TYPE_STRING;
+        case ID_SIMPLE_BLOCK:
+          return EbmlReader.TYPE_BINARY;
+        case ID_DURATION:
+          return EbmlReader.TYPE_FLOAT;
+        default:
+          return EbmlReader.TYPE_UNKNOWN;
+      }
+    }
+
+    @Override
+    public void startMasterElement(int id, long contentPosition, long contentSize) {
+      events.add(formatEvent(id, "start contentPosition=" + contentPosition
+          + " contentSize=" + contentSize));
+    }
+
+    @Override
+    public void endMasterElement(int id) {
+      events.add(formatEvent(id, "end"));
+    }
+
+    @Override
+    public void integerElement(int id, long value) {
+      events.add(formatEvent(id, "integer=" + String.valueOf(value)));
+    }
+
+    @Override
+    public void floatElement(int id, double value) {
+      events.add(formatEvent(id, "float=" + String.valueOf(value)));
+    }
+
+    @Override
+    public void stringElement(int id, String value) {
+      events.add(formatEvent(id, "string=" + value));
+    }
+
+    @Override
+    public void binaryElement(int id, int contentSize, ExtractorInput input)
+        throws IOException, InterruptedException {
+      byte[] bytes = new byte[contentSize];
+      input.readFully(bytes, 0, contentSize);
+      events.add(formatEvent(id, "bytes=" + Arrays.toString(bytes)));
+    }
+
+    private static String formatEvent(int id, String event) {
+      return "[" + Integer.toHexString(id) + "] " + event;
+    }
+
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
new file mode 100644
index 0000000000..ccd40b16dc
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.testutil.FakeDataSource;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import android.net.Uri;
+
+import junit.framework.TestCase;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Tests for {@link VarintReader}.
+ */
+public class VarintReaderTest extends TestCase {
+
+  private static final String TEST_URI = "http://www.google.com";
+  private static final byte MAX_BYTE = (byte) 0xFF;
+
+  private static final byte[] DATA_1_BYTE_0 = new byte[] {(byte) 0x80};
+  private static final byte[] DATA_2_BYTE_0 = new byte[] {0x40, 0};
+  private static final byte[] DATA_3_BYTE_0 = new byte[] {0x20, 0, 0};
+  private static final byte[] DATA_4_BYTE_0 = new byte[] {0x10, 0, 0, 0};
+  private static final byte[] DATA_5_BYTE_0 = new byte[] {0x08, 0, 0, 0, 0};
+  private static final byte[] DATA_6_BYTE_0 = new byte[] {0x04, 0, 0, 0, 0, 0};
+  private static final byte[] DATA_7_BYTE_0 = new byte[] {0x02, 0, 0, 0, 0, 0, 0};
+  private static final byte[] DATA_8_BYTE_0 = new byte[] {0x01, 0, 0, 0, 0, 0, 0, 0};
+
+  private static final byte[] DATA_1_BYTE_64 = new byte[] {(byte) 0xC0};
+  private static final byte[] DATA_2_BYTE_64 = new byte[] {0x40, 0x40};
+  private static final byte[] DATA_3_BYTE_64 = new byte[] {0x20, 0, 0x40};
+  private static final byte[] DATA_4_BYTE_64 = new byte[] {0x10, 0, 0, 0x40};
+  private static final byte[] DATA_5_BYTE_64 = new byte[] {0x08, 0, 0, 0, 0x40};
+  private static final byte[] DATA_6_BYTE_64 = new byte[] {0x04, 0, 0, 0, 0, 0x40};
+  private static final byte[] DATA_7_BYTE_64 = new byte[] {0x02, 0, 0, 0, 0, 0, 0x40};
+  private static final byte[] DATA_8_BYTE_64 = new byte[] {0x01, 0, 0, 0, 0, 0, 0, 0x40};
+
+  private static final byte[] DATA_1_BYTE_MAX = new byte[] {MAX_BYTE};
+  private static final byte[] DATA_2_BYTE_MAX = new byte[] {0x7F, MAX_BYTE};
+  private static final byte[] DATA_3_BYTE_MAX = new byte[] {0x3F, MAX_BYTE, MAX_BYTE};
+  private static final byte[] DATA_4_BYTE_MAX = new byte[] {0x1F, MAX_BYTE, MAX_BYTE, MAX_BYTE};
+  private static final byte[] DATA_5_BYTE_MAX =
+      new byte[] {0x0F, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE};
+  private static final byte[] DATA_6_BYTE_MAX =
+      new byte[] {0x07, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE};
+  private static final byte[] DATA_7_BYTE_MAX =
+      new byte[] {0x03, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE};
+  private static final byte[] DATA_8_BYTE_MAX =
+      new byte[] {0x01, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE, MAX_BYTE};
+
+  private static final long VALUE_1_BYTE_MAX = 0x7F;
+  private static final long VALUE_1_BYTE_MAX_WITH_MASK = 0xFF;
+  private static final long VALUE_2_BYTE_MAX = 0x3FFF;
+  private static final long VALUE_2_BYTE_MAX_WITH_MASK = 0x7FFF;
+  private static final long VALUE_3_BYTE_MAX = 0x1FFFFF;
+  private static final long VALUE_3_BYTE_MAX_WITH_MASK = 0x3FFFFF;
+  private static final long VALUE_4_BYTE_MAX = 0xFFFFFFF;
+  private static final long VALUE_4_BYTE_MAX_WITH_MASK = 0x1FFFFFFF;
+  private static final long VALUE_5_BYTE_MAX = 0x7FFFFFFFFL;
+  private static final long VALUE_5_BYTE_MAX_WITH_MASK = 0xFFFFFFFFFL;
+  private static final long VALUE_6_BYTE_MAX = 0x3FFFFFFFFFFL;
+  private static final long VALUE_6_BYTE_MAX_WITH_MASK = 0x7FFFFFFFFFFL;
+  private static final long VALUE_7_BYTE_MAX = 0x1FFFFFFFFFFFFL;
+  private static final long VALUE_7_BYTE_MAX_WITH_MASK = 0x3FFFFFFFFFFFFL;
+  private static final long VALUE_8_BYTE_MAX = 0xFFFFFFFFFFFFFFL;
+  private static final long VALUE_8_BYTE_MAX_WITH_MASK = 0x1FFFFFFFFFFFFFFL;
+
+  public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedException {
+    VarintReader reader = new VarintReader();
+    // Build an input, and read to the end.
+    DataSource dataSource = buildDataSource(new byte[1]);
+    dataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    int bytesRead = input.read(new byte[1], 0, 1);
+    assertEquals(1, bytesRead);
+    // End of input allowed.
+    long result = reader.readUnsignedVarint(input, true, false);
+    assertEquals(-1, result);
+    // End of input not allowed.
+    try {
+      reader.readUnsignedVarint(input, false, false);
+      fail();
+    } catch (EOFException e) {
+      // Expected.
+    }
+  }
+
+  public void testReadVarint() throws IOException, InterruptedException {
+    VarintReader reader = new VarintReader();
+    testReadVarint(reader, true, DATA_1_BYTE_0, 1, 0);
+    testReadVarint(reader, true, DATA_2_BYTE_0, 2, 0);
+    testReadVarint(reader, true, DATA_3_BYTE_0, 3, 0);
+    testReadVarint(reader, true, DATA_4_BYTE_0, 4, 0);
+    testReadVarint(reader, true, DATA_5_BYTE_0, 5, 0);
+    testReadVarint(reader, true, DATA_6_BYTE_0, 6, 0);
+    testReadVarint(reader, true, DATA_7_BYTE_0, 7, 0);
+    testReadVarint(reader, true, DATA_8_BYTE_0, 8, 0);
+    testReadVarint(reader, true, DATA_1_BYTE_64, 1, 64);
+    testReadVarint(reader, true, DATA_2_BYTE_64, 2, 64);
+    testReadVarint(reader, true, DATA_3_BYTE_64, 3, 64);
+    testReadVarint(reader, true, DATA_4_BYTE_64, 4, 64);
+    testReadVarint(reader, true, DATA_5_BYTE_64, 5, 64);
+    testReadVarint(reader, true, DATA_6_BYTE_64, 6, 64);
+    testReadVarint(reader, true, DATA_7_BYTE_64, 7, 64);
+    testReadVarint(reader, true, DATA_8_BYTE_64, 8, 64);
+    testReadVarint(reader, true, DATA_1_BYTE_MAX, 1, VALUE_1_BYTE_MAX);
+    testReadVarint(reader, true, DATA_2_BYTE_MAX, 2, VALUE_2_BYTE_MAX);
+    testReadVarint(reader, true, DATA_3_BYTE_MAX, 3, VALUE_3_BYTE_MAX);
+    testReadVarint(reader, true, DATA_4_BYTE_MAX, 4, VALUE_4_BYTE_MAX);
+    testReadVarint(reader, true, DATA_5_BYTE_MAX, 5, VALUE_5_BYTE_MAX);
+    testReadVarint(reader, true, DATA_6_BYTE_MAX, 6, VALUE_6_BYTE_MAX);
+    testReadVarint(reader, true, DATA_7_BYTE_MAX, 7, VALUE_7_BYTE_MAX);
+    testReadVarint(reader, true, DATA_8_BYTE_MAX, 8, VALUE_8_BYTE_MAX);
+    testReadVarint(reader, false, DATA_1_BYTE_MAX, 1, VALUE_1_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_2_BYTE_MAX, 2, VALUE_2_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_3_BYTE_MAX, 3, VALUE_3_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_4_BYTE_MAX, 4, VALUE_4_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_5_BYTE_MAX, 5, VALUE_5_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_6_BYTE_MAX, 6, VALUE_6_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_7_BYTE_MAX, 7, VALUE_7_BYTE_MAX_WITH_MASK);
+    testReadVarint(reader, false, DATA_8_BYTE_MAX, 8, VALUE_8_BYTE_MAX_WITH_MASK);
+  }
+
+  public void testReadVarintFlaky() throws IOException, InterruptedException {
+    VarintReader reader = new VarintReader();
+    testReadVarintFlaky(reader, true, DATA_1_BYTE_0, 1, 0);
+    testReadVarintFlaky(reader, true, DATA_2_BYTE_0, 2, 0);
+    testReadVarintFlaky(reader, true, DATA_3_BYTE_0, 3, 0);
+    testReadVarintFlaky(reader, true, DATA_4_BYTE_0, 4, 0);
+    testReadVarintFlaky(reader, true, DATA_5_BYTE_0, 5, 0);
+    testReadVarintFlaky(reader, true, DATA_6_BYTE_0, 6, 0);
+    testReadVarintFlaky(reader, true, DATA_7_BYTE_0, 7, 0);
+    testReadVarintFlaky(reader, true, DATA_8_BYTE_0, 8, 0);
+    testReadVarintFlaky(reader, true, DATA_1_BYTE_64, 1, 64);
+    testReadVarintFlaky(reader, true, DATA_2_BYTE_64, 2, 64);
+    testReadVarintFlaky(reader, true, DATA_3_BYTE_64, 3, 64);
+    testReadVarintFlaky(reader, true, DATA_4_BYTE_64, 4, 64);
+    testReadVarintFlaky(reader, true, DATA_5_BYTE_64, 5, 64);
+    testReadVarintFlaky(reader, true, DATA_6_BYTE_64, 6, 64);
+    testReadVarintFlaky(reader, true, DATA_7_BYTE_64, 7, 64);
+    testReadVarintFlaky(reader, true, DATA_8_BYTE_64, 8, 64);
+    testReadVarintFlaky(reader, true, DATA_1_BYTE_MAX, 1, VALUE_1_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_2_BYTE_MAX, 2, VALUE_2_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_3_BYTE_MAX, 3, VALUE_3_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_4_BYTE_MAX, 4, VALUE_4_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_5_BYTE_MAX, 5, VALUE_5_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_6_BYTE_MAX, 6, VALUE_6_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_7_BYTE_MAX, 7, VALUE_7_BYTE_MAX);
+    testReadVarintFlaky(reader, true, DATA_8_BYTE_MAX, 8, VALUE_8_BYTE_MAX);
+    testReadVarintFlaky(reader, false, DATA_1_BYTE_MAX, 1, VALUE_1_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_2_BYTE_MAX, 2, VALUE_2_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_3_BYTE_MAX, 3, VALUE_3_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_4_BYTE_MAX, 4, VALUE_4_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_5_BYTE_MAX, 5, VALUE_5_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_6_BYTE_MAX, 6, VALUE_6_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_7_BYTE_MAX, 7, VALUE_7_BYTE_MAX_WITH_MASK);
+    testReadVarintFlaky(reader, false, DATA_8_BYTE_MAX, 8, VALUE_8_BYTE_MAX_WITH_MASK);
+  }
+
+  private static void testReadVarint(VarintReader reader, boolean removeMask, byte[] data,
+      int expectedLength, long expectedValue) throws IOException, InterruptedException {
+    DataSource dataSource = buildDataSource(data);
+    dataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    long result = reader.readUnsignedVarint(input, false, removeMask);
+    assertEquals(expectedLength, input.getPosition());
+    assertEquals(expectedValue, result);
+  }
+
+  private static void testReadVarintFlaky(VarintReader reader, boolean removeMask, byte[] data,
+      int expectedLength, long expectedValue) throws IOException, InterruptedException {
+    DataSource dataSource = buildFlakyDataSource(data);
+    ExtractorInput input = null;
+    long position = 0;
+    long result = -1;
+    while (result == -1) {
+      dataSource.open(new DataSpec(Uri.parse(TEST_URI), position, C.LENGTH_UNBOUNDED, null));
+      input = new DefaultExtractorInput(dataSource, position, C.LENGTH_UNBOUNDED);
+      try {
+        result = reader.readUnsignedVarint(input, false, removeMask);
+        position = input.getPosition();
+      } catch (IOException e) {
+        // Expected. We'll try again from the position that the input was advanced to.
+        position = input.getPosition();
+        dataSource.close();
+      }
+    }
+    assertEquals(expectedLength, input.getPosition());
+    assertEquals(expectedValue, result);
+  }
+
+  private static DataSource buildDataSource(byte[] data) {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(data);
+    return builder.build();
+  }
+
+  private static DataSource buildFlakyDataSource(byte[] data) {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadError(new IOException("A"));
+    builder.appendReadData(new byte[] {data[0]});
+    if (data.length > 1) {
+      builder.appendReadError(new IOException("B"));
+      builder.appendReadData(new byte[] {data[1]});
+    }
+    if (data.length > 2) {
+      builder.appendReadError(new IOException("C"));
+      builder.appendReadData(Arrays.copyOfRange(data, 2, data.length));
+    }
+    return builder.build();
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
new file mode 100644
index 0000000000..8d51e13f61
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -0,0 +1,944 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ChunkIndex;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.testutil.FakeDataSource;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.net.Uri;
+import android.test.InstrumentationTestCase;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.UUID;
+
+/**
+ * Tests for {@link WebmExtractor}.
+ */
+public class WebmExtractorTest extends InstrumentationTestCase {
+
+  private static final int CUE_POINT_ELEMENT_BYTE_SIZE = 31;
+
+  private static final int DEFAULT_TIMECODE_SCALE = 1000000;
+
+  private static final long TEST_DURATION_US = 9920000L;
+  private static final int TEST_WIDTH = 1280;
+  private static final int TEST_HEIGHT = 720;
+  private static final int TEST_CHANNEL_COUNT = 1;
+  private static final int TEST_SAMPLE_RATE = 48000;
+  private static final long TEST_CODEC_DELAY = 6500000;
+  private static final long TEST_SEEK_PRE_ROLL = 80000000;
+  private static final int TEST_OPUS_CODEC_PRIVATE_SIZE = 2;
+  private static final String TEST_VORBIS_CODEC_PRIVATE = "webm/vorbis_codec_private";
+  private static final int TEST_VORBIS_INFO_SIZE = 30;
+  private static final int TEST_VORBIS_BOOKS_SIZE = 4140;
+  private static final byte[] TEST_ENCRYPTION_KEY_ID = { 0x00, 0x01, 0x02, 0x03 };
+  private static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+  private static final UUID ZERO_UUID = new UUID(0, 0);
+  private static final byte[] TEST_INITIALIZATION_VECTOR = {
+      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
+  };
+
+  private static final int ID_VP9 = 0;
+  private static final int ID_OPUS = 1;
+  private static final int ID_VORBIS = 2;
+  private static final int ID_DUMMY = 3;
+
+  private WebmExtractor extractor;
+  private TestExtractorOutput extractorOutput;
+  private TestTrackOutput audioOutput;
+  private TestTrackOutput videoOutput;
+
+  @Override
+  public void setUp() {
+    extractor = new WebmExtractor();
+    extractorOutput = new TestExtractorOutput();
+    audioOutput = new TestTrackOutput();
+    videoOutput = new TestTrackOutput();
+    extractor.init(extractorOutput);
+  }
+
+  @Override
+  public void tearDown() {
+    extractor = null;
+    extractorOutput = null;
+    audioOutput = null;
+    videoOutput = null;
+  }
+
+  public void testReadInitializationSegment() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, null));
+    assertVideoFormat();
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareOpus() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_OPUS}, null));
+    assertAudioFormat(ID_OPUS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareVorbis() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VORBIS}, null));
+    assertAudioFormat(ID_VORBIS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareTwoTracks() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9, ID_OPUS}, null));
+    assertEquals(2, extractorOutput.numberOfTracks);
+    assertVideoFormat();
+    assertAudioFormat(ID_OPUS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareThreeTracks() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9, ID_DUMMY, ID_OPUS}, null));
+    // Eventhough the input stream has 3 tracks, only 2 of them are supported and will be reported.
+    assertEquals(2, extractorOutput.numberOfTracks);
+    assertVideoFormat();
+    assertAudioFormat(ID_OPUS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareFourTracks() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9, ID_VORBIS, ID_VP9, ID_OPUS}, null));
+    // Eventhough the input stream has 4 supported tracks, only the first video and audio track will
+    // be reported.
+    assertEquals(2, extractorOutput.numberOfTracks);
+    assertVideoFormat();
+    assertAudioFormat(ID_VORBIS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareContentEncodingEncryption() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
+    consume(
+        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, settings));
+    assertVideoFormat();
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    DrmInitData drmInitData = extractorOutput.drmInitData;
+    assertNotNull(drmInitData);
+    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, drmInitData.get(WIDEVINE_UUID));
+    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, drmInitData.get(ZERO_UUID));
+  }
+
+  public void testPrepareThreeCuePoints() throws IOException, InterruptedException {
+    consume(
+        createInitializationSegment(3, 0, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, null));
+    assertVideoFormat();
+    assertIndex(
+        new IndexPoint(0, 0, 10000),
+        new IndexPoint(10000, 0, 10000),
+        new IndexPoint(20000, 0, TEST_DURATION_US - 20000));
+  }
+
+  public void testPrepareCustomTimecodeScale() throws IOException, InterruptedException {
+    consume(createInitializationSegment(3, 0, true, 1000, new int[] {ID_VP9}, null));
+    assertVideoFormat();
+    assertIndex(
+        new IndexPoint(0, 0, 10),
+        new IndexPoint(10, 0, 10),
+        new IndexPoint(20, 0, (TEST_DURATION_US / 1000) - 20));
+  }
+
+  public void testPrepareNoCuePoints() throws IOException, InterruptedException {
+    try {
+      consume(
+          createInitializationSegment(0, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, null));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("Invalid/missing cue points", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidDocType() throws IOException, InterruptedException {
+    try {
+      consume(
+          createInitializationSegment(1, 0, false, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, null));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("DocType webB not supported", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidContentEncodingOrder() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(1, 1, 1, 5, 1);
+    try {
+      consume(
+          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, settings));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("ContentEncodingOrder 1 not supported", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidContentEncodingScope() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 0, 1, 5, 1);
+    try {
+      consume(
+          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, settings));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("ContentEncodingScope 0 not supported", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidContentEncodingType() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 0, 5, 1);
+    try {
+      consume(
+          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, settings));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("ContentEncodingType 0 not supported", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidContentEncAlgo() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 4, 1);
+    try {
+      consume(
+          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, settings));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("ContentEncAlgo 4 not supported", exception.getMessage());
+    }
+  }
+
+  public void testPrepareInvalidAESSettingsCipherMode() throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 0);
+    try {
+      consume(
+          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
+              new int[] {ID_VP9}, settings));
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("AESSettingsCipherMode 0 not supported", exception.getMessage());
+    }
+  }
+
+  public void testReadSampleKeyframe() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 0, true, false, false, videoOutput);
+  }
+
+  public void testReadTwoTrackSamples() throws IOException, InterruptedException {
+    MediaSegment mediaSegmentAudio =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 2);
+    MediaSegment mediaSegmentVideo =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegmentAudio.clusterBytes.length + mediaSegmentVideo.clusterBytes.length,
+            true, DEFAULT_TIMECODE_SCALE, new int[] {ID_VP9, ID_OPUS}, null),
+        mediaSegmentVideo.clusterBytes, mediaSegmentAudio.clusterBytes);
+    consume(testInputData);
+    assertEquals(2, extractorOutput.numberOfTracks);
+    assertVideoFormat();
+    assertAudioFormat(ID_OPUS);
+    assertSample(mediaSegmentVideo, 0, true, false, false, videoOutput);
+    assertSample(mediaSegmentAudio, 0, true, false, false, audioOutput);
+  }
+
+  public void testReadTwoTrackSamplesWithSkippedTrack() throws IOException, InterruptedException {
+    MediaSegment mediaSegmentAudio =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 2);
+    MediaSegment mediaSegmentVideo =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
+    MediaSegment mediaSegmentDummy =
+        createMediaSegment(100, 0, 0, true, false, true, false, false, 17);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1,
+            mediaSegmentAudio.clusterBytes.length + mediaSegmentVideo.clusterBytes.length
+                + mediaSegmentDummy.clusterBytes.length,
+            true, DEFAULT_TIMECODE_SCALE, new int[] {ID_DUMMY, ID_VP9, ID_OPUS}, null),
+        mediaSegmentVideo.clusterBytes,
+        mediaSegmentDummy.clusterBytes,
+        mediaSegmentAudio.clusterBytes);
+    consume(testInputData);
+    assertEquals(2, extractorOutput.numberOfTracks);
+    assertVideoFormat();
+    assertAudioFormat(ID_OPUS);
+    assertSample(mediaSegmentVideo, 0, true, false, false, videoOutput);
+    assertSample(mediaSegmentAudio, 0, true, false, false, audioOutput);
+  }
+
+  public void testReadBlock() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 0, 0, true, false, false, false, false, 2);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_OPUS}, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertAudioFormat(ID_OPUS);
+    assertSample(mediaSegment, 0, true, false, false, audioOutput);
+  }
+
+  public void testReadBlockNonKeyframe() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 0, 0, false, false, false, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] { ID_VP9 }, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 0, false, false, false, videoOutput);
+  }
+
+  public void testReadEncryptedFrame() throws IOException, InterruptedException {
+    MediaSegment mediaSegment = createMediaSegment(100, 0, 0, true, false, true, true, true, 1);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, settings),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 0, true, false, true, videoOutput);
+  }
+
+  public void testReadEncryptedFrameWithInvalidSignalByte()
+      throws IOException, InterruptedException {
+    MediaSegment mediaSegment = createMediaSegment(100, 0, 0, true, false, true, true, false, 1);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, settings),
+        mediaSegment.clusterBytes);
+    try {
+      consume(testInputData);
+      fail();
+    } catch (ParserException exception) {
+      assertEquals("Extension bit is set in signal byte", exception.getMessage());
+    }
+  }
+
+  public void testReadSampleInvisible() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 12, 13, false, true, true, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 25000, false, true, false, videoOutput);
+  }
+
+  public void testReadSampleCustomTimescale() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 12, 13, false, false, true, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, 1000, new int[] {ID_VP9}, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 25, false, false, false, videoOutput);
+  }
+
+  public void testReadSampleNegativeSimpleBlockTimecode() throws IOException, InterruptedException {
+    MediaSegment mediaSegment =
+        createMediaSegment(100, 13, -12, true, true, true, false, false, 1);
+    byte[] testInputData = joinByteArrays(
+        createInitializationSegment(
+            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
+            new int[] {ID_VP9}, null),
+        mediaSegment.clusterBytes);
+    consume(testInputData);
+    assertVideoFormat();
+    assertSample(mediaSegment, 1000, true, true, false, videoOutput);
+  }
+
+  private void consume(byte[] data) throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(data);
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult == Extractor.RESULT_CONTINUE) {
+      readResult = extractor.read(input, null);
+    }
+    assertEquals(Extractor.RESULT_END_OF_INPUT, readResult);
+  }
+
+  private static ExtractorInput createTestInput(byte[] data) throws IOException {
+    DataSource dataSource = new FakeDataSource.Builder().appendReadData(data).build();
+    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
+    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    return input;
+  }
+
+  private void assertVideoFormat() {
+    MediaFormat format = videoOutput.format;
+    assertEquals(TEST_WIDTH, format.width);
+    assertEquals(TEST_HEIGHT, format.height);
+    assertEquals(MimeTypes.VIDEO_VP9, format.mimeType);
+  }
+
+  private void assertAudioFormat(int codecId) {
+    MediaFormat format = audioOutput.format;
+    assertEquals(TEST_CHANNEL_COUNT, format.channelCount);
+    assertEquals(TEST_SAMPLE_RATE, format.sampleRate);
+    if (codecId == ID_OPUS) {
+      assertEquals(MimeTypes.AUDIO_OPUS, format.mimeType);
+      assertEquals(3, format.initializationData.size());
+      assertEquals(TEST_OPUS_CODEC_PRIVATE_SIZE, format.initializationData.get(0).length);
+      assertEquals(TEST_CODEC_DELAY, ByteBuffer.wrap(format.initializationData.get(1)).getLong());
+      assertEquals(TEST_SEEK_PRE_ROLL, ByteBuffer.wrap(format.initializationData.get(2)).getLong());
+    } else if (codecId == ID_VORBIS) {
+      assertEquals(MimeTypes.AUDIO_VORBIS, format.mimeType);
+      assertEquals(2, format.initializationData.size());
+      assertEquals(TEST_VORBIS_INFO_SIZE, format.initializationData.get(0).length);
+      assertEquals(TEST_VORBIS_BOOKS_SIZE, format.initializationData.get(1).length);
+    }
+  }
+
+  private void assertIndex(IndexPoint... indexPoints) {
+    ChunkIndex index = (ChunkIndex) extractorOutput.seekMap;
+    assertEquals(indexPoints.length, index.length);
+    for (int i = 0; i < indexPoints.length; i++) {
+      IndexPoint indexPoint = indexPoints[i];
+      assertEquals(indexPoint.timeUs, index.timesUs[i]);
+      assertEquals(indexPoint.size, index.sizes[i]);
+      assertEquals(indexPoint.durationUs, index.durationsUs[i]);
+    }
+  }
+
+  private void assertSample(MediaSegment mediaSegment, int timeUs, boolean keyframe,
+      boolean invisible, boolean encrypted, TestTrackOutput output) {
+    byte[] expectedOutput = mediaSegment.data;
+    if (encrypted) {
+      expectedOutput = joinByteArrays(new byte[] {(byte) TEST_INITIALIZATION_VECTOR.length},
+          TEST_INITIALIZATION_VECTOR, expectedOutput);
+    }
+    assertTrue(Arrays.equals(expectedOutput, output.sampleData));
+    assertEquals(timeUs, output.sampleTimeUs);
+    assertEquals(keyframe, (output.sampleFlags & C.SAMPLE_FLAG_SYNC) != 0);
+    assertEquals(invisible, (output.sampleFlags & C.SAMPLE_FLAG_DECODE_ONLY) != 0);
+    assertEquals(encrypted, (output.sampleFlags & C.SAMPLE_FLAG_ENCRYPTED) != 0);
+  }
+
+  private byte[] createInitializationSegment(int cuePoints, int mediaSegmentSize,
+      boolean docTypeIsWebm, int timecodeScale, int[] codecIds,
+      ContentEncodingSettings contentEncodingSettings) {
+    byte[] tracksElement = createTracksElement(codecIds, contentEncodingSettings);
+    byte[] infoElement = createInfoElement(timecodeScale);
+    byte[] cuesElement = createCuesElement(CUE_POINT_ELEMENT_BYTE_SIZE * cuePoints);
+    int initalizationSegmentSize = infoElement.length + tracksElement.length
+        + cuesElement.length + CUE_POINT_ELEMENT_BYTE_SIZE * cuePoints;
+    byte[] segmentElement = createSegmentElement(initalizationSegmentSize + mediaSegmentSize);
+    byte[] bytes = joinByteArrays(createEbmlElement(1, docTypeIsWebm, 2),
+        segmentElement, infoElement, tracksElement, cuesElement);
+    for (int i = 0; i < cuePoints; i++) {
+      bytes = joinByteArrays(bytes, createCuePointElement(10 * i, initalizationSegmentSize));
+    }
+    return bytes;
+  }
+
+  private byte[] createTracksElement(int[] codecIds,
+      ContentEncodingSettings contentEncodingSettings) {
+    byte[] trackBytes = new byte[0];
+    for (int codecId : codecIds) {
+      switch (codecId) {
+        case ID_VP9:
+          trackBytes = joinByteArrays(trackBytes,
+              createVideoTrackEntry(true, TEST_WIDTH, TEST_HEIGHT, contentEncodingSettings));
+          break;
+        case ID_OPUS:
+          trackBytes = joinByteArrays(trackBytes, createOpusAudioTrackEntry(TEST_CHANNEL_COUNT));
+          break;
+        case ID_VORBIS:
+          trackBytes = joinByteArrays(trackBytes, createVorbisAudioTrackEntry(TEST_CHANNEL_COUNT));
+          break;
+        case ID_DUMMY:
+          trackBytes = joinByteArrays(trackBytes, createUnsupportedTrackEntry());
+          break;
+      }
+    }
+    byte[] tracksSize = getIntegerBytes(trackBytes.length);
+    byte[] tracksHeader = createByteArray(
+        0x16, 0x54, 0xAE, 0x6B, // Tracks
+        0x01, 0x00, 0x00, 0x00, tracksSize[0], tracksSize[1], tracksSize[2], tracksSize[3]);
+    return joinByteArrays(tracksHeader, trackBytes);
+  }
+
+  private static MediaSegment createMediaSegment(int dataLength, int clusterTimecode,
+      int blockTimecode, boolean keyframe, boolean invisible, boolean simple,
+      boolean encrypted, boolean validSignalByte, int trackNumber) {
+    byte[] data = createFrameData(dataLength);
+    byte[] blockBytes;
+    if (simple) {
+      blockBytes = createSimpleBlockElement(data.length, blockTimecode,
+          keyframe, invisible, true, encrypted, validSignalByte, trackNumber);
+    } else {
+      blockBytes = createBlockElement(data.length, blockTimecode,
+          keyframe, invisible, true, trackNumber);
+    }
+    byte[] clusterBytes =
+        createClusterElement(blockBytes.length + data.length, clusterTimecode);
+    return new MediaSegment(joinByteArrays(clusterBytes, blockBytes, data), data);
+  }
+
+  private static byte[] joinByteArrays(byte[]... byteArrays) {
+    int length = 0;
+    for (byte[] byteArray : byteArrays) {
+      length += byteArray.length;
+    }
+    byte[] joined = new byte[length];
+    length = 0;
+    for (byte[] byteArray : byteArrays) {
+      System.arraycopy(byteArray, 0, joined, length, byteArray.length);
+      length += byteArray.length;
+    }
+    return joined;
+  }
+
+  private static byte[] createEbmlElement(
+      int ebmlReadVersion, boolean docTypeIsWebm, int docTypeReadVersion) {
+    return createByteArray(
+        0x1A, 0x45, 0xDF, 0xA3, // EBML
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, // size=15
+        0x42, 0xF7, // EBMLReadVersion
+        0x81, ebmlReadVersion, // size=1
+        0x42, 0x82, // DocType
+        0x84, 0x77, 0x65, 0x62, docTypeIsWebm ? 0x6D : 0x42, // size=4 value=webm/B
+        0x42, 0x85, // DocTypeReadVersion
+        0x81, docTypeReadVersion); // size=1
+  }
+
+  private static byte[] createSegmentElement(int size) {
+    byte[] sizeBytes = getIntegerBytes(size);
+    return createByteArray(
+        0x18, 0x53, 0x80, 0x67, // Segment
+        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
+  }
+
+  private static byte[] createInfoElement(int timecodeScale) {
+    byte[] scaleBytes = getIntegerBytes(timecodeScale);
+    return createByteArray(
+        0x15, 0x49, 0xA9, 0x66, // Info
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, // size=19
+        0x2A, 0xD7, 0xB1, // TimecodeScale
+        0x84, scaleBytes[0], scaleBytes[1], scaleBytes[2], scaleBytes[3], // size=4
+        0x44, 0x89, // Duration
+        0x88, 0x40, 0xC3, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00); // size=8 value=9920.0
+  }
+
+  private static byte[] createVideoTrackEntry(
+      boolean codecIsVp9, int pixelWidth, int pixelHeight,
+      ContentEncodingSettings contentEncodingSettings) {
+    byte[] widthBytes = getIntegerBytes(pixelWidth);
+    byte[] heightBytes = getIntegerBytes(pixelHeight);
+    if (contentEncodingSettings != null) {
+      byte[] orderBytes = getIntegerBytes(contentEncodingSettings.order);
+      byte[] scopeBytes = getIntegerBytes(contentEncodingSettings.scope);
+      byte[] typeBytes = getIntegerBytes(contentEncodingSettings.type);
+      byte[] algorithmBytes = getIntegerBytes(contentEncodingSettings.algorithm);
+      byte[] cipherModeBytes = getIntegerBytes(contentEncodingSettings.aesCipherMode);
+      return createByteArray(
+          0xAE, // TrackEntry
+          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, // size=69
+          0x86, // CodecID
+          0x85, 0x56, 0x5F, 0x56, 0x50, codecIsVp9 ? 0x39 : 0x30, // size=5 value=V_VP9/0
+          0xD7, // TrackNumber
+          0x81, 0x01, // size=1 value=1
+          0x83, // TrackType
+          0x81, 0x01, // size=1 value=1
+          0x6D, 0x80, // ContentEncodings
+          0xA4, // size=36
+          0x62, 0x40, // ContentEncoding
+          0xA1, // size=33
+          0x50, 0x31, // ContentEncodingOrder
+          0x81, orderBytes[3],
+          0x50, 0x32, // ContentEncodingScope
+          0x81, scopeBytes[3],
+          0x50, 0x33, // ContentEncodingType
+          0x81, typeBytes[3],
+          0x50, 0x35, // ContentEncryption
+          0x92, // size=18
+          0x47, 0xE1, // ContentEncAlgo
+          0x81, algorithmBytes[3],
+          0x47, 0xE2, // ContentEncKeyID
+          0x84, // size=4
+          TEST_ENCRYPTION_KEY_ID[0], TEST_ENCRYPTION_KEY_ID[1],
+          TEST_ENCRYPTION_KEY_ID[2], TEST_ENCRYPTION_KEY_ID[3], // value=binary
+          0x47, 0xE7, // ContentEncAESSettings
+          0x84, // size=4
+          0x47, 0xE8, // AESSettingsCipherMode
+          0x81, cipherModeBytes[3],
+          0xE0, // Video
+          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // size=8
+          0xB0, // PixelWidth
+          0x82, widthBytes[2], widthBytes[3], // size=2
+          0xBA, // PixelHeight
+          0x82, heightBytes[2], heightBytes[3]); // size=2
+    } else {
+      return createByteArray(
+          0xAE, // TrackEntry
+          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, // size=30
+          0x86, // CodecID
+          0x85, 0x56, 0x5F, 0x56, 0x50, codecIsVp9 ? 0x39 : 0x30, // size=5 value=V_VP9/0
+          0xD7, // TrackNumber
+          0x81, 0x01, // size=1 value=1
+          0x83, // TrackType
+          0x81, 0x01, // size=1 value=1
+          0xE0, // Video
+          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // size=8
+          0xB0, // PixelWidth
+          0x82, widthBytes[2], widthBytes[3], // size=2
+          0xBA, // PixelHeight
+          0x82, heightBytes[2], heightBytes[3]); // size=2
+    }
+  }
+
+  private static byte[] createOpusAudioTrackEntry(int channelCount) {
+    byte[] channelCountBytes = getIntegerBytes(channelCount);
+    return createByteArray(
+        0xAE, // TrackEntry
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, // size=54
+        0x86, // CodecID
+        0x86, 0x41, 0x5F, 0x4F, 0x50, 0x55, 0x53, // size=6 value=A_OPUS
+        0xD7, // TrackNumber
+        0x81, 0x02, // size=1 value=2
+        0x83, // TrackType
+        0x81, 0x02, // size=1 value=2
+        0x56, 0xAA, // CodecDelay
+        0x83, 0x63, 0x2E, 0xA0, // size=3 value=6500000
+        0x56, 0xBB, // SeekPreRoll
+        0x84, 0x04, 0xC4, 0xB4, 0x00, // size=4 value=80000000
+        0xE1, // Audio
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, // size=13
+        0x9F, // Channels
+        0x81, channelCountBytes[3], // size=1
+        0xB5, // SamplingFrequency
+        0x88, 0x40, 0xE7, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, // size=8 value=48000
+        0x63, 0xA2, // CodecPrivate
+        0x82, 0x00, 0x00); // size=2
+  }
+
+  private byte[] createVorbisAudioTrackEntry(int channelCount) {
+    byte[] channelCountBytes = getIntegerBytes(channelCount);
+    byte[] tracksElement = createByteArray(
+        0xAE, // TrackEntry
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x99, // size=4249 (42+4207)
+        0x86, // CodecID
+        0x88, 0x41, 0x5f, 0x56, 0x4f, 0x52, 0x42, 0x49, 0x53, // size=8 value=A_VORBIS
+        0xD7, // TrackNumber
+        0x81, 0x02, // size=1 value=2
+        0x83, // TrackType
+        0x81, 0x02, // size=1 value=2
+        0xE1, // Audio
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, // size=13
+        0x9F, // Channels
+        0x81, channelCountBytes[3], // size=1
+        0xB5, // SamplingFrequency
+        0x88, 0x40, 0xE7, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, // size=8 value=48000
+        0x63, 0xA2, // CodecPrivate
+        0x50, 0x6F); // size=4207
+    byte[] codecPrivate = new byte[4207];
+    try {
+      getInstrumentation().getContext().getResources().getAssets().open(TEST_VORBIS_CODEC_PRIVATE)
+          .read(codecPrivate);
+    } catch (IOException e) {
+      fail(); // should never happen
+    }
+    return joinByteArrays(tracksElement, codecPrivate);
+  }
+
+  private static byte[] createUnsupportedTrackEntry() {
+    return createByteArray(
+        0xAE, // TrackEntry
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // size=32
+        0x86, // CodecID
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // size =17
+        0x44, 0x5f, 0x57, 0x45, 0x42, 0x56, 0x54, 0x54,
+        0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, // value=D_WEBVTT/metadata
+        0xD7, // TrackNumber
+        0x81, 0x03, // size=1 value=3
+        0x83, // TrackType
+        0x81, 0x11); // size=1 value=11
+  }
+
+  private static byte[] createCuesElement(int size) {
+    byte[] sizeBytes = getIntegerBytes(size);
+    return createByteArray(
+        0x1C, 0x53, 0xBB, 0x6B, // Cues
+        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
+  }
+
+  private static byte[] createCuePointElement(int cueTime, int cueClusterPosition) {
+    byte[] positionBytes = getIntegerBytes(cueClusterPosition);
+    return createByteArray(
+        0xBB, // CuePoint
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, // size=22
+        0xB3, // CueTime
+        0x81, cueTime, // size=1
+        0xB7, // CueTrackPositions
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, // size=10
+        0xF1, // CueClusterPosition
+        0x88, 0x00, 0x00, 0x00, 0x00, positionBytes[0], positionBytes[1],
+        positionBytes[2], positionBytes[3]); // size=8
+  }
+
+  private static byte[] createClusterElement(int size, int timecode) {
+    byte[] sizeBytes = getIntegerBytes(size);
+    byte[] timeBytes = getIntegerBytes(timecode);
+    return createByteArray(
+        0x1F, 0x43, 0xB6, 0x75, // Cluster
+        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3],
+        0xE7, // Timecode
+        0x84, timeBytes[0], timeBytes[1], timeBytes[2], timeBytes[3]); // size=4
+  }
+
+  private static byte[] createSimpleBlockElement(
+      int size, int timecode, boolean keyframe, boolean invisible, boolean noLacing,
+      boolean encrypted, boolean validSignalByte, int trackNumber) {
+    byte[] sizeBytes = getIntegerBytes(size + 5 + (encrypted ? 9 : 0));
+    byte[] timeBytes = getIntegerBytes(timecode);
+    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
+    byte flags = (byte)
+        ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00) | (noLacing ? 0x00 : 0x06));
+    byte[] simpleBlock = createByteArray(
+        0xA3, // SimpleBlock
+        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3],
+        0x40, trackNumberBytes[3], // Track number size=2
+        timeBytes[2], timeBytes[3], flags); // Timecode and flags
+    if (encrypted) {
+      simpleBlock = joinByteArrays(
+          simpleBlock, createByteArray(validSignalByte ? 0x01 : 0x80),
+          Arrays.copyOfRange(TEST_INITIALIZATION_VECTOR, 0, 8));
+    }
+    return simpleBlock;
+  }
+
+  private static byte[] createBlockElement(
+      int size, int timecode, boolean keyframe, boolean invisible, boolean noLacing,
+      int trackNumber) {
+    int blockSize = size + 5;
+    byte[] blockSizeBytes = getIntegerBytes(blockSize);
+    byte[] timeBytes = getIntegerBytes(timecode);
+    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
+    // Size of blockgroup = id + size + size of reference block + length of data.
+    int blockGroupElementSize = 1 + 8 + (keyframe ? 0 : 3) +  blockSize;
+    byte[] sizeBytes = getIntegerBytes(blockGroupElementSize);
+    byte flags = (byte) ((invisible ? 0x08 : 0x00) | (noLacing ? 0x00 : 0x06));
+    byte[] blockGroupHeader = createByteArray(
+        0xA0, // BlockGroup
+        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
+    byte[] referenceBlock = keyframe ? new byte[0] : createByteArray(
+        0xFB, // ReferenceBlock
+        0x81, 0x00); // size=1 value=0
+    byte[] blockData = createByteArray(
+        0xA1, // Block
+        0x01, 0x00, 0x00, 0x00,
+        blockSizeBytes[0], blockSizeBytes[1], blockSizeBytes[2], blockSizeBytes[3],
+        0x40, trackNumberBytes[3], // Track number size=2
+        timeBytes[2], timeBytes[3], flags); // Timecode and flags
+    return joinByteArrays(blockGroupHeader, referenceBlock, blockData);
+  }
+
+  private static byte[] createFrameData(int size) {
+    byte[] data = new byte[size];
+    for (int i = 0; i < size; i++) {
+      data[i] = (byte) i;
+    }
+    return data;
+  }
+
+  private static byte[] getIntegerBytes(int value) {
+    return createByteArray(
+        (value & 0xFF000000) >> 24,
+        (value & 0x00FF0000) >> 16,
+        (value & 0x0000FF00) >> 8,
+        (value & 0x000000FF));
+  }
+
+  private static byte[] createByteArray(int... intArray) {
+    byte[] byteArray = new byte[intArray.length];
+    for (int i = 0; i < byteArray.length; i++) {
+      byteArray[i] = (byte) intArray[i];
+    }
+    return byteArray;
+  }
+
+  /** Used by {@link #createMediaSegment} to return both cluster and video bytes together. */
+  private static final class MediaSegment {
+
+    private final byte[] clusterBytes;
+    private final byte[] data;
+
+    private MediaSegment(byte[] clusterBytes, byte[] data) {
+      this.clusterBytes = clusterBytes;
+      this.data = data;
+    }
+
+  }
+
+  /** Used by {@link #assertIndex(IndexPoint...)} to validate index elements. */
+  private static final class IndexPoint {
+
+    private final long timeUs;
+    private final int size;
+    private final long durationUs;
+
+    private IndexPoint(long timeUs, int size, long durationUs) {
+      this.timeUs = timeUs;
+      this.size = size;
+      this.durationUs = durationUs;
+    }
+
+  }
+
+  /** Used by {@link #createVideoTrackEntry} to create a Track header with Encryption. */
+  private static final class ContentEncodingSettings {
+
+    private final int order;
+    private final int scope;
+    private final int type;
+    private final int algorithm;
+    private final int aesCipherMode;
+
+    private ContentEncodingSettings(int order, int scope, int type, int algorithm,
+        int aesCipherMode) {
+      this.order = order;
+      this.scope = scope;
+      this.type = type;
+      this.algorithm = algorithm;
+      this.aesCipherMode = aesCipherMode;
+    }
+
+  }
+
+  /** Implements {@link ExtractorOutput} for test purposes. */
+  public class TestExtractorOutput implements ExtractorOutput {
+
+    public boolean tracksEnded;
+    public SeekMap seekMap;
+    public DrmInitData drmInitData;
+    public int numberOfTracks;
+
+    @Override
+    public TrackOutput track(int trackId) {
+      numberOfTracks++;
+      // In the test samples, track number 1 is always video and track number 2 is always audio.
+      return (trackId == 1) ? videoOutput : audioOutput;
+    }
+
+    @Override
+    public void endTracks() {
+      tracksEnded = true;
+    }
+
+    @Override
+    public void seekMap(SeekMap seekMap) {
+      this.seekMap = seekMap;
+    }
+
+    @Override
+    public void drmInitData(DrmInitData drmInitData) {
+      this.drmInitData = drmInitData;
+    }
+
+  }
+
+  /** Implements {@link TrackOutput} for test purposes. */
+  public static class TestTrackOutput implements TrackOutput {
+
+    public MediaFormat format;
+    private long sampleTimeUs;
+    private int sampleFlags;
+    private byte[] sampleData;
+
+    @Override
+    public void format(MediaFormat format) {
+      this.format = format;
+    }
+
+    @Override
+    public int sampleData(ExtractorInput input, int length) throws IOException,
+        InterruptedException {
+      byte[] newData = new byte[length];
+      input.readFully(newData, 0, length);
+      sampleData = sampleData == null ? newData : joinByteArrays(sampleData, newData);
+      return length;
+    }
+
+    @Override
+    public void sampleData(ParsableByteArray data, int length) {
+      byte[] newData = new byte[length];
+      data.readBytes(newData, 0, length);
+      sampleData = sampleData == null ? newData : joinByteArrays(sampleData, newData);
+    }
+
+    @Override
+    public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+      this.sampleTimeUs = timeUs;
+      this.sampleFlags = flags;
+    }
+
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java b/library/src/test/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java
new file mode 100644
index 0000000000..45716b06ab
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+
+import junit.framework.TestCase;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.List;
+
+/**
+ * Test for {@link HlsMasterPlaylistParserTest}
+ */
+public class HlsMasterPlaylistParserTest extends TestCase {
+
+  public void testParseMasterPlaylist() {
+    String playlistUrl = "https://example.com/test.m3u8";
+    String playlistString = "#EXTM3U\n"
+        + "\n"
+        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+        + "http://example.com/low.m3u8\n"
+        + "\n"
+        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+        + "http://example.com/spaces_in_codecs.m3u8\n"
+        + "\n"
+        + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
+        + "http://example.com/mid.m3u8\n"
+        + "\n"
+        + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
+        + "http://example.com/hi.m3u8\n"
+        + "\n"
+        + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
+        + "http://example.com/audio-only.m3u8";
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(
+        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    try {
+      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUrl, inputStream);
+      assertNotNull(playlist);
+      assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
+
+      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+
+      List<Variant> variants = masterPlaylist.variants;
+      assertNotNull(variants);
+      assertEquals(5, variants.size());
+
+      assertEquals(1280000, variants.get(0).format.bitrate);
+      assertNotNull(variants.get(0).format.codecs);
+      assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
+      assertEquals(304, variants.get(0).format.width);
+      assertEquals(128, variants.get(0).format.height);
+      assertEquals("http://example.com/low.m3u8", variants.get(0).url);
+
+      assertEquals(1280000, variants.get(1).format.bitrate);
+      assertNotNull(variants.get(1).format.codecs);
+      assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
+      assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
+
+      assertEquals(2560000, variants.get(2).format.bitrate);
+      assertEquals(null, variants.get(2).format.codecs);
+      assertEquals(384, variants.get(2).format.width);
+      assertEquals(160, variants.get(2).format.height);
+      assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
+
+      assertEquals(7680000, variants.get(3).format.bitrate);
+      assertEquals(null, variants.get(3).format.codecs);
+      assertEquals(-1, variants.get(3).format.width);
+      assertEquals(-1, variants.get(3).format.height);
+      assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
+
+      assertEquals(65000, variants.get(4).format.bitrate);
+      assertNotNull(variants.get(4).format.codecs);
+      assertEquals("mp4a.40.5", variants.get(4).format.codecs);
+      assertEquals(-1, variants.get(4).format.width);
+      assertEquals(-1, variants.get(4).format.height);
+      assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
+    } catch (IOException exception) {
+      fail(exception.getMessage());
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java b/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
new file mode 100644
index 0000000000..beec89e4a6
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+
+import junit.framework.TestCase;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Test for {@link HlsMediaPlaylistParserTest}
+ */
+public class HlsMediaPlaylistParserTest extends TestCase {
+
+  public void testParseMediaPlaylist() {
+    String playlistUrl = "https://example.com/test.m3u8";
+    String playlistString = "#EXTM3U\n"
+        + "#EXT-X-VERSION:3\n"
+        + "#EXT-X-TARGETDURATION:8\n"
+        + "#EXT-X-MEDIA-SEQUENCE:2679\n"
+        + "#EXT-X-ALLOW-CACHE:YES\n"
+        + "\n"
+        + "#EXTINF:7.975,\n"
+        + "#EXT-X-BYTERANGE:51370@0\n"
+        + "https://priv.example.com/fileSequence2679.ts\n"
+        + "\n"
+        + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
+        + "#EXTINF:7.975,\n"
+        + "#EXT-X-BYTERANGE:51501@51370\n"
+        + "https://priv.example.com/fileSequence2680.ts\n"
+        + "\n"
+        + "#EXT-X-KEY:METHOD=NONE\n"
+        + "#EXTINF:7.941,\n"
+        + "#EXT-X-BYTERANGE:51501\n" // @102871
+        + "https://priv.example.com/fileSequence2681.ts\n"
+        + "\n"
+        + "#EXT-X-DISCONTINUITY\n"
+        + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2682\"\n"
+        + "#EXTINF:7.975,\n"
+        + "#EXT-X-BYTERANGE:51740\n" // @154372
+        + "https://priv.example.com/fileSequence2682.ts\n"
+        + "\n"
+        + "#EXTINF:7.975,\n"
+        + "https://priv.example.com/fileSequence2683.ts\n"
+        + "#EXT-X-ENDLIST";
+    InputStream inputStream = new ByteArrayInputStream(
+        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    try {
+      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUrl, inputStream);
+      assertNotNull(playlist);
+      assertEquals(HlsPlaylist.TYPE_MEDIA, playlist.type);
+
+      HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+
+      assertEquals(2679, mediaPlaylist.mediaSequence);
+      assertEquals(8, mediaPlaylist.targetDurationSecs);
+      assertEquals(3, mediaPlaylist.version);
+      assertEquals(false, mediaPlaylist.live);
+      List<HlsMediaPlaylist.Segment> segments = mediaPlaylist.segments;
+      assertNotNull(segments);
+      assertEquals(5, segments.size());
+
+      assertEquals(false, segments.get(0).discontinuity);
+      assertEquals(7.975, segments.get(0).durationSecs);
+      assertEquals(false, segments.get(0).isEncrypted);
+      assertEquals(null, segments.get(0).encryptionKeyUri);
+      assertEquals(null, segments.get(0).encryptionIV);
+      assertEquals(51370, segments.get(0).byterangeLength);
+      assertEquals(0, segments.get(0).byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2679.ts", segments.get(0).url);
+
+      assertEquals(false, segments.get(1).discontinuity);
+      assertEquals(7.975, segments.get(1).durationSecs);
+      assertEquals(true, segments.get(1).isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
+      assertEquals("0x1566B", segments.get(1).encryptionIV);
+      assertEquals(51501, segments.get(1).byterangeLength);
+      assertEquals(51370, segments.get(1).byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
+
+      assertEquals(false, segments.get(2).discontinuity);
+      assertEquals(7.941, segments.get(2).durationSecs);
+      assertEquals(false, segments.get(2).isEncrypted);
+      assertEquals(null, segments.get(2).encryptionKeyUri);
+      assertEquals(null, segments.get(2).encryptionIV);
+      assertEquals(51501, segments.get(2).byterangeLength);
+      assertEquals(102871, segments.get(2).byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
+
+      assertEquals(true, segments.get(3).discontinuity);
+      assertEquals(7.975, segments.get(3).durationSecs);
+      assertEquals(true, segments.get(3).isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(3).encryptionKeyUri);
+      // 0xA7A == 2682.
+      assertNotNull(segments.get(3).encryptionIV);
+      assertEquals("A7A", segments.get(3).encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(51740, segments.get(3).byterangeLength);
+      assertEquals(154372, segments.get(3).byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
+
+      assertEquals(false, segments.get(4).discontinuity);
+      assertEquals(7.975, segments.get(4).durationSecs);
+      assertEquals(true, segments.get(4).isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(4).encryptionKeyUri);
+      // 0xA7B == 2683.
+      assertNotNull(segments.get(4).encryptionIV);
+      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(C.LENGTH_UNBOUNDED, segments.get(4).byterangeLength);
+      assertEquals(0, segments.get(4).byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2683.ts", segments.get(4).url);
+    } catch (IOException exception) {
+      fail(exception.getMessage());
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/metadata/Id3ParserTest.java b/library/src/test/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
new file mode 100644
index 0000000000..1dead0a139
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata;
+
+import junit.framework.TestCase;
+
+import java.util.Map;
+
+/**
+ * Test for {@link Id3Parser}
+ */
+public class Id3ParserTest extends TestCase {
+
+  public void testParseTxxxFrames() {
+    byte[] rawId3 = new byte[] { 73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31,
+        0, 0, 3, 0, 109, 100, 105, 97, 108, 111, 103, 95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50,
+        55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0 };
+
+    Id3Parser parser = new Id3Parser();
+    try {
+      Map<String, Object> metadata = parser.parse(rawId3, rawId3.length);
+      assertNotNull(metadata);
+      assertEquals(1, metadata.size());
+      TxxxMetadata txxx = (TxxxMetadata) metadata.get(TxxxMetadata.TYPE);
+      assertNotNull(txxx);
+      assertEquals("", txxx.description);
+      assertEquals("mdialog_VINDICO1527664_start", txxx.value);
+    } catch (Exception exception) {
+      fail(exception.getMessage());
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java b/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
new file mode 100644
index 0000000000..1312ab2255
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * A fake {@link DataSource} capable of simulating various scenarios.
+ * <p>
+ * The data that will be read from the source can be constructed by calling
+ * {@link Builder#appendReadData(byte[])}. Calls to {@link #read(byte[], int, int)} will not span
+ * the boundaries between arrays passed to successive calls, and hence the boundaries control the
+ * positions at which read requests to the source may only be partially satisfied.
+ * <p>
+ * Errors can be inserted by calling {@link Builder#appendReadError(IOException)}. An inserted error
+ * will be thrown from the first call to {@link #read(byte[], int, int)} that attempts to read from
+ * the corresponding position, and from all subsequent calls to {@link #read(byte[], int, int)}
+ * until the source is closed. If the source is closed and re-opened having encountered an error,
+ * that error will not be thrown again.
+ */
+public final class FakeDataSource implements DataSource {
+
+  private final ArrayList<Segment> segments;
+
+  private final boolean simulateUnknownLength;
+  private final long totalLength;
+
+  private boolean opened;
+  private int currentSegmentIndex;
+  private long bytesRemaining;
+
+  public FakeDataSource(boolean simulateUnknownLength, ArrayList<Segment> segments) {
+    this.simulateUnknownLength = simulateUnknownLength;
+    this.segments = segments;
+    long totalLength = 0;
+    for (Segment segment : segments) {
+      totalLength += segment.length;
+    }
+    this.totalLength = totalLength;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    Assertions.checkState(!opened);
+    // DataSpec requires a matching close call even if open fails.
+    opened = true;
+    // If the source knows that the request is unsatisfiable then fail.
+    if (dataSpec.position >= totalLength) {
+      throw new IOException("Unsatisfiable position");
+    } else if (dataSpec.length != C.LENGTH_UNBOUNDED
+        && dataSpec.position + dataSpec.length >= totalLength) {
+      throw new IOException("Unsatisfiable range");
+    }
+    // Scan through the segments, configuring them for the current read.
+    boolean findingCurrentSegmentIndex = true;
+    currentSegmentIndex = 0;
+    int scannedLength = 0;
+    for (Segment segment : segments) {
+      segment.bytesRead =
+          (int) Math.min(Math.max(0, dataSpec.position - scannedLength), segment.length);
+      scannedLength += segment.length;
+      findingCurrentSegmentIndex &= segment.isErrorSegment() ? segment.exceptionCleared
+          : segment.bytesRead == segment.length;
+      if (findingCurrentSegmentIndex) {
+        currentSegmentIndex++;
+      }
+    }
+    // Configure bytesRemaining, and return.
+    if (dataSpec.length == C.LENGTH_UNBOUNDED) {
+      bytesRemaining = totalLength - dataSpec.position;
+      return simulateUnknownLength ? C.LENGTH_UNBOUNDED : bytesRemaining;
+    } else {
+      bytesRemaining = dataSpec.length;
+      return bytesRemaining;
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    Assertions.checkState(opened);
+    opened = false;
+    if (currentSegmentIndex < segments.size()) {
+      Segment current = segments.get(currentSegmentIndex);
+      if (current.isErrorSegment() && current.exceptionThrown) {
+        current.exceptionCleared = true;
+      }
+    }
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    Assertions.checkState(opened);
+    while (true) {
+      if (currentSegmentIndex == segments.size() || bytesRemaining == 0) {
+        return -1;
+      }
+      Segment current = segments.get(currentSegmentIndex);
+      if (current.exception != null) {
+        if (!current.exceptionCleared) {
+          current.exceptionThrown = true;
+          throw current.exception;
+        } else {
+          currentSegmentIndex++;
+        }
+      } else {
+        // Read at most bytesRemaining.
+        readLength = (int) Math.min(readLength, bytesRemaining);
+        // Do not allow crossing of the segment boundary.
+        readLength = Math.min(readLength, current.length - current.bytesRead);
+        // Perform the read and return.
+        System.arraycopy(current.data, current.bytesRead, buffer, offset, readLength);
+        bytesRemaining -= readLength;
+        current.bytesRead += readLength;
+        if (current.bytesRead == current.length) {
+          currentSegmentIndex++;
+        }
+        return readLength;
+      }
+    }
+  }
+
+  private static class Segment {
+
+    public final IOException exception;
+    public final byte[] data;
+    public final int length;
+
+    private boolean exceptionThrown;
+    private boolean exceptionCleared;
+    private int bytesRead;
+
+    public Segment(byte[] data, IOException exception) {
+      this.data = data;
+      this.exception = exception;
+      length = data != null ? data.length : 0;
+    }
+
+    public boolean isErrorSegment() {
+      return exception != null;
+    }
+
+  }
+
+  /**
+   * Builder of {@link FakeDataSource} instances.
+   */
+  public static class Builder {
+
+    private final ArrayList<Segment> segments;
+    private boolean simulateUnknownLength;
+
+    public Builder() {
+      segments = new ArrayList<Segment>();
+    }
+
+    /**
+     * When set, {@link FakeDataSource#open(DataSpec)} will behave as though the source is unable to
+     * determine the length of the underlying data. Hence the return value will always be equal to
+     * the {@link DataSpec#length} of the argument, including the case where the length is equal to
+     * {@link C#LENGTH_UNBOUNDED}.
+     */
+    public Builder setSimulateUnknownLength(boolean simulateUnknownLength) {
+      this.simulateUnknownLength = simulateUnknownLength;
+      return this;
+    }
+
+    /**
+     * Appends to the underlying data.
+     */
+    public Builder appendReadData(byte[] data) {
+      Assertions.checkState(data != null && data.length > 0);
+      segments.add(new Segment(data, null));
+      return this;
+    }
+
+    /**
+     * Appends an error in the underlying data.
+     */
+    public Builder appendReadError(IOException exception) {
+      segments.add(new Segment(null, exception));
+      return this;
+    }
+
+    public FakeDataSource build() {
+      return new FakeDataSource(simulateUnknownLength, segments);
+    }
+
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/Util.java b/library/src/test/java/com/google/android/exoplayer/testutil/Util.java
new file mode 100644
index 0000000000..4d2897e7a4
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/Util.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import android.test.InstrumentationTestCase;
+
+import org.mockito.MockitoAnnotations;
+
+import java.util.Random;
+
+/**
+ * Utility methods for tests.
+ */
+public class Util {
+
+  private Util() {}
+
+  public static byte[] buildTestData(int length) {
+    return buildTestData(length, length);
+  }
+
+  public static byte[] buildTestData(int length, int seed) {
+    Random random = new Random(seed);
+    byte[] source = new byte[length];
+    random.nextBytes(source);
+    return source;
+  }
+
+  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
+    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
+    System.setProperty("dexmaker.dexcache",
+        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
+    MockitoAnnotations.initMocks(instrumentationTestCase);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
new file mode 100644
index 0000000000..426c5152df
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.C;
+
+import android.test.InstrumentationTestCase;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Unit test for {@link WebvttParser}.
+ */
+public class WebvttParserTest extends InstrumentationTestCase {
+
+  private static final String TYPICAL_WEBVTT_FILE = "webvtt/typical";
+  private static final String TYPICAL_WITH_IDS_WEBVTT_FILE = "webvtt/typical_with_identifiers";
+  private static final String TYPICAL_WITH_TAGS_WEBVTT_FILE = "webvtt/typical_with_tags";
+  private static final String EMPTY_WEBVTT_FILE = "webvtt/empty";
+
+  public void testParseNullWebvttFile() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(EMPTY_WEBVTT_FILE);
+
+    try {
+      parser.parse(inputStream, C.UTF8_NAME, 0);
+      fail("Expected IOException");
+    } catch (IOException expected) {
+      // Do nothing.
+    }
+  }
+
+  public void testParseTypicalWebvttFile() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(TYPICAL_WEBVTT_FILE);
+    WebvttSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+
+    // test start time and event count
+    long startTimeUs = 5000000;
+    assertEquals(startTimeUs, subtitle.getStartTime());
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // test first cue
+    assertEquals(startTimeUs, subtitle.getEventTime(0));
+    assertEquals("This is the first subtitle.",
+        subtitle.getText(subtitle.getEventTime(0)));
+    assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
+
+    // test second cue
+    assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
+    assertEquals("This is the second subtitle.",
+        subtitle.getText(subtitle.getEventTime(2)));
+    assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
+  }
+
+  public void testParseTypicalWithIdsWebvttFile() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets()
+          .open(TYPICAL_WITH_IDS_WEBVTT_FILE);
+    WebvttSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+
+    // test start time and event count
+    long startTimeUs = 5000000;
+    assertEquals(startTimeUs, subtitle.getStartTime());
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // test first cue
+    assertEquals(startTimeUs, subtitle.getEventTime(0));
+    assertEquals("This is the first subtitle.",
+        subtitle.getText(subtitle.getEventTime(0)));
+    assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
+
+    // test second cue
+    assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
+    assertEquals("This is the second subtitle.",
+        subtitle.getText(subtitle.getEventTime(2)));
+    assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
+  }
+
+  public void testParseTypicalWithTagsWebvttFile() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets()
+          .open(TYPICAL_WITH_TAGS_WEBVTT_FILE);
+    WebvttSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+
+    // test start time and event count
+    long startTimeUs = 5000000;
+    assertEquals(startTimeUs, subtitle.getStartTime());
+    assertEquals(8, subtitle.getEventTimeCount());
+
+    // test first cue
+    assertEquals(startTimeUs, subtitle.getEventTime(0));
+    assertEquals("This is the first subtitle.",
+        subtitle.getText(subtitle.getEventTime(0)));
+    assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
+
+    // test second cue
+    assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
+    assertEquals("This is the second subtitle.",
+        subtitle.getText(subtitle.getEventTime(2)));
+    assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
+
+    // test third cue
+    assertEquals(startTimeUs + 4000000, subtitle.getEventTime(4));
+    assertEquals("This is the third subtitle.",
+        subtitle.getText(subtitle.getEventTime(4)));
+    assertEquals(startTimeUs + 5000000, subtitle.getEventTime(5));
+
+    // test fourth cue
+    assertEquals(startTimeUs + 6000000, subtitle.getEventTime(6));
+    assertEquals("This is the <fourth> &subtitle.",
+        subtitle.getText(subtitle.getEventTime(6)));
+    assertEquals(startTimeUs + 7000000, subtitle.getEventTime(7));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
new file mode 100644
index 0000000000..e95482f0fb
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link WebvttSubtitle}.
+ */
+public class WebvttSubtitleTest extends TestCase {
+
+  private static final String FIRST_SUBTITLE_STRING = "This is the first subtitle.";
+  private static final String SECOND_SUBTITLE_STRING = "This is the second subtitle.";
+  private static final String FIRST_AND_SECOND_SUBTITLE_STRING =
+      FIRST_SUBTITLE_STRING + SECOND_SUBTITLE_STRING;
+
+  private WebvttSubtitle emptySubtitle = new WebvttSubtitle(new String[] {}, 0, new long[] {});
+
+  private WebvttSubtitle simpleSubtitle = new WebvttSubtitle(
+      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
+      new long[] {1000000, 2000000, 3000000, 4000000});
+
+  private WebvttSubtitle overlappingSubtitle = new WebvttSubtitle(
+      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
+      new long[] {1000000, 3000000, 2000000, 4000000});
+
+  private WebvttSubtitle nestedSubtitle = new WebvttSubtitle(
+      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
+      new long[] {1000000, 4000000, 2000000, 3000000});
+
+  public void testEventCount() {
+    assertEquals(0, emptySubtitle.getEventTimeCount());
+    assertEquals(4, simpleSubtitle.getEventTimeCount());
+    assertEquals(4, overlappingSubtitle.getEventTimeCount());
+    assertEquals(4, nestedSubtitle.getEventTimeCount());
+  }
+
+  public void testStartTime() {
+    assertEquals(0, emptySubtitle.getStartTime());
+    assertEquals(0, simpleSubtitle.getStartTime());
+    assertEquals(0, overlappingSubtitle.getStartTime());
+    assertEquals(0, nestedSubtitle.getStartTime());
+  }
+
+  public void testLastEventTime() {
+    assertEquals(-1, emptySubtitle.getLastEventTime());
+    assertEquals(4000000, simpleSubtitle.getLastEventTime());
+    assertEquals(4000000, overlappingSubtitle.getLastEventTime());
+    assertEquals(4000000, nestedSubtitle.getLastEventTime());
+  }
+
+  public void testSimpleSubtitleEventTimes() {
+    testSubtitleEventTimesHelper(simpleSubtitle);
+  }
+
+  public void testSimpleSubtitleEventIndices() {
+    testSubtitleEventIndicesHelper(simpleSubtitle);
+  }
+
+  public void testSimpleSubtitleText() {
+    // Test before first subtitle
+    assertNull(simpleSubtitle.getText(0));
+    assertNull(simpleSubtitle.getText(500000));
+    assertNull(simpleSubtitle.getText(999999));
+
+    // Test first subtitle
+    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1000000));
+    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1500000));
+    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1999999));
+
+    // Test after first subtitle, before second subtitle
+    assertNull(simpleSubtitle.getText(2000000));
+    assertNull(simpleSubtitle.getText(2500000));
+    assertNull(simpleSubtitle.getText(2999999));
+
+    // Test second subtitle
+    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3000000));
+    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3500000));
+    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3999999));
+
+    // Test after second subtitle
+    assertNull(simpleSubtitle.getText(4000000));
+    assertNull(simpleSubtitle.getText(4500000));
+    assertNull(simpleSubtitle.getText(Long.MAX_VALUE));
+  }
+
+  public void testOverlappingSubtitleEventTimes() {
+    testSubtitleEventTimesHelper(overlappingSubtitle);
+  }
+
+  public void testOverlappingSubtitleEventIndices() {
+    testSubtitleEventIndicesHelper(overlappingSubtitle);
+  }
+
+  public void testOverlappingSubtitleText() {
+    // Test before first subtitle
+    assertNull(overlappingSubtitle.getText(0));
+    assertNull(overlappingSubtitle.getText(500000));
+    assertNull(overlappingSubtitle.getText(999999));
+
+    // Test first subtitle
+    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1000000));
+    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1500000));
+    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1999999));
+
+    // Test after first and second subtitle
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2000000));
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2500000));
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2999999));
+
+    // Test second subtitle
+    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3000000));
+    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3500000));
+    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3999999));
+
+    // Test after second subtitle
+    assertNull(overlappingSubtitle.getText(4000000));
+    assertNull(overlappingSubtitle.getText(4500000));
+    assertNull(overlappingSubtitle.getText(Long.MAX_VALUE));
+  }
+
+  public void testNestedSubtitleEventTimes() {
+    testSubtitleEventTimesHelper(nestedSubtitle);
+  }
+
+  public void testNestedSubtitleEventIndices() {
+    testSubtitleEventIndicesHelper(nestedSubtitle);
+  }
+
+  public void testNestedSubtitleText() {
+    // Test before first subtitle
+    assertNull(nestedSubtitle.getText(0));
+    assertNull(nestedSubtitle.getText(500000));
+    assertNull(nestedSubtitle.getText(999999));
+
+    // Test first subtitle
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1000000));
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1500000));
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1999999));
+
+    // Test after first and second subtitle
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2000000));
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2500000));
+    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2999999));
+
+    // Test first subtitle
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3000000));
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3500000));
+    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3999999));
+
+    // Test after second subtitle
+    assertNull(nestedSubtitle.getText(4000000));
+    assertNull(nestedSubtitle.getText(4500000));
+    assertNull(nestedSubtitle.getText(Long.MAX_VALUE));
+  }
+
+  private void testSubtitleEventTimesHelper(WebvttSubtitle subtitle) {
+    assertEquals(1000000, subtitle.getEventTime(0));
+    assertEquals(2000000, subtitle.getEventTime(1));
+    assertEquals(3000000, subtitle.getEventTime(2));
+    assertEquals(4000000, subtitle.getEventTime(3));
+  }
+
+  private void testSubtitleEventIndicesHelper(WebvttSubtitle subtitle) {
+    // Test first event
+    assertEquals(0, subtitle.getNextEventTimeIndex(0));
+    assertEquals(0, subtitle.getNextEventTimeIndex(500000));
+    assertEquals(0, subtitle.getNextEventTimeIndex(999999));
+
+    // Test second event
+    assertEquals(1, subtitle.getNextEventTimeIndex(1000000));
+    assertEquals(1, subtitle.getNextEventTimeIndex(1500000));
+    assertEquals(1, subtitle.getNextEventTimeIndex(1999999));
+
+    // Test third event
+    assertEquals(2, subtitle.getNextEventTimeIndex(2000000));
+    assertEquals(2, subtitle.getNextEventTimeIndex(2500000));
+    assertEquals(2, subtitle.getNextEventTimeIndex(2999999));
+
+    // Test fourth event
+    assertEquals(3, subtitle.getNextEventTimeIndex(3000000));
+    assertEquals(3, subtitle.getNextEventTimeIndex(3500000));
+    assertEquals(3, subtitle.getNextEventTimeIndex(3999999));
+
+    // Test null event (i.e. look for events after the last event)
+    assertEquals(-1, subtitle.getNextEventTimeIndex(4000000));
+    assertEquals(-1, subtitle.getNextEventTimeIndex(4500000));
+    assertEquals(-1, subtitle.getNextEventTimeIndex(Long.MAX_VALUE));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java b/library/src/test/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java
new file mode 100644
index 0000000000..550cb149a8
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.C;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+
+/**
+ * Unit tests for {@link ByteArrayDataSource}.
+ */
+public class ByteArrayDataSourceTest extends TestCase {
+
+  private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+  private static final byte[] TEST_DATA_ODD = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  public void testFullReadSingleBytes() {
+    readTestData(TEST_DATA, 0, C.LENGTH_UNBOUNDED, 1, 0, 1, false);
+  }
+
+  public void testFullReadAllBytes() {
+    readTestData(TEST_DATA, 0, C.LENGTH_UNBOUNDED, 100, 0, 100, false);
+  }
+
+  public void testLimitReadSingleBytes() {
+    // Limit set to the length of the data.
+    readTestData(TEST_DATA, 0, TEST_DATA.length, 1, 0, 1, false);
+    // And less.
+    readTestData(TEST_DATA, 0, 6, 1, 0, 1, false);
+  }
+
+  public void testFullReadTwoBytes() {
+    // Try with the total data length an exact multiple of the size of each individual read.
+    readTestData(TEST_DATA, 0, C.LENGTH_UNBOUNDED, 2, 0, 2, false);
+    // And not.
+    readTestData(TEST_DATA_ODD, 0, C.LENGTH_UNBOUNDED, 2, 0, 2, false);
+  }
+
+  public void testLimitReadTwoBytes() {
+    // Try with the limit an exact multiple of the size of each individual read.
+    readTestData(TEST_DATA, 0, 6, 2, 0, 2, false);
+    // And not.
+    readTestData(TEST_DATA, 0, 7, 2, 0, 2, false);
+  }
+
+  public void testReadFromValidOffsets() {
+    // Read from an offset without bound.
+    readTestData(TEST_DATA, 1, C.LENGTH_UNBOUNDED, 1, 0, 1, false);
+    // And with bound.
+    readTestData(TEST_DATA, 1, 6, 1, 0, 1, false);
+    // Read from the last possible offset without bound.
+    readTestData(TEST_DATA, TEST_DATA.length - 1, C.LENGTH_UNBOUNDED, 1, 0, 1, false);
+    // And with bound.
+    readTestData(TEST_DATA, TEST_DATA.length - 1, 1, 1, 0, 1, false);
+  }
+
+  public void testReadFromInvalidOffsets() {
+    // Read from first invalid offset and check failure without bound.
+    readTestData(TEST_DATA, TEST_DATA.length, C.LENGTH_UNBOUNDED, 1, 0, 1, true);
+    // And with bound.
+    readTestData(TEST_DATA, TEST_DATA.length, 1, 1, 0, 1, true);
+  }
+
+  public void testReadWithInvalidLength() {
+    // Read more data than is available.
+    readTestData(TEST_DATA, 0, TEST_DATA.length + 1, 1, 0, 1, true);
+    // And with bound.
+    readTestData(TEST_DATA, 1, TEST_DATA.length, 1, 0, 1, true);
+  }
+
+  /**
+   * Tests reading from a {@link ByteArrayDataSource} with various parameters.
+   *
+   * @param testData The data that the {@link ByteArrayDataSource} will wrap.
+   * @param dataOffset The offset from which to read data.
+   * @param dataLength The total length of data to read.
+   * @param outputBufferLength The length of the target buffer for each read.
+   * @param writeOffset The offset into {@code outputBufferLength} for each read.
+   * @param maxReadLength The maximum length of each read.
+   * @param expectFailOnOpen Whether it is expected that opening the source will fail.
+   */
+  private void readTestData(byte[] testData, int dataOffset, int dataLength, int outputBufferLength,
+      int writeOffset, int maxReadLength, boolean expectFailOnOpen) {
+    int expectedFinalBytesRead =
+        dataLength == C.LENGTH_UNBOUNDED ? (testData.length - dataOffset) : dataLength;
+    ByteArrayDataSource dataSource = new ByteArrayDataSource(testData);
+    boolean opened = false;
+    try {
+      // Open the source.
+      long length = dataSource.open(new DataSpec(null, dataOffset, dataLength, null));
+      opened = true;
+      assertFalse(expectFailOnOpen);
+
+      // Verify the resolved length is as we expect.
+      assertEquals(expectedFinalBytesRead, length);
+
+      byte[] outputBuffer = new byte[outputBufferLength];
+      int accumulatedBytesRead = 0;
+      while (true) {
+        // Calculate a valid length for the next read, constraining by the specified output buffer
+        // length, write offset and maximum write length input parameters.
+        int requestedReadLength = Math.min(maxReadLength, outputBufferLength - writeOffset);
+        assertTrue(requestedReadLength > 0);
+
+        int bytesRead = dataSource.read(outputBuffer, writeOffset, requestedReadLength);
+        if (bytesRead != -1) {
+          assertTrue(bytesRead > 0);
+          assertTrue(bytesRead <= requestedReadLength);
+          // Check the data read was correct.
+          for (int i = 0; i < bytesRead; i++) {
+            assertEquals(testData[dataOffset + accumulatedBytesRead + i],
+                outputBuffer[writeOffset + i]);
+          }
+          // Check that we haven't read more data than we were expecting.
+          accumulatedBytesRead += bytesRead;
+          assertTrue(accumulatedBytesRead <= expectedFinalBytesRead);
+          // If we haven't read all of the bytes the request should have been satisfied in full.
+          assertTrue(accumulatedBytesRead == expectedFinalBytesRead
+              || bytesRead == requestedReadLength);
+        } else {
+          // We're done. Check we read the expected number of bytes.
+          assertEquals(expectedFinalBytesRead, accumulatedBytesRead);
+          return;
+        }
+      }
+    } catch (IOException e) {
+      if (expectFailOnOpen && !opened) {
+        // Expected.
+        return;
+      }
+      // Unexpected failure.
+      fail();
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/util/FakeClock.java b/library/src/test/java/com/google/android/exoplayer/util/FakeClock.java
new file mode 100644
index 0000000000..8881a3b3a6
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/util/FakeClock.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+/**
+ * A {@link Clock} that returns a fixed value specified in the constructor.
+ */
+public class FakeClock implements Clock {
+
+  private final long timeMs;
+
+  public FakeClock(long timeMs) {
+    this.timeMs = timeMs;
+  }
+
+  @Override
+  public long elapsedRealtime() {
+    return timeMs;
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java b/library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java
new file mode 100644
index 0000000000..78bfa0c3fb
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import junit.framework.TestCase;
+
+import java.util.Arrays;
+
+/**
+ * Tests for {@link H264Util}.
+ */
+public class H264UtilTest extends TestCase {
+
+  private static final int TEST_PARTIAL_NAL_POSITION = 4;
+  private static final int TEST_NAL_POSITION = 10;
+
+  public void testFindNalUnit() {
+    byte[] data = buildTestData();
+
+    // Should find NAL unit.
+    int result = H264Util.findNalUnit(data, 0, data.length, null);
+    assertEquals(TEST_NAL_POSITION, result);
+    // Should find NAL unit whose prefix ends one byte before the limit.
+    result = H264Util.findNalUnit(data, 0, TEST_NAL_POSITION + 4, null);
+    assertEquals(TEST_NAL_POSITION, result);
+    // Shouldn't find NAL unit whose prefix ends at the limit (since the limit is exclusive).
+    result = H264Util.findNalUnit(data, 0, TEST_NAL_POSITION + 3, null);
+    assertEquals(TEST_NAL_POSITION + 3, result);
+    // Should find NAL unit whose prefix starts at the offset.
+    result = H264Util.findNalUnit(data, TEST_NAL_POSITION, data.length, null);
+    assertEquals(TEST_NAL_POSITION, result);
+    // Shouldn't find NAL unit whose prefix starts one byte past the offset.
+    result = H264Util.findNalUnit(data, TEST_NAL_POSITION + 1, data.length, null);
+    assertEquals(data.length, result);
+  }
+
+  public void testFindNalUnitWithPrefix() {
+    byte[] data = buildTestData();
+
+    // First byte of NAL unit in data1, rest in data2.
+    boolean[] prefixFlags = new boolean[3];
+    byte[] data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
+    byte[] data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, data.length);
+    int result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    assertEquals(data1.length, result);
+    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    assertEquals(-1, result);
+    assertPrefixFlagsCleared(prefixFlags);
+
+    // First three bytes of NAL unit in data1, rest in data2.
+    prefixFlags = new boolean[3];
+    data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 3);
+    data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 3, data.length);
+    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    assertEquals(data1.length, result);
+    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    assertEquals(-3, result);
+    assertPrefixFlagsCleared(prefixFlags);
+
+    // First byte of NAL unit in data1, second byte in data2, rest in data3.
+    prefixFlags = new boolean[3];
+    data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
+    data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, TEST_NAL_POSITION + 2);
+    byte[] data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
+    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    assertEquals(data1.length, result);
+    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    assertEquals(data2.length, result);
+    result = H264Util.findNalUnit(data3, 0, data3.length, prefixFlags);
+    assertEquals(-2, result);
+    assertPrefixFlagsCleared(prefixFlags);
+
+    // NAL unit split with one byte in four arrays.
+    prefixFlags = new boolean[3];
+    data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
+    data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, TEST_NAL_POSITION + 2);
+    data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, TEST_NAL_POSITION + 3);
+    byte[] data4 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
+    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    assertEquals(data1.length, result);
+    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    assertEquals(data2.length, result);
+    result = H264Util.findNalUnit(data3, 0, data3.length, prefixFlags);
+    assertEquals(data3.length, result);
+    result = H264Util.findNalUnit(data4, 0, data4.length, prefixFlags);
+    assertEquals(-3, result);
+    assertPrefixFlagsCleared(prefixFlags);
+
+    // NAL unit entirely in data2. data1 ends with partial prefix.
+    prefixFlags = new boolean[3];
+    data1 = Arrays.copyOfRange(data, 0, TEST_PARTIAL_NAL_POSITION + 2);
+    data2 = Arrays.copyOfRange(data, TEST_PARTIAL_NAL_POSITION + 2, data.length);
+    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    assertEquals(data1.length, result);
+    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    assertEquals(4, result);
+    assertPrefixFlagsCleared(prefixFlags);
+  }
+
+  private static byte[] buildTestData() {
+    byte[] data = new byte[20];
+    for (int i = 0; i < data.length; i++) {
+      data[i] = (byte) 0xFF;
+    }
+    // Insert an incomplete NAL unit start code.
+    data[TEST_PARTIAL_NAL_POSITION] = 0;
+    data[TEST_PARTIAL_NAL_POSITION + 1] = 0;
+    // Insert a complete NAL unit start code.
+    data[TEST_NAL_POSITION] = 0;
+    data[TEST_NAL_POSITION + 1] = 0;
+    data[TEST_NAL_POSITION + 2] = 1;
+    data[TEST_NAL_POSITION + 3] = 5;
+    return data;
+  }
+
+  private static void assertPrefixFlagsCleared(boolean[] flags) {
+    assertEquals(false, flags[0] || flags[1] || flags[2]);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java b/library/src/test/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
new file mode 100644
index 0000000000..ac3590cd24
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import junit.framework.TestCase;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Tests for {@link ParsableByteArray}.
+ */
+public class ParsableByteArrayTest extends TestCase {
+
+  private static final byte[] TEST_DATA =
+      new byte[] {0x0F, (byte) 0xFF, (byte) 0x42, (byte) 0x0F, 0x00, 0x00, 0x00, 0x00};
+
+  private static ParsableByteArray getTestDataArray() {
+    ParsableByteArray testArray = new ParsableByteArray(TEST_DATA.length);
+    System.arraycopy(TEST_DATA, 0, testArray.data, 0, TEST_DATA.length);
+    return testArray;
+  }
+
+  public void testReadInt() {
+    testReadInt(0);
+    testReadInt(1);
+    testReadInt(-1);
+    testReadInt(Integer.MIN_VALUE);
+    testReadInt(Integer.MAX_VALUE);
+  }
+
+  private static void testReadInt(int testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        ByteBuffer.allocate(4).putInt(testValue).array());
+    int readValue = testArray.readInt();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(4, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-4);
+    readValue = testArray.readInt();
+    assertEquals(testValue, readValue);
+    assertEquals(4, testArray.getPosition());
+  }
+
+  public void testReadUnsignedInt() {
+    testReadUnsignedInt(0);
+    testReadUnsignedInt(1);
+    testReadUnsignedInt(Integer.MAX_VALUE);
+    testReadUnsignedInt(Integer.MAX_VALUE + 1L);
+    testReadUnsignedInt(0xFFFFFFFFL);
+  }
+
+  private static void testReadUnsignedInt(long testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        Arrays.copyOfRange(ByteBuffer.allocate(8).putLong(testValue).array(), 4, 8));
+    long readValue = testArray.readUnsignedInt();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(4, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-4);
+    readValue = testArray.readUnsignedInt();
+    assertEquals(testValue, readValue);
+    assertEquals(4, testArray.getPosition());
+  }
+
+  public void testReadUnsignedIntToInt() {
+    testReadUnsignedIntToInt(0);
+    testReadUnsignedIntToInt(1);
+    testReadUnsignedIntToInt(Integer.MAX_VALUE);
+    try {
+      testReadUnsignedIntToInt(-1);
+      fail();
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
+    try {
+      testReadUnsignedIntToInt(Integer.MIN_VALUE);
+      fail();
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
+  }
+
+  private static void testReadUnsignedIntToInt(int testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        ByteBuffer.allocate(4).putInt(testValue).array());
+    int readValue = testArray.readUnsignedIntToInt();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(4, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-4);
+    readValue = testArray.readUnsignedIntToInt();
+    assertEquals(testValue, readValue);
+    assertEquals(4, testArray.getPosition());
+  }
+
+  public void testReadUnsignedLongToLong() {
+    testReadUnsignedLongToLong(0);
+    testReadUnsignedLongToLong(1);
+    testReadUnsignedLongToLong(Long.MAX_VALUE);
+    try {
+      testReadUnsignedLongToLong(-1);
+      fail();
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
+    try {
+      testReadUnsignedLongToLong(Long.MIN_VALUE);
+      fail();
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
+  }
+
+  private static void testReadUnsignedLongToLong(long testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        ByteBuffer.allocate(8).putLong(testValue).array());
+    long readValue = testArray.readUnsignedLongToLong();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(8, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-8);
+    readValue = testArray.readUnsignedLongToLong();
+    assertEquals(testValue, readValue);
+    assertEquals(8, testArray.getPosition());
+  }
+
+  public void testReadLong() {
+    testReadLong(0);
+    testReadLong(1);
+    testReadLong(-1);
+    testReadLong(Long.MIN_VALUE);
+    testReadLong(Long.MAX_VALUE);
+  }
+
+  private static void testReadLong(long testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        ByteBuffer.allocate(8).putLong(testValue).array());
+    long readValue = testArray.readLong();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(8, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-8);
+    readValue = testArray.readLong();
+    assertEquals(testValue, readValue);
+    assertEquals(8, testArray.getPosition());
+  }
+
+  public void testReadingMovesPosition() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // Given an array at the start
+    assertEquals(0, parsableByteArray.getPosition());
+    // When reading an integer, the position advances
+    parsableByteArray.readUnsignedInt();
+    assertEquals(4, parsableByteArray.getPosition());
+  }
+
+  public void testOutOfBoundsThrows() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // Given an array at the end
+    parsableByteArray.readUnsignedLongToLong();
+    assertEquals(TEST_DATA.length, parsableByteArray.getPosition());
+    // Then reading more data throws.
+    try {
+      parsableByteArray.readUnsignedInt();
+      fail();
+    } catch (Exception e) {
+      // Expected.
+    }
+  }
+
+  public void testModificationsAffectParsableArray() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // When modifying the wrapped byte array
+    byte[] data = parsableByteArray.data;
+    long readValue = parsableByteArray.readUnsignedInt();
+    data[0] = (byte) (TEST_DATA[0] + 1);
+    parsableByteArray.setPosition(0);
+    // Then the parsed value changes.
+    assertFalse(parsableByteArray.readUnsignedInt() == readValue);
+  }
+
+  public void testReadingUnsignedLongWithMsbSetThrows() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // Given an array with the most-significant bit set on the top byte
+    byte[] data = parsableByteArray.data;
+    data[0] = (byte) 0x80;
+    // Then reading an unsigned long throws.
+    try {
+      parsableByteArray.readUnsignedLongToLong();
+      fail();
+    } catch (Exception e) {
+      // Expected.
+    }
+  }
+
+  public void testReadUnsignedFixedPoint1616() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // When reading the integer part of a 16.16 fixed point value
+    int value = parsableByteArray.readUnsignedFixedPoint1616();
+    // Then the read value is equal to the array elements interpreted as a short.
+    assertEquals((0xFF & TEST_DATA[0]) << 8 | (TEST_DATA[1] & 0xFF), value);
+    assertEquals(4, parsableByteArray.getPosition());
+  }
+
+  public void testReadingBytesReturnsCopy() {
+    ParsableByteArray parsableByteArray = getTestDataArray();
+
+    // When reading all the bytes back
+    int length = parsableByteArray.limit();
+    assertEquals(TEST_DATA.length, length);
+    byte[] copy = new byte[length];
+    parsableByteArray.readBytes(copy, 0, length);
+    // Then the array elements are the same.
+    assertTrue(Arrays.equals(parsableByteArray.data, copy));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/util/UriUtilTest.java b/library/src/test/java/com/google/android/exoplayer/util/UriUtilTest.java
new file mode 100644
index 0000000000..f482d99c47
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/util/UriUtilTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link UriUtil}.
+ */
+public class UriUtilTest extends TestCase {
+
+  /**
+   * Tests normal usage of {@link UriUtil#resolve(String, String)}.
+   * <p>
+   * The test cases are taken from RFC-3986 5.4.1.
+   */
+  public void testResolveNormal() {
+    String base = "http://a/b/c/d;p?q";
+
+    assertEquals("g:h", UriUtil.resolve(base, "g:h"));
+    assertEquals("http://a/b/c/g", UriUtil.resolve(base, "g"));
+    assertEquals("http://a/b/c/g/", UriUtil.resolve(base, "g/"));
+    assertEquals("http://a/g", UriUtil.resolve(base, "/g"));
+    assertEquals("http://g", UriUtil.resolve(base, "//g"));
+    assertEquals("http://a/b/c/d;p?y", UriUtil.resolve(base, "?y"));
+    assertEquals("http://a/b/c/g?y", UriUtil.resolve(base, "g?y"));
+    assertEquals("http://a/b/c/d;p?q#s", UriUtil.resolve(base, "#s"));
+    assertEquals("http://a/b/c/g#s", UriUtil.resolve(base, "g#s"));
+    assertEquals("http://a/b/c/g?y#s", UriUtil.resolve(base, "g?y#s"));
+    assertEquals("http://a/b/c/;x", UriUtil.resolve(base, ";x"));
+    assertEquals("http://a/b/c/g;x", UriUtil.resolve(base, "g;x"));
+    assertEquals("http://a/b/c/g;x?y#s", UriUtil.resolve(base, "g;x?y#s"));
+    assertEquals("http://a/b/c/d;p?q", UriUtil.resolve(base, ""));
+    assertEquals("http://a/b/c/", UriUtil.resolve(base, "."));
+    assertEquals("http://a/b/c/", UriUtil.resolve(base, "./"));
+    assertEquals("http://a/b/", UriUtil.resolve(base, ".."));
+    assertEquals("http://a/b/", UriUtil.resolve(base, "../"));
+    assertEquals("http://a/b/g", UriUtil.resolve(base, "../g"));
+    assertEquals("http://a/", UriUtil.resolve(base, "../.."));
+    assertEquals("http://a/", UriUtil.resolve(base, "../../"));
+    assertEquals("http://a/g", UriUtil.resolve(base, "../../g"));
+  }
+
+  /**
+   * Tests abnormal usage of {@link UriUtil#resolve(String, String)}.
+   * <p>
+   * The test cases are taken from RFC-3986 5.4.2.
+   */
+  public void testResolveAbnormal() {
+    String base = "http://a/b/c/d;p?q";
+
+    assertEquals("http://a/g", UriUtil.resolve(base, "../../../g"));
+    assertEquals("http://a/g", UriUtil.resolve(base, "../../../../g"));
+
+    assertEquals("http://a/g", UriUtil.resolve(base, "/./g"));
+    assertEquals("http://a/g", UriUtil.resolve(base, "/../g"));
+    assertEquals("http://a/b/c/g.", UriUtil.resolve(base, "g."));
+    assertEquals("http://a/b/c/.g", UriUtil.resolve(base, ".g"));
+    assertEquals("http://a/b/c/g..", UriUtil.resolve(base, "g.."));
+    assertEquals("http://a/b/c/..g", UriUtil.resolve(base, "..g"));
+
+    assertEquals("http://a/b/g", UriUtil.resolve(base, "./../g"));
+    assertEquals("http://a/b/c/g/", UriUtil.resolve(base, "./g/."));
+    assertEquals("http://a/b/c/g/h", UriUtil.resolve(base, "g/./h"));
+    assertEquals("http://a/b/c/h", UriUtil.resolve(base, "g/../h"));
+    assertEquals("http://a/b/c/g;x=1/y", UriUtil.resolve(base, "g;x=1/./y"));
+    assertEquals("http://a/b/c/y", UriUtil.resolve(base, "g;x=1/../y"));
+
+    assertEquals("http://a/b/c/g?y/./x", UriUtil.resolve(base, "g?y/./x"));
+    assertEquals("http://a/b/c/g?y/../x", UriUtil.resolve(base, "g?y/../x"));
+    assertEquals("http://a/b/c/g#s/./x", UriUtil.resolve(base, "g#s/./x"));
+    assertEquals("http://a/b/c/g#s/../x", UriUtil.resolve(base, "g#s/../x"));
+
+    assertEquals("http:g", UriUtil.resolve(base, "http:g"));
+  }
+
+  /**
+   * Tests additional abnormal usage of {@link UriUtil#resolve(String, String)}.
+   */
+  public void testResolveAbnormalAdditional() {
+    assertEquals("c:e", UriUtil.resolve("http://a/b", "c:d/../e"));
+    assertEquals("a:c", UriUtil.resolve("a:b", "../c"));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java b/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
new file mode 100644
index 0000000000..351e93c339
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import junit.framework.TestCase;
+
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Unit tests for {@link Util}.
+ */
+public class UtilTest extends TestCase {
+
+  public void testArrayBinarySearchFloor() {
+    long[] values = new long[0];
+    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
+    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
+
+    values = new long[] {1, 3, 5};
+    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
+    assertEquals(-1, Util.binarySearchFloor(values, 0, true, false));
+    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
+    assertEquals(0, Util.binarySearchFloor(values, 0, true, true));
+
+    assertEquals(-1, Util.binarySearchFloor(values, 1, false, false));
+    assertEquals(0, Util.binarySearchFloor(values, 1, true, false));
+    assertEquals(0, Util.binarySearchFloor(values, 1, false, true));
+    assertEquals(0, Util.binarySearchFloor(values, 1, true, true));
+
+    assertEquals(1, Util.binarySearchFloor(values, 4, false, false));
+    assertEquals(1, Util.binarySearchFloor(values, 4, true, false));
+
+    assertEquals(1, Util.binarySearchFloor(values, 5, false, false));
+    assertEquals(2, Util.binarySearchFloor(values, 5, true, false));
+
+    assertEquals(2, Util.binarySearchFloor(values, 6, false, false));
+    assertEquals(2, Util.binarySearchFloor(values, 6, true, false));
+  }
+
+  public void testListBinarySearchFloor() {
+    List<Integer> values = new ArrayList<Integer>();
+    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
+    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
+
+    values.add(1);
+    values.add(3);
+    values.add(5);
+    assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
+    assertEquals(-1, Util.binarySearchFloor(values, 0, true, false));
+    assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
+    assertEquals(0, Util.binarySearchFloor(values, 0, true, true));
+
+    assertEquals(-1, Util.binarySearchFloor(values, 1, false, false));
+    assertEquals(0, Util.binarySearchFloor(values, 1, true, false));
+    assertEquals(0, Util.binarySearchFloor(values, 1, false, true));
+    assertEquals(0, Util.binarySearchFloor(values, 1, true, true));
+
+    assertEquals(1, Util.binarySearchFloor(values, 4, false, false));
+    assertEquals(1, Util.binarySearchFloor(values, 4, true, false));
+
+    assertEquals(1, Util.binarySearchFloor(values, 5, false, false));
+    assertEquals(2, Util.binarySearchFloor(values, 5, true, false));
+
+    assertEquals(2, Util.binarySearchFloor(values, 6, false, false));
+    assertEquals(2, Util.binarySearchFloor(values, 6, true, false));
+  }
+
+  public void testArrayBinarySearchCeil() {
+    long[] values = new long[0];
+    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
+    assertEquals(-1, Util.binarySearchCeil(values, 0, false, true));
+
+    values = new long[] {1, 3, 5};
+    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
+    assertEquals(0, Util.binarySearchCeil(values, 0, true, false));
+
+    assertEquals(1, Util.binarySearchCeil(values, 1, false, false));
+    assertEquals(0, Util.binarySearchCeil(values, 1, true, false));
+
+    assertEquals(1, Util.binarySearchCeil(values, 2, false, false));
+    assertEquals(1, Util.binarySearchCeil(values, 2, true, false));
+
+    assertEquals(3, Util.binarySearchCeil(values, 5, false, false));
+    assertEquals(2, Util.binarySearchCeil(values, 5, true, false));
+    assertEquals(2, Util.binarySearchCeil(values, 5, false, true));
+    assertEquals(2, Util.binarySearchCeil(values, 5, true, true));
+
+    assertEquals(3, Util.binarySearchCeil(values, 6, false, false));
+    assertEquals(3, Util.binarySearchCeil(values, 6, true, false));
+    assertEquals(2, Util.binarySearchCeil(values, 6, false, true));
+    assertEquals(2, Util.binarySearchCeil(values, 6, true, true));
+  }
+
+  public void testListBinarySearchCeil() {
+    List<Integer> values = new ArrayList<Integer>();
+    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
+    assertEquals(-1, Util.binarySearchCeil(values, 0, false, true));
+
+    values.add(1);
+    values.add(3);
+    values.add(5);
+    assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
+    assertEquals(0, Util.binarySearchCeil(values, 0, true, false));
+
+    assertEquals(1, Util.binarySearchCeil(values, 1, false, false));
+    assertEquals(0, Util.binarySearchCeil(values, 1, true, false));
+
+    assertEquals(1, Util.binarySearchCeil(values, 2, false, false));
+    assertEquals(1, Util.binarySearchCeil(values, 2, true, false));
+
+    assertEquals(3, Util.binarySearchCeil(values, 5, false, false));
+    assertEquals(2, Util.binarySearchCeil(values, 5, true, false));
+    assertEquals(2, Util.binarySearchCeil(values, 5, false, true));
+    assertEquals(2, Util.binarySearchCeil(values, 5, true, true));
+
+    assertEquals(3, Util.binarySearchCeil(values, 6, false, false));
+    assertEquals(3, Util.binarySearchCeil(values, 6, true, false));
+    assertEquals(2, Util.binarySearchCeil(values, 6, false, true));
+    assertEquals(2, Util.binarySearchCeil(values, 6, true, true));
+  }
+
+  public void testParseXsDuration() {
+    assertEquals(150279L, Util.parseXsDuration("PT150.279S"));
+    assertEquals(1500L, Util.parseXsDuration("PT1.500S"));
+  }
+
+  public void testParseXsDateTime() throws ParseException {
+    assertEquals(1403219262000L, Util.parseXsDateTime("2014-06-19T23:07:42"));
+    assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00Z"));
+  }
+
+}
diff --git a/library/src/test/libs/.README.txt b/library/src/test/libs/.README.txt
new file mode 100644
index 0000000000..3f37353a9d
--- /dev/null
+++ b/library/src/test/libs/.README.txt
@@ -0,0 +1 @@
+This file is needed to make sure the libs directory is present.
diff --git a/library/src/test/project.properties b/library/src/test/project.properties
new file mode 100644
index 0000000000..00cf62bacc
--- /dev/null
+++ b/library/src/test/project.properties
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-22
diff --git a/library/src/test/res/.README.txt b/library/src/test/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/library/src/test/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/third_party/dexmaker/LICENSE b/third_party/dexmaker/LICENSE
new file mode 100644
index 0000000000..261eeb9e9f
--- /dev/null
+++ b/third_party/dexmaker/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/third_party/dexmaker/dexmaker-1.2.jar b/third_party/dexmaker/dexmaker-1.2.jar
new file mode 100644
index 0000000000..08d1b85f18
Binary files /dev/null and b/third_party/dexmaker/dexmaker-1.2.jar differ
diff --git a/third_party/dexmaker/dexmaker-mockito-1.2.jar b/third_party/dexmaker/dexmaker-mockito-1.2.jar
new file mode 100644
index 0000000000..a3e19759c2
Binary files /dev/null and b/third_party/dexmaker/dexmaker-mockito-1.2.jar differ
diff --git a/third_party/mockito/LICENSE b/third_party/mockito/LICENSE
new file mode 100644
index 0000000000..2a5730a7ce
--- /dev/null
+++ b/third_party/mockito/LICENSE
@@ -0,0 +1,21 @@
+The MIT License
+
+Copyright (c) 2008-2010 Mockito contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/third_party/mockito/mockito-all-1.9.5.jar b/third_party/mockito/mockito-all-1.9.5.jar
new file mode 100644
index 0000000000..00416eb387
Binary files /dev/null and b/third_party/mockito/mockito-all-1.9.5.jar differ
