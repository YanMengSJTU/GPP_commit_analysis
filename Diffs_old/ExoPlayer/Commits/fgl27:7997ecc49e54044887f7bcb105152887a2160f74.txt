diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index d166fb41c6..5f7d5bea9c 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -38,6 +38,14 @@
   `ExoPlayer.Builder`.
 * Inject `DrmSessionManager` into the `MediaSources` instead of `Renderers`
   ([#5619](https://github.com/google/ExoPlayer/issues/5619)).
+* Fix issue where player errors are thrown too early at playlist transitions
+  ([#5407](https://github.com/google/ExoPlayer/issues/5407)).
+* Deprecate `setTag` parameter of `Timeline.getWindow`. Tags will always be set.
+* Support out-of-band HDR10+ metadata for VP9 in WebM/Matroska.
+* Fix issue where HLS streams get stuck in infinite buffering state after
+  postroll ad ([#6314](https://github.com/google/ExoPlayer/issues/6314)).
+* Fix audio selection issue where languages are compared by bit rate
+  ([#6335](https://github.com/google/ExoPlayer/issues/6335)).
 
 ### 2.10.4 ###
 
diff --git a/constants.gradle b/constants.gradle
index b063ed5e87..abbb413284 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -26,6 +26,7 @@ project.ext {
     checkerframeworkVersion = '2.10.0'
     checkerframeworkVersionC = '2.5.5'
     jsr305Version = '3.0.2'
+    kotlinAnnotationsVersion = '1.3.31'
     androidXTestVersion = '1.2.0'
     androidXTestVersionJ = '1.1.1'
     truthVersion = '1.0'
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
index b84f1c1f2b..58dbec611a 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -110,13 +110,11 @@ public int getWindowCount() {
   }
 
   @Override
-  public Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
     long durationUs = durationsUs[windowIndex];
     boolean isDynamic = durationUs == C.TIME_UNSET;
-    Object tag = setTag ? ids[windowIndex] : null;
     return window.set(
-        tag,
+        /* tag= */ ids[windowIndex],
         /* manifest= */ null,
         /* presentationStartTimeMs= */ C.TIME_UNSET,
         /* windowStartTimeMs= */ C.TIME_UNSET,
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index e37f192c97..3b2bcd8880 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -327,6 +327,7 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
+  private boolean wasSetPlayerCalled;
   @Nullable private Player nextPlayer;
   private Object pendingAdRequestContext;
   private List<String> supportedMimeTypes;
@@ -337,6 +338,7 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private int lastVolumePercentage;
 
   private AdsManager adsManager;
+  private boolean initializedAdsManager;
   private AdLoadException pendingAdLoadError;
   private Timeline timeline;
   private long contentDurationMs;
@@ -483,6 +485,7 @@ private ImaAdsLoader(
     pendingContentPositionMs = C.TIME_UNSET;
     adGroupIndex = C.INDEX_UNSET;
     contentDurationMs = C.TIME_UNSET;
+    timeline = Timeline.EMPTY;
   }
 
   /**
@@ -558,6 +561,7 @@ public void setPlayer(@Nullable Player player) {
     Assertions.checkState(
         player == null || player.getApplicationLooper() == Looper.getMainLooper());
     nextPlayer = player;
+    wasSetPlayerCalled = true;
   }
 
   @Override
@@ -585,9 +589,12 @@ public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
 
   @Override
   public void start(EventListener eventListener, AdViewProvider adViewProvider) {
-    Assertions.checkNotNull(
-        nextPlayer, "Set player using adsLoader.setPlayer before preparing the player.");
+    Assertions.checkState(
+        wasSetPlayerCalled, "Set player using adsLoader.setPlayer before preparing the player.");
     player = nextPlayer;
+    if (player == null) {
+      return;
+    }
     this.eventListener = eventListener;
     lastVolumePercentage = 0;
     lastAdProgress = null;
@@ -607,8 +614,8 @@ public void start(EventListener eventListener, AdViewProvider adViewProvider) {
         adsManager.resume();
       }
     } else if (adsManager != null) {
-      // Ads have loaded but the ads manager is not initialized.
-      startAdPlayback();
+      adPlaybackState = new AdPlaybackState(getAdGroupTimesUs(adsManager.getAdCuePoints()));
+      updateAdPlaybackState();
     } else {
       // Ads haven't loaded yet, so request them.
       requestAds(adViewGroup);
@@ -617,6 +624,9 @@ public void start(EventListener eventListener, AdViewProvider adViewProvider) {
 
   @Override
   public void stop() {
+    if (player == null) {
+      return;
+    }
     if (adsManager != null && imaPausedContent) {
       adPlaybackState =
           adPlaybackState.withAdResumePositionUs(
@@ -679,7 +689,8 @@ public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
     if (player != null) {
       // If a player is attached already, start playback immediately.
       try {
-        startAdPlayback();
+        adPlaybackState = new AdPlaybackState(getAdGroupTimesUs(adsManager.getAdCuePoints()));
+        updateAdPlaybackState();
       } catch (Exception e) {
         maybeNotifyInternalError("onAdsManagerLoaded", e);
       }
@@ -958,7 +969,11 @@ public void onTimelineChanged(Timeline timeline, @Player.TimelineChangeReason in
     if (contentDurationUs != C.TIME_UNSET) {
       adPlaybackState = adPlaybackState.withContentDurationUs(contentDurationUs);
     }
-    updateImaStateForPlayerState();
+    if (!initializedAdsManager && adsManager != null) {
+      initializedAdsManager = true;
+      initializeAdsManager();
+    }
+    onPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
   }
 
   @Override
@@ -1013,7 +1028,7 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
           }
         }
         updateAdPlaybackState();
-      } else {
+      } else if (!timeline.isEmpty()) {
         long positionMs = player.getCurrentPosition();
         timeline.getPeriod(0, period);
         int newAdGroupIndex = period.getAdGroupIndexForPositionUs(C.msToUs(positionMs));
@@ -1025,14 +1040,13 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
           }
         }
       }
-    } else {
-      updateImaStateForPlayerState();
     }
+    updateImaStateForPlayerState();
   }
 
   // Internal methods.
 
-  private void startAdPlayback() {
+  private void initializeAdsManager() {
     AdsRenderingSettings adsRenderingSettings = imaFactory.createAdsRenderingSettings();
     adsRenderingSettings.setEnablePreloading(ENABLE_PRELOADING);
     adsRenderingSettings.setMimeTypes(supportedMimeTypes);
@@ -1047,10 +1061,9 @@ private void startAdPlayback() {
       adsRenderingSettings.setUiElements(adUiElements);
     }
 
-    // Set up the ad playback state, skipping ads based on the start position as required.
+    // Skip ads based on the start position as required.
     long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
-    adPlaybackState = new AdPlaybackState(adGroupTimesUs);
-    long contentPositionMs = player.getCurrentPosition();
+    long contentPositionMs = player.getContentPosition();
     int adGroupIndexForPosition =
         adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
     if (adGroupIndexForPosition > 0 && adGroupIndexForPosition != C.INDEX_UNSET) {
@@ -1084,7 +1097,6 @@ private void startAdPlayback() {
       pendingContentPositionMs = contentPositionMs;
     }
 
-    // Start ad playback.
     adsManager.init(adsRenderingSettings);
     updateAdPlaybackState();
     if (DEBUG) {
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
index ab880703ee..98aee17d73 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
@@ -143,7 +143,8 @@ public void testStart_updatesAdPlaybackState() {
     assertThat(adsLoaderListener.adPlaybackState)
         .isEqualTo(
             new AdPlaybackState(/* adGroupTimesUs= */ 0)
-                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US));
+                .withAdDurationsUs(PREROLL_ADS_DURATIONS_US)
+                .withContentDurationUs(CONTENT_DURATION_US));
   }
 
   @Test
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 1392e782f8..5630058712 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -30,9 +30,11 @@
 /* package */ final class VpxDecoder
     extends SimpleDecoder<VideoDecoderInputBuffer, VpxOutputBuffer, VpxDecoderException> {
 
+  // These constants should match the codes returned from vpxDecode and vpxSecureDecode functions in
+  // https://github.com/google/ExoPlayer/blob/release-v2/extensions/vp9/src/main/jni/vpx_jni.cc.
   private static final int NO_ERROR = 0;
-  private static final int DECODE_ERROR = 1;
-  private static final int DRM_ERROR = 2;
+  private static final int DECODE_ERROR = -1;
+  private static final int DRM_ERROR = -2;
 
   @Nullable private final ExoMediaCrypto exoMediaCrypto;
   private final long vpxDecContext;
@@ -139,7 +141,10 @@ protected VpxDecoderException decode(
     }
 
     if (!inputBuffer.isDecodeOnly()) {
-      outputBuffer.init(inputBuffer.timeUs, outputMode);
+      @Nullable
+      ByteBuffer supplementalData =
+          inputBuffer.hasSupplementalData() ? inputBuffer.supplementalData : null;
+      outputBuffer.init(inputBuffer.timeUs, outputMode, supplementalData);
       int getFrameResult = vpxGetFrame(vpxDecContext, outputBuffer);
       if (getFrameResult == 1) {
         outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index d23f07a90b..303672334d 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -342,7 +342,7 @@ class JniBufferManager {
     *fb = out_buffer->vpx_fb;
     int retVal = 0;
     if (!out_buffer->vpx_fb.data || all_buffer_count >= MAX_FRAMES) {
-      LOGE("ERROR: JniBufferManager get_buffer OOM.");
+      LOGE("JniBufferManager get_buffer OOM.");
       retVal = -1;
     } else {
       memset(fb->data, 0, fb->size);
@@ -354,7 +354,7 @@ class JniBufferManager {
 
   JniFrameBuffer* get_buffer(int id) const {
     if (id < 0 || id >= all_buffer_count) {
-      LOGE("ERROR: JniBufferManager get_buffer invalid id %d.", id);
+      LOGE("JniBufferManager get_buffer invalid id %d.", id);
       return NULL;
     }
     return all_buffers[id];
@@ -362,7 +362,7 @@ class JniBufferManager {
 
   void add_ref(int id) {
     if (id < 0 || id >= all_buffer_count) {
-      LOGE("ERROR: JniBufferManager add_ref invalid id %d.", id);
+      LOGE("JniBufferManager add_ref invalid id %d.", id);
       return;
     }
     pthread_mutex_lock(&mutex);
@@ -372,13 +372,13 @@ class JniBufferManager {
 
   int release(int id) {
     if (id < 0 || id >= all_buffer_count) {
-      LOGE("ERROR: JniBufferManager release invalid id %d.", id);
+      LOGE("JniBufferManager release invalid id %d.", id);
       return -1;
     }
     pthread_mutex_lock(&mutex);
     JniFrameBuffer* buffer = all_buffers[id];
     if (!buffer->ref_count) {
-      LOGE("ERROR: JniBufferManager release, buffer already released.");
+      LOGE("JniBufferManager release, buffer already released.");
       pthread_mutex_unlock(&mutex);
       return -1;
     }
@@ -444,7 +444,7 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
   vpx_codec_err_t err =
       vpx_codec_dec_init(context->decoder, &vpx_codec_vp9_dx_algo, &cfg, 0);
   if (err) {
-    LOGE("ERROR: Failed to initialize libvpx decoder, error = %d.", err);
+    LOGE("Failed to initialize libvpx decoder, error = %d.", err);
     errorCode = err;
     return 0;
   }
@@ -452,20 +452,19 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
   err = vpx_codec_control(context->decoder, VP9D_SET_ROW_MT,
                           enableRowMultiThreadMode);
   if (err) {
-    LOGE("ERROR: Failed to enable row multi thread mode, error = %d.", err);
+    LOGE("Failed to enable row multi thread mode, error = %d.", err);
   }
 #endif
   if (disableLoopFilter) {
     err = vpx_codec_control(context->decoder, VP9_SET_SKIP_LOOP_FILTER, true);
     if (err) {
-      LOGE("ERROR: Failed to shut off libvpx loop filter, error = %d.", err);
+      LOGE("Failed to shut off libvpx loop filter, error = %d.", err);
     }
 #ifdef VPX_CTRL_VP9_SET_LOOP_FILTER_OPT
   } else {
     err = vpx_codec_control(context->decoder, VP9D_SET_LOOP_FILTER_OPT, true);
     if (err) {
-      LOGE("ERROR: Failed to enable loop filter optimization, error = %d.",
-           err);
+      LOGE("Failed to enable loop filter optimization, error = %d.", err);
     }
 #endif
   }
@@ -473,8 +472,7 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
       context->decoder, vpx_get_frame_buffer, vpx_release_frame_buffer,
       context->buffer_manager);
   if (err) {
-    LOGE("ERROR: Failed to set libvpx frame buffer functions, error = %d.",
-         err);
+    LOGE("Failed to set libvpx frame buffer functions, error = %d.", err);
   }
 
   // Populate JNI References.
@@ -500,7 +498,7 @@ DECODER_FUNC(jlong, vpxDecode, jlong jContext, jobject encoded, jint len) {
       vpx_codec_decode(context->decoder, buffer, len, NULL, 0);
   errorCode = 0;
   if (status != VPX_CODEC_OK) {
-    LOGE("ERROR: vpx_codec_decode() failed, status= %d", status);
+    LOGE("vpx_codec_decode() failed, status= %d", status);
     errorCode = status;
     return -1;
   }
@@ -597,8 +595,8 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
   } else if (outputMode == kOutputModeSurfaceYuv) {
     if (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) {
       LOGE(
-          "ERROR: High bit depth output format %d not supported in surface "
-          "YUV output mode",
+          "High bit depth output format %d not supported in surface YUV output "
+          "mode",
           img->fmt);
       return -1;
     }
diff --git a/library/core/build.gradle b/library/core/build.gradle
index 775289c1e8..fcc943787b 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -61,8 +61,7 @@ dependencies {
     compileOnly 'com.google.code.findbugs:jsr305:' + jsr305Version
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersionC
-    // Uncomment to enable Kotlin non-null strict mode. See [internal: b/138703808].
-    // compileOnly "org.jetbrains.kotlin:kotlin-annotations-jvm:1.1.60"
+    compileOnly 'org.jetbrains.kotlin:kotlin-annotations-jvm:' + kotlinAnnotationsVersion
     androidTestImplementation 'androidx.test:runner:' + androidXTestVersion
     androidTestImplementation 'androidx.test.ext:junit:' + androidXTestVersionJ
     androidTestImplementation 'com.google.truth:truth:' + truthVersion
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index 1f7a8d0ee7..ab3cc5fccd 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -58,5 +58,6 @@
   <init>(com.google.android.exoplayer2.upstream.DataSource$Factory);
 }
 
-# Don't warn about checkerframework
+# Don't warn about checkerframework and Kotlin annotations
 -dontwarn org.checkerframework.**
+-dontwarn kotlin.annotations.jvm.**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
index bb14ac147b..1b3e57cede 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -95,18 +95,14 @@ public final int getPreviousWindowIndex() {
   @Nullable
   public final Object getCurrentTag() {
     Timeline timeline = getCurrentTimeline();
-    return timeline.isEmpty()
-        ? null
-        : timeline.getWindow(getCurrentWindowIndex(), window, /* setTag= */ true).tag;
+    return timeline.isEmpty() ? null : timeline.getWindow(getCurrentWindowIndex(), window).tag;
   }
 
   @Override
   @Nullable
   public final Object getCurrentManifest() {
     Timeline timeline = getCurrentTimeline();
-    return timeline.isEmpty()
-        ? null
-        : timeline.getWindow(getCurrentWindowIndex(), window, /* setTag= */ false).manifest;
+    return timeline.isEmpty() ? null : timeline.getWindow(getCurrentWindowIndex(), window).manifest;
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index cd862e503f..d073eb4ee0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -480,6 +480,7 @@ private C() {}
       value = {
         BUFFER_FLAG_KEY_FRAME,
         BUFFER_FLAG_END_OF_STREAM,
+        BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA,
         BUFFER_FLAG_LAST_SAMPLE,
         BUFFER_FLAG_ENCRYPTED,
         BUFFER_FLAG_DECODE_ONLY
@@ -493,6 +494,8 @@ private C() {}
    * Flag for empty buffers that signal that the end of the stream was reached.
    */
   public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+  /** Indicates that a buffer has supplemental data. */
+  public static final int BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA = 1 << 28; // 0x10000000
   /** Indicates that a buffer is known to contain the last media sample of the stream. */
   public static final int BUFFER_FLAG_LAST_SAMPLE = 1 << 29; // 0x20000000
   /** Indicates that a buffer is (at least partially) encrypted. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 991be9b08b..2bed5d6f8b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -19,6 +19,7 @@
 import android.os.Looper;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
@@ -138,6 +139,8 @@
     private LoadControl loadControl;
     private BandwidthMeter bandwidthMeter;
     private Looper looper;
+    private AnalyticsCollector analyticsCollector;
+    private boolean useLazyPreparation;
     private boolean buildCalled;
 
     /**
@@ -152,6 +155,8 @@
      *   <li>{@link Looper}: The {@link Looper} associated with the current thread, or the {@link
      *       Looper} of the application's main thread if the current thread doesn't have a {@link
      *       Looper}
+     *   <li>{@link AnalyticsCollector}: {@link AnalyticsCollector} with {@link Clock#DEFAULT}
+     *   <li>{@code useLazyPreparation}: {@code true}
      *   <li>{@link Clock}: {@link Clock#DEFAULT}
      * </ul>
      *
@@ -165,6 +170,8 @@ public Builder(Context context, Renderer... renderers) {
           new DefaultLoadControl(),
           DefaultBandwidthMeter.getSingletonInstance(context),
           Util.getLooper(),
+          new AnalyticsCollector(Clock.DEFAULT),
+          /* useLazyPreparation= */ true,
           Clock.DEFAULT);
     }
 
@@ -180,6 +187,8 @@ public Builder(Context context, Renderer... renderers) {
      * @param loadControl A {@link LoadControl}.
      * @param bandwidthMeter A {@link BandwidthMeter}.
      * @param looper A {@link Looper} that must be used for all calls to the player.
+     * @param analyticsCollector An {@link AnalyticsCollector}.
+     * @param useLazyPreparation Whether media sources should be initialized lazily.
      * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
      */
     public Builder(
@@ -188,6 +197,8 @@ public Builder(
         LoadControl loadControl,
         BandwidthMeter bandwidthMeter,
         Looper looper,
+        AnalyticsCollector analyticsCollector,
+        boolean useLazyPreparation,
         Clock clock) {
       Assertions.checkArgument(renderers.length > 0);
       this.renderers = renderers;
@@ -195,6 +206,8 @@ public Builder(
       this.loadControl = loadControl;
       this.bandwidthMeter = bandwidthMeter;
       this.looper = looper;
+      this.analyticsCollector = analyticsCollector;
+      this.useLazyPreparation = useLazyPreparation;
       this.clock = clock;
     }
 
@@ -251,6 +264,36 @@ public Builder setLooper(Looper looper) {
       return this;
     }
 
+    /**
+     * Sets the {@link AnalyticsCollector} that will collect and forward all player events.
+     *
+     * @param analyticsCollector An {@link AnalyticsCollector}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setAnalyticsCollector(AnalyticsCollector analyticsCollector) {
+      Assertions.checkState(!buildCalled);
+      this.analyticsCollector = analyticsCollector;
+      return this;
+    }
+
+    /**
+     * Sets whether media sources should be initialized lazily.
+     *
+     * <p>If false, all initial preparation steps (e.g., manifest loads) happen immediately. If
+     * true, these initial preparations are triggered only when the player starts buffering the
+     * media.
+     *
+     * @param useLazyPreparation Whether to use lazy preparation.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setUseLazyPreparation(boolean useLazyPreparation) {
+      Assertions.checkState(!buildCalled);
+      this.useLazyPreparation = useLazyPreparation;
+      return this;
+    }
+
     /**
      * Sets the {@link Clock} that will be used by the player. Should only be set for testing
      * purposes.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index ae5071717d..efe351c70a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -296,6 +296,7 @@ public static SimpleExoPlayer newSimpleInstance(
         drmSessionManager,
         bandwidthMeter,
         analyticsCollector,
+        Clock.DEFAULT,
         looper);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index cacdaec02e..38d66e5cbc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -74,7 +74,6 @@
   private int pendingSetPlaybackParametersAcks;
   private PlaybackParameters playbackParameters;
   private SeekParameters seekParameters;
-  @Nullable private ExoPlaybackException playbackError;
 
   // Playback information when there is no pending seek/set source operation.
   private PlaybackInfo playbackInfo;
@@ -202,13 +201,12 @@ public int getPlaybackState() {
   @Override
   @Nullable
   public ExoPlaybackException getPlaybackError() {
-    return playbackError;
+    return playbackInfo.playbackError;
   }
 
   @Override
   public void retry() {
-    if (mediaSource != null
-        && (playbackError != null || playbackInfo.playbackState == Player.STATE_IDLE)) {
+    if (mediaSource != null && playbackInfo.playbackState == Player.STATE_IDLE) {
       prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
     }
   }
@@ -220,11 +218,13 @@ public void prepare(MediaSource mediaSource) {
 
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-    playbackError = null;
     this.mediaSource = mediaSource;
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
-            resetPosition, resetState, /* playbackState= */ Player.STATE_BUFFERING);
+            resetPosition,
+            resetState,
+            /* resetError= */ true,
+            /* playbackState= */ Player.STATE_BUFFERING);
     // Trigger internal prepare first before updating the playback info and notifying external
     // listeners to ensure that new operations issued in the listener notifications reach the
     // player after this prepare. The internal player can't change the playback info immediately
@@ -381,13 +381,13 @@ public void setForegroundMode(boolean foregroundMode) {
   @Override
   public void stop(boolean reset) {
     if (reset) {
-      playbackError = null;
       mediaSource = null;
     }
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
             /* resetPosition= */ reset,
             /* resetState= */ reset,
+            /* resetError= */ reset,
             /* playbackState= */ Player.STATE_IDLE);
     // Trigger internal stop first before updating the playback info and notifying external
     // listeners to ensure that new operations issued in the listener notifications reach the
@@ -415,6 +415,7 @@ public void release() {
         getResetPlaybackInfo(
             /* resetPosition= */ false,
             /* resetState= */ false,
+            /* resetError= */ false,
             /* playbackState= */ Player.STATE_IDLE);
   }
 
@@ -572,11 +573,6 @@ public Timeline getCurrentTimeline() {
       case ExoPlayerImplInternal.MSG_PLAYBACK_PARAMETERS_CHANGED:
         handlePlaybackParameters((PlaybackParameters) msg.obj, /* operationAck= */ msg.arg1 != 0);
         break;
-      case ExoPlayerImplInternal.MSG_ERROR:
-        ExoPlaybackException playbackError = (ExoPlaybackException) msg.obj;
-        this.playbackError = playbackError;
-        notifyListeners(listener -> listener.onPlayerError(playbackError));
-        break;
       default:
         throw new IllegalStateException();
     }
@@ -635,7 +631,10 @@ private void handlePlaybackInfo(
   }
 
   private PlaybackInfo getResetPlaybackInfo(
-      boolean resetPosition, boolean resetState, @Player.State int playbackState) {
+      boolean resetPosition,
+      boolean resetState,
+      boolean resetError,
+      @Player.State int playbackState) {
     if (resetPosition) {
       maskingWindowIndex = 0;
       maskingPeriodIndex = 0;
@@ -659,6 +658,7 @@ private PlaybackInfo getResetPlaybackInfo(
         startPositionUs,
         contentPositionUs,
         playbackState,
+        resetError ? null : playbackInfo.playbackError,
         /* isLoading= */ false,
         resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
         resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
@@ -728,6 +728,7 @@ private boolean shouldMaskPosition() {
     private final @Player.TimelineChangeReason int timelineChangeReason;
     private final boolean seekProcessed;
     private final boolean playbackStateChanged;
+    private final boolean playbackErrorChanged;
     private final boolean timelineChanged;
     private final boolean isLoadingChanged;
     private final boolean trackSelectorResultChanged;
@@ -752,6 +753,9 @@ public PlaybackInfoUpdate(
       this.seekProcessed = seekProcessed;
       this.playWhenReady = playWhenReady;
       playbackStateChanged = previousPlaybackInfo.playbackState != playbackInfo.playbackState;
+      playbackErrorChanged =
+          previousPlaybackInfo.playbackError != playbackInfo.playbackError
+              && playbackInfo.playbackError != null;
       timelineChanged = previousPlaybackInfo.timeline != playbackInfo.timeline;
       isLoadingChanged = previousPlaybackInfo.isLoading != playbackInfo.isLoading;
       trackSelectorResultChanged =
@@ -770,6 +774,9 @@ public void run() {
             listenerSnapshot,
             listener -> listener.onPositionDiscontinuity(positionDiscontinuityReason));
       }
+      if (playbackErrorChanged) {
+        invokeAll(listenerSnapshot, listener -> listener.onPlayerError(playbackInfo.playbackError));
+      }
       if (trackSelectorResultChanged) {
         trackSelector.onSelectionActivated(playbackInfo.trackSelectorResult.info);
         invokeAll(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 6ab0838e26..a6e8c679a8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -61,7 +61,6 @@
   // External messages
   public static final int MSG_PLAYBACK_INFO_CHANGED = 0;
   public static final int MSG_PLAYBACK_PARAMETERS_CHANGED = 1;
-  public static final int MSG_ERROR = 2;
 
   // Internal messages
   private static final int MSG_PREPARE = 0;
@@ -83,8 +82,7 @@
   private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 16;
   private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 17;
 
-  private static final int PREPARING_SOURCE_INTERVAL_MS = 10;
-  private static final int RENDERING_INTERVAL_MS = 10;
+  private static final int ACTIVE_INTERVAL_MS = 10;
   private static final int IDLE_INTERVAL_MS = 1000;
 
   private final Renderer[] renderers;
@@ -375,19 +373,19 @@ public boolean handleMessage(Message msg) {
       maybeNotifyPlaybackInfoChanged();
     } catch (ExoPlaybackException e) {
       Log.e(TAG, "Playback error.", e);
-      eventHandler.obtainMessage(MSG_ERROR, e).sendToTarget();
       stopInternal(
           /* forceResetRenderers= */ true,
           /* resetPositionAndState= */ false,
           /* acknowledgeStop= */ false);
+      playbackInfo = playbackInfo.copyWithPlaybackError(e);
       maybeNotifyPlaybackInfoChanged();
     } catch (IOException e) {
       Log.e(TAG, "Source error.", e);
-      eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForSource(e)).sendToTarget();
       stopInternal(
           /* forceResetRenderers= */ false,
           /* resetPositionAndState= */ false,
           /* acknowledgeStop= */ false);
+      playbackInfo = playbackInfo.copyWithPlaybackError(ExoPlaybackException.createForSource(e));
       maybeNotifyPlaybackInfoChanged();
     } catch (RuntimeException | OutOfMemoryError e) {
       Log.e(TAG, "Internal runtime error.", e);
@@ -395,11 +393,11 @@ public boolean handleMessage(Message msg) {
           e instanceof OutOfMemoryError
               ? ExoPlaybackException.createForOutOfMemoryError((OutOfMemoryError) e)
               : ExoPlaybackException.createForUnexpected((RuntimeException) e);
-      eventHandler.obtainMessage(MSG_ERROR, error).sendToTarget();
       stopInternal(
           /* forceResetRenderers= */ true,
           /* resetPositionAndState= */ false,
           /* acknowledgeStop= */ false);
+      playbackInfo = playbackInfo.copyWithPlaybackError(error);
       maybeNotifyPlaybackInfoChanged();
     }
     return true;
@@ -437,7 +435,11 @@ private void maybeNotifyPlaybackInfoChanged() {
   private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     pendingPrepareCount++;
     resetInternal(
-        /* resetRenderers= */ false, /* releaseMediaSource= */ true, resetPosition, resetState);
+        /* resetRenderers= */ false,
+        /* releaseMediaSource= */ true,
+        resetPosition,
+        resetState,
+        /* resetError= */ true);
     loadControl.onPrepared();
     this.mediaSource = mediaSource;
     setState(Player.STATE_BUFFERING);
@@ -514,22 +516,25 @@ private void stopRenderers() throws ExoPlaybackException {
   }
 
   private void updatePlaybackPositions() throws ExoPlaybackException {
-    if (!queue.hasPlayingPeriod()) {
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    if (playingPeriodHolder == null) {
       return;
     }
 
     // Update the playback position.
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
-    long periodPositionUs = playingPeriodHolder.mediaPeriod.readDiscontinuity();
-    if (periodPositionUs != C.TIME_UNSET) {
-      resetRendererPosition(periodPositionUs);
+    long discontinuityPositionUs =
+        playingPeriodHolder.prepared
+            ? playingPeriodHolder.mediaPeriod.readDiscontinuity()
+            : C.TIME_UNSET;
+    if (discontinuityPositionUs != C.TIME_UNSET) {
+      resetRendererPosition(discontinuityPositionUs);
       // A MediaPeriod may report a discontinuity at the current playback position to ensure the
       // renderers are flushed. Only report the discontinuity externally if the position changed.
-      if (periodPositionUs != playbackInfo.positionUs) {
+      if (discontinuityPositionUs != playbackInfo.positionUs) {
         playbackInfo =
             playbackInfo.copyWithNewPosition(
                 playbackInfo.periodId,
-                periodPositionUs,
+                discontinuityPositionUs,
                 playbackInfo.contentPositionUs,
                 getTotalBufferedDurationUs());
         playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
@@ -538,7 +543,7 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
       rendererPositionUs =
           mediaClock.syncAndGetPositionUs(
               /* isReadingAhead= */ playingPeriodHolder != queue.getReadingPeriod());
-      periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
+      long periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
       maybeTriggerPendingMessages(playbackInfo.positionUs, periodPositionUs);
       playbackInfo.positionUs = periodPositionUs;
     }
@@ -552,60 +557,71 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
   private void doSomeWork() throws ExoPlaybackException, IOException {
     long operationStartTimeMs = clock.uptimeMillis();
     updatePeriods();
-    if (!queue.hasPlayingPeriod()) {
-      // We're still waiting for the first period to be prepared.
-      maybeThrowPeriodPrepareError();
-      scheduleNextWork(operationStartTimeMs, PREPARING_SOURCE_INTERVAL_MS);
+
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    if (playingPeriodHolder == null) {
+      // We're still waiting until the playing period is available.
+      scheduleNextWork(operationStartTimeMs, ACTIVE_INTERVAL_MS);
       return;
     }
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
 
     TraceUtil.beginSection("doSomeWork");
 
     updatePlaybackPositions();
-    long rendererPositionElapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
-
-    playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs - backBufferDurationUs,
-        retainBackBufferFromKeyframe);
 
     boolean renderersEnded = true;
-    boolean renderersReadyOrEnded = true;
-    for (Renderer renderer : enabledRenderers) {
-      // TODO: Each renderer should return the maximum delay before which it wishes to be called
-      // again. The minimum of these values should then be used as the delay before the next
-      // invocation of this method.
-      renderer.render(rendererPositionUs, rendererPositionElapsedRealtimeUs);
-      renderersEnded = renderersEnded && renderer.isEnded();
-      // Determine whether the renderer is ready (or ended). We override to assume the renderer is
-      // ready if it needs the next sample stream. This is necessary to avoid getting stuck if
-      // tracks in the current period have uneven durations. See:
-      // https://github.com/google/ExoPlayer/issues/1874
-      boolean rendererReadyOrEnded = renderer.isReady() || renderer.isEnded()
-          || rendererWaitingForNextStream(renderer);
-      if (!rendererReadyOrEnded) {
-        renderer.maybeThrowStreamError();
+    boolean renderersAllowPlayback = true;
+    if (playingPeriodHolder.prepared) {
+      long rendererPositionElapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
+      playingPeriodHolder.mediaPeriod.discardBuffer(
+          playbackInfo.positionUs - backBufferDurationUs, retainBackBufferFromKeyframe);
+      for (int i = 0; i < renderers.length; i++) {
+        Renderer renderer = renderers[i];
+        if (renderer.getState() == Renderer.STATE_DISABLED) {
+          continue;
+        }
+        // TODO: Each renderer should return the maximum delay before which it wishes to be called
+        // again. The minimum of these values should then be used as the delay before the next
+        // invocation of this method.
+        renderer.render(rendererPositionUs, rendererPositionElapsedRealtimeUs);
+        renderersEnded = renderersEnded && renderer.isEnded();
+        // Determine whether the renderer allows playback to continue. Playback can continue if the
+        // renderer is ready or ended. Also continue playback if the renderer is reading ahead into
+        // the next stream or is waiting for the next stream. This is to avoid getting stuck if
+        // tracks in the current period have uneven durations and are still being read by another
+        // renderer. See: https://github.com/google/ExoPlayer/issues/1874.
+        boolean isReadingAhead = playingPeriodHolder.sampleStreams[i] != renderer.getStream();
+        boolean isWaitingForNextStream =
+            !isReadingAhead
+                && playingPeriodHolder.getNext() != null
+                && renderer.hasReadStreamToEnd();
+        boolean allowsPlayback =
+            isReadingAhead || isWaitingForNextStream || renderer.isReady() || renderer.isEnded();
+        renderersAllowPlayback = renderersAllowPlayback && allowsPlayback;
+        if (!allowsPlayback) {
+          renderer.maybeThrowStreamError();
+        }
       }
-      renderersReadyOrEnded = renderersReadyOrEnded && rendererReadyOrEnded;
-    }
-    if (!renderersReadyOrEnded) {
-      maybeThrowPeriodPrepareError();
+    } else {
+      playingPeriodHolder.mediaPeriod.maybeThrowPrepareError();
     }
 
     long playingPeriodDurationUs = playingPeriodHolder.info.durationUs;
     if (renderersEnded
+        && playingPeriodHolder.prepared
         && (playingPeriodDurationUs == C.TIME_UNSET
             || playingPeriodDurationUs <= playbackInfo.positionUs)
         && playingPeriodHolder.info.isFinal) {
       setState(Player.STATE_ENDED);
       stopRenderers();
     } else if (playbackInfo.playbackState == Player.STATE_BUFFERING
-        && shouldTransitionToReadyState(renderersReadyOrEnded)) {
+        && shouldTransitionToReadyState(renderersAllowPlayback)) {
       setState(Player.STATE_READY);
       if (playWhenReady) {
         startRenderers();
       }
     } else if (playbackInfo.playbackState == Player.STATE_READY
-        && !(enabledRenderers.length == 0 ? isTimelineReady() : renderersReadyOrEnded)) {
+        && !(enabledRenderers.length == 0 ? isTimelineReady() : renderersAllowPlayback)) {
       rebuffering = playWhenReady;
       setState(Player.STATE_BUFFERING);
       stopRenderers();
@@ -619,7 +635,7 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
 
     if ((playWhenReady && playbackInfo.playbackState == Player.STATE_READY)
         || playbackInfo.playbackState == Player.STATE_BUFFERING) {
-      scheduleNextWork(operationStartTimeMs, RENDERING_INTERVAL_MS);
+      scheduleNextWork(operationStartTimeMs, ACTIVE_INTERVAL_MS);
     } else if (enabledRenderers.length != 0 && playbackInfo.playbackState != Player.STATE_ENDED) {
       scheduleNextWork(operationStartTimeMs, IDLE_INTERVAL_MS);
     } else {
@@ -675,13 +691,16 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
             /* resetRenderers= */ false,
             /* releaseMediaSource= */ false,
             /* resetPosition= */ true,
-            /* resetState= */ false);
+            /* resetState= */ false,
+            /* resetError= */ true);
       } else {
         // Execute the seek in the current media periods.
         long newPeriodPositionUs = periodPositionUs;
         if (periodId.equals(playbackInfo.periodId)) {
           MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
-          if (playingPeriodHolder != null && newPeriodPositionUs != 0) {
+          if (playingPeriodHolder != null
+              && playingPeriodHolder.prepared
+              && newPeriodPositionUs != 0) {
             newPeriodPositionUs =
                 playingPeriodHolder.mediaPeriod.getAdjustedSeekPositionUs(
                     newPeriodPositionUs, seekParameters);
@@ -771,10 +790,11 @@ private long seekToPeriodPosition(
   }
 
   private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackException {
+    MediaPeriodHolder playingMediaPeriod = queue.getPlayingPeriod();
     rendererPositionUs =
-        !queue.hasPlayingPeriod()
+        playingMediaPeriod == null
             ? periodPositionUs
-            : queue.getPlayingPeriod().toRendererTime(periodPositionUs);
+            : playingMediaPeriod.toRendererTime(periodPositionUs);
     mediaClock.resetPosition(rendererPositionUs);
     for (Renderer renderer : enabledRenderers) {
       renderer.resetPosition(rendererPositionUs);
@@ -818,7 +838,8 @@ private void stopInternal(
         /* resetRenderers= */ forceResetRenderers || !foregroundMode,
         /* releaseMediaSource= */ true,
         /* resetPosition= */ resetPositionAndState,
-        /* resetState= */ resetPositionAndState);
+        /* resetState= */ resetPositionAndState,
+        /* resetError= */ resetPositionAndState);
     playbackInfoUpdate.incrementPendingOperationAcks(
         pendingPrepareCount + (acknowledgeStop ? 1 : 0));
     pendingPrepareCount = 0;
@@ -831,7 +852,8 @@ private void releaseInternal() {
         /* resetRenderers= */ true,
         /* releaseMediaSource= */ true,
         /* resetPosition= */ true,
-        /* resetState= */ true);
+        /* resetState= */ true,
+        /* resetError= */ false);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
     internalPlaybackThread.quit();
@@ -845,7 +867,8 @@ private void resetInternal(
       boolean resetRenderers,
       boolean releaseMediaSource,
       boolean resetPosition,
-      boolean resetState) {
+      boolean resetState,
+      boolean resetError) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
     mediaClock.stop();
@@ -908,6 +931,7 @@ private void resetInternal(
             startPositionUs,
             contentPositionUs,
             playbackInfo.playbackState,
+            resetError ? null : playbackInfo.playbackError,
             /* isLoading= */ false,
             resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
             resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
@@ -1092,10 +1116,6 @@ private void disableRenderer(Renderer renderer) throws ExoPlaybackException {
   }
 
   private void reselectTracksInternal() throws ExoPlaybackException {
-    if (!queue.hasPlayingPeriod()) {
-      // We don't have tracks yet, so we don't care.
-      return;
-    }
     float playbackSpeed = mediaClock.getPlaybackParameters().speed;
     // Reselect tracks on each period in turn, until the selection changes.
     MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
@@ -1182,8 +1202,8 @@ private void reselectTracksInternal() throws ExoPlaybackException {
   }
 
   private void updateTrackSelectionPlaybackSpeed(float playbackSpeed) {
-    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
-    while (periodHolder != null && periodHolder.prepared) {
+    MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
+    while (periodHolder != null) {
       TrackSelection[] trackSelections = periodHolder.getTrackSelectorResult().selections.getAll();
       for (TrackSelection trackSelection : trackSelections) {
         if (trackSelection != null) {
@@ -1195,7 +1215,7 @@ private void updateTrackSelectionPlaybackSpeed(float playbackSpeed) {
   }
 
   private void notifyTrackSelectionDiscontinuity() {
-    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
+    MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
     while (periodHolder != null) {
       TrackSelection[] trackSelections = periodHolder.getTrackSelectorResult().selections.getAll();
       for (TrackSelection trackSelection : trackSelections) {
@@ -1230,12 +1250,10 @@ private boolean shouldTransitionToReadyState(boolean renderersReadyOrEnded) {
 
   private boolean isTimelineReady() {
     MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
-    MediaPeriodHolder nextPeriodHolder = playingPeriodHolder.getNext();
     long playingPeriodDurationUs = playingPeriodHolder.info.durationUs;
-    return playingPeriodDurationUs == C.TIME_UNSET
-        || playbackInfo.positionUs < playingPeriodDurationUs
-        || (nextPeriodHolder != null
-            && (nextPeriodHolder.prepared || nextPeriodHolder.info.id.isAd()));
+    return playingPeriodHolder.prepared
+        && (playingPeriodDurationUs == C.TIME_UNSET
+            || playbackInfo.positionUs < playingPeriodDurationUs);
   }
 
   private void maybeThrowSourceInfoRefreshError() throws IOException {
@@ -1251,21 +1269,6 @@ private void maybeThrowSourceInfoRefreshError() throws IOException {
     mediaSource.maybeThrowSourceInfoRefreshError();
   }
 
-  private void maybeThrowPeriodPrepareError() throws IOException {
-    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
-    if (loadingPeriodHolder != null
-        && !loadingPeriodHolder.prepared
-        && (readingPeriodHolder == null || readingPeriodHolder.getNext() == loadingPeriodHolder)) {
-      for (Renderer renderer : enabledRenderers) {
-        if (!renderer.hasReadStreamToEnd()) {
-          return;
-        }
-      }
-      loadingPeriodHolder.mediaPeriod.maybeThrowPrepareError();
-    }
-  }
-
   private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       throws ExoPlaybackException {
     if (sourceRefreshInfo.source != mediaSource) {
@@ -1335,7 +1338,7 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       }
     } else {
       // Something changed. Seek to new start position.
-      MediaPeriodHolder periodHolder = queue.getFrontPeriod();
+      MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
       if (periodHolder != null) {
         // Update the new playing media period info if it already exists.
         while (periodHolder.getNext() != null) {
@@ -1361,6 +1364,9 @@ private long getMaxRendererReadPositionUs() {
       return 0;
     }
     long maxReadPositionUs = readingHolder.getRendererOffset();
+    if (!readingHolder.prepared) {
+      return maxReadPositionUs;
+    }
     for (int i = 0; i < renderers.length; i++) {
       if (renderers[i].getState() == Renderer.STATE_DISABLED
           || renderers[i].getStream() != readingHolder.sampleStreams[i]) {
@@ -1384,7 +1390,8 @@ private void handleSourceInfoRefreshEndedPlayback() {
         /* resetRenderers= */ false,
         /* releaseMediaSource= */ false,
         /* resetPosition= */ true,
-        /* resetState= */ false);
+        /* resetState= */ false,
+        /* resetError= */ true);
   }
 
   /**
@@ -1494,23 +1501,26 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     maybeUpdatePlayingPeriod();
   }
 
-  private void maybeUpdateLoadingPeriod() throws IOException {
+  private void maybeUpdateLoadingPeriod() throws ExoPlaybackException, IOException {
     queue.reevaluateBuffer(rendererPositionUs);
     if (queue.shouldLoadNextMediaPeriod()) {
       MediaPeriodInfo info = queue.getNextMediaPeriodInfo(rendererPositionUs, playbackInfo);
       if (info == null) {
         maybeThrowSourceInfoRefreshError();
       } else {
-        MediaPeriod mediaPeriod =
-            queue.enqueueNextMediaPeriod(
+        MediaPeriodHolder mediaPeriodHolder =
+            queue.enqueueNextMediaPeriodHolder(
                 rendererCapabilities,
                 trackSelector,
                 loadControl.getAllocator(),
                 mediaSource,
                 info,
                 emptyTrackSelectorResult);
-        mediaPeriod.prepare(this, info.startPositionUs);
+        mediaPeriodHolder.mediaPeriod.prepare(this, info.startPositionUs);
         setIsLoading(true);
+        if (queue.getPlayingPeriod() == mediaPeriodHolder) {
+          resetRendererPosition(mediaPeriodHolder.getStartPositionRendererTime());
+        }
         handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
       }
     }
@@ -1522,7 +1532,7 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     }
   }
 
-  private void maybeUpdateReadingPeriod() throws ExoPlaybackException, IOException {
+  private void maybeUpdateReadingPeriod() throws ExoPlaybackException {
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     if (readingPeriodHolder == null) {
       return;
@@ -1552,7 +1562,6 @@ private void maybeUpdateReadingPeriod() throws ExoPlaybackException, IOException
 
     if (!readingPeriodHolder.getNext().prepared) {
       // The successor is not prepared yet.
-      maybeThrowPeriodPrepareError();
       return;
     }
 
@@ -1607,6 +1616,11 @@ private void maybeUpdatePlayingPeriod() throws ExoPlaybackException {
         maybeNotifyPlaybackInfoChanged();
       }
       MediaPeriodHolder oldPlayingPeriodHolder = queue.getPlayingPeriod();
+      if (oldPlayingPeriodHolder == queue.getReadingPeriod()) {
+        // The reading period hasn't advanced yet, so we can't seamlessly replace the SampleStreams
+        // anymore and need to re-enable the renderers. Set all current streams final to do that.
+        setAllRendererStreamsFinal();
+      }
       MediaPeriodHolder newPlayingPeriodHolder = queue.advancePlayingPeriod();
       updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
       playbackInfo =
@@ -1633,17 +1647,22 @@ private boolean shouldAdvancePlayingPeriod() {
     if (playingPeriodHolder == null) {
       return false;
     }
+    MediaPeriodHolder nextPlayingPeriodHolder = playingPeriodHolder.getNext();
+    if (nextPlayingPeriodHolder == null) {
+      return false;
+    }
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
-    if (playingPeriodHolder == readingPeriodHolder) {
+    if (playingPeriodHolder == readingPeriodHolder && !hasReadingPeriodFinishedReading()) {
       return false;
     }
-    MediaPeriodHolder nextPlayingPeriodHolder =
-        Assertions.checkNotNull(playingPeriodHolder.getNext());
     return rendererPositionUs >= nextPlayingPeriodHolder.getStartPositionRendererTime();
   }
 
   private boolean hasReadingPeriodFinishedReading() {
     MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
+    if (!readingPeriodHolder.prepared) {
+      return false;
+    }
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
@@ -1674,10 +1693,9 @@ private void handlePeriodPrepared(MediaPeriod mediaPeriod) throws ExoPlaybackExc
         mediaClock.getPlaybackParameters().speed, playbackInfo.timeline);
     updateLoadControlTrackSelection(
         loadingPeriodHolder.getTrackGroups(), loadingPeriodHolder.getTrackSelectorResult());
-    if (!queue.hasPlayingPeriod()) {
-      // This is the first prepared period, so start playing it.
-      MediaPeriodHolder playingPeriodHolder = queue.advancePlayingPeriod();
-      resetRendererPosition(playingPeriodHolder.info.startPositionUs);
+    if (loadingPeriodHolder == queue.getPlayingPeriod()) {
+      // This is the first prepared period, so update the position and the renderers.
+      resetRendererPosition(loadingPeriodHolder.info.startPositionUs);
       updatePlayingPeriodRenderers(/* oldPlayingPeriodHolder= */ null);
     }
     maybeContinueLoading();
@@ -1805,12 +1823,6 @@ private void enableRenderer(
     }
   }
 
-  private boolean rendererWaitingForNextStream(Renderer renderer) {
-    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
-    MediaPeriodHolder nextPeriodHolder = readingPeriodHolder.getNext();
-    return nextPeriodHolder != null && nextPeriodHolder.prepared && renderer.hasReadStreamToEnd();
-  }
-
   private void handleLoadingMediaPeriodChanged(boolean loadingTrackSelectionChanged) {
     MediaPeriodHolder loadingMediaPeriodHolder = queue.getLoadingPeriod();
     MediaPeriodId loadingMediaPeriodId =
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 0f279ba6d3..e515877d78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -128,8 +128,8 @@ public boolean shouldLoadNextMediaPeriod() {
   }
 
   /**
-   * Enqueues a new media period based on the specified information as the new loading media period,
-   * and returns it.
+   * Enqueues a new media period holder based on the specified information as the new loading media
+   * period, and returns it.
    *
    * @param rendererCapabilities The renderer capabilities.
    * @param trackSelector The track selector.
@@ -139,7 +139,7 @@ public boolean shouldLoadNextMediaPeriod() {
    * @param emptyTrackSelectorResult A {@link TrackSelectorResult} with empty selections for each
    *     renderer.
    */
-  public MediaPeriod enqueueNextMediaPeriod(
+  public MediaPeriodHolder enqueueNextMediaPeriodHolder(
       RendererCapabilities[] rendererCapabilities,
       TrackSelector trackSelector,
       Allocator allocator,
@@ -162,13 +162,15 @@ public MediaPeriod enqueueNextMediaPeriod(
             info,
             emptyTrackSelectorResult);
     if (loading != null) {
-      Assertions.checkState(hasPlayingPeriod());
       loading.setNext(newPeriodHolder);
+    } else {
+      playing = newPeriodHolder;
+      reading = newPeriodHolder;
     }
     oldFrontPeriodUid = null;
     loading = newPeriodHolder;
     length++;
-    return newPeriodHolder.mediaPeriod;
+    return newPeriodHolder;
   }
 
   /**
@@ -182,36 +184,19 @@ public MediaPeriodHolder getLoadingPeriod() {
 
   /**
    * Returns the playing period holder which is at the front of the queue, or null if the queue is
-   * empty or hasn't started playing.
+   * empty.
    */
   @Nullable
   public MediaPeriodHolder getPlayingPeriod() {
     return playing;
   }
 
-  /**
-   * Returns the reading period holder, or null if the queue is empty or the player hasn't started
-   * reading.
-   */
+  /** Returns the reading period holder, or null if the queue is empty. */
   @Nullable
   public MediaPeriodHolder getReadingPeriod() {
     return reading;
   }
 
-  /**
-   * Returns the period holder in the front of the queue which is the playing period holder when
-   * playing, or null if the queue is empty.
-   */
-  @Nullable
-  public MediaPeriodHolder getFrontPeriod() {
-    return hasPlayingPeriod() ? playing : loading;
-  }
-
-  /** Returns whether the reading and playing period holders are set. */
-  public boolean hasPlayingPeriod() {
-    return playing != null;
-  }
-
   /**
    * Continues reading from the next period holder in the queue.
    *
@@ -225,29 +210,26 @@ public MediaPeriodHolder advanceReadingPeriod() {
 
   /**
    * Dequeues the playing period holder from the front of the queue and advances the playing period
-   * holder to be the next item in the queue. If the playing period holder is unset, set it to the
-   * item in the front of the queue.
+   * holder to be the next item in the queue.
    *
    * @return The updated playing period holder, or null if the queue is or becomes empty.
    */
   @Nullable
   public MediaPeriodHolder advancePlayingPeriod() {
-    if (playing != null) {
-      if (playing == reading) {
-        reading = playing.getNext();
-      }
-      playing.release();
-      length--;
-      if (length == 0) {
-        loading = null;
-        oldFrontPeriodUid = playing.uid;
-        oldFrontPeriodWindowSequenceNumber = playing.info.id.windowSequenceNumber;
-      }
-      playing = playing.getNext();
-    } else {
-      playing = loading;
-      reading = loading;
+    if (playing == null) {
+      return null;
+    }
+    if (playing == reading) {
+      reading = playing.getNext();
+    }
+    playing.release();
+    length--;
+    if (length == 0) {
+      loading = null;
+      oldFrontPeriodUid = playing.uid;
+      oldFrontPeriodWindowSequenceNumber = playing.info.id.windowSequenceNumber;
     }
+    playing = playing.getNext();
     return playing;
   }
 
@@ -283,7 +265,7 @@ public boolean removeAfter(MediaPeriodHolder mediaPeriodHolder) {
    *     of queue (typically the playing one) for later reuse.
    */
   public void clear(boolean keepFrontPeriodUid) {
-    MediaPeriodHolder front = getFrontPeriod();
+    MediaPeriodHolder front = playing;
     if (front != null) {
       oldFrontPeriodUid = keepFrontPeriodUid ? front.uid : null;
       oldFrontPeriodWindowSequenceNumber = front.info.id.windowSequenceNumber;
@@ -315,7 +297,7 @@ public boolean updateQueuedPeriods(long rendererPositionUs, long maxRendererRead
     // is set, once all cases handled by ExoPlayerImplInternal.handleSourceInfoRefreshed can be
     // handled here.
     MediaPeriodHolder previousPeriodHolder = null;
-    MediaPeriodHolder periodHolder = getFrontPeriod();
+    MediaPeriodHolder periodHolder = playing;
     while (periodHolder != null) {
       MediaPeriodInfo oldPeriodInfo = periodHolder.info;
 
@@ -451,7 +433,7 @@ private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
         }
       }
     }
-    MediaPeriodHolder mediaPeriodHolder = getFrontPeriod();
+    MediaPeriodHolder mediaPeriodHolder = playing;
     while (mediaPeriodHolder != null) {
       if (mediaPeriodHolder.uid.equals(periodUid)) {
         // Reuse window sequence number of first exact period match.
@@ -459,7 +441,7 @@ private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
       }
       mediaPeriodHolder = mediaPeriodHolder.getNext();
     }
-    mediaPeriodHolder = getFrontPeriod();
+    mediaPeriodHolder = playing;
     while (mediaPeriodHolder != null) {
       int indexOfHolderInTimeline = timeline.getIndexOfPeriod(mediaPeriodHolder.uid);
       if (indexOfHolderInTimeline != C.INDEX_UNSET) {
@@ -496,7 +478,7 @@ private boolean areDurationsCompatible(long previousDurationUs, long newDuration
    */
   private boolean updateForPlaybackModeChange() {
     // Find the last existing period holder that matches the new period order.
-    MediaPeriodHolder lastValidPeriodHolder = getFrontPeriod();
+    MediaPeriodHolder lastValidPeriodHolder = playing;
     if (lastValidPeriodHolder == null) {
       return true;
     }
@@ -529,7 +511,7 @@ private boolean updateForPlaybackModeChange() {
     lastValidPeriodHolder.info = getUpdatedMediaPeriodInfo(lastValidPeriodHolder.info);
 
     // If renderers may have read from a period that's been removed, it is necessary to restart.
-    return !readingPeriodRemoved || !hasPlayingPeriod();
+    return !readingPeriodRemoved;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index e9b99acd77..9d2a3b5459 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import androidx.annotation.CheckResult;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
@@ -51,6 +52,8 @@
   public final long contentPositionUs;
   /** The current playback state. One of the {@link Player}.STATE_ constants. */
   @Player.State public final int playbackState;
+  /** The current playback error, or null if this is not an error state. */
+  @Nullable public final ExoPlaybackException playbackError;
   /** Whether the player is currently loading. */
   public final boolean isLoading;
   /** The currently available track groups. */
@@ -93,6 +96,7 @@ public static PlaybackInfo createDummy(
         startPositionUs,
         /* contentPositionUs= */ C.TIME_UNSET,
         Player.STATE_IDLE,
+        /* playbackError= */ null,
         /* isLoading= */ false,
         TrackGroupArray.EMPTY,
         emptyTrackSelectorResult,
@@ -124,6 +128,7 @@ public PlaybackInfo(
       long startPositionUs,
       long contentPositionUs,
       @Player.State int playbackState,
+      @Nullable ExoPlaybackException playbackError,
       boolean isLoading,
       TrackGroupArray trackGroups,
       TrackSelectorResult trackSelectorResult,
@@ -136,6 +141,7 @@ public PlaybackInfo(
     this.startPositionUs = startPositionUs;
     this.contentPositionUs = contentPositionUs;
     this.playbackState = playbackState;
+    this.playbackError = playbackError;
     this.isLoading = isLoading;
     this.trackGroups = trackGroups;
     this.trackSelectorResult = trackSelectorResult;
@@ -194,6 +200,7 @@ public PlaybackInfo copyWithNewPosition(
         positionUs,
         periodId.isAd() ? contentPositionUs : C.TIME_UNSET,
         playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
@@ -217,6 +224,7 @@ public PlaybackInfo copyWithTimeline(Timeline timeline) {
         startPositionUs,
         contentPositionUs,
         playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
@@ -240,6 +248,31 @@ public PlaybackInfo copyWithPlaybackState(int playbackState) {
         startPositionUs,
         contentPositionUs,
         playbackState,
+        playbackError,
+        isLoading,
+        trackGroups,
+        trackSelectorResult,
+        loadingMediaPeriodId,
+        bufferedPositionUs,
+        totalBufferedDurationUs,
+        positionUs);
+  }
+
+  /**
+   * Copies playback info with a playback error.
+   *
+   * @param playbackError The error. See {@link #playbackError}.
+   * @return Copied playback info with the playback error.
+   */
+  @CheckResult
+  public PlaybackInfo copyWithPlaybackError(@Nullable ExoPlaybackException playbackError) {
+    return new PlaybackInfo(
+        timeline,
+        periodId,
+        startPositionUs,
+        contentPositionUs,
+        playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
@@ -263,6 +296,7 @@ public PlaybackInfo copyWithIsLoading(boolean isLoading) {
         startPositionUs,
         contentPositionUs,
         playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
@@ -288,6 +322,7 @@ public PlaybackInfo copyWithTrackInfo(
         startPositionUs,
         contentPositionUs,
         playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
@@ -311,6 +346,7 @@ public PlaybackInfo copyWithLoadingMediaPeriodId(MediaPeriodId loadingMediaPerio
         startPositionUs,
         contentPositionUs,
         playbackState,
+        playbackError,
         isLoading,
         trackGroups,
         trackSelectorResult,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 9606cc0d48..b5956c9dae 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -95,6 +95,7 @@
     private BandwidthMeter bandwidthMeter;
     private AnalyticsCollector analyticsCollector;
     private Looper looper;
+    private boolean useLazyPreparation;
     private boolean buildCalled;
 
     /**
@@ -115,6 +116,7 @@
      *       Looper} of the application's main thread if the current thread doesn't have a {@link
      *       Looper}
      *   <li>{@link AnalyticsCollector}: {@link AnalyticsCollector} with {@link Clock#DEFAULT}
+     *   <li>{@code useLazyPreparation}: {@code true}
      *   <li>{@link Clock}: {@link Clock#DEFAULT}
      * </ul>
      *
@@ -142,6 +144,7 @@ public Builder(Context context, RenderersFactory renderersFactory) {
           DefaultBandwidthMeter.getSingletonInstance(context),
           Util.getLooper(),
           new AnalyticsCollector(Clock.DEFAULT),
+          /* useLazyPreparation= */ true,
           Clock.DEFAULT);
     }
 
@@ -160,6 +163,7 @@ public Builder(Context context, RenderersFactory renderersFactory) {
      * @param bandwidthMeter A {@link BandwidthMeter}.
      * @param looper A {@link Looper} that must be used for all calls to the player.
      * @param analyticsCollector An {@link AnalyticsCollector}.
+     * @param useLazyPreparation Whether media sources should be initialized lazily.
      * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
      */
     public Builder(
@@ -170,6 +174,7 @@ public Builder(
         BandwidthMeter bandwidthMeter,
         Looper looper,
         AnalyticsCollector analyticsCollector,
+        boolean useLazyPreparation,
         Clock clock) {
       this.context = context;
       this.renderersFactory = renderersFactory;
@@ -178,6 +183,7 @@ public Builder(
       this.bandwidthMeter = bandwidthMeter;
       this.looper = looper;
       this.analyticsCollector = analyticsCollector;
+      this.useLazyPreparation = useLazyPreparation;
       this.clock = clock;
     }
 
@@ -247,6 +253,23 @@ public Builder setAnalyticsCollector(AnalyticsCollector analyticsCollector) {
       return this;
     }
 
+    /**
+     * Sets whether media sources should be initialized lazily.
+     *
+     * <p>If false, all initial preparation steps (e.g., manifest loads) happen immediately. If
+     * true, these initial preparations are triggered only when the player starts buffering the
+     * media.
+     *
+     * @param useLazyPreparation Whether to use lazy preparation.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setUseLazyPreparation(boolean useLazyPreparation) {
+      Assertions.checkState(!buildCalled);
+      this.useLazyPreparation = useLazyPreparation;
+      return this;
+    }
+
     /**
      * Sets the {@link Clock} that will be used by the player. Should only be set for testing
      * purposes.
@@ -324,78 +347,6 @@ public SimpleExoPlayer build() {
   @Nullable private PriorityTaskManager priorityTaskManager;
   private boolean isPriorityTaskManagerRegistered;
 
-  /**
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
-   * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
-   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
-   *     DrmSessionManager} to the {@link MediaSource} factories.
-   */
-  @Deprecated
-  protected SimpleExoPlayer(
-      Context context,
-      RenderersFactory renderersFactory,
-      TrackSelector trackSelector,
-      LoadControl loadControl,
-      BandwidthMeter bandwidthMeter,
-      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      Looper looper) {
-    this(
-        context,
-        renderersFactory,
-        trackSelector,
-        loadControl,
-        drmSessionManager,
-        bandwidthMeter,
-        new AnalyticsCollector(Clock.DEFAULT),
-        looper);
-  }
-
-  /**
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
-   *     player events.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
-   * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
-   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
-   *     DrmSessionManager} to the {@link MediaSource} factories.
-   */
-  @Deprecated
-  protected SimpleExoPlayer(
-      Context context,
-      RenderersFactory renderersFactory,
-      TrackSelector trackSelector,
-      LoadControl loadControl,
-      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      BandwidthMeter bandwidthMeter,
-      AnalyticsCollector analyticsCollector,
-      Looper looper) {
-    this(
-        context,
-        renderersFactory,
-        trackSelector,
-        loadControl,
-        drmSessionManager,
-        bandwidthMeter,
-        analyticsCollector,
-        Clock.DEFAULT,
-        looper);
-  }
-
   /**
    * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 32fa3a6e4b..57d3d8bf1d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -26,96 +26,92 @@
  * complex compositions of media such as playlists and streams with inserted ads. Instances are
  * immutable. For cases where media is changing dynamically (e.g. live streams), a timeline provides
  * a snapshot of the current state.
- * <p>
- * A timeline consists of related {@link Period}s and {@link Window}s. A period defines a single
- * logical piece of media, for example a media file. It may also define groups of ads inserted into
- * the media, along with information about whether those ads have been loaded and played. A window
- * spans one or more periods, defining the region within those periods that's currently available
- * for playback along with additional information such as whether seeking is supported within the
- * window. Each window defines a default position, which is the position from which playback will
- * start when the player starts playing the window. The following examples illustrate timelines for
- * various use cases.
+ *
+ * <p>A timeline consists of {@link Window Windows} and {@link Period Periods}.
+ *
+ * <ul>
+ *   <li>A {@link Window} usually corresponds to one playlist item. It may span one or more periods
+ *       and it defines the region within those periods that's currently available for playback. The
+ *       window also provides additional information such as whether seeking is supported within the
+ *       window and the default position, which is the position from which playback will start when
+ *       the player starts playing the window.
+ *   <li>A {@link Period} defines a single logical piece of media, for example a media file. It may
+ *       also define groups of ads inserted into the media, along with information about whether
+ *       those ads have been loaded and played.
+ * </ul>
+ *
+ * <p>The following examples illustrate timelines for various use cases.
  *
  * <h3 id="single-file">Single media file or on-demand stream</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-single-file.svg" alt="Example timeline for a single file">
- * </p>
- * A timeline for a single media file or on-demand stream consists of a single period and window.
- * The window spans the whole period, indicating that all parts of the media are available for
- * playback. The window's default position is typically at the start of the period (indicated by the
- * black dot in the figure above).
+ *
+ * <p align="center"><img src="doc-files/timeline-single-file.svg" alt="Example timeline for a
+ * single file"> A timeline for a single media file or on-demand stream consists of a single period
+ * and window. The window spans the whole period, indicating that all parts of the media are
+ * available for playback. The window's default position is typically at the start of the period
+ * (indicated by the black dot in the figure above).
  *
  * <h3>Playlist of media files or on-demand streams</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-playlist.svg" alt="Example timeline for a playlist of files">
- * </p>
- * A timeline for a playlist of media files or on-demand streams consists of multiple periods, each
- * with its own window. Each window spans the whole of the corresponding period, and typically has a
- * default position at the start of the period. The properties of the periods and windows (e.g.
- * their durations and whether the window is seekable) will often only become known when the player
- * starts buffering the corresponding file or stream.
+ *
+ * <p align="center"><img src="doc-files/timeline-playlist.svg" alt="Example timeline for a playlist
+ * of files"> A timeline for a playlist of media files or on-demand streams consists of multiple
+ * periods, each with its own window. Each window spans the whole of the corresponding period, and
+ * typically has a default position at the start of the period. The properties of the periods and
+ * windows (e.g. their durations and whether the window is seekable) will often only become known
+ * when the player starts buffering the corresponding file or stream.
  *
  * <h3 id="live-limited">Live stream with limited availability</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-live-limited.svg" alt="Example timeline for a live stream with
- *       limited availability">
- * </p>
- * A timeline for a live stream consists of a period whose duration is unknown, since it's
- * continually extending as more content is broadcast. If content only remains available for a
- * limited period of time then the window may start at a non-zero position, defining the region of
- * content that can still be played. The window will have {@link Window#isDynamic} set to true if
- * the stream is still live. Its default position is typically near to the live edge (indicated by
- * the black dot in the figure above).
+ *
+ * <p align="center"><img src="doc-files/timeline-live-limited.svg" alt="Example timeline for a live
+ * stream with limited availability"> A timeline for a live stream consists of a period whose
+ * duration is unknown, since it's continually extending as more content is broadcast. If content
+ * only remains available for a limited period of time then the window may start at a non-zero
+ * position, defining the region of content that can still be played. The window will have {@link
+ * Window#isDynamic} set to true if the stream is still live. Its default position is typically near
+ * to the live edge (indicated by the black dot in the figure above).
  *
  * <h3>Live stream with indefinite availability</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-live-indefinite.svg" alt="Example timeline for a live stream with
- *       indefinite availability">
- * </p>
- * A timeline for a live stream with indefinite availability is similar to the
- * <a href="#live-limited">Live stream with limited availability</a> case, except that the window
- * starts at the beginning of the period to indicate that all of the previously broadcast content
- * can still be played.
+ *
+ * <p align="center"><img src="doc-files/timeline-live-indefinite.svg" alt="Example timeline for a
+ * live stream with indefinite availability"> A timeline for a live stream with indefinite
+ * availability is similar to the <a href="#live-limited">Live stream with limited availability</a>
+ * case, except that the window starts at the beginning of the period to indicate that all of the
+ * previously broadcast content can still be played.
  *
  * <h3 id="live-multi-period">Live stream with multiple periods</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-live-multi-period.svg" alt="Example timeline for a live stream
- *       with multiple periods">
- * </p>
- * This case arises when a live stream is explicitly divided into separate periods, for example at
- * content boundaries. This case is similar to the <a href="#live-limited">Live stream with limited
- * availability</a> case, except that the window may span more than one period. Multiple periods are
- * also possible in the indefinite availability case.
+ *
+ * <p align="center"><img src="doc-files/timeline-live-multi-period.svg" alt="Example timeline for a
+ * live stream with multiple periods"> This case arises when a live stream is explicitly divided
+ * into separate periods, for example at content boundaries. This case is similar to the <a
+ * href="#live-limited">Live stream with limited availability</a> case, except that the window may
+ * span more than one period. Multiple periods are also possible in the indefinite availability
+ * case.
  *
  * <h3>On-demand stream followed by live stream</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-advanced.svg" alt="Example timeline for an on-demand stream
- *       followed by a live stream">
- * </p>
- * This case is the concatenation of the <a href="#single-file">Single media file or on-demand
- * stream</a> and <a href="#multi-period">Live stream with multiple periods</a> cases. When playback
- * of the on-demand stream ends, playback of the live stream will start from its default position
- * near the live edge.
+ *
+ * <p align="center"><img src="doc-files/timeline-advanced.svg" alt="Example timeline for an
+ * on-demand stream followed by a live stream"> This case is the concatenation of the <a
+ * href="#single-file">Single media file or on-demand stream</a> and <a href="#multi-period">Live
+ * stream with multiple periods</a> cases. When playback of the on-demand stream ends, playback of
+ * the live stream will start from its default position near the live edge.
  *
  * <h3 id="single-file-midrolls">On-demand stream with mid-roll ads</h3>
- * <p align="center">
- *   <img src="doc-files/timeline-single-file-midrolls.svg" alt="Example timeline for an on-demand
- *       stream with mid-roll ad groups">
- * </p>
- * This case includes mid-roll ad groups, which are defined as part of the timeline's single period.
- * The period can be queried for information about the ad groups and the ads they contain.
+ *
+ * <p align="center"><img src="doc-files/timeline-single-file-midrolls.svg" alt="Example timeline
+ * for an on-demand stream with mid-roll ad groups"> This case includes mid-roll ad groups, which
+ * are defined as part of the timeline's single period. The period can be queried for information
+ * about the ad groups and the ads they contain.
  */
 public abstract class Timeline {
 
   /**
-   * Holds information about a window in a {@link Timeline}. A window defines a region of media
-   * currently available for playback along with additional information such as whether seeking is
-   * supported within the window. The figure below shows some of the information defined by a
-   * window, as well as how this information relates to corresponding {@link Period}s in the
-   * timeline.
-   * <p align="center">
-   *   <img src="doc-files/timeline-window.svg" alt="Information defined by a timeline window">
-   * </p>
+   * Holds information about a window in a {@link Timeline}. A window usually corresponds to one
+   * playlist item and defines a region of media currently available for playback along with
+   * additional information such as whether seeking is supported within the window. The figure below
+   * shows some of the information defined by a window, as well as how this information relates to
+   * corresponding {@link Period Periods} in the timeline.
+   *
+   * <p align="center"><img src="doc-files/timeline-window.svg" alt="Information defined by a
+   * timeline window">
    */
   public static final class Window {
 
@@ -524,8 +520,7 @@ public int getWindowCount() {
         }
 
         @Override
-        public Window getWindow(
-            int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+        public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
           throw new IndexOutOfBoundsException();
         }
 
@@ -637,28 +632,20 @@ public int getFirstWindowIndex(boolean shuffleModeEnabled) {
   }
 
   /**
-   * Populates a {@link Window} with data for the window at the specified index. Does not populate
-   * {@link Window#tag}.
+   * Populates a {@link Window} with data for the window at the specified index.
    *
    * @param windowIndex The index of the window.
    * @param window The {@link Window} to populate. Must not be null.
    * @return The populated {@link Window}, for convenience.
    */
   public final Window getWindow(int windowIndex, Window window) {
-    return getWindow(windowIndex, window, false);
+    return getWindow(windowIndex, window, /* defaultPositionProjectionUs= */ 0);
   }
 
-  /**
-   * Populates a {@link Window} with data for the window at the specified index.
-   *
-   * @param windowIndex The index of the window.
-   * @param window The {@link Window} to populate. Must not be null.
-   * @param setTag Whether {@link Window#tag} should be populated. If false, the field will be set
-   *     to null. The caller should pass false for efficiency reasons unless the field is required.
-   * @return The populated {@link Window}, for convenience.
-   */
+  /** @deprecated Use {@link #getWindow(int, Window)} instead. Tags will always be set. */
+  @Deprecated
   public final Window getWindow(int windowIndex, Window window, boolean setTag) {
-    return getWindow(windowIndex, window, setTag, 0);
+    return getWindow(windowIndex, window, /* defaultPositionProjectionUs= */ 0);
   }
 
   /**
@@ -666,14 +653,21 @@ public final Window getWindow(int windowIndex, Window window, boolean setTag) {
    *
    * @param windowIndex The index of the window.
    * @param window The {@link Window} to populate. Must not be null.
-   * @param setTag Whether {@link Window#tag} should be populated. If false, the field will be set
-   *     to null. The caller should pass false for efficiency reasons unless the field is required.
    * @param defaultPositionProjectionUs A duration into the future that the populated window's
    *     default start position should be projected.
    * @return The populated {@link Window}, for convenience.
    */
-  public abstract Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs);
+  @SuppressWarnings("deprecation")
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+    return getWindow(windowIndex, window, /* setTag= */ true, defaultPositionProjectionUs);
+  }
+
+  /** @deprecated Implement {@link #getWindow(int, Window, long)} instead and always set the tag. */
+  @Deprecated
+  public Window getWindow(
+      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+    return getWindow(windowIndex, window, defaultPositionProjectionUs);
+  }
 
   /**
    * Returns the number of periods in the timeline.
@@ -754,7 +748,7 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
       long windowPositionUs,
       long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, getWindowCount());
-    getWindow(windowIndex, window, false, defaultPositionProjectionUs);
+    getWindow(windowIndex, window, defaultPositionProjectionUs);
     if (windowPositionUs == C.TIME_UNSET) {
       windowPositionUs = window.getDefaultPositionUs();
       if (windowPositionUs == C.TIME_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 825424ae04..1ccd4ffc84 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -465,10 +465,7 @@ public final void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
 
   @Override
   public final void onPlayerError(ExoPlaybackException error) {
-    EventTime eventTime =
-        error.type == ExoPlaybackException.TYPE_SOURCE
-            ? generateLoadingMediaPeriodEventTime()
-            : generatePlayingMediaPeriodEventTime();
+    EventTime eventTime = generateLastReportedPlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
       listener.onPlayerError(eventTime, error);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index b4e0058982..65d997396b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -37,7 +37,6 @@
 import java.nio.ByteOrder;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 
 /**
@@ -122,7 +121,15 @@ private InvalidAudioTrackTimestampException(String message) {
      * audioProcessors} applied before silence skipping and playback parameters.
      */
     public DefaultAudioProcessorChain(AudioProcessor... audioProcessors) {
-      this.audioProcessors = Arrays.copyOf(audioProcessors, audioProcessors.length + 2);
+      // The passed-in type may be more specialized than AudioProcessor[], so allocate a new array
+      // rather than using Arrays.copyOf.
+      this.audioProcessors = new AudioProcessor[audioProcessors.length + 2];
+      System.arraycopy(
+          /* src= */ audioProcessors,
+          /* srcPos= */ 0,
+          /* dest= */ this.audioProcessors,
+          /* destPos= */ 0,
+          /* length= */ audioProcessors.length);
       silenceSkippingAudioProcessor = new SilenceSkippingAudioProcessor();
       sonicAudioProcessor = new SonicAudioProcessor();
       this.audioProcessors[audioProcessors.length] = silenceSkippingAudioProcessor;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
index 773959fbfc..8fd25f2cf9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
@@ -53,6 +53,11 @@ public final boolean isKeyFrame() {
     return getFlag(C.BUFFER_FLAG_KEY_FRAME);
   }
 
+  /** Returns whether the {@link C#BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA} flag is set. */
+  public final boolean hasSupplementalData() {
+    return getFlag(C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA);
+  }
+
   /**
    * Replaces this buffer's flags with {@code flags}.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index c31ae92cfc..7a19d85aa8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -68,6 +68,12 @@
    */
   public long timeUs;
 
+  /**
+   * Supplemental data related to the buffer, if {@link #hasSupplementalData()} returns true. If
+   * present, the buffer is populated with supplemental data from position 0 to its limit.
+   */
+  @Nullable public ByteBuffer supplementalData;
+
   @BufferReplacementMode private final int bufferReplacementMode;
 
   /**
@@ -89,6 +95,16 @@ public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
     this.bufferReplacementMode = bufferReplacementMode;
   }
 
+  /** Resets {@link #supplementalData} in preparation for storing {@code length} bytes. */
+  @EnsuresNonNull("supplementalData")
+  public void resetSupplementalData(int length) {
+    if (supplementalData == null || supplementalData.capacity() < length) {
+      supplementalData = ByteBuffer.allocate(length);
+    }
+    supplementalData.position(0);
+    supplementalData.limit(length);
+  }
+
   /**
    * Ensures that {@link #data} is large enough to accommodate a write of a given length at its
    * current position.
@@ -148,6 +164,9 @@ public final boolean isEncrypted() {
    */
   public final void flip() {
     data.flip();
+    if (supplementalData != null) {
+      supplementalData.flip();
+    }
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index b7465f82eb..03aabecb0e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.decoder;
 
+import androidx.annotation.CallSuper;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
@@ -125,6 +126,7 @@ public final O dequeueOutputBuffer() throws E {
    *
    * @param outputBuffer The output buffer being released.
    */
+  @CallSuper
   protected void releaseOutputBuffer(O outputBuffer) {
     synchronized (lock) {
       releaseOutputBufferInternal(outputBuffer);
@@ -150,6 +152,7 @@ public final void flush() {
     }
   }
 
+  @CallSuper
   @Override
   public void release() {
     synchronized (lock) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index c785865f6a..e4f42fcf91 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -149,6 +149,10 @@
   private static final int ID_BLOCK_GROUP = 0xA0;
   private static final int ID_BLOCK = 0xA1;
   private static final int ID_BLOCK_DURATION = 0x9B;
+  private static final int ID_BLOCK_ADDITIONS = 0x75A1;
+  private static final int ID_BLOCK_MORE = 0xA6;
+  private static final int ID_BLOCK_ADD_ID = 0xEE;
+  private static final int ID_BLOCK_ADDITIONAL = 0xA5;
   private static final int ID_REFERENCE_BLOCK = 0xFB;
   private static final int ID_TRACKS = 0x1654AE6B;
   private static final int ID_TRACK_ENTRY = 0xAE;
@@ -157,6 +161,7 @@
   private static final int ID_FLAG_DEFAULT = 0x88;
   private static final int ID_FLAG_FORCED = 0x55AA;
   private static final int ID_DEFAULT_DURATION = 0x23E383;
+  private static final int ID_MAX_BLOCK_ADDITION_ID = 0x55EE;
   private static final int ID_NAME = 0x536E;
   private static final int ID_CODEC_ID = 0x86;
   private static final int ID_CODEC_PRIVATE = 0x63A2;
@@ -215,6 +220,12 @@
   private static final int ID_LUMNINANCE_MAX = 0x55D9;
   private static final int ID_LUMNINANCE_MIN = 0x55DA;
 
+  /**
+   * BlockAddID value for ITU T.35 metadata in a VP9 track. See also
+   * https://www.webmproject.org/docs/container/.
+   */
+  private static final int BLOCK_ADD_ID_VP9_ITU_T_35 = 4;
+
   private static final int LACING_NONE = 0;
   private static final int LACING_XIPH = 1;
   private static final int LACING_FIXED_SIZE = 2;
@@ -323,6 +334,7 @@
   private final ParsableByteArray subtitleSample;
   private final ParsableByteArray encryptionInitializationVector;
   private final ParsableByteArray encryptionSubsampleData;
+  private final ParsableByteArray blockAddData;
   private ByteBuffer encryptionSubsampleDataBuffer;
 
   private long segmentContentSize;
@@ -361,6 +373,7 @@
   private int blockTrackNumberLength;
   @C.BufferFlags
   private int blockFlags;
+  private int blockAddId;
 
   // Sample reading state.
   private int sampleBytesRead;
@@ -401,6 +414,7 @@ public MatroskaExtractor(@Flags int flags) {
     subtitleSample = new ParsableByteArray();
     encryptionInitializationVector = new ParsableByteArray(ENCRYPTION_IV_SIZE);
     encryptionSubsampleData = new ParsableByteArray();
+    blockAddData = new ParsableByteArray();
   }
 
   @Override
@@ -479,6 +493,8 @@ protected int getElementType(int id) {
       case ID_CUE_POINT:
       case ID_CUE_TRACK_POSITIONS:
       case ID_BLOCK_GROUP:
+      case ID_BLOCK_ADDITIONS:
+      case ID_BLOCK_MORE:
       case ID_PROJECTION:
       case ID_COLOUR:
       case ID_MASTERING_METADATA:
@@ -499,6 +515,7 @@ protected int getElementType(int id) {
       case ID_FLAG_DEFAULT:
       case ID_FLAG_FORCED:
       case ID_DEFAULT_DURATION:
+      case ID_MAX_BLOCK_ADDITION_ID:
       case ID_CODEC_DELAY:
       case ID_SEEK_PRE_ROLL:
       case ID_CHANNELS:
@@ -518,6 +535,7 @@ protected int getElementType(int id) {
       case ID_MAX_CLL:
       case ID_MAX_FALL:
       case ID_PROJECTION_TYPE:
+      case ID_BLOCK_ADD_ID:
         return EbmlProcessor.ELEMENT_TYPE_UNSIGNED_INT;
       case ID_DOC_TYPE:
       case ID_NAME:
@@ -531,6 +549,7 @@ protected int getElementType(int id) {
       case ID_BLOCK:
       case ID_CODEC_PRIVATE:
       case ID_PROJECTION_PRIVATE:
+      case ID_BLOCK_ADDITIONAL:
         return EbmlProcessor.ELEMENT_TYPE_BINARY;
       case ID_DURATION:
       case ID_SAMPLING_FREQUENCY:
@@ -760,6 +779,9 @@ protected void integerElement(int id, long value) throws ParserException {
       case ID_DEFAULT_DURATION:
         currentTrack.defaultSampleDurationNs = (int) value;
         break;
+      case ID_MAX_BLOCK_ADDITION_ID:
+        currentTrack.maxBlockAdditionId = (int) value;
+        break;
       case ID_CODEC_DELAY:
         currentTrack.codecDelayNs = value;
         break;
@@ -914,6 +936,9 @@ protected void integerElement(int id, long value) throws ParserException {
             break;
         }
         break;
+      case ID_BLOCK_ADD_ID:
+        blockAddId = (int) value;
+        break;
       default:
         break;
     }
@@ -1171,12 +1196,30 @@ protected void binaryElement(int id, int contentSize, ExtractorInput input)
           writeSampleData(input, track, blockLacingSampleSizes[0]);
         }
 
+        break;
+      case ID_BLOCK_ADDITIONAL:
+        if (blockState != BLOCK_STATE_DATA) {
+          return;
+        }
+        handleBlockAdditionalData(tracks.get(blockTrackNumber), blockAddId, input, contentSize);
         break;
       default:
         throw new ParserException("Unexpected id: " + id);
     }
   }
 
+  protected void handleBlockAdditionalData(
+      Track track, int blockAddId, ExtractorInput input, int contentSize)
+      throws IOException, InterruptedException {
+    if (blockAddId == BLOCK_ADD_ID_VP9_ITU_T_35 && CODEC_ID_VP9.equals(track.codecId)) {
+      blockAddData.reset(contentSize);
+      input.readFully(blockAddData.data, 0, contentSize);
+    } else {
+      // Unhandled block additional data.
+      input.skipFully(contentSize);
+    }
+  }
+
   private void commitSampleToOutput(Track track, long timeUs) {
     if (track.trueHdSampleRechunker != null) {
       track.trueHdSampleRechunker.sampleMetadata(track, timeUs);
@@ -1196,6 +1239,12 @@ private void commitSampleToOutput(Track track, long timeUs) {
             SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR,
             SSA_TIMECODE_EMPTY);
       }
+      if ((blockFlags & C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA) != 0) {
+        // Append supplemental data.
+        int size = blockAddData.limit();
+        track.output.sampleData(blockAddData, size);
+        sampleBytesWritten += size;
+      }
       track.output.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, track.cryptoData);
     }
     sampleRead = true;
@@ -1328,6 +1377,21 @@ private void writeSampleData(ExtractorInput input, Track track, int size)
         // If the sample has header stripping, prepare to read/output the stripped bytes first.
         sampleStrippedBytes.reset(track.sampleStrippedBytes, track.sampleStrippedBytes.length);
       }
+
+      if (track.maxBlockAdditionId > 0) {
+        blockFlags |= C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA;
+        blockAddData.reset();
+        // If there is supplemental data, the structure of the sample data is:
+        // sample size (4 bytes) || sample data || supplemental data
+        scratch.reset(/* limit= */ 4);
+        scratch.data[0] = (byte) ((size >> 24) & 0xFF);
+        scratch.data[1] = (byte) ((size >> 16) & 0xFF);
+        scratch.data[2] = (byte) ((size >> 8) & 0xFF);
+        scratch.data[3] = (byte) (size & 0xFF);
+        output.sampleData(scratch, 4);
+        sampleBytesWritten += 4;
+      }
+
       sampleEncodingHandled = true;
     }
     size += sampleStrippedBytes.limit();
@@ -1713,6 +1777,7 @@ public void outputPendingSampleMetadata(Track track) {
     public int number;
     public int type;
     public int defaultSampleDurationNs;
+    public int maxBlockAdditionId;
     public boolean hasContentEncryption;
     public byte[] sampleStrippedBytes;
     public TrackOutput.CryptoData cryptoData;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index d07def1894..c700259b13 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -264,6 +264,18 @@ public boolean isCodecSupported(Format format) {
     return false;
   }
 
+  /** Whether the codec handles HDR10+ out-of-band metadata. */
+  public boolean isHdr10PlusOutOfBandMetadataSupported() {
+    if (Util.SDK_INT >= 29 && MimeTypes.VIDEO_VP9.equals(mimeType)) {
+      for (CodecProfileLevel capabilities : getProfileLevels()) {
+        if (capabilities.profile == CodecProfileLevel.VP9Profile2HDR10Plus) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
   /**
    * Returns whether it may be possible to adapt to playing a different format when the codec is
    * configured to play media in the specified {@code format}. For adaptation to succeed, the codec
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index ee2c9ad1a3..c077d8d227 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -1140,6 +1140,9 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
           Math.max(largestQueuedPresentationTimeUs, presentationTimeUs);
 
       buffer.flip();
+      if (buffer.hasSupplementalData()) {
+        handleInputBufferSupplementalData(buffer);
+      }
       onQueueInputBuffer(buffer);
 
       if (bufferEncrypted) {
@@ -1297,10 +1300,23 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     // Do nothing.
   }
 
+  /**
+   * Handles supplemental data associated with an input buffer.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param buffer The input buffer that is about to be queued.
+   * @throws ExoPlaybackException Thrown if an error occurs handling supplemental data.
+   */
+  protected void handleInputBufferSupplementalData(DecoderInputBuffer buffer)
+      throws ExoPlaybackException {
+    // Do nothing.
+  }
+
   /**
    * Called immediately before an input buffer is queued into the codec.
-   * <p>
-   * The default implementation is a no-op.
+   *
+   * <p>The default implementation is a no-op.
    *
    * @param buffer The buffer to be queued.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index c9e9d54093..7e3862ca31 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -27,21 +27,36 @@
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
-/**
- * An Event Message (emsg) as defined in ISO 23009-1.
- */
+/** An Event Message (emsg) as defined in ISO 23009-1. */
 public final class EventMessage implements Metadata.Entry {
 
-  @VisibleForTesting
-  public static final String ID3_SCHEME_ID = "https://developer.apple.com/streaming/emsg-id3";
+  /**
+   * emsg scheme_id_uri from the <a href="https://aomediacodec.github.io/av1-id3/#semantics">CMAF
+   * spec</a>.
+   */
+  @VisibleForTesting public static final String ID3_SCHEME_ID_AOM = "https://aomedia.org/emsg/ID3";
+
+  /**
+   * The Apple-hosted scheme_id equivalent to {@code ID3_SCHEME_ID_AOM} - used before AOM adoption.
+   */
+  private static final String ID3_SCHEME_ID_APPLE =
+      "https://developer.apple.com/streaming/emsg-id3";
+
+  /**
+   * scheme_id_uri from section 7.3.2 of <a
+   * href="https://www.scte.org/SCTEDocs/Standards/ANSI_SCTE%20214-3%202015.pdf">SCTE 214-3
+   * 2015</a>.
+   */
+  @VisibleForTesting public static final String SCTE35_SCHEME_ID = "urn:scte:scte35:2014:bin";
 
   private static final Format ID3_FORMAT =
       Format.createSampleFormat(
           /* id= */ null, MimeTypes.APPLICATION_ID3, Format.OFFSET_SAMPLE_RELATIVE);
+  private static final Format SCTE35_FORMAT =
+      Format.createSampleFormat(
+          /* id= */ null, MimeTypes.APPLICATION_SCTE35, Format.OFFSET_SAMPLE_RELATIVE);
 
-  /**
-   * The message scheme.
-   */
+  /** The message scheme. */
   public final String schemeIdUri;
 
   /**
@@ -94,13 +109,21 @@ public EventMessage(
   @Override
   @Nullable
   public Format getWrappedMetadataFormat() {
-    return ID3_SCHEME_ID.equals(schemeIdUri) ? ID3_FORMAT : null;
+    switch (schemeIdUri) {
+      case ID3_SCHEME_ID_AOM:
+      case ID3_SCHEME_ID_APPLE:
+        return ID3_FORMAT;
+      case SCTE35_SCHEME_ID:
+        return SCTE35_FORMAT;
+      default:
+        return null;
+    }
   }
 
   @Override
   @Nullable
   public byte[] getWrappedMetadataBytes() {
-    return ID3_SCHEME_ID.equals(schemeIdUri) ? messageData : null;
+    return getWrappedMetadataFormat() != null ? messageData : null;
   }
 
   @Override
@@ -135,7 +158,14 @@ public boolean equals(@Nullable Object obj) {
 
   @Override
   public String toString() {
-    return "EMSG: scheme=" + schemeIdUri + ", id=" + id + ", value=" + value;
+    return "EMSG: scheme="
+        + schemeIdUri
+        + ", id="
+        + id
+        + ", durationMs="
+        + durationMs
+        + ", value="
+        + value;
   }
 
   // Parcelable implementation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index a1196c41c8..bbf7476d25 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
@@ -28,21 +29,31 @@
 
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
+  @Nullable
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     byte[] data = buffer.array();
     int size = buffer.limit();
-    return new Metadata(decode(new ParsableByteArray(data, size)));
+    EventMessage decodedEventMessage = decode(new ParsableByteArray(data, size));
+    if (decodedEventMessage == null) {
+      return null;
+    } else {
+      return new Metadata(decodedEventMessage);
+    }
   }
 
+  @Nullable
   public EventMessage decode(ParsableByteArray emsgData) {
-    String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-    String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-    long durationMs = emsgData.readUnsignedInt();
-    long id = emsgData.readUnsignedInt();
-    byte[] messageData =
-        Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
-    return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
+    try {
+      String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+      String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+      long durationMs = emsgData.readUnsignedInt();
+      long id = emsgData.readUnsignedInt();
+      byte[] messageData =
+          Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
+      return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
+    } catch (RuntimeException e) {
+      return null;
+    }
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index db19764318..4e7b572384 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -189,14 +189,12 @@ public int getFirstWindowIndex(boolean shuffleModeEnabled) {
   }
 
   @Override
-  public final Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+  public final Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
     int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
     getTimelineByChildIndex(childIndex)
-        .getWindow(
-            windowIndex - firstWindowIndexInChild, window, setTag, defaultPositionProjectionUs);
+        .getWindow(windowIndex - firstWindowIndexInChild, window, defaultPositionProjectionUs);
     window.firstPeriodIndex += firstPeriodIndexInChild;
     window.lastPeriodIndex += firstPeriodIndexInChild;
     return window;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index 81169354de..703f8bafc0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -342,10 +342,8 @@ public ClippingTimeline(Timeline timeline, long startUs, long endUs)
     }
 
     @Override
-    public Window getWindow(
-        int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
-      timeline.getWindow(
-          /* windowIndex= */ 0, window, setTag, /* defaultPositionProjectionUs= */ 0);
+    public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+      timeline.getWindow(/* windowIndex= */ 0, window, /* defaultPositionProjectionUs= */ 0);
       window.positionInFirstPeriodUs += startUs;
       window.durationUs = durationUs;
       window.isDynamic = isDynamic;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
index 45997aced4..38b373b26c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ForwardingTimeline.java
@@ -57,9 +57,8 @@ public int getFirstWindowIndex(boolean shuffleModeEnabled) {
   }
 
   @Override
-  public Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
-    return timeline.getWindow(windowIndex, window, setTag, defaultPositionProjectionUs);
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+    return timeline.getWindow(windowIndex, window, defaultPositionProjectionUs);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
index d9dd83de4f..35800f56da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
@@ -287,8 +287,7 @@ public int getWindowCount() {
     }
 
     @Override
-    public Window getWindow(
-        int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+    public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
       return window.set(
           tag,
           /* manifest= */ null,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index 921afcdf2f..fa4a26aa3c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -393,13 +393,7 @@ public int read(
             buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
           }
           if (!buffer.isFlagsOnly()) {
-            // Read encryption data if the sample is encrypted.
-            if (buffer.isEncrypted()) {
-              readEncryptionData(buffer, extrasHolder);
-            }
-            // Write the sample data into the holder.
-            buffer.ensureSpaceForWrite(extrasHolder.size);
-            readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+            readToBuffer(buffer, extrasHolder);
           }
         }
         return C.RESULT_BUFFER_READ;
@@ -410,12 +404,48 @@ public int read(
     }
   }
 
+  /**
+   * Reads data from the rolling buffer to populate a decoder input buffer.
+   *
+   * @param buffer The buffer to populate.
+   * @param extrasHolder The extras holder whose offset should be read and subsequently adjusted.
+   */
+  private void readToBuffer(DecoderInputBuffer buffer, SampleExtrasHolder extrasHolder) {
+    // Read encryption data if the sample is encrypted.
+    if (buffer.isEncrypted()) {
+      readEncryptionData(buffer, extrasHolder);
+    }
+    // Read sample data, extracting supplemental data into a separate buffer if needed.
+    if (buffer.hasSupplementalData()) {
+      // If there is supplemental data, the sample data is prefixed by its size.
+      scratch.reset(4);
+      readData(extrasHolder.offset, scratch.data, 4);
+      int sampleSize = scratch.readUnsignedIntToInt();
+      extrasHolder.offset += 4;
+      extrasHolder.size -= 4;
+
+      // Write the sample data.
+      buffer.ensureSpaceForWrite(sampleSize);
+      readData(extrasHolder.offset, buffer.data, sampleSize);
+      extrasHolder.offset += sampleSize;
+      extrasHolder.size -= sampleSize;
+
+      // Write the remaining data as supplemental data.
+      buffer.resetSupplementalData(extrasHolder.size);
+      readData(extrasHolder.offset, buffer.supplementalData, extrasHolder.size);
+    } else {
+      // Write the sample data.
+      buffer.ensureSpaceForWrite(extrasHolder.size);
+      readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+    }
+  }
+
   /**
    * Reads encryption data for the current sample.
-   * <p>
-   * The encryption data is written into {@link DecoderInputBuffer#cryptoInfo}, and
-   * {@link SampleExtrasHolder#size} is adjusted to subtract the number of bytes that were read. The
-   * same value is added to {@link SampleExtrasHolder#offset}.
+   *
+   * <p>The encryption data is written into {@link DecoderInputBuffer#cryptoInfo}, and {@link
+   * SampleExtrasHolder#size} is adjusted to subtract the number of bytes that were read. The same
+   * value is added to {@link SampleExtrasHolder#offset}.
    *
    * @param buffer The buffer into which the encryption data should be written.
    * @param extrasHolder The extras holder whose offset should be read and subsequently adjusted.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 8790b09f07..966f8e4c7a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -159,10 +159,8 @@ public int getWindowCount() {
   }
 
   @Override
-  public Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, 1);
-    Object tag = setTag ? this.tag : null;
     long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
     if (isDynamic && defaultPositionProjectionUs != 0) {
       if (windowDurationUs == C.TIME_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
index 25a1440c80..b5167dc173 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
@@ -55,9 +55,8 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
   }
 
   @Override
-  public Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
-    window = super.getWindow(windowIndex, window, setTag, defaultPositionProjectionUs);
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+    window = super.getWindow(windowIndex, window, defaultPositionProjectionUs);
     if (window.durationUs == C.TIME_UNSET) {
       window.durationUs = adPlaybackState.contentDurationUs;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index b43701f1bc..21dff0b4b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -2548,6 +2548,7 @@ private static int compareInts(int first, int second) {
      */
     public final boolean isWithinConstraints;
 
+    @Nullable private final String language;
     private final Parameters parameters;
     private final boolean isWithinRendererCapabilities;
     private final int preferredLanguageScore;
@@ -2560,6 +2561,7 @@ private static int compareInts(int first, int second) {
 
     public AudioTrackScore(Format format, Parameters parameters, int formatSupport) {
       this.parameters = parameters;
+      this.language = normalizeUndeterminedLanguageToNull(format.language);
       isWithinRendererCapabilities = isSupported(formatSupport, false);
       preferredLanguageScore =
           getFormatLanguageScore(
@@ -2633,7 +2635,11 @@ public int compareTo(AudioTrackScore other) {
       if (this.sampleRate != other.sampleRate) {
         return resultSign * compareInts(this.sampleRate, other.sampleRate);
       }
-      return resultSign * compareInts(this.bitrate, other.bitrate);
+      if (Util.areEqual(this.language, other.language)) {
+        // Only compare bit rates of tracks with the same or unknown language.
+        return resultSign * compareInts(this.bitrate, other.bitrate);
+      }
+      return 0;
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index c2007b19a3..6e7b19936f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -68,7 +68,7 @@
    * setting this flag may also enable more concurrent access to the data (e.g. reading one fragment
    * whilst writing another).
    */
-  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 4; // 8
+  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 4; // 16
 
   /**
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/NonNullApi.java b/library/core/src/main/java/com/google/android/exoplayer2/util/NonNullApi.java
index bd7a70eba0..7678710f18 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/NonNullApi.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/NonNullApi.java
@@ -20,8 +20,8 @@
 import java.lang.annotation.RetentionPolicy;
 import javax.annotation.Nonnull;
 import javax.annotation.meta.TypeQualifierDefault;
-// import kotlin.annotations.jvm.MigrationStatus;
-// import kotlin.annotations.jvm.UnderMigration;
+import kotlin.annotations.jvm.MigrationStatus;
+import kotlin.annotations.jvm.UnderMigration;
 
 /**
  * Annotation to declare all type usages in the annotated instance as {@link Nonnull}, unless
@@ -29,8 +29,6 @@
  */
 @Nonnull
 @TypeQualifierDefault(ElementType.TYPE_USE)
-// TODO(internal: b/138703808): Uncomment to ensure Kotlin issues compiler errors when non-null
-// types are used incorrectly.
-// @UnderMigration(status = MigrationStatus.STRICT)
+@UnderMigration(status = MigrationStatus.STRICT)
 @Retention(RetentionPolicy.CLASS)
 public @interface NonNullApi {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index de77e8318d..0310800876 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -23,6 +23,7 @@
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.SystemClock;
 import androidx.annotation.CallSuper;
@@ -123,6 +124,7 @@ public VideoDecoderException(
 
   private CodecMaxValues codecMaxValues;
   private boolean codecNeedsSetOutputSurfaceWorkaround;
+  private boolean codecHandlesHdr10PlusOutOfBandMetadata;
 
   private Surface surface;
   private Surface dummySurface;
@@ -683,6 +685,8 @@ protected void onCodecInitialized(String name, long initializedTimestampMs,
       long initializationDurationMs) {
     eventDispatcher.decoderInitialized(name, initializedTimestampMs, initializationDurationMs);
     codecNeedsSetOutputSurfaceWorkaround = codecNeedsSetOutputSurfaceWorkaround(name);
+    codecHandlesHdr10PlusOutOfBandMetadata =
+        Assertions.checkNotNull(getCodecInfo()).isHdr10PlusOutOfBandMetadataSupported();
   }
 
   @Override
@@ -727,6 +731,37 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     processOutputFormat(codec, width, height);
   }
 
+  @Override
+  protected void handleInputBufferSupplementalData(DecoderInputBuffer buffer)
+      throws ExoPlaybackException {
+    if (!codecHandlesHdr10PlusOutOfBandMetadata) {
+      return;
+    }
+    ByteBuffer data = Assertions.checkNotNull(buffer.supplementalData);
+    if (data.remaining() >= 7) {
+      // Check for HDR10+ out-of-band metadata. See User_data_registered_itu_t_t35 in ST 2094-40.
+      byte ituTT35CountryCode = data.get();
+      int ituTT35TerminalProviderCode = data.getShort();
+      int ituTT35TerminalProviderOrientedCode = data.getShort();
+      byte applicationIdentifier = data.get();
+      byte applicationVersion = data.get();
+      data.position(0);
+      if (ituTT35CountryCode == (byte) 0xB5
+          && ituTT35TerminalProviderCode == 0x003C
+          && ituTT35TerminalProviderOrientedCode == 0x0001
+          && applicationIdentifier == 4
+          && applicationVersion == 0) {
+        // The metadata size may vary so allocate a new array every time. This is not too
+        // inefficient because the metadata is only a few tens of bytes.
+        byte[] hdr10PlusInfo = new byte[data.remaining()];
+        data.get(hdr10PlusInfo);
+        data.position(0);
+        // If codecHandlesHdr10PlusOutOfBandMetadata is true, this is an API 29 or later build.
+        setHdr10PlusInfoV29(getCodec(), hdr10PlusInfo);
+      }
+    }
+  }
+
   @Override
   protected boolean processOutputBuffer(
       long positionUs,
@@ -1153,6 +1188,13 @@ private static boolean isBufferVeryLate(long earlyUs) {
     return earlyUs < -500000;
   }
 
+  @TargetApi(29)
+  private static void setHdr10PlusInfoV29(MediaCodec codec, byte[] hdr10PlusInfo) {
+    Bundle codecParameters = new Bundle();
+    codecParameters.putByteArray(MediaCodec.PARAMETER_KEY_HDR10_PLUS_INFO, hdr10PlusInfo);
+    codec.setParameters(codecParameters);
+  }
+
   @TargetApi(23)
   private static void setOutputSurfaceV23(MediaCodec codec, Surface surface) {
     codec.setOutputSurface(surface);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index b4b09b20a2..10ccb4eba2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -46,16 +46,35 @@
   @Nullable public int[] yuvStrides;
   public int colorspace;
 
+  /**
+   * Supplemental data related to the output frame, if {@link #hasSupplementalData()} returns true.
+   * If present, the buffer is populated with supplemental data from position 0 to its limit.
+   */
+  @Nullable public ByteBuffer supplementalData;
+
   /**
    * Initializes the buffer.
    *
    * @param timeUs The presentation timestamp for the buffer, in microseconds.
    * @param mode The output mode. One of {@link C#VIDEO_OUTPUT_MODE_NONE}, {@link
    *     C#VIDEO_OUTPUT_MODE_YUV} and {@link C#VIDEO_OUTPUT_MODE_SURFACE_YUV}.
+   * @param supplementalData Supplemental data associated with the frame, or {@code null} if not
+   *     present. It is safe to reuse the provided buffer after this method returns.
    */
-  public void init(long timeUs, @C.VideoOutputMode int mode) {
+  public void init(
+      long timeUs, @C.VideoOutputMode int mode, @Nullable ByteBuffer supplementalData) {
     this.timeUs = timeUs;
     this.mode = mode;
+    if (supplementalData != null) {
+      int size = supplementalData.limit();
+      if (this.supplementalData == null || this.supplementalData.capacity() < size) {
+        this.supplementalData = ByteBuffer.allocate(size);
+      }
+      this.supplementalData.position(0);
+      this.supplementalData.put(supplementalData);
+      this.supplementalData.flip();
+      supplementalData.position(0);
+    }
   }
 
   /**
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
index 14aa436be3..afcce904e9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
@@ -359,6 +359,7 @@ private void setupTimeline(long initialPositionUs, long... adGroupTimesUs) {
             /* startPositionUs= */ 0,
             /* contentPositionUs= */ 0,
             Player.STATE_READY,
+            /* playbackError= */ null,
             /* isLoading= */ false,
             /* trackGroups= */ null,
             /* trackSelectorResult= */ null,
@@ -370,7 +371,9 @@ private void setupTimeline(long initialPositionUs, long... adGroupTimesUs) {
 
   private void advance() {
     enqueueNext();
-    advancePlaying();
+    if (mediaPeriodQueue.getLoadingPeriod() != mediaPeriodQueue.getPlayingPeriod()) {
+      advancePlaying();
+    }
   }
 
   private void advancePlaying() {
@@ -382,7 +385,7 @@ private void advanceReading() {
   }
 
   private void enqueueNext() {
-    mediaPeriodQueue.enqueueNextMediaPeriod(
+    mediaPeriodQueue.enqueueNextMediaPeriodHolder(
         rendererCapabilities,
         trackSelector,
         allocator,
@@ -460,7 +463,7 @@ private void assertNextMediaPeriodInfoIsAd(int adGroupIndex, long contentPositio
 
   private int getQueueLength() {
     int length = 0;
-    MediaPeriodHolder periodHolder = mediaPeriodQueue.getFrontPeriod();
+    MediaPeriodHolder periodHolder = mediaPeriodQueue.getPlayingPeriod();
     while (periodHolder != null) {
       length++;
       periodHolder = periodHolder.getNext();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java
index c0b5205455..7982163ee8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java
@@ -67,6 +67,13 @@ public void setUp() {
             /* enableConvertHighResIntPcmToFloat= */ false);
   }
 
+  @Test
+  public void handlesSpecializedAudioProcessorArray() {
+    defaultAudioSink =
+        new DefaultAudioSink(
+            AudioCapabilities.DEFAULT_AUDIO_CAPABILITIES, new TeeAudioProcessor[0]);
+  }
+
   @Test
   public void handlesBufferAfterReset() throws Exception {
     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
index 4de8bb76cc..de18d370ec 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.metadata.emsg.EventMessageEncoder;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2.metadata.scte35.TimeSignalCommand;
 import com.google.android.exoplayer2.testutil.FakeSampleStream;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.Assertions;
@@ -40,6 +41,28 @@
 @RunWith(AndroidJUnit4.class)
 public class MetadataRendererTest {
 
+  private static final byte[] SCTE35_TIME_SIGNAL_BYTES =
+      TestUtil.joinByteArrays(
+          TestUtil.createByteArray(
+              0, // table_id.
+              0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+              0x14, // section_length(8).
+              0x00, // protocol_version.
+              0x00), // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+          TestUtil.createByteArray(0x00, 0x00, 0x00, 0x00), // pts_adjustment(32).
+          TestUtil.createByteArray(
+              0x00, // cw_index.
+              0x00, // tier(8).
+              0x00, // tier(4), splice_command_length(4).
+              0x05, // splice_command_length(8).
+              0x06, // splice_command_type = time_signal.
+              // Start of splice_time().
+              0x80), // time_specified_flag, reserved, pts_time(1).
+          TestUtil.createByteArray(
+              0x52, 0x03, 0x02, 0x8f), // pts_time(32). PTS for a second after playback position.
+          TestUtil.createByteArray(
+              0x00, 0x00, 0x00, 0x00)); // CRC_32 (ignored, check happens at extraction).
+
   private static final Format EMSG_FORMAT =
       Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG, Format.OFFSET_SAMPLE_RELATIVE);
 
@@ -55,7 +78,7 @@ public void decodeMetadata() throws Exception {
             /* id= */ 0,
             "Test data".getBytes(UTF_8));
 
-    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).hasSize(1);
     assertThat(metadata.get(0).length()).isEqualTo(1);
@@ -63,16 +86,23 @@ public void decodeMetadata() throws Exception {
   }
 
   @Test
-  public void decodeMetadata_handlesWrappedMetadata() throws Exception {
+  public void decodeMetadata_skipsMalformed() throws Exception {
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, "not valid emsg bytes".getBytes(UTF_8));
+
+    assertThat(metadata).isEmpty();
+  }
+
+  @Test
+  public void decodeMetadata_handlesId3WrappedInEmsg() throws Exception {
     EventMessage emsg =
         new EventMessage(
-            EventMessage.ID3_SCHEME_ID,
+            EventMessage.ID3_SCHEME_ID_AOM,
             /* value= */ "",
             /* durationMs= */ 1,
             /* id= */ 0,
             encodeTxxxId3Frame("Test description", "Test value"));
 
-    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).hasSize(1);
     assertThat(metadata.get(0).length()).isEqualTo(1);
@@ -81,27 +111,46 @@ public void decodeMetadata_handlesWrappedMetadata() throws Exception {
     assertThat(metadata.get(0).get(0)).isEqualTo(expectedId3Frame);
   }
 
+  @Test
+  public void decodeMetadata_handlesScte35WrappedInEmsg() throws Exception {
+
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.SCTE35_SCHEME_ID,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            SCTE35_TIME_SIGNAL_BYTES);
+
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    assertThat(metadata.get(0).get(0)).isInstanceOf(TimeSignalCommand.class);
+  }
+
   @Test
   public void decodeMetadata_skipsMalformedWrappedMetadata() throws Exception {
     EventMessage emsg =
         new EventMessage(
-            EventMessage.ID3_SCHEME_ID,
+            EventMessage.ID3_SCHEME_ID_AOM,
             /* value= */ "",
             /* durationMs= */ 1,
             /* id= */ 0,
             "Not a real ID3 tag".getBytes(ISO_8859_1));
 
-    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).isEmpty();
   }
 
-  private static List<Metadata> runRenderer(byte[] input) throws ExoPlaybackException {
+  private static List<Metadata> runRenderer(Format format, byte[] input)
+      throws ExoPlaybackException {
     List<Metadata> metadata = new ArrayList<>();
     MetadataRenderer renderer = new MetadataRenderer(metadata::add, /* outputLooper= */ null);
     renderer.replaceStream(
-        new Format[] {EMSG_FORMAT},
-        new FakeSampleStream(EMSG_FORMAT, /* eventDispatcher= */ null, input),
+        new Format[] {format},
+        new FakeSampleStream(format, /* eventDispatcher= */ null, input),
         /* offsetUs= */ 0L);
     renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the format
     renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the data
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
index 701ec3521c..cb21db8212 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
@@ -88,8 +88,7 @@ public void setNullTag_returnsNullTag_butUsesDefaultUid() {
             /* manifest= */ null,
             /* tag= */ null);
 
-    assertThat(timeline.getWindow(/* windowIndex= */ 0, window, /* setTag= */ false).tag).isNull();
-    assertThat(timeline.getWindow(/* windowIndex= */ 0, window, /* setTag= */ true).tag).isNull();
+    assertThat(timeline.getWindow(/* windowIndex= */ 0, window).tag).isNull();
     assertThat(timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ false).id).isNull();
     assertThat(timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ true).id).isNull();
     assertThat(timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ false).uid).isNull();
@@ -98,7 +97,7 @@ public void setNullTag_returnsNullTag_butUsesDefaultUid() {
   }
 
   @Test
-  public void setTag_isUsedForWindowTag() {
+  public void getWindow_setsTag() {
     Object tag = new Object();
     SinglePeriodTimeline timeline =
         new SinglePeriodTimeline(
@@ -108,9 +107,7 @@ public void setTag_isUsedForWindowTag() {
             /* manifest= */ null,
             tag);
 
-    assertThat(timeline.getWindow(/* windowIndex= */ 0, window, /* setTag= */ false).tag).isNull();
-    assertThat(timeline.getWindow(/* windowIndex= */ 0, window, /* setTag= */ true).tag)
-        .isEqualTo(tag);
+    assertThat(timeline.getWindow(/* windowIndex= */ 0, window).tag).isEqualTo(tag);
   }
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 0374f88bae..7c57c44924 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -717,37 +717,38 @@ public void testSelectTracksWithinCapabilitiesSelectHigherSampleRate()
   }
 
   /**
-   * Tests that track selector will select audio tracks with higher bit-rate when other factors are
-   * the same, and tracks are within renderer's capabilities.
+   * Tests that track selector will select audio tracks with higher bit rate when other factors are
+   * the same, and tracks are within renderer's capabilities, and have the same language.
    */
   @Test
-  public void testSelectTracksWithinCapabilitiesSelectHigherBitrate() throws Exception {
+  public void selectAudioTracks_withinCapabilities_andSameLanguage_selectsHigherBitrate()
+      throws Exception {
     Format lowerBitrateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
             MimeTypes.AUDIO_AAC,
-            null,
-            15000,
-            Format.NO_VALUE,
-            2,
-            44100,
-            null,
-            null,
-            0,
-            null);
+            /* codecs= */ null,
+            /* bitrate= */ 15000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
     Format higherBitrateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
             MimeTypes.AUDIO_AAC,
-            null,
-            30000,
-            Format.NO_VALUE,
-            2,
-            44100,
-            null,
-            null,
-            0,
-            null);
+            /* codecs= */ null,
+            /* bitrate= */ 30000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
     TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);
 
     TrackSelectorResult result =
@@ -759,14 +760,58 @@ public void testSelectTracksWithinCapabilitiesSelectHigherBitrate() throws Excep
     assertFixedSelection(result.selections.get(0), trackGroups, higherBitrateFormat);
   }
 
+  /**
+   * Tests that track selector will select the first audio track even if other tracks with a
+   * different language have higher bit rates, all other factors are the same, and tracks are within
+   * renderer's capabilities.
+   */
+  @Test
+  public void selectAudioTracks_withinCapabilities_andDifferentLanguage_selectsFirstTrack()
+      throws Exception {
+    Format firstLanguageFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            /* codecs= */ null,
+            /* bitrate= */ 15000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "hi");
+    Format higherBitrateFormat =
+        Format.createAudioSampleFormat(
+            "audioFormat",
+            MimeTypes.AUDIO_AAC,
+            /* codecs= */ null,
+            /* bitrate= */ 30000,
+            /* maxInputSize= */ Format.NO_VALUE,
+            /* channelCount= */ 2,
+            /* sampleRate= */ 44100,
+            /* initializationData= */ null,
+            /* drmInitData= */ null,
+            /* selectionFlags= */ 0,
+            /* language= */ "te");
+    TrackGroupArray trackGroups = wrapFormats(firstLanguageFormat, higherBitrateFormat);
+
+    TrackSelectorResult result =
+        trackSelector.selectTracks(
+            new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
+            trackGroups,
+            periodId,
+            TIMELINE);
+    assertFixedSelection(result.selections.get(0), trackGroups, firstLanguageFormat);
+  }
+
   /**
    * Tests that track selector will prefer audio tracks with higher channel count over tracks with
    * higher sample rate when other factors are the same, and tracks are within renderer's
    * capabilities.
    */
   @Test
-  public void testSelectTracksPreferHigherNumChannelBeforeSampleRate()
-      throws Exception {
+  public void testSelectTracksPreferHigherNumChannelBeforeSampleRate() throws Exception {
     Format higherChannelLowerSampleRateFormat =
         Format.createAudioSampleFormat(
             "audioFormat",
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 890a272c5e..1b163c02e2 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -1207,18 +1207,16 @@ public int getWindowCount() {
     }
 
     @Override
-    public Window getWindow(
-        int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+    public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
       Assertions.checkIndex(windowIndex, 0, 1);
       long windowDefaultStartPositionUs = getAdjustedWindowDefaultStartPositionUs(
           defaultPositionProjectionUs);
-      Object tag = setTag ? windowTag : null;
       boolean isDynamic =
           manifest.dynamic
               && manifest.minUpdatePeriodMs != C.TIME_UNSET
               && manifest.durationMs == C.TIME_UNSET;
       return window.set(
-          tag,
+          windowTag,
           manifest,
           presentationStartTimeMs,
           windowStartTimeMs,
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
index af4bf3ad70..883ca7420e 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -360,6 +360,9 @@ private void parseAndDiscardSamples() {
         }
         long eventTimeUs = inputBuffer.timeUs;
         Metadata metadata = decoder.decode(inputBuffer);
+        if (metadata == null) {
+          continue;
+        }
         EventMessage eventMessage = (EventMessage) metadata.get(0);
         if (isPlayerEmsgEvent(eventMessage.schemeIdUri, eventMessage.value)) {
           parsePlayerEmsgEvent(eventTimeUs, eventMessage);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index c452a29cf9..370d79edc7 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -225,10 +225,17 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    *     media in previous periods still to be played.
    * @param loadPositionUs The current load position relative to the period start in microseconds.
    * @param queue The queue of buffered {@link HlsMediaChunk}s.
+   * @param allowEndOfStream Whether {@link HlsChunkHolder#endOfStream} is allowed to be set for
+   *     non-empty media playlists. If {@code false}, the last available chunk is returned instead.
+   *     If the media playlist is empty, {@link HlsChunkHolder#endOfStream} is always set.
    * @param out A holder to populate.
    */
   public void getNextChunk(
-      long playbackPositionUs, long loadPositionUs, List<HlsMediaChunk> queue, HlsChunkHolder out) {
+      long playbackPositionUs,
+      long loadPositionUs,
+      List<HlsMediaChunk> queue,
+      boolean allowEndOfStream,
+      HlsChunkHolder out) {
     HlsMediaChunk previous = queue.isEmpty() ? null : queue.get(queue.size() - 1);
     int oldTrackIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
@@ -292,15 +299,20 @@ public void getNextChunk(
     }
 
     int segmentIndexInPlaylist = (int) (chunkMediaSequence - mediaPlaylist.mediaSequence);
-    if (segmentIndexInPlaylist >= mediaPlaylist.segments.size()) {
+    int availableSegmentCount = mediaPlaylist.segments.size();
+    if (segmentIndexInPlaylist >= availableSegmentCount) {
       if (mediaPlaylist.hasEndTag) {
-        out.endOfStream = true;
+        if (allowEndOfStream || availableSegmentCount == 0) {
+          out.endOfStream = true;
+          return;
+        }
+        segmentIndexInPlaylist = availableSegmentCount - 1;
       } else /* Live */ {
         out.playlistUrl = selectedPlaylistUrl;
         seenExpectedPlaylistError &= selectedPlaylistUrl.equals(expectedPlaylistUrl);
         expectedPlaylistUrl = selectedPlaylistUrl;
+        return;
       }
-      return;
     }
     // We have a valid playlist snapshot, we can discard any playlist errors at this point.
     seenExpectedPlaylistError = false;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index ff725ec6f7..e4c756c6b6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSession;
@@ -232,6 +233,9 @@ public void prepareWithMasterPlaylistInfo(
 
   public void maybeThrowPrepareError() throws IOException {
     maybeThrowError();
+    if (loadingFinished && !prepared) {
+      throw new ParserException("Loading finished before preparation is complete.");
+    }
   }
 
   public TrackGroupArray getTrackGroups() {
@@ -608,7 +612,12 @@ public boolean continueLoading(long positionUs) {
               ? lastMediaChunk.endTimeUs
               : Math.max(lastSeekPositionUs, lastMediaChunk.startTimeUs);
     }
-    chunkSource.getNextChunk(positionUs, loadPositionUs, chunkQueue, nextChunkHolder);
+    chunkSource.getNextChunk(
+        positionUs,
+        loadPositionUs,
+        chunkQueue,
+        /* allowEndOfStream= */ prepared || !chunkQueue.isEmpty(),
+        nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     Uri playlistUrlToLoad = nextChunkHolder.playlistUrl;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index 58ee32cdd9..f0a0c77ff6 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -179,12 +179,10 @@ public int getWindowCount() {
   }
 
   @Override
-  public Window getWindow(
-      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
+  public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
     TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
-    Object tag = setTag ? windowDefinition.id : null;
     return window.set(
-        tag,
+        /* tag= */ windowDefinition.id,
         manifests[windowIndex],
         /* presentationStartTimeMs= */ C.TIME_UNSET,
         /* windowStartTimeMs= */ C.TIME_UNSET,
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
index 1e3c9c61d9..f3ec47a88b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
@@ -52,7 +52,7 @@ public static void assertWindowTags(Timeline timeline, Object... expectedWindowT
     Window window = new Window();
     assertThat(timeline.getWindowCount()).isEqualTo(expectedWindowTags.length);
     for (int i = 0; i < timeline.getWindowCount(); i++) {
-      timeline.getWindow(i, window, true);
+      timeline.getWindow(i, window);
       if (expectedWindowTags[i] != null) {
         assertThat(window.tag).isEqualTo(expectedWindowTags[i]);
       }
@@ -63,7 +63,7 @@ public static void assertWindowTags(Timeline timeline, Object... expectedWindowT
   public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsDynamic) {
     Window window = new Window();
     for (int i = 0; i < timeline.getWindowCount(); i++) {
-      timeline.getWindow(i, window, true);
+      timeline.getWindow(i, window);
       assertThat(window.isDynamic).isEqualTo(windowIsDynamic[i]);
     }
   }
@@ -129,7 +129,7 @@ public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCo
     Window window = new Window();
     Period period = new Period();
     for (int i = 0; i < windowCount; i++) {
-      timeline.getWindow(i, window, true);
+      timeline.getWindow(i, window);
       assertThat(window.firstPeriodIndex).isEqualTo(accumulatedPeriodCounts[i]);
       assertThat(window.lastPeriodIndex).isEqualTo(accumulatedPeriodCounts[i + 1] - 1);
     }
