diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
index e8c455a898..3c0851f5c9 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
@@ -81,7 +81,6 @@
   private static final String TEST_CONTENT_TYPE = "test/test";
   private static final byte[] TEST_POST_BODY = "test post body".getBytes();
   private static final long TEST_CONTENT_LENGTH = 16000L;
-  private static final int TEST_BUFFER_SIZE = 16;
   private static final int TEST_CONNECTION_STATUS = 5;
 
   private DataSpec testDataSpec;
@@ -101,7 +100,6 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
         boolean disableCache,
         boolean disableConnectionMigration,
         boolean allowDirectExecutor);
-
   }
 
   @Mock
@@ -130,12 +128,12 @@ public void setUp() throws Exception {
         new CronetDataSource(
             mockCronetEngine,
             mockExecutor,
-            mockClock,
             mockContentTypePredicate,
             mockTransferListener,
             TEST_CONNECT_TIMEOUT_MS,
             TEST_READ_TIMEOUT_MS,
-            true)); // resetTimeoutOnRedirects
+            true, // resetTimeoutOnRedirects
+            mockClock));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.createRequest(
         anyString(),
@@ -148,13 +146,12 @@ public void setUp() throws Exception {
         any(Boolean.class))).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
-    testDataSpec =
-        new DataSpec(Uri.parse(TEST_URL), 0 /* flags */, C.LENGTH_UNBOUNDED, null /* key */);
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNBOUNDED, null);
     testPostDataSpec = new DataSpec(
         Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNBOUNDED, null, 0);
     testResponseHeader = new HashMap<>();
     testResponseHeader.put("Content-Type", TEST_CONTENT_TYPE);
-    // This value can be anything since the DataSpec is unbounded.
+    // This value can be anything since the DataSpec is unset.
     testResponseHeader.put("Content-Length", Long.toString(TEST_CONTENT_LENGTH));
     testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
   }
@@ -175,10 +172,7 @@ private UrlResponseInfo createUrlResponseInfo(int statusCode) {
   @Test(expected = IllegalStateException.class)
   public void testOpeningTwiceThrows() throws HttpDataSourceException {
     mockResponseStartSuccess();
-
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
     dataSourceUnderTest.open(testDataSpec);
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     dataSourceUnderTest.open(testDataSpec);
   }
 
@@ -206,7 +200,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            null);
+            mockUrlRequestException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -235,10 +229,8 @@ public void testRequestStartCalled() throws HttpDataSourceException {
 
   @Test
   public void testRequestHeadersSet() throws HttpDataSourceException {
-    mockResponseStartSuccess();
-
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-    testResponseHeader.put("Content-Length", Long.toString(5000L));
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("firstHeader", "firstValue");
     dataSourceUnderTest.setRequestProperty("secondHeader", "secondValue");
@@ -254,24 +246,19 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
   @Test
   public void testRequestOpen() throws HttpDataSourceException {
     mockResponseStartSuccess();
-
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     verify(mockTransferListener).onTransferStart();
   }
 
   @Test
   public void testRequestOpenGzippedCompressedReturnsDataSpecLength()
       throws HttpDataSourceException {
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 5000, null);
     testResponseHeader.put("Content-Encoding", "gzip");
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    testResponseHeader.put("Content-Length", Long.toString(50L));
     mockResponseStartSuccess();
 
-    // Data spec's requested length, 5000. Test response's length, 16,000.
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-
     assertEquals(5000 /* contentLength */, dataSourceUnderTest.open(testDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     verify(mockTransferListener).onTransferStart();
   }
 
@@ -286,7 +273,6 @@ public void testRequestOpenFail() {
       // Check for connection not automatically closed.
       assertFalse(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
@@ -304,7 +290,6 @@ public void testRequestOpenFailDueToDnsFailure() {
       // Check for connection not automatically closed.
       assertTrue(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
@@ -321,7 +306,6 @@ public void testRequestOpenValidatesStatusCode() {
       assertTrue(e instanceof HttpDataSource.InvalidResponseCodeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
@@ -338,37 +322,16 @@ public void testRequestOpenValidatesContentTypePredicate() {
       assertTrue(e instanceof HttpDataSource.InvalidContentTypeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockContentTypePredicate).evaluate(TEST_CONTENT_TYPE);
     }
   }
 
-  @Test
-  public void testRequestOpenValidatesContentLength() {
-    mockResponseStartSuccess();
-
-    // Data spec's requested length, 5000. Test response's length, 16,000.
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-
-    try {
-      dataSourceUnderTest.open(testDataSpec);
-      fail("HttpDataSource.HttpDataSourceException expected");
-    } catch (HttpDataSourceException e) {
-      verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
-      // Check for connection not automatically closed.
-      verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
-      verify(mockTransferListener, never()).onTransferStart();
-    }
-  }
-
   @Test
   public void testPostRequestOpen() throws HttpDataSourceException {
     mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testPostDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     verify(mockTransferListener).onTransferStart();
   }
 
@@ -401,7 +364,7 @@ public void testPostRequestOpenRejects307Redirects() {
   @Test
   public void testRequestReadTwice() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    mockReadSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -423,28 +386,23 @@ public void testRequestReadTwice() throws HttpDataSourceException {
   @Test
   public void testSecondRequestNoContentLength() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    mockReadSuccess();
-
-    byte[] returnedBuffer = new byte[8];
+    testResponseHeader.put("Content-Length", Long.toString(1L));
+    mockReadSuccess(0, 16);
 
     // First request.
-    testResponseHeader.put("Content-Length", Long.toString(1L));
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
     dataSourceUnderTest.open(testDataSpec);
+    byte[] returnedBuffer = new byte[8];
     dataSourceUnderTest.read(returnedBuffer, 0, 1);
     dataSourceUnderTest.close();
 
-    // Second request. There's no Content-Length response header.
     testResponseHeader.remove("Content-Length");
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    mockReadSuccess(0, 16);
+
+    // Second request.
     dataSourceUnderTest.open(testDataSpec);
     returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(10, bytesRead);
-
-    mockResponseFinished();
-
-    // Should read whats left in the buffer first.
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(6, bytesRead);
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
@@ -454,23 +412,54 @@ public void testSecondRequestNoContentLength() throws HttpDataSourceException {
   @Test
   public void testReadWithOffset() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    mockReadSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
     byte[] returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
-    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
     assertEquals(8, bytesRead);
+    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
     verify(mockTransferListener).onBytesTransferred(8);
   }
 
   @Test
-  public void testReadWithUnboundedLength() throws HttpDataSourceException {
+  public void testRangeRequestWith206Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(1000, 5000);
+    testUrlResponseInfo = createUrlResponseInfo(206); // Server supports range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(16);
+  }
+
+  @Test
+  public void testRangeRequestWith200Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 7000);
+    testUrlResponseInfo = createUrlResponseInfo(200); // Server does not support range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(16);
+  }
+
+  @Test
+  public void testReadWithUnsetLength() throws HttpDataSourceException {
     testResponseHeader.remove("Content-Length");
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
     mockResponseStartSuccess();
-    mockReadSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -484,7 +473,7 @@ public void testReadWithUnboundedLength() throws HttpDataSourceException {
   @Test
   public void testReadReturnsWhatItCan() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    mockReadSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -498,7 +487,7 @@ public void testReadReturnsWhatItCan() throws HttpDataSourceException {
   @Test
   public void testClosedMeansClosed() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    mockReadSuccess();
+    mockReadSuccess(0, 16);
 
     int bytesRead = 0;
     dataSourceUnderTest.open(testDataSpec);
@@ -510,7 +499,6 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
     dataSourceUnderTest.close();
     verify(mockTransferListener).onTransferEnd();
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
 
     try {
       bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
@@ -525,32 +513,29 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
   @Test
   public void testOverread() throws HttpDataSourceException {
-    mockResponseStartSuccess();
-    mockReadSuccess();
-
-    // Ask for 16 bytes
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 10000, 16, null);
-    // Let the response promise to give 16 bytes back.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 16, null);
     testResponseHeader.put("Content-Length", Long.toString(16L));
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
     byte[] returnedBuffer = new byte[8];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
     assertEquals(8, bytesRead);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
 
     // The current buffer is kept if not completely consumed by DataSource reader.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 6);
-    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
     assertEquals(14, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
 
     // 2 bytes left at this point.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
     assertEquals(16, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
@@ -571,7 +556,6 @@ public void testOverread() throws HttpDataSourceException {
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
     // Check for connection not automatically closed.
     verify(mockUrlRequest, never()).cancel();
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     assertEquals(16, bytesRead);
   }
 
@@ -602,15 +586,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart();
   }
@@ -636,15 +617,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // The response arrives just in time.
     dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
     openCondition.block();
-    assertEquals(CronetDataSource.OPEN_CONNECTION, dataSourceUnderTest.connectionState);
   }
 
   @Test
@@ -673,11 +651,9 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl1");
@@ -688,7 +664,6 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl2");
@@ -699,11 +674,9 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart();
     assertEquals(1, openExceptions.get());
@@ -794,16 +767,24 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).start();
   }
 
-  private void mockReadSuccess() {
+  private void mockReadSuccess(int position, int length) {
+    final int[] positionAndRemaining = new int[] {position, length};
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocation) throws Throwable {
-        ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
-        inputBuffer.put(buildTestDataBuffer());
-        dataSourceUnderTest.onReadCompleted(
-            mockUrlRequest,
-            testUrlResponseInfo,
-            inputBuffer);
+        if (positionAndRemaining[1] == 0) {
+          dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+        } else {
+          ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+          int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
+          inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
+          positionAndRemaining[0] += readLength;
+          positionAndRemaining[1] -= readLength;
+          dataSourceUnderTest.onReadCompleted(
+              mockUrlRequest,
+              testUrlResponseInfo,
+              inputBuffer);
+        }
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -816,17 +797,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            null);
-        return null;
-      }
-    }).when(mockUrlRequest).read(any(ByteBuffer.class));
-  }
-
-  private void mockResponseFinished() {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+            mockUrlRequestException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -844,8 +815,8 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return startedCondition;
   }
 
-  private static byte[] buildTestDataArray(int start, int length) {
-    return Arrays.copyOfRange(buildTestDataBuffer().array(), start, start + length);
+  private static byte[] buildTestDataArray(int position, int length) {
+    return buildTestDataBuffer(position, length).array();
   }
 
   public static byte[] prefixZeros(byte[] data, int requiredLength) {
@@ -858,17 +829,13 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return Arrays.copyOf(data, requiredLength);
   }
 
-  private static ByteBuffer buildTestDataBuffer() {
-    ByteBuffer testBuffer = ByteBuffer.allocate(TEST_BUFFER_SIZE);
-    for (byte i = 1; i <= TEST_BUFFER_SIZE; i++) {
-      testBuffer.put(i);
+  private static ByteBuffer buildTestDataBuffer(int position, int length) {
+    ByteBuffer testBuffer = ByteBuffer.allocate(length);
+    for (int i = 0; i < length; i++) {
+      testBuffer.put((byte) (position + i));
     }
     testBuffer.flip();
     return testBuffer;
   }
 
-  private void assertConnectionState(int state) {
-    assertEquals(state, dataSourceUnderTest.connectionState);
-  }
-
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
index 7abe23ecce..99a66c995b 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
@@ -25,7 +25,7 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Clock;
 import com.google.android.exoplayer.util.Predicate;
-import com.google.android.exoplayer.util.TraceUtil;
+import com.google.android.exoplayer.util.SystemClock;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -35,12 +35,11 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
 import org.chromium.net.UrlRequest;
+import org.chromium.net.UrlRequest.Status;
 import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
@@ -73,72 +72,105 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
 
   }
 
+  /**
+   * The default connection timeout, in milliseconds.
+   */
+  public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
+  /**
+   * The default read timeout, in milliseconds.
+   */
+  public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
+
   private static final String TAG = "CronetDataSource";
+  private static final String CONTENT_TYPE = "Content-Type";
   private static final Pattern CONTENT_RANGE_HEADER_PATTERN =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
   // The size of read buffer passed to cronet UrlRequest.read().
   private static final int READ_BUFFER_SIZE_BYTES = 32 * 1024;
 
-  /* package */ static final int IDLE_CONNECTION = 5;
-  /* package */ static final int OPENING_CONNECTION = 2;
-  /* package */ static final int CONNECTED_CONNECTION = 3;
-  /* package */ static final int OPEN_CONNECTION = 4;
-
   private final CronetEngine cronetEngine;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener transferListener;
+  private final TransferListener listener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
   private final Map<String, String> requestProperties;
   private final ConditionVariable operation;
-  private final ByteBuffer readBuffer;
   private final Clock clock;
 
+  // Accessed by the calling thread only.
+  private boolean opened;
+  private long bytesToSkip;
+  private long bytesRemaining;
+
+  // Written from the calling thread only. currentUrlRequest.start() calls ensure writes are visible
+  // to reads made by the Cronet thread.
   private UrlRequest currentUrlRequest;
   private DataSpec currentDataSpec;
+
+  // Reference written and read by calling thread only. Passed to Cronet thread as a local variable.
+  // operation.open() calls ensure writes into the buffer are visible to reads made by the calling
+  // thread.
+  private ByteBuffer readBuffer;
+
+  // Written from the Cronet thread only. operation.open() calls ensure writes are visible to reads
+  // made by the calling thread.
   private UrlResponseInfo responseInfo;
+  private IOException exception;
+  private boolean finished;
 
-  /* package */ volatile int connectionState;
-  private volatile String currentUrl;
   private volatile long currentConnectTimeoutMs;
-  private volatile HttpDataSourceException exception;
-  private volatile long contentLength;
-  private volatile AtomicLong expectedBytesRemainingToRead;
-  private volatile boolean hasData;
-  private volatile boolean responseFinished;
 
   /**
    * @param cronetEngine A CronetEngine.
-   * @param executor The {@link java.util.concurrent.Executor} that will perform the request.
-   * @param clock A {@link com.google.android.exoplayer.util.Clock} for keeping track of timeout.
-   * @param contentTypePredicate A {@link Predicate}. If a content type is rejected by the
-   *     predicate then a
-   *     {@link com.google.android.exoplayer.upstream.HttpDataSource.InvalidContentTypeException}
-   *     is thrown from {@link #validateResponse(UrlResponseInfo)}.
-   * @param transferListener A listener.
-   * @param connectTimeoutMs The timeout to execute a connection.
-   * @param readTimeoutMs The timeout to execute a connection.
-   * @param resetTimeoutOnRedirects Allow to reset the timeout when redirects occur.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from
+   *     {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener) {
+    this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS, false);
+  }
+
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from
+   *     {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   * @param connectTimeoutMs The connection timeout, in milliseconds.
+   * @param readTimeoutMs The read timeout, in milliseconds.
+   * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
    */
-  public CronetDataSource(CronetEngine cronetEngine, Executor executor, Clock clock,
-      Predicate<String> contentTypePredicate, TransferListener transferListener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener, int connectTimeoutMs,
+      int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
+        readTimeoutMs, resetTimeoutOnRedirects, new SystemClock());
+  }
+
+  /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener, int connectTimeoutMs,
+      int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock) {
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
-    this.clock = Assertions.checkNotNull(clock);
     this.contentTypePredicate = contentTypePredicate;
-    this.transferListener = transferListener;
+    this.listener = listener;
     this.connectTimeoutMs = connectTimeoutMs;
     this.readTimeoutMs = readTimeoutMs;
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
-    readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+    this.clock = Assertions.checkNotNull(clock);
     requestProperties = new HashMap<>();
     operation = new ConditionVariable();
-    connectionState = IDLE_CONNECTION;
   }
 
+  // HttpDataSource implementation.
+
   @Override
   public void setRequestProperty(String name, String value) {
     synchronized (requestProperties) {
@@ -166,278 +198,152 @@ public void clearAllRequestProperties() {
   }
 
   @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.open");
-    try {
-      Assertions.checkNotNull(dataSpec);
-      synchronized (this) {
-        Assertions.checkState(connectionState == IDLE_CONNECTION, "Connection already open");
-        connectionState = OPENING_CONNECTION;
-      }
-
-      operation.close();
-      resetConnectTimeout();
-      startRequest(dataSpec);
-      boolean requestStarted = blockUntilConnectTimeout();
-
-      if (exception != null) {
-        // An error occurred opening the connection.
-        throw exception;
-      } else if (!requestStarted) {
-        // The timeout was reached before the connection was opened.
-        throw new OpenException(new SocketTimeoutException(), dataSpec, getCurrentRequestStatus());
-      }
-
-      // Connection was opened.
-      if (transferListener != null) {
-        transferListener.onTransferStart();
-      }
-      connectionState = OPEN_CONNECTION;
-      return contentLength;
-    } finally {
-      TraceUtil.endSection();
-    }
+  public String getUri() {
+    return responseInfo == null ? null : responseInfo.getUrl();
   }
 
-  private void startRequest(DataSpec dataSpec) throws HttpDataSourceException {
-    currentUrl = dataSpec.uri.toString();
+  @Override
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    Assertions.checkNotNull(dataSpec);
+    Assertions.checkState(!opened);
+
+    operation.close();
+    resetConnectTimeout();
     currentDataSpec = dataSpec;
-    UrlRequest.Builder urlRequestBuilder = new UrlRequest.Builder(currentUrl, this, executor,
-        cronetEngine);
-    fillCurrentRequestHeader(urlRequestBuilder);
-    fillCurrentRequestPostBody(urlRequestBuilder, dataSpec);
-    currentUrlRequest = urlRequestBuilder.build();
+    currentUrlRequest = buildRequest(dataSpec);
     currentUrlRequest.start();
-  }
+    boolean requestStarted = blockUntilConnectTimeout();
 
-  private void fillCurrentRequestHeader(UrlRequest.Builder urlRequestBuilder) {
-    synchronized (requestProperties) {
-      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
-        urlRequestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
-      }
-    }
-    if (currentDataSpec.position == 0 && currentDataSpec.length == C.LENGTH_UNBOUNDED) {
-      // Not required.
-      return;
+    if (exception != null) {
+      throw new OpenException(exception, currentDataSpec, getStatus(currentUrlRequest));
+    } else if (!requestStarted) {
+      // The timeout was reached before the connection was opened.
+      throw new OpenException(new SocketTimeoutException(), dataSpec, getStatus(currentUrlRequest));
     }
-    StringBuilder rangeValue = new StringBuilder();
-    rangeValue.append("bytes=");
-    rangeValue.append(currentDataSpec.position);
-    rangeValue.append("-");
-    if (currentDataSpec.length != C.LENGTH_UNBOUNDED) {
-      rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
+
+    // Check for a valid response code.
+    int responseCode = responseInfo.getHttpStatusCode();
+    if (responseCode < 200 || responseCode > 299) {
+      throw new InvalidResponseCodeException(responseCode, responseInfo.getAllHeaders(),
+          currentDataSpec);
     }
-    urlRequestBuilder.addHeader("Range", rangeValue.toString());
-  }
 
-  private void fillCurrentRequestPostBody(UrlRequest.Builder urlRequestBuilder, DataSpec dataSpec)
-      throws HttpDataSourceException {
-    if (dataSpec.postBody != null) {
-      if (!requestProperties.containsKey("Content-Type")) {
-        throw new OpenException("POST requests must set a Content-Type header", dataSpec,
-            getCurrentRequestStatus());
+    // Check for a valid content type.
+    if (contentTypePredicate != null) {
+      List<String> contentTypeHeaders = responseInfo.getAllHeaders().get(CONTENT_TYPE);
+      String contentType = isEmpty(contentTypeHeaders) ? null : contentTypeHeaders.get(0);
+      if (!contentTypePredicate.evaluate(contentType)) {
+        throw new InvalidContentTypeException(contentType, currentDataSpec);
       }
-      urlRequestBuilder.setUploadDataProvider(
-          new ByteArrayUploadDataProvider(dataSpec.postBody), executor);
     }
-  }
 
-  @Override
-  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      UrlRequestException error) {
-    if (request != currentUrlRequest) {
-      return;
+    // If we requested a range starting from a non-zero position and received a 200 rather than a
+    // 206, then the server does not support partial requests. We'll need to manually skip to the
+    // requested position.
+    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+    // Calculate the content length.
+    if (!getIsCompressed(responseInfo)) {
+      if (dataSpec.length != C.LENGTH_UNBOUNDED) {
+        bytesRemaining = dataSpec.length;
+      } else {
+        bytesRemaining = getContentLength(responseInfo);
+      }
+    } else {
+      // If the response is compressed then the content length will be that of the compressed data
+      // which isn't what we want. Always use the dataSpec length in this case.
+      bytesRemaining = currentDataSpec.length;
     }
-    if (connectionState == OPENING_CONNECTION) {
-      IOException cause = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-          ? new UnknownHostException() : error;
-      exception = new OpenException(cause, currentDataSpec, getCurrentRequestStatus());
-    } else if (connectionState == OPEN_CONNECTION) {
-      readBuffer.limit(0);
-      exception = new HttpDataSourceException(error, currentDataSpec,
-          HttpDataSourceException.TYPE_READ);
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart();
     }
-    operation.open();
+
+    return bytesRemaining;
   }
 
   @Override
-  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
-    if (request != currentUrlRequest) {
-      return;
+  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
+    Assertions.checkState(opened);
+
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
+      return C.RESULT_END_OF_INPUT;
     }
-    TraceUtil.beginSection("CronetDataSource.onResponseStarted");
-    try {
-      validateResponse(info);
-      responseInfo = info;
 
-      if (isCompressed(info)) {
-        contentLength = currentDataSpec.length;
+    if (readBuffer == null) {
+      readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+      readBuffer.limit(0);
+    }
+    while (!readBuffer.hasRemaining()) {
+      // Fill readBuffer with more data from Cronet.
+      operation.close();
+      readBuffer.clear();
+      currentUrlRequest.read(readBuffer);
+      if (!operation.block(readTimeoutMs)) {
+        // We're timing out, but since the operation is still ongoing we'll need to replace
+        // readBuffer to avoid the possibility of it being written to by this operation during a
+        // subsequent request.
+        readBuffer = null;
+        throw new HttpDataSourceException(
+            new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
+      } else if (exception != null) {
+        throw new HttpDataSourceException(exception, currentDataSpec,
+            HttpDataSourceException.TYPE_READ);
+      } else if (finished) {
+        return C.RESULT_END_OF_INPUT;
       } else {
-        // Check content length.
-        contentLength = getContentLength(info.getAllHeaders());
-        // If a specific length is requested and a specific length is returned but the 2 don't match
-        // it's an error.
-        if (currentDataSpec.length != C.LENGTH_UNBOUNDED
-            && contentLength != C.LENGTH_UNBOUNDED
-            && currentDataSpec.length != contentLength) {
-          throw new OpenException("Content length did not match requested length", currentDataSpec,
-              getCurrentRequestStatus());
+        // The operation didn't time out, fail or finish, and therefore data must have been read.
+        readBuffer.flip();
+        Assertions.checkState(readBuffer.hasRemaining());
+        if (bytesToSkip > 0) {
+          int bytesSkipped = (int) Math.min(readBuffer.remaining(), bytesToSkip);
+          readBuffer.position(readBuffer.position() + bytesSkipped);
+          bytesToSkip -= bytesSkipped;
         }
       }
-
-      if (contentLength > 0) {
-        expectedBytesRemainingToRead = new AtomicLong(contentLength);
-      }
-
-      // Keep track of redirects.
-      currentUrl = responseInfo.getUrl();
-      connectionState = CONNECTED_CONNECTION;
-    } catch (HttpDataSourceException e) {
-      exception = e;
-    } finally {
-      operation.open();
-      TraceUtil.endSection();
     }
-  }
 
-  /**
-   * Returns {@code true} iff the content is compressed.
-   *
-   * <p>If {@code true}, clients cannot use the value of content length from the request headers to
-   * read the data, since Cronet returns the uncompressed data and this content length reflects the
-   * compressed content length.
-   */
-  private boolean isCompressed(UrlResponseInfo info) {
-    for (Map.Entry<String, String> entry : info.getAllHeadersAsList()) {
-      if (entry.getKey().equalsIgnoreCase("Content-Encoding")) {
-        return !entry.getValue().equalsIgnoreCase("identity");
-      }
-    }
+    int bytesRead = Math.min(readBuffer.remaining(), readLength);
+    readBuffer.get(buffer, offset, bytesRead);
 
-    return false;
-  }
-
-  private void validateResponse(UrlResponseInfo info) throws HttpDataSourceException {
-    // Check for a valid response code.
-    int responseCode = info.getHttpStatusCode();
-    if (responseCode < 200 || responseCode > 299) {
-      throw new HttpDataSource.InvalidResponseCodeException(
-          responseCode,
-          info.getAllHeaders(),
-          currentDataSpec);
+    if (bytesRemaining != C.LENGTH_UNBOUNDED) {
+      bytesRemaining -= bytesRead;
     }
-    // Check for a valid content type.
-    try {
-      String contentType = info.getAllHeaders().get("Content-Type").get(0);
-      if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
-        throw new HttpDataSource.InvalidContentTypeException(contentType, currentDataSpec);
-      }
-    } catch (IndexOutOfBoundsException e) {
-      throw new HttpDataSource.InvalidContentTypeException(null, currentDataSpec);
+    if (listener != null) {
+      listener.onBytesTransferred(bytesRead);
     }
+    return bytesRead;
   }
 
-  private long getContentLength(Map<String, List<String>> headers) {
-    // Logic copied from {@code DefaultHttpDataSource}
-    long contentLength = C.LENGTH_UNBOUNDED;
-    List<String> contentLengthHeader = headers.get("Content-Length");
-    if (contentLengthHeader != null
-        && !contentLengthHeader.isEmpty()
-        && !TextUtils.isEmpty(contentLengthHeader.get(0))) {
-      try {
-        contentLength = Long.parseLong(contentLengthHeader.get(0));
-      } catch (NumberFormatException e) {
-        log(Log.ERROR, "Unexpected Content-Length [" + contentLengthHeader + "]");
-      }
+  @Override
+  public synchronized void close() {
+    if (currentUrlRequest != null) {
+      currentUrlRequest.cancel();
+      currentUrlRequest = null;
     }
-    List<String> contentRangeHeader = headers.get("Content-Range");
-    if (contentRangeHeader != null
-        && !contentRangeHeader.isEmpty()
-        && !TextUtils.isEmpty(contentRangeHeader.get(0))) {
-      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader.get(0));
-      if (matcher.find()) {
-        try {
-          long contentLengthFromRange =
-              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
-          if (contentLength < 0) {
-            // Some proxy servers strip the Content-Length header. Fall back to the length
-            // calculated here in this case.
-            contentLength = contentLengthFromRange;
-          } else if (contentLength != contentLengthFromRange) {
-            // If there is a discrepancy between the Content-Length and Content-Range headers,
-            // assume the one with the larger value is correct. We have seen cases where carrier
-            // change one of them to reduce the size of a request, but it is unlikely anybody
-            // would increase it.
-            log(Log.WARN, "Inconsistent headers [" + contentLengthHeader + "] ["
-                + contentRangeHeader + "]");
-            contentLength = Math.max(contentLength, contentLengthFromRange);
-          }
-        } catch (NumberFormatException e) {
-          log(Log.ERROR, "Unexpected Content-Range [" + contentRangeHeader + "]");
-        }
-      }
+    if (readBuffer != null) {
+      readBuffer.limit(0);
     }
-    return contentLength;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.read");
-    try {
-      synchronized (this) {
-        if (connectionState != OPEN_CONNECTION) {
-          throw new IllegalStateException("Connection not ready");
-        }
+    currentDataSpec = null;
+    responseInfo = null;
+    exception = null;
+    finished = false;
+    if (opened) {
+      opened = false;
+      if (listener != null) {
+        listener.onTransferEnd();
       }
-
-      // If being asked to read beyond the amount of bytes initially requested, return
-      // RESULT_END_OF_INPUT.
-      if (expectedBytesRemainingToRead != null && expectedBytesRemainingToRead.get() <= 0) {
-        return C.RESULT_END_OF_INPUT;
-      }
-
-      if (!hasData) {
-        // Read more data from cronet.
-        operation.close();
-        currentUrlRequest.read(readBuffer);
-        if (!operation.block(readTimeoutMs)) {
-          throw new HttpDataSourceException(
-              new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
-        }
-        if (exception != null) {
-          throw exception;
-        }
-        // The expected response length is unknown, but cronet has indicated that the request
-        // already finished successfully.
-        if (responseFinished) {
-          return C.RESULT_END_OF_INPUT;
-        }
-      }
-
-      int bytesRead = Math.min(readBuffer.remaining(), readLength);
-
-      readBuffer.get(buffer, offset, bytesRead);
-
-      if (!readBuffer.hasRemaining()) {
-        readBuffer.clear();
-        hasData = false;
-      }
-
-      if (expectedBytesRemainingToRead != null) {
-        expectedBytesRemainingToRead.addAndGet(-bytesRead);
-      }
-
-      if (transferListener != null && bytesRead >= 0) {
-        transferListener.onBytesTransferred(bytesRead);
-      }
-      return bytesRead;
-    } finally {
-      TraceUtil.endSection();
     }
   }
 
+  // UrlRequest.Callback implementation
+
   @Override
-  public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
+  public synchronized void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
+      String newLocationUrl) {
     if (request != currentUrlRequest) {
       return;
     }
@@ -447,8 +353,8 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
       // For other redirect response codes the POST request is converted to a GET request and the
       // redirect is followed.
       if (responseCode == 307 || responseCode == 308) {
-        exception = new OpenException("POST request redirected with 307 or 308 response code",
-            currentDataSpec, getCurrentRequestStatus());
+        exception = new InvalidResponseCodeException(responseCode, info.getAllHeaders(),
+            currentDataSpec);
         operation.open();
         return;
       }
@@ -460,78 +366,74 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
   }
 
   @Override
-  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
-      ByteBuffer buffer) {
+  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
     if (request != currentUrlRequest) {
       return;
     }
-    readBuffer.flip();
-    if (readBuffer.limit() > 0) {
-      hasData = true;
-    }
+    responseInfo = info;
     operation.open();
   }
 
   @Override
-  public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
+      ByteBuffer buffer) {
     if (request != currentUrlRequest) {
       return;
     }
-    responseFinished = true;
     operation.open();
   }
 
   @Override
-  public synchronized void close() {
-    TraceUtil.beginSection("CronetDataSource.close");
-    try {
-      if (currentUrlRequest != null) {
-        currentUrlRequest.cancel();
-        currentUrlRequest = null;
-      }
-      readBuffer.clear();
-      currentDataSpec = null;
-      currentUrl = null;
-      exception = null;
-      contentLength = 0;
-      hasData = false;
-      responseInfo = null;
-      expectedBytesRemainingToRead = null;
-      responseFinished = false;
-      if (transferListener != null && connectionState == OPEN_CONNECTION) {
-        transferListener.onTransferEnd();
-      }
-    } finally {
-      connectionState = IDLE_CONNECTION;
-      TraceUtil.endSection();
+  public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    finished = true;
+    operation.open();
   }
 
   @Override
-  public String getUri() {
-    return currentUrl;
-  }
-
-  private void log(int priority, String message) {
-    if (Log.isLoggable(TAG, priority)) {
-      Log.println(priority, TAG, message);
+  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
+      UrlRequestException error) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
+        ? new UnknownHostException() : error;
+    operation.open();
   }
 
-  private int getCurrentRequestStatus() {
-    if (currentUrlRequest == null) {
-      return UrlRequest.Status.IDLE;
+  // Internal methods.
+
+  private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
+    UrlRequest.Builder requestBuilder = new UrlRequest.Builder(dataSpec.uri.toString(), this,
+        executor, cronetEngine);
+    // Set the headers.
+    synchronized (requestProperties) {
+      if (dataSpec.postBody != null && !requestProperties.containsKey(CONTENT_TYPE)) {
+        throw new OpenException("POST request must set Content-Type", dataSpec, Status.IDLE);
+      }
+      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
+        requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+      }
     }
-    final ConditionVariable conditionVariable = new ConditionVariable();
-    final AtomicInteger result = new AtomicInteger();
-    currentUrlRequest.getStatus(new UrlRequest.StatusListener() {
-      @Override
-      public void onStatus(int status) {
-        result.set(status);
-        conditionVariable.open();
+    // Set the Range header.
+    if (currentDataSpec.position != 0 || currentDataSpec.length != C.LENGTH_UNBOUNDED) {
+      StringBuilder rangeValue = new StringBuilder();
+      rangeValue.append("bytes=");
+      rangeValue.append(currentDataSpec.position);
+      rangeValue.append("-");
+      if (currentDataSpec.length != C.LENGTH_UNBOUNDED) {
+        rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
       }
-    });
-    return result.get();
+      requestBuilder.addHeader("Range", rangeValue.toString());
+    }
+    // Set the body.
+    if (dataSpec.postBody != null) {
+      requestBuilder.setUploadDataProvider(new ByteArrayUploadDataProvider(dataSpec.postBody),
+          executor);
+    }
+    return requestBuilder.build();
   }
 
   private boolean blockUntilConnectTimeout() {
@@ -548,4 +450,75 @@ private void resetConnectTimeout() {
     currentConnectTimeoutMs = clock.elapsedRealtime() + connectTimeoutMs;
   }
 
+  private static boolean getIsCompressed(UrlResponseInfo info) {
+    for (Map.Entry<String, String> entry : info.getAllHeadersAsList()) {
+      if (entry.getKey().equalsIgnoreCase("Content-Encoding")) {
+        return !entry.getValue().equalsIgnoreCase("identity");
+      }
+    }
+    return false;
+  }
+
+  private static long getContentLength(UrlResponseInfo info) {
+    long contentLength = C.LENGTH_UNBOUNDED;
+    Map<String, List<String>> headers = info.getAllHeaders();
+    List<String> contentLengthHeaders = headers.get("Content-Length");
+    String contentLengthHeader = null;
+    if (!isEmpty(contentLengthHeaders)) {
+      contentLengthHeader = contentLengthHeaders.get(0);
+      if (!TextUtils.isEmpty(contentLengthHeader)) {
+        try {
+          contentLength = Long.parseLong(contentLengthHeader);
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
+        }
+      }
+    }
+    List<String> contentRangeHeaders = headers.get("Content-Range");
+    if (!isEmpty(contentRangeHeaders)) {
+      String contentRangeHeader = contentRangeHeaders.get(0);
+      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader);
+      if (matcher.find()) {
+        try {
+          long contentLengthFromRange =
+              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+          if (contentLength < 0) {
+            // Some proxy servers strip the Content-Length header. Fall back to the length
+            // calculated here in this case.
+            contentLength = contentLengthFromRange;
+          } else if (contentLength != contentLengthFromRange) {
+            // If there is a discrepancy between the Content-Length and Content-Range headers,
+            // assume the one with the larger value is correct. We have seen cases where carrier
+            // change one of them to reduce the size of a request, but it is unlikely anybody
+            // would increase it.
+            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
+                + "]");
+            contentLength = Math.max(contentLength, contentLengthFromRange);
+          }
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
+        }
+      }
+    }
+    return contentLength;
+  }
+
+  private static int getStatus(UrlRequest request) {
+    final ConditionVariable conditionVariable = new ConditionVariable();
+    final int[] statusHolder = new int[1];
+    request.getStatus(new UrlRequest.StatusListener() {
+      @Override
+      public void onStatus(int status) {
+        statusHolder[0] = status;
+        conditionVariable.open();
+      }
+    });
+    conditionVariable.block();
+    return statusHolder[0];
+  }
+
+  private static boolean isEmpty(List<?> list) {
+    return list == null || list.isEmpty();
+  }
+
 }
