diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 065f30d45b..8e1f1cf03a 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -58,6 +58,9 @@ private DecoderQueryException(Throwable cause) {
 
   private static final Map<CodecKey, List<DecoderInfo>> decoderInfosCache = new HashMap<>();
 
+  // Lazily initialized.
+  private static int maxH264DecodableFrameSize = -1;
+
   private MediaCodecUtil() {}
 
   /**
@@ -290,14 +293,15 @@ public static boolean isH264ProfileSupported(int profile, int level)
    * @return the maximum frame size for an H264 stream that can be decoded on the device.
    */
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
-    DecoderInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
-    if (decoderInfo == null) {
-      return 0;
-    }
-    int maxH264DecodableFrameSize = 0;
-    for (CodecProfileLevel profileLevel : decoderInfo.capabilities.profileLevels) {
-      maxH264DecodableFrameSize = Math.max(
-          avcLevelToMaxFrameSize(profileLevel.level), maxH264DecodableFrameSize);
+    if (maxH264DecodableFrameSize == -1) {
+      int result = 0;
+      DecoderInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
+      if (decoderInfo != null) {
+        for (CodecProfileLevel profileLevel : decoderInfo.capabilities.profileLevels) {
+          result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
+        }
+      }
+      maxH264DecodableFrameSize = result;
     }
     return maxH264DecodableFrameSize;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index b2f1c39f37..c313a289f9 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -94,14 +94,12 @@
       int viewportWidth, int viewportHeight) throws DecoderQueryException {
     int maxVideoPixelsToRetain = Integer.MAX_VALUE;
     ArrayList<Integer> selectedIndexList = new ArrayList<>();
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
 
     // First pass to filter out formats that individually fail to meet the selection criteria.
     int formatWrapperCount = formatWrappers.size();
     for (int i = 0; i < formatWrapperCount; i++) {
       Format format = formatWrappers.get(i).getFormat();
-      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats,
-          maxDecodableFrameSize)) {
+      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats)) {
         // Select the format for now. It may still be filtered in the second pass below.
         selectedIndexList.add(i);
         // Keep track of the number of pixels of the selected format whose resolution is the
@@ -141,7 +139,7 @@
    * whether HD formats should be filtered and a maximum decodable frame size in pixels.
    */
   private static boolean isFormatPlayable(Format format, String[] allowedContainerMimeTypes,
-      boolean filterHdFormats, int maxDecodableFrameSize) throws DecoderQueryException {
+      boolean filterHdFormats) throws DecoderQueryException {
     if (allowedContainerMimeTypes != null
         && !Util.contains(allowedContainerMimeTypes, format.mimeType)) {
       // Filtering format based on its container mime type.
@@ -167,7 +165,7 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
         }
       }
       // Assume the video is H.264.
-      if (format.width * format.height > maxDecodableFrameSize) {
+      if (format.width * format.height > MediaCodecUtil.maxH264DecodableFrameSize()) {
         // Filtering format because it exceeds the maximum decodable frame size.
         return false;
       }
