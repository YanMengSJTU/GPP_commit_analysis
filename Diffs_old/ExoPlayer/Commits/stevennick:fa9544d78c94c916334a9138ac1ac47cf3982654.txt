diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index d22a45ce88..99c1e34614 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -26,6 +26,8 @@
  */
 public class DecoderInputBuffer extends Buffer {
 
+  public final int format;
+
   /**
    * The buffer replacement mode, which may disable replacement.
    */
@@ -78,8 +80,18 @@ public static DecoderInputBuffer newFlagsOnlyInstance() {
    *     {@link #BUFFER_REPLACEMENT_MODE_DIRECT}.
    */
   public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
+    this(bufferReplacementMode, C.TRACK_TYPE_UNKNOWN);
+  }
+
+  /**
+   * @param bufferReplacementMode Determines the behavior of {@link #ensureSpaceForWrite(int)}. One
+   *     of {@link #BUFFER_REPLACEMENT_MODE_DISABLED}, {@link #BUFFER_REPLACEMENT_MODE_NORMAL} and
+   *     {@link #BUFFER_REPLACEMENT_MODE_DIRECT}.
+   */
+  public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode, int format) {
     this.cryptoInfo = new CryptoInfo();
     this.bufferReplacementMode = bufferReplacementMode;
+    this.format = format;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index 3b0c73e979..e7903bc783 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -203,6 +203,22 @@ public int getReadIndex() {
     return infoQueue.getReadIndex();
   }
 
+  /**
+   * Returns the current queue size.
+   */
+  public int getQueueSize() {
+    return infoQueue.getQueueSize();
+  }
+
+  /**
+   * Returns current queued time frame in us.
+   * @param index
+   * @return
+   */
+  public long getQueuedFrameTimeUs(int index) {
+    return infoQueue.getQueuedFrameTimeUs(index);
+  }
+
   /**
    * Peeks the source id of the next sample, or the current upstream source id if the buffer is
    * empty.
@@ -299,7 +315,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolea
           }
           // Write the sample data into the holder.
           buffer.ensureSpaceForWrite(extrasHolder.size);
-          readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+          readData(extrasHolder.offset, buffer.data, extrasHolder.size, buffer.format);
           // Advance the read head.
           dropDownstreamTo(extrasHolder.nextOffset);
         }
@@ -391,26 +407,44 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
    * @param target The buffer into which data should be written.
    * @param length The number of bytes to read.
    */
-  private void readData(long absolutePosition, ByteBuffer target, int length) {
+  private void readData(long absolutePosition, ByteBuffer target, int length, int format) {
     int remaining = length;
     String logMessage = "";
-    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
-    Log.d(TAG, logMessage);
-    TraceUtil.beginSection(logMessage);
+    String type;
+    switch(format) {
+      case C.TRACK_TYPE_AUDIO:
+        type = "audio";
+        break;
+      case C.TRACK_TYPE_VIDEO:
+        type = "video";
+        break;
+      case C.TRACK_TYPE_METADATA:
+        type = "metadata";
+        break;
+      case C.TRACK_TYPE_DEFAULT:
+        type = "default";
+        break;
+      case C.TRACK_TYPE_TEXT:
+        type = "text";
+        break;
+      default:
+        type = "unknown";
+        break;
+    }
+
     while (remaining > 0) {
       dropDownstreamTo(absolutePosition);
       int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
       int toCopy = Math.min(remaining, allocationLength - positionInAllocation);
       Allocation allocation = dataQueue.peek();
-      logMessage = "readData(from allocation #" +allocation.id + ")[absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
-      Log.d(TAG, logMessage);
+//      logMessage = "readData(allocation #" +allocation.id + " -> DecodeInputBuffer.ByteBuffer)[format=" + type + ", absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
+//      Log.d(TAG, logMessage);
       target.put(allocation.data, allocation.translateOffset(positionInAllocation), toCopy);
       absolutePosition += toCopy;
       remaining -= toCopy;
     }
-    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[FIN, absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
-    Log.d(TAG, logMessage);
-    TraceUtil.endSection();
+//    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[FIN, format=" + type + ", absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
+//    Log.d(TAG, logMessage);
   }
 
   /**
@@ -442,7 +476,7 @@ private void readData(long absolutePosition, byte[] target, int length) {
    */
   private void dropDownstreamTo(long absolutePosition) {
     String logMessage = "DefaultTrackOutput.dropDownstreamTo(" + absolutePosition + ")";
-    Log.d(TAG, logMessage);
+//    Log.d(TAG, logMessage);
     TraceUtil.beginSection(logMessage);
     int relativePosition = (int) (absolutePosition - totalBytesDropped);
     int allocationIndex = relativePosition / allocationLength;
@@ -661,6 +695,7 @@ private static Format getAdjustedSampleFormat(Format format, long sampleOffsetUs
     private Format upstreamFormat;
     private int upstreamSourceId;
     private final String TAG = "TrackOutput.InfoQueue";
+    private long frameCount;
 
     public InfoQueue() {
       capacity = SAMPLE_CAPACITY_INCREMENT;
@@ -675,6 +710,7 @@ public InfoQueue() {
       largestQueuedTimestampUs = Long.MIN_VALUE;
       upstreamFormatRequired = true;
       upstreamKeyframeRequired = true;
+      frameCount = 0;
     }
 
     public void clearSampleData() {
@@ -761,6 +797,22 @@ public synchronized boolean isEmpty() {
       return queueSize == 0;
     }
 
+    /**
+     * Return current queue size.
+     */
+    public synchronized int getQueueSize() {
+      return queueSize;
+    }
+
+    /**
+     * Return current queued frame time in us time.
+     * @param index
+     * @return
+     */
+    public synchronized long getQueuedFrameTimeUs(int index) {
+      return timesUs[index];
+    }
+
     /**
      * Returns the upstream {@link Format} in which samples are being queued.
      */
@@ -834,7 +886,7 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
       extrasHolder.size = sizes[relativeReadIndex];
       extrasHolder.offset = offsets[relativeReadIndex];
       extrasHolder.encryptionKeyId = encryptionKeys[relativeReadIndex];
-      String logMessage = "BufferExtractsHolder[size=" +extrasHolder.size+ ", offset="+extrasHolder.offset+"], relaIndex= " +relativeReadIndex+ ", timeUs=" + buffer.timeUs +", largeDeqTimestampUs=" + largestDequeuedTimestampUs;
+      String logMessage = "BufferExtractsHolder[format=" + formats[relativeReadIndex].sampleMimeType + ", size=" +extrasHolder.size+ ", offset="+extrasHolder.offset+"], relaIndex= " +relativeReadIndex+ ", timeUs=" + buffer.timeUs +", largeDeqTimestampUs=" + largestDequeuedTimestampUs;
       Log.d(TAG, logMessage);
       largestDequeuedTimestampUs = Math.max(largestDequeuedTimestampUs, buffer.timeUs);
       queueSize--;
@@ -952,7 +1004,8 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       sourceIds[relativeWriteIndex] = upstreamSourceId;
       // Increment the write index.
       queueSize++;
-      Log.d(TAG, "commitSample[timeUs="+timeUs+", relativeWriteIndex="+relativeWriteIndex+ ", sampleFlags="+sampleFlags+", offset="+offset+", size="+size+", queueSize="+ queueSize + "]");
+      frameCount  = frameCount + 1;
+      Log.d(TAG, "commitSample[format=" + upstreamFormat.sampleMimeType + ", timeUs="+timeUs+", relativeWriteIndex="+relativeWriteIndex+ ", sampleFlags="+sampleFlags+", offset="+offset+", size="+size+", queueSize="+ queueSize + ", frameCount=" + frameCount + "]");
       if (queueSize == capacity) {
         // Increase the capacity.
         int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 222031d505..94ef1ab4fd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -229,7 +229,7 @@ public MediaCodecRenderer(int trackType, MediaCodecSelector mediaCodecSelector,
     this.mediaCodecSelector = Assertions.checkNotNull(mediaCodecSelector);
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
-    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
+    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED, trackType);
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     formatHolder = new FormatHolder();
     decodeOnlyPresentationTimestamps = new ArrayList<>();
@@ -711,7 +711,28 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
 //      Log.d(TAG, "Queue input bufferIndex @" + inputIndex + " with ByteBuffer: " + buffer.data.hashCode());
       buffer.flip();
 //      Log.d(TAG, "New ByteBuffer bufferIndex @" + inputIndex + " hash: " + buffer.data.hashCode());
-      Log.d(TAG, "ByteBuffer bufferIndex @" + inputIndex + " queued.");
+      String type;
+      switch(buffer.format) {
+        case C.TRACK_TYPE_AUDIO:
+          type = "audio";
+          break;
+        case C.TRACK_TYPE_VIDEO:
+          type = "video";
+          break;
+        case C.TRACK_TYPE_METADATA:
+          type = "metadata";
+          break;
+        case C.TRACK_TYPE_DEFAULT:
+          type = "default";
+                  break;
+        case C.TRACK_TYPE_TEXT:
+          type = "text";
+          break;
+        default:
+          type = "unknown";
+          break;
+      }
+      Log.d(TAG, type + " ByteBuffer bufferIndex @" + inputIndex + " queued.[timeUs=" + buffer.timeUs +"]");
       onQueueInputBuffer(buffer);
 
       if (bufferEncrypted) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 67cf190bfa..976f1ac3ac 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -86,6 +86,7 @@
   private long durationUs;
   private boolean[] trackEnabledStates;
   private boolean[] trackIsAudioVideoFlags;
+  private boolean[] trackIsVideoFlags;
   private boolean haveAudioVideoTracks;
   private long length;
 
@@ -96,6 +97,9 @@
   private boolean loadingFinished;
   private boolean released;
   private final String TAG = "ExtractorMediaPeriod";
+  private final boolean makeSureConstantLatency = false;
+  private final int framesize = 10;
+  private final int fps = 30;
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -269,6 +273,23 @@ public long readDiscontinuity() {
     return C.TIME_UNSET;
   }
 
+  /**
+   * Get current buffered video frame size.
+   * Only selected video track size will be considered.
+   */
+  public int getBufferedVideoFrameSize() {
+    int frameSize = 0;
+    if(!prepared) { return frameSize; }
+    int trackCount = sampleQueues.size();
+    for (int i = 0; i < trackCount; i++) {
+      if (trackIsVideoFlags[i] && trackEnabledStates[i]) {
+        frameSize = Math.max(frameSize,
+        sampleQueues.valueAt(i).getQueueSize());
+      }
+    }
+    return frameSize;
+  }
+
   @Override
   public long getBufferedPositionUs() {
     if (loadingFinished) {
@@ -445,6 +466,7 @@ private void maybeFinishPrepare() {
     TrackGroup[] trackArray = new TrackGroup[trackCount];
     trackIsAudioVideoFlags = new boolean[trackCount];
     trackEnabledStates = new boolean[trackCount];
+    trackIsVideoFlags = new boolean[trackCount];
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
       Format trackFormat = sampleQueues.valueAt(i).getUpstreamFormat();
@@ -453,6 +475,7 @@ private void maybeFinishPrepare() {
       boolean isAudioVideo = MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
       trackIsAudioVideoFlags[i] = isAudioVideo;
       haveAudioVideoTracks |= isAudioVideo;
+      trackIsVideoFlags[i] = MimeTypes.isVideo(mimeType);
     }
     tracks = new TrackGroupArray(trackArray);
     prepared = true;
@@ -623,6 +646,28 @@ public void setLoadPosition(long position, long timeUs) {
       pendingExtractorSeek = true;
     }
 
+    /**
+     *
+     * @param frameSize
+     * @param fps
+     */
+    private void limitLatency(int frameSize, int fps) {
+      long largestQueuedTimestampUs = getBufferedPositionUs();
+      int currentQueuedFrameSize = getBufferedVideoFrameSize();
+      if (currentQueuedFrameSize > frameSize) {
+        // Skip frames to under frame size defined in frameSize.
+        int track = sampleQueues.size();
+        for(int index = 0; index < track; index++) {
+          long nextPositionUs = largestQueuedTimestampUs - (100000 / fps * frameSize);
+          String logMessage= "extractor.load[SKIP, queuedFrameSize=" + currentQueuedFrameSize +", largestQueuedTimestampUs=" + largestQueuedTimestampUs + ", nextPositionUs=" +nextPositionUs+ "]";
+          Log.d(TAG, logMessage);
+          if(trackIsAudioVideoFlags[index] && trackEnabledStates[index]) {
+            skipData(index, nextPositionUs);
+          }
+        }
+      }
+    }
+
     @Override
     public void cancelLoad() {
       loadCanceled = true;
@@ -657,7 +702,7 @@ public void load() throws IOException, InterruptedException {
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
           }
-          logMessage= "extractor.read[inputPos=" + input.getPosition() +", initPos=" + position + "]";
+          logMessage= "extractor.read[START, inputPos=" + input.getPosition() +", initPos=" + position + "]";
           Log.d(TAG, logMessage);
           TraceUtil.beginSection(logMessage);
           while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
@@ -668,9 +713,12 @@ public void load() throws IOException, InterruptedException {
               loadCondition.close();
               handler.post(onContinueLoadingRequestedRunnable);
             }
+            if (makeSureConstantLatency) {
+              this.limitLatency(framesize, fps);
+            }
           }
           TraceUtil.endSection();
-          logMessage= "extractor.read[inputPos=" + input.getPosition() +", initPos=" + position + "]";
+          logMessage= "extractor.read[PAUSE, inputPos=" + input.getPosition() +", initPos=" + position + "]";
           Log.d(TAG, logMessage);
         } finally {
           if (result == Extractor.RESULT_SEEK) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index a1abfe5dbc..d09204dcc8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -62,7 +62,7 @@
   private static final int[] STANDARD_LONG_EDGE_VIDEO_PX = new int[] {
       1920, 1600, 1440, 1280, 960, 854, 640, 540, 480};
 
-  private final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
+  protected final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
@@ -74,7 +74,7 @@
   private Surface surface;
   @C.VideoScalingMode
   private int scalingMode;
-  private boolean renderedFirstFrame;
+  protected boolean renderedFirstFrame;
   private long joiningDeadlineMs;
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrames;
@@ -495,14 +495,14 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
     return earlyUs < -30000;
   }
 
-  private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
+  protected void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("MediaCodecVideoRenderer.skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
     decoderCounters.skippedOutputBufferCount++;
   }
 
-  private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
+  protected void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("MediaCodecVideoRenderer.dropVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
@@ -516,7 +516,7 @@ private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     }
   }
 
-  private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
+  protected void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     maybeNotifyVideoSizeChanged();
     TraceUtil.beginSection("MediaCodecVideoRenderer.releaseOutputBuffer");
     codec.releaseOutputBuffer(bufferIndex, true);
@@ -527,9 +527,9 @@ private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
   }
 
   @TargetApi(21)
-  private void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
+  protected void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
-    String logMessage = "release video output buffer with bufferIndex @" + bufferIndex;
+    String logMessage = "Release video output buffer with bufferIndex @" + bufferIndex + "[rendered=" + (decoderCounters.renderedOutputBufferCount + 1) + "]";
     Log.d(TAG, logMessage);
     TraceUtil.beginSection(logMessage);
     codec.releaseOutputBuffer(bufferIndex, releaseTimeNs);
