diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 816cce4233..6d1e21957f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,7 +1,20 @@
-# How to Contribute #
+# How to contribute #
 
-We'd love to hear your feedback. Please open new issues describing any bugs,
-feature requests or suggestions that you have.
+## Reporting issues ##
+
+We use the [GitHub issue tracker](https://github.com/google/ExoPlayer/issues)
+to track bugs, feature requests and questions.
+
+Before filing a new issue, please search the tracker to check if it's already
+covered by an existing report. Avoiding duplicates helps us maximize the time we
+can spend fixing bugs and adding new features.
+
+If you're filing a bug, be sure to provide enough information for us to
+efficiently diagnose and reproduce the problem.
+[Reporting an issue](https://google.github.io/ExoPlayer/2015/10/01/reporting-issues.html)
+gives some examples of what to include.
+
+## Pull requests ##
 
 We will also consider high quality pull requests. These should normally merge
 into the [dev][] branch rather than master. To contribute in this way you must
@@ -9,11 +22,10 @@ first submit a Contributor License Agreement, as described below.
 
 [dev]: https://github.com/google/ExoPlayer/tree/dev
 
-
-## Contributor License Agreement ##
+## Contributor license agreement ##
 
 Contributions to any Google project must be accompanied by a Contributor
-License Agreement.  This is not a copyright **assignment**, it simply gives
+License Agreement. This is not a copyright **assignment**, it simply gives
 Google permission to use and redistribute your contributions as part of the
 project.
 
diff --git a/README.md b/README.md
index 982ccaee34..8ed742d69e 100644
--- a/README.md
+++ b/README.md
@@ -31,8 +31,7 @@ Read news, hints and tips on the [news][] page.
 The easiest way to get started using ExoPlayer is by including the following in
 your project's `build.gradle` file:
 
-```
-gradle
+```gradle
 compile 'com.google.android.exoplayer:exoplayer:rX.X.X'
 ```
 
@@ -47,8 +46,7 @@ project's [Releases][]. For more details, see the project on [Bintray][].
 ExoPlayer can also be built from source using Gradle. You can include it as a
 dependent project like so:
 
-```
-gradle
+```gradle
 // settings.gradle
 include ':app', ':..:ExoPlayer:library'
 
@@ -62,8 +60,7 @@ dependencies {
 
 If you want to use ExoPlayer as a jar, run:
 
-```
-sh
+```sh
 ./gradlew jarRelease
 ```
 
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 3a18119fdd..d8be58a59a 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,16 @@
 # Release notes #
 
+### r1.5.6 ###
+
+* MP3: Fix mono streams playing at 2x speed on some MediaTek based devices (#801).
+* MP3: Fix playback of some streams when stream length is unknown.
+* ID3: Support multiple frames of the same type in a single tag.
+* EIA608: Correctly handle repeated control characters, fixing an issue in which captions would
+  immediately disappear.
+* AVC3: Fix decoder failures on some MediaTek devices in the case where the first buffer fed to the
+  decoder does not start with SPS/PPS NAL units.
+* Misc bug fixes.
+
 ### r1.5.5 ###
 
 * DASH: Enable MP4 embedded WebVTT playback (#1185)
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index a7c1072663..6a49b8804b 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1505"
-    android:versionName="1.5.5"
+    android:versionCode="1506"
+    android:versionName="1.5.6"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index e41398b734..d1813c72ea 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -30,9 +30,10 @@
 import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
 import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
 import com.google.android.exoplayer.drm.UnsupportedDrmException;
-import com.google.android.exoplayer.metadata.GeobMetadata;
-import com.google.android.exoplayer.metadata.PrivMetadata;
-import com.google.android.exoplayer.metadata.TxxxMetadata;
+import com.google.android.exoplayer.metadata.id3.GeobFrame;
+import com.google.android.exoplayer.metadata.id3.Id3Frame;
+import com.google.android.exoplayer.metadata.id3.PrivFrame;
+import com.google.android.exoplayer.metadata.id3.TxxxFrame;
 import com.google.android.exoplayer.text.CaptionStyleCompat;
 import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleLayout;
@@ -74,7 +75,6 @@
 import java.net.CookiePolicy;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 
 /**
  * An activity that plays media using {@link DemoPlayer}.
@@ -605,23 +605,21 @@ public void onCues(List<Cue> cues) {
   // DemoPlayer.MetadataListener implementation
 
   @Override
-  public void onId3Metadata(Map<String, Object> metadata) {
-    for (Map.Entry<String, Object> entry : metadata.entrySet()) {
-      if (TxxxMetadata.TYPE.equals(entry.getKey())) {
-        TxxxMetadata txxxMetadata = (TxxxMetadata) entry.getValue();
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s, value=%s",
-            TxxxMetadata.TYPE, txxxMetadata.description, txxxMetadata.value));
-      } else if (PrivMetadata.TYPE.equals(entry.getKey())) {
-        PrivMetadata privMetadata = (PrivMetadata) entry.getValue();
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: owner=%s",
-            PrivMetadata.TYPE, privMetadata.owner));
-      } else if (GeobMetadata.TYPE.equals(entry.getKey())) {
-        GeobMetadata geobMetadata = (GeobMetadata) entry.getValue();
+  public void onId3Metadata(List<Id3Frame> id3Frames) {
+    for (Id3Frame id3Frame : id3Frames) {
+      if (id3Frame instanceof TxxxFrame) {
+        TxxxFrame txxxFrame = (TxxxFrame) id3Frame;
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s, value=%s", txxxFrame.id,
+            txxxFrame.description, txxxFrame.value));
+      } else if (id3Frame instanceof PrivFrame) {
+        PrivFrame privFrame = (PrivFrame) id3Frame;
+        Log.i(TAG, String.format("ID3 TimedMetadata %s: owner=%s", privFrame.id, privFrame.owner));
+      } else if (id3Frame instanceof GeobFrame) {
+        GeobFrame geobFrame = (GeobFrame) id3Frame;
         Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, filename=%s, description=%s",
-            GeobMetadata.TYPE, geobMetadata.mimeType, geobMetadata.filename,
-            geobMetadata.description));
+            geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
       } else {
-        Log.i(TAG, String.format("ID3 TimedMetadata %s", entry.getKey()));
+        Log.i(TAG, String.format("ID3 TimedMetadata %s", id3Frame.id));
       }
     }
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index b22e204f3f..c3c37bde32 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer.hls.HlsSampleSource;
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer.MetadataRenderer;
+import com.google.android.exoplayer.metadata.id3.Id3Frame;
 import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.TextRenderer;
 import com.google.android.exoplayer.upstream.BandwidthMeter;
@@ -48,7 +49,6 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
@@ -60,7 +60,7 @@
     HlsSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
     MediaCodecVideoTrackRenderer.EventListener, MediaCodecAudioTrackRenderer.EventListener,
     StreamingDrmSessionManager.EventListener, DashChunkSource.EventListener, TextRenderer,
-    MetadataRenderer<Map<String, Object>>, DebugTextViewHelper.Provider {
+    MetadataRenderer<List<Id3Frame>>, DebugTextViewHelper.Provider {
 
   /**
    * Builds renderers for the player.
@@ -140,7 +140,7 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
    * A listener for receiving ID3 metadata parsed from the media stream.
    */
   public interface Id3MetadataListener {
-    void onId3Metadata(Map<String, Object> metadata);
+    void onId3Metadata(List<Id3Frame> id3Frames);
   }
 
   // Constants pulled into this class for convenience.
@@ -519,9 +519,9 @@ public void onCues(List<Cue> cues) {
   }
 
   @Override
-  public void onMetadata(Map<String, Object> metadata) {
+  public void onMetadata(List<Id3Frame> id3Frames) {
     if (id3MetadataListener != null && getSelectedTrack(TYPE_METADATA) != TRACK_DISABLED) {
-      id3MetadataListener.onId3Metadata(metadata);
+      id3MetadataListener.onId3Metadata(id3Frames);
     }
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 242faeace4..abc3595476 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -30,8 +30,9 @@
 import com.google.android.exoplayer.hls.HlsPlaylistParser;
 import com.google.android.exoplayer.hls.HlsSampleSource;
 import com.google.android.exoplayer.hls.PtsTimestampAdjusterProvider;
-import com.google.android.exoplayer.metadata.Id3Parser;
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
+import com.google.android.exoplayer.metadata.id3.Id3Frame;
+import com.google.android.exoplayer.metadata.id3.Id3Parser;
 import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.text.eia608.Eia608TrackRenderer;
 import com.google.android.exoplayer.upstream.DataSource;
@@ -47,7 +48,7 @@
 import android.os.Handler;
 
 import java.io.IOException;
-import java.util.Map;
+import java.util.List;
 
 /**
  * A {@link RendererBuilder} for HLS.
@@ -145,7 +146,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
       MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
           MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
           AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
-      MetadataTrackRenderer<Map<String, Object>> id3Renderer = new MetadataTrackRenderer<>(
+      MetadataTrackRenderer<List<Id3Frame>> id3Renderer = new MetadataTrackRenderer<>(
           sampleSource, new Id3Parser(), player, mainHandler.getLooper());
 
       // Build the text renderer, preferring Webvtt where available.
diff --git a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
index b7afa3b77b..376540734c 100644
--- a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
+++ b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.vp9opus"
-    android:versionCode="1505"
-    android:versionName="1.5.5"
+    android:versionCode="1506"
+    android:versionName="1.5.6"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index acffce3f97..ace9a1f05c 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -150,6 +150,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     if (outputStreamEnded) {
       return;
     }
+    this.sourceIsReady = sourceIsReady;
 
     // Try and read a format if we don't have one already.
     if (format == null && !readFormat(positionUs)) {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 6f5fa62b08..2a1b29ef47 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -191,6 +191,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     if (outputStreamEnded) {
       return;
     }
+    this.sourceIsReady = sourceIsReady;
 
     // Try and read a format if we don't have one already.
     if (format == null && !readFormat(positionUs)) {
diff --git a/extensions/vp9/src/main/proguard.cfg b/extensions/vp9/src/main/proguard.cfg
index 28ec41a6b3..41a8b85a7e 100644
--- a/extensions/vp9/src/main/proguard.cfg
+++ b/extensions/vp9/src/main/proguard.cfg
@@ -6,6 +6,6 @@
 }
 
 # Some members of this class are being accessed from native methods. Keep them unobfuscated.
--keep class com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper$OutputBuffer {
+-keep class com.google.android.exoplayer.ext.vp9.VpxOutputBuffer {
     *;
 }
diff --git a/library/build.gradle b/library/build.gradle
index f5ac063ffc..ad4dff4e49 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.5'
+    version = 'r1.5.6'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/assets/webvtt/with_positioning b/library/src/androidTest/assets/webvtt/with_positioning
index e50163a64c..06a81df901 100644
--- a/library/src/androidTest/assets/webvtt/with_positioning
+++ b/library/src/androidTest/assets/webvtt/with_positioning
@@ -26,3 +26,8 @@ NOTE The positioning alignment should be inherited from align.
 00:07.000 --> 00:08.000 position:10% align:end size:10%
 This is the fifth subtitle.
 
+NOTE In newer drafts, align:middle has been replaced by align:center
+
+00:10.000 --> 00:11.000 line:45%,end align:center size:35%
+This is the sixth subtitle.
+
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
index 1365772660..90741612a3 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
@@ -15,14 +15,9 @@
  */
 package com.google.android.exoplayer.extractor.webm;
 
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.testutil.FakeDataSource;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSpec;
-
-import android.net.Uri;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.TestUtil;
 
 import junit.framework.TestCase;
 
@@ -140,22 +135,15 @@ private static void assertEvents(ExtractorInput input, List<String> expectedEven
 
   /**
    * Helper to build an {@link ExtractorInput} from byte data.
-   * <p>
-   * Each argument must be able to cast to a byte value.
    *
    * @param data Zero or more integers with values between {@code 0x00} and {@code 0xFF}.
    * @return An {@link ExtractorInput} from which the data can be read.
-   * @throws IOException If an error occurs creating the input.
    */
-  private static ExtractorInput createTestInput(int... data) throws IOException {
-    byte[] bytes = new byte[data.length];
-    for (int i = 0; i < data.length; i++) {
-      bytes[i] = (byte) data[i];
-    }
-    DataSource dataSource = new FakeDataSource.Builder().appendReadData(bytes).build();
-    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
-    return input;
+  private static ExtractorInput createTestInput(int... data) {
+    return new FakeExtractorInput.Builder()
+        .setData(TestUtil.createByteArray(data))
+        .setSimulateUnknownLength(true)
+        .build();
   }
 
   /**
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
index f50bb6a2f9..d69a44d5d7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
@@ -136,9 +136,9 @@ public StreamBuilder addUnsupportedTrack(byte trackNumber) {
   public StreamBuilder addSimpleBlockEncryptedMedia(int trackNumber, int clusterTimecode,
       int blockTimecode, boolean keyframe, boolean invisible, boolean validSignalByte,
       byte[] data) {
-    byte flags = (byte) ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00));
-    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags,
-        true, validSignalByte, 1, data);
+    int flags = (keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00);
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags, true,
+        validSignalByte, 1, data);
     mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
     return this;
   }
@@ -146,9 +146,9 @@ public StreamBuilder addSimpleBlockEncryptedMedia(int trackNumber, int clusterTi
 
   public StreamBuilder addSimpleBlockMedia(int trackNumber, int clusterTimecode,
       int blockTimecode, boolean keyframe, boolean invisible, byte[] data) {
-    byte flags = (byte) ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00));
-    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags,
-        false, true, 1, data);
+    int flags = (keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00);
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags, false,
+        true, 1, data);
     mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
     return this;
   }
@@ -344,13 +344,13 @@ private static EbmlElement createSimpleBlock(int trackNumber, int timecode, int
     byte[] simpleBlockBytes;
     if (lacingFrameCount > 1) {
       flags |= 0x04; // Fixed-size lacing
-      simpleBlockBytes = TestUtil.createByteArray(
-          0x40, trackNumberBytes[3], // Track number size=2
-          timeBytes[2], timeBytes[3], flags, lacingFrameCount - 1); // Timecode, flags and lacing.
+      simpleBlockBytes = TestUtil.joinByteArrays(
+          new byte[] {0x40, trackNumberBytes[3], timeBytes[2], timeBytes[3]},
+          TestUtil.createByteArray(flags, lacingFrameCount - 1));
     } else {
-      simpleBlockBytes = TestUtil.createByteArray(
-          0x40, trackNumberBytes[3], // Track number size=2
-          timeBytes[2], timeBytes[3], flags); // Timecode and flags
+      simpleBlockBytes = TestUtil.joinByteArrays(
+          new byte[] {0x40, trackNumberBytes[3], timeBytes[2], timeBytes[3]},
+          TestUtil.createByteArray(flags));
     }
     if (encrypted) {
       simpleBlockBytes = TestUtil.joinByteArrays(
@@ -412,10 +412,10 @@ private static EbmlElement createBlock(int trackNumber, int timecode, boolean ke
 
   private static byte[] getIntegerBytes(int value) {
     return TestUtil.createByteArray(
-        (value & 0xFF000000) >> 24,
-        (value & 0x00FF0000) >> 16,
-        (value & 0x0000FF00) >> 8,
-        (value & 0x000000FF));
+        (value >> 24) & 0xFF,
+        (value >> 16) & 0xFF,
+        (value >> 8) & 0xFF,
+        (value) & 0xFF);
   }
 
   private static byte[] getLongBytes(long value) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
index ba498526e7..2fd8bc6f8d 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
@@ -16,26 +16,20 @@
 package com.google.android.exoplayer.extractor.webm;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.testutil.FakeDataSource;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSpec;
-
-import android.net.Uri;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
 
 import junit.framework.TestCase;
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.util.Arrays;
 
 /**
  * Tests for {@link VarintReader}.
  */
-public class VarintReaderTest extends TestCase {
+public final class VarintReaderTest extends TestCase {
 
-  private static final String TEST_URI = "http://www.google.com";
   private static final byte MAX_BYTE = (byte) 0xFF;
 
   private static final byte[] DATA_1_BYTE_0 = new byte[] {(byte) 0x80};
@@ -88,12 +82,10 @@
 
   public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
-    // Build an input, and read to the end.
-    DataSource dataSource = buildDataSource(new byte[1]);
-    dataSource.open(new DataSpec(Uri.parse(TEST_URI)));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
-    int bytesRead = input.read(new byte[1], 0, 1);
-    assertEquals(1, bytesRead);
+    // Build an input with no data.
+    ExtractorInput input = new FakeExtractorInput.Builder()
+        .setSimulateUnknownLength(true)
+        .build();
     // End of input allowed.
     long result = reader.readUnsignedVarint(input, true, false, 8);
     assertEquals(C.RESULT_END_OF_INPUT, result);
@@ -108,9 +100,10 @@ public void testReadVarintEndOfInputAtStart() throws IOException, InterruptedExc
 
   public void testReadVarintExceedsMaximumAllowedLength() throws IOException, InterruptedException {
     VarintReader reader = new VarintReader();
-    DataSource dataSource = buildDataSource(DATA_8_BYTE_0);
-    dataSource.open(new DataSpec(Uri.parse(TEST_URI)));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    ExtractorInput input = new FakeExtractorInput.Builder()
+        .setData(DATA_8_BYTE_0)
+        .setSimulateUnknownLength(true)
+        .build();
     long result = reader.readUnsignedVarint(input, false, true, 4);
     assertEquals(C.RESULT_MAX_LENGTH_EXCEEDED, result);
   }
@@ -189,9 +182,10 @@ public void testReadVarintFlaky() throws IOException, InterruptedException {
 
   private static void testReadVarint(VarintReader reader, boolean removeMask, byte[] data,
       int expectedLength, long expectedValue) throws IOException, InterruptedException {
-    DataSource dataSource = buildDataSource(data);
-    dataSource.open(new DataSpec(Uri.parse(TEST_URI)));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
+    ExtractorInput input = new FakeExtractorInput.Builder()
+        .setData(data)
+        .setSimulateUnknownLength(true)
+        .build();
     long result = reader.readUnsignedVarint(input, false, removeMask, 8);
     assertEquals(expectedLength, input.getPosition());
     assertEquals(expectedValue, result);
@@ -199,45 +193,22 @@ private static void testReadVarint(VarintReader reader, boolean removeMask, byte
 
   private static void testReadVarintFlaky(VarintReader reader, boolean removeMask, byte[] data,
       int expectedLength, long expectedValue) throws IOException, InterruptedException {
-    DataSource dataSource = buildFlakyDataSource(data);
-    ExtractorInput input = null;
-    long position = 0;
+    ExtractorInput input = new FakeExtractorInput.Builder()
+        .setData(data)
+        .setSimulateUnknownLength(true)
+        .setSimulateIOErrors(true)
+        .setSimulatePartialReads(true)
+        .build();
     long result = -1;
     while (result == -1) {
-      dataSource.open(new DataSpec(Uri.parse(TEST_URI), position, C.LENGTH_UNBOUNDED, null));
-      input = new DefaultExtractorInput(dataSource, position, C.LENGTH_UNBOUNDED);
       try {
         result = reader.readUnsignedVarint(input, false, removeMask, 8);
-        position = input.getPosition();
-      } catch (IOException e) {
-        // Expected. We'll try again from the position that the input was advanced to.
-        position = input.getPosition();
-        dataSource.close();
+      } catch (SimulatedIOException e) {
+        // Expected.
       }
     }
     assertEquals(expectedLength, input.getPosition());
     assertEquals(expectedValue, result);
   }
 
-  private static DataSource buildDataSource(byte[] data) {
-    FakeDataSource.Builder builder = new FakeDataSource.Builder();
-    builder.appendReadData(data);
-    return builder.build();
-  }
-
-  private static DataSource buildFlakyDataSource(byte[] data) {
-    FakeDataSource.Builder builder = new FakeDataSource.Builder();
-    builder.appendReadError(new IOException("A"));
-    builder.appendReadData(new byte[] {data[0]});
-    if (data.length > 1) {
-      builder.appendReadError(new IOException("B"));
-      builder.appendReadData(new byte[] {data[1]});
-    }
-    if (data.length > 2) {
-      builder.appendReadError(new IOException("C"));
-      builder.appendReadData(Arrays.copyOfRange(data, 2, data.length));
-    }
-    return builder.build();
-  }
-
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
index 4011a53e9d..206feabed4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -667,7 +667,7 @@ public void testReadSampleWithFixedSizeLacing() throws IOException, InterruptedE
         .addOpusTrack(AUDIO_TRACK_NUMBER, TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
             TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE, TEST_DEFAULT_DURATION_NS)
         .addSimpleBlockMediaWithFixedSizeLacing(2 /* trackNumber */, 0 /* clusterTimecode */,
-            0 /* blockTimecode */, 20, media)
+            0 /* blockTimecode */, 20 /* lacingFrameCount */, media)
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/metadata/Id3ParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
similarity index 63%
rename from library/src/androidTest/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
index 1dead0a139..6946ba3b07 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/metadata/id3/Id3ParserTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.metadata;
+package com.google.android.exoplayer.metadata.id3;
 
 import junit.framework.TestCase;
 
-import java.util.Map;
+import java.util.List;
 
 /**
  * Test for {@link Id3Parser}
@@ -25,19 +25,17 @@
 public class Id3ParserTest extends TestCase {
 
   public void testParseTxxxFrames() {
-    byte[] rawId3 = new byte[] { 73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31,
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31,
         0, 0, 3, 0, 109, 100, 105, 97, 108, 111, 103, 95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50,
-        55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0 };
-
+        55, 54, 54, 52, 95, 115, 116, 97, 114, 116, 0};
     Id3Parser parser = new Id3Parser();
     try {
-      Map<String, Object> metadata = parser.parse(rawId3, rawId3.length);
-      assertNotNull(metadata);
-      assertEquals(1, metadata.size());
-      TxxxMetadata txxx = (TxxxMetadata) metadata.get(TxxxMetadata.TYPE);
-      assertNotNull(txxx);
-      assertEquals("", txxx.description);
-      assertEquals("mdialog_VINDICO1527664_start", txxx.value);
+      List<Id3Frame> id3Frames = parser.parse(rawId3, rawId3.length);
+      assertNotNull(id3Frames);
+      assertEquals(1, id3Frames.size());
+      TxxxFrame txxxFrame = (TxxxFrame) id3Frames.get(0);
+      assertEquals("", txxxFrame.description);
+      assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
     } catch (Exception exception) {
       fail(exception.getMessage());
     }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java
index e128159ef9..8d71dc8ed7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java
@@ -48,7 +48,7 @@
   private int currentSegmentIndex;
   private long bytesRemaining;
 
-  public FakeDataSource(boolean simulateUnknownLength, ArrayList<Segment> segments) {
+  private FakeDataSource(boolean simulateUnknownLength, ArrayList<Segment> segments) {
     this.simulateUnknownLength = simulateUnknownLength;
     this.segments = segments;
     long totalLength = 0;
@@ -163,7 +163,7 @@ public boolean isErrorSegment() {
   /**
    * Builder of {@link FakeDataSource} instances.
    */
-  public static class Builder {
+  public static final class Builder {
 
     private final ArrayList<Segment> segments;
     private boolean simulateUnknownLength;
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorInput.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorInput.java
new file mode 100644
index 0000000000..8b2c43746d
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorInput.java
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import android.util.SparseBooleanArray;
+
+import junit.framework.Assert;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * A fake {@link ExtractorInput} capable of simulating various scenarios.
+ * <p>
+ * Read, skip and peek errors can be simulated using {@link Builder#setSimulateIOErrors}. When
+ * enabled each read and skip will throw a {@link SimulatedIOException} unless one has already been
+ * thrown from the current position. Each peek will throw {@link SimulatedIOException} unless one
+ * has already been thrown from the current peek position. When a {@link SimulatedIOException} is
+ * thrown the read position is left unchanged and the peek position is reset back to the read
+ * position.
+ * <p>
+ * Partial reads and skips can be simulated using {@link Builder#setSimulatePartialReads}. When
+ * enabled, {@link #read(byte[], int, int)} and {@link #skip(int)} calls will only read or skip a
+ * single byte unless a partial read or skip has already been performed that had the same target
+ * position. For example, a first read request for 10 bytes will be partially satisfied by reading
+ * a single byte and advancing the position to 1. If the following read request attempts to read 9
+ * bytes then it will be fully satisfied, since it has the same target position of 10.
+ * <p>
+ * Unknown data length can be simulated using {@link Builder#setSimulateUnknownLength}. When enabled
+ * {@link #getLength()} will return {@link C#LENGTH_UNBOUNDED} rather than the length of the data.
+ */
+public final class FakeExtractorInput implements ExtractorInput {
+
+  /**
+   * Thrown when simulating an {@link IOException}.
+   */
+  public static final class SimulatedIOException extends IOException {
+
+    public SimulatedIOException(String message) {
+      super(message);
+    }
+
+  }
+
+  private final byte[] data;
+  private final boolean simulateUnknownLength;
+  private final boolean simulatePartialReads;
+  private final boolean simulateIOErrors;
+
+  private int readPosition;
+  private int peekPosition;
+
+  private final SparseBooleanArray partiallySatisfiedTargetPositions;
+  private final SparseBooleanArray failedReadPositions;
+  private final SparseBooleanArray failedPeekPositions;
+
+  private FakeExtractorInput(byte[] data, boolean simulateUnknownLength,
+      boolean simulatePartialReads, boolean simulateIOErrors) {
+    this.data = data;
+    this.simulateUnknownLength = simulateUnknownLength;
+    this.simulatePartialReads = simulatePartialReads;
+    this.simulateIOErrors = simulateIOErrors;
+    partiallySatisfiedTargetPositions = new SparseBooleanArray();
+    failedReadPositions = new SparseBooleanArray();
+    failedPeekPositions = new SparseBooleanArray();
+  }
+
+  /**
+   * Sets the read and peek positions.
+   *
+   * @param position The position to set.
+   */
+  public void setPosition(int position) {
+    Assert.assertTrue(0 <= position && position < data.length);
+    readPosition = position;
+    peekPosition = position;
+  }
+
+  @Override
+  public int read(byte[] target, int offset, int length) throws IOException {
+    length = getReadLength(length);
+    if (readFully(target, offset, length, true)) {
+      return length;
+    }
+    return C.RESULT_END_OF_INPUT;
+  }
+
+  @Override
+  public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException {
+    if (!checkXFully(allowEndOfInput, readPosition, length, failedReadPositions)) {
+      return false;
+    }
+    System.arraycopy(data, readPosition, target, offset, length);
+    readPosition += length;
+    peekPosition = readPosition;
+    return true;
+  }
+
+  @Override
+  public void readFully(byte[] target, int offset, int length) throws IOException {
+    readFully(target, offset, length, false);
+  }
+
+  @Override
+  public int skip(int length) throws IOException {
+    length = getReadLength(length);
+    if (skipFully(length, true)) {
+      return length;
+    }
+    return C.RESULT_END_OF_INPUT;
+  }
+
+  @Override
+  public boolean skipFully(int length, boolean allowEndOfInput) throws IOException {
+    if (!checkXFully(allowEndOfInput, readPosition, length, failedReadPositions)) {
+      return false;
+    }
+    readPosition += length;
+    peekPosition = readPosition;
+    return true;
+  }
+
+  @Override
+  public void skipFully(int length) throws IOException {
+    skipFully(length, false);
+  }
+
+  @Override
+  public boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws IOException {
+    if (!checkXFully(allowEndOfInput, peekPosition, length, failedPeekPositions)) {
+      return false;
+    }
+    System.arraycopy(data, peekPosition, target, offset, length);
+    peekPosition += length;
+    return true;
+  }
+
+  @Override
+  public void peekFully(byte[] target, int offset, int length) throws IOException {
+    peekFully(target, offset, length, false);
+  }
+
+  @Override
+  public boolean advancePeekPosition(int length, boolean allowEndOfInput) throws IOException {
+    if (!checkXFully(allowEndOfInput, peekPosition, length, failedPeekPositions)) {
+      return false;
+    }
+    peekPosition += length;
+    return true;
+  }
+
+  @Override
+  public void advancePeekPosition(int length) throws IOException {
+    advancePeekPosition(length, false);
+  }
+
+  @Override
+  public void resetPeekPosition() {
+    peekPosition = readPosition;
+  }
+
+  @Override
+  public long getPeekPosition() {
+    return peekPosition;
+  }
+
+  @Override
+  public long getPosition() {
+    return readPosition;
+  }
+
+  @Override
+  public long getLength() {
+    return simulateUnknownLength ? C.LENGTH_UNBOUNDED : data.length;
+  }
+
+  private boolean checkXFully(boolean allowEndOfInput, int position, int length,
+      SparseBooleanArray failedPositions) throws IOException {
+    if (simulateIOErrors && !failedPositions.get(position)) {
+      failedPositions.put(position, true);
+      peekPosition = readPosition;
+      throw new SimulatedIOException("Simulated IO error at position: " + position);
+    }
+    if (isEof()) {
+      if (allowEndOfInput) {
+        return false;
+      }
+      throw new EOFException();
+    }
+    if (position + length > data.length) {
+      throw new IOException("Attempted to move past end of data: (" + position + " + "
+          + length + ") > " + data.length);
+    }
+    return true;
+  }
+
+  private int getReadLength(int requestedLength) {
+    int targetPosition = readPosition + requestedLength;
+    if (simulatePartialReads && requestedLength > 1
+        && !partiallySatisfiedTargetPositions.get(targetPosition)) {
+      partiallySatisfiedTargetPositions.put(targetPosition, true);
+      return 1;
+    }
+    return Math.min(requestedLength, data.length - readPosition);
+  }
+
+  private boolean isEof() {
+    return readPosition == data.length;
+  }
+
+  /**
+   * Builder of {@link FakeExtractorInput} instances.
+   */
+  public static final class Builder {
+
+    private byte[] data;
+    private boolean simulateUnknownLength;
+    private boolean simulatePartialReads;
+    private boolean simulateIOErrors;
+
+    public Builder() {
+      data = new byte[0];
+    }
+
+    public Builder setData(byte[] data) {
+      this.data = data;
+      return this;
+    }
+
+    public Builder setSimulateUnknownLength(boolean simulateUnknownLength) {
+      this.simulateUnknownLength = simulateUnknownLength;
+      return this;
+    }
+
+    public Builder setSimulatePartialReads(boolean simulatePartialReads) {
+      this.simulatePartialReads = simulatePartialReads;
+      return this;
+    }
+
+    public Builder setSimulateIOErrors(boolean simulateIOErrors) {
+      this.simulateIOErrors = simulateIOErrors;
+      return this;
+    }
+
+    public FakeExtractorInput build() {
+      return new FakeExtractorInput(data, simulateUnknownLength, simulatePartialReads,
+          simulateIOErrors);
+    }
+
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
index 6dbab04e7d..d8aa2ed019 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
@@ -21,6 +21,7 @@
 
 import android.util.SparseArray;
 
+import junit.framework.Assert;
 import junit.framework.TestCase;
 
 /**
@@ -32,10 +33,10 @@
 
   public final SparseArray<FakeTrackOutput> trackOutputs;
 
+  public int numberOfTracks;
   public boolean tracksEnded;
   public SeekMap seekMap;
   public DrmInitData drmInitData;
-  public int numberOfTracks;
 
   public FakeExtractorOutput() {
     this(false);
@@ -74,4 +75,29 @@ public void drmInitData(DrmInitData drmInitData) {
     this.drmInitData = drmInitData;
   }
 
+  public void assertEquals(FakeExtractorOutput expected) {
+    Assert.assertEquals(expected.numberOfTracks, numberOfTracks);
+    Assert.assertEquals(expected.tracksEnded, tracksEnded);
+    if (expected.seekMap == null) {
+      Assert.assertNull(seekMap);
+    } else {
+      // TODO: Bulk up this check if possible.
+      Assert.assertNotNull(seekMap);
+      Assert.assertEquals(expected.seekMap.getClass(), seekMap.getClass());
+      Assert.assertEquals(expected.seekMap.isSeekable(), seekMap.isSeekable());
+      Assert.assertEquals(expected.seekMap.getPosition(0), seekMap.getPosition(0));
+    }
+    if (expected.drmInitData == null) {
+      Assert.assertNull(drmInitData);
+    } else {
+      // TODO: Bulk up this check if possible.
+      Assert.assertNotNull(drmInitData);
+      Assert.assertEquals(expected.drmInitData.getClass(), drmInitData.getClass());
+    }
+    for (int i = 0; i < numberOfTracks; i++) {
+      Assert.assertEquals(expected.trackOutputs.keyAt(i), trackOutputs.keyAt(i));
+      trackOutputs.valueAt(i).assertEquals(expected.trackOutputs.valueAt(i));
+    }
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
index 5bdeccc4d9..198f9ab17f 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
@@ -22,7 +22,7 @@
 
 import android.test.MoreAsserts;
 
-import junit.framework.TestCase;
+import junit.framework.Assert;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -82,21 +82,38 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
   }
 
   public void assertSampleCount(int count) {
-    TestCase.assertEquals(count, sampleTimesUs.size());
+    Assert.assertEquals(count, sampleTimesUs.size());
   }
 
   public void assertSample(int index, byte[] data, long timeUs, int flags, byte[] encryptionKey) {
     byte[] actualData = Arrays.copyOfRange(sampleData, sampleStartOffsets.get(index),
         sampleEndOffsets.get(index));
     MoreAsserts.assertEquals(data, actualData);
-    TestCase.assertEquals(timeUs, (long) sampleTimesUs.get(index));
-    TestCase.assertEquals(flags, (int) sampleFlags.get(index));
+    Assert.assertEquals(timeUs, (long) sampleTimesUs.get(index));
+    Assert.assertEquals(flags, (int) sampleFlags.get(index));
     byte[] sampleEncryptionKey = sampleEncryptionKeys.get(index);
     if (encryptionKey == null) {
-      TestCase.assertEquals(null, sampleEncryptionKey);
+      Assert.assertEquals(null, sampleEncryptionKey);
     } else {
       MoreAsserts.assertEquals(encryptionKey, sampleEncryptionKey);
     }
   }
 
+  public void assertEquals(FakeTrackOutput expected) {
+    Assert.assertEquals(expected.format, format);
+    Assert.assertEquals(expected.sampleTimesUs.size(), sampleTimesUs.size());
+    MoreAsserts.assertEquals(expected.sampleData, sampleData);
+    for (int i = 0; i < sampleTimesUs.size(); i++) {
+      Assert.assertEquals(expected.sampleTimesUs.get(i), sampleTimesUs.get(i));
+      Assert.assertEquals(expected.sampleFlags.get(i), sampleFlags.get(i));
+      Assert.assertEquals(expected.sampleStartOffsets.get(i), sampleStartOffsets.get(i));
+      Assert.assertEquals(expected.sampleEndOffsets.get(i), sampleEndOffsets.get(i));
+      if (expected.sampleEncryptionKeys.get(i) == null) {
+        Assert.assertNull(sampleEncryptionKeys.get(i));
+      } else {
+        MoreAsserts.assertEquals(expected.sampleEncryptionKeys.get(i), sampleEncryptionKeys.get(i));
+      }
+    }
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
index 08c86b0d32..fc479bbc28 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
@@ -15,23 +15,18 @@
  */
 package com.google.android.exoplayer.testutil;
 
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer.extractor.Extractor;
-import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.PositionHolder;
-import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
 import android.app.Instrumentation;
-import android.net.Uri;
 import android.test.InstrumentationTestCase;
 
 import org.mockito.MockitoAnnotations;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.Arrays;
 import java.util.Random;
 
 /**
@@ -43,46 +38,43 @@ private TestUtil() {}
 
   public static void consumeTestData(Extractor extractor, byte[] data)
       throws IOException, InterruptedException {
-    ExtractorInput input = createTestExtractorInput(data);
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
     PositionHolder seekPositionHolder = new PositionHolder();
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
       readResult = extractor.read(input, seekPositionHolder);
       if (readResult == Extractor.RESULT_SEEK) {
-        input = createTestExtractorInput(data, (int) seekPositionHolder.position);
+        long seekPosition = seekPositionHolder.position;
+        Assertions.checkState(0 < seekPosition && seekPosition <= Integer.MAX_VALUE);
+        input.setPosition((int) seekPosition);
       }
     }
   }
 
-  public static ExtractorInput createTestExtractorInput(byte[] data) throws IOException {
-    return createTestExtractorInput(data, 0);
-  }
-
-  public static ExtractorInput createTestExtractorInput(byte[] data, int offset)
-      throws IOException {
-    if (offset != 0) {
-      data = Arrays.copyOfRange(data, offset, data.length);
-    }
-    FakeDataSource dataSource = new FakeDataSource.Builder().appendReadData(data).build();
-    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, offset, C.LENGTH_UNBOUNDED);
-    return input;
-  }
-
   public static byte[] buildTestData(int length) {
     return buildTestData(length, length);
   }
 
   public static byte[] buildTestData(int length, int seed) {
-    Random random = new Random(seed);
+    return buildTestData(length, new Random(seed));
+  }
+
+  public static byte[] buildTestData(int length, Random random) {
     byte[] source = new byte[length];
     random.nextBytes(source);
     return source;
   }
 
+  /**
+   * Converts an array of integers in the range [0, 255] into an equivalent byte array.
+   *
+   * @param intArray An array of integers, all of which must be in the range [0, 255].
+   * @return The equivalent byte array.
+   */
   public static byte[] createByteArray(int... intArray) {
     byte[] byteArray = new byte[intArray.length];
     for (int i = 0; i < byteArray.length; i++) {
+      Assertions.checkState(0x00 <= intArray[i] && intArray[i] <= 0xFF);
       byteArray[i] = (byte) intArray[i];
     }
     return byteArray;
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
index 0c45bae33a..ad2e664e13 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
@@ -109,7 +109,7 @@ public void testParseWithPositioning() throws IOException {
     WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
 
     // test event count
-    assertEquals(10, subtitle.getEventTimeCount());
+    assertEquals(12, subtitle.getEventTimeCount());
 
     // test cues
     assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.", Alignment.ALIGN_NORMAL,
@@ -126,6 +126,9 @@ public void testParseWithPositioning() throws IOException {
     assertCue(subtitle, 8, 7000000, 8000000, "This is the fifth subtitle.",
         Alignment.ALIGN_OPPOSITE, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, 0.1f,
         Cue.ANCHOR_TYPE_END, 0.1f);
+  assertCue(subtitle, 10, 10000000, 11000000, "This is the sixth subtitle.",
+        Alignment.ALIGN_CENTER, 0.45f, Cue.LINE_TYPE_FRACTION, Cue.ANCHOR_TYPE_END, Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET, 0.35f);
   }
 
   public void testParseWithBadCueHeader() throws IOException {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
index 3755a9f250..9bd1d07d3d 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
@@ -17,6 +17,7 @@
 
 import junit.framework.TestCase;
 
+import java.nio.ByteBuffer;
 import java.util.Arrays;
 
 /**
@@ -122,6 +123,22 @@ public void testUnescapeModifiesBuffersWithStartCodes() {
     assertUnescapeMatchesExpected("0000030200000300", "000002000000");
   }
 
+  public void testDiscardToSps() {
+    assertDiscardToSpsMatchesExpected("", "");
+    assertDiscardToSpsMatchesExpected("00", "");
+    assertDiscardToSpsMatchesExpected("FFFF000001", "");
+    assertDiscardToSpsMatchesExpected("00000001", "");
+    assertDiscardToSpsMatchesExpected("00000001FF67", "");
+    assertDiscardToSpsMatchesExpected("00000001000167", "");
+    assertDiscardToSpsMatchesExpected("0000000167", "0000000167");
+    assertDiscardToSpsMatchesExpected("0000000167FF", "0000000167FF");
+    assertDiscardToSpsMatchesExpected("0000000167FF", "0000000167FF");
+    assertDiscardToSpsMatchesExpected("0000000167FF000000016700", "0000000167FF000000016700");
+    assertDiscardToSpsMatchesExpected("000000000167FF", "0000000167FF");
+    assertDiscardToSpsMatchesExpected("0001670000000167FF", "0000000167FF");
+    assertDiscardToSpsMatchesExpected("FF00000001660000000167FF", "0000000167FF");
+  }
+
   private static byte[] buildTestData() {
     byte[] data = new byte[20];
     for (int i = 0; i < data.length; i++) {
@@ -156,4 +173,14 @@ private static void assertUnescapeMatchesExpected(String input, String expectedO
     assertTrue(Arrays.equals(expectedOutputBitstream, outputBitstream));
   }
 
+  private static void assertDiscardToSpsMatchesExpected(String input, String expectedOutput) {
+    byte[] bitstream = Util.getBytesFromHexString(input);
+    byte[] expectedOutputBitstream = Util.getBytesFromHexString(expectedOutput);
+    ByteBuffer buffer = ByteBuffer.wrap(bitstream);
+    buffer.position(buffer.limit());
+    NalUnitUtil.discardToSps(buffer);
+    assertTrue(Arrays.equals(expectedOutputBitstream,
+        Arrays.copyOf(buffer.array(), buffer.position())));
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index 5d265a64ff..e4cf3f6eab 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -212,7 +212,7 @@ public static ExoPlayer newInstance(int rendererCount) {
   public static final int STATE_BUFFERING = 3;
   /**
    * The player is prepared and able to immediately play from the current position. The player will
-   * be playing if {@link #setPlayWhenReady(boolean)} returns true, and paused otherwise.
+   * be playing if {@link #getPlayWhenReady()} returns true, and paused otherwise.
    */
   public static final int STATE_READY = 4;
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 69f9a7e569..ade47c08e9 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.5";
+  public static final String VERSION = "1.5.6";
 
   /**
    * The version of the library, expressed as an integer.
@@ -31,7 +31,7 @@
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001005005;
+  public static final int VERSION_INT = 001005006;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index eb54971a39..064410798c 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -313,6 +313,8 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     int rotationDegrees = getOptionalIntegerV16(format, "rotation-degrees");
     int channelCount = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_SAMPLE_RATE);
+    int encoderDelay = getOptionalIntegerV16(format, "encoder-delay");
+    int encoderPadding = getOptionalIntegerV16(format, "encoder-padding");
     ArrayList<byte[]> initializationData = new ArrayList<>();
     for (int i = 0; format.containsKey("csd-" + i); i++) {
       ByteBuffer buffer = format.getByteBuffer("csd-" + i);
@@ -326,7 +328,7 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, encoderDelay, encoderPadding);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 71a774b5e1..e39d7c51e9 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -189,13 +189,13 @@ protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaForma
     String mimeType = mediaFormat.mimeType;
     return MimeTypes.isAudio(mimeType) && (MimeTypes.AUDIO_UNKNOWN.equals(mimeType)
         || (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderName() != null)
-        || mediaCodecSelector.getDecoderInfo(mediaFormat, false) != null);
+        || mediaCodecSelector.getDecoderInfo(mimeType, false) != null);
   }
 
   @Override
-  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, MediaFormat format,
+  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, String mimeType,
       boolean requiresSecureDecoder) throws DecoderQueryException {
-    if (allowPassthrough(format.mimeType)) {
+    if (allowPassthrough(mimeType)) {
       String passthroughDecoderName = mediaCodecSelector.getPassthroughDecoderName();
       if (passthroughDecoderName != null) {
         passthroughEnabled = true;
@@ -203,7 +203,7 @@ protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, Medi
       }
     }
     passthroughEnabled = false;
-    return super.getDecoderInfo(mediaCodecSelector, format, requiresSecureDecoder);
+    return super.getDecoderInfo(mediaCodecSelector, mimeType, requiresSecureDecoder);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
index 40378b40fd..7341b989e0 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecSelector.java
@@ -35,9 +35,9 @@
     private static final String RAW_DECODER_NAME = "OMX.google.raw.decoder";
 
     @Override
-    public DecoderInfo getDecoderInfo(MediaFormat format, boolean requiresSecureDecoder)
+    public DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
         throws DecoderQueryException {
-      return MediaCodecUtil.getDecoderInfo(format.mimeType, requiresSecureDecoder);
+      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
     }
 
     @Override
@@ -49,15 +49,15 @@ public String getPassthroughDecoderName() throws DecoderQueryException {
   };
 
   /**
-   * Selects a decoder to instantiate for a given format.
+   * Selects a decoder to instantiate for a given mime type.
    *
-   * @param format The format for which a decoder is required.
+   * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
    * @return A {@link DecoderInfo} describing the decoder to instantiate, or null if no suitable
    *     decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  DecoderInfo getDecoderInfo(MediaFormat format, boolean requiresSecureDecoder)
+  DecoderInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
       throws DecoderQueryException;
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 2c2597b17d..6e92e90535 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.TraceUtil;
 import com.google.android.exoplayer.util.Util;
 
@@ -209,10 +210,11 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private DrmInitData drmInitData;
   private MediaCodec codec;
   private boolean codecIsAdaptive;
+  private boolean codecNeedsDiscardToSpsWorkaround;
   private boolean codecNeedsFlushWorkaround;
   private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
-  private boolean codecReceivedEos;
+  private boolean codecNeedsMonoChannelCountWorkaround;
   private ByteBuffer[] inputBuffers;
   private ByteBuffer[] outputBuffers;
   private long codecHotswapTimeMs;
@@ -222,7 +224,8 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean codecReconfigured;
   private int codecReconfigurationState;
   private int codecReinitializationState;
-  private boolean codecHasQueuedBuffers;
+  private boolean codecReceivedBuffers;
+  private boolean codecReceivedEos;
 
   private int sourceState;
   private boolean inputStreamEnded;
@@ -284,15 +287,15 @@ protected abstract boolean handlesTrack(MediaCodecSelector mediaCodecSelector,
    * Returns a {@link DecoderInfo} for a given format.
    *
    * @param mediaCodecSelector The decoder selector.
-   * @param mediaFormat The format for which a decoder is required.
+   * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
    * @return A {@link DecoderInfo} describing the decoder to instantiate, or null if no suitable
    *     decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
-      MediaFormat mediaFormat, boolean requiresSecureDecoder) throws DecoderQueryException {
-    return mediaCodecSelector.getDecoderInfo(format, requiresSecureDecoder);
+  protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, String mimeType,
+      boolean requiresSecureDecoder) throws DecoderQueryException {
+    return mediaCodecSelector.getDecoderInfo(mimeType, requiresSecureDecoder);
   }
 
   /**
@@ -338,7 +341,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     DecoderInfo decoderInfo = null;
     try {
-      decoderInfo = getDecoderInfo(mediaCodecSelector, format, requiresSecureDecoder);
+      decoderInfo = getDecoderInfo(mediaCodecSelector, mimeType, requiresSecureDecoder);
     } catch (DecoderQueryException e) {
       notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
           requiresSecureDecoder, DecoderInitializationException.DECODER_QUERY_ERROR));
@@ -351,9 +354,11 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     String codecName = decoderInfo.name;
     codecIsAdaptive = decoderInfo.adaptive;
+    codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
     codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
     codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
+    codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
       TraceUtil.beginSection("createByCodecName(" + codecName + ")");
@@ -428,11 +433,13 @@ protected void releaseCodec() {
       inputBuffers = null;
       outputBuffers = null;
       codecReconfigured = false;
-      codecHasQueuedBuffers = false;
+      codecReceivedBuffers = false;
       codecIsAdaptive = false;
+      codecNeedsDiscardToSpsWorkaround = false;
       codecNeedsFlushWorkaround = false;
       codecNeedsEosPropagationWorkaround = false;
       codecNeedsEosFlushWorkaround = false;
+      codecNeedsMonoChannelCountWorkaround = false;
       codecReceivedEos = false;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       codecReinitializationState = REINITIALIZATION_STATE_NONE;
@@ -516,7 +523,7 @@ private void flushCodec() throws ExoPlaybackException {
     } else {
       // We can flush and re-use the existing decoder.
       codec.flush();
-      codecHasQueuedBuffers = false;
+      codecReceivedBuffers = false;
     }
     if (codecReconfigured && format != null) {
       // Any reconfiguration data that we send shortly before the flush may be discarded. We
@@ -606,7 +613,7 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
       inputStreamEnded = true;
-      if (!codecHasQueuedBuffers) {
+      if (!codecReceivedBuffers) {
         processEndOfStream();
         return false;
       }
@@ -643,6 +650,13 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
     if (waitingForKeys) {
       return false;
     }
+    if (codecNeedsDiscardToSpsWorkaround && !sampleEncrypted) {
+      NalUnitUtil.discardToSps(sampleHolder.data);
+      if (sampleHolder.data.position() == 0) {
+        return true;
+      }
+      codecNeedsDiscardToSpsWorkaround = false;
+    }
     try {
       int bufferSize = sampleHolder.data.position();
       int adaptiveReconfigurationBytes = bufferSize - sampleHolder.size;
@@ -658,8 +672,9 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
         codec.queueInputBuffer(inputIndex, 0, bufferSize, presentationTimeUs, 0);
       }
       inputIndex = -1;
-      codecHasQueuedBuffers = true;
+      codecReceivedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
+      onQueuedInputBuffer(presentationTimeUs);
     } catch (CryptoException e) {
       notifyCryptoError(e);
       throw new ExoPlaybackException(e);
@@ -720,7 +735,7 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
       codecReconfigured = true;
       codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
     } else {
-      if (codecHasQueuedBuffers) {
+      if (codecReceivedBuffers) {
         // Signal end of stream and wait for any final output buffers before re-initialization.
         codecReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
       } else {
@@ -755,6 +770,28 @@ protected void onOutputStreamEnded() {
     // Do nothing.
   }
 
+  /**
+   * Invoked when an input buffer is queued into the codec.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param presentationTimeUs The timestamp associated with the input buffer.
+   */
+  protected void onQueuedInputBuffer(long presentationTimeUs) {
+    // Do nothing.
+  }
+
+  /**
+   * Invoked when an output buffer is successfully processed.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param presentationTimeUs The timestamp associated with the output buffer.
+   */
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    // Do Nothing.
+  }
+
   /**
    * Determines whether the existing {@link MediaCodec} should be reconfigured for a new format by
    * sending codec specific initialization data at the start of the next input buffer. If true is
@@ -825,8 +862,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-      onOutputFormatChanged(codec.getOutputFormat());
-      codecCounters.outputFormatChangedCount++;
+      processOutputFormat();
       return true;
     } else if (outputIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
       outputBuffers = codec.getOutputBuffers();
@@ -849,6 +885,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     int decodeOnlyIndex = getDecodeOnlyIndex(outputBufferInfo.presentationTimeUs);
     if (processOutputBuffer(positionUs, elapsedRealtimeUs, codec, outputBuffers[outputIndex],
         outputBufferInfo, outputIndex, decodeOnlyIndex != -1)) {
+      onProcessedOutputBuffer(outputBufferInfo.presentationTimeUs);
       if (decodeOnlyIndex != -1) {
         decodeOnlyPresentationTimestamps.remove(decodeOnlyIndex);
       }
@@ -859,6 +896,20 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     return false;
   }
 
+  /**
+   * Processes a new output format.
+   *
+   * @throws ExoPlaybackException If an error occurs processing the output format.
+   */
+  private void processOutputFormat() throws ExoPlaybackException {
+    android.media.MediaFormat format = codec.getOutputFormat();
+    if (codecNeedsMonoChannelCountWorkaround) {
+      format.setInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT, 1);
+    }
+    onOutputFormatChanged(format);
+    codecCounters.outputFormatChangedCount++;
+  }
+
   /**
    * Processes the provided output buffer.
    *
@@ -948,6 +999,21 @@ private static boolean codecNeedsFlushWorkaround(String name) {
             && ("OMX.Exynos.avc.dec".equals(name) || "OMX.Exynos.avc.dec.secure".equals(name)));
   }
 
+  /**
+   * Returns whether the decoder is an H.264/AVC decoder known to fail if NAL units are queued
+   * before the codec specific data.
+   * <p>
+   * If true is returned, the renderer will work around the issue by discarding data up to the SPS.
+   *
+   * @param name The name of the decoder.
+   * @param format The format used to configure the decoder.
+   * @return True if the decoder is known to fail if NAL units are queued before CSD.
+   */
+  private static boolean codecNeedsDiscardToSpsWorkaround(String name, MediaFormat format) {
+    return Util.SDK_INT < 21 && format.initializationData.isEmpty()
+        && "OMX.MTK.VIDEO.DECODER.AVC".equals(name);
+  }
+
   /**
    * Returns whether the decoder is known to handle the propagation of the
    * {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} flag incorrectly on the host device.
@@ -979,6 +1045,24 @@ private static boolean codecNeedsEosFlushWorkaround(String name) {
     return Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name);
   }
 
+  /**
+   * Returns whether the decoder is known to set the number of audio channels in the output format
+   * to 2 for the given input format, whilst only actually outputting a single channel.
+   * <p>
+   * If true is returned then we explicitly override the number of channels in the output format,
+   * setting it to 1.
+   *
+   * @param name The decoder name.
+   * @param format The input format.
+   * @return True if the device is known to set the number of audio channels in the output format
+   *     to 2 for the given input format, whilst only actually outputting a single channel. False
+   *     otherwise.
+   */
+  private static boolean codecNeedsMonoChannelCountWorkaround(String name, MediaFormat format) {
+    return Util.SDK_INT <= 18 && format.channelCount == 1
+        && "OMX.MTK.AUDIO.DECODER.MP3".equals(name);
+  }
+
   /**
    * Returns whether the device is known to enable frame-rate conversion logic that negatively
    * impacts ExoPlayer.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 9ff406de56..e3cd5b7e6c 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -345,7 +345,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
   }
 
   /**
-   * Conversion values taken from: https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC.
+   * Conversion values taken from ISO 14496-10 Table A-1.
    *
    * @param avcLevel one of CodecProfileLevel.AVCLevel* constants.
    * @return maximum frame size that can be decoded by a decoder with the specified avc level
@@ -353,21 +353,21 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    */
   private static int avcLevelToMaxFrameSize(int avcLevel) {
     switch (avcLevel) {
-      case CodecProfileLevel.AVCLevel1: return 25344;
-      case CodecProfileLevel.AVCLevel1b: return 25344;
-      case CodecProfileLevel.AVCLevel12: return 101376;
-      case CodecProfileLevel.AVCLevel13: return 101376;
-      case CodecProfileLevel.AVCLevel2: return 101376;
-      case CodecProfileLevel.AVCLevel21: return 202752;
-      case CodecProfileLevel.AVCLevel22: return 414720;
-      case CodecProfileLevel.AVCLevel3: return 414720;
-      case CodecProfileLevel.AVCLevel31: return 921600;
-      case CodecProfileLevel.AVCLevel32: return 1310720;
-      case CodecProfileLevel.AVCLevel4: return 2097152;
-      case CodecProfileLevel.AVCLevel41: return 2097152;
-      case CodecProfileLevel.AVCLevel42: return 2228224;
-      case CodecProfileLevel.AVCLevel5: return 5652480;
-      case CodecProfileLevel.AVCLevel51: return 9437184;
+      case CodecProfileLevel.AVCLevel1: return 99 * 16 * 16;
+      case CodecProfileLevel.AVCLevel1b: return 99 * 16 * 16;
+      case CodecProfileLevel.AVCLevel12: return 396 * 16 * 16;
+      case CodecProfileLevel.AVCLevel13: return 396 * 16 * 16;
+      case CodecProfileLevel.AVCLevel2: return 396 * 16 * 16;
+      case CodecProfileLevel.AVCLevel21: return 792 * 16 * 16;
+      case CodecProfileLevel.AVCLevel22: return 1620 * 16 * 16;
+      case CodecProfileLevel.AVCLevel3: return 1620 * 16 * 16;
+      case CodecProfileLevel.AVCLevel31: return 3600 * 16 * 16;
+      case CodecProfileLevel.AVCLevel32: return 5120 * 16 * 16;
+      case CodecProfileLevel.AVCLevel4: return 8192 * 16 * 16;
+      case CodecProfileLevel.AVCLevel41: return 8192 * 16 * 16;
+      case CodecProfileLevel.AVCLevel42: return 8704 * 16 * 16;
+      case CodecProfileLevel.AVCLevel5: return 22080 * 16 * 16;
+      case CodecProfileLevel.AVCLevel51: return 36864 * 16 * 16;
       default: return -1;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index d5e82482ff..a5a1760e8f 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -221,7 +221,7 @@ protected boolean handlesTrack(MediaCodecSelector mediaCodecSelector, MediaForma
       throws DecoderQueryException {
     String mimeType = mediaFormat.mimeType;
     return MimeTypes.isVideo(mimeType) && (MimeTypes.VIDEO_UNKNOWN.equals(mimeType)
-        || mediaCodecSelector.getDecoderInfo(mediaFormat, false) != null);
+        || mediaCodecSelector.getDecoderInfo(mimeType, false) != null);
   }
 
   @Override
@@ -527,6 +527,7 @@ private void maybeSetMaxInputSize(android.media.MediaFormat format, boolean code
         maxPixels = maxWidth * maxHeight;
         minCompressionRatio = 2;
         break;
+      case MimeTypes.VIDEO_H265:
       case MimeTypes.VIDEO_VP9:
         maxPixels = maxWidth * maxHeight;
         minCompressionRatio = 4;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 9978221a74..bc68b93e3a 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -119,6 +119,14 @@
    * The audio sampling rate in Hz, or {@link #NO_VALUE} if unknown or not applicable.
    */
   public final int sampleRate;
+  /**
+   * The number of samples to trim from the start of the decoded audio stream.
+   */
+  public final int encoderDelay;
+  /**
+   * The number of samples to trim from the end of the decoded audio stream.
+   */
+  public final int encoderPadding;
 
   // Text specific.
 
@@ -150,7 +158,7 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
@@ -158,7 +166,7 @@ public static MediaFormat createAudioFormat(String trackId, String mimeType, int
       List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -171,14 +179,14 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createId3Format() {
@@ -189,7 +197,8 @@ public static MediaFormat createId3Format() {
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
-      List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight) {
+      List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
+      int encoderDelay, int encoderPadding) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -208,43 +217,57 @@ public static MediaFormat createId3Format() {
     this.adaptive = adaptive;
     this.maxWidth = maxWidth;
     this.maxHeight = maxHeight;
+    this.encoderDelay = encoderDelay;
+    this.encoderPadding = encoderPadding;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
       String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE);
+        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, encoderDelay,
+        encoderPadding);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight);
+        maxHeight, NO_VALUE, NO_VALUE);
+  }
+
+  public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
   }
 
   /**
@@ -265,6 +288,8 @@ public MediaFormat copyAsAdaptive(String trackId) {
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_MAX_HEIGHT, maxHeight);
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_CHANNEL_COUNT, channelCount);
       maybeSetIntegerV16(format, android.media.MediaFormat.KEY_SAMPLE_RATE, sampleRate);
+      maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
+      maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
       for (int i = 0; i < initializationData.size(); i++) {
         format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
       }
@@ -293,7 +318,8 @@ public String toString() {
     return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitrate + ", " + maxInputSize
         + ", " + width + ", " + height + ", " + rotationDegrees + ", " + pixelWidthHeightRatio
         + ", " + channelCount + ", " + sampleRate + ", " + language + ", " + durationUs + ", "
-        + adaptive + ", " + maxWidth + ", " + maxHeight + ")";
+        + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + encoderDelay + ", "
+        + encoderPadding + ")";
   }
 
   @Override
@@ -312,6 +338,8 @@ public int hashCode() {
       result = 31 * result + (adaptive ? 1231 : 1237);
       result = 31 * result + maxWidth;
       result = 31 * result + maxHeight;
+      result = 31 * result + encoderDelay;
+      result = 31 * result + encoderPadding;
       result = 31 * result + channelCount;
       result = 31 * result + sampleRate;
       result = 31 * result + (language == null ? 0 : language.hashCode());
@@ -337,6 +365,7 @@ public boolean equals(Object obj) {
         || rotationDegrees != other.rotationDegrees
         || pixelWidthHeightRatio != other.pixelWidthHeightRatio
         || maxWidth != other.maxWidth || maxHeight != other.maxHeight
+        || encoderDelay != other.encoderDelay || encoderPadding != other.encoderPadding
         || channelCount != other.channelCount || sampleRate != other.sampleRate
         || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 420bd39899..da45eb3b8b 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -514,12 +514,14 @@ public void onChunkLoadCompleted(Chunk chunk) {
       if (initializationChunk.hasFormat()) {
         representationHolder.mediaFormat = initializationChunk.getFormat();
       }
-      if (initializationChunk.hasSeekMap()) {
+      // The null check avoids overwriting an index obtained from the manifest with one obtained
+      // from the stream. If the manifest defines an index then the stream shouldn't, but in cases
+      // where it does we should ignore it.
+      if (representationHolder.segmentIndex == null && initializationChunk.hasSeekMap()) {
         representationHolder.segmentIndex = new DashWrappingSegmentIndex(
             (ChunkIndex) initializationChunk.getSeekMap(),
             initializationChunk.dataSpec.uri.toString());
       }
-
       // The null check avoids overwriting drmInitData obtained from the manifest with drmInitData
       // obtained from the stream, as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
       if (periodHolder.drmInitData == null && initializationChunk.hasDrmInitData()) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index 538f0bb005..7ba7e5d8b3 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -324,16 +324,18 @@ protected ContentProtection parseContentProtection(XmlPullParser xpp)
     String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
     UUID uuid = null;
     SchemeInitData data = null;
+    boolean seenPsshElement = false;
     do {
       xpp.next();
       // The cenc:pssh element is defined in 23001-7:2015.
       if (ParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
+        seenPsshElement = true;
         data = new SchemeInitData(MimeTypes.VIDEO_MP4,
             Base64.decode(xpp.getText(), Base64.DEFAULT));
         uuid = PsshAtomUtil.parseUuid(data.data);
       }
     } while (!ParserUtil.isEndTag(xpp, "ContentProtection"));
-    if (uuid == null) {
+    if (seenPsshElement && uuid == null) {
       Log.w(TAG, "Skipped unsupported ContentProtection element");
       return null;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index a9b517a4d2..e0c5a84eb5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -153,6 +153,13 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.ts.PsExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
   }
 
   private final ExtractorHolder extractorHolder;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index 05359c8df9..72f6e4b6ed 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -119,9 +119,14 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (seeker == null) {
       setupSeeker(input);
       extractorOutput.seekMap(seeker);
-      trackOutput.format(MediaFormat.createAudioFormat(null, synchronizedHeader.mimeType,
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, synchronizedHeader.mimeType,
           MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, seeker.getDurationUs(),
-          synchronizedHeader.channels, synchronizedHeader.sampleRate, null, null));
+          synchronizedHeader.channels, synchronizedHeader.sampleRate, null, null);
+      if (gaplessInfo != null) {
+        mediaFormat =
+            mediaFormat.copyWithGaplessInfo(gaplessInfo.encoderDelay, gaplessInfo.encoderPadding);
+      }
+      trackOutput.format(mediaFormat);
     }
     return readSample(input);
   }
@@ -202,6 +207,9 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     if (input.getPosition() == 0) {
       gaplessInfo = Id3Util.parseId3(input);
       peekedId3Bytes = (int) input.getPeekPosition();
+      if (!sniffing) {
+        input.skipFully(peekedId3Bytes);
+      }
     }
     while (true) {
       if (sniffing && searched == MAX_SNIFF_BYTES) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index b47702f0f4..4d5500054d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer.extractor.mp4;
 
+import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
@@ -274,12 +276,11 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
   private void processMoovAtom(ContainerAtom moov) {
     List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
-    // TODO: Apply gapless information.
-    // GaplessInfo gaplessInfo = null;
-    // Atom.ContainerAtom udta = moov.getContainerAtomOfType(Atom.TYPE_udta);
-    // if (udta != null) {
-    //   gaplessInfo = AtomParsers.parseUdta(udta);
-    // }
+    GaplessInfo gaplessInfo = null;
+    Atom.ContainerAtom udta = moov.getContainerAtomOfType(Atom.TYPE_udta);
+    if (udta != null) {
+      gaplessInfo = AtomParsers.parseUdta(udta);
+    }
     for (int i = 0; i < moov.containerChildren.size(); i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
       if (atom.type != Atom.TYPE_trak) {
@@ -303,7 +304,12 @@ private void processMoovAtom(ContainerAtom moov) {
       // Each sample has up to three bytes of overhead for the start code that replaces its length.
       // Allow ten source samples per output sample, like the platform extractor.
       int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
-      mp4Track.trackOutput.format(track.mediaFormat.copyWithMaxInputSize(maxInputSize));
+      MediaFormat mediaFormat = track.mediaFormat.copyWithMaxInputSize(maxInputSize);
+      if (gaplessInfo != null) {
+        mediaFormat =
+            mediaFormat.copyWithGaplessInfo(gaplessInfo.encoderDelay, gaplessInfo.encoderPadding);
+      }
+      mp4Track.trackOutput.format(mediaFormat);
       tracks.add(mp4Track);
 
       long firstSampleOffset = trackSampleTable.offsets[0];
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index 86c31d7c8b..e20781adb5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -68,11 +68,11 @@
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
-  public H264Reader(TrackOutput output, SeiReader seiReader, boolean idrKeyframesOnly) {
+  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes) {
     super(output);
     this.seiReader = seiReader;
     prefixFlags = new boolean[3];
-    ifrParserBuffer = (idrKeyframesOnly) ? null : new IfrParserBuffer();
+    ifrParserBuffer = allowNonIdrKeyframes ? new IfrParserBuffer() : null;
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java
new file mode 100644
index 0000000000..59059f3122
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.SparseArray;
+
+import java.io.IOException;
+
+/**
+ * Facilitates the extraction of data from the MPEG-2 TS container format.
+ */
+public final class PsExtractor implements Extractor {
+
+  private static final int PACK_START_CODE = 0x000001BA;
+  private static final int SYSTEM_HEADER_START_CODE = 0x000001BB;
+  private static final int PACKET_START_CODE_PREFIX = 0x000001;
+  private static final int MPEG_PROGRAM_END_CODE = 0x000001B9;
+  private static final long MAX_SEARCH_LENGTH = 1024 * 1024;
+
+  public static final int PRIVATE_STREAM_1 = 0xBD;
+  public static final int AUDIO_STREAM = 0xC0;
+  public static final int AUDIO_STREAM_MASK = 0xE0;
+  public static final int VIDEO_STREAM = 0xE0;
+  public static final int VIDEO_STREAM_MASK = 0xF0;
+
+  private final PtsTimestampAdjuster ptsTimestampAdjuster;
+  private final SparseArray<PesReader> psPayloadReaders; // Indexed by pid
+  private final ParsableByteArray psPacketBuffer;
+  private boolean foundAllTracks;
+  private boolean foundAudioTrack;
+  private boolean foundVideoTrack;
+
+  // Accessed only by the loading thread.
+  private ExtractorOutput output;
+
+  public PsExtractor() {
+    this(new PtsTimestampAdjuster(0));
+  }
+
+  public PsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster) {
+    this.ptsTimestampAdjuster = ptsTimestampAdjuster;
+    psPacketBuffer = new ParsableByteArray(4096);
+    psPayloadReaders = new SparseArray<>();
+  }
+
+  // Extractor implementation.
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    byte[] scratch = new byte[14];
+    input.peekFully(scratch, 0, 14);
+
+    // Verify the PACK_START_CODE for the first 4 bytes
+    if (PACK_START_CODE != (((scratch[0] & 0xFF) << 24) | ((scratch[1] & 0xFF) << 16)
+        | ((scratch[2] & 0xFF) << 8) | (scratch[3] & 0xFF))) {
+      return false;
+    }
+    // Verify the 01xxx1xx marker on the 5th byte
+    if ((scratch[4] & 0xC4) != 0x44) {
+      return false;
+    }
+    // Verify the xxxxx1xx marker on the 7th byte
+    if ((scratch[6] & 0x04) != 0x04) {
+      return false;
+    }
+    // Verify the xxxxx1xx marker on the 9th byte
+    if ((scratch[8] & 0x04) != 0x04) {
+      return false;
+    }
+    // Verify the xxxxxxx1 marker on the 10th byte
+    if ((scratch[9] & 0x01) != 0x01) {
+      return false;
+    }
+    // Verify the xxxxxx11 marker on the 13th byte
+    if ((scratch[12] & 0x03) != 0x03) {
+      return false;
+    }
+    // Read the stuffing length from the 14th byte (last 3 bits)
+    int packStuffingLength = scratch[13] & 0x07;
+    input.advancePeekPosition(packStuffingLength);
+    // Now check that the next 3 bytes are the beginning of an MPEG start code
+    input.peekFully(scratch, 0, 3);
+    return (PACKET_START_CODE_PREFIX == (((scratch[0] & 0xFF) << 16) | ((scratch[1] & 0xFF) << 8)
+        | (scratch[2] & 0xFF)));
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.output = output;
+    output.seekMap(SeekMap.UNSEEKABLE);
+  }
+
+  @Override
+  public void seek() {
+    ptsTimestampAdjuster.reset();
+    for (int i = 0; i < psPayloadReaders.size(); i++) {
+      psPayloadReaders.valueAt(i).seek();
+    }
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    // First peek and check what type of start code is next.
+    if (!input.peekFully(psPacketBuffer.data, 0, 4, true)) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    psPacketBuffer.setPosition(0);
+    int nextStartCode = psPacketBuffer.readInt();
+    if (nextStartCode == MPEG_PROGRAM_END_CODE) {
+      return RESULT_END_OF_INPUT;
+    } else if (nextStartCode == PACK_START_CODE) {
+      // Now peek the rest of the pack_header.
+      input.peekFully(psPacketBuffer.data, 0, 10);
+
+      // We only care about the pack_stuffing_length in here, skip the first 77 bits.
+      psPacketBuffer.setPosition(0);
+      psPacketBuffer.skipBytes(9);
+
+      // Last 3 bits is the length.
+      int packStuffingLength = psPacketBuffer.readUnsignedByte() & 0x07;
+
+      // Now skip the stuffing and the pack header.
+      input.skipFully(packStuffingLength + 14);
+      return RESULT_CONTINUE;
+    } else if (nextStartCode == SYSTEM_HEADER_START_CODE) {
+      // We just skip all this, but we need to get the length first.
+      input.peekFully(psPacketBuffer.data, 0, 2);
+
+      // Length is the next 2 bytes.
+      psPacketBuffer.setPosition(0);
+      int systemHeaderLength = psPacketBuffer.readUnsignedShort();
+      input.skipFully(systemHeaderLength + 6);
+      return RESULT_CONTINUE;
+    } else if (((nextStartCode & 0xFFFFFF00) >> 8) != PACKET_START_CODE_PREFIX) {
+      input.skipFully(1);  // Skip bytes until we see a valid start code again.
+      return RESULT_CONTINUE;
+    }
+
+    // We're at the start of a regular PES packet now.
+    // Get the stream ID off the last byte of the start code.
+    int streamId = nextStartCode & 0xFF;
+
+    // Check to see if we have this one in our map yet, and if not, then add it.
+    PesReader payloadReader = psPayloadReaders.get(streamId);
+    if (!foundAllTracks) {
+      if (payloadReader == null) {
+        ElementaryStreamReader elementaryStreamReader = null;
+        if (!foundAudioTrack && streamId == PRIVATE_STREAM_1) {
+          // Private stream, used for AC3 audio.
+          // NOTE: This may need further parsing to determine if its DTS, but that's likely only
+          // valid for DVDs.
+          elementaryStreamReader = new Ac3Reader(output.track(streamId), false);
+          foundAudioTrack = true;
+        } else if (!foundAudioTrack && (streamId & AUDIO_STREAM_MASK) == AUDIO_STREAM) {
+          elementaryStreamReader = new MpegAudioReader(output.track(streamId));
+          foundAudioTrack = true;
+        } else if (!foundVideoTrack && (streamId & VIDEO_STREAM_MASK) == VIDEO_STREAM) {
+          elementaryStreamReader = new H262Reader(output.track(streamId));
+          foundVideoTrack = true;
+        }
+        if (elementaryStreamReader != null) {
+          payloadReader = new PesReader(elementaryStreamReader, ptsTimestampAdjuster);
+          psPayloadReaders.put(streamId, payloadReader);
+        }
+      }
+      if ((foundAudioTrack && foundVideoTrack) || input.getPosition() > MAX_SEARCH_LENGTH) {
+        foundAllTracks = true;
+        output.endTracks();
+      }
+    }
+
+    // The next 2 bytes are the length, once we have that we can consume the complete packet.
+    input.peekFully(psPacketBuffer.data, 0, 2);
+    psPacketBuffer.setPosition(0);
+    int payloadLength = psPacketBuffer.readUnsignedShort();
+    int pesLength = payloadLength + 6;
+
+    if (payloadReader == null) {
+      // Just skip this data.
+      input.skipFully(pesLength);
+    } else {
+      if (psPacketBuffer.capacity() < pesLength) {
+        // Reallocate for this and future packets.
+        psPacketBuffer.reset(new byte[pesLength], pesLength);
+      }
+      // Read the whole packet and the header for consumption.
+      input.readFully(psPacketBuffer.data, 0, pesLength);
+      psPacketBuffer.setPosition(6);
+      psPacketBuffer.setLimit(pesLength);
+      payloadReader.consume(psPacketBuffer, output);
+      psPacketBuffer.setLimit(psPacketBuffer.capacity());
+    }
+
+    return RESULT_CONTINUE;
+  }
+
+  // Internals.
+
+  /**
+   * Parses PES packet data and extracts samples.
+   */
+  private static final class PesReader {
+
+    private static final int PES_SCRATCH_SIZE = 64;
+
+    private final ElementaryStreamReader pesPayloadReader;
+    private final PtsTimestampAdjuster ptsTimestampAdjuster;
+    private final ParsableBitArray pesScratch;
+
+    private boolean ptsFlag;
+    private boolean dtsFlag;
+    private boolean seenFirstDts;
+    private int extendedHeaderLength;
+    private long timeUs;
+
+    public PesReader(ElementaryStreamReader pesPayloadReader,
+        PtsTimestampAdjuster ptsTimestampAdjuster) {
+      this.pesPayloadReader = pesPayloadReader;
+      this.ptsTimestampAdjuster = ptsTimestampAdjuster;
+      pesScratch = new ParsableBitArray(new byte[PES_SCRATCH_SIZE]);
+    }
+
+    /**
+     * Notifies the reader that a seek has occurred.
+     * <p>
+     * Following a call to this method, the data passed to the next invocation of
+     * {@link #consume(ParsableByteArray, ExtractorOutput)} will not be a continuation of
+     * the data that was previously passed. Hence the reader should reset any internal state.
+     */
+    public void seek() {
+      seenFirstDts = false;
+      pesPayloadReader.seek();
+    }
+
+    /**
+     * Consumes the payload of a PS packet.
+     *
+     * @param data The PES packet. The position will be set to the start of the payload.
+     * @param output The output to which parsed data should be written.
+     */
+    public void consume(ParsableByteArray data, ExtractorOutput output) {
+      data.readBytes(pesScratch.data, 0, 3);
+      pesScratch.setPosition(0);
+      parseHeader();
+      data.readBytes(pesScratch.data, 0, extendedHeaderLength);
+      pesScratch.setPosition(0);
+      parseHeaderExtension();
+      pesPayloadReader.packetStarted(timeUs, true);
+      pesPayloadReader.consume(data);
+      // We always have complete PES packets with program stream.
+      pesPayloadReader.packetFinished();
+    }
+
+    private void parseHeader() {
+      // Note: see ISO/IEC 13818-1, section 2.4.3.6 for detailed information on the format of
+      // the header.
+      // First 8 bits are skipped: '10' (2), PES_scrambling_control (2), PES_priority (1),
+      // data_alignment_indicator (1), copyright (1), original_or_copy (1)
+      pesScratch.skipBits(8);
+      ptsFlag = pesScratch.readBit();
+      dtsFlag = pesScratch.readBit();
+      // ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
+      // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
+      pesScratch.skipBits(6);
+      extendedHeaderLength = pesScratch.readBits(8);
+    }
+
+    private void parseHeaderExtension() {
+      timeUs = 0;
+      if (ptsFlag) {
+        pesScratch.skipBits(4); // '0010' or '0011'
+        long pts = (long) pesScratch.readBits(3) << 30;
+        pesScratch.skipBits(1); // marker_bit
+        pts |= pesScratch.readBits(15) << 15;
+        pesScratch.skipBits(1); // marker_bit
+        pts |= pesScratch.readBits(15);
+        pesScratch.skipBits(1); // marker_bit
+        if (!seenFirstDts && dtsFlag) {
+          pesScratch.skipBits(4); // '0011'
+          long dts = (long) pesScratch.readBits(3) << 30;
+          pesScratch.skipBits(1); // marker_bit
+          dts |= pesScratch.readBits(15) << 15;
+          pesScratch.skipBits(1); // marker_bit
+          dts |= pesScratch.readBits(15);
+          pesScratch.skipBits(1); // marker_bit
+          // Subsequent PES packets may have earlier presentation timestamps than this one, but they
+          // should all be greater than or equal to this packet's decode timestamp. We feed the
+          // decode timestamp to the adjuster here so that in the case that this is the first to be
+          // fed, the adjuster will be able to compute an offset to apply such that the adjusted
+          // presentation timestamps of all future packets are non-negative.
+          ptsTimestampAdjuster.adjustTimestamp(dts);
+          seenFirstDts = true;
+        }
+        timeUs = ptsTimestampAdjuster.adjustTimestamp(pts);
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 9fee879779..675c626272 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -36,6 +36,10 @@
  */
 public final class TsExtractor implements Extractor {
 
+  public static final int WORKAROUND_ALLOW_NON_IDR_KEYFRAMES = 1;
+  public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
+  public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
+
   private static final String TAG = "TsExtractor";
 
   private static final int TS_PACKET_SIZE = 188;
@@ -60,7 +64,7 @@
   private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
 
   private final PtsTimestampAdjuster ptsTimestampAdjuster;
-  private final boolean idrKeyframesOnly;
+  private final int workaroundFlags;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
   /* package */ final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
@@ -75,12 +79,12 @@ public TsExtractor() {
   }
 
   public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster) {
-    this(ptsTimestampAdjuster, true);
+    this(ptsTimestampAdjuster, 0);
   }
 
-  public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, boolean idrKeyframesOnly) {
+  public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, int workaroundFlags) {
     this.ptsTimestampAdjuster = ptsTimestampAdjuster;
-    this.idrKeyframesOnly = idrKeyframesOnly;
+    this.workaroundFlags = workaroundFlags;
     tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
     tsPayloadReaders = new SparseArray<>();
@@ -337,8 +341,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA_LSF));
             break;
           case TS_STREAM_TYPE_AAC:
-            pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC),
-                new DummyTrackOutput());
+            pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_AAC_STREAM) != 0 ? null
+                : new AdtsReader(output.track(TS_STREAM_TYPE_AAC), new DummyTrackOutput());
             break;
           case TS_STREAM_TYPE_AC3:
             pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_AC3), false);
@@ -354,8 +358,10 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = new H262Reader(output.track(TS_STREAM_TYPE_H262));
             break;
           case TS_STREAM_TYPE_H264:
-            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264),
-                new SeiReader(output.track(TS_STREAM_TYPE_EIA608)), idrKeyframesOnly);
+            pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_H264_STREAM) != 0 ? null
+                : new H264Reader(output.track(TS_STREAM_TYPE_H264),
+                    new SeiReader(output.track(TS_STREAM_TYPE_EIA608)),
+                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0);
             break;
           case TS_STREAM_TYPE_H265:
             pesPayloadReader = new H265Reader(output.track(TS_STREAM_TYPE_H265),
@@ -371,7 +377,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
 
         if (pesPayloadReader != null) {
           streamTypes.put(streamType, true);
-          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
+          tsPayloadReaders.put(elementaryPid,
+              new PesReader(pesPayloadReader, ptsTimestampAdjuster));
         }
       }
 
@@ -422,7 +429,7 @@ private int readPrivateDataStreamType(ParsableByteArray data, int length) {
   /**
    * Parses PES packet data and extracts samples.
    */
-  private class PesReader extends TsPayloadReader {
+  private static final class PesReader extends TsPayloadReader {
 
     private static final int STATE_FINDING_HEADER = 0;
     private static final int STATE_READING_HEADER = 1;
@@ -433,8 +440,9 @@ private int readPrivateDataStreamType(ParsableByteArray data, int length) {
     private static final int MAX_HEADER_EXTENSION_SIZE = 10;
     private static final int PES_SCRATCH_SIZE = 10; // max(HEADER_SIZE, MAX_HEADER_EXTENSION_SIZE)
 
-    private final ParsableBitArray pesScratch;
     private final ElementaryStreamReader pesPayloadReader;
+    private final PtsTimestampAdjuster ptsTimestampAdjuster;
+    private final ParsableBitArray pesScratch;
 
     private int state;
     private int bytesRead;
@@ -447,8 +455,10 @@ private int readPrivateDataStreamType(ParsableByteArray data, int length) {
     private boolean dataAlignmentIndicator;
     private long timeUs;
 
-    public PesReader(ElementaryStreamReader pesPayloadReader) {
+    public PesReader(ElementaryStreamReader pesPayloadReader,
+        PtsTimestampAdjuster ptsTimestampAdjuster) {
       this.pesPayloadReader = pesPayloadReader;
+      this.ptsTimestampAdjuster = ptsTimestampAdjuster;
       pesScratch = new ParsableBitArray(new byte[PES_SCRATCH_SIZE]);
       state = STATE_FINDING_HEADER;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
index 1b73b5dfd2..1f036f8d27 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
@@ -22,7 +22,6 @@
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.nio.charset.Charset;
 import java.util.Stack;
 
 /**
@@ -215,9 +214,12 @@ private double readFloat(ExtractorInput input, int byteLength)
    */
   private String readString(ExtractorInput input, int byteLength)
       throws IOException, InterruptedException {
+    if (byteLength == 0) {
+      return "";
+    }
     byte[] stringBytes = new byte[byteLength];
     input.readFully(stringBytes, 0, byteLength);
-    return new String(stringBytes, Charset.forName(C.UTF8_NAME));
+    return new String(stringBytes);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
index d775b066c9..6cc845ba76 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
@@ -84,8 +84,10 @@ public long readUnsignedVarint(ExtractorInput input, boolean allowEndOfInput,
       return C.RESULT_MAX_LENGTH_EXCEEDED;
     }
 
-    // Read the remaining bytes.
-    input.readFully(scratch, 1, length - 1);
+    if (length != 1) {
+      // Read the remaining bytes.
+      input.readFully(scratch, 1, length - 1);
+    }
 
     state = STATE_BEGIN_READING;
     return assembleVarint(scratch, length, removeLengthMask);
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 803f8fbd79..39288400ff 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -39,6 +39,7 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+import android.text.TextUtils;
 import android.util.Log;
 
 import java.io.ByteArrayInputStream;
@@ -498,8 +499,21 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
         // The master source has yet to instantiate an adjuster for the discontinuity sequence.
         return;
       }
+      int workaroundFlags = 0;
+      String codecs = format.codecs;
+      if (!TextUtils.isEmpty(codecs)) {
+        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+        // exist. If we know from the codec attribute that they don't exist, then we can explicitly
+        // ignore them even if they're declared.
+        if (MimeTypes.getAudioMediaMimeType(codecs) != MimeTypes.AUDIO_AAC) {
+          workaroundFlags |= TsExtractor.WORKAROUND_IGNORE_AAC_STREAM;
+        }
+        if (MimeTypes.getVideoMediaMimeType(codecs) != MimeTypes.VIDEO_H264) {
+          workaroundFlags |= TsExtractor.WORKAROUND_IGNORE_H264_STREAM;
+        }
+      }
+      Extractor extractor = new TsExtractor(timestampAdjuster, workaroundFlags);
       ExposedTrack selectedTrack = tracks.get(selectedTrackIndex);
-      Extractor extractor = new TsExtractor(timestampAdjuster);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
           switchingVariantSpliced, selectedTrack.adaptiveMaxWidth, selectedTrack.adaptiveMaxHeight);
     } else {
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/BinaryFrame.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/BinaryFrame.java
new file mode 100644
index 0000000000..65eda909c2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/BinaryFrame.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata.id3;
+
+/**
+ * Binary ID3 frame.
+ */
+public final class BinaryFrame extends Id3Frame {
+
+  public final byte[] data;
+
+  public BinaryFrame(String type, byte[] data) {
+    super(type);
+    this.data = data;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/GeobFrame.java
similarity index 72%
rename from library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
rename to library/src/main/java/com/google/android/exoplayer/metadata/id3/GeobFrame.java
index 6cc61dd468..109b1fb4b0 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/GeobFrame.java
@@ -13,22 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.metadata;
+package com.google.android.exoplayer.metadata.id3;
 
 /**
- * A metadata that contains parsed ID3 GEOB (General Encapsulated Object) frame data associated
- * with time indices.
+ * GEOB (General Encapsulated Object) ID3 frame.
  */
-public final class GeobMetadata {
+public final class GeobFrame extends Id3Frame {
 
-  public static final String TYPE = "GEOB";
+  public static final String ID = "GEOB";
 
   public final String mimeType;
   public final String filename;
   public final String description;
   public final byte[] data;
 
-  public GeobMetadata(String mimeType, String filename, String description, byte[] data) {
+  public GeobFrame(String mimeType, String filename, String description, byte[] data) {
+    super(ID);
     this.mimeType = mimeType;
     this.filename = filename;
     this.description = description;
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Frame.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Frame.java
new file mode 100644
index 0000000000..11e6f33f0c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Frame.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.metadata.id3;
+
+/**
+ * Base class for ID3 frames.
+ */
+public abstract class Id3Frame {
+
+  /**
+   * The frame ID.
+   */
+  public final String id;
+
+  public Id3Frame(String id) {
+    this.id = id;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
similarity index 89%
rename from library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
rename to library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
index 6b52cb5371..deac62d8e5 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
@@ -13,22 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.metadata;
+package com.google.android.exoplayer.metadata.id3;
 
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.metadata.MetadataParser;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 
 /**
  * Extracts individual TXXX text frames from raw ID3 data.
  */
-public final class Id3Parser implements MetadataParser<Map<String, Object>> {
+public final class Id3Parser implements MetadataParser<List<Id3Frame>> {
 
   private static final int ID3_TEXT_ENCODING_ISO_8859_1 = 0;
   private static final int ID3_TEXT_ENCODING_UTF_16 = 1;
@@ -41,9 +42,9 @@ public boolean canParse(String mimeType) {
   }
 
   @Override
-  public Map<String, Object> parse(byte[] data, int size)
-      throws UnsupportedEncodingException, ParserException {
-    Map<String, Object> metadata = new HashMap<>();
+  public List<Id3Frame> parse(byte[] data, int size) throws UnsupportedEncodingException,
+      ParserException {
+    List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
     int id3Size = parseId3Header(id3Data);
 
@@ -70,9 +71,8 @@ public boolean canParse(String mimeType) {
         String description = new String(frame, 0, firstZeroIndex, charset);
         int valueStartIndex = firstZeroIndex + delimiterLength(encoding);
         int valueEndIndex = indexOfEOS(frame, valueStartIndex, encoding);
-        String value = new String(frame, valueStartIndex, valueEndIndex - valueStartIndex,
-            charset);
-        metadata.put(TxxxMetadata.TYPE, new TxxxMetadata(description, value));
+        String value = new String(frame, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+        id3Frames.add(new TxxxFrame(description, value));
       } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
         // Check frame ID == PRIV
         byte[] frame = new byte[frameSize];
@@ -82,7 +82,7 @@ public boolean canParse(String mimeType) {
         String owner = new String(frame, 0, firstZeroIndex, "ISO-8859-1");
         byte[] privateData = new byte[frameSize - firstZeroIndex - 1];
         System.arraycopy(frame, firstZeroIndex + 1, privateData, 0, frameSize - firstZeroIndex - 1);
-        metadata.put(PrivMetadata.TYPE, new PrivMetadata(owner, privateData));
+        id3Frames.add(new PrivFrame(owner, privateData));
       } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
         // Check frame ID == GEOB
         int encoding = id3Data.readUnsignedByte();
@@ -106,19 +106,18 @@ public boolean canParse(String mimeType) {
         byte[] objectData = new byte[objectDataSize];
         System.arraycopy(frame, descriptionEndIndex + delimiterLength(encoding), objectData, 0,
             objectDataSize);
-        metadata.put(GeobMetadata.TYPE, new GeobMetadata(mimeType, filename,
-            description, objectData));
+        id3Frames.add(new GeobFrame(mimeType, filename, description, objectData));
       } else {
         String type = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
         byte[] frame = new byte[frameSize];
         id3Data.readBytes(frame, 0, frameSize);
-        metadata.put(type, frame);
+        id3Frames.add(new BinaryFrame(type, frame));
       }
 
       id3Size -= frameSize + 10 /* header size */;
     }
 
-    return Collections.unmodifiableMap(metadata);
+    return Collections.unmodifiableList(id3Frames);
   }
 
   private static int indexOf(byte[] data, int fromIndex, byte key) {
@@ -150,8 +149,8 @@ private static int indexOfEOS(byte[] data, int fromIndex, int encodingByte) {
   }
 
   private static int delimiterLength(int encodingByte) {
-    return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1
-        || encodingByte == ID3_TEXT_ENCODING_UTF_8) ? 1 : 2;
+    return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8)
+        ? 1 : 2;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/PrivFrame.java
similarity index 73%
rename from library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
rename to library/src/main/java/com/google/android/exoplayer/metadata/id3/PrivFrame.java
index 94ba6e52cc..3a429b19e4 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/PrivFrame.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.metadata;
+package com.google.android.exoplayer.metadata.id3;
 
 /**
- * A metadata that contains parsed ID3 PRIV (Private) frame data associated
- * with time indices.
+ * PRIV (Private) ID3 frame.
  */
-public final class PrivMetadata {
+public final class PrivFrame extends Id3Frame {
 
-  public static final String TYPE = "PRIV";
+  public static final String ID = "PRIV";
 
   public final String owner;
   public final byte[] privateData;
 
-  public PrivMetadata(String owner, byte[] privateData) {
+  public PrivFrame(String owner, byte[] privateData) {
+    super(ID);
     this.owner = owner;
     this.privateData = privateData;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/TxxxFrame.java
similarity index 71%
rename from library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
rename to library/src/main/java/com/google/android/exoplayer/metadata/id3/TxxxFrame.java
index c0f1d2c5b3..f31ad9d54f 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/TxxxFrame.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.metadata;
+package com.google.android.exoplayer.metadata.id3;
 
 /**
- * A metadata that contains parsed ID3 TXXX (User defined text information) frame data associated
- * with time indices.
+ * TXXX (User defined text information) ID3 frame.
  */
-public final class TxxxMetadata {
+public final class TxxxFrame extends Id3Frame {
 
-  public static final String TYPE = "TXXX";
+  public static final String ID = "TXXX";
 
   public final String description;
   public final String value;
 
-  public TxxxMetadata(String description, String value) {
+  public TxxxFrame(String description, String value) {
+    super(ID);
     this.description = description;
     this.value = value;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
index 0fd1b1fcb6..e1f2bab41e 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/ClosedCaptionCtrl.java
@@ -94,4 +94,8 @@ public boolean isPreambleAddressCode() {
     return (cc1 >= 0x10 && cc1 <= 0x1F) && (cc2 >= 0x40 && cc2 <= 0x7F);
   }
 
+  public boolean isRepeatable() {
+    return cc1 >= 0x10 && cc1 <= 0x1F;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
index 4004846621..2e42f90be5 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -66,6 +66,7 @@
   private int captionRowCount;
   private String caption;
   private String lastRenderedCaption;
+  private ClosedCaptionCtrl repeatableControl;
 
   /**
    * @param source A source from which samples containing EIA-608 closed captions can be read.
@@ -102,6 +103,7 @@ protected void onEnabled(int track, long positionUs, boolean joining)
   @Override
   protected void onDiscontinuity(long positionUs) {
     inputStreamEnded = false;
+    repeatableControl = null;
     pendingCaptionLists.clear();
     clearPendingSample();
     captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
@@ -206,10 +208,20 @@ private void consumeCaptionList(ClosedCaptionList captionList) {
       return;
     }
 
+    boolean isRepeatableControl = false;
     for (int i = 0; i < captionBufferSize; i++) {
       ClosedCaption caption = captionList.captions[i];
       if (caption.type == ClosedCaption.TYPE_CTRL) {
         ClosedCaptionCtrl captionCtrl = (ClosedCaptionCtrl) caption;
+        isRepeatableControl = captionBufferSize == 1 && captionCtrl.isRepeatable();
+        if (isRepeatableControl && repeatableControl != null
+            && repeatableControl.cc1 == captionCtrl.cc1
+            && repeatableControl.cc2 == captionCtrl.cc2) {
+          repeatableControl = null;
+          continue;
+        } else if (isRepeatableControl) {
+          repeatableControl = captionCtrl;
+        }
         if (captionCtrl.isMiscCode()) {
           handleMiscCode(captionCtrl);
         } else if (captionCtrl.isPreambleAddressCode()) {
@@ -220,6 +232,9 @@ private void consumeCaptionList(ClosedCaptionList captionList) {
       }
     }
 
+    if (!isRepeatableControl) {
+      repeatableControl = null;
+    }
     if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
       caption = getDisplayCaption();
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
index 7c65a266d7..e681dd32e4 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
@@ -275,6 +275,7 @@ private static int parsePositionAnchor(String s) {
     switch (s) {
       case "start":
         return Cue.ANCHOR_TYPE_START;
+      case "center":
       case "middle":
         return Cue.ANCHOR_TYPE_MIDDLE;
       case "end":
@@ -290,6 +291,7 @@ private static Alignment parseTextAlignment(String s) {
       case "start":
       case "left":
         return Alignment.ALIGN_NORMAL;
+      case "center":
       case "middle":
         return Alignment.ALIGN_CENTER;
       case "end":
diff --git a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
index 75830c9cc9..7b4caae880 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.util;
 
+import java.nio.ByteBuffer;
 import java.util.Arrays;
 
 /**
@@ -48,6 +49,8 @@
     2f
   };
 
+  private static final int NAL_UNIT_TYPE_SPS = 7;
+
   private static final Object scratchEscapePositionsLock = new Object();
 
   /**
@@ -103,6 +106,43 @@ public static int unescapeStream(byte[] data, int limit) {
     }
   }
 
+  /**
+   * Discards data from the buffer up to the first SPS, where {@code data.position()} is interpreted
+   * as the length of the buffer.
+   * <p>
+   * When the method returns, {@code data.position()} will contain the new length of the buffer. If
+   * the buffer is not empty it is guaranteed to start with an SPS.
+   *
+   * @param data Buffer containing start code delimited NAL units.
+   */
+  public static void discardToSps(ByteBuffer data) {
+    int length = data.position();
+    int consecutiveZeros = 0;
+    int offset = 0;
+    while (offset + 1 < length) {
+      int value = data.get(offset) & 0xFF;
+      if (consecutiveZeros == 3) {
+        if (value == 1 && (data.get(offset + 1) & 0x1F) == NAL_UNIT_TYPE_SPS) {
+          // Copy from this NAL unit onwards to the start of the buffer.
+          ByteBuffer offsetData = data.duplicate();
+          offsetData.position(offset - 3);
+          offsetData.limit(length);
+          data.position(0);
+          data.put(offsetData);
+          return;
+        }
+      } else if (value == 0) {
+        consecutiveZeros++;
+      }
+      if (value != 0) {
+        consecutiveZeros = 0;
+      }
+      offset++;
+    }
+    // Empty the buffer if the SPS NAL unit was not found.
+    data.clear();
+  }
+
   /**
    * Constructs and returns a NAL unit with a start code followed by the data in {@code atom}.
    */
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index d96d879161..d272843d37 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1505"
-    android:versionName="1.5.5">
+    android:versionCode="1506"
+    android:versionName="1.5.6">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index b50b17ac6b..eaaef4aaa2 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -22,7 +22,6 @@
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecUtil;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.ChunkSource;
@@ -37,6 +36,7 @@
 import com.google.android.exoplayer.dash.mpd.Representation;
 import com.google.android.exoplayer.playbacktests.util.ActionSchedule;
 import com.google.android.exoplayer.playbacktests.util.CodecCountersUtil;
+import com.google.android.exoplayer.playbacktests.util.DebugMediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.playbacktests.util.ExoHostedTest;
 import com.google.android.exoplayer.playbacktests.util.HostActivity;
 import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
@@ -413,11 +413,11 @@ public DashHostedTest(String testName, MediaPresentationDescription mpd,
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, VIDEO_EVENT_ID,
           MIN_LOADABLE_RETRY_COUNT);
-      MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(host,
+      DebugMediaCodecVideoTrackRenderer videoRenderer = new DebugMediaCodecVideoTrackRenderer(host,
           videoSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
-          0, handler, logger, 50);
+          0, handler, logger, 50, fullPlaybackNoSeeking);
       videoCounters = videoRenderer.codecCounters;
-      player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
+      player.sendMessage(videoRenderer, DebugMediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
 
       // Build the audio renderer.
       DataSource audioDataSource = new DefaultUriDataSource(host, null, userAgent);
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
new file mode 100644
index 0000000000..62f351d999
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.util;
+
+import com.google.android.exoplayer.MediaCodecSelector;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Handler;
+
+/**
+ * Decodes and renders video using {@link MediaCodecVideoTrackRenderer}. Provides buffer timestamp
+ * assertions.
+ */
+@TargetApi(16)
+public class DebugMediaCodecVideoTrackRenderer extends MediaCodecVideoTrackRenderer {
+
+  private static final int ARRAY_SIZE = 1000;
+
+  public final long[] timestampsList = new long[ARRAY_SIZE];
+
+  private int startIndex;
+  private int queueSize;
+  private boolean enableBufferTimestampAssertions;
+
+  public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify,
+      boolean enableBufferTimestampAssertions) {
+    super(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
+        eventHandler, eventListener, maxDroppedFrameCountToNotify);
+    this.enableBufferTimestampAssertions = enableBufferTimestampAssertions;
+    startIndex = 0;
+    queueSize = 0;
+  }
+
+  @Override
+  protected void onQueuedInputBuffer(long presentationTimeUs) {
+    if (enableBufferTimestampAssertions) {
+      insertTimestamp(presentationTimeUs);
+      maybeShiftTimestampsList();
+    }
+  }
+
+  @Override
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    if (enableBufferTimestampAssertions) {
+      Assertions.checkArgument(dequeueTimestamp() == presentationTimeUs);
+    }
+  }
+
+  private void insertTimestamp(long presentationTimeUs) {
+    for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
+      if (presentationTimeUs >= timestampsList[i]) {
+        timestampsList[i + 1] = presentationTimeUs;
+        queueSize++;
+        return;
+      }
+      timestampsList[i + 1] = timestampsList[i];
+    }
+    timestampsList[startIndex] = presentationTimeUs;
+    queueSize++;
+  }
+
+  private void maybeShiftTimestampsList() {
+    if (startIndex + queueSize == ARRAY_SIZE) {
+      System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
+      startIndex = 0;
+    }
+  }
+
+  private long dequeueTimestamp() {
+    startIndex++;
+    queueSize--;
+    return timestampsList[startIndex - 1];
+  }
+}
