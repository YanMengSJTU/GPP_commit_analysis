diff --git a/demo/src/main/assets/media.exolist.json b/demo/src/main/assets/media.exolist.json
index 814c89a45b..dbff097473 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demo/src/main/assets/media.exolist.json
@@ -1,4 +1,15 @@
 [
+  {
+    "name": "SampleAES ",
+    "samples": [
+
+      {
+        "name": "sample-aes pure video-h264",
+        "uri": "http://10.86.107.208/test/Test/SampleAes/mlb_sample_aes/zwg_sample_aes_test_purevideo.m3u8"
+      }
+
+    ]
+  },
   {
     "name": "YouTube DASH",
     "samples": [
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 35a69df39e..bf4e3d9a4e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -22,643 +22,907 @@
 import android.media.MediaCodec;
 import android.media.MediaFormat;
 import android.support.annotation.IntDef;
+import android.util.Log;
 import android.view.Surface;
+
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.security.SecureRandom;
 import java.util.UUID;
+import java.util.Vector;
+
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+import static java.lang.Math.min;
 
 /**
  * Defines constants used by the library.
  */
 public final class C {
 
-  private C() {}
-
-  /**
-   * Special constant representing a time corresponding to the end of a source. Suitable for use in
-   * any time base.
-   */
-  public static final long TIME_END_OF_SOURCE = Long.MIN_VALUE;
-
-  /**
-   * Special constant representing an unset or unknown time or duration. Suitable for use in any
-   * time base.
-   */
-  public static final long TIME_UNSET = Long.MIN_VALUE + 1;
-
-  /**
-   * Represents an unset or unknown index.
-   */
-  public static final int INDEX_UNSET = -1;
-
-  /**
-   * Represents an unset or unknown position.
-   */
-  public static final int POSITION_UNSET = -1;
-
-  /**
-   * Represents an unset or unknown length.
-   */
-  public static final int LENGTH_UNSET = -1;
-
-  /**
-   * The number of microseconds in one second.
-   */
-  public static final long MICROS_PER_SECOND = 1000000L;
-
-  /**
-   * The number of nanoseconds in one second.
-   */
-  public static final long NANOS_PER_SECOND = 1000000000L;
-
-  /**
-   * The name of the UTF-8 charset.
-   */
-  public static final String UTF8_NAME = "UTF-8";
-
-  /**
-   * The name of the UTF-16 charset.
-   */
-  public static final String UTF16_NAME = "UTF-16";
-
-  /**
-   * * The name of the serif font family.
-   */
-  public static final String SERIF_NAME = "serif";
-
-  /**
-   * * The name of the sans-serif font family.
-   */
-  public static final String SANS_SERIF_NAME = "sans-serif";
-
-  /**
-   * Crypto modes for a codec.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
-  public @interface CryptoMode {}
-  /**
-   * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
-  /**
-   * @see MediaCodec#CRYPTO_MODE_AES_CTR
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
-  /**
-   * @see MediaCodec#CRYPTO_MODE_AES_CBC
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
-
-  /**
-   * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
-   * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
-
-  /**
-   * Represents an audio encoding, or an invalid or unset value.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
-      ENCODING_DTS_HD})
-  public @interface Encoding {}
-
-  /**
-   * Represents a PCM audio encoding, or an invalid or unset value.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
-  public @interface PcmEncoding {}
-  /**
-   * @see AudioFormat#ENCODING_INVALID
-   */
-  public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
-  /**
-   * @see AudioFormat#ENCODING_PCM_8BIT
-   */
-  public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
-  /**
-   * @see AudioFormat#ENCODING_PCM_16BIT
-   */
-  public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
-  /**
-   * PCM encoding with 24 bits per sample.
-   */
-  public static final int ENCODING_PCM_24BIT = 0x80000000;
-  /**
-   * PCM encoding with 32 bits per sample.
-   */
-  public static final int ENCODING_PCM_32BIT = 0x40000000;
-  /**
-   * @see AudioFormat#ENCODING_AC3
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
-  /**
-   * @see AudioFormat#ENCODING_E_AC3
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
-  /**
-   * @see AudioFormat#ENCODING_DTS
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
-  /**
-   * @see AudioFormat#ENCODING_DTS_HD
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
-
-  /**
-   * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
-   */
-  @SuppressWarnings({"InlinedApi", "deprecation"})
-  public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
-      ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
-
-  /**
-   * Stream types for an {@link android.media.AudioTrack}.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
-      STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
-  public @interface StreamType {}
-  /**
-   * @see AudioManager#STREAM_ALARM
-   */
-  public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
-  /**
-   * @see AudioManager#STREAM_MUSIC
-   */
-  public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
-  /**
-   * @see AudioManager#STREAM_NOTIFICATION
-   */
-  public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
-  /**
-   * @see AudioManager#STREAM_RING
-   */
-  public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
-  /**
-   * @see AudioManager#STREAM_SYSTEM
-   */
-  public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
-  /**
-   * @see AudioManager#STREAM_VOICE_CALL
-   */
-  public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
-  /**
-   * The default stream type used by audio renderers.
-   */
-  public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
-
-  /**
-   * Flags which can apply to a buffer containing a media sample.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
-      BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
-  public @interface BufferFlags {}
-  /**
-   * Indicates that a buffer holds a synchronization sample.
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
-  /**
-   * Flag for empty buffers that signal that the end of the stream was reached.
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
-  /**
-   * Indicates that a buffer is (at least partially) encrypted.
-   */
-  public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
-  /**
-   * Indicates that a buffer should be decoded but not rendered.
-   */
-  public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
-
-  /**
-   * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
-  public @interface VideoScalingMode {}
-  /**
-   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
-      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
-  /**
-   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
-      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
-  /**
-   * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
-   */
-  public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
-
-  /**
-   * Track selection flags.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
-      SELECTION_FLAG_AUTOSELECT})
-  public @interface SelectionFlags {}
-  /**
-   * Indicates that the track should be selected if user preferences do not state otherwise.
-   */
-  public static final int SELECTION_FLAG_DEFAULT = 1;
-  /**
-   * Indicates that the track must be displayed. Only applies to text tracks.
-   */
-  public static final int SELECTION_FLAG_FORCED = 2;
-  /**
-   * Indicates that the player may choose to play the track in absence of an explicit user
-   * preference.
-   */
-  public static final int SELECTION_FLAG_AUTOSELECT = 4;
-
-  /**
-   * Represents a streaming or other media type.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
-  public @interface ContentType {}
-  /**
-   * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
-   */
-  public static final int TYPE_DASH = 0;
-  /**
-   * Value returned by {@link Util#inferContentType(String)} for Smooth Streaming manifests.
-   */
-  public static final int TYPE_SS = 1;
-  /**
-   * Value returned by {@link Util#inferContentType(String)} for HLS manifests.
-   */
-  public static final int TYPE_HLS = 2;
-  /**
-   * Value returned by {@link Util#inferContentType(String)} for files other than DASH, HLS or
-   * Smooth Streaming manifests.
-   */
-  public static final int TYPE_OTHER = 3;
-
-  /**
-   * A return value for methods where the end of an input was encountered.
-   */
-  public static final int RESULT_END_OF_INPUT = -1;
-  /**
-   * A return value for methods where the length of parsed data exceeds the maximum length allowed.
-   */
-  public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
-  /**
-   * A return value for methods where nothing was read.
-   */
-  public static final int RESULT_NOTHING_READ = -3;
-  /**
-   * A return value for methods where a buffer was read.
-   */
-  public static final int RESULT_BUFFER_READ = -4;
-  /**
-   * A return value for methods where a format was read.
-   */
-  public static final int RESULT_FORMAT_READ = -5;
-
-  /**
-   * A data type constant for data of unknown or unspecified type.
-   */
-  public static final int DATA_TYPE_UNKNOWN = 0;
-  /**
-   * A data type constant for media, typically containing media samples.
-   */
-  public static final int DATA_TYPE_MEDIA = 1;
-  /**
-   * A data type constant for media, typically containing only initialization data.
-   */
-  public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
-  /**
-   * A data type constant for drm or encryption data.
-   */
-  public static final int DATA_TYPE_DRM = 3;
-  /**
-   * A data type constant for a manifest file.
-   */
-  public static final int DATA_TYPE_MANIFEST = 4;
-  /**
-   * A data type constant for time synchronization data.
-   */
-  public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
-  /**
-   * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
-   * equal to this value.
-   */
-  public static final int DATA_TYPE_CUSTOM_BASE = 10000;
-
-  /**
-   * A type constant for tracks of unknown type.
-   */
-  public static final int TRACK_TYPE_UNKNOWN = -1;
-  /**
-   * A type constant for tracks of some default type, where the type itself is unknown.
-   */
-  public static final int TRACK_TYPE_DEFAULT = 0;
-  /**
-   * A type constant for audio tracks.
-   */
-  public static final int TRACK_TYPE_AUDIO = 1;
-  /**
-   * A type constant for video tracks.
-   */
-  public static final int TRACK_TYPE_VIDEO = 2;
-  /**
-   * A type constant for text tracks.
-   */
-  public static final int TRACK_TYPE_TEXT = 3;
-  /**
-   * A type constant for metadata tracks.
-   */
-  public static final int TRACK_TYPE_METADATA = 4;
-  /**
-   * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
-   * equal to this value.
-   */
-  public static final int TRACK_TYPE_CUSTOM_BASE = 10000;
-
-  /**
-   * A selection reason constant for selections whose reasons are unknown or unspecified.
-   */
-  public static final int SELECTION_REASON_UNKNOWN = 0;
-  /**
-   * A selection reason constant for an initial track selection.
-   */
-  public static final int SELECTION_REASON_INITIAL = 1;
-  /**
-   * A selection reason constant for an manual (i.e. user initiated) track selection.
-   */
-  public static final int SELECTION_REASON_MANUAL = 2;
-  /**
-   * A selection reason constant for an adaptive track selection.
-   */
-  public static final int SELECTION_REASON_ADAPTIVE = 3;
-  /**
-   * A selection reason constant for a trick play track selection.
-   */
-  public static final int SELECTION_REASON_TRICK_PLAY = 4;
-  /**
-   * Applications or extensions may define custom {@code SELECTION_REASON_*} constants greater than
-   * or equal to this value.
-   */
-  public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
-
-  /**
-   * A default size in bytes for an individual allocation that forms part of a larger buffer.
-   */
-  public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
-
-  /**
-   * A default size in bytes for a video buffer.
-   */
-  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /**
-   * A default size in bytes for an audio buffer.
-   */
-  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /**
-   * A default size in bytes for a text buffer.
-   */
-  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /**
-   * A default size in bytes for a metadata buffer.
-   */
-  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /**
-   * A default size in bytes for a muxed buffer (e.g. containing video, audio and text).
-   */
-  public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE
-      + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
-
-  /**
-   * The Nil UUID as defined by
-   * <a href="https://tools.ietf.org/html/rfc4122#section-4.1.7">RFC4122</a>.
-   */
-  public static final UUID UUID_NIL = new UUID(0L, 0L);
-
-  /**
-   * UUID for the ClearKey DRM scheme.
-   * <p>
-   * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
-   */
-  public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
-
-  /**
-   * UUID for the Widevine DRM scheme.
-   * <p>
-   * Widevine is supported on Android devices running Android 4.3 (API Level 18) and up.
-   */
-  public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
-
-  /**
-   * UUID for the PlayReady DRM scheme.
-   * <p>
-   * PlayReady is supported on all AndroidTV devices. Note that most other Android devices do not
-   * provide PlayReady support.
-   */
-  public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
-
-  /**
-   * The type of a message that can be passed to a video {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be the target {@link Surface}, or null.
-   */
-  public static final int MSG_SET_SURFACE = 1;
-
-  /**
-   * A type of a message that can be passed to an audio {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be a {@link Float} with 0 being silence and 1 being unity gain.
-   */
-  public static final int MSG_SET_VOLUME = 2;
-
-  /**
-   * A type of a message that can be passed to an audio {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be one of the integer stream types in {@link C.StreamType}, and will specify the stream
-   * type of the underlying {@link android.media.AudioTrack}. See also
-   * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}. If the stream type
-   * is not set, audio renderers use {@link #STREAM_TYPE_DEFAULT}.
-   * <p>
-   * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
-   * introduce a brief gap in audio output. Note also that tracks in the same audio session must
-   * share the same routing, so a new audio session id will be generated.
-   */
-  public static final int MSG_SET_STREAM_TYPE = 3;
-
-  /**
-   * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
-   * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
-   * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
-   * <p>
-   * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
-   * owned by a {@link android.view.SurfaceView}.
-   */
-  public static final int MSG_SET_SCALING_MODE = 4;
-
-  /**
-   * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
-   * this value.
-   */
-  public static final int MSG_CUSTOM_BASE = 10000;
-
-  /**
-   * The stereo mode for 360/3D/VR videos.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({
-      Format.NO_VALUE,
-      STEREO_MODE_MONO,
-      STEREO_MODE_TOP_BOTTOM,
-      STEREO_MODE_LEFT_RIGHT,
-      STEREO_MODE_STEREO_MESH
-  })
-  public @interface StereoMode {}
-  /**
-   * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
-   */
-  public static final int STEREO_MODE_MONO = 0;
-  /**
-   * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
-   */
-  public static final int STEREO_MODE_TOP_BOTTOM = 1;
-  /**
-   * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
-   */
-  public static final int STEREO_MODE_LEFT_RIGHT = 2;
-  /**
-   * Indicates a stereo layout where the left and right eyes have separate meshes,
-   * used with 360/3D/VR videos.
-   */
-  public static final int STEREO_MODE_STEREO_MESH = 3;
-
-  /**
-   * Video colorspaces.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
-  public @interface ColorSpace {}
-  /**
-   * @see MediaFormat#COLOR_STANDARD_BT709
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
-  /**
-   * @see MediaFormat#COLOR_STANDARD_BT601_PAL
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
-  /**
-   * @see MediaFormat#COLOR_STANDARD_BT2020
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
-
-  /**
-   * Video color transfer characteristics.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
-  public @interface ColorTransfer {}
-  /**
-   * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
-  /**
-   * @see MediaFormat#COLOR_TRANSFER_ST2084
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
-  /**
-   * @see MediaFormat#COLOR_TRANSFER_HLG
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
-
-  /**
-   * Video color range.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
-  public @interface ColorRange {}
-  /**
-   * @see MediaFormat#COLOR_RANGE_LIMITED
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
-  /**
-   * @see MediaFormat#COLOR_RANGE_FULL
-   */
-  @SuppressWarnings("InlinedApi")
-  public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
-
-  /**
-   * Priority for media playback.
-   *
-   * <p>Larger values indicate higher priorities.
-   */
-  public static final int PRIORITY_PLAYBACK = 0;
-
-  /**
-   * Priority for media downloading.
-   *
-   * <p>Larger values indicate higher priorities.
-   */
-  public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
-
-  /**
-   * Converts a time in microseconds to the corresponding time in milliseconds, preserving
-   * {@link #TIME_UNSET} values.
-   *
-   * @param timeUs The time in microseconds.
-   * @return The corresponding time in milliseconds.
-   */
-  public static long usToMs(long timeUs) {
-    return timeUs == TIME_UNSET ? TIME_UNSET : (timeUs / 1000);
-  }
-
-  /**
-   * Converts a time in milliseconds to the corresponding time in microseconds, preserving
-   * {@link #TIME_UNSET} values.
-   *
-   * @param timeMs The time in milliseconds.
-   * @return The corresponding time in microseconds.
-   */
-  public static long msToUs(long timeMs) {
-    return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
-  }
-
-  /**
-   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
-   */
-  @TargetApi(21)
-  public static int generateAudioSessionIdV21(Context context) {
-    return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
-        .generateAudioSessionId();
-  }
+    private C() {
+    }
+
+
+    public static final int AES_BLOCK_LENGTH_BYTES = 16;
+
+    public static final int TS_STREAM_TYPE_H262 = 0x02;
+    public static final int TS_STREAM_TYPE_H264 = 0x1B;
+    public static final int TS_STREAM_TYPE_H265 = 0x24;
+    public static final int TS_STREAM_TYPE_SAMPLE_AES_H264 = 0xDB;
+    public static final int TS_STREAM_TYPE_SAMPLE_AES_H265 = 0xE4;
+
+    public static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
+    public static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
+    public static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
+
+    public static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
+    public static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
+    public static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+    public static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
+
+    public static final int NAL_UNIT_TYPE_SLICE = 1;
+    public static final String ENCRYPTION_METHOD_SAMPLE_AES = "SAMPLE-AES";
+    public static final String ENCRYPTION_METHOD_AES_128 = "AES-128";
+
+    public static final int TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES = 0xcf;
+    public static final int TS_STREAM_TYPE_AC3_SAMPLE_AES = 0xc1;
+    public static final int TS_STREAM_TYPE_EAC3_SAMPLE_AES = 0xc2;
+
+    public static final int TS_STREAM_TYPE_AAC = 0x0F;
+    public static final int TS_STREAM_TYPE_AC3 = 0x81;
+    public static final int TS_STREAM_TYPE_DTS = 0x8A;
+
+
+    /**
+     * Special constant representing a time corresponding to the end of a source. Suitable for use in
+     * any time base.
+     */
+    public static final long TIME_END_OF_SOURCE = Long.MIN_VALUE;
+
+    /**
+     * Special constant representing an unset or unknown time or duration. Suitable for use in any
+     * time base.
+     */
+    public static final long TIME_UNSET = Long.MIN_VALUE + 1;
+
+    /**
+     * Represents an unset or unknown index.
+     */
+    public static final int INDEX_UNSET = -1;
+
+    /**
+     * Represents an unset or unknown position.
+     */
+    public static final int POSITION_UNSET = -1;
+
+    /**
+     * Represents an unset or unknown length.
+     */
+    public static final int LENGTH_UNSET = -1;
+
+    /**
+     * The number of microseconds in one second.
+     */
+    public static final long MICROS_PER_SECOND = 1000000L;
+
+    /**
+     * The number of nanoseconds in one second.
+     */
+    public static final long NANOS_PER_SECOND = 1000000000L;
+
+    /**
+     * The name of the UTF-8 charset.
+     */
+    public static final String UTF8_NAME = "UTF-8";
+
+    /**
+     * The name of the UTF-16 charset.
+     */
+    public static final String UTF16_NAME = "UTF-16";
+
+    /**
+     * * The name of the serif font family.
+     */
+    public static final String SERIF_NAME = "serif";
+
+    /**
+     * * The name of the sans-serif font family.
+     */
+    public static final String SANS_SERIF_NAME = "sans-serif";
+
+    /**
+     * Crypto modes for a codec.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
+    public @interface CryptoMode {
+    }
+
+    /**
+     * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
+    /**
+     * @see MediaCodec#CRYPTO_MODE_AES_CTR
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
+    /**
+     * @see MediaCodec#CRYPTO_MODE_AES_CBC
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
+
+    /**
+     * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
+     * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
+
+    /**
+     * Represents an audio encoding, or an invalid or unset value.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+            ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
+            ENCODING_DTS_HD})
+    public @interface Encoding {
+    }
+
+    /**
+     * Represents a PCM audio encoding, or an invalid or unset value.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+            ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
+    public @interface PcmEncoding {
+    }
+
+    /**
+     * @see AudioFormat#ENCODING_INVALID
+     */
+    public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
+    /**
+     * @see AudioFormat#ENCODING_PCM_8BIT
+     */
+    public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
+    /**
+     * @see AudioFormat#ENCODING_PCM_16BIT
+     */
+    public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
+    /**
+     * PCM encoding with 24 bits per sample.
+     */
+    public static final int ENCODING_PCM_24BIT = 0x80000000;
+    /**
+     * PCM encoding with 32 bits per sample.
+     */
+    public static final int ENCODING_PCM_32BIT = 0x40000000;
+    /**
+     * @see AudioFormat#ENCODING_AC3
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
+    /**
+     * @see AudioFormat#ENCODING_E_AC3
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
+    /**
+     * @see AudioFormat#ENCODING_DTS
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
+    /**
+     * @see AudioFormat#ENCODING_DTS_HD
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
+
+    /**
+     * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
+     */
+    @SuppressWarnings({"InlinedApi", "deprecation"})
+    public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
+            ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
+
+    /**
+     * Stream types for an {@link android.media.AudioTrack}.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
+            STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
+    public @interface StreamType {
+    }
+
+    /**
+     * @see AudioManager#STREAM_ALARM
+     */
+    public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
+    /**
+     * @see AudioManager#STREAM_MUSIC
+     */
+    public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
+    /**
+     * @see AudioManager#STREAM_NOTIFICATION
+     */
+    public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
+    /**
+     * @see AudioManager#STREAM_RING
+     */
+    public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
+    /**
+     * @see AudioManager#STREAM_SYSTEM
+     */
+    public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
+    /**
+     * @see AudioManager#STREAM_VOICE_CALL
+     */
+    public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
+    /**
+     * The default stream type used by audio renderers.
+     */
+    public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
+
+    /**
+     * Flags which can apply to a buffer containing a media sample.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
+            BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
+    public @interface BufferFlags {
+    }
+
+    /**
+     * Indicates that a buffer holds a synchronization sample.
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
+    /**
+     * Flag for empty buffers that signal that the end of the stream was reached.
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+    /**
+     * Indicates that a buffer is (at least partially) encrypted.
+     */
+    public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
+    /**
+     * Indicates that a buffer should be decoded but not rendered.
+     */
+    public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
+
+    /**
+     * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
+    public @interface VideoScalingMode {
+    }
+
+    /**
+     * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
+            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
+    /**
+     * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
+            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
+    /**
+     * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
+     */
+    public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
+
+    /**
+     * Track selection flags.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
+            SELECTION_FLAG_AUTOSELECT})
+    public @interface SelectionFlags {
+    }
+
+    /**
+     * Indicates that the track should be selected if user preferences do not state otherwise.
+     */
+    public static final int SELECTION_FLAG_DEFAULT = 1;
+    /**
+     * Indicates that the track must be displayed. Only applies to text tracks.
+     */
+    public static final int SELECTION_FLAG_FORCED = 2;
+    /**
+     * Indicates that the player may choose to play the track in absence of an explicit user
+     * preference.
+     */
+    public static final int SELECTION_FLAG_AUTOSELECT = 4;
+
+    /**
+     * Represents a streaming or other media type.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
+    public @interface ContentType {
+    }
+
+    /**
+     * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
+     */
+    public static final int TYPE_DASH = 0;
+    /**
+     * Value returned by {@link Util#inferContentType(String)} for Smooth Streaming manifests.
+     */
+    public static final int TYPE_SS = 1;
+    /**
+     * Value returned by {@link Util#inferContentType(String)} for HLS manifests.
+     */
+    public static final int TYPE_HLS = 2;
+    /**
+     * Value returned by {@link Util#inferContentType(String)} for files other than DASH, HLS or
+     * Smooth Streaming manifests.
+     */
+    public static final int TYPE_OTHER = 3;
+
+    /**
+     * A return value for methods where the end of an input was encountered.
+     */
+    public static final int RESULT_END_OF_INPUT = -1;
+    /**
+     * A return value for methods where the length of parsed data exceeds the maximum length allowed.
+     */
+    public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
+    /**
+     * A return value for methods where nothing was read.
+     */
+    public static final int RESULT_NOTHING_READ = -3;
+    /**
+     * A return value for methods where a buffer was read.
+     */
+    public static final int RESULT_BUFFER_READ = -4;
+    /**
+     * A return value for methods where a format was read.
+     */
+    public static final int RESULT_FORMAT_READ = -5;
+
+    /**
+     * A data type constant for data of unknown or unspecified type.
+     */
+    public static final int DATA_TYPE_UNKNOWN = 0;
+    /**
+     * A data type constant for media, typically containing media samples.
+     */
+    public static final int DATA_TYPE_MEDIA = 1;
+    /**
+     * A data type constant for media, typically containing only initialization data.
+     */
+    public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
+    /**
+     * A data type constant for drm or encryption data.
+     */
+    public static final int DATA_TYPE_DRM = 3;
+    /**
+     * A data type constant for a manifest file.
+     */
+    public static final int DATA_TYPE_MANIFEST = 4;
+    /**
+     * A data type constant for time synchronization data.
+     */
+    public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
+    /**
+     * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
+     * equal to this value.
+     */
+    public static final int DATA_TYPE_CUSTOM_BASE = 10000;
+
+    /**
+     * A type constant for tracks of unknown type.
+     */
+    public static final int TRACK_TYPE_UNKNOWN = -1;
+    /**
+     * A type constant for tracks of some default type, where the type itself is unknown.
+     */
+    public static final int TRACK_TYPE_DEFAULT = 0;
+    /**
+     * A type constant for audio tracks.
+     */
+    public static final int TRACK_TYPE_AUDIO = 1;
+    /**
+     * A type constant for video tracks.
+     */
+    public static final int TRACK_TYPE_VIDEO = 2;
+    /**
+     * A type constant for text tracks.
+     */
+    public static final int TRACK_TYPE_TEXT = 3;
+    /**
+     * A type constant for metadata tracks.
+     */
+    public static final int TRACK_TYPE_METADATA = 4;
+    /**
+     * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
+     * equal to this value.
+     */
+    public static final int TRACK_TYPE_CUSTOM_BASE = 10000;
+
+    /**
+     * A selection reason constant for selections whose reasons are unknown or unspecified.
+     */
+    public static final int SELECTION_REASON_UNKNOWN = 0;
+    /**
+     * A selection reason constant for an initial track selection.
+     */
+    public static final int SELECTION_REASON_INITIAL = 1;
+    /**
+     * A selection reason constant for an manual (i.e. user initiated) track selection.
+     */
+    public static final int SELECTION_REASON_MANUAL = 2;
+    /**
+     * A selection reason constant for an adaptive track selection.
+     */
+    public static final int SELECTION_REASON_ADAPTIVE = 3;
+    /**
+     * A selection reason constant for a trick play track selection.
+     */
+    public static final int SELECTION_REASON_TRICK_PLAY = 4;
+    /**
+     * Applications or extensions may define custom {@code SELECTION_REASON_*} constants greater than
+     * or equal to this value.
+     */
+    public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
+
+    /**
+     * A default size in bytes for an individual allocation that forms part of a larger buffer.
+     */
+    public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
+
+    /**
+     * A default size in bytes for a video buffer.
+     */
+    public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+    /**
+     * A default size in bytes for an audio buffer.
+     */
+    public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+    /**
+     * A default size in bytes for a text buffer.
+     */
+    public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+    /**
+     * A default size in bytes for a metadata buffer.
+     */
+    public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
+
+    /**
+     * A default size in bytes for a muxed buffer (e.g. containing video, audio and text).
+     */
+    public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE
+            + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+
+    /**
+     * The Nil UUID as defined by
+     * <a href="https://tools.ietf.org/html/rfc4122#section-4.1.7">RFC4122</a>.
+     */
+    public static final UUID UUID_NIL = new UUID(0L, 0L);
+
+    /**
+     * UUID for the ClearKey DRM scheme.
+     * <p>
+     * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
+     */
+    public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
+
+    /**
+     * UUID for the Widevine DRM scheme.
+     * <p>
+     * Widevine is supported on Android devices running Android 4.3 (API Level 18) and up.
+     */
+    public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+
+    /**
+     * UUID for the PlayReady DRM scheme.
+     * <p>
+     * PlayReady is supported on all AndroidTV devices. Note that most other Android devices do not
+     * provide PlayReady support.
+     */
+    public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
+
+    /**
+     * The type of a message that can be passed to a video {@link Renderer} via
+     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+     * should be the target {@link Surface}, or null.
+     */
+    public static final int MSG_SET_SURFACE = 1;
+
+    /**
+     * A type of a message that can be passed to an audio {@link Renderer} via
+     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+     * should be a {@link Float} with 0 being silence and 1 being unity gain.
+     */
+    public static final int MSG_SET_VOLUME = 2;
+
+    /**
+     * A type of a message that can be passed to an audio {@link Renderer} via
+     * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+     * should be one of the integer stream types in {@link C.StreamType}, and will specify the stream
+     * type of the underlying {@link android.media.AudioTrack}. See also
+     * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}. If the stream type
+     * is not set, audio renderers use {@link #STREAM_TYPE_DEFAULT}.
+     * <p>
+     * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+     * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+     * share the same routing, so a new audio session id will be generated.
+     */
+    public static final int MSG_SET_STREAM_TYPE = 3;
+
+    /**
+     * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
+     * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
+     * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
+     * <p>
+     * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
+     * owned by a {@link android.view.SurfaceView}.
+     */
+    public static final int MSG_SET_SCALING_MODE = 4;
+
+    /**
+     * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
+     * this value.
+     */
+    public static final int MSG_CUSTOM_BASE = 10000;
+
+    /**
+     * The stereo mode for 360/3D/VR videos.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            Format.NO_VALUE,
+            STEREO_MODE_MONO,
+            STEREO_MODE_TOP_BOTTOM,
+            STEREO_MODE_LEFT_RIGHT,
+            STEREO_MODE_STEREO_MESH
+    })
+    public @interface StereoMode {
+    }
+
+    /**
+     * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
+     */
+    public static final int STEREO_MODE_MONO = 0;
+    /**
+     * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
+     */
+    public static final int STEREO_MODE_TOP_BOTTOM = 1;
+    /**
+     * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
+     */
+    public static final int STEREO_MODE_LEFT_RIGHT = 2;
+    /**
+     * Indicates a stereo layout where the left and right eyes have separate meshes,
+     * used with 360/3D/VR videos.
+     */
+    public static final int STEREO_MODE_STEREO_MESH = 3;
+
+    /**
+     * Video colorspaces.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
+    public @interface ColorSpace {
+    }
+
+    /**
+     * @see MediaFormat#COLOR_STANDARD_BT709
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
+    /**
+     * @see MediaFormat#COLOR_STANDARD_BT601_PAL
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
+    /**
+     * @see MediaFormat#COLOR_STANDARD_BT2020
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
+
+    /**
+     * Video color transfer characteristics.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
+    public @interface ColorTransfer {
+    }
+
+    /**
+     * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
+    /**
+     * @see MediaFormat#COLOR_TRANSFER_ST2084
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
+    /**
+     * @see MediaFormat#COLOR_TRANSFER_HLG
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
+
+    /**
+     * Video color range.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
+    public @interface ColorRange {
+    }
+
+    /**
+     * @see MediaFormat#COLOR_RANGE_LIMITED
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
+    /**
+     * @see MediaFormat#COLOR_RANGE_FULL
+     */
+    @SuppressWarnings("InlinedApi")
+    public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
+
+    /**
+     * Priority for media playback.
+     * <p>
+     * <p>Larger values indicate higher priorities.
+     */
+    public static final int PRIORITY_PLAYBACK = 0;
+
+    /**
+     * Priority for media downloading.
+     * <p>
+     * <p>Larger values indicate higher priorities.
+     */
+    public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
+
+    /**
+     * Converts a time in microseconds to the corresponding time in milliseconds, preserving
+     * {@link #TIME_UNSET} values.
+     *
+     * @param timeUs The time in microseconds.
+     * @return The corresponding time in milliseconds.
+     */
+    public static long usToMs(long timeUs) {
+        return timeUs == TIME_UNSET ? TIME_UNSET : (timeUs / 1000);
+    }
+
+    /**
+     * Converts a time in milliseconds to the corresponding time in microseconds, preserving
+     * {@link #TIME_UNSET} values.
+     *
+     * @param timeMs The time in milliseconds.
+     * @return The corresponding time in microseconds.
+     */
+    public static long msToUs(long timeMs) {
+        return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
+    }
+
+    /**
+     * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+     */
+    @TargetApi(21)
+    public static int generateAudioSessionIdV21(Context context) {
+        return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
+                .generateAudioSessionId();
+    }
+
+
+    public static final byte[] AES_CBC(byte[] content, byte[] keyBytes, byte[] iv, boolean bEncrypt) {
+        try {
+            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
+            keyGenerator.init(128, new SecureRandom(keyBytes));
+
+            SecretKey key = new SecretKeySpec(keyBytes, "AES");
+            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
+            bEncrypt = false;
+            if (bEncrypt)
+                cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
+            else
+                cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
+
+            byte[] result = cipher.doFinal(content);
+            return result;
+        } catch (Exception e) {
+            System.out.println("exception:" + e.toString());
+        }
+        return null;
+    }
+
+    /**
+     * Encryption of NAL units
+     * <p>
+     * Encrypted_nal_unit () {
+     * nal_unit_type_byte                // 1 byte
+     * unencrypted_leader                // 31 bytes
+     * while (bytes_remaining() > 0) {
+     * if (bytes_remaining() > 16) {
+     * encrypted_block           // 16 bytes
+     * }
+     * unencrypted_block           // MIN(144, bytes_remaining()) bytes
+     * }
+     * }
+     * <p>
+     * Each NAL unit is formed with start code emulation prevention applied. The preceding start code is not part of the protected block and is not encrypted. The byte containing the nal_unit_type value, plus the 31 bytes that follow, are unencrypted. The contiguous data that follows the unencrypted bytes is a protected block. Any protected block with a length of 16 bytes or fewer has no encryption applied; therefore, a NAL unit with length of 48 bytes or fewer is completely unencrypted.
+     * <p>
+     * The protected block uses 10% skip encryption. Each 16-byte block of encrypted data is followed by up to nine 16-byte blocks of unencrypted data.
+     *
+     *
+     * @param dataSampleAES IDR/Slice data
+     * @param sizeSampleAES size of sample-aes encrypted NAL data
+     * @param encrytionKey
+     * @param encryptionIv
+     */
+    public static final void decryptSampleAes_NAL(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
+        int skipSize = 3;
+        //sanity check the first 3 bytes
+        byte[] prefix = {0, 0, 0};
+        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), prefix, 0, skipSize);
+        Assertions.checkArgument(prefix[0] == 0 && prefix[1] == 0 && prefix[2] == 1);
+
+        int size = sizeSampleAES - skipSize;
+        Assertions.checkArgument(size > 0);
+
+        int tmp_nal_size = size;
+        Vector clearBytes = new Vector();
+        Vector encryptBytes = new Vector();
+
+        clearBytes.add(min(32, tmp_nal_size));
+        tmp_nal_size -= min(32, tmp_nal_size);
+
+        if (tmp_nal_size > 16) {
+            while (tmp_nal_size > 0) {
+                if (tmp_nal_size > 16) {
+                    encryptBytes.add(16);
+                    tmp_nal_size -= 16;
+                } else {
+                    encryptBytes.add(0);
+                }
+
+                if (tmp_nal_size > 0) {
+                    clearBytes.add(min(144, tmp_nal_size));
+                    tmp_nal_size -= min(144, tmp_nal_size);
+                }
+            }
+
+            if (encryptBytes.size() < clearBytes.size()) {
+                encryptBytes.add(0);
+            }
+        } else {
+            int lastValue = (int) clearBytes.lastElement();
+            int newValue = lastValue + tmp_nal_size;
+            int lastIndex = clearBytes.lastIndexOf(clearBytes.lastElement());
+            clearBytes.set(lastIndex, newValue);
+            encryptBytes.add(0);
+        }
+
+        //TODO: try zero-memcopy to improve performance
+        byte[] buffer = new byte[size];
+        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition() + skipSize, buffer, 0, size);
+        decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes );
+        System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition() + skipSize, size);
+    }
+
+
+    public static final void decryptSampleAes(byte[] buffer, int bufferSize, byte[] encrytionKey, byte[] encryptionIv, Vector clearBytes, Vector encryptBytes) {
+        //TODO: sanity check for input parameters
+        int numSubSamples = clearBytes.size();
+        int offset = 0;
+        byte[] packet_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
+        Assertions.checkArgument(encryptionIv.length == C.AES_BLOCK_LENGTH_BYTES);
+        System.arraycopy(encryptionIv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+
+        byte[] temp_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
+        int value = 0;
+
+        for (int i = 0; i < numSubSamples; i++) {
+            value = (int) clearBytes.elementAt(i);
+            offset += value;
+
+            int encryptSize = 0;
+            value = (int) encryptBytes.elementAt(i);
+            encryptSize = value;
+
+            Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
+            if (encryptSize > 0) {
+                Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
+                int ptr = offset + encryptSize - C.AES_BLOCK_LENGTH_BYTES;
+                System.arraycopy(buffer, offset, temp_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+
+                byte[] encryptData = new byte[encryptSize];
+                System.arraycopy(buffer, ptr, encryptData, 0, encryptSize);
+                byte[] decrypted = AES_CBC(encryptData, encrytionKey, packet_iv, false);
+                Assertions.checkArgument(decrypted.length % C.AES_BLOCK_LENGTH_BYTES == 0);
+                Assertions.checkArgument(decrypted.length == encryptSize);
+                //in-place: copy the decrypted content into the original position
+                System.arraycopy(decrypted, 0, buffer, offset, encryptSize);
+
+                offset += encryptSize;
+                System.arraycopy(temp_iv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+            }
+        }
+    }
+
+
+    /**
+     * Encryption of AAC Audio Frames
+     * <p>
+     * Encrypted_AAC_Frame () {
+     * ADTS_Header                        // 7 or 9 bytes
+     * unencrypted_leader                 // 16 bytes
+     * while (bytes_remaining() >= 16) {
+     * encrypted_block                // 16 bytes
+     * }
+     * unencrypted_trailer                // 0-15 bytes
+     * }
+     * <p>
+     * The ADTS header, which can be 7 or 9 bytes long, plus the first 16 bytes of the frame after it, are unencrypted. The contiguous data section that follows is encrypted. The size, in bytes, of the encrypted section must be an integer multiple of 16 and is possibly zero. The AAC frame ends with 0 to 15 unencrypted bytes. Start code emulation prevention is not performed on the encrypted frame.
+     *
+     * @param dataSampleAES IDR/Slice data, not used, use the sampleData directly to avoid data copy
+     * @param sizeSampleAES
+     */
+    public static final void decryptSampleAes_Audio(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
+        //TODO: sanity check for input parameters
+        int size = sizeSampleAES;
+        Assertions.checkArgument(size > 0);
+        if (size < 32)
+            return;
+
+        int tmp_nal_size = size;
+        Vector clearBytes = new Vector(2);
+        Vector encryptBytes = new Vector(2);
+
+        int audio_frame_size = size;
+        int index = 0;
+        int value = 0;
+
+        value = min(16, audio_frame_size);
+        clearBytes.add(value);
+
+        audio_frame_size -= value;
+
+        encryptBytes.add(audio_frame_size / 16 * 16);
+        index++;
+
+        audio_frame_size = audio_frame_size % 16;
+        if (audio_frame_size > 0) {
+            clearBytes.add(audio_frame_size);
+            encryptBytes.add(0);
+            index++;
+        }
+
+        //TODO: try zero-memcopy to improve performance
+        byte[] buffer = new byte[size];
+        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), buffer, 0, size);
+        decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes );
+        System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition(), size);
+    }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 0bffd28ba5..ecf1feb5d5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -18,8 +18,7 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.MediaFormat;
-import android.os.Parcel;
-import android.os.Parcelable;
+
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -34,7 +33,7 @@
 /**
  * Representation of a media format.
  */
-public final class Format implements Parcelable {
+public final class Format {
 
   /**
    * A value for various fields to indicate that the field's value is unknown or not applicable.
@@ -178,11 +177,14 @@
   @C.SelectionFlags
   public final int selectionFlags;
 
+
+
   /**
    * The language, or null if unknown or not applicable.
    */
   public final String language;
 
+  public final int streamType;
   /**
    * The Accessibility channel, or {@link #NO_VALUE} if not known or applicable.
    */
@@ -208,6 +210,14 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
     return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, initializationData, NO_VALUE, NO_VALUE, drmInitData);
   }
+  public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
+                                               int bitrate, int maxInputSize, int width, int height, float frameRate,
+                                               List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
+                                               DrmInitData drmInitData, int streamType) {
+    return createVideoSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, width,
+            height, frameRate, initializationData, rotationDegrees, pixelWidthHeightRatio, null,
+            NO_VALUE, null, drmInitData, streamType);
+  }
 
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate,
@@ -218,6 +228,17 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
         NO_VALUE, null, drmInitData);
   }
 
+  public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
+                                               int bitrate, int maxInputSize, int width, int height, float frameRate,
+                                               List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
+                                               byte[] projectionData, @C.StereoMode int stereoMode, ColorInfo colorInfo,
+                                               DrmInitData drmInitData, int streamType) {
+    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, width, height,
+            frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
+            colorInfo, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, NO_VALUE,
+            OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData, null, streamType);
+  }
+
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate,
       List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
@@ -248,6 +269,23 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
         sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language);
   }
 
+  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
+                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
+                                               List<byte[]> initializationData, DrmInitData drmInitData,
+                                               @C.SelectionFlags int selectionFlags, String language, int streamType) {
+    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
+            sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language, streamType);
+  }
+
+  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
+                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
+                                               @C.PcmEncoding int pcmEncoding, List<byte[]> initializationData, DrmInitData drmInitData,
+                                               @C.SelectionFlags int selectionFlags, String language, int streamType) {
+    return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
+            sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
+            selectionFlags, language, null, streamType);
+  }
+
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
       @C.PcmEncoding int pcmEncoding, List<byte[]> initializationData, DrmInitData drmInitData,
@@ -256,7 +294,16 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
         sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
         selectionFlags, language, null);
   }
-
+  public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
+                                               int bitrate, int maxInputSize, int channelCount, int sampleRate,
+                                               @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
+                                               List<byte[]> initializationData, DrmInitData drmInitData,
+                                               @C.SelectionFlags int selectionFlags, String language, Metadata metadata, int streamType) {
+    return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, NO_VALUE, NO_VALUE,
+            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, channelCount, sampleRate, pcmEncoding,
+            encoderDelay, encoderPadding, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+            initializationData, drmInitData, metadata, streamType);
+  }
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
       @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
@@ -338,19 +385,58 @@ public static Format createContainerFormat(String id, String containerMimeType,
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType,
-      long subsampleOffsetUs) {
+                                          long subsampleOffsetUs) {
     return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
+            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+            NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, DrmInitData drmInitData) {
+                                          int bitrate, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
+            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+            NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
   }
 
+  /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
+                       int bitrate, int maxInputSize, int width, int height, float frameRate, int rotationDegrees,
+                       float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
+                       ColorInfo colorInfo, int channelCount, int sampleRate, @C.PcmEncoding int pcmEncoding,
+                       int encoderDelay, int encoderPadding, @C.SelectionFlags int selectionFlags, String language,
+                       int accessibilityChannel, long subsampleOffsetUs, List<byte[]> initializationData,
+                       DrmInitData drmInitData, Metadata metadata, int streamType) {
+    this.id = id;
+    this.containerMimeType = containerMimeType;
+    this.sampleMimeType = sampleMimeType;
+    this.codecs = codecs;
+    this.bitrate = bitrate;
+    this.maxInputSize = maxInputSize;
+    this.width = width;
+    this.height = height;
+    this.frameRate = frameRate;
+    this.rotationDegrees = rotationDegrees;
+    this.pixelWidthHeightRatio = pixelWidthHeightRatio;
+    this.projectionData = projectionData;
+    this.stereoMode = stereoMode;
+    this.colorInfo = colorInfo;
+    this.channelCount = channelCount;
+    this.sampleRate = sampleRate;
+    this.pcmEncoding = pcmEncoding;
+    this.encoderDelay = encoderDelay;
+    this.encoderPadding = encoderPadding;
+    this.selectionFlags = selectionFlags;
+    this.language = language;
+    this.accessibilityChannel = accessibilityChannel;
+    this.subsampleOffsetUs = subsampleOffsetUs;
+    this.initializationData = initializationData == null ? Collections.<byte[]>emptyList()
+            : initializationData;
+    this.drmInitData = drmInitData;
+    this.metadata = metadata;
+    this.streamType = streamType;
+  }
+
+
+
   /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate, int rotationDegrees,
       float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
@@ -385,41 +471,7 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
         : initializationData;
     this.drmInitData = drmInitData;
     this.metadata = metadata;
-  }
-
-  @SuppressWarnings("ResourceType")
-  /* package */ Format(Parcel in) {
-    id = in.readString();
-    containerMimeType = in.readString();
-    sampleMimeType = in.readString();
-    codecs = in.readString();
-    bitrate = in.readInt();
-    maxInputSize = in.readInt();
-    width = in.readInt();
-    height = in.readInt();
-    frameRate = in.readFloat();
-    rotationDegrees = in.readInt();
-    pixelWidthHeightRatio = in.readFloat();
-    boolean hasProjectionData = in.readInt() != 0;
-    projectionData = hasProjectionData ? in.createByteArray() : null;
-    stereoMode = in.readInt();
-    colorInfo = in.readParcelable(ColorInfo.class.getClassLoader());
-    channelCount = in.readInt();
-    sampleRate = in.readInt();
-    pcmEncoding = in.readInt();
-    encoderDelay = in.readInt();
-    encoderPadding = in.readInt();
-    selectionFlags = in.readInt();
-    language = in.readString();
-    accessibilityChannel = in.readInt();
-    subsampleOffsetUs = in.readLong();
-    int initializationDataSize = in.readInt();
-    initializationData = new ArrayList<>(initializationDataSize);
-    for (int i = 0; i < initializationDataSize; i++) {
-      initializationData.add(in.createByteArray());
-    }
-    drmInitData = in.readParcelable(DrmInitData.class.getClassLoader());
-    metadata = in.readParcelable(Metadata.class.getClassLoader());
+    this.streamType = 0;
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
@@ -664,60 +716,4 @@ public static String toLogString(Format format) {
 
   // Parcelable implementation.
 
-  @Override
-  public int describeContents() {
-    return 0;
-  }
-
-  @Override
-  public void writeToParcel(Parcel dest, int flags) {
-    dest.writeString(id);
-    dest.writeString(containerMimeType);
-    dest.writeString(sampleMimeType);
-    dest.writeString(codecs);
-    dest.writeInt(bitrate);
-    dest.writeInt(maxInputSize);
-    dest.writeInt(width);
-    dest.writeInt(height);
-    dest.writeFloat(frameRate);
-    dest.writeInt(rotationDegrees);
-    dest.writeFloat(pixelWidthHeightRatio);
-    dest.writeInt(projectionData != null ? 1 : 0);
-    if (projectionData != null) {
-      dest.writeByteArray(projectionData);
-    }
-    dest.writeInt(stereoMode);
-    dest.writeParcelable(colorInfo, flags);
-    dest.writeInt(channelCount);
-    dest.writeInt(sampleRate);
-    dest.writeInt(pcmEncoding);
-    dest.writeInt(encoderDelay);
-    dest.writeInt(encoderPadding);
-    dest.writeInt(selectionFlags);
-    dest.writeString(language);
-    dest.writeInt(accessibilityChannel);
-    dest.writeLong(subsampleOffsetUs);
-    int initializationDataSize = initializationData.size();
-    dest.writeInt(initializationDataSize);
-    for (int i = 0; i < initializationDataSize; i++) {
-      dest.writeByteArray(initializationData.get(i));
-    }
-    dest.writeParcelable(drmInitData, 0);
-    dest.writeParcelable(metadata, 0);
-  }
-
-  public static final Creator<Format> CREATOR = new Creator<Format>() {
-
-    @Override
-    public Format createFromParcel(Parcel in) {
-      return new Format(in);
-    }
-
-    @Override
-    public Format[] newArray(int size) {
-      return new Format[size];
-    }
-
-  };
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index f7dadd51b2..1cf78f04f9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -61,6 +62,11 @@
   private AdtsReader reader;
   private boolean startedPacket;
 
+  private  int mMode = C.TS_STREAM_TYPE_AAC;
+  private  String encryptionMethod;
+  private  byte[] encryptionKey;
+  private  byte[] encryptionIv;
+
   public AdtsExtractor() {
     this(0);
   }
@@ -70,6 +76,18 @@ public AdtsExtractor(long firstSampleTimestampUs) {
     packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
   }
 
+  public AdtsExtractor(long firstSampleTimestampUs, HLSEncryptInfo hlsEncryptInfo) {
+    this.firstSampleTimestampUs = firstSampleTimestampUs;
+    packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
+    this.encryptionMethod = hlsEncryptInfo.encryptionMethod;
+    this.encryptionKey = hlsEncryptInfo.encryptionKey;
+    this.encryptionIv = hlsEncryptInfo.encryptionIv;
+    if ( encryptionMethod != null && encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES)) {
+      this.mMode = C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES;
+    }
+
+  }
+
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     // Skip any ID3 headers.
@@ -127,7 +145,8 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-    reader = new AdtsReader(true);
+
+    reader = new AdtsReader(true, mMode, encryptionKey, encryptionIv);
     reader.createTracks(output, new TrackIdGenerator(0, 1));
     output.endTracks();
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 7277df5bb8..8fe2ef198f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -17,326 +17,492 @@
 
 import android.util.Log;
 import android.util.Pair;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.security.SecureRandom;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Vector;
+
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+import static java.lang.Math.min;
 
 /**
  * Parses a continuous ADTS byte stream and extracts individual frames.
  */
 public final class AdtsReader implements ElementaryStreamReader {
 
-  private static final String TAG = "AdtsReader";
-
-  private static final int STATE_FINDING_SAMPLE = 0;
-  private static final int STATE_READING_ID3_HEADER = 1;
-  private static final int STATE_READING_ADTS_HEADER = 2;
-  private static final int STATE_READING_SAMPLE = 3;
-
-  private static final int HEADER_SIZE = 5;
-  private static final int CRC_SIZE = 2;
-
-  // Match states used while looking for the next sample
-  private static final int MATCH_STATE_VALUE_SHIFT = 8;
-  private static final int MATCH_STATE_START = 1 << MATCH_STATE_VALUE_SHIFT;
-  private static final int MATCH_STATE_FF = 2 << MATCH_STATE_VALUE_SHIFT;
-  private static final int MATCH_STATE_I = 3 << MATCH_STATE_VALUE_SHIFT;
-  private static final int MATCH_STATE_ID = 4 << MATCH_STATE_VALUE_SHIFT;
-
-  private static final int ID3_HEADER_SIZE = 10;
-  private static final int ID3_SIZE_OFFSET = 6;
-  private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
-
-  private final boolean exposeId3;
-  private final ParsableBitArray adtsScratch;
-  private final ParsableByteArray id3HeaderBuffer;
-  private final String language;
-
-  private String formatId;
-  private TrackOutput output;
-  private TrackOutput id3Output;
-
-  private int state;
-  private int bytesRead;
-
-  private int matchState;
-
-  private boolean hasCrc;
-
-  // Used when parsing the header.
-  private boolean hasOutputFormat;
-  private long sampleDurationUs;
-  private int sampleSize;
-
-  // Used when reading the samples.
-  private long timeUs;
-
-  private TrackOutput currentOutput;
-  private long currentSampleDuration;
-
-  /**
-   * @param exposeId3 True if the reader should expose ID3 information.
-   */
-  public AdtsReader(boolean exposeId3) {
-    this(exposeId3, null);
-  }
-
-  /**
-   * @param exposeId3 True if the reader should expose ID3 information.
-   * @param language Track language.
-   */
-  public AdtsReader(boolean exposeId3, String language) {
-    adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
-    id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
-    setFindingSampleState();
-    this.exposeId3 = exposeId3;
-    this.language = language;
-  }
-
-  @Override
-  public void seek() {
-    setFindingSampleState();
-  }
-
-  @Override
-  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    idGenerator.generateNewId();
-    formatId = idGenerator.getFormatId();
-    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
-    if (exposeId3) {
-      idGenerator.generateNewId();
-      id3Output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
-      id3Output.format(Format.createSampleFormat(idGenerator.getFormatId(),
-          MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE, null));
-    } else {
-      id3Output = new DummyTrackOutput();
+    private static final String TAG = "AdtsReader";
+
+    private static final int STATE_FINDING_SAMPLE = 0;
+    private static final int STATE_READING_ID3_HEADER = 1;
+    private static final int STATE_READING_ADTS_HEADER = 2;
+    private static final int STATE_READING_SAMPLE = 3;
+
+    private static final int HEADER_SIZE = 5;
+    private static final int CRC_SIZE = 2;
+
+    // Match states used while looking for the next sample
+    private static final int MATCH_STATE_VALUE_SHIFT = 8;
+    private static final int MATCH_STATE_START = 1 << MATCH_STATE_VALUE_SHIFT;
+    private static final int MATCH_STATE_FF = 2 << MATCH_STATE_VALUE_SHIFT;
+    private static final int MATCH_STATE_I = 3 << MATCH_STATE_VALUE_SHIFT;
+    private static final int MATCH_STATE_ID = 4 << MATCH_STATE_VALUE_SHIFT;
+
+    private static final int ID3_HEADER_SIZE = 10;
+    private static final int ID3_SIZE_OFFSET = 6;
+    private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
+
+    private final boolean exposeId3;
+    private final ParsableBitArray adtsScratch;
+    private final ParsableByteArray id3HeaderBuffer;
+    private final String language;
+
+    private String formatId;
+    private TrackOutput output;
+    private TrackOutput id3Output;
+
+    private int state;
+    private int bytesRead;
+
+    private int matchState;
+
+    private boolean hasCrc;
+
+    // Used when parsing the header.
+    private boolean hasOutputFormat;
+    private long sampleDurationUs;
+    private int sampleSize;
+
+    // Used when reading the samples.
+    private long timeUs;
+
+    private TrackOutput currentOutput;
+    private long currentSampleDuration;
+
+
+    private int mMode = C.TS_STREAM_TYPE_AAC;
+    private String encryptionMethod;
+    private byte[] encryptionKey;
+    private byte[] encryptionIv;
+
+
+    private ParsableByteArray sampleData;
+    private int writtenSampleSize;
+    private boolean bMyCode;
+    private boolean bParseID3;
+    private boolean bFirstSample;
+    private long totalBytesWritten;
+
+    /**
+     * @param exposeId3 True if the reader should expose ID3 information.
+     */
+    public AdtsReader(boolean exposeId3) {
+        this(exposeId3, null);
     }
-  }
-
-  @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    timeUs = pesTimeUs;
-  }
-
-  @Override
-  public void consume(ParsableByteArray data) {
-    while (data.bytesLeft() > 0) {
-      switch (state) {
-        case STATE_FINDING_SAMPLE:
-          findNextSample(data);
-          break;
-        case STATE_READING_ID3_HEADER:
-          if (continueRead(data, id3HeaderBuffer.data, ID3_HEADER_SIZE)) {
-            parseId3Header();
-          }
-          break;
-        case STATE_READING_ADTS_HEADER:
-          int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
-          if (continueRead(data, adtsScratch.data, targetLength)) {
-            parseAdtsHeader();
-          }
-          break;
-        case STATE_READING_SAMPLE:
-          readSample(data);
-          break;
-      }
+
+    public AdtsReader(boolean exposeId3, String language, int streamType, HLSEncryptInfo hlsEncryptInfo) {
+        this(exposeId3, language);
+
+
+        this.mMode = streamType;
+        this.encryptionKey = hlsEncryptInfo.encryptionKey;
+        this.encryptionIv = hlsEncryptInfo.encryptionIv;
     }
-  }
-
-  @Override
-  public void packetFinished() {
-    // Do nothing.
-  }
-
-  /**
-   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
-   * that the data should be written into {@code target} starting from an offset of zero.
-   *
-   * @param source The source from which to read.
-   * @param target The target into which data is to be read.
-   * @param targetLength The target length of the read.
-   * @return Whether the target length was reached.
-   */
-  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
-    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
-    source.readBytes(target, bytesRead, bytesToRead);
-    bytesRead += bytesToRead;
-    return bytesRead == targetLength;
-  }
-
-  /**
-   * Sets the state to STATE_FINDING_SAMPLE.
-   */
-  private void setFindingSampleState() {
-    state = STATE_FINDING_SAMPLE;
-    bytesRead = 0;
-    matchState = MATCH_STATE_START;
-  }
-
-  /**
-   * Sets the state to STATE_READING_ID3_HEADER and resets the fields required for
-   * {@link #parseId3Header()}.
-   */
-  private void setReadingId3HeaderState() {
-    state = STATE_READING_ID3_HEADER;
-    bytesRead = ID3_IDENTIFIER.length;
-    sampleSize = 0;
-    id3HeaderBuffer.setPosition(0);
-  }
-
-  /**
-   * Sets the state to STATE_READING_SAMPLE.
-   *
-   * @param outputToUse TrackOutput object to write the sample to
-   * @param currentSampleDuration Duration of the sample to be read
-   * @param priorReadBytes Size of prior read bytes
-   * @param sampleSize Size of the sample
-   */
-  private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
-      int priorReadBytes, int sampleSize) {
-    state = STATE_READING_SAMPLE;
-    bytesRead = priorReadBytes;
-    this.currentOutput = outputToUse;
-    this.currentSampleDuration = currentSampleDuration;
-    this.sampleSize = sampleSize;
-  }
-
-  /**
-   * Sets the state to STATE_READING_ADTS_HEADER.
-   */
-  private void setReadingAdtsHeaderState() {
-    state = STATE_READING_ADTS_HEADER;
-    bytesRead = 0;
-  }
-
-  /**
-   * Locates the next sample start, advancing the position to the byte that immediately follows
-   * identifier. If a sample was not located, the position is advanced to the limit.
-   *
-   * @param pesBuffer The buffer whose position should be advanced.
-   */
-  private void findNextSample(ParsableByteArray pesBuffer) {
-    byte[] adtsData = pesBuffer.data;
-    int position = pesBuffer.getPosition();
-    int endOffset = pesBuffer.limit();
-    while (position < endOffset) {
-      int data = adtsData[position++] & 0xFF;
-      if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
-        hasCrc = (data & 0x1) == 0;
-        setReadingAdtsHeaderState();
-        pesBuffer.setPosition(position);
-        return;
-      }
-      switch (matchState | data) {
-        case MATCH_STATE_START | 0xFF:
-          matchState = MATCH_STATE_FF;
-          break;
-        case MATCH_STATE_START | 'I':
-          matchState = MATCH_STATE_I;
-          break;
-        case MATCH_STATE_I | 'D':
-          matchState = MATCH_STATE_ID;
-          break;
-        case MATCH_STATE_ID | '3':
-          setReadingId3HeaderState();
-          pesBuffer.setPosition(position);
-          return;
-        default:
-          if (matchState != MATCH_STATE_START) {
-            // If matching fails in a later state, revert to MATCH_STATE_START and
-            // check this byte again
-            matchState = MATCH_STATE_START;
-            position--;
-          }
-          break;
-      }
+
+
+    public AdtsReader(boolean exposeId3, int streamType, byte[] encryptionKey, byte[] encryptionIv) {
+        this(exposeId3, null);
+
+        this.mMode = streamType;
+        this.encryptionKey = encryptionKey;
+        this.encryptionIv = encryptionIv;
+    }
+
+    /**
+     * @param exposeId3 True if the reader should expose ID3 information.
+     * @param language  Track language.
+     */
+    public AdtsReader(boolean exposeId3, String language) {
+        adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
+        id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
+        setFindingSampleState();
+        this.exposeId3 = exposeId3;
+        this.language = language;
+
+
+        bMyCode = false;//TODO:original code could handle AAC audio well, need further investigation here
+        bParseID3 = false;
+        bFirstSample = true;
+        sampleData = new ParsableByteArray();//TODO: it will "eat" huge memory, only used in dev stage, should use better mechnism
+        writtenSampleSize = 0;
+        totalBytesWritten = 0;
+    }
+
+    @Override
+    public void seek() {
+        setFindingSampleState();
+    }
+
+    @Override
+    public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+        idGenerator.generateNewId();
+        formatId = idGenerator.getFormatId();
+        output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
+        if (exposeId3) {
+            idGenerator.generateNewId();
+            id3Output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
+            id3Output.format(Format.createSampleFormat(idGenerator.getFormatId(),
+                    MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE, null));
+        } else {
+            id3Output = new DummyTrackOutput();
+        }
+    }
+
+    @Override
+    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+        timeUs = pesTimeUs;
     }
-    pesBuffer.setPosition(position);
-  }
-
-  /**
-   * Parses the Id3 header.
-   */
-  private void parseId3Header() {
-    id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);
-    id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);
-    setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
-        id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
-  }
-
-  /**
-   * Parses the sample header.
-   */
-  private void parseAdtsHeader() {
-    adtsScratch.setPosition(0);
-
-    if (!hasOutputFormat) {
-      int audioObjectType = adtsScratch.readBits(2) + 1;
-      if (audioObjectType != 2) {
-        // The stream indicates AAC-Main (1), AAC-SSR (3) or AAC-LTP (4). When the stream indicates
-        // AAC-Main it's more likely that the stream contains HE-AAC (5), which cannot be
-        // represented correctly in the 2 bit audio_object_type field in the ADTS header. In
-        // practice when the stream indicates AAC-SSR or AAC-LTP it more commonly contains AAC-LC or
-        // HE-AAC. Since most Android devices don't support AAC-Main, AAC-SSR or AAC-LTP, and since
-        // indicating AAC-LC works for HE-AAC streams, we pretend that we're dealing with AAC-LC and
-        // hope for the best. In practice this often works.
-        // See: https://github.com/google/ExoPlayer/issues/774
-        // See: https://github.com/google/ExoPlayer/issues/1383
-        Log.w(TAG, "Detected audio object type: " + audioObjectType + ", but assuming AAC LC.");
-        audioObjectType = 2;
-      }
-
-      int sampleRateIndex = adtsScratch.readBits(4);
-      adtsScratch.skipBits(1);
-      int channelConfig = adtsScratch.readBits(3);
-
-      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
-          audioObjectType, sampleRateIndex, channelConfig);
-      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
-          audioSpecificConfig);
-
-      Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
-          Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
-          Collections.singletonList(audioSpecificConfig), null, 0, language);
-      // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
-      // number of PCM audio samples per second.
-      sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
-      output.format(format);
-      hasOutputFormat = true;
-    } else {
-      adtsScratch.skipBits(10);
+
+    @Override
+    public void consume(ParsableByteArray data) {
+        int offset = data.getPosition();
+        int limit = data.limit();
+        int size = data.bytesLeft();
+
+        totalBytesWritten += data.bytesLeft();
+
+        if (bMyCode) {
+            if (bFirstSample) {
+                bFirstSample = false;
+                sampleData.reset((int) totalBytesWritten);
+                System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
+
+            } else {
+                int curLeft = sampleData.bytesLeft();
+                byte[] leftData = new byte[curLeft];
+                if (curLeft > 0) {
+                    System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
+                }
+                sampleData.reset(curLeft + size);
+                if (curLeft > 0) {
+                    System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
+                }
+                System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
+
+            }
+        }
+
+        while (data.bytesLeft() > 0) {
+            switch (state) {
+                case STATE_FINDING_SAMPLE:
+                    findNextSample(data);
+                    break;
+                case STATE_READING_ID3_HEADER:
+                    if (continueRead(data, id3HeaderBuffer.data, ID3_HEADER_SIZE)) {
+                        parseId3Header();
+                    }
+                    break;
+                case STATE_READING_ADTS_HEADER:
+                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
+                    if (continueRead(data, adtsScratch.data, targetLength)) {
+                        parseAdtsHeader();
+                    }
+                    break;
+                case STATE_READING_SAMPLE:
+                    readSample(data);
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public void packetFinished() {
+        // Do nothing.
+    }
+
+    /**
+     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+     * that the data should be written into {@code target} starting from an offset of zero.
+     *
+     * @param source       The source from which to read.
+     * @param target       The target into which data is to be read.
+     * @param targetLength The target length of the read.
+     * @return Whether the target length was reached.
+     */
+    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+        source.readBytes(target, bytesRead, bytesToRead);
+        bytesRead += bytesToRead;
+        return bytesRead == targetLength;
+    }
+
+    /**
+     * Sets the state to STATE_FINDING_SAMPLE.
+     */
+    private void setFindingSampleState() {
+        state = STATE_FINDING_SAMPLE;
+        bytesRead = 0;
+        matchState = MATCH_STATE_START;
+    }
+
+    /**
+     * Sets the state to STATE_READING_ID3_HEADER and resets the fields required for
+     * {@link #parseId3Header()}.
+     */
+    private void setReadingId3HeaderState() {
+        state = STATE_READING_ID3_HEADER;
+        bytesRead = ID3_IDENTIFIER.length;
+        bParseID3 = true;
+        sampleSize = 0;
+        id3HeaderBuffer.setPosition(0);
     }
 
-    adtsScratch.skipBits(4);
-    int sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
-    if (hasCrc) {
-      sampleSize -= CRC_SIZE;
+    /**
+     * Sets the state to STATE_READING_SAMPLE.
+     *
+     * @param outputToUse           TrackOutput object to write the sample to
+     * @param currentSampleDuration Duration of the sample to be read
+     * @param priorReadBytes        Size of prior read bytes
+     * @param sampleSize            Size of the sample
+     */
+    private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
+                                       int priorReadBytes, int sampleSize) {
+        state = STATE_READING_SAMPLE;
+        bytesRead = priorReadBytes;
+        this.currentOutput = outputToUse;
+        this.currentSampleDuration = currentSampleDuration;
+        this.sampleSize = sampleSize;
     }
 
-    setReadingSampleState(output, sampleDurationUs, 0, sampleSize);
-  }
-
-  /**
-   * Reads the rest of the sample
-   */
-  private void readSample(ParsableByteArray data) {
-    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
-    currentOutput.sampleData(data, bytesToRead);
-    bytesRead += bytesToRead;
-    if (bytesRead == sampleSize) {
-      currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
-      timeUs += currentSampleDuration;
-      setFindingSampleState();
+    /**
+     * Sets the state to STATE_READING_ADTS_HEADER.
+     */
+    private void setReadingAdtsHeaderState() {
+        state = STATE_READING_ADTS_HEADER;
+        bytesRead = 0;
+    }
+
+    /**
+     * Locates the next sample start, advancing the position to the byte that immediately follows
+     * identifier. If a sample was not located, the position is advanced to the limit.
+     *
+     * @param pesBuffer The buffer whose position should be advanced.
+     */
+    private void findNextSample(ParsableByteArray pesBuffer) {
+        byte[] adtsData = pesBuffer.data;
+        int position = pesBuffer.getPosition();
+        int endOffset = pesBuffer.limit();
+        bParseID3 = false;
+        while (position < endOffset) {
+            int data = adtsData[position++] & 0xFF;
+            if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
+                hasCrc = (data & 0x1) == 0;
+                setReadingAdtsHeaderState();
+                pesBuffer.setPosition(position);
+                return;
+            }
+            switch (matchState | data) {
+                case MATCH_STATE_START | 0xFF:
+                    matchState = MATCH_STATE_FF;
+                    break;
+                case MATCH_STATE_START | 'I':
+                    matchState = MATCH_STATE_I;
+                    break;
+                case MATCH_STATE_I | 'D':
+                    matchState = MATCH_STATE_ID;
+                    break;
+                case MATCH_STATE_ID | '3':
+                    setReadingId3HeaderState();
+                    pesBuffer.setPosition(position);
+                    bParseID3 = true;
+                    return;
+                default:
+                    if (matchState != MATCH_STATE_START) {
+                        // If matching fails in a later state, revert to MATCH_STATE_START and
+                        // check this byte again
+                        matchState = MATCH_STATE_START;
+                        position--;
+                    }
+                    break;
+            }
+        }
+        pesBuffer.setPosition(position);
+    }
+
+    /**
+     * Parses the Id3 header.
+     */
+    private void parseId3Header() {
+        id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);
+        id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);
+        setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
+                id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
+    }
+/**
+ * ADTS帧结构：
+
+ header     body
+
+ ADTS帧首部结构：
+ 序号 	域 	                  长度（bits） 	说明
+ 1 	    Syncword 	                  12 	all bits must be 1
+ 2 	    MPEG version 	              1 	0 for MPEG-4, 1 for MPEG-2
+ 3 	    Layer 	                      2 	always 0
+ 4 	    Protection Absent 	          1 	et to 1 if there is no CRC and 0 if there is CRC
+ 5 	    Profile 	                  2 	the MPEG-4 Audio Object Type minus 1
+ 6 	    MPEG-4 Sampling Frequency Index 	4 	MPEG-4 Sampling Frequency Index (15 is forbidden)
+ 7 	    Private Stream 	              1 	set to 0 when encoding, ignore when decoding
+ 8 	    MPEG-4 Channel Configuration  3 	MPEG-4 Channel Configuration (in the case of 0, the channel configuration is sent via an inband PCE)
+ 9 	    Originality 	              1 	set to 0 when encoding, ignore when decoding
+ 10 	Home 	                      1 	set to 0 when encoding, ignore when decoding
+ 11 	Copyrighted Stream 	          1 	set to 0 when encoding, ignore when decoding
+ 12 	Copyrighted Start 	          1 	set to 0 when encoding, ignore when decoding
+ 13 	Frame Length 	              13 	this value must include 7 or 9 bytes of header length:
+ FrameLength = (ProtectionAbsent == 1 ? 7 : 9) + size(AACFrame)
+ 14 	Buffer Fullness 	          11 	buffer fullness
+ 15 	Number of AAC Frames 	      2 	number of AAC frames (RDBs) in ADTS frame minus 1, for maximum compatibility always use 1 AAC frame per ADTS frame
+ 16 	CRC 	                      16 	CRC if protection absent is 0
+ */
+
+    /**
+     * Parses the sample header.
+     */
+    private void parseAdtsHeader() {
+        adtsScratch.setPosition(0);
+
+        if (!hasOutputFormat) {
+            int audioObjectType = adtsScratch.readBits(2) + 1;
+            if (audioObjectType != 2) {
+                // The stream indicates AAC-Main (1), AAC-SSR (3) or AAC-LTP (4). When the stream indicates
+                // AAC-Main it's more likely that the stream contains HE-AAC (5), which cannot be
+                // represented correctly in the 2 bit audio_object_type field in the ADTS header. In
+                // practice when the stream indicates AAC-SSR or AAC-LTP it more commonly contains AAC-LC or
+                // HE-AAC. Since most Android devices don't support AAC-Main, AAC-SSR or AAC-LTP, and since
+                // indicating AAC-LC works for HE-AAC streams, we pretend that we're dealing with AAC-LC and
+                // hope for the best. In practice this often works.
+                // See: https://github.com/google/ExoPlayer/issues/774
+                // See: https://github.com/google/ExoPlayer/issues/1383
+                Log.w(TAG, "Detected audio object type: " + audioObjectType + ", but assuming AAC LC.");
+                audioObjectType = 2;
+            }
+
+            int sampleRateIndex = adtsScratch.readBits(4);
+            adtsScratch.skipBits(1);
+            int channelConfig = adtsScratch.readBits(3);
+
+            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
+                    audioObjectType, sampleRateIndex, channelConfig);
+            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
+                    audioSpecificConfig);
+
+            Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
+                    Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
+                    Collections.singletonList(audioSpecificConfig), null, 0, language, mMode);
+            // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
+            // number of PCM audio samples per second.
+            sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
+            output.format(format);
+            hasOutputFormat = true;
+        } else {
+            adtsScratch.skipBits(10);
+        }
+
+        adtsScratch.skipBits(4);
+        int sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
+        if (hasCrc) {
+            sampleSize -= CRC_SIZE;
+        }
+
+        setReadingSampleState(output, sampleDurationUs, 0, sampleSize);
     }
-  }
 
+    /**
+     * Reads the rest of the sample
+     */
+    private void readSample(ParsableByteArray data) {
+
+        int skipSize = 0;
+        int realSampleSize = 0;
+
+
+        int headerSize = 2 /* the sync word */ + HEADER_SIZE;
+        if (hasCrc) {
+            headerSize += CRC_SIZE;
+        }
+
+        int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+
+
+        if (bMyCode) {
+            //Assertions.checkArgument(data.getPosition() );
+            if (bParseID3)
+                skipSize = bytesRead;
+            else
+                skipSize = headerSize;// when ID3 parsed, bytesRead != 0
+        }
+
+        if (!bMyCode) {
+
+            currentOutput.sampleData(data, bytesToRead);
+            writtenSampleSize += bytesToRead;
+        } else {
+            data.setPosition(data.getPosition() + bytesToRead);
+        }
+
+        bytesRead += bytesToRead;
+
+        if (bytesRead == sampleSize) {
+
+            if (bMyCode) {
+                if (skipSize != headerSize) //ID3 header parsed
+                    realSampleSize = bytesToRead;
+                else
+                    realSampleSize = sampleSize;
+
+                ParsableByteArray realSample = new ParsableByteArray();
+                realSample.reset(realSampleSize);
+                System.arraycopy(sampleData.data, sampleData.getPosition() + skipSize, realSample.data, 0, realSampleSize);
+                sampleData.setPosition(sampleData.getPosition() + skipSize + realSampleSize);
+
+                if (mMode == C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES) {
+                    C.decryptSampleAes_Audio(realSample, realSampleSize, encryptionKey, encryptionIv);
+                }
+
+                currentOutput.sampleData(realSample, realSampleSize);
+                writtenSampleSize += realSampleSize;
+            }
+
+            if (!bMyCode) {
+                currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+            } else {
+                int newOffset = (int) (writtenSampleSize - totalBytesWritten);
+                currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, newOffset, null);
+            }
+            timeUs += currentSampleDuration;
+
+            setFindingSampleState();
+        }
+
+    }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 4bc7f11c1a..edd0539ebb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -17,8 +17,11 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
+
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.lang.annotation.Retention;
@@ -89,14 +92,15 @@ public DefaultTsPayloadReaderFactory(@Flags int flags, List<Format> closedCaptio
   }
 
   @Override
-  public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
+  public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEncryptInfo hlsEncryptInfo) {
     switch (streamType) {
       case TsExtractor.TS_STREAM_TYPE_MPA:
       case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
         return new PesReader(new MpegAudioReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AAC:
+      case C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES:
         return isSet(FLAG_IGNORE_AAC_STREAM)
-            ? null : new PesReader(new AdtsReader(false, esInfo.language));
+            ? null : new PesReader(new AdtsReader(false, esInfo.language, streamType, hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_AC3:
       case TsExtractor.TS_STREAM_TYPE_E_AC3:
         return new PesReader(new Ac3Reader(esInfo.language));
@@ -106,9 +110,10 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader());
       case TsExtractor.TS_STREAM_TYPE_H264:
+      case C.TS_STREAM_TYPE_SAMPLE_AES_H264:
         return isSet(FLAG_IGNORE_H264_STREAM) ? null
             : new PesReader(new H264Reader(buildSeiReader(esInfo),
-                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS)));
+                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS), streamType, hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_H265:
         return new PesReader(new H265Reader(buildSeiReader(esInfo)));
       case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 8206ed7d6d..da2c2c7704 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -16,506 +16,595 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.ParsableNalUnitBitArray;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Vector;
+
+import android.util.Log;
 
 /**
  * Parses a continuous H264 byte stream and extracts individual frames.
  */
 public final class H264Reader implements ElementaryStreamReader {
+    private static final String TAG = "H264Reader";
 
-  private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
-  private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
-  private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
-
-  private final SeiReader seiReader;
-  private final boolean allowNonIdrKeyframes;
-  private final boolean detectAccessUnits;
-  private final NalUnitTargetBuffer sps;
-  private final NalUnitTargetBuffer pps;
-  private final NalUnitTargetBuffer sei;
-  private long totalBytesWritten;
-  private final boolean[] prefixFlags;
-
-  private String formatId;
-  private TrackOutput output;
-  private SampleReader sampleReader;
-
-  // State that should not be reset on seek.
-  private boolean hasOutputFormat;
-
-  // Per packet state that gets reset at the start of each packet.
-  private long pesTimeUs;
-
-  // Scratch variables to avoid allocations.
-  private final ParsableByteArray seiWrapper;
-
-  /**
-   * @param seiReader An SEI reader for consuming closed caption channels.
-   * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
-   *     synchronization samples (key-frames).
-   * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
-   *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
-   */
-  public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
-    this.seiReader = seiReader;
-    this.allowNonIdrKeyframes = allowNonIdrKeyframes;
-    this.detectAccessUnits = detectAccessUnits;
-    prefixFlags = new boolean[3];
-    sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
-    pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
-    sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
-    seiWrapper = new ParsableByteArray();
-  }
-
-  @Override
-  public void seek() {
-    NalUnitUtil.clearPrefixFlags(prefixFlags);
-    sps.reset();
-    pps.reset();
-    sei.reset();
-    sampleReader.reset();
-    totalBytesWritten = 0;
-  }
-
-  @Override
-  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    idGenerator.generateNewId();
-    formatId = idGenerator.getFormatId();
-    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
-    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
-    seiReader.createTracks(extractorOutput, idGenerator);
-  }
-
-  @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    this.pesTimeUs = pesTimeUs;
-  }
-
-  @Override
-  public void consume(ParsableByteArray data) {
-    int offset = data.getPosition();
-    int limit = data.limit();
-    byte[] dataArray = data.data;
-
-    // Append the data to the buffer.
-    totalBytesWritten += data.bytesLeft();
-    output.sampleData(data, data.bytesLeft());
-
-    // Scan the appended data, processing NAL units as they are encountered
-    while (true) {
-      int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
-
-      if (nalUnitOffset == limit) {
-        // We've scanned to the end of the data without finding the start of another NAL unit.
-        nalUnitData(dataArray, offset, limit);
-        return;
-      }
-
-      // We've seen the start of a NAL unit of the following type.
-      int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nalUnitOffset);
-
-      // This is the number of bytes from the current offset to the start of the next NAL unit.
-      // It may be negative if the NAL unit started in the previously consumed data.
-      int lengthToNalUnit = nalUnitOffset - offset;
-      if (lengthToNalUnit > 0) {
-        nalUnitData(dataArray, offset, nalUnitOffset);
-      }
-      int bytesWrittenPastPosition = limit - nalUnitOffset;
-      long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
-      // Indicate the end of the previous NAL unit. If the length to the start of the next unit
-      // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
-      // when notifying that the unit has ended.
-      endNalUnit(absolutePosition, bytesWrittenPastPosition,
-          lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
-      // Indicate the start of the next NAL unit.
-      startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
-      // Continue scanning the data.
-      offset = nalUnitOffset + 3;
-    }
-  }
+    private final SeiReader seiReader;
+    private final boolean allowNonIdrKeyframes;
+    private final boolean detectAccessUnits;
+    private final NalUnitTargetBuffer sps;
+    private final NalUnitTargetBuffer pps;
+    private final NalUnitTargetBuffer sei;
+    private long totalBytesWritten;
+    private final boolean[] prefixFlags;
 
-  @Override
-  public void packetFinished() {
-    // Do nothing.
-  }
+    private ParsableByteArray sampleData;
+    private int writtenSampleSize;
+    private int mMode = C.TS_STREAM_TYPE_H264;
+
+    private byte[] encryptionKey;
+    private byte[] encryptionIv;
+
+    private HLSEncryptInfo hlsEncryptInfo;
+
+    private boolean bFirstSample;
+    private String formatId;
+    private TrackOutput output;
+    private SampleReader sampleReader;
+
+    // State that should not be reset on seek.
+    private boolean hasOutputFormat;
+
+    // Per packet state that gets reset at the start of each packet.
+    private long pesTimeUs;
+
+    // Scratch variables to avoid allocations.
+    private final ParsableByteArray seiWrapper;
+
+    /**
+     * @param seiReader            An SEI reader for consuming closed caption channels.
+     * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
+     *                             synchronization samples (key-frames).
+     * @param detectAccessUnits    Whether to split the input stream into access units (samples) based on
+     *                             slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
+     */
+    public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
+        this.seiReader = seiReader;
+        this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+        this.detectAccessUnits = detectAccessUnits;
+        prefixFlags = new boolean[3];
+        sps = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_SPS, 128);
+        pps = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_PPS, 128);
+        sei = new NalUnitTargetBuffer(C.NAL_UNIT_TYPE_SEI, 128);
+        seiWrapper = new ParsableByteArray();
+
+        bFirstSample = true;
+        sampleData = new ParsableByteArray();
+        writtenSampleSize = 0;
 
-  private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
-    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-      sps.startNalUnit(nalUnitType);
-      pps.startNalUnit(nalUnitType);
-    }
-    sei.startNalUnit(nalUnitType);
-    sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
-  }
-
-  private void nalUnitData(byte[] dataArray, int offset, int limit) {
-    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-      sps.appendToNalUnit(dataArray, offset, limit);
-      pps.appendToNalUnit(dataArray, offset, limit);
     }
-    sei.appendToNalUnit(dataArray, offset, limit);
-    sampleReader.appendToNalUnit(dataArray, offset, limit);
-  }
-
-  private void endNalUnit(long position, int offset, int discardPadding, long pesTimeUs) {
-    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
-      sps.endNalUnit(discardPadding);
-      pps.endNalUnit(discardPadding);
-      if (!hasOutputFormat) {
-        if (sps.isCompleted() && pps.isCompleted()) {
-          List<byte[]> initializationData = new ArrayList<>();
-          initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
-          initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
-          NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
-          NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-          output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
-              Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
-              initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null));
-          hasOutputFormat = true;
-          sampleReader.putSps(spsData);
-          sampleReader.putPps(ppsData);
-          sps.reset();
-          pps.reset();
+
+    public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits, int streamType, HLSEncryptInfo hlsEncryptInfo) {
+        this(seiReader, allowNonIdrKeyframes, detectAccessUnits);
+        this.mMode = streamType;
+        this.hlsEncryptInfo = hlsEncryptInfo;
+        if (hlsEncryptInfo != null) {
+            this.encryptionIv = hlsEncryptInfo.encryptionIv;
+            this.encryptionKey = hlsEncryptInfo.encryptionKey;
         }
-      } else if (sps.isCompleted()) {
-        NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
-        sampleReader.putSps(spsData);
+
+    }
+
+    @Override
+    public void seek() {
+        NalUnitUtil.clearPrefixFlags(prefixFlags);
         sps.reset();
-      } else if (pps.isCompleted()) {
-        NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-        sampleReader.putPps(ppsData);
         pps.reset();
-      }
+        sei.reset();
+        sampleReader.reset();
+        totalBytesWritten = 0;
     }
-    if (sei.endNalUnit(discardPadding)) {
-      int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
-      seiWrapper.reset(sei.nalData, unescapedLength);
-      seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
-      seiReader.consume(pesTimeUs, seiWrapper);
+
+    @Override
+    public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+        idGenerator.generateNewId();
+        formatId = idGenerator.getFormatId();
+        output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
+        sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
+        seiReader.createTracks(extractorOutput, idGenerator);
     }
-    sampleReader.endNalUnit(position, offset);
-  }
 
-  /**
-   * Consumes a stream of NAL units and outputs samples.
-   */
-  private static final class SampleReader {
+    @Override
+    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+        this.pesTimeUs = pesTimeUs;
+    }
 
-    private static final int DEFAULT_BUFFER_SIZE = 128;
+    @Override
+    public void consume(ParsableByteArray data) {
+        int offset = data.getPosition();
+        int limit = data.limit();
+        byte[] dataArray = data.data;
+        int size = data.bytesLeft();
+
+        // Append the data to the buffer.
+        totalBytesWritten += data.bytesLeft();
+
+        data.setPosition(offset + size);
+
+
+        if (bFirstSample) {
+            bFirstSample = false;
+            sampleData.reset(size);
+            System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
+        } else {
+
+            int curLeft = sampleData.bytesLeft();
+            byte[] leftData = new byte[curLeft];
+            if (curLeft > 0) {
+                System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
+            }
+            sampleData.reset(curLeft + size);
+            if (curLeft > 0) {
+                System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
+            }
+            System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
+        }
 
-    private static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
-    private static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
-    private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
-    private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
-    private final TrackOutput output;
-    private final boolean allowNonIdrKeyframes;
-    private final boolean detectAccessUnits;
-    private final SparseArray<NalUnitUtil.SpsData> sps;
-    private final SparseArray<NalUnitUtil.PpsData> pps;
-    private final ParsableNalUnitBitArray bitArray;
-
-    private byte[] buffer;
-    private int bufferLength;
-
-    // Per NAL unit state. A sample consists of one or more NAL units.
-    private int nalUnitType;
-    private long nalUnitStartPosition;
-    private boolean isFilling;
-    private long nalUnitTimeUs;
-    private SliceHeaderData previousSliceHeader;
-    private SliceHeaderData sliceHeader;
-
-    // Per sample state that gets reset at the start of each sample.
-    private boolean readingSample;
-    private long samplePosition;
-    private long sampleTimeUs;
-    private boolean sampleIsKeyframe;
-
-    public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
-        boolean detectAccessUnits) {
-      this.output = output;
-      this.allowNonIdrKeyframes = allowNonIdrKeyframes;
-      this.detectAccessUnits = detectAccessUnits;
-      sps = new SparseArray<>();
-      pps = new SparseArray<>();
-      previousSliceHeader = new SliceHeaderData();
-      sliceHeader = new SliceHeaderData();
-      buffer = new byte[DEFAULT_BUFFER_SIZE];
-      bitArray = new ParsableNalUnitBitArray(buffer, 0, 0);
-      reset();
+        // Scan the appended data, processing NAL units as they are encountered
+        while (true) {
+            int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
+
+            int mybytesWrittenPastPosition = limit - nalUnitOffset;
+            int myabsolutePosition = (int) (totalBytesWritten - mybytesWrittenPastPosition);
+
+            if (nalUnitOffset == limit) {
+                // We've scanned to the end of the data without finding the start of another NAL unit.
+                nalUnitData(dataArray, offset, limit, myabsolutePosition, mybytesWrittenPastPosition);
+                return;
+            }
+
+            // We've seen the start of a NAL unit of the following type.
+            int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nalUnitOffset);
+
+            // This is the number of bytes from the current offset to the start of the next NAL unit.
+            // It may be negative if the NAL unit started in the previously consumed data.
+            int lengthToNalUnit = nalUnitOffset - offset;
+            if (lengthToNalUnit > 0) {
+                nalUnitData(dataArray, offset, nalUnitOffset, -1, -1);
+            }
+
+            int bytesWrittenPastPosition = limit - nalUnitOffset;
+            long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
+            // Indicate the end of the previous NAL unit. If the length to the start of the next unit
+            // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
+            // when notifying that the unit has ended.
+            endNalUnit(nalUnitType, absolutePosition, bytesWrittenPastPosition,
+                    lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
+            // Indicate the start of the next NAL unit.
+            startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
+            // Continue scanning the data.
+            offset = nalUnitOffset + 3;
+        }
     }
 
-    public boolean needsSpsPps() {
-      return detectAccessUnits;
+    @Override
+    public void packetFinished() {
+        // Do nothing.
     }
 
-    public void putSps(NalUnitUtil.SpsData spsData) {
-      sps.append(spsData.seqParameterSetId, spsData);
+    private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
+        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+            sps.startNalUnit(nalUnitType);
+            pps.startNalUnit(nalUnitType);
+        }
+        //  sei.startNalUnit(nalUnitType);
+        sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
     }
 
-    public void putPps(NalUnitUtil.PpsData ppsData) {
-      pps.append(ppsData.picParameterSetId, ppsData);
+    private void nalUnitData(byte[] dataArray, int offset, int limit, int mybytesWrittenPastPosition, int myabsolutePosition) {
+        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+            sps.appendToNalUnit(dataArray, offset, limit);
+            pps.appendToNalUnit(dataArray, offset, limit);
+        }
+        //sei.appendToNalUnit(dataArray, offset, limit);
+        sampleReader.appendToNalUnit(dataArray, offset, limit, mybytesWrittenPastPosition, myabsolutePosition);
     }
 
-    public void reset() {
-      isFilling = false;
-      readingSample = false;
-      sliceHeader.clear();
-    }
+    private void endNalUnit(int nalUnitType, long position, int offset, int discardPadding, long pesTimeUs) {
+        if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+            sps.endNalUnit(discardPadding);
+            pps.endNalUnit(discardPadding);
+            if (!hasOutputFormat) {
+                if (sps.isCompleted() && pps.isCompleted()) {
+                    List<byte[]> initializationData = new ArrayList<>();
+                    initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
+                    initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
+                    NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
+                    NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
+
+
+                    output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
+                            Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
+                            initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null, mMode));
+
+                    hasOutputFormat = true;
+                    sampleReader.putSps(spsData);
+                    sampleReader.putPps(ppsData);
+                    sps.reset();
+                    pps.reset();
+                }
+            } else if (sps.isCompleted()) {
+                NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
+                sampleReader.putSps(spsData);
+                sps.reset();
+            } else if (pps.isCompleted()) {
+                NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
+                sampleReader.putPps(ppsData);
+                pps.reset();
+            }
+        }
 
-    public void startNalUnit(long position, int type, long pesTimeUs) {
-      nalUnitType = type;
-      nalUnitTimeUs = pesTimeUs;
-      nalUnitStartPosition = position;
-      if ((allowNonIdrKeyframes && nalUnitType == NAL_UNIT_TYPE_NON_IDR)
-          || (detectAccessUnits && (nalUnitType == NAL_UNIT_TYPE_IDR
-              || nalUnitType == NAL_UNIT_TYPE_NON_IDR
-              || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
-        // Store the previous header and prepare to populate the new one.
-        SliceHeaderData newSliceHeader = previousSliceHeader;
-        previousSliceHeader = sliceHeader;
-        sliceHeader = newSliceHeader;
-        sliceHeader.clear();
-        bufferLength = 0;
-        isFilling = true;
-      }
+        // if (sei.endNalUnit(discardPadding)) {
+        //  int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
+        // seiWrapper.reset(sei.nalData, unescapedLength);
+        //  seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
+        // seiReader.consume(pesTimeUs, seiWrapper);
+        //  }
+        sampleReader.endNalUnit(nalUnitType, position, offset);
     }
 
+
     /**
-     * Called to pass stream data. The data passed should not include the 3 byte start code.
-     *
-     * @param data Holds the data being passed.
-     * @param offset The offset of the data in {@code data}.
-     * @param limit The limit (exclusive) of the data in {@code data}.
+     * Consumes a stream of NAL units and outputs samples.
      */
-    public void appendToNalUnit(byte[] data, int offset, int limit) {
-      if (!isFilling) {
-        return;
-      }
-      int readLength = limit - offset;
-      if (buffer.length < bufferLength + readLength) {
-        buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
-      }
-      System.arraycopy(data, offset, buffer, bufferLength, readLength);
-      bufferLength += readLength;
-
-      bitArray.reset(buffer, 0, bufferLength);
-      if (!bitArray.canReadBits(8)) {
-        return;
-      }
-      bitArray.skipBits(1); // forbidden_zero_bit
-      int nalRefIdc = bitArray.readBits(2);
-      bitArray.skipBits(5); // nal_unit_type
-
-      // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
-      // subsection 7.3.3.
-      if (!bitArray.canReadExpGolombCodedNum()) {
-        return;
-      }
-      bitArray.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
-      if (!bitArray.canReadExpGolombCodedNum()) {
-        return;
-      }
-      int sliceType = bitArray.readUnsignedExpGolombCodedInt();
-      if (!detectAccessUnits) {
-        // There are AUDs in the stream so the rest of the header can be ignored.
-        isFilling = false;
-        sliceHeader.setSliceType(sliceType);
-        return;
-      }
-      if (!bitArray.canReadExpGolombCodedNum()) {
-        return;
-      }
-      int picParameterSetId = bitArray.readUnsignedExpGolombCodedInt();
-      if (pps.indexOfKey(picParameterSetId) < 0) {
-        // We have not seen the PPS yet, so don't try to decode the slice header.
-        isFilling = false;
-        return;
-      }
-      NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
-      NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
-      if (spsData.separateColorPlaneFlag) {
-        if (!bitArray.canReadBits(2)) {
-          return;
+    private final class SampleReader {
+        private static final int DEFAULT_BUFFER_SIZE = 128;
+
+        private final TrackOutput output;
+        private final boolean allowNonIdrKeyframes;
+        private final boolean detectAccessUnits;
+        private final SparseArray<NalUnitUtil.SpsData> sps;
+        private final SparseArray<NalUnitUtil.PpsData> pps;
+        private final ParsableNalUnitBitArray bitArray;
+
+        private byte[] buffer;
+        private int bufferLength;
+
+        // Per NAL unit state. A sample consists of one or more NAL units.
+        private int nalUnitType;
+        private long nalUnitStartPosition;
+        private boolean isFilling;
+        private long nalUnitTimeUs;
+        private SliceHeaderData previousSliceHeader;
+        private SliceHeaderData sliceHeader;
+
+        // Per sample state that gets reset at the start of each sample.
+        private boolean readingSample;
+        private long samplePosition;
+        private long sampleTimeUs;
+        private boolean sampleIsKeyframe;
+
+        public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
+                            boolean detectAccessUnits) {
+            this.output = output;
+            this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+            this.detectAccessUnits = detectAccessUnits;
+            sps = new SparseArray<>();
+            pps = new SparseArray<>();
+            previousSliceHeader = new SliceHeaderData();
+            sliceHeader = new SliceHeaderData();
+            buffer = new byte[DEFAULT_BUFFER_SIZE];
+            bitArray = new ParsableNalUnitBitArray(buffer, 0, 0);
+            reset();
         }
-        bitArray.skipBits(2); // colour_plane_id
-      }
-      if (!bitArray.canReadBits(spsData.frameNumLength)) {
-        return;
-      }
-      boolean fieldPicFlag = false;
-      boolean bottomFieldFlagPresent = false;
-      boolean bottomFieldFlag = false;
-      int frameNum = bitArray.readBits(spsData.frameNumLength);
-      if (!spsData.frameMbsOnlyFlag) {
-        if (!bitArray.canReadBits(1)) {
-          return;
-        }
-        fieldPicFlag = bitArray.readBit();
-        if (fieldPicFlag) {
-          if (!bitArray.canReadBits(1)) {
-            return;
-          }
-          bottomFieldFlag = bitArray.readBit();
-          bottomFieldFlagPresent = true;
+
+        public boolean needsSpsPps() {
+            return detectAccessUnits;
         }
-      }
-      boolean idrPicFlag = nalUnitType == NAL_UNIT_TYPE_IDR;
-      int idrPicId = 0;
-      if (idrPicFlag) {
-        if (!bitArray.canReadExpGolombCodedNum()) {
-          return;
+
+        public void putSps(NalUnitUtil.SpsData spsData) {
+            sps.append(spsData.seqParameterSetId, spsData);
         }
-        idrPicId = bitArray.readUnsignedExpGolombCodedInt();
-      }
-      int picOrderCntLsb = 0;
-      int deltaPicOrderCntBottom = 0;
-      int deltaPicOrderCnt0 = 0;
-      int deltaPicOrderCnt1 = 0;
-      if (spsData.picOrderCountType == 0) {
-        if (!bitArray.canReadBits(spsData.picOrderCntLsbLength)) {
-          return;
+
+        public void putPps(NalUnitUtil.PpsData ppsData) {
+            pps.append(ppsData.picParameterSetId, ppsData);
         }
-        picOrderCntLsb = bitArray.readBits(spsData.picOrderCntLsbLength);
-        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
-          if (!bitArray.canReadExpGolombCodedNum()) {
-            return;
-          }
-          deltaPicOrderCntBottom = bitArray.readSignedExpGolombCodedInt();
+
+        public void reset() {
+            isFilling = false;
+            readingSample = false;
+            sliceHeader.clear();
         }
-      } else if (spsData.picOrderCountType == 1
-          && !spsData.deltaPicOrderAlwaysZeroFlag) {
-        if (!bitArray.canReadExpGolombCodedNum()) {
-          return;
+
+        public void startNalUnit(long position, int type, long pesTimeUs) {
+            nalUnitType = type;
+            nalUnitTimeUs = pesTimeUs;
+            nalUnitStartPosition = position;
+
+            if ((allowNonIdrKeyframes && nalUnitType == C.NAL_UNIT_TYPE_NON_IDR)
+                    || (detectAccessUnits && (nalUnitType == C.NAL_UNIT_TYPE_IDR
+                    || nalUnitType == C.NAL_UNIT_TYPE_NON_IDR
+                    || nalUnitType == C.NAL_UNIT_TYPE_PARTITION_A))) {
+                // Store the previous header and prepare to populate the new one.
+                SliceHeaderData newSliceHeader = previousSliceHeader;
+                previousSliceHeader = sliceHeader;
+                sliceHeader = newSliceHeader;
+                sliceHeader.clear();
+                bufferLength = 0;
+                isFilling = true;
+            }
         }
-        deltaPicOrderCnt0 = bitArray.readSignedExpGolombCodedInt();
-        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
-          if (!bitArray.canReadExpGolombCodedNum()) {
-            return;
-          }
-          deltaPicOrderCnt1 = bitArray.readSignedExpGolombCodedInt();
+
+        /**
+         * Called to pass stream data. The data passed should not include the 3 byte start code.
+         *
+         * @param data   Holds the data being passed.
+         * @param offset The offset of the data in {@code data}.
+         * @param limit  The limit (exclusive) of the data in {@code data}.
+         */
+        public void appendToNalUnit(byte[] data, int offset, int limit, int mybytesWrittenPastPosition, int myabsolutePosition) {
+            if (!isFilling) {
+                return;
+            }
+            int readLength = limit - offset;
+            if (buffer.length < bufferLength + readLength) {
+                buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
+            }
+            System.arraycopy(data, offset, buffer, bufferLength, readLength);
+            bufferLength += readLength;
+
+            bitArray.reset(buffer, 0, bufferLength);
+            if (!bitArray.canReadBits(8)) {
+                return;
+            }
+            bitArray.skipBits(1); // forbidden_zero_bit
+            int nalRefIdc = bitArray.readBits(2);
+            bitArray.skipBits(5); // nal_unit_type
+
+            // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
+            // subsection 7.3.3.
+            if (!bitArray.canReadExpGolombCodedNum()) {
+                return;
+            }
+            bitArray.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
+            if (!bitArray.canReadExpGolombCodedNum()) {
+                return;
+            }
+            int sliceType = bitArray.readUnsignedExpGolombCodedInt();
+            if (!detectAccessUnits) {
+                // There are AUDs in the stream so the rest of the header can be ignored.
+                isFilling = false;
+                sliceHeader.setSliceType(sliceType);
+                return;
+            }
+            if (!bitArray.canReadExpGolombCodedNum()) {
+                return;
+            }
+            int picParameterSetId = bitArray.readUnsignedExpGolombCodedInt();
+            if (pps.indexOfKey(picParameterSetId) < 0) {
+                // We have not seen the PPS yet, so don't try to decode the slice header.
+                isFilling = false;
+                return;
+            }
+            NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
+            NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
+            if (spsData.separateColorPlaneFlag) {
+                if (!bitArray.canReadBits(2)) {
+                    return;
+                }
+                bitArray.skipBits(2); // colour_plane_id
+            }
+            if (!bitArray.canReadBits(spsData.frameNumLength)) {
+                return;
+            }
+            boolean fieldPicFlag = false;
+            boolean bottomFieldFlagPresent = false;
+            boolean bottomFieldFlag = false;
+            int frameNum = bitArray.readBits(spsData.frameNumLength);
+            if (!spsData.frameMbsOnlyFlag) {
+                if (!bitArray.canReadBits(1)) {
+                    return;
+                }
+                fieldPicFlag = bitArray.readBit();
+                if (fieldPicFlag) {
+                    if (!bitArray.canReadBits(1)) {
+                        return;
+                    }
+                    bottomFieldFlag = bitArray.readBit();
+                    bottomFieldFlagPresent = true;
+                }
+            }
+            boolean idrPicFlag = nalUnitType == C.NAL_UNIT_TYPE_IDR;
+            int idrPicId = 0;
+            if (idrPicFlag) {
+                if (!bitArray.canReadExpGolombCodedNum()) {
+                    return;
+                }
+                idrPicId = bitArray.readUnsignedExpGolombCodedInt();
+            }
+            int picOrderCntLsb = 0;
+            int deltaPicOrderCntBottom = 0;
+            int deltaPicOrderCnt0 = 0;
+            int deltaPicOrderCnt1 = 0;
+            if (spsData.picOrderCountType == 0) {
+                if (!bitArray.canReadBits(spsData.picOrderCntLsbLength)) {
+                    return;
+                }
+                picOrderCntLsb = bitArray.readBits(spsData.picOrderCntLsbLength);
+                if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+                    if (!bitArray.canReadExpGolombCodedNum()) {
+                        return;
+                    }
+                    deltaPicOrderCntBottom = bitArray.readSignedExpGolombCodedInt();
+                }
+            } else if (spsData.picOrderCountType == 1
+                    && !spsData.deltaPicOrderAlwaysZeroFlag) {
+                if (!bitArray.canReadExpGolombCodedNum()) {
+                    return;
+                }
+                deltaPicOrderCnt0 = bitArray.readSignedExpGolombCodedInt();
+                if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+                    if (!bitArray.canReadExpGolombCodedNum()) {
+                        return;
+                    }
+                    deltaPicOrderCnt1 = bitArray.readSignedExpGolombCodedInt();
+                }
+            }
+            sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
+                    bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
+                    deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
+            isFilling = false;
         }
-      }
-      sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
-          bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
-          deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
-      isFilling = false;
-    }
 
-    public void endNalUnit(long position, int offset) {
-      if (nalUnitType == NAL_UNIT_TYPE_AUD
-          || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
-        // If the NAL unit ending is the start of a new sample, output the previous one.
-        if (readingSample) {
-          int nalUnitLength = (int) (position - nalUnitStartPosition);
-          outputSample(offset + nalUnitLength);
+
+        public void endNalUnit(int curNALUnitType, long position, int offset) {
+            int size = (int) (position - nalUnitStartPosition);
+            Assertions.checkArgument(size > 0);
+
+            if (mMode == C.TS_STREAM_TYPE_SAMPLE_AES_H264) {
+                int previousNALUnitType = nalUnitType;
+
+                if (curNALUnitType == 5 && curNALUnitType == previousNALUnitType) {
+                    C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
+                }
+                if (curNALUnitType == 1 && curNALUnitType == previousNALUnitType) {
+                    C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
+                }
+
+                if (curNALUnitType == C.NAL_UNIT_TYPE_AUD) {
+                    if ((previousNALUnitType == C.NAL_UNIT_TYPE_IDR) || (previousNALUnitType == C.NAL_UNIT_TYPE_SLICE)) {
+                        C.decryptSampleAes_NAL(sampleData, size, encryptionKey, encryptionIv);
+                    }
+                }
+            }
+
+            output.sampleData(sampleData, size);
+            writtenSampleSize += size;
+
+            if (nalUnitType == C.NAL_UNIT_TYPE_AUD
+                    || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
+                // If the NAL unit ending is the start of a new sample, output the previous one.
+                if (readingSample) {
+                    int nalUnitLength = (int) (position - nalUnitStartPosition);
+                    @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+
+                    int newsize = (int) (nalUnitStartPosition - samplePosition);
+                    int newOffset = 0;
+
+                    newOffset = (int) (writtenSampleSize - totalBytesWritten) + offset + nalUnitLength;
+                    output.sampleMetadata(sampleTimeUs, flags, newsize, newOffset, null);
+                }
+                samplePosition = nalUnitStartPosition;
+                sampleTimeUs = nalUnitTimeUs;
+                sampleIsKeyframe = false;
+                readingSample = true;
+            }
+            sampleIsKeyframe |= nalUnitType == C.NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
+                    && nalUnitType == C.NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
         }
-        samplePosition = nalUnitStartPosition;
-        sampleTimeUs = nalUnitTimeUs;
-        sampleIsKeyframe = false;
-        readingSample = true;
-      }
-      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
-          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
-    }
 
-    private void outputSample(int offset) {
-      @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
-      int size = (int) (nalUnitStartPosition - samplePosition);
-      output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
-    }
 
-    private static final class SliceHeaderData {
-
-      private static final int SLICE_TYPE_I = 2;
-      private static final int SLICE_TYPE_ALL_I = 7;
-
-      private boolean isComplete;
-      private boolean hasSliceType;
-
-      private SpsData spsData;
-      private int nalRefIdc;
-      private int sliceType;
-      private int frameNum;
-      private int picParameterSetId;
-      private boolean fieldPicFlag;
-      private boolean bottomFieldFlagPresent;
-      private boolean bottomFieldFlag;
-      private boolean idrPicFlag;
-      private int idrPicId;
-      private int picOrderCntLsb;
-      private int deltaPicOrderCntBottom;
-      private int deltaPicOrderCnt0;
-      private int deltaPicOrderCnt1;
-
-      public void clear() {
-        hasSliceType = false;
-        isComplete = false;
-      }
-
-      public void setSliceType(int sliceType) {
-        this.sliceType = sliceType;
-        hasSliceType = true;
-      }
-
-      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
-          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
-          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
-          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
-        this.spsData = spsData;
-        this.nalRefIdc = nalRefIdc;
-        this.sliceType = sliceType;
-        this.frameNum = frameNum;
-        this.picParameterSetId = picParameterSetId;
-        this.fieldPicFlag = fieldPicFlag;
-        this.bottomFieldFlagPresent = bottomFieldFlagPresent;
-        this.bottomFieldFlag = bottomFieldFlag;
-        this.idrPicFlag = idrPicFlag;
-        this.idrPicId = idrPicId;
-        this.picOrderCntLsb = picOrderCntLsb;
-        this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
-        this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
-        this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
-        isComplete = true;
-        hasSliceType = true;
-      }
-
-      public boolean isISlice() {
-        return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
-      }
-
-      private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
-        // See ISO 14496-10 subsection 7.4.1.2.4.
-        return isComplete && (!other.isComplete || frameNum != other.frameNum
-            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
-            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
-                && bottomFieldFlag != other.bottomFieldFlag)
-            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
-            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
-                && (picOrderCntLsb != other.picOrderCntLsb
-                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
-            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
-                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
-                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
-            || idrPicFlag != other.idrPicFlag
-            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
-      }
+        /*
+            private void outputSample(int offset) {
+              @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+              int size = (int) (nalUnitStartPosition - samplePosition);
+              output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
+            }
+            */
+        private final class SliceHeaderData {
+
+            private static final int SLICE_TYPE_I = 2;
+            private static final int SLICE_TYPE_ALL_I = 7;
+
+            private boolean isComplete;
+            private boolean hasSliceType;
+
+            private SpsData spsData;
+            private int nalRefIdc;
+            private int sliceType;
+            private int frameNum;
+            private int picParameterSetId;
+            private boolean fieldPicFlag;
+            private boolean bottomFieldFlagPresent;
+            private boolean bottomFieldFlag;
+            private boolean idrPicFlag;
+            private int idrPicId;
+            private int picOrderCntLsb;
+            private int deltaPicOrderCntBottom;
+            private int deltaPicOrderCnt0;
+            private int deltaPicOrderCnt1;
+
+            public void clear() {
+                hasSliceType = false;
+                isComplete = false;
+            }
+
+            public void setSliceType(int sliceType) {
+                this.sliceType = sliceType;
+                hasSliceType = true;
+            }
+
+            public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
+                               int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
+                               boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
+                               int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+                this.spsData = spsData;
+                this.nalRefIdc = nalRefIdc;
+                this.sliceType = sliceType;
+                this.frameNum = frameNum;
+                this.picParameterSetId = picParameterSetId;
+                this.fieldPicFlag = fieldPicFlag;
+                this.bottomFieldFlagPresent = bottomFieldFlagPresent;
+                this.bottomFieldFlag = bottomFieldFlag;
+                this.idrPicFlag = idrPicFlag;
+                this.idrPicId = idrPicId;
+                this.picOrderCntLsb = picOrderCntLsb;
+                this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
+                this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
+                this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
+                isComplete = true;
+                hasSliceType = true;
+            }
+
+            public boolean isISlice() {
+                return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
+            }
+
+            private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
+                // See ISO 14496-10 subsection 7.4.1.2.4.
+                return isComplete && (!other.isComplete || frameNum != other.frameNum
+                        || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
+                        || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
+                        && bottomFieldFlag != other.bottomFieldFlag)
+                        || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+                        || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
+                        && (picOrderCntLsb != other.picOrderCntLsb
+                        || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+                        || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
+                        && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                        || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+                        || idrPicFlag != other.idrPicFlag
+                        || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+            }
+
+        }
 
     }
 
-  }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 71b8375bd8..c20dda2703 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
+import android.util.Log;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
@@ -32,6 +33,7 @@
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
@@ -56,6 +58,7 @@
 
     @Override
     public Extractor[] createExtractors() {
+      Log.d("TsExtractor", "createExtractors");
       return new Extractor[] {new TsExtractor()};
     }
 
@@ -65,13 +68,13 @@
    * Modes for the extractor.
    */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
+  @IntDef({MODE_NORMAL, MODE_SINGLE_PMT, MODE_HLS})
   public @interface Mode {}
 
   /**
    * Behave as defined in ISO/IEC 13818-1.
    */
-  public static final int MODE_MULTI_PMT = 0;
+  public static final int MODE_NORMAL = 0;
   /**
    * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
    */
@@ -82,6 +85,8 @@
    */
   public static final int MODE_HLS = 2;
 
+
+
   public static final int TS_STREAM_TYPE_MPA = 0x03;
   public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
   public static final int TS_STREAM_TYPE_AAC = 0x0F;
@@ -92,10 +97,12 @@
   public static final int TS_STREAM_TYPE_H262 = 0x02;
   public static final int TS_STREAM_TYPE_H264 = 0x1B;
   public static final int TS_STREAM_TYPE_H265 = 0x24;
+
   public static final int TS_STREAM_TYPE_ID3 = 0x15;
   public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
   public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
 
+  private static final String TAG = "TsExtractor";
   private static final int TS_PACKET_SIZE = 188;
   private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
   private static final int TS_PAT_PID = 0;
@@ -105,10 +112,25 @@
   private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
   private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
 
+    private static final long ZAVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("ZAVC");
+
   private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
 
   @Mode private final int mode;
+
+    private static int mMode = TS_STREAM_TYPE_H264;
+  //private  String encryptionMethod;
+  //2017-6-3,zhouwg, add it
+ // private  byte[] encryptionKey;
+  //private  byte[] encryptionIv;
+  //2017-6-5,zhouwg, add it
+ // private String encryptionKeyFormat;
+
+  //2017-6-7,zhouwg, add it
+  private HLSEncryptInfo hlsEncryptInfo;
+
+
   private final List<TimestampAdjuster> timestampAdjusters;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
@@ -127,28 +149,33 @@ public TsExtractor() {
     this(0);
   }
 
-  /**
-   * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-   *     {@code FLAG_*} values that control the behavior of the payload readers.
-   */
-  public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
-    this(MODE_SINGLE_PMT, defaultTsPayloadReaderFlags);
+  public TsExtractor(int mode, int defaultTsPayloadReaderFlags) {
+    this(mode, new TimestampAdjuster(0),
+            new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
   }
-
   /**
-   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
-   *     and {@link #MODE_HLS}.
    * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
    *     {@code FLAG_*} values that control the behavior of the payload readers.
    */
-  public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
-    this(mode, new TimestampAdjuster(0),
+  public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
+    this(MODE_NORMAL, new TimestampAdjuster(0),
         new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
   }
 
+  //2017-6-3,zhouwg, add it
+  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+                     TsPayloadReader.Factory payloadReaderFactory, HLSEncryptInfo hlsEncryptInfo) {
+    this(mode, timestampAdjuster, payloadReaderFactory);
+
+    //this.encryptionMethod = encryptionMethod;
+    //this.encryptionKeyFormat = encryptionKeyFormat;
+    //this.encryptionIv = encryptionIv;
+    //this.encryptionKey = encryptionKey;
+    this.hlsEncryptInfo = hlsEncryptInfo;
 
+  }
   /**
-   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+   * @param mode Mode for the extractor. One of {@link #MODE_NORMAL}, {@link #MODE_SINGLE_PMT}
    *     and {@link #MODE_HLS}.
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
@@ -169,6 +196,11 @@ public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
     tsPayloadReaders = new SparseArray<>();
     continuityCounters = new SparseIntArray();
     resetPayloadReaders();
+
+    //2017-6-3,zhouwg
+    //encryptionMethod = "";
+    //encryptionIv = new byte[16];
+    //encryptionKey = new byte[16];
   }
 
   // Extractor implementation.
@@ -381,6 +413,9 @@ public void consume(ParsableByteArray sectionData) {
     private static final int TS_PMT_DESC_DTS = 0x7B;
     private static final int TS_PMT_DESC_DVBSUBS = 0x59;
 
+      //2017-5-26,zhouwg, add it
+    private static final int TS_PMT_DESC_SAMPLE_AES_H264 = 15;
+
     private final ParsableBitArray pmtScratch;
     private final int pid;
 
@@ -430,10 +465,10 @@ public void consume(ParsableByteArray sectionData) {
       if (mode == MODE_HLS && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See [Internal: b/20261500].
-        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
-        id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
-        id3Reader.init(timestampAdjuster, output,
-            new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+        //EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
+        //id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
+       // id3Reader.init(timestampAdjuster, output,
+         //   new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
       }
 
       int remainingEntriesLength = sectionData.bytesLeft();
@@ -445,9 +480,19 @@ public void consume(ParsableByteArray sectionData) {
         pmtScratch.skipBits(4); // reserved
         int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
         EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
-        if (streamType == 0x06) {
+        if (streamType == 0x06) {//STREAMTYPE_EAC3_DVB
           streamType = esInfo.streamType;
         }
+
+        if (streamType == C.TS_STREAM_TYPE_SAMPLE_AES_H264) {
+          Log.d(TAG, "SAMPLE_AES H264");
+            mMode = C.TS_STREAM_TYPE_SAMPLE_AES_H264;
+        }
+        //2017-6-3,zhouwg
+        if (streamType == C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES) {
+          Log.d(TAG, "SAMPLE_AES AAC");
+          mMode = C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES;
+        }
         remainingEntriesLength -= esInfoLength + 5;
 
         int trackId = mode == MODE_HLS ? streamType : elementaryPid;
@@ -460,7 +505,7 @@ public void consume(ParsableByteArray sectionData) {
         if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
           reader = id3Reader;
         } else {
-          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo);
+          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo, hlsEncryptInfo);
           if (reader != null) {
             reader.init(timestampAdjuster, output,
                 new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
@@ -471,6 +516,9 @@ public void consume(ParsableByteArray sectionData) {
           tsPayloadReaders.put(elementaryPid, reader);
         }
       }
+
+
+
       if (mode == MODE_HLS) {
         if (!tracksEnded) {
           output.endTracks();
@@ -506,14 +554,16 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
         int descriptorLength = data.readUnsignedByte();
         int positionOfNextDescriptor = data.getPosition() + descriptorLength;
         if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
-          long formatIdentifier = data.readUnsignedInt();
-          if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_AC3;
-          } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_E_AC3;
-          } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_H265;
-          }
+            long formatIdentifier = data.readUnsignedInt();
+            if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
+                streamType = TS_STREAM_TYPE_AC3;
+            } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
+                streamType = TS_STREAM_TYPE_E_AC3;
+            } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
+              streamType = TS_STREAM_TYPE_H265;
+            }
+        //} else if (descriptorTag == TS_PMT_DESC_SAMPLE_AES_H264)  { //TODO:hardcode here
+        //    streamType = C.TS_STREAM_TYPE_SAMPLE_AES_H264;
         } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
           streamType = TS_STREAM_TYPE_AC3;
         } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index e7996c66c3..c4882d8b7b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -18,6 +18,7 @@
 import android.util.SparseArray;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.Collections;
@@ -51,7 +52,7 @@
      * @return A {@link TsPayloadReader} for the packet stream carried by the provided pid.
      *     {@code null} if the stream is not supported.
      */
-    TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo);
+    TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEncryptInfo hlsEncryptInfo);
 
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
new file mode 100644
index 0000000000..b69265e2fb
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
@@ -0,0 +1,40 @@
+package com.google.android.exoplayer2.util;
+
+/**
+ * Created by zhou.weiguo on 07-06-2017.
+ */
+
+public final class HLSEncryptInfo {
+    private static final String TAG = "HLSEncryptInfo";
+
+    public String encryptionMethod;
+    public String encryptionKeyUri;
+    public String encryptionIvString;
+
+    public String encryptionKeyId;
+    public String encryptionKeyFormat;
+
+    public String encryptionKeyString;
+
+    public byte[] encryptionIv;
+    public byte[] encryptionKey;
+    public boolean isEncrypted;
+
+    public HLSEncryptInfo() {
+
+    }
+
+    public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv) {
+        this.isEncrypted = isEncrypted;
+        this.encryptionMethod = encryptionMethod;
+        this.encryptionKeyUri = encryptionKeyUri;
+        this.encryptionIvString = encryptionKeyIv;
+    }
+
+    public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv, String encryptionKeyFormat, String encryptionKeyId) {
+        this(isEncrypted, encryptionMethod, encryptionKeyUri, encryptionKeyIv);
+        this.encryptionKeyFormat = encryptionKeyFormat;
+        this.encryptionKeyId = encryptionKeyId;
+    }
+
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 795e2f0eaa..9b3f10efea 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -92,13 +93,14 @@ public void clear() {
   private boolean isTimestampMaster;
   private byte[] scratchSpace;
   private IOException fatalError;
-  private HlsUrl expectedPlaylistUrl;
 
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
   private byte[] encryptionIv;
 
+
+
   // Note: The track group in the selection is typically *not* equal to trackGroup. This is due to
   // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
   // in TrackSelection to avoid unexpected behavior.
@@ -112,8 +114,7 @@ public void clear() {
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
-   *     information is available in the master playlist.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
    */
   public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
       HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
@@ -144,9 +145,6 @@ public void maybeThrowError() throws IOException {
     if (fatalError != null) {
       throw fatalError;
     }
-    if (expectedPlaylistUrl != null) {
-      playlistTracker.maybeThrowPlaylistRefreshError(expectedPlaylistUrl);
-    }
   }
 
   /**
@@ -199,7 +197,6 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
         : trackGroup.indexOf(previous.trackFormat);
-    expectedPlaylistUrl = null;
     // Use start time of the previous chunk rather than its end time because switching format will
     // require downloading overlapping segments.
     long bufferedDurationUs = previous == null ? 0
@@ -213,7 +210,6 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     HlsUrl selectedUrl = variants[selectedVariantIndex];
     if (!playlistTracker.isSnapshotValid(selectedUrl)) {
       out.playlist = selectedUrl;
-      expectedPlaylistUrl = selectedUrl;
       // Retry when playlist is refreshed.
       return;
     }
@@ -253,7 +249,6 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         out.endOfStream = true;
       } else /* Live */ {
         out.playlist = selectedUrl;
-        expectedPlaylistUrl = selectedUrl;
       }
       return;
     }
@@ -264,14 +259,23 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Check if encryption is specified.
     if (segment.isEncrypted) {
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
-      if (!keyUri.equals(encryptionKeyUri)) {
-        // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
-            trackSelection.getSelectionReason(), trackSelection.getSelectionData());
-        return;
+
+      if (
+              ((segment.hlsEncryptInfo.encryptionKeyFormat == null) && segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES))
+           || segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_AES_128)
+              ) {
+
+        if (!keyUri.equals(encryptionKeyUri)) {
+          // Encryption is specified and the key has changed.
+          out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
+                  trackSelection.getSelectionReason(), trackSelection.getSelectionData());
+          encryptionKeyUri = keyUri;
+          return;
+        }
       }
+
       if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
-        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
+        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey, (segment.hlsEncryptInfo != null) ? segment.hlsEncryptInfo.encryptionMethod : null);
       }
     } else {
       clearEncryptionData();
@@ -299,7 +303,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     out.chunk = new HlsMediaChunk(mediaDataSource, dataSpec, initDataSpec, selectedUrl,
         muxedCaptionFormats, trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
         startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence, discontinuitySequence,
-        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv);
+        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv, segment.hlsEncryptInfo);
   }
 
   /**
@@ -355,7 +359,6 @@ private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int vari
     return new EncryptionKeyChunk(encryptionDataSource, dataSpec, variants[variantIndex].format,
         trackSelectionReason, trackSelectionData, scratchSpace, iv);
   }
-
   private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     String trimmedIv;
     if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
@@ -368,7 +371,7 @@ private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     byte[] ivDataWithPadding = new byte[16];
     int offset = ivData.length > 16 ? ivData.length - 16 : 0;
     System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
-        + offset, ivData.length - offset);
+            + offset, ivData.length - offset);
 
     encryptionKeyUri = keyUri;
     encryptionKey = secretKey;
@@ -376,6 +379,12 @@ private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     encryptionIv = ivDataWithPadding;
   }
 
+
+  private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey, String method) {
+    setEncryptionData(keyUri, iv, secretKey);
+
+  }
+
   private void clearEncryptionData() {
     encryptionKeyUri = null;
     encryptionKey = null;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 6997324f02..bb01a0327e 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -34,12 +34,12 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -80,6 +80,13 @@
   private final DataSource initDataSource;
   private final DataSpec initDataSpec;
   private final boolean isEncrypted;
+
+
+  private final byte[] encryptionKey;
+  private final byte[] encryptionIv;
+
+  private final HLSEncryptInfo hlsEncryptInfo;
+
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
   private final String lastPathSegment;
@@ -105,8 +112,7 @@
    * @param dataSpec Defines the data to be loaded.
    * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
    * @param hlsUrl The url of the playlist from which this chunk was obtained.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
-   *     information is available in the master playlist.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
    * @param trackSelectionReason See {@link #trackSelectionReason}.
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the chunk in microseconds.
@@ -124,8 +130,8 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
       Object trackSelectionData, long startTimeUs, long endTimeUs, int chunkIndex,
       int discontinuitySequenceNumber, boolean isMasterTimestampSource,
       TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, byte[] encryptionKey,
-      byte[] encryptionIv) {
-    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
+      byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
+    super(buildDataSource(dataSource, encryptionKey, encryptionIv, hlsEncryptInfo), dataSpec, hlsUrl.format,
         trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     this.initDataSpec = initDataSpec;
@@ -134,7 +140,14 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
     // Note: this.dataSource and dataSource may be different.
-    this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+    this.isEncrypted = this.dataSource instanceof Aes128DataSource; //TODO: this.isEncrypted = hlsEncryptInfo.isEncrypted;
+    this.encryptionKey = encryptionKey;
+    this.encryptionIv = encryptionIv;
+    hlsEncryptInfo.encryptionKey = encryptionKey;
+    hlsEncryptInfo.encryptionIv = encryptionIv;
+    this.hlsEncryptInfo = hlsEncryptInfo;
+
+
     lastPathSegment = dataSpec.uri.getLastPathSegment();
     isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
         || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
@@ -331,11 +344,20 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
    * order to decrypt the loaded data. Else returns the original.
    */
   private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
-      byte[] encryptionIv) {
+      byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
+   /*
     if (encryptionKey == null || encryptionIv == null) {
       return dataSource;
     }
     return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
+   */
+    if (encryptionKey == null || encryptionIv == null) {
+    } else {
+      if (hlsEncryptInfo.encryptionMethod != null && hlsEncryptInfo.encryptionMethod.equals("AES-128"))
+        return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
+    }
+
+    return dataSource;
   }
 
   private Extractor createExtractor() {
@@ -358,12 +380,9 @@ private Extractor createExtractor() {
       // This flag ensures the change of pid between streams does not affect the sample queues.
       @DefaultTsPayloadReaderFactory.Flags
       int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
-      List<Format> closedCaptionFormats = muxedCaptionFormats;
-      if (closedCaptionFormats != null) {
+      if (!muxedCaptionFormats.isEmpty()) {
         // The playlist declares closed caption renditions, we should ignore descriptors.
         esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
-      } else {
-        closedCaptionFormats = Collections.emptyList();
       }
       String codecs = trackFormat.codecs;
       if (!TextUtils.isEmpty(codecs)) {
@@ -377,8 +396,10 @@ private Extractor createExtractor() {
           esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
         }
       }
+
+
       extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, closedCaptionFormats));
+          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats), hlsEncryptInfo);
     }
     if (usingNewExtractor) {
       extractor.init(extractorOutput);
@@ -389,7 +410,7 @@ private Extractor createExtractor() {
   private Extractor buildPackedAudioExtractor(long startTimeUs) {
     Extractor extractor;
     if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
-      extractor = new AdtsExtractor(startTimeUs);
+      extractor = new AdtsExtractor(startTimeUs, hlsEncryptInfo);
     } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
       extractor = new Ac3Extractor(startTimeUs);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 69b95e6d3d..9371657bdc 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -18,6 +18,8 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -40,23 +42,32 @@
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
     public final String encryptionIV;
+
     public final long byterangeOffset;
     public final long byterangeLength;
 
+
+    public final HLSEncryptInfo hlsEncryptInfo;
+
+
+
+
+
     public Segment(String uri, long byterangeOffset, long byterangeLength) {
-      this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
+      this(uri, 0, -1, C.TIME_UNSET, null, byterangeOffset, byterangeLength);
     }
 
     public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
-        long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
-        long byterangeOffset, long byterangeLength) {
+                   long relativeStartTimeUs, HLSEncryptInfo hlsEncryptInfo, long byterangeOffset, long byterangeLength) {
       this.url = uri;
       this.durationUs = durationUs;
       this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
-      this.isEncrypted = isEncrypted;
-      this.encryptionKeyUri = encryptionKeyUri;
-      this.encryptionIV = encryptionIV;
+      this.hlsEncryptInfo = hlsEncryptInfo;
+      this.isEncrypted = (hlsEncryptInfo != null) ? hlsEncryptInfo.isEncrypted : false;
+      this.encryptionKeyUri = (hlsEncryptInfo != null) ? hlsEncryptInfo.encryptionKeyUri : null;
+      this.encryptionIV = (hlsEncryptInfo != null) ? hlsEncryptInfo.encryptionIvString : null;
+
       this.byterangeOffset = byterangeOffset;
       this.byterangeLength = byterangeLength;
     }
@@ -91,14 +102,12 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
   public final boolean hasProgramDateTime;
   public final Segment initializationSegment;
   public final List<Segment> segments;
-  public final List<String> dateRanges;
   public final long durationUs;
 
   public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
       long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
       int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
-      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments,
-      List<String> dateRanges) {
+      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments) {
     super(baseUri);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
@@ -119,7 +128,6 @@ public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long sta
     }
     this.startOffsetUs = startOffsetUs == C.TIME_UNSET ? C.TIME_UNSET
         : startOffsetUs >= 0 ? startOffsetUs : durationUs + startOffsetUs;
-    this.dateRanges = Collections.unmodifiableList(dateRanges);
   }
 
   /**
@@ -158,7 +166,7 @@ public long getEndTimeUs() {
   public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs, true,
         discontinuitySequence, mediaSequence, version, targetDurationUs, hasEndTag,
-        hasProgramDateTime, initializationSegment, segments, dateRanges);
+        hasProgramDateTime, initializationSegment, segments);
   }
 
   /**
@@ -173,7 +181,7 @@ public HlsMediaPlaylist copyWithEndTag() {
     }
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs,
         hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
-        true, hasProgramDateTime, initializationSegment, segments, dateRanges);
+        true, hasProgramDateTime, initializationSegment, segments);
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 664306baff..63d573606b 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.BufferedReader;
@@ -29,18 +30,20 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import android.util.Log;
+
 
 /**
  * HLS playlists parsing logic.
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
+  private static final String TAG = "HlsPlaylistParser";
   private static final String PLAYLIST_HEADER = "#EXTM3U";
 
   private static final String TAG_VERSION = "#EXT-X-VERSION";
@@ -58,7 +61,6 @@
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
-  private static final String TAG_DATERANGE = "#EXT-X-DATERANGE";
 
   private static final String TYPE_AUDIO = "AUDIO";
   private static final String TYPE_VIDEO = "VIDEO";
@@ -67,12 +69,11 @@
 
   private static final String METHOD_NONE = "NONE";
   private static final String METHOD_AES128 = "AES-128";
+  private static final String METHOD_SAMPLEAES = "SAMPLE-AES";
 
   private static final String BOOLEAN_TRUE = "YES";
   private static final String BOOLEAN_FALSE = "NO";
 
-  private static final String ATTR_CLOSED_CAPTIONS_NONE = "CLOSED-CAPTIONS=NONE";
-
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
@@ -89,11 +90,16 @@
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
-      Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
+          Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
+
   private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
-      + METHOD_AES128 + ")");
+      + METHOD_AES128 + "|" + METHOD_SAMPLEAES + ")");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
   private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
+
+  private static final Pattern REGEX_KEYID = Pattern.compile("KeyId=(.+?-.+?-.+?-.+?-.{12})");
+  private static final Pattern REGEX_KEYFORMAT = Pattern.compile("KEYFORMAT=\"(.+?)\"");
+
   private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
       + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
   private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
@@ -176,8 +182,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
     Format muxedAudioFormat = null;
-    List<Format> muxedCaptionFormats = null;
-    boolean noClosedCaptions = false;
+    ArrayList<Format> muxedCaptionFormats = new ArrayList<>();
 
     String line;
     while (iterator.hasNext()) {
@@ -214,9 +219,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
               mimeType = MimeTypes.APPLICATION_CEA708;
               accessibilityChannel = Integer.parseInt(instreamId.substring(7));
             }
-            if (muxedCaptionFormats == null) {
-              muxedCaptionFormats = new ArrayList<>();
-            }
             muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
                 Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
             break;
@@ -228,7 +230,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
         String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
         String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
-        noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int width;
         int height;
         if (resolutionString != null) {
@@ -251,9 +252,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
       }
     }
-    if (noClosedCaptions) {
-      muxedCaptionFormats = Collections.emptyList();
-    }
     return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
         muxedCaptionFormats);
   }
@@ -275,7 +273,6 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     boolean hasEndTag = false;
     Segment initializationSegment = null;
     List<Segment> segments = new ArrayList<>();
-    List<String> dateRanges = new ArrayList<>();
 
     long segmentDurationUs = 0;
     boolean hasDiscontinuitySequence = false;
@@ -291,6 +288,13 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     String encryptionKeyUri = null;
     String encryptionIV = null;
 
+    String encryptionKeyId = null;
+    String encryptionKeyFormat = null;
+    String encryptionMethod = null;
+
+
+    HLSEncryptInfo hlsEncryptInfo;
+
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
@@ -330,10 +334,12 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
             (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
         String method = parseStringAttr(line, REGEX_METHOD);
-        isEncrypted = METHOD_AES128.equals(method);
+		//Log.e("HlsPlaylistParser" + method);
+        isEncrypted = METHOD_AES128.equals(method) | METHOD_SAMPLEAES.equals(method);
         if (isEncrypted) {
           encryptionKeyUri = parseStringAttr(line, REGEX_URI);
           encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
+          encryptionMethod = method;
         } else {
           encryptionKeyUri = null;
           encryptionIV = null;
@@ -356,8 +362,6 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
               C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
           playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
         }
-      } else if (line.startsWith(TAG_DATERANGE)) {
-        dateRanges.add(line);
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
         if (!isEncrypted) {
@@ -367,13 +371,17 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         } else {
           segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
         }
+
         segmentMediaSequence++;
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
+
+        hlsEncryptInfo = new HLSEncryptInfo(isEncrypted, encryptionMethod, encryptionKeyUri, segmentEncryptionIV, encryptionKeyFormat, encryptionKeyId);
+
         segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
-            segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
-            segmentByteRangeOffset, segmentByteRangeLength));
+                segmentStartTimeUs, hlsEncryptInfo, segmentByteRangeOffset, segmentByteRangeLength));
+
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
@@ -386,8 +394,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     }
     return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, playlistStartTimeUs,
         hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
-        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments,
-        dateRanges);
+        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
   }
 
   private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
