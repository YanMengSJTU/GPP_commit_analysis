diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 4a09b7168a..7c3b6a5f4a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -23,7 +23,9 @@
 import android.media.MediaFormat;
 import android.support.annotation.IntDef;
 import android.view.Surface;
+
 import com.google.android.exoplayer2.util.Util;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.UUID;
@@ -31,6 +33,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.security.SecureRandom;
 import java.util.UUID;
 import java.util.Vector;
@@ -48,36 +51,37 @@
  */
 public final class C {
 
-  private C() {}
+  private C() {
+  }
 
-    public static final int AES_BLOCK_LENGTH_BYTES = 16;
+  public static final int AES_BLOCK_LENGTH_BYTES = 16;
 
-    public static final int TS_STREAM_TYPE_H262 = 0x02;
-    public static final int TS_STREAM_TYPE_H264 = 0x1B;
-    public static final int TS_STREAM_TYPE_H265 = 0x24;
-    public static final int TS_STREAM_TYPE_SAMPLE_AES_H264 = 0xDB;
-    public static final int TS_STREAM_TYPE_SAMPLE_AES_H265 = 0xE4;
+  public static final int TS_STREAM_TYPE_H262 = 0x02;
+  public static final int TS_STREAM_TYPE_H264 = 0x1B;
+  public static final int TS_STREAM_TYPE_H265 = 0x24;
+  public static final int TS_STREAM_TYPE_SAMPLE_AES_H264 = 0xDB;
+  public static final int TS_STREAM_TYPE_SAMPLE_AES_H265 = 0xE4;
 
-    public static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
-    public static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
-    public static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
+  public static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
+  public static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
+  public static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
 
-    public static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
-    public static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
-    public static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
-    public static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
+  public static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
+  public static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
+  public static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+  public static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
-    public static final int NAL_UNIT_TYPE_SLICE = 1;
-    public static final String ENCRYPTION_METHOD_SAMPLE_AES = "SAMPLE-AES";
-    public static final String ENCRYPTION_METHOD_AES_128 = "AES-128";
+  public static final int NAL_UNIT_TYPE_SLICE = 1;
+  public static final String ENCRYPTION_METHOD_SAMPLE_AES = "SAMPLE-AES";
+  public static final String ENCRYPTION_METHOD_AES_128 = "AES-128";
 
-    public static final int TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES = 0xcf;
-    public static final int TS_STREAM_TYPE_AC3_SAMPLE_AES = 0xc1;
-    public static final int TS_STREAM_TYPE_EAC3_SAMPLE_AES = 0xc2;
+  public static final int TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES = 0xcf;
+  public static final int TS_STREAM_TYPE_AC3_SAMPLE_AES = 0xc1;
+  public static final int TS_STREAM_TYPE_EAC3_SAMPLE_AES = 0xc2;
 
-    public static final int TS_STREAM_TYPE_AAC = 0x0F;
-    public static final int TS_STREAM_TYPE_AC3 = 0x81;
-    public static final int TS_STREAM_TYPE_DTS = 0x8A;
+  public static final int TS_STREAM_TYPE_AAC = 0x0F;
+  public static final int TS_STREAM_TYPE_AC3 = 0x81;
+  public static final int TS_STREAM_TYPE_DTS = 0x8A;
 
   /**
    * Special constant representing a time corresponding to the end of a source. Suitable for use in
@@ -141,7 +145,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
-  public @interface CryptoMode {}
+  public @interface CryptoMode {
+  }
+
   /**
    * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
    */
@@ -172,7 +178,8 @@ private C() {}
   @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
       ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
       ENCODING_DTS_HD})
-  public @interface Encoding {}
+  public @interface Encoding {
+  }
 
   /**
    * Represents a PCM audio encoding, or an invalid or unset value.
@@ -180,7 +187,9 @@ private C() {}
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
       ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
-  public @interface PcmEncoding {}
+  public @interface PcmEncoding {
+  }
+
   /**
    * @see AudioFormat#ENCODING_INVALID
    */
@@ -235,7 +244,9 @@ private C() {}
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
       STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
-  public @interface StreamType {}
+  public @interface StreamType {
+  }
+
   /**
    * @see AudioManager#STREAM_ALARM
    */
@@ -271,7 +282,9 @@ private C() {}
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
       BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
-  public @interface BufferFlags {}
+  public @interface BufferFlags {
+  }
+
   /**
    * Indicates that a buffer holds a synchronization sample.
    */
@@ -296,7 +309,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
-  public @interface VideoScalingMode {}
+  public @interface VideoScalingMode {
+  }
+
   /**
    * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
    */
@@ -320,7 +335,9 @@ private C() {}
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
       SELECTION_FLAG_AUTOSELECT})
-  public @interface SelectionFlags {}
+  public @interface SelectionFlags {
+  }
+
   /**
    * Indicates that the track should be selected if user preferences do not state otherwise.
    */
@@ -340,7 +357,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
-  public @interface ContentType {}
+  public @interface ContentType {
+  }
+
   /**
    * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
    */
@@ -580,7 +599,9 @@ private C() {}
       STEREO_MODE_LEFT_RIGHT,
       STEREO_MODE_STEREO_MESH
   })
-  public @interface StereoMode {}
+  public @interface StereoMode {
+  }
+
   /**
    * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
    */
@@ -604,7 +625,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_SPACE_BT709, COLOR_SPACE_BT601, COLOR_SPACE_BT2020})
-  public @interface ColorSpace {}
+  public @interface ColorSpace {
+  }
+
   /**
    * @see MediaFormat#COLOR_STANDARD_BT709
    */
@@ -626,7 +649,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_TRANSFER_SDR, COLOR_TRANSFER_ST2084, COLOR_TRANSFER_HLG})
-  public @interface ColorTransfer {}
+  public @interface ColorTransfer {
+  }
+
   /**
    * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO
    */
@@ -648,7 +673,9 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, COLOR_RANGE_LIMITED, COLOR_RANGE_FULL})
-  public @interface ColorRange {}
+  public @interface ColorRange {
+  }
+
   /**
    * @see MediaFormat#COLOR_RANGE_LIMITED
    */
@@ -662,14 +689,14 @@ private C() {}
 
   /**
    * Priority for media playback.
-   *
+   * <p>
    * <p>Larger values indicate higher priorities.
    */
   public static final int PRIORITY_PLAYBACK = 0;
 
   /**
    * Priority for media downloading.
-   *
+   * <p>
    * <p>Larger values indicate higher priorities.
    */
   public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
@@ -706,191 +733,192 @@ public static int generateAudioSessionIdV21(Context context) {
   }
 
 
-    public static final byte[] AES_CBC(byte[] content, byte[] keyBytes, byte[] iv, boolean bEncrypt) {
-        try {
-            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
-            keyGenerator.init(128, new SecureRandom(keyBytes));
+  public static final byte[] AES_CBC(byte[] content, byte[] keyBytes, byte[] iv, boolean bEncrypt) {
+    try {
+      KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
+      keyGenerator.init(128, new SecureRandom(keyBytes));
 
-            SecretKey key = new SecretKeySpec(keyBytes, "AES");
-            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
-            bEncrypt = false;
-            if (bEncrypt)
-                cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
-            else
-                cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
+      SecretKey key = new SecretKeySpec(keyBytes, "AES");
+      Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
+      bEncrypt = false;
+      if (bEncrypt)
+        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
+      else
+        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
 
-            byte[] result = cipher.doFinal(content);
-            return result;
-        } catch (Exception e) {
-            System.out.println("exception:" + e.toString());
-        }
-        return null;
+      byte[] result = cipher.doFinal(content);
+      return result;
+    } catch (Exception e) {
+      System.out.println("exception:" + e.toString());
     }
+    return null;
+  }
 
-    /**
-     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
-     *
-     * Encryption of NAL units
-     *
-     * Encrypted_nal_unit () {
-     * nal_unit_type_byte                // 1 byte
-     * unencrypted_leader                // 31 bytes
-     * while (bytes_remaining() > 0) {
-     * if (bytes_remaining() > 16) {
-     * encrypted_block           // 16 bytes
-     * }
-     * unencrypted_block           // MIN(144, bytes_remaining()) bytes
-     * }
-     * }
-     *
-     * @param dataSampleAES IDR/Slice data
-     * @param sizeSampleAES size of sample-aes encrypted NAL data
-     * @param encrytionKey
-     * @param encryptionIv
-     */
-    public static final void decryptSampleAes_NAL(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
-        int skipSize = 3;
-        //sanity check the first 3 bytes
-        byte[] prefix = {0, 0, 0};
-        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), prefix, 0, skipSize);
-        Assertions.checkArgument(prefix[0] == 0 && prefix[1] == 0 && prefix[2] == 1);
-
-        int size = sizeSampleAES - skipSize;
-        Assertions.checkArgument(size > 0);
-
-        int tmp_nal_size = size;
-        Vector clearBytes = new Vector();
-        Vector encryptBytes = new Vector();
-
-        clearBytes.add(min(32, tmp_nal_size));
-        tmp_nal_size -= min(32, tmp_nal_size);
-
+  /**
+   * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
+   * <p>
+   * Encryption of NAL units
+   * <p>
+   * Encrypted_nal_unit () {
+   * nal_unit_type_byte                // 1 byte
+   * unencrypted_leader                // 31 bytes
+   * while (bytes_remaining() > 0) {
+   * if (bytes_remaining() > 16) {
+   * encrypted_block           // 16 bytes
+   * }
+   * unencrypted_block           // MIN(144, bytes_remaining()) bytes
+   * }
+   * }
+   *
+   * @param dataSampleAES IDR/Slice data
+   * @param sizeSampleAES size of sample-aes encrypted NAL data
+   * @param encrytionKey
+   * @param encryptionIv
+   */
+  public static final void decryptSampleAes_NAL(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
+    int skipSize = 3;
+    //sanity check the first 3 bytes
+    byte[] prefix = {0, 0, 0};
+    System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), prefix, 0, skipSize);
+    Assertions.checkArgument(prefix[0] == 0 && prefix[1] == 0 && prefix[2] == 1);
+
+    int size = sizeSampleAES - skipSize;
+    Assertions.checkArgument(size > 0);
+
+    int tmp_nal_size = size;
+    Vector clearBytes = new Vector();
+    Vector encryptBytes = new Vector();
+
+    clearBytes.add(min(32, tmp_nal_size));
+    tmp_nal_size -= min(32, tmp_nal_size);
+
+    if (tmp_nal_size > 16) {
+      while (tmp_nal_size > 0) {
         if (tmp_nal_size > 16) {
-            while (tmp_nal_size > 0) {
-                if (tmp_nal_size > 16) {
-                    encryptBytes.add(16);
-                    tmp_nal_size -= 16;
-                } else {
-                    encryptBytes.add(0);
-                }
-
-                if (tmp_nal_size > 0) {
-                    clearBytes.add(min(144, tmp_nal_size));
-                    tmp_nal_size -= min(144, tmp_nal_size);
-                }
-            }
-
-            if (encryptBytes.size() < clearBytes.size()) {
-                encryptBytes.add(0);
-            }
+          encryptBytes.add(16);
+          tmp_nal_size -= 16;
         } else {
-            int lastValue = (int) clearBytes.lastElement();
-            int newValue = lastValue + tmp_nal_size;
-            int lastIndex = clearBytes.lastIndexOf(clearBytes.lastElement());
-            clearBytes.set(lastIndex, newValue);
-            encryptBytes.add(0);
+          encryptBytes.add(0);
         }
 
-        //TODO: try zero-memcopy to improve performance
-        byte[] buffer = new byte[size];
-        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition() + skipSize, buffer, 0, size);
-        decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes );
-        System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition() + skipSize, size);
+        if (tmp_nal_size > 0) {
+          clearBytes.add(min(144, tmp_nal_size));
+          tmp_nal_size -= min(144, tmp_nal_size);
+        }
+      }
+
+      if (encryptBytes.size() < clearBytes.size()) {
+        encryptBytes.add(0);
+      }
+    } else {
+      int lastValue = (int) clearBytes.lastElement();
+      int newValue = lastValue + tmp_nal_size;
+      int lastIndex = clearBytes.lastIndexOf(clearBytes.lastElement());
+      clearBytes.set(lastIndex, newValue);
+      encryptBytes.add(0);
     }
 
+    //TODO: try zero-memcopy to improve performance
+    byte[] buffer = new byte[size];
+    System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition() + skipSize, buffer, 0, size);
+    decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes);
+    System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition() + skipSize, size);
+  }
 
-    public static final void decryptSampleAes(byte[] buffer, int bufferSize, byte[] encrytionKey, byte[] encryptionIv, Vector clearBytes, Vector encryptBytes) {
-        //TODO: sanity check for input parameters
-        int numSubSamples = clearBytes.size();
-        int offset = 0;
-        byte[] packet_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
-        Assertions.checkArgument(encryptionIv.length == C.AES_BLOCK_LENGTH_BYTES);
-        System.arraycopy(encryptionIv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
-
-        byte[] temp_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
-        int value = 0;
-
-        for (int i = 0; i < numSubSamples; i++) {
-            value = (int) clearBytes.elementAt(i);
-            offset += value;
-
-            int encryptSize = 0;
-            value = (int) encryptBytes.elementAt(i);
-            encryptSize = value;
-
-            Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
-            if (encryptSize > 0) {
-                Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
-                int ptr = offset + encryptSize - C.AES_BLOCK_LENGTH_BYTES;
-                System.arraycopy(buffer, offset, temp_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
-
-                byte[] encryptData = new byte[encryptSize];
-                System.arraycopy(buffer, ptr, encryptData, 0, encryptSize);
-                byte[] decrypted = AES_CBC(encryptData, encrytionKey, packet_iv, false);
-                Assertions.checkArgument(decrypted.length % C.AES_BLOCK_LENGTH_BYTES == 0);
-                Assertions.checkArgument(decrypted.length == encryptSize);
-                //in-place: copy the decrypted content into the original position
-                System.arraycopy(decrypted, 0, buffer, offset, encryptSize);
-
-                offset += encryptSize;
-                System.arraycopy(temp_iv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
-            }
-        }
+
+  public static final void decryptSampleAes(byte[] buffer, int bufferSize, byte[] encrytionKey, byte[] encryptionIv, Vector clearBytes, Vector encryptBytes) {
+    //TODO: sanity check for input parameters
+    int numSubSamples = clearBytes.size();
+    int offset = 0;
+    byte[] packet_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
+    Assertions.checkArgument(encryptionIv.length == C.AES_BLOCK_LENGTH_BYTES);
+    System.arraycopy(encryptionIv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+
+    byte[] temp_iv = new byte[C.AES_BLOCK_LENGTH_BYTES];
+    int value = 0;
+
+    for (int i = 0; i < numSubSamples; i++) {
+      value = (int) clearBytes.elementAt(i);
+      offset += value;
+
+      int encryptSize = 0;
+      value = (int) encryptBytes.elementAt(i);
+      encryptSize = value;
+
+      Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
+      if (encryptSize > 0) {
+        Assertions.checkArgument(encryptSize % C.AES_BLOCK_LENGTH_BYTES == 0);
+        int ptr = offset + encryptSize - C.AES_BLOCK_LENGTH_BYTES;
+        System.arraycopy(buffer, offset, temp_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+
+        byte[] encryptData = new byte[encryptSize];
+        System.arraycopy(buffer, ptr, encryptData, 0, encryptSize);
+        byte[] decrypted = AES_CBC(encryptData, encrytionKey, packet_iv, false);
+        Assertions.checkArgument(decrypted.length % C.AES_BLOCK_LENGTH_BYTES == 0);
+        Assertions.checkArgument(decrypted.length == encryptSize);
+        //in-place: copy the decrypted content into the original position
+        System.arraycopy(decrypted, 0, buffer, offset, encryptSize);
+
+        offset += encryptSize;
+        System.arraycopy(temp_iv, 0, packet_iv, 0, C.AES_BLOCK_LENGTH_BYTES);
+      }
     }
+  }
 
 
-    /**
-     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
-     *
-     * Encryption of AAC Audio Frames
-     *
-     * Encrypted_AAC_Frame () {
-     * ADTS_Header                        // 7 or 9 bytes
-     * unencrypted_leader                 // 16 bytes
-     * while (bytes_remaining() >= 16) {
-     * encrypted_block                // 16 bytes
-     * }
-     * unencrypted_trailer                // 0-15 bytes
-     * }
-     * @param dataSampleAES IDR/Slice data, not used, use the sampleData directly to avoid data copy
-     * @param sizeSampleAES
-     */
-    public static final void decryptSampleAes_Audio(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
-        //TODO: sanity check for input parameters
-        int size = sizeSampleAES;
-        Assertions.checkArgument(size > 0);
-        if (size < 32)
-            return;
-
-        int tmp_nal_size = size;
-        Vector clearBytes = new Vector(2);
-        Vector encryptBytes = new Vector(2);
-
-        int audio_frame_size = size;
-        int index = 0;
-        int value = 0;
-
-        value = min(16, audio_frame_size);
-        clearBytes.add(value);
-
-        audio_frame_size -= value;
-
-        encryptBytes.add(audio_frame_size / 16 * 16);
-        index++;
-
-        audio_frame_size = audio_frame_size % 16;
-        if (audio_frame_size > 0) {
-            clearBytes.add(audio_frame_size);
-            encryptBytes.add(0);
-            index++;
-        }
+  /**
+   * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html
+   * <p>
+   * Encryption of AAC Audio Frames
+   * <p>
+   * Encrypted_AAC_Frame () {
+   * ADTS_Header                        // 7 or 9 bytes
+   * unencrypted_leader                 // 16 bytes
+   * while (bytes_remaining() >= 16) {
+   * encrypted_block                // 16 bytes
+   * }
+   * unencrypted_trailer                // 0-15 bytes
+   * }
+   *
+   * @param dataSampleAES IDR/Slice data, not used, use the sampleData directly to avoid data copy
+   * @param sizeSampleAES
+   */
+  public static final void decryptSampleAes_Audio(ParsableByteArray dataSampleAES, int sizeSampleAES, byte[] encrytionKey, byte[] encryptionIv) {
+    //TODO: sanity check for input parameters
+    int size = sizeSampleAES;
+    Assertions.checkArgument(size > 0);
+    if (size < 32)
+      return;
 
-        //TODO: try zero-memcopy to improve performance
-        byte[] buffer = new byte[size];
-        System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), buffer, 0, size);
-        decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes );
-        System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition(), size);
+    int tmp_nal_size = size;
+    Vector clearBytes = new Vector(2);
+    Vector encryptBytes = new Vector(2);
+
+    int audio_frame_size = size;
+    int index = 0;
+    int value = 0;
+
+    value = min(16, audio_frame_size);
+    clearBytes.add(value);
+
+    audio_frame_size -= value;
+
+    encryptBytes.add(audio_frame_size / 16 * 16);
+    index++;
+
+    audio_frame_size = audio_frame_size % 16;
+    if (audio_frame_size > 0) {
+      clearBytes.add(audio_frame_size);
+      encryptBytes.add(0);
+      index++;
     }
 
+    //TODO: try zero-memcopy to improve performance
+    byte[] buffer = new byte[size];
+    System.arraycopy(dataSampleAES.data, dataSampleAES.getPosition(), buffer, 0, size);
+    decryptSampleAes(buffer, size, encrytionKey, encryptionIv, clearBytes, encryptBytes);
+    System.arraycopy(buffer, 0, dataSampleAES.data, dataSampleAES.getPosition(), size);
+  }
+
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index cd2bba5afe..0b7b713912 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -27,6 +27,7 @@
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 
 /**
@@ -42,7 +43,7 @@
 
     @Override
     public Extractor[] createExtractors() {
-      return new Extractor[] {new AdtsExtractor()};
+      return new Extractor[]{new AdtsExtractor()};
     }
 
   };
@@ -63,10 +64,10 @@
   private boolean startedPacket;
 
 
-  private  int mMode = C.TS_STREAM_TYPE_AAC;
-  private  String encryptionMethod;
-  private  byte[] encryptionKey;
-  private  byte[] encryptionIv;
+  private int mMode = C.TS_STREAM_TYPE_AAC;
+  private String encryptionMethod;
+  private byte[] encryptionKey;
+  private byte[] encryptionIv;
 
   public AdtsExtractor() {
     this(0);
@@ -83,7 +84,7 @@ public AdtsExtractor(long firstSampleTimestampUs, HLSEncryptInfo hlsEncryptInfo)
     this.encryptionMethod = hlsEncryptInfo.encryptionMethod;
     this.encryptionKey = hlsEncryptInfo.encryptionKey;
     this.encryptionIv = hlsEncryptInfo.encryptionIv;
-    if ( encryptionMethod != null && encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES)) {
+    if (encryptionMethod != null && encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES)) {
       this.mMode = C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 6ded24c563..154f446bae 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -17,6 +17,7 @@
 
 import android.util.Log;
 import android.util.Pair;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
@@ -28,6 +29,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -104,7 +106,7 @@ public AdtsReader(boolean exposeId3) {
 
   /**
    * @param exposeId3 True if the reader should expose ID3 information.
-   * @param language Track language.
+   * @param language  Track language.
    */
   public AdtsReader(boolean exposeId3, String language) {
     adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
@@ -217,8 +219,8 @@ public void packetFinished() {
    * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
    * that the data should be written into {@code target} starting from an offset of zero.
    *
-   * @param source The source from which to read.
-   * @param target The target into which data is to be read.
+   * @param source       The source from which to read.
+   * @param target       The target into which data is to be read.
    * @param targetLength The target length of the read.
    * @return Whether the target length was reached.
    */
@@ -252,13 +254,13 @@ private void setReadingId3HeaderState() {
   /**
    * Sets the state to STATE_READING_SAMPLE.
    *
-   * @param outputToUse TrackOutput object to write the sample to
+   * @param outputToUse           TrackOutput object to write the sample to
    * @param currentSampleDuration Duration of the sample to be read
-   * @param priorReadBytes Size of prior read bytes
-   * @param sampleSize Size of the sample
+   * @param priorReadBytes        Size of prior read bytes
+   * @param sampleSize            Size of the sample
    */
   private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
-      int priorReadBytes, int sampleSize) {
+                                     int priorReadBytes, int sampleSize) {
     state = STATE_READING_SAMPLE;
     bytesRead = priorReadBytes;
     this.currentOutput = outputToUse;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 34f513a38e..e8ccb89fdb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -24,6 +25,7 @@
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.Factory;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -42,7 +44,9 @@
   @IntDef(flag = true, value = {FLAG_ALLOW_NON_IDR_KEYFRAMES, FLAG_IGNORE_AAC_STREAM,
       FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS, FLAG_IGNORE_SPLICE_INFO_STREAM,
       FLAG_OVERRIDE_CAPTION_DESCRIPTORS})
-  public @interface Flags {}
+  public @interface Flags {
+  }
+
   public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
   public static final int FLAG_IGNORE_AAC_STREAM = 1 << 1;
   public static final int FLAG_IGNORE_H264_STREAM = 1 << 2;
@@ -52,7 +56,8 @@
 
   private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
 
-  @Flags private final int flags;
+  @Flags
+  private final int flags;
   private final List<Format> closedCaptionFormats;
 
   public DefaultTsPayloadReaderFactory() {
@@ -61,21 +66,21 @@ public DefaultTsPayloadReaderFactory() {
 
   /**
    * @param flags A combination of {@code FLAG_*} values that control the behavior of the created
-   *     readers.
+   *              readers.
    */
   public DefaultTsPayloadReaderFactory(@Flags int flags) {
     this(flags, Collections.<Format>emptyList());
   }
 
   /**
-   * @param flags A combination of {@code FLAG_*} values that control the behavior of the created
-   *     readers.
+   * @param flags                A combination of {@code FLAG_*} values that control the behavior of the created
+   *                             readers.
    * @param closedCaptionFormats {@link Format}s to be exposed by payload readers for streams with
-   *     embedded closed captions when no caption service descriptors are provided. If
-   *     {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, {@code closedCaptionFormats} overrides
-   *     any descriptor information. If not set, and {@code closedCaptionFormats} is empty, a
-   *     closed caption track with {@link Format#accessibilityChannel} {@link Format#NO_VALUE} will
-   *     be exposed.
+   *                             embedded closed captions when no caption service descriptors are provided. If
+   *                             {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, {@code closedCaptionFormats} overrides
+   *                             any descriptor information. If not set, and {@code closedCaptionFormats} is empty, a
+   *                             closed caption track with {@link Format#accessibilityChannel} {@link Format#NO_VALUE} will
+   *                             be exposed.
    */
   public DefaultTsPayloadReaderFactory(@Flags int flags, List<Format> closedCaptionFormats) {
     this.flags = flags;
@@ -98,7 +103,7 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEnc
       case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
         return new PesReader(new MpegAudioReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AAC:
-          case C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES:
+      case C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES:
         return isSet(FLAG_IGNORE_AAC_STREAM)
             ? null : new PesReader(new AdtsReader(false, esInfo.language, streamType, hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_AC3:
@@ -110,10 +115,10 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEnc
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader());
       case TsExtractor.TS_STREAM_TYPE_H264:
-        case C.TS_STREAM_TYPE_SAMPLE_AES_H264:
+      case C.TS_STREAM_TYPE_SAMPLE_AES_H264:
         return isSet(FLAG_IGNORE_H264_STREAM) ? null
             : new PesReader(new H264Reader(buildSeiReader(esInfo),
-                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS),streamType,hlsEncryptInfo));
+            isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS), streamType, hlsEncryptInfo));
       case TsExtractor.TS_STREAM_TYPE_H265:
         return new PesReader(new H265Reader(buildSeiReader(esInfo)));
       case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 032ac139a9..5d1d0b4049 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -28,6 +29,7 @@
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.ParsableNalUnitBitArray;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -73,11 +75,11 @@
   private boolean bFirstSample;
 
   /**
-   * @param seiReader An SEI reader for consuming closed caption channels.
+   * @param seiReader            An SEI reader for consuming closed caption channels.
    * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
-   *     synchronization samples (key-frames).
-   * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
-   *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
+   *                             synchronization samples (key-frames).
+   * @param detectAccessUnits    Whether to split the input stream into access units (samples) based on
+   *                             slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
    */
   public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
     this.seiReader = seiReader;
@@ -288,7 +290,7 @@ private void endNalUnit(int curNALType, long position, int offset, int discardPa
     private boolean sampleIsKeyframe;
 
     public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
-        boolean detectAccessUnits) {
+                        boolean detectAccessUnits) {
       this.output = output;
       this.allowNonIdrKeyframes = allowNonIdrKeyframes;
       this.detectAccessUnits = detectAccessUnits;
@@ -325,8 +327,8 @@ public void startNalUnit(long position, int type, long pesTimeUs) {
       nalUnitStartPosition = position;
       if ((allowNonIdrKeyframes && nalUnitType == NAL_UNIT_TYPE_NON_IDR)
           || (detectAccessUnits && (nalUnitType == NAL_UNIT_TYPE_IDR
-              || nalUnitType == NAL_UNIT_TYPE_NON_IDR
-              || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
+          || nalUnitType == NAL_UNIT_TYPE_NON_IDR
+          || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
         // Store the previous header and prepare to populate the new one.
         SliceHeaderData newSliceHeader = previousSliceHeader;
         previousSliceHeader = sliceHeader;
@@ -340,9 +342,9 @@ public void startNalUnit(long position, int type, long pesTimeUs) {
     /**
      * Called to pass stream data. The data passed should not include the 3 byte start code.
      *
-     * @param data Holds the data being passed.
+     * @param data   Holds the data being passed.
      * @param offset The offset of the data in {@code data}.
-     * @param limit The limit (exclusive) of the data in {@code data}.
+     * @param limit  The limit (exclusive) of the data in {@code data}.
      */
     public void appendToNalUnit(byte[] data, int offset, int limit) {
       if (!isFilling) {
@@ -538,9 +540,9 @@ public void setSliceType(int sliceType) {
       }
 
       public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
-          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
-          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
-          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+                         int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
+                         boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
+                         int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
         this.spsData = spsData;
         this.nalRefIdc = nalRefIdc;
         this.sliceType = sliceType;
@@ -568,14 +570,14 @@ private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
         return isComplete && (!other.isComplete || frameNum != other.frameNum
             || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
             || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
-                && bottomFieldFlag != other.bottomFieldFlag)
+            && bottomFieldFlag != other.bottomFieldFlag)
             || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
             || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
-                && (picOrderCntLsb != other.picOrderCntLsb
-                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+            && (picOrderCntLsb != other.picOrderCntLsb
+            || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
             || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
-                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
-                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+            && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+            || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
             || idrPicFlag != other.idrPicFlag
             || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 8d368227ab..dade34ed6c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -19,6 +19,7 @@
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -37,6 +38,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -57,7 +59,7 @@
 
     @Override
     public Extractor[] createExtractors() {
-      return new Extractor[] {new TsExtractor()};
+      return new Extractor[]{new TsExtractor()};
     }
 
   };
@@ -67,7 +69,8 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
-  public @interface Mode {}
+  public @interface Mode {
+  }
 
   /**
    * Behave as defined in ISO/IEC 13818-1.
@@ -109,7 +112,8 @@
   private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
 
-  @Mode private final int mode;
+  @Mode
+  private final int mode;
   private final List<TimestampAdjuster> timestampAdjusters;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
@@ -133,17 +137,17 @@ public TsExtractor() {
 
   /**
    * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-   *     {@code FLAG_*} values that control the behavior of the payload readers.
+   *                                    {@code FLAG_*} values that control the behavior of the payload readers.
    */
   public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
     this(MODE_SINGLE_PMT, defaultTsPayloadReaderFlags);
   }
 
   /**
-   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
-   *     and {@link #MODE_HLS}.
+   * @param mode                        Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+   *                                    and {@link #MODE_HLS}.
    * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-   *     {@code FLAG_*} values that control the behavior of the payload readers.
+   *                                    {@code FLAG_*} values that control the behavior of the payload readers.
    */
   public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
     this(mode, new TimestampAdjuster(0),
@@ -152,13 +156,13 @@ public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
 
 
   /**
-   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
-   *     and {@link #MODE_HLS}.
-   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   * @param mode                 Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+   *                             and {@link #MODE_HLS}.
+   * @param timestampAdjuster    A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
    */
   public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
-      TsPayloadReader.Factory payloadReaderFactory) {
+                     TsPayloadReader.Factory payloadReaderFactory) {
     this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
     this.mode = mode;
     if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
@@ -344,7 +348,7 @@ public PatReader() {
 
     @Override
     public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
+                     TrackIdGenerator idGenerator) {
       // Do nothing.
     }
 
@@ -402,7 +406,7 @@ public PmtReader(int pid) {
 
     @Override
     public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
+                     TrackIdGenerator idGenerator) {
       // Do nothing.
     }
 
@@ -502,7 +506,7 @@ public void consume(ParsableByteArray sectionData) {
      * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
      * the end of the descriptors.
      *
-     * @param data A buffer with its position set to the start of the first descriptor.
+     * @param data   A buffer with its position set to the start of the first descriptor.
      * @param length The length of descriptors to read from the current position in {@code data}.
      * @return The stream info read from the available descriptors.
      */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index c4882d8b7b..17cf720af0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+
 import java.util.Collections;
 import java.util.List;
 
@@ -48,9 +50,9 @@
      * May return null if the stream type is not supported.
      *
      * @param streamType Stream type value as defined in the PMT entry or associated descriptors.
-     * @param esInfo Information associated to the elementary stream provided in the PMT.
+     * @param esInfo     Information associated to the elementary stream provided in the PMT.
      * @return A {@link TsPayloadReader} for the packet stream carried by the provided pid.
-     *     {@code null} if the stream is not supported.
+     * {@code null} if the stream is not supported.
      */
     TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo, HLSEncryptInfo hlsEncryptInfo);
 
@@ -67,14 +69,14 @@
     public final byte[] descriptorBytes;
 
     /**
-     * @param streamType The type of the stream as defined by the
-     *     {@link TsExtractor}{@code .TS_STREAM_TYPE_*}.
-     * @param language The language of the stream, as defined by ISO/IEC 13818-1, section 2.6.18.
+     * @param streamType       The type of the stream as defined by the
+     *                         {@link TsExtractor}{@code .TS_STREAM_TYPE_*}.
+     * @param language         The language of the stream, as defined by ISO/IEC 13818-1, section 2.6.18.
      * @param dvbSubtitleInfos Information about DVB subtitles associated to the stream.
-     * @param descriptorBytes The descriptor bytes associated to the stream.
+     * @param descriptorBytes  The descriptor bytes associated to the stream.
      */
     public EsInfo(int streamType, String language, List<DvbSubtitleInfo> dvbSubtitleInfos,
-        byte[] descriptorBytes) {
+                  byte[] descriptorBytes) {
       this.streamType = streamType;
       this.language = language;
       this.dvbSubtitleInfos = dvbSubtitleInfos == null ? Collections.<DvbSubtitleInfo>emptyList()
@@ -94,8 +96,8 @@ public EsInfo(int streamType, String language, List<DvbSubtitleInfo> dvbSubtitle
     public final byte[] initializationData;
 
     /**
-     * @param language The ISO 639-2 three character language.
-     * @param type The subtitling type.
+     * @param language           The ISO 639-2 three character language.
+     * @param type               The subtitling type.
      * @param initializationData The composition and ancillary page ids.
      */
     public DvbSubtitleInfo(String language, int type, byte[] initializationData) {
@@ -156,8 +158,8 @@ public int getTrackId() {
      * called after the first {@link #generateNewId()} call.
      *
      * @return The last generated format id, with the format {@code "programNumber/trackId"}. If no
-     *     {@code programNumber} was provided, the {@code trackId} alone is used as
-     *     format id.
+     * {@code programNumber} was provided, the {@code trackId} alone is used as
+     * format id.
      */
     public String getFormatId() {
       maybeThrowUninitializedError();
@@ -176,12 +178,12 @@ private void maybeThrowUninitializedError() {
    * Initializes the payload reader.
    *
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
-   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
-   *     {@link TrackOutput}s.
+   * @param extractorOutput   The {@link ExtractorOutput} that receives the extracted data.
+   * @param idGenerator       A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
+   *                          {@link TrackOutput}s.
    */
   void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-      TrackIdGenerator idGenerator);
+            TrackIdGenerator idGenerator);
 
   /**
    * Notifies the reader that a seek has occurred.
@@ -195,7 +197,7 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
   /**
    * Consumes the payload of a TS packet.
    *
-   * @param data The TS packet. The position will be set to the start of the payload.
+   * @param data                      The TS packet. The position will be set to the start of the payload.
    * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
    */
   void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
index 7d95428050..1cbcaef787 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/HLSEncryptInfo.java
@@ -3,34 +3,34 @@
 
 public final class HLSEncryptInfo {
 
-    public String encryptionMethod;
-    public String encryptionKeyUri;
-    public String encryptionIvString;
+  public String encryptionMethod;
+  public String encryptionKeyUri;
+  public String encryptionIvString;
 
-    public String encryptionKeyId;
-    public String encryptionKeyFormat;
+  public String encryptionKeyId;
+  public String encryptionKeyFormat;
 
-    public String encryptionKeyString;
+  public String encryptionKeyString;
 
-    public byte[] encryptionIv;
-    public byte[] encryptionKey;
-    public boolean isEncrypted;
+  public byte[] encryptionIv;
+  public byte[] encryptionKey;
+  public boolean isEncrypted;
 
-    public HLSEncryptInfo() {
+  public HLSEncryptInfo() {
 
-    }
+  }
 
-    public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv) {
-        this.isEncrypted = isEncrypted;
-        this.encryptionMethod = encryptionMethod;
-        this.encryptionKeyUri = encryptionKeyUri;
-        this.encryptionIvString = encryptionKeyIv;
-    }
+  public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv) {
+    this.isEncrypted = isEncrypted;
+    this.encryptionMethod = encryptionMethod;
+    this.encryptionKeyUri = encryptionKeyUri;
+    this.encryptionIvString = encryptionKeyIv;
+  }
 
-    public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv, String encryptionKeyFormat, String encryptionKeyId) {
-        this(isEncrypted, encryptionMethod, encryptionKeyUri, encryptionKeyIv);
-        this.encryptionKeyFormat = encryptionKeyFormat;
-        this.encryptionKeyId = encryptionKeyId;
-    }
+  public HLSEncryptInfo(boolean isEncrypted, String encryptionMethod, String encryptionKeyUri, String encryptionKeyIv, String encryptionKeyFormat, String encryptionKeyId) {
+    this(isEncrypted, encryptionMethod, encryptionKeyUri, encryptionKeyIv);
+    this.encryptionKeyFormat = encryptionKeyFormat;
+    this.encryptionKeyId = encryptionKeyId;
+  }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index f29a2d993d..0613328de6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
@@ -35,6 +36,7 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.Arrays;
@@ -105,19 +107,19 @@ public void clear() {
   private TrackSelection trackSelection;
 
   /**
-   * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
-   * @param variants The available variants.
-   * @param dataSourceFactory An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
-   *     chunks.
+   * @param playlistTracker           The {@link HlsPlaylistTracker} from which to obtain media playlists.
+   * @param variants                  The available variants.
+   * @param dataSourceFactory         An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
+   *                                  chunks.
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
-   *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
-   *     same provider.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
-   *     information is available in the master playlist.
+   *                                  multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+   *                                  same provider.
+   * @param muxedCaptionFormats       List of muxed caption {@link Format}s. Null if no closed caption
+   *                                  information is available in the master playlist.
    */
   public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
-      HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
-      List<Format> muxedCaptionFormats) {
+                        HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
+                        List<Format> muxedCaptionFormats) {
     this.playlistTracker = playlistTracker;
     this.variants = variants;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
@@ -176,7 +178,7 @@ public void reset() {
    * Sets whether this chunk source is responsible for initializing timestamp adjusters.
    *
    * @param isTimestampMaster True if this chunk source is responsible for initializing timestamp
-   *     adjusters.
+   *                          adjusters.
    */
   public void setIsTimestampMaster(boolean isTimestampMaster) {
     this.isTimestampMaster = isTimestampMaster;
@@ -190,11 +192,11 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
    * the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
    * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
    *
-   * @param previous The most recently loaded media chunk.
+   * @param previous           The most recently loaded media chunk.
    * @param playbackPositionUs The current playback position. If {@code previous} is null then this
-   *     parameter is the position from which playback is expected to start (or restart) and hence
-   *     should be interpreted as a seek position.
-   * @param out A holder to populate.
+   *                           parameter is the position from which playback is expected to start (or restart) and hence
+   *                           should be interpreted as a seek position.
+   * @param out                A holder to populate.
    */
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
@@ -261,25 +263,20 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Handle encryption.
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
 
-
-
-
-
-
     // Check if encryption is specified.
     if (segment.isEncrypted) {
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (
-            ((segment.hlsEncryptInfo.encryptionKeyFormat == null) && segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES))
-                    || segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_AES_128)
-            ){
-            if(!keyUri.equals(encryptionKeyUri)){
-            // Encryption is specified and the key has changed.
-            out.chunk=newEncryptionKeyChunk(keyUri,segment.encryptionIV,selectedVariantIndex,
-            trackSelection.getSelectionReason(),trackSelection.getSelectionData());
-            encryptionKeyUri=keyUri;
-            return;
-            }
+          ((segment.hlsEncryptInfo.encryptionKeyFormat == null) && segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_SAMPLE_AES))
+              || segment.hlsEncryptInfo.encryptionMethod.equals(C.ENCRYPTION_METHOD_AES_128)
+          ) {
+        if (!keyUri.equals(encryptionKeyUri)) {
+          // Encryption is specified and the key has changed.
+          out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
+              trackSelection.getSelectionReason(), trackSelection.getSelectionData());
+          encryptionKeyUri = keyUri;
+          return;
+        }
       }
       if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
         setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
@@ -332,9 +329,9 @@ public void onChunkLoadCompleted(Chunk chunk) {
    * Called when the {@link HlsSampleStreamWrapper} encounters an error loading a chunk obtained
    * from this source.
    *
-   * @param chunk The chunk whose load encountered the error.
+   * @param chunk      The chunk whose load encountered the error.
    * @param cancelable Whether the load can be canceled.
-   * @param error The error.
+   * @param error      The error.
    * @return Whether the load should be canceled.
    */
   public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
@@ -345,7 +342,7 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException err
   /**
    * Called when a playlist is blacklisted.
    *
-   * @param url The url that references the blacklisted playlist.
+   * @param url         The url that references the blacklisted playlist.
    * @param blacklistMs The amount of milliseconds for which the playlist was blacklisted.
    */
   public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
@@ -361,7 +358,7 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
   // Private methods.
 
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
-      int trackSelectionReason, Object trackSelectionData) {
+                                                   int trackSelectionReason, Object trackSelectionData) {
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
     return new EncryptionKeyChunk(encryptionDataSource, dataSpec, variants[variantIndex].format,
         trackSelectionReason, trackSelectionData, scratchSpace, iv);
@@ -449,7 +446,7 @@ public Object getSelectionData() {
     private byte[] result;
 
     public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-        int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
+                              int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
       super(dataSource, dataSpec, C.DATA_TYPE_DRM, trackFormat, trackSelectionReason,
           trackSelectionData, scratchSpace);
       this.iv = iv;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 85b0826285..ea5418e770 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.text.TextUtils;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
@@ -39,6 +40,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
@@ -106,32 +108,31 @@
   private final HLSEncryptInfo hlsEncryptInfo;
 
 
-
   /**
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded.
-   * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
-   * @param hlsUrl The url of the playlist from which this chunk was obtained.
-   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
-   *     information is available in the master playlist.
-   * @param trackSelectionReason See {@link #trackSelectionReason}.
-   * @param trackSelectionData See {@link #trackSelectionData}.
-   * @param startTimeUs The start time of the chunk in microseconds.
-   * @param endTimeUs The end time of the chunk in microseconds.
-   * @param chunkIndex The media sequence number of the chunk.
+   * @param dataSource                  The source from which the data should be loaded.
+   * @param dataSpec                    Defines the data to be loaded.
+   * @param initDataSpec                Defines the initialization data to be fed to new extractors. May be null.
+   * @param hlsUrl                      The url of the playlist from which this chunk was obtained.
+   * @param muxedCaptionFormats         List of muxed caption {@link Format}s. Null if no closed caption
+   *                                    information is available in the master playlist.
+   * @param trackSelectionReason        See {@link #trackSelectionReason}.
+   * @param trackSelectionData          See {@link #trackSelectionData}.
+   * @param startTimeUs                 The start time of the chunk in microseconds.
+   * @param endTimeUs                   The end time of the chunk in microseconds.
+   * @param chunkIndex                  The media sequence number of the chunk.
    * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
-   * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
-   * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
-   * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
-   * @param encryptionKey For AES encryption chunks, the encryption key.
-   * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
+   * @param isMasterTimestampSource     True if the chunk can initialize the timestamp adjuster.
+   * @param timestampAdjuster           Adjuster corresponding to the provided discontinuity sequence number.
+   * @param previousChunk               The {@link HlsMediaChunk} that preceded this one. May be null.
+   * @param encryptionKey               For AES encryption chunks, the encryption key.
+   * @param encryptionIv                For AES encryption chunks, the encryption initialization vector.
    */
   public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
-      HlsUrl hlsUrl, List<Format> muxedCaptionFormats, int trackSelectionReason,
-      Object trackSelectionData, long startTimeUs, long endTimeUs, int chunkIndex,
-      int discontinuitySequenceNumber, boolean isMasterTimestampSource,
-      TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, byte[] encryptionKey,
-      byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
+                       HlsUrl hlsUrl, List<Format> muxedCaptionFormats, int trackSelectionReason,
+                       Object trackSelectionData, long startTimeUs, long endTimeUs, int chunkIndex,
+                       int discontinuitySequenceNumber, boolean isMasterTimestampSource,
+                       TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, byte[] encryptionKey,
+                       byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
     super(buildDataSource(dataSource, encryptionKey, encryptionIv, hlsEncryptInfo), dataSpec, hlsUrl.format,
         trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
@@ -295,7 +296,7 @@ private void loadMedia() throws IOException, InterruptedException {
    *
    * @param input The {@link ExtractorInput} to obtain the PRIV frame from.
    * @return The parsed, adjusted timestamp in microseconds
-   * @throws IOException If an error occurred peeking from the input.
+   * @throws IOException          If an error occurred peeking from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
   private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
@@ -345,7 +346,7 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
    * order to decrypt the loaded data. Else returns the original.
    */
   private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
-      byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
+                                            byte[] encryptionIv, HLSEncryptInfo hlsEncryptInfo) {
 
     if (hlsEncryptInfo.encryptionMethod != null && hlsEncryptInfo.encryptionMethod.equals("AES-128"))
       return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 18cca96401..a362a41058 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -17,6 +17,7 @@
 
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.HLSEncryptInfo;
 
@@ -53,8 +54,8 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
     }
 
     public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
-        long relativeStartTimeUs, HLSEncryptInfo hlsEncryptInfo,
-        long byterangeOffset, long byterangeLength) {
+                   long relativeStartTimeUs, HLSEncryptInfo hlsEncryptInfo,
+                   long byterangeOffset, long byterangeLength) {
 
       this.url = uri;
       this.durationUs = durationUs;
@@ -82,12 +83,15 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
-  public @interface PlaylistType {}
+  public @interface PlaylistType {
+  }
+
   public static final int PLAYLIST_TYPE_UNKNOWN = 0;
   public static final int PLAYLIST_TYPE_VOD = 1;
   public static final int PLAYLIST_TYPE_EVENT = 2;
 
-  @PlaylistType public final int playlistType;
+  @PlaylistType
+  public final int playlistType;
   public final long startOffsetUs;
   public final long startTimeUs;
   public final boolean hasDiscontinuitySequence;
@@ -103,10 +107,10 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
   public final long durationUs;
 
   public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
-      long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
-      int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
-      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments,
-      List<String> dateRanges) {
+                          long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
+                          int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
+                          boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments,
+                          List<String> dateRanges) {
     super(baseUri);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
@@ -159,7 +163,7 @@ public long getEndTimeUs() {
    * and {@code hasDiscontinuitySequence} values. The first two are set to the specified values,
    * {@code hasDiscontinuitySequence} is set to true.
    *
-   * @param startTimeUs The start time for the returned playlist.
+   * @param startTimeUs           The start time for the returned playlist.
    * @param discontinuitySequence The discontinuity sequence for the returned playlist.
    * @return The playlist.
    */
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 2a4c9265c3..929db90495 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -25,6 +26,7 @@
 import com.google.android.exoplayer2.util.HLSEncryptInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
