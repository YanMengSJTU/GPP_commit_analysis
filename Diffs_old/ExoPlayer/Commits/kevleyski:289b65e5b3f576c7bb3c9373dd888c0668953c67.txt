diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
index 3667c8cc96..6e55f3dcd6 100644
--- a/ISSUE_TEMPLATE
+++ b/ISSUE_TEMPLATE
@@ -1,5 +1,7 @@
+*** PLEASE DO NOT IGNORE THIS ISSUE TEMPLATE ***
+
 Please search the existing issues before filing a new one, including issues that
-are closed. When filing a new issue please include all of the following, unless
+are closed. When filing a new issue please include ALL of the following, unless
 you're certain that they're not useful for the particular issue being reported.
 
 - A description of the issue.
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9e0439dd12..234c91daba 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,22 +1,151 @@
 # Release notes #
 
-### r2.0.3 ###
+### r2.2.0 ###
+
+* Demo app: Automatic recovery from BehindLiveWindowException, plus improved
+  handling of pausing and resuming live streams
+  ([#2344](https://github.com/google/ExoPlayer/issues/2344)).
+* AndroidTV: Added Support for tunneled video playback
+  ([#1688](https://github.com/google/ExoPlayer/issues/1688)).
+* DRM: Renamed StreamingDrmSessionManager to DefaultDrmSessionManager and
+  added support for using offline licenses
+  ([#876](https://github.com/google/ExoPlayer/issues/876)).
+* DRM: Introduce OfflineLicenseHelper to help with offline license acquisition,
+  renewal and release.
+* UI: Updated player control assets. Added vector drawables for use on API level
+  21 and above.
+* UI: Made player control seek bar work correctly with key events if focusable
+  ([#2278](https://github.com/google/ExoPlayer/issues/2278)).
+* HLS: Improved support for streams that use EXT-X-DISCONTINUITY without
+  EXT-X-DISCONTINUITY-SEQUENCE
+  ([#1789](https://github.com/google/ExoPlayer/issues/1789)).
+* HLS: Support for EXT-X-START tag
+  ([#1544](https://github.com/google/ExoPlayer/issues/1544)).
+* HLS: Check #EXTM3U header is present when parsing the playlist. Fail
+  gracefully if not ([#2301](https://github.com/google/ExoPlayer/issues/2301)).
+* HLS: Fix memory leak
+  ([#2319](https://github.com/google/ExoPlayer/issues/2319)).
+* HLS: Fix non-seamless first adaptation where master playlist omits resolution
+  tags ([#2096](https://github.com/google/ExoPlayer/issues/2096)).
+* HLS: Fix handling of WebVTT subtitle renditions with non-standard segment file
+  extensions ([#2025](https://github.com/google/ExoPlayer/issues/2025) and
+  [#2355](https://github.com/google/ExoPlayer/issues/2355)).
+* HLS: Better handle inconsistent HLS playlist update
+  ([#2249](https://github.com/google/ExoPlayer/issues/2249)).
+* DASH: Don't overflow when dealing with large segment numbers
+  ([#2311](https://github.com/google/ExoPlayer/issues/2311)).
+* DASH: Fix propagation of language from the manifest
+  ([#2335](https://github.com/google/ExoPlayer/issues/2335)).
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+* MP3/ID3: Added support for parsing Chapter and URL link frames
+  ([#2316](https://github.com/google/ExoPlayer/issues/2316)).
+* MP3/ID3: Handle ID3 frames that end with empty text field
+  ([#2309](https://github.com/google/ExoPlayer/issues/2309)).
+* Added ClippingMediaSource for playing clipped portions of media
+  ([#1988](https://github.com/google/ExoPlayer/issues/1988)).
+* Added convenience methods to query whether the current window is dynamic and
+  seekable ([#2320](https://github.com/google/ExoPlayer/issues/2320)).
+* Support setting of default headers on HttpDataSource.Factory implementations
+  ([#2166](https://github.com/google/ExoPlayer/issues/2166)).
+* Fixed cache failures when using an encrypted cache content index.
+* Fix visual artifacts when switching output surface
+  ([#2093](https://github.com/google/ExoPlayer/issues/2093)).
+* Fix gradle + proguard configurations.
+* Fix player position when replacing the MediaSource
+  ([#2369](https://github.com/google/ExoPlayer/issues/2369)).
+* Misc bug fixes, including
+  [#2330](https://github.com/google/ExoPlayer/issues/2330),
+  [#2269](https://github.com/google/ExoPlayer/issues/2269),
+  [#2252](https://github.com/google/ExoPlayer/issues/2252),
+  [#2264](https://github.com/google/ExoPlayer/issues/2264) and
+  [#2290](https://github.com/google/ExoPlayer/issues/2290).
+
+### r2.1.1 ###
+
+* Fix some subtitle types (e.g. WebVTT) being displayed out of sync
+  ([#2208](https://github.com/google/ExoPlayer/issues/2208)).
+* Fix incorrect position reporting for on-demand HLS media that includes
+  EXT-X-PROGRAM-DATE-TIME tags
+  ([#2224](https://github.com/google/ExoPlayer/issues/2224)).
+* Fix issue where playbacks could get stuck in the initial buffering state if
+  over 1MB of data needs to be read to initialize the playback.
+
+### r2.1.0 ###
+
+* HLS: Support for seeking in live streams
+  ([#87](https://github.com/google/ExoPlayer/issues/87)).
+* HLS: Improved support:
+ * Support for EXT-X-PROGRAM-DATE-TIME
+   ([#747](https://github.com/google/ExoPlayer/issues/747)).
+ * Improved handling of sample timestamps and their alignment across variants
+   and renditions.
+ * Fix issue that could cause playbacks to get stuck in an endless initial
+   buffering state.
+ * Correctly propagate BehindLiveWindowException instead of
+   IndexOutOfBoundsException exception
+   ([#1695](https://github.com/google/ExoPlayer/issues/1695)).
+* MP3/MP4: Support for ID3 metadata, including embedded album art
+  ([#979](https://github.com/google/ExoPlayer/issues/979)).
+* Improved customization of UI components. You can read about customization of
+  ExoPlayer's UI components
+  [here](https://medium.com/google-exoplayer/customizing-exoplayers-ui-components-728cf55ee07a#.9ewjg7avi).
+* Robustness improvements when handling MediaSource timeline changes and
+  MediaPeriod transitions.
+* EIA608: Support for caption styling and positioning.
+* MPEG-TS: Improved support:
+ * Support injection of custom TS payload readers.
+ * Support injection of custom section payload readers.
+ * Support SCTE-35 splice information messages.
+ * Support multiple table sections in a single PSI section.
+ * Fix NullPointerException when an unsupported stream type is encountered
+   ([#2149](https://github.com/google/ExoPlayer/issues/2149)).
+ * Avoid failure when expected ID3 header not found
+   ([#1966](https://github.com/google/ExoPlayer/issues/1966)).
+* Improvements to the upstream cache package.
+ * Support caching of media segments for DASH, HLS and SmoothStreaming. Note
+   that caching of manifest and playlist files is still not supported in the
+   (normal) case where the corresponding responses are compressed.
+ * Support caching for ExtractorMediaSource based playbacks.
+* Improved flexibility of SimpleExoPlayer
+  ([#2102](https://github.com/google/ExoPlayer/issues/2102)).
+* Fix issue where only the audio of a video would play due to capability
+  detection issues ([#2007](https://github.com/google/ExoPlayer/issues/2007),
+  [#2034](https://github.com/google/ExoPlayer/issues/2034) and
+  [#2157](https://github.com/google/ExoPlayer/issues/2157)).
+* Fix issues that could cause ExtractorMediaSource based playbacks to get stuck
+  buffering ([#1962](https://github.com/google/ExoPlayer/issues/1962)).
+* Correctly set SimpleExoPlayerView surface aspect ratio when an active player
+  is attached ([#2077](https://github.com/google/ExoPlayer/issues/2077)).
+* OGG: Fix playback of short OGG files
+  ([#1976](https://github.com/google/ExoPlayer/issues/1976)).
+* MP4: Support `.mp3` tracks
+  ([#2066](https://github.com/google/ExoPlayer/issues/2066)).
+* SubRip: Don't fail playbacks if SubRip file contains negative timestamps
+  ([#2145](https://github.com/google/ExoPlayer/issues/2145)).
+* Misc bugfixes.
+
+### r2.0.4 ###
 
-This release contains important bug fixes. Users of r2.0.0, r2.0.1 and r2.0.2
-should proactively update to this version.
+* Fix crash on Jellybean devices when using playback controls
+  ([#1965](https://github.com/google/ExoPlayer/issues/1965)).
+
+### r2.0.3 ###
 
 * Fixed NullPointerException in ExtractorMediaSource
-  ([#1914](https://github.com/google/ExoPlayer/issues/1914).
+  ([#1914](https://github.com/google/ExoPlayer/issues/1914)).
 * Fixed NullPointerException in HlsMediaPeriod
-  ([#1907](https://github.com/google/ExoPlayer/issues/1907).
+  ([#1907](https://github.com/google/ExoPlayer/issues/1907)).
 * Fixed memory leak in PlaybackControlView
-  ([#1908](https://github.com/google/ExoPlayer/issues/1908).
+  ([#1908](https://github.com/google/ExoPlayer/issues/1908)).
 * Fixed strict mode violation when using
   SimpleExoPlayer.setVideoPlayerTextureView().
 * Fixed L3 Widevine provisioning
-  ([#1925](https://github.com/google/ExoPlayer/issues/1925).
+  ([#1925](https://github.com/google/ExoPlayer/issues/1925)).
 * Fixed hiding of controls with use_controller="false"
-  ([#1919](https://github.com/google/ExoPlayer/issues/1919).
+  ([#1919](https://github.com/google/ExoPlayer/issues/1919)).
 * Improvements to Cronet network stack extension.
 * Misc bug fixes.
 
@@ -108,6 +237,34 @@ some of the motivations behind ExoPlayer 2.x
  * Suppressed "Sending message to a Handler on a dead thread" warnings
    ([#426](https://github.com/google/ExoPlayer/issues/426)).
 
+# Legacy release notes #
+
+Note: Since ExoPlayer V1 is still being maintained alongside V2, there is some
+overlap between these notes and the notes above. r2.0.0 followed from r1.5.11,
+and hence it can be assumed that all changes in r1.5.11 and earlier are included
+in all V2 releases. This cannot be assumed for changes in r1.5.12 and later,
+however it can be assumed that all such changes are included in the most recent
+V2 release.
+
+### r1.5.14 ###
+
+* Fixed cache failures when using an encrypted cache content index.
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+
+### r1.5.13 ###
+
+* Improvements to the upstream cache package.
+* MP4: Support `.mp3` tracks
+  ([#2066](https://github.com/google/ExoPlayer/issues/2066)).
+* SubRip: Don't fail playbacks if SubRip file contains negative timestamps
+  ([#2145](https://github.com/google/ExoPlayer/issues/2145)).
+* MPEG-TS: Avoid failure when expected ID3 header not found
+  ([#1966](https://github.com/google/ExoPlayer/issues/1966)).
+* Misc bugfixes.
+
 ### r1.5.12 ###
 
 * Improvements to Cronet network stack extension.
diff --git a/build.gradle b/build.gradle
index c50dd31b27..b10a17de81 100644
--- a/build.gradle
+++ b/build.gradle
@@ -19,7 +19,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.2'
+        classpath 'com.android.tools.build:gradle:2.2.1'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
@@ -35,7 +35,7 @@ allprojects {
         releaseRepoName = 'exoplayer'
         releaseUserOrg = 'google'
         releaseGroupId = 'com.google.android.exoplayer'
-        releaseVersion = 'r2.0.3'
+        releaseVersion = 'r2.2.0'
         releaseWebsite = 'https://github.com/google/ExoPlayer'
     }
 }
diff --git a/demo/assets/ic_launcher.svg b/demo/assets/ic_launcher.svg
deleted file mode 100644
index 5486b27e29..0000000000
--- a/demo/assets/ic_launcher.svg
+++ /dev/null
@@ -1,660 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="192"
-   height="192"
-   id="svg3089"
-   version="1.1"
-   inkscape:version="0.48.4 r9939"
-   sodipodi:docname="exoplayer.svg"
-   enable-background="new">
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="2.0893424"
-     inkscape:cx="79.970323"
-     inkscape:cy="85.448985"
-     inkscape:current-layer="layer2"
-     showgrid="true"
-     inkscape:grid-bbox="true"
-     inkscape:document-units="px"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="1920"
-     inkscape:window-height="1176"
-     inkscape:window-x="1920"
-     inkscape:window-y="24"
-     inkscape:window-maximized="1" />
-  <defs
-     id="defs3091">
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4624">
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0"
-         id="stop4626" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:0;"
-         offset="1"
-         id="stop4628" />
-    </linearGradient>
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient4511">
-      <stop
-         id="stop4513"
-         offset="0"
-         style="stop-color:#ffffff;stop-opacity:1;" />
-      <stop
-         id="stop4515"
-         offset="1"
-         style="stop-color:#ffffff;stop-opacity:0;" />
-    </linearGradient>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4219">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.5"
-         id="feFlood4221" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4223" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="2"
-         in="composite"
-         id="feGaussianBlur4225" />
-      <feOffset
-         result="offset"
-         dy="4"
-         dx="4"
-         id="feOffset4227" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4229" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4464">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4466" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4468" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4470" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4472" />
-      <feComposite
-         result="fbSourceGraphic"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4474" />
-      <feColorMatrix
-         id="feColorMatrix4476"
-         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
-         in="fbSourceGraphic"
-         result="fbSourceGraphicAlpha" />
-      <feFlood
-         in="fbSourceGraphic"
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4478" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="fbSourceGraphic"
-         id="feComposite4480" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4482" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4484" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="fbSourceGraphic"
-         in2="offset"
-         id="feComposite4486" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4494">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4496" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4498" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4500" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4502" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4504" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4535">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4537" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4539" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4541" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4543" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4545" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4557">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4559" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4561" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4563" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4565" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4567" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4575">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4581" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       id="filter4575-6"
-       color-interpolation-filters="sRGB">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577-1" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579-3" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         id="feGaussianBlur4581-3" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583-6" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585-9" />
-    </filter>
-    <filter
-       id="filter3896"
-       inkscape:collect="always">
-      <feBlend
-         id="feBlend3898"
-         in2="BackgroundImage"
-         mode="multiply"
-         inkscape:collect="always" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter3909">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood3911" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite3913" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur3915" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset3917" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite3919" />
-    </filter>
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498"
-       id="linearGradient4504"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498-7"
-       id="linearGradient4504-7"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498-7">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500-0" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502-0" />
-    </linearGradient>
-    <linearGradient
-       gradientTransform="translate(-0.12691481,66.675082)"
-       y2="130.50137"
-       x2="110.44475"
-       y1="63.20599"
-       x1="43.149372"
-       gradientUnits="userSpaceOnUse"
-       id="linearGradient4521"
-       xlink:href="#linearGradient4498-7"
-       inkscape:collect="always" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4624"
-       id="radialGradient4630"
-       cx="17.483059"
-       cy="18.005892"
-       fx="17.483059"
-       fy="18.005892"
-       r="88.000001"
-       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
-       gradientUnits="userSpaceOnUse" />
-    <filter
-       id="filter4680"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.4100000000000001"
-       height="1.4700000000000002"
-       x="-0.23000000000000009"
-       y="-0.23000000000000009">
-      <feFlood
-         id="feFlood4682"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4684"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4686"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4688"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4690"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4692"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.3600000000000001"
-       x="-0.2400000000000001"
-       y="-0.070000000000000034"
-       height="1.3600000000000001">
-      <feFlood
-         id="feFlood4694"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4696"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4698"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4700"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4702"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4710"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow">
-      <feFlood
-         id="feFlood4712"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4714"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4716"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4718"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4720"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-  </defs>
-  <metadata
-     id="metadata3094">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     style="display:none"
-     sodipodi:insensitive="true"
-     transform="translate(0,176)"
-     inkscape:groupmode="layer"
-     inkscape:label="Layer 1"
-     id="layer1">
-    <image
-       width="192"
-       height="192"
-       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
-       id="image3116"
-       x="0"
-       y="-176" />
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="base"
-     id="layer2"
-     inkscape:groupmode="layer">
-    <g
-       id="g4704"
-       style="filter:url(#filter4710)">
-      <path
-         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
-         id="path3938-4"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
-         id="path3938-5"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#607d8b;fill-opacity:1;stroke:none"
-         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
-         id="path3938"
-         inkscape:connector-curvature="0" />
-      <path
-         sodipodi:nodetypes="cccc"
-         inkscape:connector-curvature="0"
-         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
-         style="fill:#ffffff;stroke:none"
-         inkscape:label="Triangle"
-         id="path4262" />
-    </g>
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="Layer"
-     id="layer3"
-     inkscape:groupmode="layer"
-     sodipodi:insensitive="true">
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
-       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
-       id="path4488"
-       inkscape:connector-curvature="0" />
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
-       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
-       id="path4488-8"
-       inkscape:connector-curvature="0" />
-    <g
-       transform="translate(0,2.2931745)"
-       id="g4071"
-       style="filter:url(#filter4692)">
-      <path
-         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-1"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-8"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#00bcd4;fill-opacity:1;stroke:none"
-         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2"
-         inkscape:connector-curvature="0" />
-    </g>
-    <g
-       transform="translate(-0.511613,5.6775255)"
-       id="g4111"
-       style="filter:url(#filter4680)">
-      <g
-         id="g4106">
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-1-0"
-           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-8-8"
-           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-2"
-           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
-      </g>
-    </g>
-  </g>
-  <g
-     inkscape:groupmode="layer"
-     id="layer5"
-     inkscape:label="finish"
-     style="opacity:0.18656718;display:inline"
-     sodipodi:insensitive="true">
-    <path
-       inkscape:connector-curvature="0"
-       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
-       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
-       id="path3938-4-0" />
-  </g>
-</svg>
diff --git a/demo/build.gradle b/demo/build.gradle
index bfbcd1aa4c..007dc70590 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -24,19 +24,15 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
         }
         debug {
             jniDebuggable = true
-            debuggable = true
         }
     }
 
-    lintOptions {
-        abortOnError false
-    }
-
     productFlavors {
         noExtensions
         withExtensions
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 7fc0ac3d9c..2f3dc0d1bf 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,17 +16,19 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo"
-    android:versionCode="2003"
-    android:versionName="2.0.3">
+    android:versionCode="2200"
+    android:versionName="2.2.0">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
-
+  <uses-feature android:name="android.software.leanback" android:required="false"/>
+  <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
   <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="24"/>
 
   <application
       android:label="@string/application_name"
-      android:icon="@drawable/ic_launcher"
+      android:icon="@mipmap/ic_launcher"
+      android:banner="@drawable/ic_banner"
       android:largeHeap="true"
       android:allowBackup="false"
       android:name="com.google.android.exoplayer2.demo.DemoApplication">
@@ -37,6 +39,7 @@
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
       </intent-filter>
       <intent-filter>
         <action android:name="android.intent.action.VIEW"/>
diff --git a/demo/src/main/assets/media.exolist.json b/demo/src/main/assets/media.exolist.json
index 6fa46d7451..6fba5bd65b 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demo/src/main/assets/media.exolist.json
@@ -183,52 +183,52 @@
         "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd"
       },
       {
-        "name": "WV: Secure SD & HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD & HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure SD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure UHD (WebM,VP9)",
+        "name": "WV: Secure Fullsample UHD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_subsample/sintel_1080p_vp9_altref_subsample.mpd",
+        "name": "WV: Secure Subsample SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_fullsample/sintel_1080p_vp9_altref_fullsample.mpd",
+        "name": "WV: Secure Subsample SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_subsample/sintel_1080p_vp9_noaltref_subsample.mpd",
+        "name": "WV: Secure Subsample HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_fullsample/sintel_1080p_vp9_noaltref_fullsample.mpd",
+        "name": "WV: Secure Subsample UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       }
     ]
   },
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index 92dc08597f..b5db4c018d 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -36,13 +36,17 @@ public void onCreate() {
     userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
   }
 
-  DataSource.Factory buildDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
+  public DataSource.Factory buildDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
     return new DefaultDataSourceFactory(this, bandwidthMeter,
         buildHttpDataSourceFactory(bandwidthMeter));
   }
 
-  HttpDataSource.Factory buildHttpDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
+  public HttpDataSource.Factory buildHttpDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
     return new DefaultHttpDataSourceFactory(userAgent, bandwidthMeter);
   }
 
+  public boolean useExtensionRenderers() {
+    return BuildConfig.FLAVOR.equals("withExtensions");
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index d79de04657..edc268ddb9 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -26,27 +26,29 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
+import com.google.android.exoplayer2.metadata.id3.CommentFrame;
 import com.google.android.exoplayer2.metadata.id3.GeobFrame;
 import com.google.android.exoplayer2.metadata.id3.Id3Frame;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
-import com.google.android.exoplayer2.metadata.id3.TxxxFrame;
+import com.google.android.exoplayer2.metadata.id3.UrlLinkFrame;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.io.IOException;
 import java.text.NumberFormat;
-import java.util.List;
 import java.util.Locale;
 
 /**
@@ -54,8 +56,8 @@
  */
 /* package */ final class EventLogger implements ExoPlayer.EventListener,
     AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
-    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output<List<Id3Frame>> {
+    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener,
+    MetadataRenderer.Output {
 
   private static final String TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
@@ -67,11 +69,13 @@
     TIME_FORMAT.setGroupingUsed(false);
   }
 
+  private final MappingTrackSelector trackSelector;
   private final Timeline.Window window;
   private final Timeline.Period period;
   private final long startTimeMs;
 
-  public EventLogger() {
+  public EventLogger(MappingTrackSelector trackSelector) {
+    this.trackSelector = trackSelector;
     window = new Timeline.Window();
     period = new Timeline.Period();
     startTimeMs = SystemClock.elapsedRealtime();
@@ -126,49 +130,63 @@ public void onPlayerError(ExoPlaybackException e) {
     Log.e(TAG, "playerFailed [" + getSessionTimeString() + "]", e);
   }
 
-  // MappingTrackSelector.EventListener
-
   @Override
-  public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo> trackSelections) {
+  public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSelections) {
+    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+    if (mappedTrackInfo == null) {
+      Log.d(TAG, "Tracks []");
+      return;
+    }
     Log.d(TAG, "Tracks [");
     // Log tracks associated to renderers.
-    MappedTrackInfo info = trackSelections.info;
-    for (int rendererIndex = 0; rendererIndex < trackSelections.length; rendererIndex++) {
-      TrackGroupArray trackGroups = info.getTrackGroups(rendererIndex);
+    for (int rendererIndex = 0; rendererIndex < mappedTrackInfo.length; rendererIndex++) {
+      TrackGroupArray rendererTrackGroups = mappedTrackInfo.getTrackGroups(rendererIndex);
       TrackSelection trackSelection = trackSelections.get(rendererIndex);
-      if (trackGroups.length > 0) {
+      if (rendererTrackGroups.length > 0) {
         Log.d(TAG, "  Renderer:" + rendererIndex + " [");
-        for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
-          TrackGroup trackGroup = trackGroups.get(groupIndex);
-          String adaptiveSupport = getAdaptiveSupportString(
-              trackGroup.length, info.getAdaptiveSupport(rendererIndex, groupIndex, false));
+        for (int groupIndex = 0; groupIndex < rendererTrackGroups.length; groupIndex++) {
+          TrackGroup trackGroup = rendererTrackGroups.get(groupIndex);
+          String adaptiveSupport = getAdaptiveSupportString(trackGroup.length,
+              mappedTrackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false));
           Log.d(TAG, "    Group:" + groupIndex + ", adaptive_supported=" + adaptiveSupport + " [");
           for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
             String status = getTrackStatusString(trackSelection, trackGroup, trackIndex);
             String formatSupport = getFormatSupportString(
-                info.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
+                mappedTrackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
             Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-                + getFormatString(trackGroup.getFormat(trackIndex))
+                + Format.toLogString(trackGroup.getFormat(trackIndex))
                 + ", supported=" + formatSupport);
           }
           Log.d(TAG, "    ]");
         }
+        // Log metadata for at most one of the tracks selected for the renderer.
+        if (trackSelection != null) {
+          for (int selectionIndex = 0; selectionIndex < trackSelection.length(); selectionIndex++) {
+            Metadata metadata = trackSelection.getFormat(selectionIndex).metadata;
+            if (metadata != null) {
+              Log.d(TAG, "    Metadata [");
+              printMetadata(metadata, "      ");
+              Log.d(TAG, "    ]");
+              break;
+            }
+          }
+        }
         Log.d(TAG, "  ]");
       }
     }
     // Log tracks not associated with a renderer.
-    TrackGroupArray trackGroups = info.getUnassociatedTrackGroups();
-    if (trackGroups.length > 0) {
+    TrackGroupArray unassociatedTrackGroups = mappedTrackInfo.getUnassociatedTrackGroups();
+    if (unassociatedTrackGroups.length > 0) {
       Log.d(TAG, "  Renderer:None [");
-      for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
+      for (int groupIndex = 0; groupIndex < unassociatedTrackGroups.length; groupIndex++) {
         Log.d(TAG, "    Group:" + groupIndex + " [");
-        TrackGroup trackGroup = trackGroups.get(groupIndex);
+        TrackGroup trackGroup = unassociatedTrackGroups.get(groupIndex);
         for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
           String status = getTrackStatusString(false);
           String formatSupport = getFormatSupportString(
               RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
           Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-              + getFormatString(trackGroup.getFormat(trackIndex))
+              + Format.toLogString(trackGroup.getFormat(trackIndex))
               + ", supported=" + formatSupport);
         }
         Log.d(TAG, "    ]");
@@ -178,34 +196,13 @@ public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo>
     Log.d(TAG, "]");
   }
 
-  // MetadataRenderer.Output<List<Id3Frame>>
+  // MetadataRenderer.Output
 
   @Override
-  public void onMetadata(List<Id3Frame> id3Frames) {
-    for (Id3Frame id3Frame : id3Frames) {
-      if (id3Frame instanceof TxxxFrame) {
-        TxxxFrame txxxFrame = (TxxxFrame) id3Frame;
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s, value=%s", txxxFrame.id,
-            txxxFrame.description, txxxFrame.value));
-      } else if (id3Frame instanceof PrivFrame) {
-        PrivFrame privFrame = (PrivFrame) id3Frame;
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: owner=%s", privFrame.id, privFrame.owner));
-      } else if (id3Frame instanceof GeobFrame) {
-        GeobFrame geobFrame = (GeobFrame) id3Frame;
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, filename=%s, description=%s",
-            geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
-      } else if (id3Frame instanceof ApicFrame) {
-        ApicFrame apicFrame = (ApicFrame) id3Frame;
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: mimeType=%s, description=%s",
-            apicFrame.id, apicFrame.mimeType, apicFrame.description));
-      } else if (id3Frame instanceof TextInformationFrame) {
-        TextInformationFrame textInformationFrame = (TextInformationFrame) id3Frame;
-        Log.i(TAG, String.format("ID3 TimedMetadata %s: description=%s", textInformationFrame.id,
-            textInformationFrame.description));
-      } else {
-        Log.i(TAG, String.format("ID3 TimedMetadata %s", id3Frame.id));
-      }
-    }
+  public void onMetadata(Metadata metadata) {
+    Log.d(TAG, "onMetadata [");
+    printMetadata(metadata, "  ");
+    Log.d(TAG, "]");
   }
 
   // AudioRendererEventListener
@@ -228,7 +225,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -258,7 +255,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -283,13 +280,23 @@ public void onRenderedFirstFrame(Surface surface) {
     // Do nothing.
   }
 
-  // StreamingDrmSessionManager.EventListener
+  // DefaultDrmSessionManager.EventListener
 
   @Override
   public void onDrmSessionManagerError(Exception e) {
     printInternalError("drmSessionManagerError", e);
   }
 
+  @Override
+  public void onDrmKeysRestored() {
+    Log.d(TAG, "drmKeysRestored [" + getSessionTimeString() + "]");
+  }
+
+  @Override
+  public void onDrmKeysRemoved() {
+    Log.d(TAG, "drmKeysRemoved [" + getSessionTimeString() + "]");
+  }
+
   @Override
   public void onDrmKeysLoaded() {
     Log.d(TAG, "drmKeysLoaded [" + getSessionTimeString() + "]");
@@ -350,6 +357,42 @@ private void printInternalError(String type, Exception e) {
     Log.e(TAG, "internalError [" + getSessionTimeString() + ", " + type + "]", e);
   }
 
+  private void printMetadata(Metadata metadata, String prefix) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Metadata.Entry entry = metadata.get(i);
+      if (entry instanceof TextInformationFrame) {
+        TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: value=%s", textInformationFrame.id,
+            textInformationFrame.value));
+      } else if (entry instanceof UrlLinkFrame) {
+        UrlLinkFrame urlLinkFrame = (UrlLinkFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: url=%s", urlLinkFrame.id, urlLinkFrame.url));
+      } else if (entry instanceof PrivFrame) {
+        PrivFrame privFrame = (PrivFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: owner=%s", privFrame.id, privFrame.owner));
+      } else if (entry instanceof GeobFrame) {
+        GeobFrame geobFrame = (GeobFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: mimeType=%s, filename=%s, description=%s",
+            geobFrame.id, geobFrame.mimeType, geobFrame.filename, geobFrame.description));
+      } else if (entry instanceof ApicFrame) {
+        ApicFrame apicFrame = (ApicFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: mimeType=%s, description=%s",
+            apicFrame.id, apicFrame.mimeType, apicFrame.description));
+      } else if (entry instanceof CommentFrame) {
+        CommentFrame commentFrame = (CommentFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: language=%s, description=%s", commentFrame.id,
+            commentFrame.language, commentFrame.description));
+      } else if (entry instanceof Id3Frame) {
+        Id3Frame id3Frame = (Id3Frame) entry;
+        Log.d(TAG, prefix + String.format("%s", id3Frame.id));
+      } else if (entry instanceof EventMessage) {
+        EventMessage eventMessage = (EventMessage) entry;
+        Log.d(TAG, prefix + String.format("EMSG: scheme=%s, id=%d, value=%s",
+            eventMessage.schemeIdUri, eventMessage.id, eventMessage.value));
+      }
+    }
+  }
+
   private String getSessionTimeString() {
     return getTimeString(SystemClock.elapsedRealtime() - startTimeMs);
   }
@@ -404,33 +447,6 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
     }
   }
 
-  private static String getFormatString(Format format) {
-    if (format == null) {
-      return "null";
-    }
-    StringBuilder builder = new StringBuilder();
-    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
-    if (format.bitrate != Format.NO_VALUE) {
-      builder.append(", bitrate=").append(format.bitrate);
-    }
-    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
-      builder.append(", res=").append(format.width).append("x").append(format.height);
-    }
-    if (format.frameRate != Format.NO_VALUE) {
-      builder.append(", fps=").append(format.frameRate);
-    }
-    if (format.channelCount != Format.NO_VALUE) {
-      builder.append(", channels=").append(format.channelCount);
-    }
-    if (format.sampleRate != Format.NO_VALUE) {
-      builder.append(", sample_rate=").append(format.sampleRate);
-    }
-    if (format.language != null) {
-      builder.append(", language=").append(format.language);
-    }
-    return builder.toString();
-  }
-
   private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
       int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index e9aa46f85f..bbfadf34af 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -22,6 +22,7 @@
 import android.os.Bundle;
 import android.os.Handler;
 import android.text.TextUtils;
+import android.view.KeyEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.widget.Button;
@@ -35,15 +36,16 @@
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -55,11 +57,9 @@
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.ui.DebugTextViewHelper;
 import com.google.android.exoplayer2.ui.PlaybackControlView;
 import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
@@ -78,7 +78,7 @@
  * An activity that plays media using {@link SimpleExoPlayer}.
  */
 public class PlayerActivity extends Activity implements OnClickListener, ExoPlayer.EventListener,
-    TrackSelector.EventListener<MappedTrackInfo>, PlaybackControlView.VisibilityListener {
+    PlaybackControlView.VisibilityListener {
 
   public static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
   public static final String DRM_LICENSE_URL = "drm_license_url";
@@ -101,7 +101,6 @@
   }
 
   private Handler mainHandler;
-  private Timeline.Window window;
   private EventLogger eventLogger;
   private SimpleExoPlayerView simpleExoPlayerView;
   private LinearLayout debugRootView;
@@ -110,15 +109,14 @@
 
   private DataSource.Factory mediaDataSourceFactory;
   private SimpleExoPlayer player;
-  private MappingTrackSelector trackSelector;
+  private DefaultTrackSelector trackSelector;
   private TrackSelectionHelper trackSelectionHelper;
   private DebugTextViewHelper debugViewHelper;
   private boolean playerNeedsSource;
 
   private boolean shouldAutoPlay;
-  private boolean isTimelineStatic;
-  private int playerWindow;
-  private long playerPosition;
+  private int resumeWindow;
+  private long resumePosition;
 
   // Activity lifecycle
 
@@ -126,9 +124,9 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     shouldAutoPlay = true;
+    clearResumePosition();
     mediaDataSourceFactory = buildDataSourceFactory(true);
     mainHandler = new Handler();
-    window = new Timeline.Window();
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -149,7 +147,8 @@ public void onCreate(Bundle savedInstanceState) {
   @Override
   public void onNewIntent(Intent intent) {
     releasePlayer();
-    isTimelineStatic = false;
+    shouldAutoPlay = true;
+    clearResumePosition();
     setIntent(intent);
   }
 
@@ -196,6 +195,16 @@ public void onRequestPermissionsResult(int requestCode, String[] permissions,
     }
   }
 
+  // Activity input
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    // Show the controls on any key event.
+    simpleExoPlayerView.showController();
+    // If the event was not handled then see if the player view can handle it as a media key event.
+    return super.dispatchKeyEvent(event) || simpleExoPlayerView.dispatchMediaKeyEvent(event);
+  }
+
   // OnClickListener methods
 
   @Override
@@ -203,8 +212,11 @@ public void onClick(View view) {
     if (view == retryButton) {
       initializePlayer();
     } else if (view.getParent() == debugRootView) {
-      trackSelectionHelper.showSelectionDialog(this, ((Button) view).getText(),
-          trackSelector.getCurrentSelections().info, (int) view.getTag());
+      MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+      if (mappedTrackInfo != null) {
+        trackSelectionHelper.showSelectionDialog(this, ((Button) view).getText(),
+            trackSelector.getCurrentMappedTrackInfo(), (int) view.getTag());
+      }
     }
   }
 
@@ -249,28 +261,26 @@ private void initializePlayer() {
         }
       }
 
-      eventLogger = new EventLogger();
+      @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode =
+          ((DemoApplication) getApplication()).useExtensionRenderers()
+              ? (preferExtensionDecoders ? SimpleExoPlayer.EXTENSION_RENDERER_MODE_PREFER
+              : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
+              : SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF;
       TrackSelection.Factory videoTrackSelectionFactory =
           new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
-      trackSelector = new DefaultTrackSelector(mainHandler, videoTrackSelectionFactory);
-      trackSelector.addListener(this);
-      trackSelector.addListener(eventLogger);
+      trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
       trackSelectionHelper = new TrackSelectionHelper(trackSelector, videoTrackSelectionFactory);
       player = ExoPlayerFactory.newSimpleInstance(this, trackSelector, new DefaultLoadControl(),
-          drmSessionManager, preferExtensionDecoders);
+          drmSessionManager, extensionRendererMode);
       player.addListener(this);
+
+      eventLogger = new EventLogger(trackSelector);
       player.addListener(eventLogger);
       player.setAudioDebugListener(eventLogger);
       player.setVideoDebugListener(eventLogger);
-      player.setId3Output(eventLogger);
+      player.setMetadataOutput(eventLogger);
+
       simpleExoPlayerView.setPlayer(player);
-      if (isTimelineStatic) {
-        if (playerPosition == C.TIME_UNSET) {
-          player.seekToDefaultPosition(playerWindow);
-        } else {
-          player.seekTo(playerWindow, playerPosition);
-        }
-      }
       player.setPlayWhenReady(shouldAutoPlay);
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
@@ -307,7 +317,11 @@ private void initializePlayer() {
       }
       MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
           : new ConcatenatingMediaSource(mediaSources);
-      player.prepare(mediaSource, !isTimelineStatic, !isTimelineStatic);
+      boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
+      if (haveResumePosition) {
+        player.seekTo(resumeWindow, resumePosition);
+      }
+      player.prepare(mediaSource, !haveResumePosition, false);
       playerNeedsSource = false;
       updateButtonVisibilities();
     }
@@ -341,7 +355,7 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
     }
     HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
         buildHttpDataSourceFactory(false), keyRequestProperties);
-    return new StreamingDrmSessionManager<>(uuid,
+    return new DefaultDrmSessionManager<>(uuid,
         FrameworkMediaDrm.newInstance(uuid), drmCallback, null, mainHandler, eventLogger);
   }
 
@@ -350,12 +364,7 @@ private void releasePlayer() {
       debugViewHelper.stop();
       debugViewHelper = null;
       shouldAutoPlay = player.getPlayWhenReady();
-      playerWindow = player.getCurrentWindowIndex();
-      playerPosition = C.TIME_UNSET;
-      Timeline timeline = player.getCurrentTimeline();
-      if (timeline != null && timeline.getWindow(playerWindow, window).isSeekable) {
-        playerPosition = player.getCurrentPosition();
-      }
+      updateResumePosition();
       player.release();
       player = null;
       trackSelector = null;
@@ -364,6 +373,17 @@ private void releasePlayer() {
     }
   }
 
+  private void updateResumePosition() {
+    resumeWindow = player.getCurrentWindowIndex();
+    resumePosition = player.isCurrentWindowSeekable() ? Math.max(0, player.getCurrentPosition())
+        : C.TIME_UNSET;
+  }
+
+  private void clearResumePosition() {
+    resumeWindow = C.INDEX_UNSET;
+    resumePosition = C.TIME_UNSET;
+  }
+
   /**
    * Returns a new DataSource factory.
    *
@@ -405,13 +425,17 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onPositionDiscontinuity() {
-    // Do nothing.
+    if (playerNeedsSource) {
+      // This will only occur if the user has performed a seek whilst in the error state. Update the
+      // resume position so that if the user then retries, playback will resume from the position to
+      // which they seeked.
+      updateResumePosition();
+    }
   }
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
-    isTimelineStatic = timeline != null && timeline.getWindowCount() > 0
-        && !timeline.getWindow(timeline.getWindowCount() - 1, window).isDynamic;
+    // Do nothing.
   }
 
   @Override
@@ -443,21 +467,29 @@ public void onPlayerError(ExoPlaybackException e) {
       showToast(errorString);
     }
     playerNeedsSource = true;
-    updateButtonVisibilities();
-    showControls();
+    if (isBehindLiveWindow(e)) {
+      clearResumePosition();
+      initializePlayer();
+    } else {
+      updateResumePosition();
+      updateButtonVisibilities();
+      showControls();
+    }
   }
 
-  // MappingTrackSelector.EventListener implementation
-
   @Override
-  public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo> trackSelections) {
+  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
     updateButtonVisibilities();
-    MappedTrackInfo trackInfo = trackSelections.info;
-    if (trackInfo.hasOnlyUnplayableTracks(C.TRACK_TYPE_VIDEO)) {
-      showToast(R.string.error_unsupported_video);
-    }
-    if (trackInfo.hasOnlyUnplayableTracks(C.TRACK_TYPE_AUDIO)) {
-      showToast(R.string.error_unsupported_audio);
+    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+    if (mappedTrackInfo != null) {
+      if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_VIDEO)
+          == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+        showToast(R.string.error_unsupported_video);
+      }
+      if (mappedTrackInfo.getTrackTypeRendererSupport(C.TRACK_TYPE_AUDIO)
+          == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+        showToast(R.string.error_unsupported_audio);
+      }
     }
   }
 
@@ -473,14 +505,13 @@ private void updateButtonVisibilities() {
       return;
     }
 
-    TrackSelections<MappedTrackInfo> trackSelections = trackSelector.getCurrentSelections();
-    if (trackSelections == null) {
+    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+    if (mappedTrackInfo == null) {
       return;
     }
 
-    int rendererCount = trackSelections.length;
-    for (int i = 0; i < rendererCount; i++) {
-      TrackGroupArray trackGroups = trackSelections.info.getTrackGroups(i);
+    for (int i = 0; i < mappedTrackInfo.length; i++) {
+      TrackGroupArray trackGroups = mappedTrackInfo.getTrackGroups(i);
       if (trackGroups.length != 0) {
         Button button = new Button(this);
         int label;
@@ -517,4 +548,18 @@ private void showToast(String message) {
     Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
   }
 
+  private static boolean isBehindLiveWindow(ExoPlaybackException e) {
+    if (e.type != ExoPlaybackException.TYPE_SOURCE) {
+      return false;
+    }
+    Throwable cause = e.getSourceException();
+    while (cause != null) {
+      if (cause instanceof BehindLiveWindowException) {
+        return true;
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 95d42e0532..946181284f 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -18,6 +18,7 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.res.AssetManager;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
@@ -43,6 +44,7 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
 
@@ -63,9 +65,21 @@ public void onCreate(Bundle savedInstanceState) {
     if (dataUri != null) {
       uris = new String[] {dataUri};
     } else {
-      uris = new String[] {
-          "asset:///media.exolist.json",
-      };
+      ArrayList<String> uriList = new ArrayList<>();
+      AssetManager assetManager = getAssets();
+      try {
+        for (String asset : assetManager.list("")) {
+          if (asset.endsWith(".exolist.json")) {
+            uriList.add("asset:///" + asset);
+          }
+        }
+      } catch (IOException e) {
+        Toast.makeText(getApplicationContext(), R.string.sample_list_load_error, Toast.LENGTH_LONG)
+            .show();
+      }
+      uris = new String[uriList.size()];
+      uriList.toArray(uris);
+      Arrays.sort(uris);
     }
     SampleListLoader loaderTask = new SampleListLoader();
     loaderTask.execute(uris);
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index 8892c138d0..936cdf90f8 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -18,7 +18,9 @@
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
+import android.content.Context;
 import android.content.DialogInterface;
+import android.content.res.TypedArray;
 import android.text.TextUtils;
 import android.util.Pair;
 import android.view.LayoutInflater;
@@ -100,7 +102,7 @@ public void showSelectionDialog(Activity activity, CharSequence title, MappedTra
 
     AlertDialog.Builder builder = new AlertDialog.Builder(activity);
     builder.setTitle(title)
-        .setView(buildView(LayoutInflater.from(builder.getContext())))
+        .setView(buildView(builder.getContext()))
         .setPositiveButton(android.R.string.ok, this)
         .setNegativeButton(android.R.string.cancel, null)
         .create()
@@ -108,13 +110,20 @@ public void showSelectionDialog(Activity activity, CharSequence title, MappedTra
   }
 
   @SuppressLint("InflateParams")
-  private View buildView(LayoutInflater inflater) {
+  private View buildView(Context context) {
+    LayoutInflater inflater = LayoutInflater.from(context);
     View view = inflater.inflate(R.layout.track_selection_dialog, null);
     ViewGroup root = (ViewGroup) view.findViewById(R.id.root);
 
+    TypedArray attributeArray = context.getTheme().obtainStyledAttributes(
+        new int[] {android.R.attr.selectableItemBackground});
+    int selectableItemBackgroundResourceId = attributeArray.getResourceId(0, 0);
+    attributeArray.recycle();
+
     // View for disabling the renderer.
     disableView = (CheckedTextView) inflater.inflate(
         android.R.layout.simple_list_item_single_choice, root, false);
+    disableView.setBackgroundResource(selectableItemBackgroundResourceId);
     disableView.setText(R.string.selection_disabled);
     disableView.setFocusable(true);
     disableView.setOnClickListener(this);
@@ -123,6 +132,7 @@ private View buildView(LayoutInflater inflater) {
     // View for clearing the override to allow the selector to use its default selection logic.
     defaultView = (CheckedTextView) inflater.inflate(
         android.R.layout.simple_list_item_single_choice, root, false);
+    defaultView.setBackgroundResource(selectableItemBackgroundResourceId);
     defaultView.setText(R.string.selection_default);
     defaultView.setFocusable(true);
     defaultView.setOnClickListener(this);
@@ -146,6 +156,7 @@ private View buildView(LayoutInflater inflater) {
             : android.R.layout.simple_list_item_single_choice;
         CheckedTextView trackView = (CheckedTextView) inflater.inflate(
             trackViewLayoutId, root, false);
+        trackView.setBackgroundResource(selectableItemBackgroundResourceId);
         trackView.setText(buildTrackName(group.getFormat(trackIndex)));
         if (trackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex)
             == RendererCapabilities.FORMAT_HANDLED) {
@@ -169,6 +180,7 @@ private View buildView(LayoutInflater inflater) {
       // View for using random adaptation.
       enableRandomAdaptationView = (CheckedTextView) inflater.inflate(
           android.R.layout.simple_list_item_multiple_choice, root, false);
+      enableRandomAdaptationView.setBackgroundResource(selectableItemBackgroundResourceId);
       enableRandomAdaptationView.setText(R.string.enable_random_adaptation);
       enableRandomAdaptationView.setOnClickListener(this);
       root.addView(inflater.inflate(R.layout.list_divider, root, false));
diff --git a/demo/src/main/res/drawable-hdpi/ic_launcher.png b/demo/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 3e5716b8ad..0000000000
Binary files a/demo/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-mdpi/ic_launcher.png b/demo/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index a5d2a53b13..0000000000
Binary files a/demo/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_banner.png b/demo/src/main/res/drawable-xhdpi/ic_banner.png
new file mode 100644
index 0000000000..520d83cc3b
Binary files /dev/null and b/demo/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_launcher.png b/demo/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 1d00268635..0000000000
Binary files a/demo/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index ef2f312fd4..0000000000
Binary files a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100644
index 0acebb43c1..0000000000
Binary files a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/layout/player_activity.xml b/demo/src/main/res/layout/player_activity.xml
index 07ac5e2ba1..3f8cdaa7d6 100644
--- a/demo/src/main/res/layout/player_activity.xml
+++ b/demo/src/main/res/layout/player_activity.xml
@@ -16,13 +16,11 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/root"
-    android:focusable="true"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:keepScreenOn="true">
 
   <com.google.android.exoplayer2.ui.SimpleExoPlayerView android:id="@+id/player_view"
-      android:focusable="true"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
diff --git a/demo/src/main/res/mipmap-hdpi/ic_launcher.png b/demo/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..6e8b5499de
Binary files /dev/null and b/demo/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-mdpi/ic_launcher.png b/demo/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..26fe2f0782
Binary files /dev/null and b/demo/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..d3251491ce
Binary files /dev/null and b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..b5a12d35f3
Binary files /dev/null and b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..9c26192c32
Binary files /dev/null and b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/values/strings.xml b/demo/src/main/res/values/strings.xml
index c0e1488fe5..ac17ad4443 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demo/src/main/res/values/strings.xml
@@ -16,8 +16,7 @@
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-  <!-- The user visible name of the application. [CHAR LIMIT=20] -->
-  <string name="application_name">ExoPlayer2 Demo</string>
+  <string name="application_name">ExoPlayer</string>
 
   <string name="video">Video</string>
 
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
index be79ac7d3e..a570385a52 100644
--- a/extensions/cronet/README.md
+++ b/extensions/cronet/README.md
@@ -21,8 +21,9 @@ git clone https://github.com/google/ExoPlayer.git
 
 1. Find the latest Cronet release [here][] and navigate to its `Release/cronet`
    directory
-1. Download `cronet.jar`, `cronet_api.jar` and the `libs` directory
-1. Copy the two jar files into the `libs` directory of this extension
+1. Download `cronet_api.jar`, `cronet_impl_common_java.jar`,
+   `cronet_impl_native_java.jar` and the `libs` directory
+1. Copy the three jar files into the `libs` directory of this extension
 1. Copy the content of the downloaded `libs` directory into the `jniLibs`
    directory of this extension
 
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index ae2914dba3..a245133937 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -23,17 +23,6 @@ android {
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
-
     sourceSets.main {
         jniLibs.srcDirs = ['jniLibs']
     }
@@ -42,10 +31,11 @@ android {
 dependencies {
     compile project(':library')
     compile files('libs/cronet_api.jar')
-    compile files('libs/cronet.jar')
+    compile files('libs/cronet_impl_common_java.jar')
+    compile files('libs/cronet_impl_native_java.jar')
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'org.mockito:mockito-core:1.9.5'
     androidTestCompile project(':library')
-    androidTestCompile 'com.android.support.test:runner:0.4'
+    androidTestCompile 'com.android.support.test:runner:0.5'
 }
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index b0de0784de..31def44d36 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -22,7 +22,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
@@ -52,16 +51,16 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
+import org.chromium.net.impl.UrlResponseInfoImpl;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -88,20 +87,7 @@
   private Map<String, String> testResponseHeader;
   private UrlResponseInfo testUrlResponseInfo;
 
-  /**
-   * MockableCronetEngine is an abstract class for helping creating new Requests.
-   */
-  public abstract static class MockableCronetEngine extends CronetEngine {
-
-    @Override
-    public abstract UrlRequest createRequest(String url, UrlRequest.Callback callback,
-        Executor executor, int priority,
-        Collection<Object> connectionAnnotations,
-        boolean disableCache,
-        boolean disableConnectionMigration,
-        boolean allowDirectExecutor);
-  }
-
+  @Mock private UrlRequest.Builder mockUrlRequestBuilder;
   @Mock
   private UrlRequest mockUrlRequest;
   @Mock
@@ -113,9 +99,8 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
   @Mock
   private Executor mockExecutor;
   @Mock
-  private UrlRequestException mockUrlRequestException;
-  @Mock
-  private MockableCronetEngine mockCronetEngine;
+  private NetworkException mockNetworkException;
+  @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
 
@@ -135,15 +120,10 @@ public void setUp() throws Exception {
             true, // resetTimeoutOnRedirects
             mockClock));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
-    when(mockCronetEngine.createRequest(
-        anyString(),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class))).thenReturn(mockUrlRequest);
+    when(mockCronetEngine.newUrlRequestBuilder(
+            anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
+        .thenReturn(mockUrlRequestBuilder);
+    when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNSET, null);
@@ -159,7 +139,7 @@ public void setUp() throws Exception {
   private UrlResponseInfo createUrlResponseInfo(int statusCode) {
     ArrayList<Map.Entry<String, String>> responseHeaderList = new ArrayList<>();
     responseHeaderList.addAll(testResponseHeader.entrySet());
-    return new UrlResponseInfo(
+    return new UrlResponseInfoImpl(
         Collections.singletonList(TEST_URL),
         statusCode,
         null, // httpStatusText
@@ -184,15 +164,7 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
     dataSourceUnderTest.close();
     // Prepare a mock UrlRequest to be used in the second open() call.
     final UrlRequest mockUrlRequest2 = mock(UrlRequest.class);
-    when(mockCronetEngine.createRequest(
-        anyString(),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class))).thenReturn(mockUrlRequest2);
+    when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest2);
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -200,7 +172,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            mockUrlRequestException);
+            mockNetworkException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -215,15 +187,8 @@ public void testRequestStartCalled() throws HttpDataSourceException {
     mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
-    verify(mockCronetEngine).createRequest(
-        eq(TEST_URL),
-        any(UrlRequest.Callback.class),
-        any(Executor.class),
-        anyInt(),
-        eq(Collections.emptyList()),
-        any(Boolean.class),
-        any(Boolean.class),
-        any(Boolean.class));
+    verify(mockCronetEngine)
+        .newUrlRequestBuilder(eq(TEST_URL), any(UrlRequest.Callback.class), any(Executor.class));
     verify(mockUrlRequest).start();
   }
 
@@ -237,9 +202,9 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
 
     dataSourceUnderTest.open(testDataSpec);
     // The header value to add is current position to current position + length - 1.
-    verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
-    verify(mockUrlRequest).addHeader("firstHeader", "firstValue");
-    verify(mockUrlRequest).addHeader("secondHeader", "secondValue");
+    verify(mockUrlRequestBuilder).addHeader("Range", "bytes=1000-5999");
+    verify(mockUrlRequestBuilder).addHeader("firstHeader", "firstValue");
+    verify(mockUrlRequestBuilder).addHeader("secondHeader", "secondValue");
     verify(mockUrlRequest).start();
   }
 
@@ -280,8 +245,8 @@ public void testRequestOpenFail() {
   @Test
   public void testRequestOpenFailDueToDnsFailure() {
     mockResponseStartFailure();
-    when(mockUrlRequestException.getErrorCode()).thenReturn(
-        UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED);
+    when(mockNetworkException.getErrorCode()).thenReturn(
+        NetworkException.ERROR_HOSTNAME_NOT_RESOLVED);
 
     try {
       dataSourceUnderTest.open(testDataSpec);
@@ -763,7 +728,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).start();
@@ -799,7 +764,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 0190668a70..f6202c6e1e 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -40,9 +40,10 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.CronetException;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
 import org.chromium.net.UrlRequest.Status;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
 /**
@@ -400,20 +401,25 @@ public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
 
   @Override
   public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      UrlRequestException error) {
+      CronetException error) {
     if (request != currentUrlRequest) {
       return;
     }
-    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-        ? new UnknownHostException() : error;
+    if (error instanceof NetworkException
+        && ((NetworkException) error).getErrorCode()
+            == NetworkException.ERROR_HOSTNAME_NOT_RESOLVED) {
+      exception = new UnknownHostException();
+    } else {
+      exception = error;
+    }
     operation.open();
   }
 
   // Internal methods.
 
   private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
-    UrlRequest.Builder requestBuilder = new UrlRequest.Builder(dataSpec.uri.toString(), this,
-        executor, cronetEngine);
+    UrlRequest.Builder requestBuilder = cronetEngine.newUrlRequestBuilder(dataSpec.uri.toString(),
+        this, executor);
     // Set the headers.
     synchronized (requestProperties) {
       if (dataSpec.postBody != null && dataSpec.postBody.length != 0
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index 0f94dad158..3df901ce59 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Predicate;
@@ -25,7 +26,7 @@
 /**
  * A {@link Factory} that produces {@link CronetDataSource}.
  */
-public final class CronetDataSourceFactory implements Factory {
+public final class CronetDataSourceFactory extends BaseFactory {
 
   /**
    * The default connection timeout, in milliseconds.
@@ -67,7 +68,7 @@ public CronetDataSourceFactory(CronetEngine cronetEngine,
   }
 
   @Override
-  public CronetDataSource createDataSource() {
+  protected CronetDataSource createDataSourceInternal() {
     return new CronetDataSource(cronetEngine, executor, contentTypePredicate, transferListener,
         connectTimeoutMs, readTimeoutMs, resetTimeoutOnRedirects);
   }
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index f0ce07bdf7..0d669f826d 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -31,7 +31,7 @@ FFMPEG_EXT_PATH="${EXOPLAYER_ROOT}/extensions/ffmpeg/src/main"
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Fetch and build ffmpeg.
+* Fetch and build FFmpeg.
 
 For example, to fetch and build for armv7a:
 
@@ -63,6 +63,7 @@ git clone git://source.ffmpeg.org/ffmpeg ffmpeg && cd ffmpeg && \
     --enable-decoder=vorbis \
     --enable-decoder=opus \
     --enable-decoder=flac \
+    --enable-decoder=alac \
     && \
 make -j4 && \
 make install-libs
@@ -75,7 +76,7 @@ cd "${FFMPEG_EXT_PATH}"/jni && \
 ${NDK_PATH}/ndk-build APP_ABI=armeabi-v7a -j4
 ```
 
-TODO: Add instructions for other ABIs.
+Repeat these steps for any other architectures you need to support.
 
 * In your project, you can add a dependency on the extension by using a rule
   like this:
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index 579c663fe2..e0f6d900a0 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/ffmpeg/src/main/proguard.cfg b/extensions/ffmpeg/proguard-rules.txt
similarity index 100%
rename from extensions/ffmpeg/src/main/proguard.cfg
rename to extensions/ffmpeg/proguard-rules.txt
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index 838ed1c3e9..0aac601045 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -17,11 +17,12 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
@@ -53,15 +54,14 @@ public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener even
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
-   * @param streamType The type of audio stream for the {@link AudioTrack}.
    */
   public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities, int streamType) {
-    super(eventHandler, eventListener, audioCapabilities, streamType);
+      AudioCapabilities audioCapabilities) {
+    super(eventHandler, eventListener, audioCapabilities);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     if (!FfmpegLibrary.isAvailable()) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
@@ -71,7 +71,13 @@ public int supportsFormat(Format format) {
   }
 
   @Override
-  protected FfmpegDecoder createDecoder(Format format) throws FfmpegDecoderException {
+  public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+    return ADAPTIVE_NOT_SEAMLESS;
+  }
+
+  @Override
+  protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+      throws FfmpegDecoderException {
     decoder = new FfmpegDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
         format.sampleMimeType, format.initializationData);
     return decoder;
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 12f4bcf672..2af2101ee7 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 import java.util.List;
 
@@ -88,6 +89,13 @@ public FfmpegDecoderException decode(DecoderInputBuffer inputBuffer,
     if (!hasOutputFormat) {
       channelCount = ffmpegGetChannelCount(nativeContext);
       sampleRate = ffmpegGetSampleRate(nativeContext);
+      if (sampleRate == 0 && "alac".equals(codecName)) {
+        // ALAC decoder did not set the sample rate in earlier versions of FFMPEG.
+        // See https://trac.ffmpeg.org/ticket/6096
+        ParsableByteArray parsableExtraData = new ParsableByteArray(extraData);
+        parsableExtraData.setPosition(extraData.length - 4);
+        sampleRate = parsableExtraData.readUnsignedIntToInt();
+      }
       hasOutputFormat = true;
     }
     outputBuffer.data.position(0);
@@ -123,6 +131,7 @@ public int getSampleRate() {
   private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
+      case MimeTypes.AUDIO_ALAC:
       case MimeTypes.AUDIO_OPUS:
         return initializationData.get(0);
       case MimeTypes.AUDIO_VORBIS:
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
index 90b42c01bb..4992bcbb3e 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
@@ -92,6 +92,8 @@ public static boolean supportsFormat(String mimeType) {
         return "amrwb";
       case MimeTypes.AUDIO_FLAC:
         return "flac";
+      case MimeTypes.AUDIO_ALAC:
+        return "alac";
       default:
         return null;
     }
diff --git a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
index 0d083a8bd4..fa615f2ec1 100644
--- a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
+++ b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
@@ -267,7 +267,7 @@ int decodePacket(AVCodecContext *context, AVPacket *packet,
                                               sampleFormat, 1);
     AVAudioResampleContext *resampleContext;
     if (context->opaque) {
-      resampleContext = (AVAudioResampleContext *)context->opaque;
+      resampleContext = (AVAudioResampleContext *) context->opaque;
     } else {
       resampleContext = avresample_alloc_context();
       av_opt_set_int(resampleContext, "in_channel_layout",  channelLayout, 0);
@@ -326,7 +326,7 @@ void releaseContext(AVCodecContext *context) {
     return;
   }
   AVAudioResampleContext *resampleContext;
-  if (resampleContext = (AVAudioResampleContext *)context->opaque) {
+  if ((resampleContext = (AVAudioResampleContext *) context->opaque)) {
     avresample_free(&resampleContext);
     context->opaque = NULL;
   }
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index a40a1adead..7f1a790dad 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/proguard-rules.txt
similarity index 100%
rename from extensions/flac/src/main/proguard.cfg
rename to extensions/flac/proguard-rules.txt
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index 29a22f380a..990c470a93 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -17,7 +17,6 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -27,7 +26,9 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -72,7 +73,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibflacAudioRenderer audioRenderer = new LibflacAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
@@ -91,6 +92,11 @@ public void onLoadingChanged(boolean isLoading) {
       // Do nothing.
     }
 
+    @Override
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      // Do nothing.
+    }
+
     @Override
     public void onPositionDiscontinuity() {
       // Do nothing.
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index fd1bb16a4b..42c5908619 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -95,7 +95,7 @@ public int read(final ExtractorInput input, PositionHolder seekPosition)
         if (streamInfo == null) {
           throw new IOException("Metadata decoding failed");
         }
-      } catch (IOException e){
+      } catch (IOException e) {
         decoderJni.reset(0);
         input.setRetryPosition(0, e);
         throw e; // never executes
@@ -137,7 +137,7 @@ public long getDurationUs() {
     int size;
     try {
       size = decoderJni.decodeSample(outputByteBuffer);
-    } catch (IOException e){
+    } catch (IOException e) {
       if (lastDecodePosition >= 0) {
         decoderJni.reset(lastDecodePosition);
         input.setRetryPosition(lastDecodePosition, e);
@@ -155,7 +155,7 @@ public long getDurationUs() {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     if (position == 0) {
       metadataParsed = false;
     }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index 931b5ff3d9..eb7206c9cf 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -19,8 +19,8 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
@@ -49,21 +49,21 @@ public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
-   * @param streamType The type of audio stream for the {@link AudioTrack}.
    */
   public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities, int streamType) {
-    super(eventHandler, eventListener, audioCapabilities, streamType);
+      AudioCapabilities audioCapabilities) {
+    super(eventHandler, eventListener, audioCapabilities);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return FlacLibrary.isAvailable() && MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
 
   @Override
-  protected FlacDecoder createDecoder(Format format) throws FlacDecoderException {
+  protected FlacDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+      throws FlacDecoderException {
     return new FlacDecoder(NUM_BUFFERS, NUM_BUFFERS, format.initializationData);
   }
 
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index c7555e9ced..bbf69c60e4 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -22,22 +22,11 @@ android {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
 }
 
 dependencies {
     compile project(':library')
-    compile('com.squareup.okhttp3:okhttp:+') {
+    compile('com.squareup.okhttp3:okhttp:3.4.1') {
         exclude group: 'org.json'
     }
 }
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 2b6eaa736d..90a4728933 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -65,7 +65,8 @@
   private long bytesRead;
 
   /**
-   * @param callFactory An {@link Call.Factory} for use by the source.
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
@@ -76,7 +77,8 @@ public OkHttpDataSource(Call.Factory callFactory, String userAgent,
   }
 
   /**
-   * @param callFactory An {@link Call.Factory} for use by the source.
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a {@link InvalidContentTypeException} is thrown from
@@ -89,14 +91,14 @@ public OkHttpDataSource(Call.Factory callFactory, String userAgent,
   }
 
   /**
-   * @param callFactory An {@link Call.Factory} for use by the source.
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a {@link InvalidContentTypeException} is thrown from
    *     {@link #open(DataSpec)}.
    * @param listener An optional listener.
-   * @param cacheControl An optional {@link CacheControl} which sets all requests' Cache-Control
-   *     header. For example, you could force the network response for all requests.
+   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
    */
   public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
@@ -259,7 +261,7 @@ protected final long bytesRemaining() {
   private Request makeRequest(DataSpec dataSpec) {
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
     Request.Builder builder = new Request.Builder().url(url);
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index a4dd10a8d3..8cbe295fa4 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.okhttp;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import okhttp3.CacheControl;
@@ -24,29 +25,42 @@
 /**
  * A {@link Factory} that produces {@link OkHttpDataSource}.
  */
-public final class OkHttpDataSourceFactory implements Factory {
+public final class OkHttpDataSourceFactory extends BaseFactory {
 
   private final Call.Factory callFactory;
   private final String userAgent;
-  private final TransferListener<? super DataSource> transferListener;
+  private final TransferListener<? super DataSource> listener;
   private final CacheControl cacheControl;
 
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the sources created by the factory.
+   * @param userAgent The User-Agent string that should be used.
+   * @param listener An optional listener.
+   */
   public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
-      TransferListener<? super DataSource> transferListener) {
-    this(callFactory, userAgent, transferListener, null);
+      TransferListener<? super DataSource> listener) {
+    this(callFactory, userAgent, listener, null);
   }
 
+  /**
+   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+   *     by the sources created by the factory.
+   * @param userAgent The User-Agent string that should be used.
+   * @param listener An optional listener.
+   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
+   */
   public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
-      TransferListener<? super DataSource> transferListener, CacheControl cacheControl) {
+      TransferListener<? super DataSource> listener, CacheControl cacheControl) {
     this.callFactory = callFactory;
     this.userAgent = userAgent;
-    this.transferListener = transferListener;
+    this.listener = listener;
     this.cacheControl = cacheControl;
   }
 
   @Override
-  public OkHttpDataSource createDataSource() {
-    return new OkHttpDataSource(callFactory, userAgent, null, transferListener, cacheControl);
+  protected OkHttpDataSource createDataSourceInternal() {
+    return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
   }
 
 }
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 3bc06ddaf4..d354654c14 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/opus/src/main/proguard.cfg b/extensions/opus/proguard-rules.txt
similarity index 100%
rename from extensions/opus/src/main/proguard.cfg
rename to extensions/opus/proguard-rules.txt
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index 4f723698a4..3e07186995 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -17,7 +17,6 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -27,7 +26,9 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -72,7 +73,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibopusAudioRenderer audioRenderer = new LibopusAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
@@ -91,6 +92,11 @@ public void onLoadingChanged(boolean isLoading) {
       // Do nothing.
     }
 
+    @Override
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      // Do nothing.
+    }
+
     @Override
     public void onPositionDiscontinuity() {
       // Do nothing.
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index 3393562104..1850e68229 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -19,8 +19,9 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
@@ -50,23 +51,37 @@ public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
-   * @param streamType The type of audio stream for the {@link AudioTrack}.
    */
   public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities, int streamType) {
-    super(eventHandler, eventListener, audioCapabilities, streamType);
+      AudioCapabilities audioCapabilities) {
+    super(eventHandler, eventListener, audioCapabilities);
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
+   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   */
+  public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+      AudioCapabilities audioCapabilities, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys) {
+    super(eventHandler, eventListener, audioCapabilities, drmSessionManager,
+        playClearSamplesWithoutKeys);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return OpusLibrary.isAvailable() && MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
 
   @Override
-  protected OpusDecoder createDecoder(Format format) throws OpusDecoderException {
+  protected OpusDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+      throws OpusDecoderException {
     return new OpusDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
-        format.initializationData);
+        format.initializationData, mediaCrypto);
   }
 
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
index 73fb4072e8..6d0deb44ae 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
@@ -16,9 +16,12 @@
 package com.google.android.exoplayer2.ext.opus;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.decoder.CryptoInfo;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
+import com.google.android.exoplayer2.drm.DecryptionException;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.List;
@@ -36,6 +39,12 @@
    */
   private static final int SAMPLE_RATE = 48000;
 
+  private static final int NO_ERROR = 0;
+  private static final int DECODE_ERROR = -1;
+  private static final int DRM_ERROR = -2;
+
+  private final ExoMediaCrypto exoMediaCrypto;
+
   private final int channelCount;
   private final int headerSkipSamples;
   private final int headerSeekPreRollSamples;
@@ -52,14 +61,20 @@
    * @param initializationData Codec-specific initialization data. The first element must contain an
    *     opus header. Optionally, the list may contain two additional buffers, which must contain
    *     the encoder delay and seek pre roll values in nanoseconds, encoded as longs.
+   * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted
+   *     content. Maybe null and can be ignored if decoder does not handle encrypted content.
    * @throws OpusDecoderException Thrown if an exception occurs when initializing the decoder.
    */
   public OpusDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
-      List<byte[]> initializationData) throws OpusDecoderException {
+      List<byte[]> initializationData, ExoMediaCrypto exoMediaCrypto) throws OpusDecoderException {
     super(new DecoderInputBuffer[numInputBuffers], new SimpleOutputBuffer[numOutputBuffers]);
     if (!OpusLibrary.isAvailable()) {
       throw new OpusDecoderException("Failed to load decoder native libraries.");
     }
+    this.exoMediaCrypto = exoMediaCrypto;
+    if (exoMediaCrypto != null && !OpusLibrary.opusIsSecureDecodeSupported()) {
+      throw new OpusDecoderException("Opus decoder does not support secure decode.");
+    }
     byte[] headerBytes = initializationData.get(0);
     if (headerBytes.length < 19) {
       throw new OpusDecoderException("Header size is too small.");
@@ -139,11 +154,25 @@ public OpusDecoderException decode(DecoderInputBuffer inputBuffer,
       skipSamples = (inputBuffer.timeUs == 0) ? headerSkipSamples : headerSeekPreRollSamples;
     }
     ByteBuffer inputData = inputBuffer.data;
-    int result = opusDecode(nativeDecoderContext, inputBuffer.timeUs, inputData, inputData.limit(),
-        outputBuffer, SAMPLE_RATE);
+    CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
+    int result = inputBuffer.isEncrypted()
+        ? opusSecureDecode(nativeDecoderContext, inputBuffer.timeUs, inputData, inputData.limit(),
+            outputBuffer, SAMPLE_RATE, exoMediaCrypto, cryptoInfo.mode,
+            cryptoInfo.key, cryptoInfo.iv, cryptoInfo.numSubSamples,
+            cryptoInfo.numBytesOfClearData, cryptoInfo.numBytesOfEncryptedData)
+        : opusDecode(nativeDecoderContext, inputBuffer.timeUs, inputData, inputData.limit(),
+            outputBuffer, SAMPLE_RATE);
     if (result < 0) {
-      return new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
+      if (result == DRM_ERROR) {
+        String message = "Drm error: " + opusGetErrorMessage(nativeDecoderContext);
+        DecryptionException cause = new DecryptionException(
+            opusGetErrorCode(nativeDecoderContext), message);
+        return new OpusDecoderException(message, cause);
+      } else {
+        return new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
+      }
     }
+
     ByteBuffer outputData = outputBuffer.data;
     outputData.position(0);
     outputData.limit(result);
@@ -182,8 +211,13 @@ private native long opusInit(int sampleRate, int channelCount, int numStreams, i
       int gain, byte[] streamMap);
   private native int opusDecode(long decoder, long timeUs, ByteBuffer inputBuffer, int inputSize,
       SimpleOutputBuffer outputBuffer, int sampleRate);
+  private native int opusSecureDecode(long decoder, long timeUs, ByteBuffer inputBuffer,
+      int inputSize, SimpleOutputBuffer outputBuffer, int sampleRate,
+      ExoMediaCrypto wvCrypto, int inputMode, byte[] key, byte[] iv,
+      int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData);
   private native void opusClose(long decoder);
   private native void opusReset(long decoder);
-  private native String opusGetErrorMessage(int errorCode);
+  private native int opusGetErrorCode(long decoder);
+  private native String opusGetErrorMessage(long decoder);
 
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoderException.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoderException.java
index 338f3ea94e..6645086838 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoderException.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoderException.java
@@ -26,4 +26,8 @@
     super(message);
   }
 
+  /* package */ OpusDecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
index a79ef6df3a..41a28b9fd7 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
@@ -50,5 +50,5 @@ public static String getVersion() {
   }
 
   public static native String opusGetVersion();
-
+  public static native boolean opusIsSecureDecodeSupported();
 }
diff --git a/extensions/opus/src/main/jni/opus_jni.cc b/extensions/opus/src/main/jni/opus_jni.cc
index 0920d9e499..48c1bd5e6d 100644
--- a/extensions/opus/src/main/jni/opus_jni.cc
+++ b/extensions/opus/src/main/jni/opus_jni.cc
@@ -60,11 +60,13 @@ jint JNI_OnLoad(JavaVM* vm, void* reserved) {
 
 static const int kBytesPerSample = 2;  // opus fixed point uses 16 bit samples.
 static int channelCount;
+static int errorCode;
 
 DECODER_FUNC(jlong, opusInit, jint sampleRate, jint channelCount,
      jint numStreams, jint numCoupled, jint gain, jbyteArray jStreamMap) {
   int status = OPUS_INVALID_STATE;
   ::channelCount = channelCount;
+  errorCode = 0;
   jbyte* streamMapBytes = env->GetByteArrayElements(jStreamMap, 0);
   uint8_t* streamMap = reinterpret_cast<uint8_t*>(streamMapBytes);
   OpusMSDecoder* decoder = opus_multistream_decoder_create(
@@ -109,10 +111,24 @@ DECODER_FUNC(jint, opusDecode, jlong jDecoder, jlong jTimeUs,
       env->GetDirectBufferAddress(jOutputBufferData));
   int sampleCount = opus_multistream_decode(decoder, inputBuffer, inputSize,
       outputBufferData, outputSize, 0);
+  // record error code
+  errorCode = (sampleCount < 0) ? sampleCount : 0;
   return (sampleCount < 0) ? sampleCount
       : sampleCount * kBytesPerSample * channelCount;
 }
 
+DECODER_FUNC(jint, opusSecureDecode, jlong jDecoder, jlong jTimeUs,
+     jobject jInputBuffer, jint inputSize, jobject jOutputBuffer,
+     jint sampleRate, jobject mediaCrypto, jint inputMode, jbyteArray key,
+     jbyteArray javaIv, jint inputNumSubSamples, jintArray numBytesOfClearData,
+     jintArray numBytesOfEncryptedData) {
+  // Doesn't support
+  // Java client should have checked vpxSupportSecureDecode
+  // and avoid calling this
+  // return -2 (DRM Error)
+  return -2;
+}
+
 DECODER_FUNC(void, opusClose, jlong jDecoder) {
   OpusMSDecoder* decoder = reinterpret_cast<OpusMSDecoder*>(jDecoder);
   opus_multistream_decoder_destroy(decoder);
@@ -123,10 +139,19 @@ DECODER_FUNC(void, opusReset, jlong jDecoder) {
   opus_multistream_decoder_ctl(decoder, OPUS_RESET_STATE);
 }
 
-DECODER_FUNC(jstring, opusGetErrorMessage, jint errorCode) {
+DECODER_FUNC(jstring, opusGetErrorMessage, jlong jContext) {
   return env->NewStringUTF(opus_strerror(errorCode));
 }
 
+DECODER_FUNC(jint, opusGetErrorCode, jlong jContext) {
+  return errorCode;
+}
+
+LIBRARY_FUNC(jstring, opusIsSecureDecodeSupported) {
+  // Doesn't support
+  return 0;
+}
+
 LIBRARY_FUNC(jstring, opusGetVersion) {
   return env->NewStringUTF(opus_get_version_string());
 }
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 3bc06ddaf4..d354654c14 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/vp9/src/main/proguard.cfg b/extensions/vp9/proguard-rules.txt
similarity index 100%
rename from extensions/vp9/src/main/proguard.cfg
rename to extensions/vp9/proguard-rules.txt
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index c5f61cf231..b1ddf2368c 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -17,7 +17,6 @@
 
 import android.content.Context;
 import android.net.Uri;
-import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -27,7 +26,9 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
 /**
@@ -88,7 +89,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibvpxVideoRenderer videoRenderer = new LibvpxVideoRenderer(true, 0);
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {videoRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
@@ -110,6 +111,11 @@ public void onLoadingChanged(boolean isLoading) {
       // Do nothing.
     }
 
+    @Override
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      // Do nothing.
+    }
+
     @Override
     public void onPositionDiscontinuity() {
       // Do nothing.
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index cfdd962197..e4cc2ae3ce 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -18,6 +18,7 @@
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.os.Handler;
+import android.os.Looper;
 import android.os.SystemClock;
 import android.view.Surface;
 import com.google.android.exoplayer2.BaseRenderer;
@@ -28,8 +29,13 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
+import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
 
@@ -56,8 +62,10 @@
   private final boolean scaleToFit;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
+  private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
   private final FormatHolder formatHolder;
+  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
 
   private DecoderCounters decoderCounters;
   private Format format;
@@ -65,6 +73,8 @@
   private DecoderInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
   private VpxOutputBuffer nextOutputBuffer;
+  private DrmSession<ExoMediaCrypto> drmSession;
+  private DrmSession<ExoMediaCrypto> pendingDrmSession;
 
   private Bitmap bitmap;
   private boolean renderedFirstFrame;
@@ -72,11 +82,12 @@
   private Surface surface;
   private VpxOutputBufferRenderer outputBufferRenderer;
   private int outputMode;
+  private boolean waitingForKeys;
 
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
-  private int previousWidth;
-  private int previousHeight;
+  private int lastReportedWidth;
+  private int lastReportedHeight;
 
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrames;
@@ -104,13 +115,39 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs) {
   public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
       Handler eventHandler, VideoRendererEventListener eventListener,
       int maxDroppedFramesToNotify) {
+    this(scaleToFit, allowedJoiningTimeMs, eventHandler, eventListener, maxDroppedFramesToNotify,
+        null, false);
+  }
+
+  /**
+   * @param scaleToFit Whether video frames should be scaled to fit when rendering.
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   */
+  public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
+      Handler eventHandler, VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys) {
     super(C.TRACK_TYPE_VIDEO);
     this.scaleToFit = scaleToFit;
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
+    this.drmSessionManager = drmSessionManager;
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     joiningDeadlineMs = -1;
-    previousWidth = -1;
-    previousHeight = -1;
+    clearLastReportedVideoSize();
     formatHolder = new FormatHolder();
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     outputMode = VpxDecoder.OUTPUT_MODE_NONE;
@@ -135,12 +172,27 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
 
     if (isRendererAvailable()) {
+      drmSession = pendingDrmSession;
+      ExoMediaCrypto mediaCrypto = null;
+      if (drmSession != null) {
+        int drmSessionState = drmSession.getState();
+        if (drmSessionState == DrmSession.STATE_ERROR) {
+          throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+        } else if (drmSessionState == DrmSession.STATE_OPENED
+            || drmSessionState == DrmSession.STATE_OPENED_WITH_KEYS) {
+          mediaCrypto = drmSession.getMediaCrypto();
+        } else {
+          // The drm session isn't open yet.
+          return;
+        }
+      }
       try {
         if (decoder == null) {
           // If we don't have a decoder yet, we need to instantiate one.
           long codecInitializingTimestamp = SystemClock.elapsedRealtime();
           TraceUtil.beginSection("createVpxDecoder");
-          decoder = new VpxDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE);
+          decoder = new VpxDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
+              mediaCrypto);
           decoder.setOutputMode(outputMode);
           TraceUtil.endSection();
           long codecInitializedTimestamp = SystemClock.elapsedRealtime();
@@ -258,7 +310,7 @@ private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
     surface.unlockCanvasAndPost(canvas);
   }
 
-  private boolean feedInputBuffer() throws VpxDecoderException {
+  private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackException {
     if (inputStreamEnded) {
       return false;
     }
@@ -270,7 +322,14 @@ private boolean feedInputBuffer() throws VpxDecoderException {
       }
     }
 
-    int result = readSource(formatHolder, inputBuffer);
+    int result;
+    if (waitingForKeys) {
+      // We've already read an encrypted sample into buffer, and are waiting for keys.
+      result = C.RESULT_BUFFER_READ;
+    } else {
+      result = readSource(formatHolder, inputBuffer);
+    }
+
     if (result == C.RESULT_NOTHING_READ) {
       return false;
     }
@@ -284,6 +343,11 @@ private boolean feedInputBuffer() throws VpxDecoderException {
       inputBuffer = null;
       return false;
     }
+    boolean bufferEncrypted = inputBuffer.isEncrypted();
+    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
+    if (waitingForKeys) {
+      return false;
+    }
     inputBuffer.flip();
     decoder.queueInputBuffer(inputBuffer);
     decoderCounters.inputBufferCount++;
@@ -291,8 +355,21 @@ private boolean feedInputBuffer() throws VpxDecoderException {
     return true;
   }
 
+  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
+    if (drmSession == null) {
+      return false;
+    }
+    int drmSessionState = drmSession.getState();
+    if (drmSessionState == DrmSession.STATE_ERROR) {
+      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+    }
+    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS
+        && (bufferEncrypted || !playClearSamplesWithoutKeys);
+  }
+
   private void flushDecoder() {
     inputBuffer = null;
+    waitingForKeys = false;
     if (outputBuffer != null) {
       outputBuffer.release();
       outputBuffer = null;
@@ -311,6 +388,9 @@ public boolean isEnded() {
 
   @Override
   public boolean isReady() {
+    if (waitingForKeys) {
+      return false;
+    }
     if (format != null && (isSourceReady() || outputBuffer != null)
         && (renderedFirstFrame || !isRendererAvailable())) {
       // Ready. If we were joining then we've now joined, so clear the joining deadline.
@@ -365,11 +445,27 @@ protected void onDisabled() {
     inputBuffer = null;
     outputBuffer = null;
     format = null;
+    waitingForKeys = false;
+    clearLastReportedVideoSize();
     try {
       releaseDecoder();
     } finally {
-      decoderCounters.ensureUpdated();
-      eventDispatcher.disabled(decoderCounters);
+      try {
+        if (drmSession != null) {
+          drmSessionManager.releaseSession(drmSession);
+        }
+      } finally {
+        try {
+          if (pendingDrmSession != null && pendingDrmSession != drmSession) {
+            drmSessionManager.releaseSession(pendingDrmSession);
+          }
+        } finally {
+          drmSession = null;
+          pendingDrmSession = null;
+          decoderCounters.ensureUpdated();
+          eventDispatcher.disabled(decoderCounters);
+        }
+      }
     }
   }
 
@@ -378,10 +474,18 @@ private void releaseDecoder() {
       decoder.release();
       decoder = null;
       decoderCounters.decoderReleaseCount++;
+      waitingForKeys = false;
+      if (drmSession != null && pendingDrmSession != drmSession) {
+        try {
+          drmSessionManager.releaseSession(drmSession);
+        } finally {
+          drmSession = null;
+        }
+      }
     }
   }
 
-  private boolean readFormat() {
+  private boolean readFormat() throws ExoPlaybackException {
     int result = readSource(formatHolder, null);
     if (result == C.RESULT_FORMAT_READ) {
       onInputFormatChanged(formatHolder.format);
@@ -390,42 +494,56 @@ private boolean readFormat() {
     return false;
   }
 
-  private void onInputFormatChanged(Format newFormat) {
+  private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+    Format oldFormat = format;
     format = newFormat;
+
+    boolean drmInitDataChanged = !Util.areEqual(format.drmInitData, oldFormat == null ? null
+        : oldFormat.drmInitData);
+    if (drmInitDataChanged) {
+      if (format.drmInitData != null) {
+        if (drmSessionManager == null) {
+          throw ExoPlaybackException.createForRenderer(
+              new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
+        }
+        pendingDrmSession = drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
+        if (pendingDrmSession == drmSession) {
+          drmSessionManager.releaseSession(pendingDrmSession);
+        }
+      } else {
+        pendingDrmSession = null;
+      }
+    }
+
     eventDispatcher.inputFormatChanged(format);
   }
 
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
-      setSurface((Surface) message);
+      setOutput((Surface) message, null);
     } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
-      setOutputBufferRenderer((VpxOutputBufferRenderer) message);
+      setOutput(null, (VpxOutputBufferRenderer) message);
     } else {
       super.handleMessage(messageType, message);
     }
   }
 
-  private void setSurface(Surface surface) {
-    if (this.surface == surface) {
-      return;
-    }
+  private void setOutput(Surface surface, VpxOutputBufferRenderer outputBufferRenderer) {
+    // At most one output may be non-null. Both may be null if the output is being cleared.
+    Assertions.checkState(surface == null || outputBufferRenderer == null);
+    // Clear state so that we always call the event listener with the video size and when a frame
+    // is rendered, even if the output hasn't changed.
     renderedFirstFrame = false;
-    this.surface = surface;
-    outputBufferRenderer = null;
-    outputMode = (surface != null) ? VpxDecoder.OUTPUT_MODE_RGB : VpxDecoder.OUTPUT_MODE_NONE;
-    updateDecoder();
-  }
-
-  private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRenderer) {
-    if (this.outputBufferRenderer == outputBufferRenderer) {
-      return;
+    clearLastReportedVideoSize();
+    // We only need to update the decoder if the output has changed.
+    if (this.surface != surface || this.outputBufferRenderer != outputBufferRenderer) {
+      this.surface = surface;
+      this.outputBufferRenderer = outputBufferRenderer;
+      outputMode = outputBufferRenderer != null ? VpxDecoder.OUTPUT_MODE_YUV
+          : surface != null ? VpxDecoder.OUTPUT_MODE_RGB : VpxDecoder.OUTPUT_MODE_NONE;
+      updateDecoder();
     }
-    this.outputBufferRenderer = outputBufferRenderer;
-    surface = null;
-    outputMode = (outputBufferRenderer != null) ? VpxDecoder.OUTPUT_MODE_YUV
-        : VpxDecoder.OUTPUT_MODE_NONE;
-    updateDecoder();
   }
 
   private void updateDecoder() {
@@ -442,10 +560,15 @@ private boolean isRendererAvailable() {
     return surface != null || outputBufferRenderer != null;
   }
 
-  private void maybeNotifyVideoSizeChanged(final int width, final int height) {
-    if (previousWidth != width || previousHeight != height) {
-      previousWidth = width;
-      previousHeight = height;
+  private void clearLastReportedVideoSize() {
+    lastReportedWidth = Format.NO_VALUE;
+    lastReportedHeight = Format.NO_VALUE;
+  }
+
+  private void maybeNotifyVideoSizeChanged(int width, int height) {
+    if (lastReportedWidth != width || lastReportedHeight != height) {
+      lastReportedWidth = width;
+      lastReportedHeight = height;
       eventDispatcher.videoSizeChanged(width, height, 0, 1);
     }
   }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 5407e94f42..0d7547d125 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -16,8 +16,11 @@
 package com.google.android.exoplayer2.ext.vp9;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.decoder.CryptoInfo;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.drm.DecryptionException;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import java.nio.ByteBuffer;
 
 /**
@@ -30,6 +33,11 @@
   public static final int OUTPUT_MODE_YUV = 0;
   public static final int OUTPUT_MODE_RGB = 1;
 
+  private static final int NO_ERROR = 0;
+  private static final int DECODE_ERROR = 1;
+  private static final int DRM_ERROR = 2;
+
+  private final ExoMediaCrypto exoMediaCrypto;
   private final long vpxDecContext;
 
   private volatile int outputMode;
@@ -40,14 +48,20 @@
    * @param numInputBuffers The number of input buffers.
    * @param numOutputBuffers The number of output buffers.
    * @param initialInputBufferSize The initial size of each input buffer.
+   * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted
+   *     content. Maybe null and can be ignored if decoder does not handle encrypted content.
    * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize)
-      throws VpxDecoderException {
+  public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
+      ExoMediaCrypto exoMediaCrypto) throws VpxDecoderException {
     super(new DecoderInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     if (!VpxLibrary.isAvailable()) {
       throw new VpxDecoderException("Failed to load decoder native libraries.");
     }
+    this.exoMediaCrypto = exoMediaCrypto;
+    if (exoMediaCrypto != null && !VpxLibrary.vpxIsSecureDecodeSupported()) {
+      throw new VpxDecoderException("Vpx decoder does not support secure decode.");
+    }
     vpxDecContext = vpxInit();
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
@@ -90,12 +104,29 @@ protected VpxDecoderException decode(DecoderInputBuffer inputBuffer, VpxOutputBu
       boolean reset) {
     ByteBuffer inputData = inputBuffer.data;
     int inputSize = inputData.limit();
-    if (vpxDecode(vpxDecContext, inputData, inputSize) != 0) {
-      return new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
+    CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
+    final long result = inputBuffer.isEncrypted()
+        ? vpxSecureDecode(vpxDecContext, inputData, inputSize, exoMediaCrypto,
+        cryptoInfo.mode, cryptoInfo.key, cryptoInfo.iv, cryptoInfo.numSubSamples,
+        cryptoInfo.numBytesOfClearData, cryptoInfo.numBytesOfEncryptedData)
+        : vpxDecode(vpxDecContext, inputData, inputSize);
+    if (result != NO_ERROR) {
+      if (result == DRM_ERROR) {
+        String message = "Drm error: " + vpxGetErrorMessage(vpxDecContext);
+        DecryptionException cause = new DecryptionException(
+            vpxGetErrorCode(vpxDecContext), message);
+        return new VpxDecoderException(message, cause);
+      } else {
+        return new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
+      }
     }
+
     outputBuffer.init(inputBuffer.timeUs, outputMode);
-    if (vpxGetFrame(vpxDecContext, outputBuffer) != 0) {
+    int getFrameResult = vpxGetFrame(vpxDecContext, outputBuffer);
+    if (getFrameResult == 1) {
       outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+    } else if (getFrameResult == -1) {
+      return new VpxDecoderException("Buffer initialization failed.");
     }
     return null;
   }
@@ -109,7 +140,11 @@ public void release() {
   private native long vpxInit();
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
+  private native long vpxSecureDecode(long context, ByteBuffer encoded, int length,
+      ExoMediaCrypto wvCrypto, int inputMode, byte[] key, byte[] iv,
+      int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData);
   private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
+  private native int vpxGetErrorCode(long context);
   private native String vpxGetErrorMessage(long context);
 
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
index 94ed8e9fdd..5f43b503ac 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
@@ -20,8 +20,11 @@
  */
 public class VpxDecoderException extends Exception {
 
-    /* package */ VpxDecoderException(String message) {
-      super(message);
-    }
+  /* package */ VpxDecoderException(String message) {
+    super(message);
+  }
 
+  /* package */ VpxDecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
index 6c694ebd2c..2caa33c17c 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
@@ -59,5 +59,5 @@ public static String getBuildConfig() {
 
   private static native String vpxGetVersion();
   private static native String vpxGetBuildConfig();
-
+  public static native boolean vpxIsSecureDecodeSupported();
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index d07b1443fd..c76d0eda03 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -66,28 +66,39 @@ public void init(long timeUs, int mode) {
 
   /**
    * Resizes the buffer based on the given dimensions. Called via JNI after decoding completes.
+   * @return Whether the buffer was resized successfully.
    */
-  public void initForRgbFrame(int width, int height) {
+  public boolean initForRgbFrame(int width, int height) {
     this.width = width;
     this.height = height;
     this.yuvPlanes = null;
-
+    if (!isSafeToMultiply(width, height) || !isSafeToMultiply(width * height, 2)) {
+      return false;
+    }
     int minimumRgbSize = width * height * 2;
     initData(minimumRgbSize);
+    return true;
   }
 
   /**
    * Resizes the buffer based on the given stride. Called via JNI after decoding completes.
+   * @return Whether the buffer was resized successfully.
    */
-  public void initForYuvFrame(int width, int height, int yStride, int uvStride,
+  public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
       int colorspace) {
     this.width = width;
     this.height = height;
     this.colorspace = colorspace;
-
+    int uvHeight = (int) (((long) height + 1) / 2);
+    if (!isSafeToMultiply(yStride, height) || !isSafeToMultiply(uvStride, uvHeight)) {
+      return false;
+    }
     int yLength = yStride * height;
-    int uvLength = uvStride * ((height + 1) / 2);
+    int uvLength = uvStride * uvHeight;
     int minimumYuvSize = yLength + (uvLength * 2);
+    if (!isSafeToMultiply(uvLength, 2) || minimumYuvSize < yLength) {
+      return false;
+    }
     initData(minimumYuvSize);
 
     if (yuvPlanes == null) {
@@ -108,6 +119,7 @@ public void initForYuvFrame(int width, int height, int yStride, int uvStride,
     yuvStrides[0] = yStride;
     yuvStrides[1] = uvStride;
     yuvStrides[2] = uvStride;
+    return true;
   }
 
   private void initData(int size) {
@@ -119,4 +131,12 @@ private void initData(int size) {
     }
   }
 
+  /**
+   * Ensures that the result of multiplying individual numbers can fit into the size limit of an
+   * integer.
+   */
+  private boolean isSafeToMultiply(int a, int b) {
+    return a >= 0 && b >= 0 && !(b > 0 && a >= Integer.MAX_VALUE / b);
+  }
+
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
index a0eccb41a7..d108ae8b4f 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
@@ -73,10 +73,13 @@
   private final int[] yuvTextures = new int[3];
   private final AtomicReference<VpxOutputBuffer> pendingOutputBufferReference;
 
+  // Kept in a field rather than a local variable so that it doesn't get garbage collected before
+  // glDrawArrays uses it.
+  @SuppressWarnings("FieldCanBeLocal")
+  private FloatBuffer textureCoords;
   private int program;
   private int texLocation;
   private int colorMatrixLocation;
-  private FloatBuffer textureCoords;
   private int previousWidth;
   private int previousStride;
 
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index a07b30a728..137ff9ac21 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -59,6 +59,7 @@ static jmethodID initForRgbFrame;
 static jmethodID initForYuvFrame;
 static jfieldID dataField;
 static jfieldID outputModeField;
+static int errorCode;
 
 jint JNI_OnLoad(JavaVM* vm, void* reserved) {
   JNIEnv* env;
@@ -72,6 +73,7 @@ DECODER_FUNC(jlong, vpxInit) {
   vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
   cfg.threads = android_getCpuCount();
+  errorCode = 0;
   if (vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo, &cfg, 0)) {
     LOGE("ERROR: Fail to initialize libvpx decoder.");
     return 0;
@@ -81,9 +83,9 @@ DECODER_FUNC(jlong, vpxInit) {
   const jclass outputBufferClass = env->FindClass(
       "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
-                                     "(IIIII)V");
+                                     "(IIIII)Z");
   initForRgbFrame = env->GetMethodID(outputBufferClass, "initForRgbFrame",
-                                     "(II)V");
+                                     "(II)Z");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
   outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
@@ -97,13 +99,26 @@ DECODER_FUNC(jlong, vpxDecode, jlong jContext, jobject encoded, jint len) {
       reinterpret_cast<const uint8_t*>(env->GetDirectBufferAddress(encoded));
   const vpx_codec_err_t status =
       vpx_codec_decode(context, buffer, len, NULL, 0);
+  errorCode = 0;
   if (status != VPX_CODEC_OK) {
     LOGE("ERROR: vpx_codec_decode() failed, status= %d", status);
+    errorCode = status;
     return -1;
   }
   return 0;
 }
 
+DECODER_FUNC(jlong, vpxSecureDecode, jlong jContext, jobject encoded, jint len,
+    jobject mediaCrypto, jint inputMode, jbyteArray&, jbyteArray&,
+    jint inputNumSubSamples, jintArray numBytesOfClearData,
+    jintArray numBytesOfEncryptedData) {
+  // Doesn't support
+  // Java client should have checked vpxSupportSecureDecode
+  // and avoid calling this
+  // return -2 (DRM Error)
+  return -2;
+}
+
 DECODER_FUNC(jlong, vpxClose, jlong jContext) {
   vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
   vpx_codec_destroy(context);
@@ -126,7 +141,11 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
   int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
   if (outputMode == kOutputModeRgb) {
     // resize buffer if required.
-    env->CallVoidMethod(jOutputBuffer, initForRgbFrame, img->d_w, img->d_h);
+    jboolean initResult = env->CallBooleanMethod(jOutputBuffer, initForRgbFrame,
+                                                 img->d_w, img->d_h);
+    if (initResult == JNI_FALSE) {
+      return -1;
+    }
 
     // get pointer to the data buffer.
     const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
@@ -155,9 +174,12 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     }
 
     // resize buffer if required.
-    env->CallVoidMethod(jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
-                        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U],
-                        colorspace);
+    jboolean initResult = env->CallBooleanMethod(
+        jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
+        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U], colorspace);
+    if (initResult == JNI_FALSE) {
+      return -1;
+    }
 
     // get pointer to the data buffer.
     const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
@@ -181,6 +203,15 @@ DECODER_FUNC(jstring, vpxGetErrorMessage, jlong jContext) {
   return env->NewStringUTF(vpx_codec_error(context));
 }
 
+DECODER_FUNC(jint, vpxGetErrorCode, jlong jContext) {
+  return errorCode;
+}
+
+LIBRARY_FUNC(jstring, vpxIsSecureDecodeSupported) {
+  // Doesn't support
+  return 0;
+}
+
 LIBRARY_FUNC(jstring, vpxGetVersion) {
   return env->NewStringUTF(vpx_codec_version_str());
 }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 04363c87a9..c41838fae2 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Sep 01 11:39:15 BST 2016
+#Mon Oct 24 14:40:37 BST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index 42e7cb3bb1..0d4bbd0256 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,3 @@
-import com.android.builder.core.BuilderConstants
-
 // Copyright (C) 2016 The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,6 +11,8 @@ import com.android.builder.core.BuilderConstants
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+import com.android.builder.core.BuilderConstants
+
 apply plugin: 'com.android.library'
 apply plugin: 'bintray-release'
 
@@ -28,20 +28,15 @@ android {
         // greater.
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-        debug {
-            testCoverageEnabled = true
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        // Re-enable test coverage when the following issue is fixed:
+        // https://code.google.com/p/android/issues/detail?id=226070
+        // debug {
+        //     testCoverageEnabled = true
+        // }
     }
 
     sourceSets {
@@ -55,7 +50,7 @@ dependencies {
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'org.mockito:mockito-core:1.9.5'
-    compile 'com.android.support:support-annotations:24.2.0'
+    compile 'com.android.support:support-annotations:25.0.1'
 }
 
 android.libraryVariants.all { variant ->
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 0000000000..75f2d095be
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Accessed via reflection in SubtitleDecoderFactory.DEFAULT
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea608Decoder {
+    public <init>(java.lang.String, int);
+}
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea708Decoder {
+    public <init>(int);
+}
diff --git a/library/src/androidTest/assets/dash/sample_mpd_3_segment_template b/library/src/androidTest/assets/dash/sample_mpd_3_segment_template
new file mode 100644
index 0000000000..a9147b54df
--- /dev/null
+++ b/library/src/androidTest/assets/dash/sample_mpd_3_segment_template
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:mpeg:DASH:schema:MPD:2011" xmlns:yt="http://youtube.com/yt/2012/10/10" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd" minBufferTime="PT1.500S" profiles="urn:mpeg:dash:profile:isoff-main:2011" type="dynamic" availabilityStartTime="2016-10-14T17:00:17" timeShiftBufferDepth="PT7200.000S" minimumUpdatePeriod="PT2.000S" yt:earliestMediaSequence="0" yt:mpdRequestTime="2016-10-14T18:29:17.082" yt:mpdResponseTime="2016-10-14T18:29:17.194">
+ <Period start="PT0.000S" yt:segmentIngestTime="2016-10-14T17:00:14.257">
+  <SegmentTemplate startNumber="0" timescale="1000" media="sq/$Number$">
+   <SegmentTimeline>
+    <S d="2002" t="6009" r="2"/>
+    <S d="1985"/>
+    <S d="2000"/>
+   </SegmentTimeline>
+  </SegmentTemplate>
+  <AdaptationSet id="0" mimeType="audio/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="140" codecs="mp4a.40.2" audioSamplingRate="48000" startWithSAP="1" bandwidth="144000">
+    <AudioChannelConfiguration schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011" value="2"/>
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/140/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/audio%2Fmp4/live/1/gir/yes/noclen/1/signature/B5137EA0CC278C07DD056D204E863CC81EDEB39E.1AD5D242EBC94922EDA7165353A89A5E08A4103A/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+  <AdaptationSet id="1" mimeType="video/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="133" codecs="avc1.4d4015" width="426" height="240" startWithSAP="1" maxPlayoutRate="1" bandwidth="258000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/133/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/90154AE9C5C9D9D519CBF2E43AB0A1778375992D.40E2E855ADFB38FA7E95E168FEEEA6796B080BD7/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="134" codecs="avc1.4d401e" width="640" height="360" startWithSAP="1" maxPlayoutRate="1" bandwidth="646000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/134/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/5C094AEFDCEB1A4D2F3C05F8BD095C336EF0E1C3.7AE6B9951B0237AAE6F031927AACAC4974BAFFAA/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="135" codecs="avc1.4d401f" width="854" height="480" startWithSAP="1" maxPlayoutRate="1" bandwidth="1171000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/135/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/1F7660CA4E5B4AE4D60E18795680E34CDD2EF3C9.800B0A1D5F490DE142CCF4C88C64FD21D42129/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="160" codecs="avc1.42c00b" width="256" height="144" startWithSAP="1" maxPlayoutRate="1" bandwidth="124000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/160/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/94EB61673784DF0C4237A1A866F2E171C8A64ADB.AEC00AA06C2278FEA8702FB62693B70D8977F46C/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+   <Representation id="136" codecs="avc1.4d401f" width="1280" height="720" startWithSAP="1" maxPlayoutRate="1" bandwidth="2326000" frameRate="30">
+    <BaseURL>http://redirector.googlevideo.com/videoplayback/id/BktsoMO3OMs.0/itag/136/source/yt_live_broadcast/ratebypass/yes/cmbypass/yes/mime/video%2Fmp4/live/1/gir/yes/noclen/1/signature/6D8C34FC30A1F1A4F700B61180D1C4CCF6274844.29EBCB4A837DE626C52C66CF650519E61C2FF0BF/key/dg_test0/mpd_version/5/ip/0.0.0.0/ipbits/0/expire/1476490914/sparams/ip,ipbits,expire,id,itag,source,ratebypass,cmbypass,mime,live,gir,noclen/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+ </Period>
+</MPD>
+
diff --git a/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4
new file mode 100644
index 0000000000..3d3c63786e
Binary files /dev/null and b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 differ
diff --git a/library/src/androidTest/assets/ogg/bear.opus.0.dump b/library/src/androidTest/assets/ogg/bear.opus.0.dump
index 3826692659..8033ce8089 100644
--- a/library/src/androidTest/assets/ogg/bear.opus.0.dump
+++ b/library/src/androidTest/assets/ogg/bear.opus.0.dump
@@ -22,7 +22,7 @@ track 0:
     encoderPadding = -1
     subsampleOffsetUs = 9223372036854775807
     selectionFlags = 0
-    language = und
+    language = null
     drmInitData = -
     initializationData:
       data = length 19, hash BFE794DB
diff --git a/library/src/androidTest/assets/ogg/bear.opus.1.dump b/library/src/androidTest/assets/ogg/bear.opus.1.dump
index f073d36b27..f9aceae68a 100644
--- a/library/src/androidTest/assets/ogg/bear.opus.1.dump
+++ b/library/src/androidTest/assets/ogg/bear.opus.1.dump
@@ -22,7 +22,7 @@ track 0:
     encoderPadding = -1
     subsampleOffsetUs = 9223372036854775807
     selectionFlags = 0
-    language = und
+    language = null
     drmInitData = -
     initializationData:
       data = length 19, hash BFE794DB
diff --git a/library/src/androidTest/assets/ogg/bear.opus.2.dump b/library/src/androidTest/assets/ogg/bear.opus.2.dump
index 6e27201631..f2f07f3e2f 100644
--- a/library/src/androidTest/assets/ogg/bear.opus.2.dump
+++ b/library/src/androidTest/assets/ogg/bear.opus.2.dump
@@ -22,7 +22,7 @@ track 0:
     encoderPadding = -1
     subsampleOffsetUs = 9223372036854775807
     selectionFlags = 0
-    language = und
+    language = null
     drmInitData = -
     initializationData:
       data = length 19, hash BFE794DB
diff --git a/library/src/androidTest/assets/ogg/bear.opus.3.dump b/library/src/androidTest/assets/ogg/bear.opus.3.dump
index 8d4f451698..905055797c 100644
--- a/library/src/androidTest/assets/ogg/bear.opus.3.dump
+++ b/library/src/androidTest/assets/ogg/bear.opus.3.dump
@@ -22,7 +22,7 @@ track 0:
     encoderPadding = -1
     subsampleOffsetUs = 9223372036854775807
     selectionFlags = 0
-    language = und
+    language = null
     drmInitData = -
     initializationData:
       data = length 19, hash BFE794DB
diff --git a/library/src/androidTest/assets/ogg/bear.opus.unklen.dump b/library/src/androidTest/assets/ogg/bear.opus.unklen.dump
index 070c9ef8a6..cd29da3e27 100644
--- a/library/src/androidTest/assets/ogg/bear.opus.unklen.dump
+++ b/library/src/androidTest/assets/ogg/bear.opus.unklen.dump
@@ -22,7 +22,7 @@ track 0:
     encoderPadding = -1
     subsampleOffsetUs = 9223372036854775807
     selectionFlags = 0
-    language = und
+    language = null
     drmInitData = -
     initializationData:
       data = length 19, hash BFE794DB
diff --git a/library/src/androidTest/assets/subrip/typical_negative_timestamps b/library/src/androidTest/assets/subrip/typical_negative_timestamps
new file mode 100644
index 0000000000..2a47c0993b
--- /dev/null
+++ b/library/src/androidTest/assets/subrip/typical_negative_timestamps
@@ -0,0 +1,12 @@
+1
+-0:00:04,567 --> -0:00:03,456
+This is the first subtitle.
+
+2
+-00:00:02,345 --> 00:00:01,234
+This is the second subtitle.
+Second subtitle with second line.
+
+3
+00:00:04,567 --> 00:00:08,901
+This is the third subtitle.
diff --git a/library/src/androidTest/assets/ts/sample_with_sdt.ts b/library/src/androidTest/assets/ts/sample_with_sdt.ts
new file mode 100644
index 0000000000..8d1eccee15
Binary files /dev/null and b/library/src/androidTest/assets/ts/sample_with_sdt.ts differ
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
new file mode 100644
index 0000000000..1197139b01
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MediaClock;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link ExoPlayer}.
+ */
+public final class ExoPlayerTest extends TestCase {
+
+  /**
+   * For tests that rely on the player transitioning to the ended state, the duration in
+   * milliseconds after starting the player before the test will time out. This is to catch cases
+   * where the player under test is not making progress, in which case the test should fail.
+   */
+  private static final int TIMEOUT_MS = 10000;
+
+  private static final Format TEST_VIDEO_FORMAT = Format.createVideoSampleFormat(null,
+      MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
+      null, null);
+  private static final Format TEST_AUDIO_FORMAT =  Format.createAudioSampleFormat(null,
+      MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+  /**
+   * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
+   * error.
+   */
+  public void testPlayEmptyTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = Timeline.EMPTY;
+    MediaSource mediaSource = new FakeMediaSource(timeline, null);
+    FakeRenderer renderer = new FakeRenderer(null);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(0, renderer.formatReadCount);
+    assertEquals(0, renderer.bufferReadCount);
+    assertFalse(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests playback of a source that exposes a single period.
+   */
+  public void testPlaySinglePeriodTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
+    Object manifest = new Object();
+    MediaSource mediaSource = new FakeMediaSource(timeline, manifest, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertEquals(manifest, playerWrapper.manifest);
+    assertEquals(new TrackGroupArray(new TrackGroup(TEST_VIDEO_FORMAT)), playerWrapper.trackGroups);
+  }
+
+  /**
+   * Tests playback of a source that exposes three periods.
+   */
+  public void testPlayMultiPeriodTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(3, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests that the player does not unnecessarily reset renderers when playing a multi-period
+   * source.
+   */
+  public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
+    final PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT,
+        TEST_AUDIO_FORMAT);
+
+    FakeRenderer videoRenderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(TEST_AUDIO_FORMAT) {
+
+      @Override
+      public long getPositionUs() {
+        // Simulate the playback position lagging behind the reading position: the renderer media
+        // clock position will be the start of the timeline until the stream is set to be final, at
+        // which point it jumps to the end of the timeline allowing the playing period to advance.
+        // TODO: Avoid hard-coding ExoPlayerImplInternal.RENDERER_TIMESTAMP_OFFSET_US.
+        return isCurrentStreamFinal() ? 60000030 : 60000000;
+      }
+
+      @Override
+      public boolean isEnded() {
+        // Allow playback to end once the final period is playing.
+        return playerWrapper.positionDiscontinuityCount == 2;
+      }
+
+    };
+    playerWrapper.setup(mediaSource, videoRenderer, audioRenderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, audioRenderer.positionResetCount);
+    assertTrue(videoRenderer.isEnded);
+    assertTrue(audioRenderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Wraps a player with its own handler thread.
+   */
+  private static final class PlayerWrapper implements ExoPlayer.EventListener {
+
+    private final CountDownLatch endedCountDownLatch;
+    private final HandlerThread playerThread;
+    private final Handler handler;
+
+    private ExoPlayer player;
+    private Timeline timeline;
+    private Object manifest;
+    private TrackGroupArray trackGroups;
+    private Exception exception;
+
+    // Written only on the main thread.
+    private volatile int positionDiscontinuityCount;
+
+    public PlayerWrapper() {
+      endedCountDownLatch = new CountDownLatch(1);
+      playerThread = new HandlerThread("ExoPlayerTest thread");
+      playerThread.start();
+      handler = new Handler(playerThread.getLooper());
+    }
+
+    // Called on the test thread.
+
+    public void blockUntilEnded(long timeoutMs) throws Exception {
+      if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
+        exception = new TimeoutException("Test playback timed out.");
+      }
+      release();
+      // Throw any pending exception (from playback, timing out or releasing).
+      if (exception != null) {
+        throw exception;
+      }
+    }
+
+    public void setup(final MediaSource mediaSource, final Renderer... renderers) {
+      handler.post(new Runnable() {
+        @Override
+        public void run() {
+          try {
+            player = ExoPlayerFactory.newInstance(renderers, new DefaultTrackSelector());
+            player.addListener(PlayerWrapper.this);
+            player.setPlayWhenReady(true);
+            player.prepare(mediaSource);
+          } catch (Exception e) {
+            handleError(e);
+          }
+        }
+      });
+    }
+
+    public void release() throws InterruptedException {
+      handler.post(new Runnable() {
+        @Override
+        public void run() {
+          try {
+            if (player != null) {
+              player.release();
+            }
+          } catch (Exception e) {
+            handleError(e);
+          } finally {
+            playerThread.quit();
+          }
+        }
+      });
+      playerThread.join();
+    }
+
+    private void handleError(Exception exception) {
+      if (this.exception == null) {
+        this.exception = exception;
+      }
+      endedCountDownLatch.countDown();
+    }
+
+    // ExoPlayer.EventListener implementation.
+
+    @Override
+    public void onLoadingChanged(boolean isLoading) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == ExoPlayer.STATE_ENDED) {
+        endedCountDownLatch.countDown();
+      }
+    }
+
+    @Override
+    public void onTimelineChanged(Timeline timeline, Object manifest) {
+      this.timeline = timeline;
+      this.manifest = manifest;
+    }
+
+    @Override
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      this.trackGroups = trackGroups;
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException exception) {
+      handleError(exception);
+    }
+
+    @SuppressWarnings("NonAtomicVolatileUpdate")
+    @Override
+    public void onPositionDiscontinuity() {
+      positionDiscontinuityCount++;
+    }
+
+  }
+
+  private static final class TimelineWindowDefinition {
+
+    public final boolean isSeekable;
+    public final boolean isDynamic;
+    public final long durationUs;
+
+    public TimelineWindowDefinition(boolean isSeekable, boolean isDynamic, long durationUs) {
+      this.isSeekable = isSeekable;
+      this.isDynamic = isDynamic;
+      this.durationUs = durationUs;
+    }
+
+  }
+
+  private static final class FakeTimeline extends Timeline {
+
+    private final TimelineWindowDefinition[] windowDefinitions;
+
+    public FakeTimeline(TimelineWindowDefinition... windowDefinitions) {
+      this.windowDefinitions = windowDefinitions;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
+      Object id = setIds ? windowIndex : null;
+      return window.set(id, C.TIME_UNSET, C.TIME_UNSET, windowDefinition.isSeekable,
+          windowDefinition.isDynamic, 0, windowDefinition.durationUs, windowIndex, windowIndex, 0);
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[periodIndex];
+      Object id = setIds ? periodIndex : null;
+      return period.set(id, id, periodIndex, windowDefinition.durationUs, 0);
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      if (!(uid instanceof Integer)) {
+        return C.INDEX_UNSET;
+      }
+      int index = (Integer) uid;
+      return index >= 0 && index < windowDefinitions.length ? index : C.INDEX_UNSET;
+    }
+
+  }
+
+  /**
+   * Fake {@link MediaSource} that provides a given timeline (which must have one period). Creating
+   * the period will return a {@link FakeMediaPeriod}.
+   */
+  private static final class FakeMediaSource implements MediaSource {
+
+    private final Timeline timeline;
+    private final Object manifest;
+    private final TrackGroupArray trackGroupArray;
+    private final ArrayList<FakeMediaPeriod> activeMediaPeriods;
+
+    private boolean preparedSource;
+    private boolean releasedSource;
+
+    public FakeMediaSource(Timeline timeline, Object manifest, Format... formats) {
+      this.timeline = timeline;
+      this.manifest = manifest;
+      TrackGroup[] trackGroups = new TrackGroup[formats.length];
+      for (int i = 0; i < formats.length; i++) {
+        trackGroups[i] = new TrackGroup(formats[i]);
+      }
+      trackGroupArray = new TrackGroupArray(trackGroups);
+      activeMediaPeriods = new ArrayList<>();
+    }
+
+    @Override
+    public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+      assertFalse(preparedSource);
+      preparedSource = true;
+      listener.onSourceInfoRefreshed(timeline, manifest);
+    }
+
+    @Override
+    public void maybeThrowSourceInfoRefreshError() throws IOException {
+      assertTrue(preparedSource);
+    }
+
+    @Override
+    public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+      Assertions.checkIndex(index, 0, timeline.getPeriodCount());
+      assertTrue(preparedSource);
+      assertFalse(releasedSource);
+      assertEquals(0, positionUs);
+      FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+      activeMediaPeriods.add(mediaPeriod);
+      return mediaPeriod;
+    }
+
+    @Override
+    public void releasePeriod(MediaPeriod mediaPeriod) {
+      assertTrue(preparedSource);
+      assertFalse(releasedSource);
+      FakeMediaPeriod fakeMediaPeriod = (FakeMediaPeriod) mediaPeriod;
+      assertTrue(activeMediaPeriods.remove(fakeMediaPeriod));
+      fakeMediaPeriod.release();
+    }
+
+    @Override
+    public void releaseSource() {
+      assertTrue(preparedSource);
+      assertFalse(releasedSource);
+      assertTrue(activeMediaPeriods.isEmpty());
+      releasedSource = true;
+    }
+
+  }
+
+  /**
+   * Fake {@link MediaPeriod} that provides one track with a given {@link Format}. Selecting that
+   * track will give the player a {@link FakeSampleStream}.
+   */
+  private static final class FakeMediaPeriod implements MediaPeriod {
+
+    private final TrackGroupArray trackGroupArray;
+
+    private boolean preparedPeriod;
+
+    public FakeMediaPeriod(TrackGroupArray trackGroupArray) {
+      this.trackGroupArray = trackGroupArray;
+    }
+
+    public void release() {
+      preparedPeriod = false;
+    }
+
+    @Override
+    public void prepare(Callback callback) {
+      assertFalse(preparedPeriod);
+      preparedPeriod = true;
+      callback.onPrepared(this);
+    }
+
+    @Override
+    public void maybeThrowPrepareError() throws IOException {
+      assertTrue(preparedPeriod);
+    }
+
+    @Override
+    public TrackGroupArray getTrackGroups() {
+      assertTrue(preparedPeriod);
+      return trackGroupArray;
+    }
+
+    @Override
+    public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+        SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+      assertTrue(preparedPeriod);
+      int rendererCount = selections.length;
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          streams[i] = null;
+        }
+      }
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] == null && selections[i] != null) {
+          TrackSelection selection = selections[i];
+          assertEquals(1, selection.length());
+          assertEquals(0, selection.getIndexInTrackGroup(0));
+          TrackGroup trackGroup = selection.getTrackGroup();
+          assertTrue(trackGroupArray.indexOf(trackGroup) != C.INDEX_UNSET);
+          streams[i] = new FakeSampleStream(trackGroup.getFormat(0));
+          streamResetFlags[i] = true;
+        }
+      }
+      return 0;
+    }
+
+    @Override
+    public long readDiscontinuity() {
+      assertTrue(preparedPeriod);
+      return C.TIME_UNSET;
+    }
+
+    @Override
+    public long getBufferedPositionUs() {
+      assertTrue(preparedPeriod);
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public long seekToUs(long positionUs) {
+      assertTrue(preparedPeriod);
+      assertEquals(0, positionUs);
+      return positionUs;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+      assertTrue(preparedPeriod);
+      return C.TIME_END_OF_SOURCE;
+    }
+
+    @Override
+    public boolean continueLoading(long positionUs) {
+      assertTrue(preparedPeriod);
+      return false;
+    }
+
+  }
+
+  /**
+   * Fake {@link SampleStream} that outputs a given {@link Format} then sets the end of stream flag
+   * on its input buffer.
+   */
+  private static final class FakeSampleStream implements SampleStream {
+
+    private final Format format;
+
+    private boolean readFormat;
+
+    public FakeSampleStream(Format format) {
+      this.format = format;
+    }
+
+    @Override
+    public boolean isReady() {
+      return true;
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+      if (buffer == null || !readFormat) {
+        formatHolder.format = format;
+        readFormat = true;
+        return C.RESULT_FORMAT_READ;
+      } else {
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      // Do nothing.
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+      // Do nothing.
+    }
+
+  }
+
+  /**
+   * Fake {@link Renderer} that supports any format with the matching MIME type. The renderer
+   * verifies that it reads a given {@link Format}.
+   */
+  private static class FakeRenderer extends BaseRenderer {
+
+    private final Format expectedFormat;
+
+    public int positionResetCount;
+    public int formatReadCount;
+    public int bufferReadCount;
+    public boolean isEnded;
+
+    public FakeRenderer(Format expectedFormat) {
+      super(expectedFormat == null ? C.TRACK_TYPE_UNKNOWN
+          : MimeTypes.getTrackType(expectedFormat.sampleMimeType));
+      this.expectedFormat = expectedFormat;
+    }
+
+    @Override
+    protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+      positionResetCount++;
+      isEnded = false;
+    }
+
+    @Override
+    public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+      if (isEnded) {
+        return;
+      }
+
+      // Verify the format matches the expected format.
+      FormatHolder formatHolder = new FormatHolder();
+      DecoderInputBuffer buffer =
+          new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+      int result = readSource(formatHolder, buffer);
+      if (result == C.RESULT_FORMAT_READ) {
+        formatReadCount++;
+        assertEquals(expectedFormat, formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        bufferReadCount++;
+        if (buffer.isEndOfStream()) {
+          isEnded = true;
+        }
+      }
+    }
+
+    @Override
+    public boolean isReady() {
+      return isSourceReady();
+    }
+
+    @Override
+    public boolean isEnded() {
+      return isEnded;
+    }
+
+    @Override
+    public int supportsFormat(Format format) throws ExoPlaybackException {
+      return getTrackType() == MimeTypes.getTrackType(format.sampleMimeType) ? FORMAT_HANDLED
+          : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+  }
+
+  private abstract static class FakeMediaClockRenderer extends FakeRenderer implements MediaClock {
+
+    public FakeMediaClockRenderer(Format expectedFormat) {
+      super(expectedFormat);
+    }
+
+    @Override
+    public MediaClock getMediaClock() {
+      return this;
+    }
+
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
index 9bdf330b02..e13afceb40 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
@@ -24,6 +24,8 @@
 import android.media.MediaFormat;
 import android.os.Parcel;
 import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -56,11 +58,14 @@ public void testParcelable() {
         TestUtil.buildTestData(128, 1 /* data seed */));
     DrmInitData drmInitData = new DrmInitData(DRM_DATA_1, DRM_DATA_2);
     byte[] projectionData = new byte[] {1, 2, 3};
+    Metadata metadata = new Metadata(
+        new TextInformationFrame("id1", "description1", "value1"),
+        new TextInformationFrame("id2", "description2", "value2"));
 
     Format formatToParcel = new Format("id", MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
         1024, 2048, 1920, 1080, 24, 90, 2, projectionData, C.STEREO_MODE_TOP_BOTTOM, 6, 44100,
-        C.ENCODING_PCM_24BIT, 1001, 1002, 0, "und", Format.OFFSET_SAMPLE_RELATIVE, INIT_DATA,
-        drmInitData);
+        C.ENCODING_PCM_24BIT, 1001, 1002, 0, "und", Format.NO_VALUE, Format.OFFSET_SAMPLE_RELATIVE,
+        INIT_DATA, drmInitData, metadata);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
new file mode 100644
index 0000000000..9eed8dfd3a
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import java.util.Arrays;
+import java.util.HashMap;
+import org.mockito.Mock;
+
+/**
+ * Tests {@link OfflineLicenseHelper}.
+ */
+public class OfflineLicenseHelperTest extends InstrumentationTestCase {
+
+  private OfflineLicenseHelper<?> offlineLicenseHelper;
+  @Mock private HttpDataSource httpDataSource;
+  @Mock private MediaDrmCallback mediaDrmCallback;
+  @Mock private ExoMediaDrm<ExoMediaCrypto> mediaDrm;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    when(mediaDrm.openSession()).thenReturn(new byte[] {1, 2, 3});
+
+    offlineLicenseHelper = new OfflineLicenseHelper<>(mediaDrm, mediaDrmCallback, null);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    offlineLicenseHelper.releaseResources();
+  }
+
+  public void testDownloadRenewReleaseKey() throws Exception {
+    DashManifest manifest = newDashManifestWithAllElements();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+
+    byte[] keySetId = {2, 5, 8};
+    setStubKeySetId(keySetId);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId, offlineLicenseKeySetId);
+
+    byte[] keySetId2 = {6, 7, 0, 1, 4};
+    setStubKeySetId(keySetId2);
+
+    byte[] offlineLicenseKeySetId2 = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId2, offlineLicenseKeySetId2);
+
+    offlineLicenseHelper.release(offlineLicenseKeySetId2);
+  }
+
+  public void testDownloadFailsIfThereIsNoInitData() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest =
+        newDashManifest(newPeriods(newAdaptationSets(newRepresentations(null /*no init data*/))));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoRepresentation() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(newAdaptationSets(/*no representation*/)));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoAdaptationSet() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(/*no adaptation set*/));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoPeriod() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(/*no periods*/);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfNoKeySetIdIsReturned() throws Exception {
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadDoesNotFailIfDurationNotAvailable() throws Exception {
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNotNull(offlineLicenseKeySetId);
+  }
+
+  public void testGetLicenseDurationRemainingSec() throws Exception {
+    long licenseDuration = 1000;
+    int playbackDuration = 200;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  public void testGetLicenseDurationRemainingSecExpiredLicense() throws Exception {
+    long licenseDuration = 0;
+    int playbackDuration = 0;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  private void setDefaultStubValues()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setDefaultStubKeySetId();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+  }
+
+  private void setDefaultStubKeySetId()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setStubKeySetId(new byte[] {2, 5, 8});
+  }
+
+  private void setStubKeySetId(byte[] keySetId)
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    when(mediaDrm.provideKeyResponse(any(byte[].class), any(byte[].class))).thenReturn(keySetId);
+  }
+
+  private static void assertOfflineLicenseKeySetIdEqual(
+      byte[] expectedKeySetId, byte[] actualKeySetId) throws Exception {
+    assertNotNull(actualKeySetId);
+    MoreAsserts.assertEquals(expectedKeySetId, actualKeySetId);
+  }
+
+  private void setStubLicenseAndPlaybackDurationValues(long licenseDuration,
+      long playbackDuration) {
+    HashMap<String, String> keyStatus = new HashMap<>();
+    keyStatus.put(WidevineUtil.PROPERTY_LICENSE_DURATION_REMAINING,
+        String.valueOf(licenseDuration));
+    keyStatus.put(WidevineUtil.PROPERTY_PLAYBACK_DURATION_REMAINING,
+        String.valueOf(playbackDuration));
+    when(mediaDrm.queryKeyStatus(any(byte[].class))).thenReturn(keyStatus);
+  }
+
+  private static DashManifest newDashManifestWithAllElements() {
+    return newDashManifest(newPeriods(newAdaptationSets(newRepresentations(newDrmInitData()))));
+  }
+
+  private static DashManifest newDashManifest(Period... periods) {
+    return new DashManifest(0, 0, 0, false, 0, 0, 0, null, null, Arrays.asList(periods));
+  }
+
+  private static Period newPeriods(AdaptationSet... adaptationSets) {
+    return new Period("", 0, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet newAdaptationSets(Representation... representations) {
+    return new AdaptationSet(0, C.TRACK_TYPE_VIDEO, Arrays.asList(representations), null);
+  }
+
+  private static Representation newRepresentations(DrmInitData drmInitData) {
+    Format format = Format.createVideoSampleFormat("", "", "", 0, 0, 0, 0, 0, null, drmInitData);
+    return Representation.newInstance("", 0, format, "", new SingleSegmentBase());
+  }
+
+  private static DrmInitData newDrmInitData() {
+    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
+        new byte[]{1, 4, 7, 0, 3, 6}));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index c47614e4ee..9a8a1f7f27 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.TestUtil;
 
@@ -24,13 +25,21 @@
  */
 public final class FragmentedMp4ExtractorTest extends InstrumentationTestCase {
 
+  private static final TestUtil.ExtractorFactory EXTRACTOR_FACTORY =
+      new TestUtil.ExtractorFactory() {
+        @Override
+        public Extractor create() {
+          return new FragmentedMp4Extractor();
+        }
+      };
+
   public void testSample() throws Exception {
-    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new FragmentedMp4Extractor();
-      }
-    }, "mp4/sample_fragmented.mp4", getInstrumentation());
+    TestUtil.assertOutput(EXTRACTOR_FACTORY, "mp4/sample_fragmented.mp4", getInstrumentation());
+  }
+
+  public void testAtomWithZeroSize() throws Exception {
+    TestUtil.assertThrows(EXTRACTOR_FACTORY, "mp4/sample_fragmented_zero_size_atom.mp4",
+        getInstrumentation(), ParserException.class);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
index cccc619a0e..cb1751d43b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
@@ -27,9 +27,9 @@
  */
 public final class DefaultOggSeekerTest extends TestCase {
 
-  public void testSetupUnboundAudioLength() {
+  public void testSetupWithUnsetEndPositionFails() {
     try {
-      new DefaultOggSeeker(0, C.LENGTH_UNSET, new TestStreamReader());
+      new DefaultOggSeeker(0, C.LENGTH_UNSET, new TestStreamReader(), 1, 1);
       fail();
     } catch (IllegalArgumentException e) {
       // ignored
@@ -43,11 +43,12 @@ public void testSeeking() throws IOException, InterruptedException {
     }
   }
 
-  public void testSeeking(Random random) throws IOException, InterruptedException {
+  private void testSeeking(Random random) throws IOException, InterruptedException {
     OggTestFile testFile = OggTestFile.generate(random, 1000);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(testFile.data).build();
     TestStreamReader streamReader = new TestStreamReader();
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, testFile.data.length, streamReader);
+    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, testFile.data.length, streamReader,
+        testFile.firstPayloadPageSize, testFile.firstPayloadPageGranulePosition);
     OggPageHeader pageHeader = new OggPageHeader();
 
     while (true) {
@@ -109,8 +110,8 @@ public void testSeeking(Random random) throws IOException, InterruptedException
       long granuleDiff = currentGranule - targetGranule;
       if ((granuleDiff > DefaultOggSeeker.MATCH_RANGE || granuleDiff < 0)
           && positionDiff > DefaultOggSeeker.MATCH_BYTE_RANGE) {
-        fail(String.format("granuleDiff (%d) or positionDiff (%d) is more than allowed.",
-            granuleDiff, positionDiff));
+        fail("granuleDiff (" + granuleDiff + ") or positionDiff (" + positionDiff
+            + ") is more than allowed.");
       }
     }
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
index 052f45b8f4..d52deb108f 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
@@ -28,8 +28,8 @@
  */
 public class DefaultOggSeekerUtilMethodsTest extends TestCase {
 
-  private Random random = new Random(0);
-  
+  private final Random random = new Random(0);
+
   public void testSkipToNextPage() throws Exception {
     FakeExtractorInput extractorInput = TestData.createInput(
         TestUtil.joinByteArrays(
@@ -75,7 +75,7 @@ public void testSkipToNextPageNoMatch() throws Exception {
   private static void skipToNextPage(ExtractorInput extractorInput)
       throws IOException, InterruptedException {
     DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, extractorInput.getLength(),
-        new FlacReader());
+        new FlacReader(), 1, 2);
     while (true) {
       try {
         oggSeeker.skipToNextPage(extractorInput);
@@ -143,7 +143,7 @@ public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, Interru
 
   private void skipToPageOfGranule(ExtractorInput input, long granule,
       long elapsedSamplesExpected) throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader());
+    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
     while (true) {
       try {
         assertEquals(elapsedSamplesExpected, oggSeeker.skipToPageOfGranule(input, granule, -1));
@@ -193,7 +193,7 @@ public void testReadGranuleOfLastPageWithUnboundedLength()
 
   private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
       throws IOException, InterruptedException {
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader());
+    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, input.getLength(), new FlacReader(), 1, 2);
     while (true) {
       try {
         assertEquals(expected, oggSeeker.readGranuleOfLastPage(input));
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
index 88f36d35c1..d5d187ee7c 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
@@ -25,20 +25,25 @@
  */
 /* package */ final class OggTestFile {
 
-  public static final int MAX_PACKET_LENGTH = 2048;
-  public static final int MAX_SEGMENT_COUNT = 10;
-  public static final int MAX_GRANULES_IN_PAGE = 100000;
+  private static final int MAX_PACKET_LENGTH = 2048;
+  private static final int MAX_SEGMENT_COUNT = 10;
+  private static final int MAX_GRANULES_IN_PAGE = 100000;
 
-  byte[] data;
-  long lastGranule;
-  int packetCount;
-  int pageCount;
+  public final byte[] data;
+  public final long lastGranule;
+  public final int packetCount;
+  public final int pageCount;
+  public final int firstPayloadPageSize;
+  public final long firstPayloadPageGranulePosition;
 
-  private OggTestFile(byte[] data, long lastGranule, int packetCount, int pageCount) {
+  private OggTestFile(byte[] data, long lastGranule, int packetCount, int pageCount,
+      int firstPayloadPageSize, long firstPayloadPageGranulePosition) {
     this.data = data;
     this.lastGranule = lastGranule;
     this.packetCount = packetCount;
     this.pageCount = pageCount;
+    this.firstPayloadPageSize = firstPayloadPageSize;
+    this.firstPayloadPageGranulePosition = firstPayloadPageGranulePosition;
   }
 
   public static OggTestFile generate(Random random, int pageCount) {
@@ -47,6 +52,8 @@ public static OggTestFile generate(Random random, int pageCount) {
     long granule = 0;
     int packetLength = -1;
     int packetCount = 0;
+    int firstPayloadPageSize = 0;
+    long firstPayloadPageGranulePosition = 0;
 
     for (int i = 0; i < pageCount; i++) {
       int headerType = 0x00;
@@ -89,6 +96,10 @@ public static OggTestFile generate(Random random, int pageCount) {
       byte[] payload = TestUtil.buildTestData(bodySize, random);
       fileData.add(payload);
       fileSize += payload.length;
+      if (i == 0) {
+        firstPayloadPageSize = header.length + bodySize;
+        firstPayloadPageGranulePosition = granule;
+      }
     }
 
     byte[] file = new byte[fileSize];
@@ -97,7 +108,8 @@ public static OggTestFile generate(Random random, int pageCount) {
       System.arraycopy(data, 0, file, position, data.length);
       position += data.length;
     }
-    return new OggTestFile(file, granule, packetCount, pageCount);
+    return new OggTestFile(file, granule, packetCount, pageCount, firstPayloadPageSize,
+        firstPayloadPageGranulePosition);
   }
 
   public int findPreviousPageStart(long position) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
index 2f4da01228..4e99e2745e 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
@@ -17,8 +17,10 @@
 
 import android.annotation.TargetApi;
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
  * Tests for {@link RawCcExtractor}.
@@ -27,12 +29,15 @@
 public final class RawCcExtractorTest extends InstrumentationTestCase {
 
   public void testRawCcSample() throws Exception {
-    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new RawCcExtractor();
-      }
-    }, "rawcc/sample.rawcc", getInstrumentation());
+    TestUtil.assertOutput(
+        new TestUtil.ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new RawCcExtractor(
+                Format.createTextContainerFormat(null, null, MimeTypes.APPLICATION_CEA608,
+                    "cea608", Format.NO_VALUE, 0, null, 1));
+          }
+        }, "rawcc/sample.rawcc", getInstrumentation());
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index e19de76466..ebb547810b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
@@ -52,7 +52,7 @@
   public static final byte[] ADTS_CONTENT = TestUtil.createByteArray(
       0x20, 0x00, 0x20, 0x00, 0x00, 0x80, 0x0e);
 
-  private static final byte TEST_DATA[] = TestUtil.joinByteArrays(
+  private static final byte[] TEST_DATA = TestUtil.joinByteArrays(
       ID3_DATA_1,
       ID3_DATA_2,
       ADTS_HEADER,
@@ -73,7 +73,7 @@ protected void setUp() throws Exception {
     id3Output = fakeExtractorOutput.track(1);
     adtsReader = new AdtsReader(true);
     TrackIdGenerator idGenerator = new TrackIdGenerator(0, 1);
-    adtsReader.init(fakeExtractorOutput, idGenerator);
+    adtsReader.createTracks(fakeExtractorOutput, idGenerator);
     data = new ParsableByteArray(TEST_DATA);
     firstFeed = true;
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
new file mode 100644
index 0000000000..c4d9de3100
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link SectionReader}.
+ */
+public class SectionReaderTest extends TestCase {
+
+  private byte[] packetPayload;
+  private CustomSectionPayloadReader payloadReader;
+  private SectionReader reader;
+
+  @Override
+  public void setUp() {
+    packetPayload = new byte[512];
+    Arrays.fill(packetPayload, (byte) 0xFF);
+    payloadReader = new CustomSectionPayloadReader();
+    reader = new SectionReader(payloadReader);
+    reader.init(new TimestampAdjuster(0), new FakeExtractorOutput(),
+        new TsPayloadReader.TrackIdGenerator(0, 1));
+  }
+
+  public void testSingleOnePacketSection() {
+    packetPayload[0] = 3;
+    insertTableSection(4, (byte) 99, 3);
+    reader.consume(new ParsableByteArray(packetPayload), true);
+    assertEquals(Collections.singletonList(99), payloadReader.parsedTableIds);
+  }
+
+  public void testHeaderSplitAcrossPackets() {
+    packetPayload[0] = 3; // The first packet includes a pointer_field.
+    insertTableSection(4, (byte) 100, 3); // This section header spreads across both packets.
+
+    ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 5);
+    reader.consume(firstPacket, true);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
+    secondPacket.setPosition(5);
+    reader.consume(secondPacket, false);
+    assertEquals(Collections.singletonList(100), payloadReader.parsedTableIds);
+  }
+
+  public void testFiveSectionsInTwoPackets() {
+    packetPayload[0] = 0; // The first packet includes a pointer_field.
+    insertTableSection(1, (byte) 101, 10);
+    insertTableSection(14, (byte) 102, 10);
+    insertTableSection(27, (byte) 103, 10);
+    packetPayload[40] = 0; // The second packet includes a pointer_field.
+    insertTableSection(41, (byte) 104, 10);
+    insertTableSection(54, (byte) 105, 10);
+
+    ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 40);
+    reader.consume(firstPacket, true);
+    assertEquals(Arrays.asList(101, 102, 103), payloadReader.parsedTableIds);
+
+    ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
+    secondPacket.setPosition(40);
+    reader.consume(secondPacket, true);
+    assertEquals(Arrays.asList(101, 102, 103, 104, 105), payloadReader.parsedTableIds);
+  }
+
+  public void testLongSectionAcrossFourPackets() {
+    packetPayload[0] = 13; // The first packet includes a pointer_field.
+    insertTableSection(1, (byte) 106, 10); // First section. Should be skipped.
+    // Second section spread across four packets. Should be consumed.
+    insertTableSection(14, (byte) 107, 300);
+    packetPayload[300] = 17; // The third packet includes a pointer_field.
+    // Third section, at the payload start of the fourth packet. Should be consumed.
+    insertTableSection(318, (byte) 108, 10);
+
+    ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
+    reader.consume(firstPacket, true);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
+    secondPacket.setPosition(100);
+    reader.consume(secondPacket, false);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
+    thirdPacket.setPosition(200);
+    reader.consume(thirdPacket, false);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
+    fourthPacket.setPosition(300);
+    reader.consume(fourthPacket, true);
+    assertEquals(Arrays.asList(107, 108), payloadReader.parsedTableIds);
+  }
+
+  public void testSeek() {
+    packetPayload[0] = 13; // The first packet includes a pointer_field.
+    insertTableSection(1, (byte) 109, 10); // First section. Should be skipped.
+    // Second section spread across four packets. Should be consumed.
+    insertTableSection(14, (byte) 110, 300);
+    packetPayload[300] = 17; // The third packet includes a pointer_field.
+    // Third section, at the payload start of the fourth packet. Should be consumed.
+    insertTableSection(318, (byte) 111, 10);
+
+    ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
+    reader.consume(firstPacket, true);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
+    secondPacket.setPosition(100);
+    reader.consume(secondPacket, false);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
+    thirdPacket.setPosition(200);
+    reader.consume(thirdPacket, false);
+    assertEquals(Collections.emptyList(), payloadReader.parsedTableIds);
+
+    reader.seek();
+
+    ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
+    fourthPacket.setPosition(300);
+    reader.consume(fourthPacket, true);
+    assertEquals(Collections.singletonList(111), payloadReader.parsedTableIds);
+  }
+
+  public void testCrcChecks() {
+    byte[] correctCrcPat = new byte[] {
+        (byte) 0x0, (byte) 0x0, (byte) 0xb0, (byte) 0xd, (byte) 0x0, (byte) 0x1, (byte) 0xc1,
+        (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0xe1, (byte) 0x0, (byte) 0xe8,
+        (byte) 0xf9, (byte) 0x5e, (byte) 0x7d};
+    byte[] incorrectCrcPat = Arrays.copyOf(correctCrcPat, correctCrcPat.length);
+    // Crc field is incorrect, and should not be passed to the payload reader.
+    incorrectCrcPat[16]--;
+    reader.consume(new ParsableByteArray(correctCrcPat), true);
+    assertEquals(Collections.singletonList(0), payloadReader.parsedTableIds);
+    reader.consume(new ParsableByteArray(incorrectCrcPat), true);
+    assertEquals(Collections.singletonList(0), payloadReader.parsedTableIds);
+  }
+
+  // Internal methods.
+
+  /**
+   * Inserts a private section header to {@link #packetPayload}.
+   *
+   * @param offset The position at which the header is inserted.
+   * @param tableId The table_id for the inserted section.
+   * @param sectionLength The value to use for private_section_length.
+   */
+  private void insertTableSection(int offset, byte tableId, int sectionLength) {
+    packetPayload[offset++] = tableId;
+    packetPayload[offset++] = (byte) ((sectionLength >> 8) & 0x0F);
+    packetPayload[offset] = (byte) (sectionLength & 0xFF);
+  }
+
+  // Internal classes.
+
+  private static final class CustomSectionPayloadReader implements SectionPayloadReader {
+
+    List<Integer> parsedTableIds;
+
+    @Override
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TsPayloadReader.TrackIdGenerator idGenerator) {
+      parsedTableIds = new ArrayList<>();
+    }
+
+    @Override
+    public void consume(ParsableByteArray sectionData) {
+      parsedTableIds.add(sectionData.readUnsignedByte());
+    }
+
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index 1f08507599..2dce742158 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -16,20 +16,21 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.test.InstrumentationTestCase;
+import android.util.SparseArray;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.util.Random;
 
 /**
@@ -72,7 +73,7 @@ public Extractor create() {
   }
 
   public void testCustomPesReader() throws Exception {
-    CustomEsReaderFactory factory = new CustomEsReaderFactory();
+    CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(true, false);
     TsExtractor tsExtractor = new TsExtractor(new TimestampAdjuster(0), factory, false);
     FakeExtractorInput input = new FakeExtractorInput.Builder()
         .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample.ts"))
@@ -81,13 +82,12 @@ public void testCustomPesReader() throws Exception {
         .setSimulatePartialReads(false).build();
     FakeExtractorOutput output = new FakeExtractorOutput();
     tsExtractor.init(output);
-    tsExtractor.seek(input.getPosition());
     PositionHolder seekPositionHolder = new PositionHolder();
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
       readResult = tsExtractor.read(input, seekPositionHolder);
     }
-    CustomEsReader reader = factory.reader;
+    CustomEsReader reader = factory.esReader;
     assertEquals(2, reader.packetsRead);
     TrackOutput trackOutput = reader.getTrackOutput();
     assertTrue(trackOutput == output.trackOutputs.get(257 /* PID of audio track. */));
@@ -96,7 +96,24 @@ public void testCustomPesReader() throws Exception {
         ((FakeTrackOutput) trackOutput).format);
   }
 
-  private static void writeJunkData(ByteArrayOutputStream out, int length) throws IOException {
+  public void testCustomInitialSectionReader() throws Exception {
+    CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(false, true);
+    TsExtractor tsExtractor = new TsExtractor(new TimestampAdjuster(0), factory, false);
+    FakeExtractorInput input = new FakeExtractorInput.Builder()
+        .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample_with_sdt.ts"))
+        .setSimulateIOErrors(false)
+        .setSimulateUnknownLength(false)
+        .setSimulatePartialReads(false).build();
+    tsExtractor.init(new FakeExtractorOutput());
+    PositionHolder seekPositionHolder = new PositionHolder();
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      readResult = tsExtractor.read(input, seekPositionHolder);
+    }
+    assertEquals(1, factory.sdtReader.consumedSdts);
+  }
+
+  private static void writeJunkData(ByteArrayOutputStream out, int length) {
     for (int i = 0; i < length; i++) {
       if (((byte) i) == TS_SYNC_BYTE) {
         out.write(0);
@@ -106,7 +123,46 @@ private static void writeJunkData(ByteArrayOutputStream out, int length) throws
     }
   }
 
-  private static final class CustomEsReader extends ElementaryStreamReader {
+  private static final class CustomTsPayloadReaderFactory implements TsPayloadReader.Factory {
+
+    private final boolean provideSdtReader;
+    private final boolean provideCustomEsReader;
+    private final TsPayloadReader.Factory defaultFactory;
+    private CustomEsReader esReader;
+    private SdtSectionReader sdtReader;
+
+    public CustomTsPayloadReaderFactory(boolean provideCustomEsReader, boolean provideSdtReader) {
+      this.provideCustomEsReader = provideCustomEsReader;
+      this.provideSdtReader = provideSdtReader;
+      defaultFactory = new DefaultTsPayloadReaderFactory();
+    }
+
+    @Override
+    public SparseArray<TsPayloadReader> createInitialPayloadReaders() {
+      if (provideSdtReader) {
+        assertNull(sdtReader);
+        SparseArray<TsPayloadReader> mapping = new SparseArray<>();
+        sdtReader = new SdtSectionReader();
+        mapping.put(17, new SectionReader(sdtReader));
+        return mapping;
+      } else {
+        return defaultFactory.createInitialPayloadReaders();
+      }
+    }
+
+    @Override
+    public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
+      if (provideCustomEsReader && streamType == 3) {
+        esReader = new CustomEsReader(esInfo.language);
+        return new PesReader(esReader);
+      } else {
+        return defaultFactory.createPayloadReader(streamType, esInfo);
+      }
+    }
+
+  }
+
+  private static final class CustomEsReader implements ElementaryStreamReader {
 
     private final String language;
     private TrackOutput output;
@@ -121,7 +177,7 @@ public void seek() {
     }
 
     @Override
-    public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
       output = extractorOutput.track(idGenerator.getNextId());
       output.format(Format.createTextSampleFormat("Overriding format", "mime", null, 0, 0,
           language, null, 0));
@@ -146,23 +202,44 @@ public TrackOutput getTrackOutput() {
 
   }
 
-  private static final class CustomEsReaderFactory implements ElementaryStreamReader.Factory {
+  private static final class SdtSectionReader implements SectionPayloadReader {
 
-    private final ElementaryStreamReader.Factory defaultFactory;
-    private CustomEsReader reader;
+    private int consumedSdts;
 
-    public CustomEsReaderFactory() {
-      defaultFactory = new DefaultStreamReaderFactory();
+    @Override
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TrackIdGenerator idGenerator) {
+      // Do nothing.
     }
 
     @Override
-    public ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo) {
-      if (streamType == 3) {
-        reader = new CustomEsReader(esInfo.language);
-        return reader;
-      } else {
-        return defaultFactory.createStreamReader(streamType, esInfo);
+    public void consume(ParsableByteArray sectionData) {
+      // table_id(8), section_syntax_indicator(1), reserved_future_use(1), reserved(2),
+      // section_length(12), transport_stream_id(16), reserved(2), version_number(5),
+      // current_next_indicator(1), section_number(8), last_section_number(8),
+      // original_network_id(16), reserved_future_use(8)
+      sectionData.skipBytes(11);
+      // Start of the service loop.
+      assertEquals(0x5566 /* arbitrary service id */, sectionData.readUnsignedShort());
+      // reserved_future_use(6), EIT_schedule_flag(1), EIT_present_following_flag(1)
+      sectionData.skipBytes(1);
+      // Assert there is only one service.
+      // Remove running_status(3), free_CA_mode(1) from the descriptors_loop_length with the mask.
+      assertEquals(sectionData.readUnsignedShort() & 0xFFF, sectionData.bytesLeft());
+      while (sectionData.bytesLeft() > 0) {
+        int descriptorTag = sectionData.readUnsignedByte();
+        int descriptorLength = sectionData.readUnsignedByte();
+        if (descriptorTag == 72 /* service descriptor */) {
+          assertEquals(1, sectionData.readUnsignedByte()); // Service type: Digital TV.
+          int serviceProviderNameLength = sectionData.readUnsignedByte();
+          assertEquals("Some provider", sectionData.readString(serviceProviderNameLength));
+          int serviceNameLength = sectionData.readUnsignedByte();
+          assertEquals("Some Channel", sectionData.readString(serviceNameLength));
+        } else {
+          sectionData.skipBytes(descriptorLength);
+        }
       }
+      consumedSdts++;
     }
 
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
new file mode 100644
index 0000000000..b33dfd1067
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import java.nio.ByteBuffer;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessageDecoder}.
+ */
+public final class EventMessageDecoderTest extends TestCase {
+
+  public void testDecodeEventMessage() {
+    byte[] rawEmsgBody = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, 0, 0, // presentation_time_delta (ignored) = 0
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -45, // id = 1000403
+        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    EventMessageDecoder decoder = new EventMessageDecoder();
+    MetadataInputBuffer buffer = new MetadataInputBuffer();
+    buffer.data = ByteBuffer.allocate(rawEmsgBody.length).put(rawEmsgBody);
+    Metadata metadata = decoder.decode(buffer);
+    assertEquals(1, metadata.length());
+    EventMessage eventMessage = (EventMessage) metadata.get(0);
+    assertEquals("urn:test", eventMessage.schemeIdUri);
+    assertEquals("123", eventMessage.value);
+    assertEquals(3000, eventMessage.durationMs);
+    assertEquals(1000403, eventMessage.id);
+    MoreAsserts.assertEquals(new byte[] {0, 1, 2, 3, 4}, eventMessage.messageData);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
new file mode 100644
index 0000000000..baafb6b18b
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessage}.
+ */
+public final class EventMessageTest extends TestCase {
+
+  public void testEventMessageParcelable() {
+    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4});
+    // Write to parcel.
+    Parcel parcel = Parcel.obtain();
+    eventMessage.writeToParcel(parcel, 0);
+    // Create from parcel.
+    parcel.setDataPosition(0);
+    EventMessage fromParcelEventMessage = EventMessage.CREATOR.createFromParcel(parcel);
+    // Assert equals.
+    assertEquals(eventMessage, fromParcelEventMessage);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
new file mode 100644
index 0000000000..182ae6f1c9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterFrame}.
+ */
+public final class ChapterFrameTest extends TestCase {
+
+  public void testParcelable() {
+    Id3Frame[] subFrames = new Id3Frame[] {
+      new TextInformationFrame("TIT2", null, "title"),
+      new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterFrame chapterFrameToParcel = new ChapterFrame("id", 0, 1, 2, 3, subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterFrame chapterFrameFromParcel = ChapterFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterFrameToParcel, chapterFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
new file mode 100644
index 0000000000..9641de7669
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterTocFrame}.
+ */
+public final class ChapterTocFrameTest extends TestCase {
+
+  public void testParcelable() {
+    String[] children = new String[] {"child0", "child1"};
+    Id3Frame[] subFrames = new Id3Frame[] {
+        new TextInformationFrame("TIT2", null, "title"),
+        new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterTocFrame chapterTocFrameToParcel = new ChapterTocFrame("id", false, true, children,
+        subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterTocFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterTocFrame chapterTocFrameFromParcel = ChapterTocFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterTocFrameToParcel, chapterTocFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index f9ec1ee92b..e271108ce4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -16,25 +16,26 @@
 package com.google.android.exoplayer2.metadata.id3;
 
 import android.test.MoreAsserts;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoderException;
-import java.util.List;
 import junit.framework.TestCase;
 
 /**
- * Test for {@link Id3Decoder}
+ * Test for {@link Id3Decoder}.
  */
-public class Id3DecoderTest extends TestCase {
+public final class Id3DecoderTest extends TestCase {
 
   public void testDecodeTxxxFrame() throws MetadataDecoderException {
     byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31, 0, 0,
         3, 0, 109, 100, 105, 97, 108, 111, 103, 95, 86, 73, 78, 68, 73, 67, 79, 49, 53, 50, 55, 54,
         54, 52, 95, 115, 116, 97, 114, 116, 0};
     Id3Decoder decoder = new Id3Decoder();
-    List<Id3Frame> id3Frames = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, id3Frames.size());
-    TxxxFrame txxxFrame = (TxxxFrame) id3Frames.get(0);
-    assertEquals("", txxxFrame.description);
-    assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
+    assertEquals("TXXX", textInformationFrame.id);
+    assertEquals("", textInformationFrame.description);
+    assertEquals("mdialog_VINDICO1527664_start", textInformationFrame.value);
   }
 
   public void testDecodeApicFrame() throws MetadataDecoderException {
@@ -42,9 +43,9 @@ public void testDecodeApicFrame() throws MetadataDecoderException {
         3, 105, 109, 97, 103, 101, 47, 106, 112, 101, 103, 0, 16, 72, 101, 108, 108, 111, 32, 87,
         111, 114, 108, 100, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
     Id3Decoder decoder = new Id3Decoder();
-    List<Id3Frame> id3Frames = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, id3Frames.size());
-    ApicFrame apicFrame = (ApicFrame) id3Frames.get(0);
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    ApicFrame apicFrame = (ApicFrame) metadata.get(0);
     assertEquals("image/jpeg", apicFrame.mimeType);
     assertEquals(16, apicFrame.pictureType);
     assertEquals("Hello World", apicFrame.description);
@@ -56,11 +57,23 @@ public void testDecodeTextInformationFrame() throws MetadataDecoderException {
     byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 23, 84, 73, 84, 50, 0, 0, 0, 13, 0, 0,
         3, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0};
     Id3Decoder decoder = new Id3Decoder();
-    List<Id3Frame> id3Frames = decoder.decode(rawId3, rawId3.length);
-    assertEquals(1, id3Frames.size());
-    TextInformationFrame textInformationFrame = (TextInformationFrame) id3Frames.get(0);
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
     assertEquals("TIT2", textInformationFrame.id);
-    assertEquals("Hello World", textInformationFrame.description);
+    assertNull(textInformationFrame.description);
+    assertEquals("Hello World", textInformationFrame.value);
+  }
+
+  public void testDecodePrivFrame() throws MetadataDecoderException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 19, 80, 82, 73, 86, 0, 0, 0, 9, 0, 0,
+        116, 101, 115, 116, 0, 1, 2, 3, 4};
+    Id3Decoder decoder = new Id3Decoder();
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    PrivFrame privFrame = (PrivFrame) metadata.get(0);
+    assertEquals("test", privFrame.owner);
+    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4}, privFrame.privateData);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
new file mode 100644
index 0000000000..c50ff06699
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoderException;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
+import java.util.List;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link SpliceInfoDecoder}.
+ */
+public final class SpliceInfoDecoderTest extends TestCase {
+
+  private SpliceInfoDecoder decoder;
+  private MetadataInputBuffer inputBuffer;
+
+  @Override
+  public void setUp() {
+    decoder = new SpliceInfoDecoder();
+    inputBuffer = new MetadataInputBuffer();
+  }
+
+  public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException {
+    byte[] rawTimeSignalSection = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x14, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x05, // splice_command_length(8).
+        0x06, // splice_command_type = time_signal.
+        // Start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x52, 0x03, 0x02, (byte) 0x8f, // pts_time(32). PTS for a second after playback position.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // The playback position is 57:15:58.43 approximately.
+    // With this offset, the playback position pts before wrapping is 0x451ebf851.
+    Metadata metadata = feedInputBuffer(rawTimeSignalSection, 0x3000000000L, -0x50000L);
+    assertEquals(1, metadata.length());
+    assertEquals(removePtsConversionPrecisionError(0x3001000000L, inputBuffer.subsampleOffsetUs),
+        ((TimeSignalCommand) metadata.get(0)).playbackPositionUs);
+  }
+
+  public void test2SpliceInsertCommands() throws MetadataDecoderException {
+    byte[] rawSpliceInsertCommand1 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x19, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x0e, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        0x00, 0x00, 0x00, 0x42, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x40, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        // start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x00, 0x00, 0x00, 0x00, // PTS for playback position 3s.
+        0x00, 0x10, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    Metadata metadata = feedInputBuffer(rawSpliceInsertCommand1, 2000000, 3000000);
+    assertEquals(1, metadata.length());
+    SpliceInsertCommand command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(66, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertTrue(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(3000000, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    assertEquals(16, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+
+    byte[] rawSpliceInsertCommand2 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x22, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x13, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x00, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        0x02, // component_count.
+        0x10, // component_tag.
+        // start of splice_time().
+        (byte) 0x81, // time_specified_flag, reserved, pts_time(1).
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // PTS for playback position 10s.
+        // start of splice_time().
+        0x11, // component_tag.
+        0x00, // time_specified_flag, reserved.
+        0x00, 0x20, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // By changing the subsample offset we force adjuster reconstruction.
+    long subsampleOffset = 1000011;
+    metadata = feedInputBuffer(rawSpliceInsertCommand2, 1000000, subsampleOffset);
+    assertEquals(1, metadata.length());
+    command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(0xffffffffL, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertFalse(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(C.TIME_UNSET, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    List<SpliceInsertCommand.ComponentSplice> componentSplices = command.componentSpliceList;
+    assertEquals(2, componentSplices.size());
+    assertEquals(16, componentSplices.get(0).componentTag);
+    assertEquals(1000000, componentSplices.get(0).componentSplicePlaybackPositionUs);
+    assertEquals(17, componentSplices.get(1).componentTag);
+    assertEquals(C.TIME_UNSET, componentSplices.get(1).componentSplicePts);
+    assertEquals(32, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+  }
+
+  private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset)
+      throws MetadataDecoderException{
+    inputBuffer.clear();
+    inputBuffer.data = ByteBuffer.allocate(data.length).put(data);
+    inputBuffer.timeUs = timeUs;
+    inputBuffer.subsampleOffsetUs = subsampleOffset;
+    return decoder.decode(inputBuffer);
+  }
+
+  private static long removePtsConversionPrecisionError(long timeUs, long offsetUs) {
+    return TimestampAdjuster.ptsToUs(TimestampAdjuster.usToPts(timeUs - offsetUs)) + offsetUs;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
new file mode 100644
index 0000000000..0933fb858b
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static org.mockito.Mockito.doAnswer;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.MediaSource.Listener;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Unit tests for {@link ClippingMediaSource}.
+ */
+public final class ClippingMediaSourceTest extends InstrumentationTestCase {
+
+  private static final long TEST_PERIOD_DURATION_US = 1000000;
+  private static final long TEST_CLIP_AMOUNT_US = 300000;
+
+  @Mock
+  private MediaSource mockMediaSource;
+  private Timeline clippedTimeline;
+  private Window window;
+  private Period period;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+    window = new Timeline.Window();
+    period = new Timeline.Period();
+  }
+
+  public void testNoClipping() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+
+    assertEquals(1, clippedTimeline.getWindowCount());
+    assertEquals(1, clippedTimeline.getPeriodCount());
+    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingUnseekableWindowThrows() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), false);
+
+    // If the unseekable window isn't clipped, clipping succeeds.
+    getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+    try {
+      // If the unseekable window is clipped, clipping fails.
+      getClippedTimeline(timeline, 1, TEST_PERIOD_DURATION_US);
+      fail("Expected clipping to fail.");
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+  public void testClippingStart() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
+        TEST_PERIOD_DURATION_US);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingEnd() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, 0,
+        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingStartAndEnd() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
+        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 2);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  /**
+   * Wraps the specified timeline in a {@link ClippingMediaSource} and returns the clipped timeline.
+   */
+  private Timeline getClippedTimeline(Timeline timeline, long startMs, long endMs) {
+    mockMediaSourceSourceWithTimeline(timeline);
+    new ClippingMediaSource(mockMediaSource, startMs, endMs).prepareSource(null, true,
+        new Listener() {
+          @Override
+          public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+            clippedTimeline = timeline;
+          }
+        });
+    return clippedTimeline;
+  }
+
+  /**
+   * Returns a mock {@link MediaSource} with the specified {@link Timeline} in its source info.
+   */
+  private MediaSource mockMediaSourceSourceWithTimeline(final Timeline timeline) {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        MediaSource.Listener listener = (MediaSource.Listener) invocation.getArguments()[2];
+        listener.onSourceInfoRefreshed(timeline, null);
+        return null;
+      }
+    }).when(mockMediaSource).prepareSource(Mockito.any(ExoPlayer.class), Mockito.anyBoolean(),
+        Mockito.any(MediaSource.Listener.class));
+    return mockMediaSource;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 66ee298daf..4de0ae4081 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -17,8 +17,11 @@
 
 import android.net.Uri;
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Unit tests for {@link DashManifestParser}.
@@ -28,6 +31,8 @@
   private static final String SAMPLE_MPD_1 = "dash/sample_mpd_1";
   private static final String SAMPLE_MPD_2_UNKNOWN_MIME_TYPE =
       "dash/sample_mpd_2_unknown_mime_type";
+  private static final String SAMPLE_MPD_3_SEGMENT_TEMPLATE =
+      "dash/sample_mpd_3_segment_template";
 
   /**
    * Simple test to ensure the sample manifests parse without any exceptions being thrown.
@@ -40,4 +45,84 @@ public void testParseMediaPresentationDescription() throws IOException {
         TestUtil.getInputStream(getInstrumentation(), SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
   }
 
+  public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest mpd = parser.parse(Uri.parse("https://example.com/test.mpd"),
+        TestUtil.getInputStream(getInstrumentation(), SAMPLE_MPD_3_SEGMENT_TEMPLATE));
+
+    assertEquals(1, mpd.getPeriodCount());
+
+    Period period = mpd.getPeriod(0);
+    assertNotNull(period);
+    assertEquals(2, period.adaptationSets.size());
+
+    for (AdaptationSet adaptationSet : period.adaptationSets) {
+      assertNotNull(adaptationSet);
+      for (Representation representation : adaptationSet.representations) {
+        if (representation instanceof Representation.MultiSegmentRepresentation) {
+          Representation.MultiSegmentRepresentation multiSegmentRepresentation =
+              (Representation.MultiSegmentRepresentation) representation;
+          int firstSegmentIndex = multiSegmentRepresentation.getFirstSegmentNum();
+          RangedUri uri = multiSegmentRepresentation.getSegmentUrl(firstSegmentIndex);
+          assertTrue(uri.resolveUriString(representation.baseUrl).contains(
+              "redirector.googlevideo.com"));
+        }
+      }
+    }
+  }
+
+  public void testParseCea608AccessibilityChannel() {
+    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC1=eng")));
+    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC2=eng")));
+    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC3=eng")));
+    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC4=eng")));
+
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC0=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC5=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("Wrong format")));
+  }
+
+  public void testParseCea708AccessibilityChannel() {
+    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("1=lang:eng")));
+    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("2=lang:eng")));
+    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("3=lang:eng")));
+    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("62=lang:eng")));
+    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("63=lang:eng")));
+
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("0=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("64=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("Wrong format")));
+  }
+
+  private static List<SchemeValuePair> buildCea608AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-608:2015", value));
+  }
+
+  private static List<SchemeValuePair> buildCea708AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-708:2015", value));
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
index 59e1c14a33..fd559381fa 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
@@ -23,56 +23,64 @@
  */
 public class RangedUriTest extends TestCase {
 
-  private static final String FULL_URI = "http://www.test.com/path/file.ext";
+  private static final String BASE_URI = "http://www.test.com/";
+  private static final String PARTIAL_URI = "path/file.ext";
+  private static final String FULL_URI = BASE_URI + PARTIAL_URI;
 
   public void testMerge() {
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, 10);
-    RangedUri expected = new RangedUri(null, FULL_URI, 0, 20);
-    assertMerge(rangeA, rangeB, expected);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
+    RangedUri expected = new RangedUri(FULL_URI, 0, 20);
+    assertMerge(rangeA, rangeB, expected, null);
   }
 
   public void testMergeUnbounded() {
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 10, C.LENGTH_UNSET);
-    RangedUri expected = new RangedUri(null, FULL_URI, 0, C.LENGTH_UNSET);
-    assertMerge(rangeA, rangeB, expected);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, C.LENGTH_UNSET);
+    RangedUri expected = new RangedUri(FULL_URI, 0, C.LENGTH_UNSET);
+    assertMerge(rangeA, rangeB, expected, null);
   }
 
   public void testNonMerge() {
     // A and B do not overlap, so should not merge
-    RangedUri rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    RangedUri rangeB = new RangedUri(null, FULL_URI, 11, 10);
-    assertNonMerge(rangeA, rangeB);
+    RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 11, 10);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B do not overlap, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, 10);
-    rangeB = new RangedUri(null, FULL_URI, 11, C.LENGTH_UNSET);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, 10);
+    rangeB = new RangedUri(FULL_URI, 11, C.LENGTH_UNSET);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B are bounded but overlap, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, 11);
-    rangeB = new RangedUri(null, FULL_URI, 10, 10);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, 11);
+    rangeB = new RangedUri(FULL_URI, 10, 10);
+    assertNonMerge(rangeA, rangeB, null);
 
     // A and B overlap due to unboundedness, so should not merge
-    rangeA = new RangedUri(null, FULL_URI, 0, C.LENGTH_UNSET);
-    rangeB = new RangedUri(null, FULL_URI, 10, C.LENGTH_UNSET);
-    assertNonMerge(rangeA, rangeB);
+    rangeA = new RangedUri(FULL_URI, 0, C.LENGTH_UNSET);
+    rangeB = new RangedUri(FULL_URI, 10, C.LENGTH_UNSET);
+    assertNonMerge(rangeA, rangeB, null);
+  }
 
+  public void testMergeWithBaseUri() {
+    RangedUri rangeA = new RangedUri(PARTIAL_URI, 0, 10);
+    RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
+    RangedUri expected = new RangedUri(FULL_URI, 0, 20);
+    assertMerge(rangeA, rangeB, expected, BASE_URI);
   }
 
-  private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected) {
-    RangedUri merged = rangeA.attemptMerge(rangeB);
+  private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected, String baseUrl) {
+    RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
     assertEquals(expected, merged);
-    merged = rangeB.attemptMerge(rangeA);
+    merged = rangeB.attemptMerge(rangeA, baseUrl);
     assertEquals(expected, merged);
   }
 
-  private void assertNonMerge(RangedUri rangeA, RangedUri rangeB) {
-    RangedUri merged = rangeA.attemptMerge(rangeB);
+  private void assertNonMerge(RangedUri rangeA, RangedUri rangeB, String baseUrl) {
+    RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
     assertNull(merged);
-    merged = rangeB.attemptMerge(rangeA);
+    merged = rangeB.attemptMerge(rangeA, baseUrl);
     assertNull(merged);
   }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
index 681969ffa2..5d10aba1ae 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
@@ -27,16 +27,17 @@
 
   public void testGetCacheKey() {
     String uri = "http://www.google.com";
-    SegmentBase base = new SingleSegmentBase(new RangedUri(uri, null, 0, 1), 1, 0, uri, 1, 1);
+    SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
     Format format = Format.createVideoContainerFormat("0", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
-    Representation representation = Representation.newInstance("test_stream_1", 3, format, base);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
+    Representation representation = Representation.newInstance("test_stream_1", 3, format, uri,
+        base);
     assertEquals("test_stream_1.0.3", representation.getCacheKey());
 
     format = Format.createVideoContainerFormat("150", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
     representation = Representation.newInstance("test_stream_1", Representation.REVISION_ID_DEFAULT,
-        format, base);
+        format, uri, base);
     assertEquals("test_stream_1.150.-1", representation.getCacheKey());
   }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 488341d4f3..f0adf274ee 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -29,70 +30,86 @@
  */
 public class HlsMasterPlaylistParserTest extends TestCase {
 
-  public void testParseMasterPlaylist() {
-    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
-    String playlistString = "#EXTM3U\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-        + "http://example.com/low.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
-        + "http://example.com/spaces_in_codecs.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
-        + "http://example.com/mid.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
-        + "http://example.com/hi.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
-        + "http://example.com/audio-only.m3u8";
-    ByteArrayInputStream inputStream = new ByteArrayInputStream(
-        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+  private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
+
+  private static final String MASTER_PLAYLIST = " #EXTM3U \n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+      + "http://example.com/spaces_in_codecs.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
+      + "http://example.com/mid.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
+      + "http://example.com/hi.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
+      + "http://example.com/audio-only.m3u8";
+
+  private static final String PLAYLIST_WITH_INVALID_HEADER = "#EXTMU3\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n";
+
+  public void testParseMasterPlaylist() throws IOException{
+    HlsPlaylist playlist = parsePlaylist(PLAYLIST_URI, MASTER_PLAYLIST);
+    assertNotNull(playlist);
+    assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
+
+    HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+
+    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    assertNotNull(variants);
+    assertEquals(5, variants.size());
+
+    assertEquals(1280000, variants.get(0).format.bitrate);
+    assertNotNull(variants.get(0).format.codecs);
+    assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
+    assertEquals(304, variants.get(0).format.width);
+    assertEquals(128, variants.get(0).format.height);
+    assertEquals("http://example.com/low.m3u8", variants.get(0).url);
+
+    assertEquals(1280000, variants.get(1).format.bitrate);
+    assertNotNull(variants.get(1).format.codecs);
+    assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
+    assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
+
+    assertEquals(2560000, variants.get(2).format.bitrate);
+    assertEquals(null, variants.get(2).format.codecs);
+    assertEquals(384, variants.get(2).format.width);
+    assertEquals(160, variants.get(2).format.height);
+    assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
+
+    assertEquals(7680000, variants.get(3).format.bitrate);
+    assertEquals(null, variants.get(3).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.height);
+    assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
+
+    assertEquals(65000, variants.get(4).format.bitrate);
+    assertNotNull(variants.get(4).format.codecs);
+    assertEquals("mp4a.40.5", variants.get(4).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.height);
+    assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
+  }
+
+  public void testPlaylistWithInvalidHeader() throws IOException {
     try {
-      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
-      assertNotNull(playlist);
-      assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
-
-      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
-
-      List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
-      assertNotNull(variants);
-      assertEquals(5, variants.size());
-
-      assertEquals(1280000, variants.get(0).format.bitrate);
-      assertNotNull(variants.get(0).format.codecs);
-      assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
-      assertEquals(304, variants.get(0).format.width);
-      assertEquals(128, variants.get(0).format.height);
-      assertEquals("http://example.com/low.m3u8", variants.get(0).url);
-
-      assertEquals(1280000, variants.get(1).format.bitrate);
-      assertNotNull(variants.get(1).format.codecs);
-      assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
-      assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
-
-      assertEquals(2560000, variants.get(2).format.bitrate);
-      assertEquals(null, variants.get(2).format.codecs);
-      assertEquals(384, variants.get(2).format.width);
-      assertEquals(160, variants.get(2).format.height);
-      assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
-
-      assertEquals(7680000, variants.get(3).format.bitrate);
-      assertEquals(null, variants.get(3).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.height);
-      assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
-
-      assertEquals(65000, variants.get(4).format.bitrate);
-      assertNotNull(variants.get(4).format.codecs);
-      assertEquals("mp4a.40.5", variants.get(4).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.height);
-      assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
-    } catch (IOException exception) {
-      fail(exception.getMessage());
+      parsePlaylist(PLAYLIST_URI, PLAYLIST_WITH_INVALID_HEADER);
+      fail("Expected exception not thrown.");
+    } catch (ParserException e) {
+      // Expected due to invalid header.
     }
   }
 
+  private static HlsPlaylist parsePlaylist(String uri, String playlistString) throws IOException {
+    Uri playlistUri = Uri.parse(uri);
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(
+        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    return new HlsPlaylistParser().parse(playlistUri, inputStream);
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index cd44a283a2..4286a283c0 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,6 +35,7 @@ public void testParseMediaPlaylist() {
     Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
     String playlistString = "#EXTM3U\n"
         + "#EXT-X-VERSION:3\n"
+        + "#EXT-X-PLAYLIST-TYPE:VOD\n"
         + "#EXT-X-TARGETDURATION:8\n"
         + "#EXT-X-MEDIA-SEQUENCE:2679\n"
         + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
@@ -70,63 +72,68 @@ public void testParseMediaPlaylist() {
       assertEquals(HlsPlaylist.TYPE_MEDIA, playlist.type);
 
       HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+      assertEquals(HlsMediaPlaylist.PLAYLIST_TYPE_VOD, mediaPlaylist.playlistType);
 
       assertEquals(2679, mediaPlaylist.mediaSequence);
-      assertEquals(8, mediaPlaylist.targetDurationSecs);
       assertEquals(3, mediaPlaylist.version);
-      assertEquals(false, mediaPlaylist.live);
-      List<HlsMediaPlaylist.Segment> segments = mediaPlaylist.segments;
+      assertTrue(mediaPlaylist.hasEndTag);
+      List<Segment> segments = mediaPlaylist.segments;
       assertNotNull(segments);
       assertEquals(5, segments.size());
 
-      assertEquals(4, segments.get(0).discontinuitySequenceNumber);
-      assertEquals(7.975, segments.get(0).durationSecs);
-      assertEquals(false, segments.get(0).isEncrypted);
-      assertEquals(null, segments.get(0).encryptionKeyUri);
-      assertEquals(null, segments.get(0).encryptionIV);
-      assertEquals(51370, segments.get(0).byterangeLength);
-      assertEquals(0, segments.get(0).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2679.ts", segments.get(0).url);
+      Segment segment = segments.get(0);
+      assertEquals(4, mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51370, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2679.ts", segment.url);
 
-      assertEquals(4, segments.get(1).discontinuitySequenceNumber);
-      assertEquals(7.975, segments.get(1).durationSecs);
-      assertEquals(true, segments.get(1).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
-      assertEquals("0x1566B", segments.get(1).encryptionIV);
-      assertEquals(51501, segments.get(1).byterangeLength);
-      assertEquals(2147483648L, segments.get(1).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
+      segment = segments.get(1);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2680", segment.encryptionKeyUri);
+      assertEquals("0x1566B", segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147483648L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2680.ts", segment.url);
 
-      assertEquals(4, segments.get(2).discontinuitySequenceNumber);
-      assertEquals(7.941, segments.get(2).durationSecs);
-      assertEquals(false, segments.get(2).isEncrypted);
-      assertEquals(null, segments.get(2).encryptionKeyUri);
-      assertEquals(null, segments.get(2).encryptionIV);
-      assertEquals(51501, segments.get(2).byterangeLength);
-      assertEquals(2147535149L, segments.get(2).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
+      segment = segments.get(2);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7941000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147535149L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2681.ts", segment.url);
 
-      assertEquals(5, segments.get(3).discontinuitySequenceNumber);
-      assertEquals(7.975, segments.get(3).durationSecs);
-      assertEquals(true, segments.get(3).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(3).encryptionKeyUri);
+      segment = segments.get(3);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7A == 2682.
-      assertNotNull(segments.get(3).encryptionIV);
-      assertEquals("A7A", segments.get(3).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(51740, segments.get(3).byterangeLength);
-      assertEquals(2147586650L, segments.get(3).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7A", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(51740, segment.byterangeLength);
+      assertEquals(2147586650L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2682.ts", segment.url);
 
-      assertEquals(5, segments.get(4).discontinuitySequenceNumber);
-      assertEquals(7.975, segments.get(4).durationSecs);
-      assertEquals(true, segments.get(4).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(4).encryptionKeyUri);
+      segment = segments.get(4);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7B == 2683.
-      assertNotNull(segments.get(4).encryptionIV);
-      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(C.LENGTH_UNSET, segments.get(4).byterangeLength);
-      assertEquals(0, segments.get(4).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2683.ts", segments.get(4).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7B", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(C.LENGTH_UNSET, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2683.ts", segment.url);
     } catch (IOException exception) {
       fail(exception.getMessage());
     }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
index eca126347c..502fa9a789 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
@@ -30,6 +30,7 @@
   private static final String TYPICAL_EXTRA_BLANK_LINE = "subrip/typical_extra_blank_line";
   private static final String TYPICAL_MISSING_TIMECODE = "subrip/typical_missing_timecode";
   private static final String TYPICAL_MISSING_SEQUENCE = "subrip/typical_missing_sequence";
+  private static final String TYPICAL_NEGATIVE_TIMESTAMPS = "subrip/typical_negative_timestamps";
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
   public void testDecodeEmpty() throws IOException {
@@ -91,6 +92,15 @@ public void testDecodeTypicalMissingSequence() throws IOException {
     assertTypicalCue3(subtitle, 2);
   }
 
+  public void testDecodeTypicalNegativeTimestamps() throws IOException {
+    // Parsing should succeed, parsing the third cue only.
+    SubripDecoder decoder = new SubripDecoder();
+    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_NEGATIVE_TIMESTAMPS);
+    SubripSubtitle subtitle = decoder.decode(bytes, bytes.length);
+    assertEquals(2, subtitle.getEventTimeCount());
+    assertTypicalCue3(subtitle, 0);
+  }
+
   public void testDecodeNoEndTimecodes() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
     byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_END_TIMECODES_FILE);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
index 9f52453908..a0feaea57d 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
@@ -97,7 +97,7 @@ public void testTwoCuesSample() throws SubtitleDecoderException {
   public void testNoCueSample() throws SubtitleDecoderException {
     Mp4WebvttDecoder decoder = new Mp4WebvttDecoder();
     Subtitle result = decoder.decode(NO_CUE_SAMPLE, NO_CUE_SAMPLE.length);
-    assertMp4WebvttSubtitleEquals(result, new Cue[0]);
+    assertMp4WebvttSubtitleEquals(result);
   }
 
   // Negative tests.
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
index 013e82bd85..6ed0518e3c 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
@@ -116,7 +116,7 @@ public void testDecodeWithPositioning() throws IOException, SubtitleDecoderExcep
         Alignment.ALIGN_CENTER, 0.45f, Cue.LINE_TYPE_FRACTION, Cue.ANCHOR_TYPE_END, Cue.DIMEN_UNSET,
         Cue.TYPE_UNSET, 0.35f);
     assertCue(subtitle, 6, 6000000, 7000000, "This is the fourth subtitle.",
-        Alignment.ALIGN_CENTER, -10f, Cue.LINE_TYPE_NUMBER, Cue.TYPE_UNSET, Cue.DIMEN_UNSET,
+        Alignment.ALIGN_CENTER, -11f, Cue.LINE_TYPE_NUMBER, Cue.TYPE_UNSET, Cue.DIMEN_UNSET,
         Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
     assertCue(subtitle, 8, 7000000, 8000000, "This is the fifth subtitle.",
         Alignment.ALIGN_OPPOSITE, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, 0.1f,
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
new file mode 100644
index 0000000000..3200e9d6a3
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.IOException;
+import java.util.Arrays;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link DataSourceInputStream}.
+ */
+public class DataSourceInputStreamTest extends TestCase {
+
+  private static final byte[] TEST_DATA = TestUtil.buildTestData(16);
+
+  public void testReadSingleBytes() throws IOException {
+    DataSourceInputStream inputStream = buildTestInputStream();
+    // No bytes read yet.
+    assertEquals(0, inputStream.bytesRead());
+    // Read bytes.
+    for (int i = 0; i < TEST_DATA.length; i++) {
+      int readByte = inputStream.read();
+      assertTrue(0 <= readByte && readByte < 256);
+      assertEquals(TEST_DATA[i] & 0xFF, readByte);
+      assertEquals(i + 1, inputStream.bytesRead());
+    }
+    // Check end of stream.
+    assertEquals(-1, inputStream.read());
+    assertEquals(TEST_DATA.length, inputStream.bytesRead());
+    // Check close succeeds.
+    inputStream.close();
+  }
+
+  public void testRead() throws IOException {
+    DataSourceInputStream inputStream = buildTestInputStream();
+    // Read bytes.
+    byte[] readBytes = new byte[TEST_DATA.length];
+    int totalBytesRead = 0;
+    while (totalBytesRead < TEST_DATA.length) {
+      long bytesRead = inputStream.read(readBytes, totalBytesRead,
+          TEST_DATA.length - totalBytesRead);
+      assertTrue(bytesRead > 0);
+      totalBytesRead += bytesRead;
+      assertEquals(totalBytesRead, inputStream.bytesRead());
+    }
+    // Check the read data.
+    MoreAsserts.assertEquals(TEST_DATA, readBytes);
+    // Check end of stream.
+    assertEquals(TEST_DATA.length, inputStream.bytesRead());
+    assertEquals(TEST_DATA.length, totalBytesRead);
+    assertEquals(-1, inputStream.read());
+    // Check close succeeds.
+    inputStream.close();
+  }
+
+  public void testSkip() throws IOException {
+    DataSourceInputStream inputStream = buildTestInputStream();
+    // Skip bytes.
+    long totalBytesSkipped = 0;
+    while (totalBytesSkipped < TEST_DATA.length) {
+      long bytesSkipped = inputStream.skip(Long.MAX_VALUE);
+      assertTrue(bytesSkipped > 0);
+      totalBytesSkipped += bytesSkipped;
+      assertEquals(totalBytesSkipped, inputStream.bytesRead());
+    }
+    // Check end of stream.
+    assertEquals(TEST_DATA.length, inputStream.bytesRead());
+    assertEquals(TEST_DATA.length, totalBytesSkipped);
+    assertEquals(-1, inputStream.read());
+    // Check close succeeds.
+    inputStream.close();
+  }
+
+  private static DataSourceInputStream buildTestInputStream() {
+    FakeDataSource.Builder fakeDataSourceBuilder = new FakeDataSource.Builder()
+        .appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 5))
+        .appendReadData(Arrays.copyOfRange(TEST_DATA, 5, 10))
+        .appendReadData(Arrays.copyOfRange(TEST_DATA, 10, 15))
+        .appendReadData(Arrays.copyOfRange(TEST_DATA, 15, TEST_DATA.length));
+    return new DataSourceInputStream(fakeDataSourceBuilder.build(), new DataSpec(null));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 5e85ad4d4c..067cfe4fcd 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -23,12 +23,13 @@
 import com.google.android.exoplayer2.testutil.FakeDataSource.Builder;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.DataSpec;
-
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
 
-/** Unit tests for {@link CacheDataSource}. */
+/**
+ * Unit tests for {@link CacheDataSource}.
+ */
 public class CacheDataSourceTest extends InstrumentationTestCase {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
@@ -41,11 +42,7 @@
 
   @Override
   protected void setUp() throws Exception {
-    // Create a temporary folder
-    cacheDir = File.createTempFile("CacheDataSourceTest", null);
-    assertTrue(cacheDir.delete());
-    assertTrue(cacheDir.mkdir());
-
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
     simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
   }
 
@@ -57,8 +54,12 @@ protected void tearDown() throws Exception {
   public void testMaxCacheFileSize() throws Exception {
     CacheDataSource cacheDataSource = createCacheDataSource(false, false);
     assertReadDataContentLength(cacheDataSource, false, false);
-    assertEquals((int) Math.ceil((double) TEST_DATA.length / MAX_CACHE_FILE_SIZE),
-        cacheDir.listFiles().length);
+    File[] files = cacheDir.listFiles();
+    for (File file : files) {
+      if (!file.getName().equals(CachedContentIndex.FILE_NAME)) {
+        assertTrue(file.length() <= MAX_CACHE_FILE_SIZE);
+      }
+    }
   }
 
   public void testCacheAndRead() throws Exception {
@@ -118,6 +119,13 @@ public void testContentLengthEdgeCases() throws Exception {
         C.LENGTH_UNSET, KEY_2)));
   }
 
+  public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
+    CacheDataSource cacheDataSource = createCacheDataSource(false, true,
+        CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
+    assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
+    MoreAsserts.assertEmpty(simpleCache.getKeys());
+  }
+
   private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
       throws IOException {
     // Read all data from upstream and cache
@@ -170,6 +178,12 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
 
   private CacheDataSource createCacheDataSource(boolean setReadException,
       boolean simulateUnknownLength) {
+    return createCacheDataSource(setReadException, simulateUnknownLength,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE);
+  }
+
+  private CacheDataSource createCacheDataSource(boolean setReadException,
+      boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
     Builder builder = new Builder();
     if (setReadException) {
       builder.appendReadError(new IOException("Shouldn't read from upstream"));
@@ -177,9 +191,7 @@ private CacheDataSource createCacheDataSource(boolean setReadException,
     builder.setSimulateUnknownLength(simulateUnknownLength);
     builder.appendReadData(TEST_DATA);
     FakeDataSource upstream = builder.build();
-    return new CacheDataSource(simpleCache, upstream,
-        CacheDataSource.FLAG_BLOCK_ON_CACHE | CacheDataSource.FLAG_CACHE_UNBOUNDED_REQUESTS,
-        MAX_CACHE_FILE_SIZE);
+    return new CacheDataSource(simpleCache, upstream, flags, MAX_CACHE_FILE_SIZE);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
new file mode 100644
index 0000000000..70a7d797c1
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.content.Context;
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.FileDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSink;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSource;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Additional tests for {@link CacheDataSource}.
+ */
+public class CacheDataSourceTest2 extends AndroidTestCase {
+
+  private static final String EXO_CACHE_DIR = "exo";
+  private static final int EXO_CACHE_MAX_FILESIZE = 128;
+
+  private static final Uri URI = Uri.parse("http://test.com/content");
+  private static final String KEY = "key";
+  private static final byte[] DATA = TestUtil.buildTestData(8 * EXO_CACHE_MAX_FILESIZE + 1);
+
+  // A DataSpec that covers the full file.
+  private static final DataSpec FULL = new DataSpec(URI, 0, DATA.length, KEY);
+
+  private static final int OFFSET_ON_BOUNDARY = EXO_CACHE_MAX_FILESIZE;
+  // A DataSpec that starts at 0 and extends to a cache file boundary.
+  private static final DataSpec END_ON_BOUNDARY = new DataSpec(URI, 0, OFFSET_ON_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_ON_BOUNDARY = new DataSpec(URI, OFFSET_ON_BOUNDARY,
+      DATA.length - OFFSET_ON_BOUNDARY, KEY);
+
+  private static final int OFFSET_OFF_BOUNDARY = EXO_CACHE_MAX_FILESIZE * 2 + 1;
+  // A DataSpec that starts at 0 and extends to just past a cache file boundary.
+  private static final DataSpec END_OFF_BOUNDARY = new DataSpec(URI, 0, OFFSET_OFF_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_OFF_BOUNDARY = new DataSpec(URI, OFFSET_OFF_BOUNDARY,
+      DATA.length - OFFSET_OFF_BOUNDARY, KEY);
+
+  public void testWithoutEncryption() throws IOException {
+    testReads(false);
+  }
+
+  public void testWithEncryption() throws IOException {
+    testReads(true);
+  }
+
+  private void testReads(boolean useEncryption) throws IOException {
+    FakeDataSource upstreamSource = buildFakeUpstreamSource();
+    CacheDataSource source = buildCacheDataSource(getContext(), upstreamSource, useEncryption);
+    // First read, should arrive from upstream.
+    testRead(END_ON_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
+    // Second read, should arrive from upstream.
+    testRead(START_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_OFF_BOUNDARY, DATA.length);
+    // Second read, should arrive part from cache and part from upstream.
+    testRead(END_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_ON_BOUNDARY, OFFSET_OFF_BOUNDARY);
+    // Third read, should arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    // Various reads, should all arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+  }
+
+  private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOException {
+    byte[] scratch = new byte[4096];
+    Random random = new Random(0);
+    source.open(dataSpec);
+    int position = (int) dataSpec.absoluteStreamPosition;
+    int bytesRead = 0;
+    while (bytesRead != C.RESULT_END_OF_INPUT) {
+      int maxBytesToRead = random.nextInt(scratch.length) + 1;
+      bytesRead = source.read(scratch, 0, maxBytesToRead);
+      if (bytesRead != C.RESULT_END_OF_INPUT) {
+        MoreAsserts.assertEquals(Arrays.copyOfRange(DATA, position, position + bytesRead),
+            Arrays.copyOf(scratch, bytesRead));
+        position += bytesRead;
+      }
+    }
+    source.close();
+  }
+
+  /**
+   * Asserts that a single {@link DataSource#open(DataSpec)} call has been made to the upstream
+   * source, with the specified start (inclusive) and end (exclusive) positions.
+   */
+  private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(1, openedDataSpecs.length);
+    assertEquals(start, openedDataSpecs[0].position);
+    assertEquals(start, openedDataSpecs[0].absoluteStreamPosition);
+    assertEquals(end - start, openedDataSpecs[0].length);
+  }
+
+  /**
+   * Asserts that the upstream source was not opened.
+   */
+  private void assertNoOpen(FakeDataSource upstreamSource) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(0, openedDataSpecs.length);
+  }
+
+  private static FakeDataSource buildFakeUpstreamSource() {
+    return new FakeDataSource.Builder().appendReadData(DATA).build();
+  }
+
+  private static CacheDataSource buildCacheDataSource(Context context, DataSource upstreamSource,
+      boolean useAesEncryption) throws CacheException {
+    File cacheDir = context.getExternalCacheDir();
+    Cache cache = new SimpleCache(new File(cacheDir, EXO_CACHE_DIR), new NoOpCacheEvictor());
+    emptyCache(cache);
+
+    // Source and cipher
+    final String secretKey = "testKey:12345678";
+    DataSource file = new FileDataSource();
+    DataSource cacheReadDataSource = useAesEncryption
+        ? new AesCipherDataSource(Util.getUtf8Bytes(secretKey), file) : file;
+
+    // Sink and cipher
+    CacheDataSink cacheSink = new CacheDataSink(cache, EXO_CACHE_MAX_FILESIZE);
+    byte[] scratch = new byte[3897];
+    DataSink cacheWriteDataSink = useAesEncryption
+        ? new AesCipherDataSink(Util.getUtf8Bytes(secretKey), cacheSink, scratch) : cacheSink;
+
+    return new CacheDataSource(cache,
+        upstreamSource,
+        cacheReadDataSource,
+        cacheWriteDataSink,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE,
+        null); // eventListener
+  }
+
+  private static void emptyCache(Cache cache) throws CacheException {
+    for (String key : cache.getKeys()) {
+      for (CacheSpan span : cache.getCachedSpans(key)) {
+        cache.removeSpan(span);
+      }
+    }
+    // Sanity check that the cache really is empty now.
+    assertTrue(cache.getKeys().isEmpty());
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheSpanTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheSpanTest.java
deleted file mode 100644
index 38008c814e..0000000000
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheSpanTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.io.File;
-import java.util.Random;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link CacheSpan}.
- */
-public class CacheSpanTest extends TestCase {
-
-  public void testCacheFile() throws Exception {
-    assertCacheSpan(new File("parent"), "key", 0, 0);
-    assertCacheSpan(new File("parent/"), "key", 1, 2);
-    assertCacheSpan(new File("parent"), "<>:\"/\\|?*%", 1, 2);
-    assertCacheSpan(new File("/"), "key", 1, 2);
-
-    assertNullCacheSpan(new File("parent"), "", 1, 2);
-    assertNullCacheSpan(new File("parent"), "key", -1, 2);
-    assertNullCacheSpan(new File("parent"), "key", 1, -2);
-
-    assertNotNull(CacheSpan.createCacheEntry(new File("/asd%aa.1.2.v2.exo")));
-    assertNull(CacheSpan.createCacheEntry(new File("/asd%za.1.2.v2.exo")));
-
-    assertCacheSpan(new File("parent"),
-        "A newline (line feed) character \n"
-            + "A carriage-return character followed immediately by a newline character \r\n"
-            + "A standalone carriage-return character \r"
-            + "A next-line character \u0085"
-            + "A line-separator character \u2028"
-            + "A paragraph-separator character \u2029", 1, 2);
-  }
-
-  public void testCacheFileNameRandomData() throws Exception {
-    Random random = new Random(0);
-    File parent = new File("parent");
-    for (int i = 0; i < 1000; i++) {
-      String key = TestUtil.buildTestString(1000, random);
-      long offset = Math.abs(random.nextLong());
-      long lastAccessTimestamp = Math.abs(random.nextLong());
-      assertCacheSpan(parent, key, offset, lastAccessTimestamp);
-    }
-  }
-
-  private void assertCacheSpan(File parent, String key, long offset, long lastAccessTimestamp) {
-    File cacheFile = CacheSpan.getCacheFileName(parent, key, offset, lastAccessTimestamp);
-    CacheSpan cacheSpan = CacheSpan.createCacheEntry(cacheFile);
-    String message = cacheFile.toString();
-    assertNotNull(message, cacheSpan);
-    assertEquals(message, parent, cacheFile.getParentFile());
-    assertEquals(message, key, cacheSpan.key);
-    assertEquals(message, offset, cacheSpan.position);
-    assertEquals(message, lastAccessTimestamp, cacheSpan.lastAccessTimestamp);
-  }
-
-  private void assertNullCacheSpan(File parent, String key, long offset,
-      long lastAccessTimestamp) {
-    File cacheFile = CacheSpan.getCacheFileName(parent, key, offset, lastAccessTimestamp);
-    CacheSpan cacheSpan = CacheSpan.createCacheEntry(cacheFile);
-    assertNull(cacheFile.toString(), cacheSpan);
-  }
-
-}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
new file mode 100644
index 0000000000..4fbcc92e3d
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -0,0 +1,232 @@
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Set;
+import junit.framework.AssertionFailedError;
+
+/**
+ * Tests {@link CachedContentIndex}.
+ */
+public class CachedContentIndexTest extends InstrumentationTestCase {
+
+  private final byte[] testIndexV1File = {
+      0, 0, 0, 1, // version
+      0, 0, 0, 0, // flags
+      0, 0, 0, 2, // number_of_CachedContent
+      0, 0, 0, 5, // cache_id
+      0, 5, 65, 66, 67, 68, 69, // cache_key
+      0, 0, 0, 0, 0, 0, 0, 10, // original_content_length
+      0, 0, 0, 2, // cache_id
+      0, 5, 75, 76, 77, 78, 79, // cache_key
+      0, 0, 0, 0, 0, 0, 10, 0, // original_content_length
+      (byte) 0xF6, (byte) 0xFB, 0x50, 0x41 // hashcode_of_CachedContent_array
+  };
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Override
+  public void setUp() throws Exception {
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testAddGetRemove() throws Exception {
+    final String key1 = "key1";
+    final String key2 = "key2";
+    final String key3 = "key3";
+
+    // Add two CachedContents with add methods
+    CachedContent cachedContent1 = new CachedContent(5, key1, 10);
+    index.addNew(cachedContent1);
+    CachedContent cachedContent2 = index.add(key2);
+    assertTrue(cachedContent1.id != cachedContent2.id);
+
+    // add a span
+    File cacheSpanFile = SimpleCacheSpanTest
+        .createCacheSpanFile(cacheDir, cachedContent1.id, 10, 20, 30);
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
+    assertNotNull(span);
+    cachedContent1.addSpan(span);
+
+    // Check if they are added and get method returns null if the key isn't found
+    assertEquals(cachedContent1, index.get(key1));
+    assertEquals(cachedContent2, index.get(key2));
+    assertNull(index.get(key3));
+
+    // test getAll()
+    Collection<CachedContent> cachedContents = index.getAll();
+    assertEquals(2, cachedContents.size());
+    assertTrue(Arrays.asList(cachedContent1, cachedContent2).containsAll(cachedContents));
+
+    // test getKeys()
+    Set<String> keys = index.getKeys();
+    assertEquals(2, keys.size());
+    assertTrue(Arrays.asList(key1, key2).containsAll(keys));
+
+    // test getKeyForId()
+    assertEquals(key1, index.getKeyForId(cachedContent1.id));
+    assertEquals(key2, index.getKeyForId(cachedContent2.id));
+
+    // test remove()
+    index.removeEmpty(key2);
+    index.removeEmpty(key3);
+    assertEquals(cachedContent1, index.get(key1));
+    assertNull(index.get(key2));
+    assertTrue(cacheSpanFile.exists());
+
+    // test removeEmpty()
+    index.addNew(cachedContent2);
+    index.removeEmpty();
+    assertEquals(cachedContent1, index.get(key1));
+    assertNull(index.get(key2));
+    assertTrue(cacheSpanFile.exists());
+  }
+
+  public void testStoreAndLoad() throws Exception {
+    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir));
+  }
+
+  public void testLoadV1() throws Exception {
+    FileOutputStream fos = new FileOutputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+    fos.write(testIndexV1File);
+    fos.close();
+
+    index.load();
+    assertEquals(2, index.getAll().size());
+    assertEquals(5, index.assignIdForKey("ABCDE"));
+    assertEquals(10, index.getContentLength("ABCDE"));
+    assertEquals(2, index.assignIdForKey("KLMNO"));
+    assertEquals(2560, index.getContentLength("KLMNO"));
+  }
+
+  public void testStoreV1() throws Exception {
+    index.addNew(new CachedContent(2, "KLMNO", 2560));
+    index.addNew(new CachedContent(5, "ABCDE", 10));
+
+    index.store();
+
+    byte[] buffer = new byte[testIndexV1File.length];
+    FileInputStream fos = new FileInputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
+    assertEquals(testIndexV1File.length, fos.read(buffer));
+    assertEquals(-1, fos.read());
+    fos.close();
+
+    // TODO: The order of the CachedContent stored in index file isn't defined so this test may fail
+    // on a different implementation of the underlying set
+    MoreAsserts.assertEquals(testIndexV1File, buffer);
+  }
+
+  public void testAssignIdForKeyAndGetKeyForId() throws Exception {
+    final String key1 = "key1";
+    final String key2 = "key2";
+    int id1 = index.assignIdForKey(key1);
+    int id2 = index.assignIdForKey(key2);
+    assertEquals(key1, index.getKeyForId(id1));
+    assertEquals(key2, index.getKeyForId(id2));
+    assertTrue(id1 != id2);
+    assertEquals(id1, index.assignIdForKey(key1));
+    assertEquals(id2, index.assignIdForKey(key2));
+  }
+
+  public void testSetGetContentLength() throws Exception {
+    final String key1 = "key1";
+    assertEquals(C.LENGTH_UNSET, index.getContentLength(key1));
+    index.setContentLength(key1, 10);
+    assertEquals(10, index.getContentLength(key1));
+  }
+
+  public void testGetNewId() throws Exception {
+    SparseArray<String> idToKey = new SparseArray<>();
+    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(10, "");
+    assertEquals(11, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(Integer.MAX_VALUE, "");
+    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    idToKey.put(0, "");
+    assertEquals(1, CachedContentIndex.getNewId(idToKey));
+  }
+
+  public void testEncryption() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+        new CachedContentIndex(cacheDir, key));
+
+    // Rename the index file from the test above
+    File file1 = new File(cacheDir, CachedContentIndex.FILE_NAME);
+    File file2 = new File(cacheDir, "file2compare");
+    assertTrue(file1.renameTo(file2));
+
+    // Write a new index file
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+        new CachedContentIndex(cacheDir, key));
+
+    assertEquals(file2.length(), file1.length());
+    // Assert file content is different
+    FileInputStream fis1 = new FileInputStream(file1);
+    FileInputStream fis2 = new FileInputStream(file2);
+    for (int b; (b = fis1.read()) == fis2.read(); ) {
+      assertTrue(b != -1);
+    }
+
+    boolean threw = false;
+    try {
+      assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+          new CachedContentIndex(cacheDir, key2));
+    } catch (AssertionFailedError e) {
+      threw = true;
+    }
+    assertTrue("Encrypted index file can not be read with different encryption key", threw);
+
+    try {
+      assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
+          new CachedContentIndex(cacheDir));
+    } catch (AssertionFailedError e) {
+      threw = true;
+    }
+    assertTrue("Encrypted index file can not be read without encryption key", threw);
+
+    // Non encrypted index file can be read even when encryption key provided.
+    assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir),
+        new CachedContentIndex(cacheDir, key));
+
+    // Test multiple store() calls
+    CachedContentIndex index = new CachedContentIndex(cacheDir, key);
+    index.addNew(new CachedContent(15, "key3", 110));
+    index.store();
+    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir, key));
+  }
+
+  private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
+      throws IOException {
+    index.addNew(new CachedContent(5, "key1", 10));
+    index.add("key2");
+    index.store();
+
+    index2.load();
+    Set<String> keys = index.getKeys();
+    Set<String> keys2 = index2.getKeys();
+    assertEquals(keys, keys2);
+    for (String key : keys) {
+      assertEquals(index.getContentLength(key), index2.getContentLength(key));
+      assertEquals(index.get(key).getSpans(), index2.get(key).getSpans());
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
new file mode 100644
index 0000000000..799027f4b5
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.File;
+import java.io.IOException;
+import org.mockito.Mock;
+
+/**
+ * Tests for {@link CachedRegionTracker}.
+ */
+public final class CachedRegionTrackerTest extends InstrumentationTestCase {
+
+  private static final String CACHE_KEY = "abc";
+  private static final long MS_IN_US = 1000;
+
+  // 5 chunks, each 20 bytes long and 100 ms long.
+  private static final ChunkIndex CHUNK_INDEX = new ChunkIndex(
+      new int[] {20, 20, 20, 20, 20},
+      new long[] {100, 120, 140, 160, 180},
+      new long[] {100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US},
+      new long[] {0, 100 * MS_IN_US, 200 * MS_IN_US, 300 * MS_IN_US, 400 * MS_IN_US});
+
+  @Mock private Cache cache;
+  private CachedRegionTracker tracker;
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
+
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testGetRegion_noSpansInCache() {
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(100));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(150));
+  }
+
+  public void testGetRegion_fullyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_partiallyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_multipleSpanAddsJoinedCorrectly() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 20));
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(120, 20));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_fullyCachedThenPartiallyRemoved() throws Exception {
+    // Start with the full stream in cache.
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    // Remove the middle bit.
+    tracker.onSpanRemoved(
+        cache,
+        newCacheSpan(140, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(181));
+  }
+
+  public void testGetRegion_subchunkEstimation() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 10));
+
+    assertEquals(50, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(111));
+  }
+
+  private CacheSpan newCacheSpan(int position, int length) throws IOException {
+    return SimpleCacheSpanTest.createCacheSpan(index, cacheDir, CACHE_KEY, position, length, 0);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
new file mode 100644
index 0000000000..0b40cd7735
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.TreeSet;
+
+/**
+ * Unit tests for {@link SimpleCacheSpan}.
+ */
+public class SimpleCacheSpanTest extends InstrumentationTestCase {
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  public static File createCacheSpanFile(File cacheDir, int id, long offset, int length,
+      long lastAccessTimestamp) throws IOException {
+    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastAccessTimestamp);
+    createTestFile(cacheFile, length);
+    return cacheFile;
+  }
+
+  public static CacheSpan createCacheSpan(CachedContentIndex index, File cacheDir, String key,
+      long offset, int length, long lastAccessTimestamp) throws IOException {
+    int id = index.assignIdForKey(key);
+    File cacheFile = createCacheSpanFile(cacheDir, id, offset, length, lastAccessTimestamp);
+    return SimpleCacheSpan.createCacheEntry(cacheFile, index);
+  }
+
+  @Override
+  protected void setUp() throws Exception {
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testCacheFile() throws Exception {
+    assertCacheSpan("key1", 0, 0);
+    assertCacheSpan("key2", 1, 2);
+    assertCacheSpan("<>:\"/\\|?*%", 1, 2);
+    assertCacheSpan("key3", 1, 2);
+
+    assertNullCacheSpan(new File("parent"), "key4", -1, 2);
+    assertNullCacheSpan(new File("parent"), "key5", 1, -2);
+
+    assertCacheSpan(
+        "A newline (line feed) character \n"
+            + "A carriage-return character followed immediately by a newline character \r\n"
+            + "A standalone carriage-return character \r"
+            + "A next-line character \u0085"
+            + "A line-separator character \u2028"
+            + "A paragraph-separator character \u2029", 1, 2);
+  }
+
+  public void testUpgradeFileName() throws Exception {
+    String key = "asd\u00aa";
+    int id = index.assignIdForKey(key);
+    File v3file = createTestFile(id + ".0.1.v3.exo");
+    File v2file = createTestFile("asd%aa.1.2.v2.exo");
+    File wrongEscapedV2file = createTestFile("asd%za.3.4.v2.exo");
+    File v1File = createTestFile("asd\u00aa.5.6.v1.exo");
+
+    for (File file : cacheDir.listFiles()) {
+      SimpleCacheSpan cacheEntry = SimpleCacheSpan.createCacheEntry(file, index);
+      if (file.equals(wrongEscapedV2file)) {
+        assertNull(cacheEntry);
+      } else {
+        assertNotNull(cacheEntry);
+      }
+    }
+
+    assertTrue(v3file.exists());
+    assertFalse(v2file.exists());
+    assertTrue(wrongEscapedV2file.exists());
+    assertFalse(v1File.exists());
+
+    File[] files = cacheDir.listFiles();
+    assertEquals(4, files.length);
+
+    Set<String> keys = index.getKeys();
+    assertEquals("There should be only one key for all files.", 1, keys.size());
+    assertTrue(keys.contains(key));
+
+    TreeSet<SimpleCacheSpan> spans = index.get(key).getSpans();
+    assertTrue("upgradeOldFiles() shouldn't add any spans.", spans.isEmpty());
+
+    HashMap<Long, Long> cachedPositions = new HashMap<>();
+    for (File file : files) {
+      SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(file, index);
+      if (cacheSpan != null) {
+        assertEquals(key, cacheSpan.key);
+        cachedPositions.put(cacheSpan.position, cacheSpan.lastAccessTimestamp);
+      }
+    }
+
+    assertEquals(1, (long) cachedPositions.get((long) 0));
+    assertEquals(2, (long) cachedPositions.get((long) 1));
+    assertEquals(6, (long) cachedPositions.get((long) 5));
+  }
+
+  private static void createTestFile(File file, int length) throws IOException {
+    FileOutputStream output = new FileOutputStream(file);
+    for (int i = 0; i < length; i++) {
+      output.write(i);
+    }
+    output.close();
+  }
+
+  private File createTestFile(String name) throws IOException {
+    File file = new File(cacheDir, name);
+    createTestFile(file, 1);
+    return file;
+  }
+
+  private void assertCacheSpan(String key, long offset, long lastAccessTimestamp)
+      throws IOException {
+    int id = index.assignIdForKey(key);
+    File cacheFile = createCacheSpanFile(cacheDir, id, offset, 1, lastAccessTimestamp);
+    SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    String message = cacheFile.toString();
+    assertNotNull(message, cacheSpan);
+    assertEquals(message, cacheDir, cacheFile.getParentFile());
+    assertEquals(message, key, cacheSpan.key);
+    assertEquals(message, offset, cacheSpan.position);
+    assertEquals(message, 1, cacheSpan.length);
+    assertTrue(message, cacheSpan.isCached);
+    assertEquals(message, cacheFile, cacheSpan.file);
+    assertEquals(message, lastAccessTimestamp, cacheSpan.lastAccessTimestamp);
+  }
+
+  private void assertNullCacheSpan(File parent, String key, long offset,
+      long lastAccessTimestamp) {
+    File cacheFile = SimpleCacheSpan.getCacheFile(parent, index.assignIdForKey(key), offset,
+        lastAccessTimestamp);
+    CacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
+    assertNull(cacheFile.toString(), cacheSpan);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 2c8ea912fb..001c6adc87 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -16,13 +16,16 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.test.InstrumentationTestCase;
-
+import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.NavigableSet;
+import java.util.Random;
 import java.util.Set;
 
 /**
@@ -36,10 +39,7 @@
 
   @Override
   protected void setUp() throws Exception {
-    // Create a temporary folder
-    cacheDir = File.createTempFile("SimpleCacheTest", null);
-    assertTrue(cacheDir.delete());
-    assertTrue(cacheDir.mkdir());
+    this.cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
   }
 
   @Override
@@ -48,11 +48,11 @@ protected void tearDown() throws Exception {
   }
 
   public void testCommittingOneFile() throws Exception {
-    SimpleCache simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
+    SimpleCache simpleCache = getSimpleCache();
 
-    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertFalse(cacheSpan.isCached);
-    assertTrue(cacheSpan.isOpenEnded());
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    assertFalse(cacheSpan1.isCached);
+    assertTrue(cacheSpan1.isOpenEnded());
 
     assertNull(simpleCache.startReadWriteNonBlocking(KEY_1, 0));
 
@@ -62,62 +62,171 @@ public void testCommittingOneFile() throws Exception {
     assertEquals(0, simpleCache.getCacheSpace());
     assertEquals(0, cacheDir.listFiles().length);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
     Set<String> cachedKeys = simpleCache.getKeys();
     assertEquals(1, cachedKeys.size());
     assertTrue(cachedKeys.contains(KEY_1));
     cachedSpans = simpleCache.getCachedSpans(KEY_1);
     assertEquals(1, cachedSpans.size());
-    assertTrue(cachedSpans.contains(cacheSpan));
+    assertTrue(cachedSpans.contains(cacheSpan1));
     assertEquals(15, simpleCache.getCacheSpace());
 
-    cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertTrue(cacheSpan.isCached);
-    assertFalse(cacheSpan.isOpenEnded());
-    assertEquals(15, cacheSpan.length);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertTrue(cacheSpan2.isCached);
+    assertFalse(cacheSpan2.isOpenEnded());
+    assertEquals(15, cacheSpan2.length);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+    simpleCache.releaseHoleSpan(cacheSpan1);
   }
 
   public void testSetGetLength() throws Exception {
-    SimpleCache simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
+    SimpleCache simpleCache = getSimpleCache();
 
     assertEquals(C.LENGTH_UNSET, simpleCache.getContentLength(KEY_1));
-    assertTrue(simpleCache.setContentLength(KEY_1, 15));
+    simpleCache.setContentLength(KEY_1, 15);
     assertEquals(15, simpleCache.getContentLength(KEY_1));
 
     simpleCache.startReadWrite(KEY_1, 0);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
-    assertTrue(simpleCache.setContentLength(KEY_1, 150));
+    simpleCache.setContentLength(KEY_1, 150);
     assertEquals(150, simpleCache.getContentLength(KEY_1));
 
-    addCache(simpleCache, 140, 10);
+    addCache(simpleCache, KEY_1, 140, 10);
 
-    // Try to set length shorter then the content
-    assertFalse(simpleCache.setContentLength(KEY_1, 15));
-    assertEquals("Content length should be unchanged.",
-        150, simpleCache.getContentLength(KEY_1));
-
-    /* TODO Enable when the length persistance is fixed
     // Check if values are kept after cache is reloaded.
-    simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
-    assertEquals(150, simpleCache.getContentLength(KEY_1));
-    CacheSpan lastSpan = simpleCache.startReadWrite(KEY_1, 145);
+    SimpleCache simpleCache2 = getSimpleCache();
+    Set<String> keys = simpleCache.getKeys();
+    Set<String> keys2 = simpleCache2.getKeys();
+    assertEquals(keys, keys2);
+    for (String key : keys) {
+      assertEquals(simpleCache.getContentLength(key), simpleCache2.getContentLength(key));
+      assertEquals(simpleCache.getCachedSpans(key), simpleCache2.getCachedSpans(key));
+    }
 
     // Removing the last span shouldn't cause the length be change next time cache loaded
-    simpleCache.removeSpan(lastSpan);
-    simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
-    assertEquals(150, simpleCache.getContentLength(KEY_1));
-     */
+    SimpleCacheSpan lastSpan = simpleCache2.startReadWrite(KEY_1, 145);
+    simpleCache2.removeSpan(lastSpan);
+    simpleCache2 = getSimpleCache();
+    assertEquals(150, simpleCache2.getContentLength(KEY_1));
+  }
+
+  public void testReloadCache() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndex() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getEncryptedSimpleCache(key);
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndexWrongKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+    simpleCache = getEncryptedSimpleCache(key2);
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
   }
 
-  private void addCache(SimpleCache simpleCache, int position, int length) throws IOException {
-    File file = simpleCache.startFile(KEY_1, position, length);
+  public void testEncryptedIndexLostKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
+  }
+
+  private SimpleCache getSimpleCache() {
+    return new SimpleCache(cacheDir, new NoOpCacheEvictor());
+  }
+
+  private SimpleCache getEncryptedSimpleCache(byte[] secretKey) {
+    return new SimpleCache(cacheDir, new NoOpCacheEvictor(), secretKey);
+  }
+
+  private static void addCache(SimpleCache simpleCache, String key, int position, int length)
+      throws IOException {
+    File file = simpleCache.startFile(key, position, length);
     FileOutputStream fos = new FileOutputStream(file);
-    fos.write(new byte[length]);
-    fos.close();
+    try {
+      fos.write(generateData(key, position, length));
+    } finally {
+      fos.close();
+    }
     simpleCache.commitFile(file);
   }
 
+  private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
+    assertTrue(cacheSpan.isCached);
+    byte[] expected = generateData(cacheSpan.key, (int) cacheSpan.position, (int) cacheSpan.length);
+    FileInputStream inputStream = new FileInputStream(cacheSpan.file);
+    try {
+      MoreAsserts.assertEquals(expected, Util.toByteArray(inputStream));
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  private static byte[] generateData(String key, int position, int length) {
+    byte[] bytes = new byte[length];
+    new Random((long) (key.hashCode() ^ position)).nextBytes(bytes);
+    return bytes;
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
new file mode 100644
index 0000000000..b4e7e6e7f6
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Random;
+import javax.crypto.Cipher;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link AesFlushingCipher}.
+ */
+public class AesFlushingCipherTest extends TestCase {
+
+  private static final int DATA_LENGTH = 65536;
+  private static final byte[] KEY = Util.getUtf8Bytes("testKey:12345678");
+  private static final long NONCE = 0;
+  private static final long START_OFFSET = 11;
+  private static final long RANDOM_SEED = 0x12345678;
+
+  private AesFlushingCipher encryptCipher;
+  private AesFlushingCipher decryptCipher;
+
+  @Override
+  protected void setUp() {
+    encryptCipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, KEY, NONCE, START_OFFSET);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, START_OFFSET);
+  }
+
+  @Override
+  protected void tearDown() {
+    encryptCipher = null;
+    decryptCipher = null;
+  }
+
+  private long getMaxUnchangedBytesAllowedPostEncryption(long length) {
+    // Assuming that not more than 10% of the resultant bytes should be identical.
+    // The value of 10% is arbitrary, ciphers standards do not name a value.
+    return length / 10;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
+    int count = 0;
+    for (int i = startOffset; i < data1.length; i++) {
+      if (data1[i] != data2[i]) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2) {
+    return getDifferingByteCount(data1, data2, 0);
+  }
+
+  // Test a single encrypt and decrypt call
+  public void testSingle() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+
+    encryptCipher.updateInPlace(data, 0, data.length);
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    decryptCipher.updateInPlace(data, 0, data.length);
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size
+  public void testAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, not aligned on block boundary
+  public void testUnAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test decryption starting from the middle of an encrypted block
+  public void testMidJoin() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    // Verify
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    // Setup decryption from random location
+    offset = random.nextInt(4096);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, offset + START_OFFSET);
+    int remainingLength = data.length - offset;
+    int originalOffset = offset;
+
+    // Decrypt
+    while (remainingLength > 0) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, remainingLength);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+      remainingLength -= bytes;
+    }
+
+    // Verify
+    int differingByteCount = getDifferingByteCount(reference, data, originalOffset);
+    assertEquals(0, differingByteCount);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
new file mode 100644
index 0000000000..7cdbb9a5b1
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.util;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Tests {@link AtomicFile}.
+ */
+public class AtomicFileTest extends InstrumentationTestCase {
+
+  private File tempFolder;
+  private File file;
+  private AtomicFile atomicFile;
+
+  @Override
+  public void setUp() throws Exception {
+    tempFolder = TestUtil.createTempFolder(getInstrumentation().getContext());
+    file = new File(tempFolder, "atomicFile");
+    atomicFile = new AtomicFile(file);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(tempFolder);
+  }
+
+  public void testDelete() throws Exception {
+    assertTrue(file.createNewFile());
+    atomicFile.delete();
+    assertFalse(file.exists());
+  }
+
+  public void testWriteRead() throws Exception {
+    OutputStream output = atomicFile.startWrite();
+    output.write(5);
+    atomicFile.endWrite(output);
+    output.close();
+
+    assertRead();
+
+    output = atomicFile.startWrite();
+    output.write(5);
+    output.write(6);
+    output.close();
+
+    assertRead();
+
+    output = atomicFile.startWrite();
+    output.write(6);
+
+    assertRead();
+    output.close();
+
+    output = atomicFile.startWrite();
+
+    assertRead();
+    output.close();
+  }
+
+  private void assertRead() throws IOException {
+    InputStream input = atomicFile.openRead();
+    assertEquals(5, input.read());
+    assertEquals(-1, input.read());
+    input.close();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index a747930152..49719b95f7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -371,6 +371,73 @@ public void testReadEmptyString() {
     assertNull(parser.readLine());
   }
 
+  public void testReadNullTerminatedStringWithLengths() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test with lengths that match NUL byte positions.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(4));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with lengths that do not match NUL byte positions.
+    parser = new ParsableByteArray(bytes);
+    assertEquals("fo", parser.readNullTerminatedString(2));
+    assertEquals(2, parser.getPosition());
+    assertEquals("o", parser.readNullTerminatedString(2));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(3));
+    assertEquals(7, parser.getPosition());
+    assertEquals("", parser.readNullTerminatedString(1));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString(3));
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedString() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test normal case.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL.
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL.
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedStringWithoutEndingNull() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertNull(parser.readNullTerminatedString());
+  }
+
   public void testReadSingleLineWithoutEndingTrail() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o'
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
new file mode 100644
index 0000000000..beb9e44853
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.test.MoreAsserts;
+import java.io.ByteArrayOutputStream;
+import junit.framework.TestCase;
+
+/**
+ * Tests {@link ReusableBufferedOutputStream}.
+ */
+public class ReusableBufferedOutputStreamTest extends TestCase {
+
+  private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
+  private static final byte[] TEST_DATA_2 = "2 test data".getBytes();
+
+  public void testReset() throws Exception {
+    ByteArrayOutputStream byteArrayOutputStream1 = new ByteArrayOutputStream(1000);
+    ReusableBufferedOutputStream outputStream = new ReusableBufferedOutputStream(
+        byteArrayOutputStream1, 1000);
+    outputStream.write(TEST_DATA_1);
+    outputStream.close();
+
+    ByteArrayOutputStream byteArrayOutputStream2 = new ByteArrayOutputStream(1000);
+    outputStream.reset(byteArrayOutputStream2);
+    outputStream.write(TEST_DATA_2);
+    outputStream.close();
+
+    MoreAsserts.assertEquals(TEST_DATA_1, byteArrayOutputStream1.toByteArray());
+    MoreAsserts.assertEquals(TEST_DATA_2, byteArrayOutputStream2.toByteArray());
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
index 8d74379093..35e168e514 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -15,9 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.testutil.TestUtil;
-import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
@@ -141,23 +139,11 @@ public void testParseXsDuration() {
     assertEquals(1500L, Util.parseXsDuration("PT1.500S"));
   }
 
-  public void testParseXsDateTime() throws ParseException {
+  public void testParseXsDateTime() throws Exception {
     assertEquals(1403219262000L, Util.parseXsDateTime("2014-06-19T23:07:42"));
     assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00Z"));
-  }
-
-  public void testGetHexStringByteArray() throws Exception {
-    assertHexStringByteArray("", new byte[] {});
-    assertHexStringByteArray("01", new byte[] {1});
-    assertHexStringByteArray("FF", new byte[] {(byte) 255});
-    assertHexStringByteArray("01020304", new byte[] {1, 2, 3, 4});
-    assertHexStringByteArray("0123456789ABCDEF",
-        new byte[] {1, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF});
-  }
-
-  private void assertHexStringByteArray(String hex, byte[] array) {
-    assertEquals(hex, Util.getHexString(array));
-    MoreAsserts.assertEquals(array, Util.getBytesFromHexString(hex));
+    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-08:00"));
+    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-0800"));
   }
 
   public void testUnescapeInvalidFileName() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 3763988978..9973a50cff 100644
--- a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -28,6 +28,7 @@
 
   private final int trackType;
 
+  private RendererConfiguration configuration;
   private int index;
   private int state;
   private SampleStream stream;
@@ -70,9 +71,11 @@ public final int getState() {
   }
 
   @Override
-  public final void enable(Format[] formats, SampleStream stream, long positionUs,
-      boolean joining, long offsetUs) throws ExoPlaybackException {
+  public final void enable(RendererConfiguration configuration, Format[] formats,
+      SampleStream stream, long positionUs, boolean joining, long offsetUs)
+      throws ExoPlaybackException {
     Assertions.checkState(state == STATE_DISABLED);
+    this.configuration = configuration;
     state = STATE_ENABLED;
     onEnabled(joining);
     replaceStream(formats, stream, offsetUs);
@@ -107,10 +110,15 @@ public final boolean hasReadStreamToEnd() {
   }
 
   @Override
-  public final void setCurrentStreamIsFinal() {
+  public final void setCurrentStreamFinal() {
     streamIsFinal = true;
   }
 
+  @Override
+  public final boolean isCurrentStreamFinal() {
+    return streamIsFinal;
+  }
+
   @Override
   public final void maybeThrowStreamError() throws IOException {
     stream.maybeThrowError();
@@ -119,6 +127,7 @@ public final void maybeThrowStreamError() throws IOException {
   @Override
   public final void resetPosition(long positionUs) throws ExoPlaybackException {
     streamIsFinal = false;
+    readEndOfStream = false;
     onPositionReset(positionUs, false);
   }
 
@@ -194,8 +203,7 @@ protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
    * @param joining Whether this renderer is being enabled to join an ongoing playback.
    * @throws ExoPlaybackException If an error occurs.
    */
-  protected void onPositionReset(long positionUs, boolean joining)
-      throws ExoPlaybackException {
+  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     // Do nothing.
   }
 
@@ -232,10 +240,15 @@ protected void onDisabled() {
 
   // Methods to be called by subclasses.
 
+  /**
+   * Returns the configuration set when the renderer was most recently enabled.
+   */
+  protected final RendererConfiguration getConfiguration() {
+    return configuration;
+  }
+
   /**
    * Returns the index of the renderer within the player.
-   *
-   * @return The index of the renderer within the player.
    */
   protected final int getIndex() {
     return index;
@@ -243,14 +256,14 @@ protected final int getIndex() {
 
   /**
    * Reads from the enabled upstream source. If the upstream source has been read to the end then
-   * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamIsFinal()} has been
+   * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
    * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
    *
-   * @see SampleStream#readData(FormatHolder, DecoderInputBuffer)
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
@@ -262,6 +275,12 @@ protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buf
         return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;
       }
       buffer.timeUs += streamOffsetUs;
+    } else if (result == C.RESULT_FORMAT_READ) {
+      Format format = formatHolder.format;
+      if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
+        format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + streamOffsetUs);
+        formatHolder.format = format;
+      }
     }
     return result;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 8c69524e95..0b1c33bfc9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2;
 
+import android.annotation.TargetApi;
+import android.content.Context;
 import android.media.AudioFormat;
+import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.support.annotation.IntDef;
 import android.view.Surface;
@@ -95,6 +98,13 @@ private C() {}
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
 
+  /**
+   * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
+   * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
+
   /**
    * Represents an audio encoding, or an invalid or unset value.
    */
@@ -159,6 +169,42 @@ private C() {}
   public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
       ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
 
+  /**
+   * Stream types for an {@link android.media.AudioTrack}.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STREAM_TYPE_ALARM, STREAM_TYPE_MUSIC, STREAM_TYPE_NOTIFICATION, STREAM_TYPE_RING,
+      STREAM_TYPE_SYSTEM, STREAM_TYPE_VOICE_CALL})
+  public @interface StreamType {}
+  /**
+   * @see AudioManager#STREAM_ALARM
+   */
+  public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
+  /**
+   * @see AudioManager#STREAM_MUSIC
+   */
+  public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
+  /**
+   * @see AudioManager#STREAM_NOTIFICATION
+   */
+  public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
+  /**
+   * @see AudioManager#STREAM_RING
+   */
+  public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
+  /**
+   * @see AudioManager#STREAM_SYSTEM
+   */
+  public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
+  /**
+   * @see AudioManager#STREAM_VOICE_CALL
+   */
+  public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
+  /**
+   * The default stream type used by audio renderers.
+   */
+  public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
+
   /**
    * Flags which can apply to a buffer containing a media sample.
    */
@@ -185,6 +231,29 @@ private C() {}
    */
   public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
 
+  /**
+   * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(value = {VIDEO_SCALING_MODE_SCALE_TO_FIT, VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING})
+  public @interface VideoScalingMode {}
+  /**
+   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT =
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
+  /**
+   * @see MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING =
+      MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
+  /**
+   * A default video scaling mode for {@link MediaCodec}-based {@link Renderer}s.
+   */
+  public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
+
   /**
    * Track selection flags.
    */
@@ -397,21 +466,45 @@ private C() {}
   public static final int MSG_SET_SURFACE = 1;
 
   /**
-   * The type of a message that can be passed to an audio {@link Renderer} via
+   * A type of a message that can be passed to an audio {@link Renderer} via
    * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
    * should be a {@link Float} with 0 being silence and 1 being unity gain.
    */
   public static final int MSG_SET_VOLUME = 2;
 
   /**
-   * The type of a message that can be passed to an audio {@link Renderer} via
+   * A type of a message that can be passed to an audio {@link Renderer} via
    * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be a {@link android.media.PlaybackParams}, which will be used to configure the
+   * should be a {@link android.media.PlaybackParams}, or null, which will be used to configure the
    * underlying {@link android.media.AudioTrack}. The message object should not be modified by the
    * caller after it has been passed
    */
   public static final int MSG_SET_PLAYBACK_PARAMS = 3;
 
+  /**
+   * A type of a message that can be passed to an audio {@link Renderer} via
+   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
+   * should be one of the integer stream types in {@link C.StreamType}, and will specify the stream
+   * type of the underlying {@link android.media.AudioTrack}. See also
+   * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}. If the stream type
+   * is not set, audio renderers use {@link #STREAM_TYPE_DEFAULT}.
+   * <p>
+   * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+   * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+   * share the same routing, so a new audio session id will be generated.
+   */
+  public static final int MSG_SET_STREAM_TYPE = 4;
+
+  /**
+   * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
+   * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
+   * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
+   * <p>
+   * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
+   * owned by a {@link android.view.SurfaceView}.
+   */
+  public static final int MSG_SET_SCALING_MODE = 5;
+
   /**
    * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
    * this value.
@@ -459,4 +552,13 @@ public static long msToUs(long timeMs) {
     return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
   }
 
+  /**
+   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   */
+  @TargetApi(21)
+  public static int generateAudioSessionIdV21(Context context) {
+    return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
+        .generateAudioSessionId();
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index e7a0f8b1b8..fe7015a942 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -16,9 +16,10 @@
 package com.google.android.exoplayer2;
 
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -50,6 +51,11 @@
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS  = 5000;
 
+  /**
+   * Priority for media loading.
+   */
+  public static final int LOADING_PRIORITY = 0;
+
   private static final int ABOVE_HIGH_WATERMARK = 0;
   private static final int BETWEEN_WATERMARKS = 1;
   private static final int BELOW_LOW_WATERMARK = 2;
@@ -60,6 +66,7 @@
   private final long maxBufferUs;
   private final long bufferForPlaybackUs;
   private final long bufferForPlaybackAfterRebufferUs;
+  private final PriorityTaskManager priorityTaskManager;
 
   private int targetBufferSize;
   private boolean isBuffering;
@@ -97,11 +104,36 @@ public DefaultLoadControl(DefaultAllocator allocator) {
    */
   public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
       long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs) {
+    this(allocator, minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs,
+        null);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param allocator The {@link DefaultAllocator} used by the loader.
+   * @param minBufferMs The minimum duration of media that the player will attempt to ensure is
+   *     buffered at all times, in milliseconds.
+   * @param maxBufferMs The maximum duration of media that the player will attempt buffer, in
+   *     milliseconds.
+   * @param bufferForPlaybackMs The duration of media that must be buffered for playback to start or
+   *     resume following a user action such as a seek, in milliseconds.
+   * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
+   *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
+   *     buffer depletion rather than a user action.
+   * @param priorityTaskManager If not null, registers itself as a task with priority
+   *     {@link #LOADING_PRIORITY} during loading periods, and unregisters itself during draining
+   *     periods.
+   */
+  public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
+      long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs,
+      PriorityTaskManager priorityTaskManager) {
     this.allocator = allocator;
     minBufferUs = minBufferMs * 1000L;
     maxBufferUs = maxBufferMs * 1000L;
     bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
+    this.priorityTaskManager = priorityTaskManager;
   }
 
   @Override
@@ -111,7 +143,7 @@ public void onPrepared() {
 
   @Override
   public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
-      TrackSelections<?> trackSelections) {
+      TrackSelectionArray trackSelections) {
     targetBufferSize = 0;
     for (int i = 0; i < renderers.length; i++) {
       if (trackSelections.get(i) != null) {
@@ -146,8 +178,16 @@ public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering)
   public boolean shouldContinueLoading(long bufferedDurationUs) {
     int bufferTimeState = getBufferTimeState(bufferedDurationUs);
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
+    boolean wasBuffering = isBuffering;
     isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
         || (bufferTimeState == BETWEEN_WATERMARKS && isBuffering && !targetBufferSizeReached);
+    if (priorityTaskManager != null && isBuffering != wasBuffering) {
+      if (isBuffering) {
+        priorityTaskManager.add(LOADING_PRIORITY);
+      } else {
+        priorityTaskManager.remove(LOADING_PRIORITY);
+      }
+    }
     return isBuffering;
   }
 
@@ -158,6 +198,9 @@ private int getBufferTimeState(long bufferedDurationUs) {
 
   private void reset(boolean resetAllocator) {
     targetBufferSize = 0;
+    if (priorityTaskManager != null && isBuffering) {
+      priorityTaskManager.remove(LOADING_PRIORITY);
+    }
     isBuffering = false;
     if (resetAllocator) {
       allocator.reset();
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index e3c9b6e114..083569416c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -22,11 +22,13 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MergingMediaSource;
 import com.google.android.exoplayer2.source.SingleSampleMediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
@@ -110,6 +112,28 @@
    */
   interface EventListener {
 
+    /**
+     * Called when the timeline and/or manifest has been refreshed.
+     * <p>
+     * Note that if the timeline has changed then a position discontinuity may also have occurred.
+     * For example the current period index may have changed as a result of periods being added or
+     * removed from the timeline. The will <em>not</em> be reported via a separate call to
+     * {@link #onPositionDiscontinuity()}.
+     *
+     * @param timeline The latest timeline. Never null, but may be empty.
+     * @param manifest The latest manifest. May be null.
+     */
+    void onTimelineChanged(Timeline timeline, Object manifest);
+
+    /**
+     * Called when the available or selected tracks change.
+     *
+     * @param trackGroups The available tracks. Never null, but may be of length zero.
+     * @param trackSelections The track selections for each {@link Renderer}. Never null and always
+     *     of length {@link #getRendererCount()}, but may contain null elements.
+     */
+    void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections);
+
     /**
      * Called when the player starts or stops loading the source.
      *
@@ -127,14 +151,6 @@
      */
     void onPlayerStateChanged(boolean playWhenReady, int playbackState);
 
-    /**
-     * Called when timeline and/or manifest has been refreshed.
-     *
-     * @param timeline The latest timeline, or null if the timeline is being cleared.
-     * @param manifest The latest manifest, or null if the manifest is being cleared.
-     */
-    void onTimelineChanged(Timeline timeline, Object manifest);
-
     /**
      * Called when an error occurs. The playback state will transition to {@link #STATE_IDLE}
      * immediately after this method is called. The player instance can still be used, and
@@ -145,9 +161,14 @@
     void onPlayerError(ExoPlaybackException error);
 
     /**
-     * Called when a position discontinuity occurs. Position discontinuities occur when seeks are
-     * performed, when playbacks transition from one period in the timeline to the next, and when
-     * the player introduces discontinuities internally.
+     * Called when a position discontinuity occurs without a change to the timeline. A position
+     * discontinuity occurs when the current window or period index changes (as a result of playback
+     * transitioning from one period in the timeline to the next), or when the playback position
+     * jumps within the period currently being played (as a result of a seek being performed, or
+     * when the source introduces a discontinuity internally).
+     * <p>
+     * When a position discontinuity occurs as a result of a change to the timeline this method is
+     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object)} is called in this case.
      */
     void onPositionDiscontinuity();
 
@@ -259,11 +280,11 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    * @param resetPosition Whether the playback position should be reset to the default position in
    *     the first {@link Timeline.Window}. If false, playback will start from the position defined
    *     by {@link #getCurrentWindowIndex()} and {@link #getCurrentPosition()}.
-   * @param resetTimeline Whether the timeline and manifest should be reset. Should be true unless
-   *     the player is being prepared to play the same media as it was playing previously (e.g. if
-   *     playback failed and is being retried).
+   * @param resetState Whether the timeline, manifest, tracks and track selections should be reset.
+   *     Should be true unless the player is being prepared to play the same media as it was playing
+   *     previously (e.g. if playback failed and is being retried).
    */
-  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline);
+  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
 
   /**
    * Sets whether playback should proceed when {@link #getPlaybackState()} == {@link #STATE_READY}.
@@ -309,17 +330,19 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
   /**
    * Seeks to a position specified in milliseconds in the current window.
    *
-   * @param windowPositionMs The seek position in the current window.
+   * @param positionMs The seek position in the current window, or {@link C#TIME_UNSET} to seek to
+   *     the window's default position.
    */
-  void seekTo(long windowPositionMs);
+  void seekTo(long positionMs);
 
   /**
    * Seeks to a position specified in milliseconds in the specified window.
    *
    * @param windowIndex The index of the window.
-   * @param windowPositionMs The seek position in the specified window.
+   * @param positionMs The seek position in the specified window, or {@link C#TIME_UNSET} to seek to
+   *     the window's default position.
    */
-  void seekTo(int windowIndex, long windowPositionMs);
+  void seekTo(int windowIndex, long positionMs);
 
   /**
    * Stops playback. Use {@code setPlayWhenReady(false)} rather than this method if the intention
@@ -356,19 +379,43 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    */
   void blockingSendMessages(ExoPlayerMessage... messages);
 
+  /**
+   * Returns the number of renderers.
+   */
+  int getRendererCount();
+
+  /**
+   * Returns the track type that the renderer at a given index handles.
+   *
+   * @see Renderer#getTrackType()
+   * @param index The index of the renderer.
+   * @return One of the {@code TRACK_TYPE_*} constants defined in {@link C}.
+   */
+  int getRendererType(int index);
+
+  /**
+   * Returns the available track groups.
+   */
+  TrackGroupArray getCurrentTrackGroups();
+
+  /**
+   * Returns the current track selections for each renderer.
+   */
+  TrackSelectionArray getCurrentTrackSelections();
+
   /**
    * Returns the current manifest. The type depends on the {@link MediaSource} passed to
-   * {@link #prepare}.
+   * {@link #prepare}. May be null.
    */
   Object getCurrentManifest();
 
   /**
-   * Returns the current {@link Timeline}, or {@code null} if there is no timeline.
+   * Returns the current {@link Timeline}. Never null, but may be empty.
    */
   Timeline getCurrentTimeline();
 
   /**
-   * Returns the index of the period currently being played, or {@link C#INDEX_UNSET} if unknown.
+   * Returns the index of the period currently being played.
    */
   int getCurrentPeriodIndex();
 
@@ -400,4 +447,20 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    */
   int getBufferedPercentage();
 
+  /**
+   * Returns whether the current window is dynamic, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isDynamic
+   */
+  boolean isCurrentWindowDynamic();
+
+  /**
+   * Returns whether the current window is seekable, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isSeekable
+   */
+  boolean isCurrentWindowSeekable();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 91ab56805a..43de6fe751 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -42,14 +42,14 @@ private ExoPlayerFactory() {}
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
       LoadControl loadControl) {
     return newSimpleInstance(context, trackSelector, loadControl, null);
   }
 
   /**
    * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
-   * {@link Looper}.
+   * {@link Looper}. Available extension renderers are not used.
    *
    * @param context A {@link Context}.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
@@ -57,9 +57,10 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
       LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-    return newSimpleInstance(context, trackSelector, loadControl, drmSessionManager, false);
+    return newSimpleInstance(context, trackSelector, loadControl,
+        drmSessionManager, SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF);
   }
 
   /**
@@ -71,15 +72,15 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
-   * @param preferExtensionDecoders True to prefer {@link Renderer} instances defined in
-   *     available extensions over those defined in the core library. Note that extensions must be
-   *     included in the application build for setting this flag to have any effect.
+   * @param extensionRendererMode The extension renderer mode, which determines if and how available
+   *     extension renderers are used. Note that extensions must be included in the application
+   *     build for them to be considered available.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
       LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean preferExtensionDecoders) {
+      @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode) {
     return newSimpleInstance(context, trackSelector, loadControl, drmSessionManager,
-        preferExtensionDecoders, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
+        extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
   }
 
   /**
@@ -91,17 +92,18 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
-   * @param preferExtensionDecoders True to prefer {@link Renderer} instances defined in
-   *     available extensions over those defined in the core library. Note that extensions must be
-   *     included in the application build for setting this flag to have any effect.
+   * @param extensionRendererMode The extension renderer mode, which determines if and how available
+   *     extension renderers are used. Note that extensions must be included in the application
+   *     build for them to be considered available.
    * @param allowedVideoJoiningTimeMs The maximum duration for which a video renderer can attempt to
    *     seamlessly join an ongoing playback.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
       LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean preferExtensionDecoders, long allowedVideoJoiningTimeMs) {
+      @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode,
+      long allowedVideoJoiningTimeMs) {
     return new SimpleExoPlayer(context, trackSelector, loadControl, drmSessionManager,
-        preferExtensionDecoders, allowedVideoJoiningTimeMs);
+        extensionRendererMode, allowedVideoJoiningTimeMs);
   }
 
   /**
@@ -111,7 +113,7 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector<?> trackSelector) {
+  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector) {
     return newInstance(renderers, trackSelector, new DefaultLoadControl());
   }
 
@@ -123,7 +125,7 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector<?> track
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector<?> trackSelector,
+  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl) {
     return new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 3eb2ceb38b..d44d138091 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -20,11 +20,16 @@
 import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
-import android.util.Pair;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
+import com.google.android.exoplayer2.ExoPlayerImplInternal.SourceInfo;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
@@ -34,19 +39,24 @@
 
   private static final String TAG = "ExoPlayerImpl";
 
+  private final Renderer[] renderers;
+  private final TrackSelector trackSelector;
+  private final TrackSelectionArray emptyTrackSelections;
   private final Handler eventHandler;
-  private final ExoPlayerImplInternal<?> internalPlayer;
+  private final ExoPlayerImplInternal internalPlayer;
   private final CopyOnWriteArraySet<EventListener> listeners;
   private final Timeline.Window window;
   private final Timeline.Period period;
 
-  private boolean pendingInitialSeek;
+  private boolean tracksSelected;
   private boolean playWhenReady;
   private int playbackState;
   private int pendingSeekAcks;
   private boolean isLoading;
   private Timeline timeline;
   private Object manifest;
+  private TrackGroupArray trackGroups;
+  private TrackSelectionArray trackSelections;
 
   // Playback information when there is no pending seek/set source operation.
   private PlaybackInfo playbackInfo;
@@ -63,16 +73,20 @@
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
   @SuppressLint("HandlerLeak")
-  public ExoPlayerImpl(Renderer[] renderers, TrackSelector<?> trackSelector,
-      LoadControl loadControl) {
-    Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION);
-    Assertions.checkNotNull(renderers);
+  public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
+    Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION + " [" + Util.DEVICE_DEBUG_INFO + "]");
     Assertions.checkState(renderers.length > 0);
+    this.renderers = Assertions.checkNotNull(renderers);
+    this.trackSelector = Assertions.checkNotNull(trackSelector);
     this.playWhenReady = false;
     this.playbackState = STATE_IDLE;
     this.listeners = new CopyOnWriteArraySet<>();
+    emptyTrackSelections = new TrackSelectionArray(new TrackSelection[renderers.length]);
+    timeline = Timeline.EMPTY;
     window = new Timeline.Window();
     period = new Timeline.Period();
+    trackGroups = TrackGroupArray.EMPTY;
+    trackSelections = emptyTrackSelections;
     eventHandler = new Handler() {
       @Override
       public void handleMessage(Message msg) {
@@ -80,8 +94,8 @@ public void handleMessage(Message msg) {
       }
     };
     playbackInfo = new ExoPlayerImplInternal.PlaybackInfo(0, 0);
-    internalPlayer = new ExoPlayerImplInternal<>(renderers, trackSelector, loadControl,
-        playWhenReady, eventHandler, playbackInfo);
+    internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
+        eventHandler, playbackInfo, this);
   }
 
   @Override
@@ -105,12 +119,23 @@ public void prepare(MediaSource mediaSource) {
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
-    if (resetTimeline && (timeline != null || manifest != null)) {
-      timeline = null;
-      manifest = null;
-      for (EventListener listener : listeners) {
-        listener.onTimelineChanged(null, null);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    if (resetState) {
+      if (!timeline.isEmpty() || manifest != null) {
+        timeline = Timeline.EMPTY;
+        manifest = null;
+        for (EventListener listener : listeners) {
+          listener.onTimelineChanged(timeline, manifest);
+        }
+      }
+      if (tracksSelected) {
+        tracksSelected = false;
+        trackGroups = TrackGroupArray.EMPTY;
+        trackSelections = emptyTrackSelections;
+        trackSelector.onSelectionActivated(null);
+        for (EventListener listener : listeners) {
+          listener.onTracksChanged(trackGroups, trackSelections);
+        }
       }
     }
     internalPlayer.prepare(mediaSource, resetPosition);
@@ -144,17 +169,7 @@ public void seekToDefaultPosition() {
 
   @Override
   public void seekToDefaultPosition(int windowIndex) {
-    if (timeline == null) {
-      maskingWindowIndex = windowIndex;
-      maskingWindowPositionMs = C.TIME_UNSET;
-      pendingInitialSeek = true;
-    } else {
-      Assertions.checkIndex(windowIndex, 0, timeline.getWindowCount());
-      pendingSeekAcks++;
-      maskingWindowIndex = windowIndex;
-      maskingWindowPositionMs = 0;
-      internalPlayer.seekTo(timeline.getWindow(windowIndex, window).firstPeriodIndex, C.TIME_UNSET);
-    }
+    seekTo(windowIndex, C.TIME_UNSET);
   }
 
   @Override
@@ -164,27 +179,17 @@ public void seekTo(long positionMs) {
 
   @Override
   public void seekTo(int windowIndex, long positionMs) {
+    if (windowIndex < 0 || (!timeline.isEmpty() && windowIndex >= timeline.getWindowCount())) {
+      throw new IllegalSeekPositionException(timeline, windowIndex, positionMs);
+    }
+    pendingSeekAcks++;
+    maskingWindowIndex = windowIndex;
     if (positionMs == C.TIME_UNSET) {
-      seekToDefaultPosition(windowIndex);
-    } else if (timeline == null) {
-      maskingWindowIndex = windowIndex;
-      maskingWindowPositionMs = positionMs;
-      pendingInitialSeek = true;
+      maskingWindowPositionMs = 0;
+      internalPlayer.seekTo(timeline, windowIndex, C.TIME_UNSET);
     } else {
-      Assertions.checkIndex(windowIndex, 0, timeline.getWindowCount());
-      pendingSeekAcks++;
-      maskingWindowIndex = windowIndex;
       maskingWindowPositionMs = positionMs;
-      timeline.getWindow(windowIndex, window);
-      int periodIndex = window.firstPeriodIndex;
-      long periodPositionMs = window.getPositionInFirstPeriodMs() + positionMs;
-      long periodDurationMs = timeline.getPeriod(periodIndex, period).getDurationMs();
-      while (periodDurationMs != C.TIME_UNSET && periodPositionMs >= periodDurationMs
-          && periodIndex < window.lastPeriodIndex) {
-        periodPositionMs -= periodDurationMs;
-        periodDurationMs = timeline.getPeriod(++periodIndex, period).getDurationMs();
-      }
-      internalPlayer.seekTo(periodIndex, C.msToUs(periodPositionMs));
+      internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
       for (EventListener listener : listeners) {
         listener.onPositionDiscontinuity();
       }
@@ -219,7 +224,7 @@ public int getCurrentPeriodIndex() {
 
   @Override
   public int getCurrentWindowIndex() {
-    if (timeline == null || pendingSeekAcks > 0) {
+    if (timeline.isEmpty() || pendingSeekAcks > 0) {
       return maskingWindowIndex;
     } else {
       return timeline.getPeriod(playbackInfo.periodIndex, period).windowIndex;
@@ -228,7 +233,7 @@ public int getCurrentWindowIndex() {
 
   @Override
   public long getDuration() {
-    if (timeline == null) {
+    if (timeline.isEmpty()) {
       return C.TIME_UNSET;
     }
     return timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
@@ -236,7 +241,7 @@ public long getDuration() {
 
   @Override
   public long getCurrentPosition() {
-    if (timeline == null || pendingSeekAcks > 0) {
+    if (timeline.isEmpty() || pendingSeekAcks > 0) {
       return maskingWindowPositionMs;
     } else {
       timeline.getPeriod(playbackInfo.periodIndex, period);
@@ -247,7 +252,7 @@ public long getCurrentPosition() {
   @Override
   public long getBufferedPosition() {
     // TODO - Implement this properly.
-    if (timeline == null || pendingSeekAcks > 0) {
+    if (timeline.isEmpty() || pendingSeekAcks > 0) {
       return maskingWindowPositionMs;
     } else {
       timeline.getPeriod(playbackInfo.periodIndex, period);
@@ -257,7 +262,7 @@ public long getBufferedPosition() {
 
   @Override
   public int getBufferedPercentage() {
-    if (timeline == null) {
+    if (timeline.isEmpty()) {
       return 0;
     }
     long bufferedPosition = getBufferedPosition();
@@ -266,6 +271,42 @@ public int getBufferedPercentage() {
         : (int) (duration == 0 ? 100 : (bufferedPosition * 100) / duration);
   }
 
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
+  @Override
+  public int getRendererCount() {
+    return renderers.length;
+  }
+
+  @Override
+  public int getRendererType(int index) {
+    return renderers[index].getTrackType();
+  }
+
+  @Override
+  public TrackGroupArray getCurrentTrackGroups() {
+    return trackGroups;
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return trackSelections;
+  }
+
   @Override
   public Timeline getCurrentTimeline() {
     return timeline;
@@ -293,11 +334,24 @@ public Object getCurrentManifest() {
         }
         break;
       }
+      case ExoPlayerImplInternal.MSG_TRACKS_CHANGED: {
+        TrackSelectorResult trackSelectorResult = (TrackSelectorResult) msg.obj;
+        tracksSelected = true;
+        trackGroups = trackSelectorResult.groups;
+        trackSelections = trackSelectorResult.selections;
+        trackSelector.onSelectionActivated(trackSelectorResult.info);
+        for (EventListener listener : listeners) {
+          listener.onTracksChanged(trackGroups, trackSelections);
+        }
+        break;
+      }
       case ExoPlayerImplInternal.MSG_SEEK_ACK: {
         if (--pendingSeekAcks == 0) {
           playbackInfo = (ExoPlayerImplInternal.PlaybackInfo) msg.obj;
-          for (EventListener listener : listeners) {
-            listener.onPositionDiscontinuity();
+          if (msg.arg1 != 0) {
+            for (EventListener listener : listeners) {
+              listener.onPositionDiscontinuity();
+            }
           }
         }
         break;
@@ -312,14 +366,11 @@ public Object getCurrentManifest() {
         break;
       }
       case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED: {
-        @SuppressWarnings("unchecked")
-        Pair<Timeline, Object> timelineAndManifest = (Pair<Timeline, Object>) msg.obj;
-        timeline = timelineAndManifest.first;
-        manifest = timelineAndManifest.second;
-        if (pendingInitialSeek) {
-          pendingInitialSeek = false;
-          seekTo(maskingWindowIndex, maskingWindowPositionMs);
-        }
+        SourceInfo sourceInfo = (SourceInfo) msg.obj;
+        timeline = sourceInfo.timeline;
+        manifest = sourceInfo.manifest;
+        playbackInfo = sourceInfo.playbackInfo;
+        pendingSeekAcks -= sourceInfo.seekAcks;
         for (EventListener listener : listeners) {
           listener.onTimelineChanged(timeline, manifest);
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 56b862073a..faf86087c9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -27,20 +27,20 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.PriorityHandlerThread;
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
 import com.google.android.exoplayer2.util.TraceUtil;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
  * Implements the internal behavior of {@link ExoPlayerImpl}.
  */
-/* package */ final class ExoPlayerImplInternal<T> implements Handler.Callback,
+/* package */ final class ExoPlayerImplInternal implements Handler.Callback,
     MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
 
   /**
@@ -62,6 +62,29 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
       bufferedPositionUs = startPositionUs;
     }
 
+    public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
+      PlaybackInfo playbackInfo = new PlaybackInfo(periodIndex, startPositionUs);
+      playbackInfo.positionUs = positionUs;
+      playbackInfo.bufferedPositionUs = bufferedPositionUs;
+      return playbackInfo;
+    }
+
+  }
+
+  public static final class SourceInfo {
+
+    public final Timeline timeline;
+    public final Object manifest;
+    public final PlaybackInfo playbackInfo;
+    public final int seekAcks;
+
+    public SourceInfo(Timeline timeline, Object manifest, PlaybackInfo playbackInfo, int seekAcks) {
+      this.timeline = timeline;
+      this.manifest = manifest;
+      this.playbackInfo = playbackInfo;
+      this.seekAcks = seekAcks;
+    }
+
   }
 
   private static final String TAG = "ExoPlayerImplInternal";
@@ -69,10 +92,11 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
   // External messages
   public static final int MSG_STATE_CHANGED = 1;
   public static final int MSG_LOADING_CHANGED = 2;
-  public static final int MSG_SEEK_ACK = 3;
-  public static final int MSG_POSITION_DISCONTINUITY = 4;
-  public static final int MSG_SOURCE_INFO_REFRESHED = 5;
-  public static final int MSG_ERROR = 6;
+  public static final int MSG_TRACKS_CHANGED = 3;
+  public static final int MSG_SEEK_ACK = 4;
+  public static final int MSG_POSITION_DISCONTINUITY = 5;
+  public static final int MSG_SOURCE_INFO_REFRESHED = 6;
+  public static final int MSG_ERROR = 7;
 
   // Internal messages
   private static final int MSG_PREPARE = 0;
@@ -98,14 +122,23 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
    */
   private static final int MAXIMUM_BUFFER_AHEAD_PERIODS = 100;
 
+  /**
+   * Offset added to all sample timestamps read by renderers to make them non-negative. This is
+   * provided for convenience of sources that may return negative timestamps due to prerolling
+   * samples from a keyframe before their first sample with timestamp zero, so it must be set to a
+   * value greater than or equal to the maximum key-frame interval in seekable periods.
+   */
+  private static final int RENDERER_TIMESTAMP_OFFSET_US = 60000000;
+
   private final Renderer[] renderers;
   private final RendererCapabilities[] rendererCapabilities;
-  private final TrackSelector<T> trackSelector;
+  private final TrackSelector trackSelector;
   private final LoadControl loadControl;
   private final StandaloneMediaClock standaloneMediaClock;
   private final Handler handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
+  private final ExoPlayer player;
   private final Timeline.Window window;
   private final Timeline.Period period;
 
@@ -123,20 +156,19 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
   private int customMessagesProcessed;
   private long elapsedRealtimeUs;
 
+  private int pendingInitialSeekCount;
+  private SeekPosition pendingSeekPosition;
   private long rendererPositionUs;
 
-  private boolean isTimelineReady;
-  private boolean isTimelineEnded;
-  private int bufferAheadPeriodCount;
-  private MediaPeriodHolder<T> playingPeriodHolder;
-  private MediaPeriodHolder<T> readingPeriodHolder;
-  private MediaPeriodHolder<T> loadingPeriodHolder;
+  private MediaPeriodHolder loadingPeriodHolder;
+  private MediaPeriodHolder readingPeriodHolder;
+  private MediaPeriodHolder playingPeriodHolder;
 
   private Timeline timeline;
 
-  public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector<T> trackSelector,
+  public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl, boolean playWhenReady, Handler eventHandler,
-      PlaybackInfo playbackInfo) {
+      PlaybackInfo playbackInfo, ExoPlayer player) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
@@ -144,6 +176,7 @@ public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector<T> trackSelecto
     this.eventHandler = eventHandler;
     this.state = ExoPlayer.STATE_IDLE;
     this.playbackInfo = playbackInfo;
+    this.player = player;
 
     rendererCapabilities = new RendererCapabilities[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
@@ -173,8 +206,9 @@ public void setPlayWhenReady(boolean playWhenReady) {
     handler.obtainMessage(MSG_SET_PLAY_WHEN_READY, playWhenReady ? 1 : 0, 0).sendToTarget();
   }
 
-  public void seekTo(int periodIndex, long positionUs) {
-    handler.obtainMessage(MSG_SEEK_TO, periodIndex, 0, positionUs).sendToTarget();
+  public void seekTo(Timeline timeline, int windowIndex, long positionUs) {
+    handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs))
+        .sendToTarget();
   }
 
   public void stop() {
@@ -249,6 +283,7 @@ public void onTrackSelectionsInvalidated() {
 
   // Handler.Callback implementation.
 
+  @SuppressWarnings("unchecked")
   @Override
   public boolean handleMessage(Message msg) {
     try {
@@ -266,7 +301,7 @@ public boolean handleMessage(Message msg) {
           return true;
         }
         case MSG_SEEK_TO: {
-          seekToInternal(msg.arg1, (Long) msg.obj);
+          seekToInternal((SeekPosition) msg.obj);
           return true;
         }
         case MSG_STOP: {
@@ -335,15 +370,14 @@ private void setIsLoading(boolean isLoading) {
     }
   }
 
-  private void prepareInternal(MediaSource mediaSource, boolean resetPosition)
-      throws ExoPlaybackException {
-    resetInternal();
+  private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
+    resetInternal(true);
     loadControl.onPrepared();
     if (resetPosition) {
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
     }
     this.mediaSource = mediaSource;
-    mediaSource.prepareSource(this);
+    mediaSource.prepareSource(player, true, this);
     setState(ExoPlayer.STATE_BUFFERING);
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
@@ -395,7 +429,7 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
       } else {
         rendererPositionUs = standaloneMediaClock.getPositionUs();
       }
-      periodPositionUs = rendererPositionUs - playingPeriodHolder.rendererPositionOffsetUs;
+      periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
     }
     playbackInfo.positionUs = periodPositionUs;
     elapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
@@ -410,7 +444,6 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
 
   private void doSomeWork() throws ExoPlaybackException, IOException {
     long operationStartTimeMs = SystemClock.elapsedRealtime();
-
     updatePeriods();
     if (playingPeriodHolder == null) {
       // We're still waiting for the first period to be prepared.
@@ -448,22 +481,27 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
     if (allRenderersEnded
         && (playingPeriodDurationUs == C.TIME_UNSET
         || playingPeriodDurationUs <= playbackInfo.positionUs)
-        && isTimelineEnded) {
+        && playingPeriodHolder.isLast) {
       setState(ExoPlayer.STATE_ENDED);
       stopRenderers();
     } else if (state == ExoPlayer.STATE_BUFFERING) {
-      if ((enabledRenderers.length > 0
-          ? (allRenderersReadyOrEnded && haveSufficientBuffer(rebuffering)) : isTimelineReady)) {
+      boolean isNewlyReady = enabledRenderers.length > 0
+          ? (allRenderersReadyOrEnded && haveSufficientBuffer(rebuffering))
+          : isTimelineReady(playingPeriodDurationUs);
+      if (isNewlyReady) {
         setState(ExoPlayer.STATE_READY);
         if (playWhenReady) {
           startRenderers();
         }
       }
-    } else if (state == ExoPlayer.STATE_READY
-        && (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !isTimelineReady)) {
-      rebuffering = playWhenReady;
-      setState(ExoPlayer.STATE_BUFFERING);
-      stopRenderers();
+    } else if (state == ExoPlayer.STATE_READY) {
+      boolean isStillReady = enabledRenderers.length > 0 ? allRenderersReadyOrEnded
+          : isTimelineReady(playingPeriodDurationUs);
+      if (!isStillReady) {
+        rebuffering = playWhenReady;
+        setState(ExoPlayer.STATE_BUFFERING);
+        stopRenderers();
+      }
     }
 
     if (state == ExoPlayer.STATE_BUFFERING) {
@@ -494,51 +532,55 @@ private void scheduleNextWork(long thisOperationStartTimeMs, long intervalMs) {
     }
   }
 
-  private void seekToInternal(int periodIndex, long periodPositionUs) throws ExoPlaybackException {
-    try {
-      if (periodPositionUs == C.TIME_UNSET && timeline != null
-          && periodIndex < timeline.getPeriodCount()) {
-        // We know about the window, so seek to its default initial position now.
-        Pair<Integer, Long> defaultPosition = getDefaultPosition(periodIndex);
-        periodIndex = defaultPosition.first;
-        periodPositionUs = defaultPosition.second;
-      }
+  private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
+    if (timeline == null) {
+      pendingInitialSeekCount++;
+      pendingSeekPosition = seekPosition;
+      return;
+    }
 
+    Pair<Integer, Long> periodPosition = resolveSeekPosition(seekPosition);
+    if (periodPosition == null) {
+      // The seek position was valid for the timeline that it was performed into, but the
+      // timeline has changed and a suitable seek position could not be resolved in the new one.
+      playbackInfo = new PlaybackInfo(0, 0);
+      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0, playbackInfo).sendToTarget();
+      // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't
+      // ignored.
+      playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
+      setState(ExoPlayer.STATE_ENDED);
+      // Reset, but retain the source so that it can still be used should a seek occur.
+      resetInternal(false);
+      return;
+    }
+
+    boolean seekPositionAdjusted = seekPosition.windowPositionUs == C.TIME_UNSET;
+    int periodIndex = periodPosition.first;
+    long periodPositionUs = periodPosition.second;
+
+    try {
       if (periodIndex == playbackInfo.periodIndex
-          && ((periodPositionUs == C.TIME_UNSET && playbackInfo.positionUs == C.TIME_UNSET)
-          || ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000)))) {
+          && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
         // Seek position equals the current position. Do nothing.
         return;
       }
-      periodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      long newPeriodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
+      periodPositionUs = newPeriodPositionUs;
     } finally {
       playbackInfo = new PlaybackInfo(periodIndex, periodPositionUs);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_SEEK_ACK, seekPositionAdjusted ? 1 : 0, 0, playbackInfo)
+          .sendToTarget();
     }
   }
 
   private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
       throws ExoPlaybackException {
-    if (mediaSource == null) {
-      if (periodPositionUs != C.TIME_UNSET) {
-        resetRendererPosition(periodPositionUs);
-      }
-      return periodPositionUs;
-    }
-
     stopRenderers();
     rebuffering = false;
     setState(ExoPlayer.STATE_BUFFERING);
 
-    if (periodPositionUs == C.TIME_UNSET || (readingPeriodHolder != playingPeriodHolder
-        && (periodIndex == playingPeriodHolder.index
-        || periodIndex == readingPeriodHolder.index))) {
-      // Clear the timeline because either the seek position is not known, or a renderer is reading
-      // ahead to the next period and the seek is to either the playing or reading period.
-      periodIndex = C.INDEX_UNSET;
-    }
-
-    MediaPeriodHolder<T> newPlayingPeriodHolder = null;
+    MediaPeriodHolder newPlayingPeriodHolder = null;
     if (playingPeriodHolder == null) {
       // We're still waiting for the first period to be prepared.
       if (loadingPeriodHolder != null) {
@@ -546,7 +588,7 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
       }
     } else {
       // Clear the timeline, but keep the requested period if it is already prepared.
-      MediaPeriodHolder<T> periodHolder = playingPeriodHolder;
+      MediaPeriodHolder periodHolder = playingPeriodHolder;
       while (periodHolder != null) {
         if (periodHolder.index == periodIndex && periodHolder.prepared) {
           newPlayingPeriodHolder = periodHolder;
@@ -557,46 +599,45 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
       }
     }
 
-    // Disable all the renderers if the period is changing.
-    if (newPlayingPeriodHolder != playingPeriodHolder) {
+    // Disable all the renderers if the period being played is changing, or if the renderers are
+    // reading from a period other than the one being played.
+    if (playingPeriodHolder != newPlayingPeriodHolder
+        || playingPeriodHolder != readingPeriodHolder) {
       for (Renderer renderer : enabledRenderers) {
         renderer.disable();
       }
       enabledRenderers = new Renderer[0];
       rendererMediaClock = null;
       rendererMediaClockSource = null;
+      playingPeriodHolder = null;
     }
 
-    // Update loaded periods.
-    bufferAheadPeriodCount = 0;
+    // Update the holders.
     if (newPlayingPeriodHolder != null) {
       newPlayingPeriodHolder.next = null;
+      loadingPeriodHolder = newPlayingPeriodHolder;
+      readingPeriodHolder = newPlayingPeriodHolder;
       setPlayingPeriodHolder(newPlayingPeriodHolder);
-      updateTimelineState();
-      readingPeriodHolder = playingPeriodHolder;
-      loadingPeriodHolder = playingPeriodHolder;
       if (playingPeriodHolder.hasEnabledTracks) {
         periodPositionUs = playingPeriodHolder.mediaPeriod.seekToUs(periodPositionUs);
       }
       resetRendererPosition(periodPositionUs);
       maybeContinueLoading();
     } else {
-      playingPeriodHolder = null;
-      readingPeriodHolder = null;
       loadingPeriodHolder = null;
-      if (periodPositionUs != C.TIME_UNSET) {
-        resetRendererPosition(periodPositionUs);
-      }
+      readingPeriodHolder = null;
+      playingPeriodHolder = null;
+      resetRendererPosition(periodPositionUs);
     }
-    updatePlaybackPositions();
+
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
     return periodPositionUs;
   }
 
   private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackException {
-    long periodOffsetUs = playingPeriodHolder == null ? 0
-        : playingPeriodHolder.rendererPositionOffsetUs;
-    rendererPositionUs = periodOffsetUs + periodPositionUs;
+    rendererPositionUs = playingPeriodHolder == null
+        ? periodPositionUs + RENDERER_TIMESTAMP_OFFSET_US
+        : playingPeriodHolder.toRendererTime(periodPositionUs);
     standaloneMediaClock.setPositionUs(rendererPositionUs);
     for (Renderer renderer : enabledRenderers) {
       renderer.resetPosition(rendererPositionUs);
@@ -604,13 +645,13 @@ private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackExce
   }
 
   private void stopInternal() {
-    resetInternal();
+    resetInternal(true);
     loadControl.onStopped();
     setState(ExoPlayer.STATE_IDLE);
   }
 
   private void releaseInternal() {
-    resetInternal();
+    resetInternal(true);
     loadControl.onReleased();
     setState(ExoPlayer.STATE_IDLE);
     synchronized (this) {
@@ -619,12 +660,13 @@ private void releaseInternal() {
     }
   }
 
-  private void resetInternal() {
+  private void resetInternal(boolean releaseMediaSource) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
     standaloneMediaClock.stop();
     rendererMediaClock = null;
     rendererMediaClockSource = null;
+    rendererPositionUs = RENDERER_TIMESTAMP_OFFSET_US;
     for (Renderer renderer : enabledRenderers) {
       try {
         ensureStopped(renderer);
@@ -637,18 +679,17 @@ private void resetInternal() {
     enabledRenderers = new Renderer[0];
     releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder
         : loadingPeriodHolder);
-    if (mediaSource != null) {
-      mediaSource.releaseSource();
-      mediaSource = null;
-    }
-    isTimelineReady = false;
-    isTimelineEnded = false;
-    playingPeriodHolder = null;
-    readingPeriodHolder = null;
     loadingPeriodHolder = null;
-    timeline = null;
-    bufferAheadPeriodCount = 0;
+    readingPeriodHolder = null;
+    playingPeriodHolder = null;
     setIsLoading(false);
+    if (releaseMediaSource) {
+      if (mediaSource != null) {
+        mediaSource.releaseSource();
+        mediaSource = null;
+      }
+      timeline = null;
+    }
   }
 
   private void sendMessagesInternal(ExoPlayerMessage[] messages) throws ExoPlaybackException {
@@ -680,7 +721,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       return;
     }
     // Reselect tracks on each period in turn, until the selection changes.
-    MediaPeriodHolder<T> periodHolder = playingPeriodHolder;
+    MediaPeriodHolder periodHolder = playingPeriodHolder;
     boolean selectionsChangedForReadPeriod = true;
     while (true) {
       if (periodHolder == null || !periodHolder.prepared) {
@@ -703,13 +744,12 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       boolean recreateStreams = readingPeriodHolder != playingPeriodHolder;
       releasePeriodHoldersFrom(playingPeriodHolder.next);
       playingPeriodHolder.next = null;
-      readingPeriodHolder = playingPeriodHolder;
       loadingPeriodHolder = playingPeriodHolder;
-      bufferAheadPeriodCount = 0;
+      readingPeriodHolder = playingPeriodHolder;
 
       boolean[] streamResetFlags = new boolean[renderers.length];
       long periodPositionUs = playingPeriodHolder.updatePeriodTrackSelection(
-          playbackInfo.positionUs, loadControl, recreateStreams, streamResetFlags);
+          playbackInfo.positionUs, recreateStreams, streamResetFlags);
       if (periodPositionUs != playbackInfo.positionUs) {
         playbackInfo.positionUs = periodPositionUs;
         resetRendererPosition(periodPositionUs);
@@ -741,11 +781,12 @@ private void reselectTracksInternal() throws ExoPlaybackException {
             renderer.disable();
           } else if (streamResetFlags[i]) {
             // The renderer will continue to consume from its current stream, but needs to be reset.
-            renderer.resetPosition(playbackInfo.positionUs);
+            renderer.resetPosition(rendererPositionUs);
           }
         }
       }
-      trackSelector.onSelectionActivated(playingPeriodHolder.trackSelections);
+      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult)
+          .sendToTarget();
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
@@ -754,26 +795,29 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       while (periodHolder != null) {
         periodHolder.release();
         periodHolder = periodHolder.next;
-        bufferAheadPeriodCount--;
       }
       loadingPeriodHolder.next = null;
-      long loadingPeriodPositionUs = Math.max(0,
-          rendererPositionUs - loadingPeriodHolder.rendererPositionOffsetUs);
-      loadingPeriodHolder.updatePeriodTrackSelection(loadingPeriodPositionUs, loadControl, false);
+      if (loadingPeriodHolder.prepared) {
+        long loadingPeriodPositionUs = Math.max(loadingPeriodHolder.startPositionUs,
+            loadingPeriodHolder.toPeriodTime(rendererPositionUs));
+        loadingPeriodHolder.updatePeriodTrackSelection(loadingPeriodPositionUs, false);
+      }
     }
     maybeContinueLoading();
     updatePlaybackPositions();
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
+  private boolean isTimelineReady(long playingPeriodDurationUs) {
+    return playingPeriodDurationUs == C.TIME_UNSET
+        || playbackInfo.positionUs < playingPeriodDurationUs
+        || (playingPeriodHolder.next != null && playingPeriodHolder.next.prepared);
+  }
+
   private boolean haveSufficientBuffer(boolean rebuffering) {
-    if (loadingPeriodHolder == null) {
-      return false;
-    }
-    long loadingPeriodPositionUs = rendererPositionUs
-        - loadingPeriodHolder.rendererPositionOffsetUs;
-    long loadingPeriodBufferedPositionUs =
-        !loadingPeriodHolder.prepared ? 0 : loadingPeriodHolder.mediaPeriod.getBufferedPositionUs();
+    long loadingPeriodBufferedPositionUs = !loadingPeriodHolder.prepared
+        ? loadingPeriodHolder.startPositionUs
+        : loadingPeriodHolder.mediaPeriod.getBufferedPositionUs();
     if (loadingPeriodBufferedPositionUs == C.TIME_END_OF_SOURCE) {
       if (loadingPeriodHolder.isLast) {
         return true;
@@ -782,7 +826,8 @@ private boolean haveSufficientBuffer(boolean rebuffering) {
           .getDurationUs();
     }
     return loadControl.shouldStartPlayback(
-        loadingPeriodBufferedPositionUs - loadingPeriodPositionUs, rebuffering);
+        loadingPeriodBufferedPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs),
+        rebuffering);
   }
 
   private void maybeThrowPeriodPrepareError() throws IOException {
@@ -798,134 +843,250 @@ private void maybeThrowPeriodPrepareError() throws IOException {
   }
 
   private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifest)
-      throws ExoPlaybackException, IOException {
-    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED, timelineAndManifest).sendToTarget();
-    Timeline oldTimeline = this.timeline;
-    this.timeline = timelineAndManifest.first;
-
-    // Update the loaded periods to take into account the new timeline.
-    if (playingPeriodHolder != null) {
-      int index = timeline.getIndexOfPeriod(playingPeriodHolder.uid);
-      if (index == C.INDEX_UNSET) {
-        attemptRestart(timeline, oldTimeline, playingPeriodHolder.index);
-        return;
+      throws ExoPlaybackException {
+    Timeline oldTimeline = timeline;
+    timeline = timelineAndManifest.first;
+    Object manifest = timelineAndManifest.second;
+
+    int processedInitialSeekCount = 0;
+    if (oldTimeline == null) {
+      if (pendingInitialSeekCount > 0) {
+        Pair<Integer, Long> periodPosition = resolveSeekPosition(pendingSeekPosition);
+        processedInitialSeekCount = pendingInitialSeekCount;
+        pendingInitialSeekCount = 0;
+        pendingSeekPosition = null;
+        if (periodPosition == null) {
+          // The seek position was valid for the timeline that it was performed into, but the
+          // timeline has changed and a suitable seek position could not be resolved in the new one.
+          handleSourceInfoRefreshEndedPlayback(manifest, processedInitialSeekCount);
+          return;
+        }
+        playbackInfo = new PlaybackInfo(periodPosition.first, periodPosition.second);
+      } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
+        if (timeline.isEmpty()) {
+          handleSourceInfoRefreshEndedPlayback(manifest, processedInitialSeekCount);
+          return;
+        }
+        Pair<Integer, Long> defaultPosition = getPeriodPosition(0, C.TIME_UNSET);
+        playbackInfo = new PlaybackInfo(defaultPosition.first, defaultPosition.second);
       }
+    }
 
-      // The playing period is also in the new timeline. Update the index for each loaded period
-      // until a period is found that does not match the old timeline.
-      timeline.getPeriod(index, period, true);
-      playingPeriodHolder.setIndex(timeline, timeline.getWindow(period.windowIndex, window),
-          index);
-
-      MediaPeriodHolder<T> previousPeriodHolder = playingPeriodHolder;
-      boolean seenReadingPeriod = false;
-      bufferAheadPeriodCount = 0;
-      while (previousPeriodHolder.next != null) {
-        MediaPeriodHolder<T> periodHolder = previousPeriodHolder.next;
-        index++;
-        timeline.getPeriod(index, period, true);
-        if (!periodHolder.uid.equals(period.uid)) {
-          if (!seenReadingPeriod) {
-            // Renderers may have read a period that has been removed, so release all loaded periods
-            // and seek to the current position of the playing period index.
-            index = playingPeriodHolder.index;
-            releasePeriodHoldersFrom(playingPeriodHolder);
-            playingPeriodHolder = null;
-            readingPeriodHolder = null;
-            loadingPeriodHolder = null;
-            long newPositionUs = seekToPeriodPosition(index, playbackInfo.positionUs);
-            if (newPositionUs != playbackInfo.positionUs) {
-              playbackInfo = new PlaybackInfo(index, newPositionUs);
-              eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
-            }
-            return;
-          }
+    MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder
+        : loadingPeriodHolder;
+    if (periodHolder == null) {
+      // We don't have any period holders, so we're done.
+      notifySourceInfoRefresh(manifest, processedInitialSeekCount);
+      return;
+    }
+
+    int periodIndex = timeline.getIndexOfPeriod(periodHolder.uid);
+    if (periodIndex == C.INDEX_UNSET) {
+      // We didn't find the current period in the new timeline. Attempt to resolve a subsequent
+      // period whose window we can restart from.
+      int newPeriodIndex = resolveSubsequentPeriod(periodHolder.index, oldTimeline, timeline);
+      if (newPeriodIndex == C.INDEX_UNSET) {
+        // We failed to resolve a suitable restart position.
+        handleSourceInfoRefreshEndedPlayback(manifest, processedInitialSeekCount);
+        return;
+      }
+      // We resolved a subsequent period. Seek to the default position in the corresponding window.
+      Pair<Integer, Long> defaultPosition = getPeriodPosition(
+          timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
+      newPeriodIndex = defaultPosition.first;
+      long newPositionUs = defaultPosition.second;
+      timeline.getPeriod(newPeriodIndex, period, true);
+      // Clear the index of each holder that doesn't contain the default position. If a holder
+      // contains the default position then update its index so it can be re-used when seeking.
+      Object newPeriodUid = period.uid;
+      periodHolder.index = C.INDEX_UNSET;
+      while (periodHolder.next != null) {
+        periodHolder = periodHolder.next;
+        periodHolder.index = periodHolder.uid.equals(newPeriodUid) ? newPeriodIndex : C.INDEX_UNSET;
+      }
+      // Actually do the seek.
+      newPositionUs = seekToPeriodPosition(newPeriodIndex, newPositionUs);
+      playbackInfo = new PlaybackInfo(newPeriodIndex, newPositionUs);
+      notifySourceInfoRefresh(manifest, processedInitialSeekCount);
+      return;
+    }
 
-          // Update the loading period to be the latest period that is still valid.
+    // The current period is in the new timeline. Update the holder and playbackInfo.
+    timeline.getPeriod(periodIndex, period);
+    boolean isLastPeriod = periodIndex == timeline.getPeriodCount() - 1
+        && !timeline.getWindow(period.windowIndex, window).isDynamic;
+    periodHolder.setIndex(periodIndex, isLastPeriod);
+    boolean seenReadingPeriod = periodHolder == readingPeriodHolder;
+    if (periodIndex != playbackInfo.periodIndex) {
+      playbackInfo = playbackInfo.copyWithPeriodIndex(periodIndex);
+    }
+
+    // If there are subsequent holders, update the index for each of them. If we find a holder
+    // that's inconsistent with the new timeline then take appropriate action.
+    while (periodHolder.next != null) {
+      MediaPeriodHolder previousPeriodHolder = periodHolder;
+      periodHolder = periodHolder.next;
+      periodIndex++;
+      timeline.getPeriod(periodIndex, period, true);
+      isLastPeriod = periodIndex == timeline.getPeriodCount() - 1
+          && !timeline.getWindow(period.windowIndex, window).isDynamic;
+      if (periodHolder.uid.equals(period.uid)) {
+        // The holder is consistent with the new timeline. Update its index and continue.
+        periodHolder.setIndex(periodIndex, isLastPeriod);
+        seenReadingPeriod |= (periodHolder == readingPeriodHolder);
+      } else {
+        // The holder is inconsistent with the new timeline.
+        if (!seenReadingPeriod) {
+          // Renderers may have read from a period that's been removed. Seek back to the current
+          // position of the playing period to make sure none of the removed period is played.
+          periodIndex = playingPeriodHolder.index;
+          long newPositionUs = seekToPeriodPosition(periodIndex, playbackInfo.positionUs);
+          playbackInfo = new PlaybackInfo(periodIndex, newPositionUs);
+        } else {
+          // Update the loading period to be the last period that's still valid, and release all
+          // subsequent periods.
           loadingPeriodHolder = previousPeriodHolder;
           loadingPeriodHolder.next = null;
-
           // Release the rest of the timeline.
           releasePeriodHoldersFrom(periodHolder);
-          break;
-        }
-
-        bufferAheadPeriodCount++;
-        int windowIndex = timeline.getPeriod(index, period).windowIndex;
-        periodHolder.setIndex(timeline, timeline.getWindow(windowIndex, window), index);
-        if (periodHolder == readingPeriodHolder) {
-          seenReadingPeriod = true;
         }
-        previousPeriodHolder = periodHolder;
-      }
-    } else if (loadingPeriodHolder != null) {
-      Object uid = loadingPeriodHolder.uid;
-      int index = timeline.getIndexOfPeriod(uid);
-      if (index == C.INDEX_UNSET) {
-        attemptRestart(timeline, oldTimeline, loadingPeriodHolder.index);
-        return;
-      } else {
-        int windowIndex = timeline.getPeriod(index, this.period).windowIndex;
-        loadingPeriodHolder.setIndex(timeline, timeline.getWindow(windowIndex, window),
-            index);
+        break;
       }
     }
 
-    // TODO[playlists]: Signal the identifier discontinuity, even if the index hasn't changed.
-    if (oldTimeline != null) {
-      int newPlayingIndex = playingPeriodHolder != null ? playingPeriodHolder.index
-          : loadingPeriodHolder != null ? loadingPeriodHolder.index : C.INDEX_UNSET;
-      if (newPlayingIndex != C.INDEX_UNSET
-          && newPlayingIndex != playbackInfo.periodIndex) {
-        playbackInfo = new PlaybackInfo(newPlayingIndex, playbackInfo.positionUs);
-        updatePlaybackPositions();
-        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
-      }
-    }
+    notifySourceInfoRefresh(manifest, processedInitialSeekCount);
+  }
+
+  private void handleSourceInfoRefreshEndedPlayback(Object manifest,
+      int processedInitialSeekCount) {
+    // Set the playback position to (0,0) for notifying the eventHandler.
+    playbackInfo = new PlaybackInfo(0, 0);
+    notifySourceInfoRefresh(manifest, processedInitialSeekCount);
+    // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't ignored.
+    playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
+    setState(ExoPlayer.STATE_ENDED);
+    // Reset, but retain the source so that it can still be used should a seek occur.
+    resetInternal(false);
   }
 
-  private void attemptRestart(Timeline newTimeline, Timeline oldTimeline,
-      int oldPeriodIndex) throws ExoPlaybackException {
+  private void notifySourceInfoRefresh(Object manifest, int processedInitialSeekCount) {
+    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED,
+        new SourceInfo(timeline, manifest, playbackInfo, processedInitialSeekCount)).sendToTarget();
+  }
+
+  /**
+   * Given a period index into an old timeline, finds the first subsequent period that also exists
+   * in a new timeline. The index of this period in the new timeline is returned.
+   *
+   * @param oldPeriodIndex The index of the period in the old timeline.
+   * @param oldTimeline The old timeline.
+   * @param newTimeline The new timeline.
+   * @return The index in the new timeline of the first subsequent period, or {@link C#INDEX_UNSET}
+   *     if no such period was found.
+   */
+  private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
+      Timeline newTimeline) {
     int newPeriodIndex = C.INDEX_UNSET;
-    while (newPeriodIndex == C.INDEX_UNSET
-        && oldPeriodIndex < oldTimeline.getPeriodCount() - 1) {
-      newPeriodIndex =
-          newTimeline.getIndexOfPeriod(oldTimeline.getPeriod(++oldPeriodIndex, period, true).uid);
-    }
-    if (newPeriodIndex == C.INDEX_UNSET) {
-      // We failed to find a replacement period. Stop the player.
-      stopInternal();
-      return;
+    while (newPeriodIndex == C.INDEX_UNSET && oldPeriodIndex < oldTimeline.getPeriodCount() - 1) {
+      newPeriodIndex = newTimeline.getIndexOfPeriod(
+          oldTimeline.getPeriod(++oldPeriodIndex, period, true).uid);
     }
+    return newPeriodIndex;
+  }
 
-    // Release all loaded periods.
-    releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder
-        : loadingPeriodHolder);
-    bufferAheadPeriodCount = 0;
-    playingPeriodHolder = null;
-    readingPeriodHolder = null;
-    loadingPeriodHolder = null;
+  /**
+   * Converts a {@link SeekPosition} into the corresponding (periodIndex, periodPositionUs) for the
+   * internal timeline.
+   *
+   * @param seekPosition The position to resolve.
+   * @return The resolved position, or null if resolution was not successful.
+   * @throws IllegalSeekPositionException If the window index of the seek position is outside the
+   *     bounds of the timeline.
+   */
+  private Pair<Integer, Long> resolveSeekPosition(SeekPosition seekPosition) {
+    Timeline seekTimeline = seekPosition.timeline;
+    if (seekTimeline.isEmpty()) {
+      // The application performed a blind seek without a non-empty timeline (most likely based on
+      // knowledge of what the future timeline will be). Use the internal timeline.
+      seekTimeline = timeline;
+    }
+    // Map the SeekPosition to a position in the corresponding timeline.
+    Pair<Integer, Long> periodPosition;
+    try {
+      periodPosition = getPeriodPosition(seekTimeline, seekPosition.windowIndex,
+          seekPosition.windowPositionUs);
+    } catch (IndexOutOfBoundsException e) {
+      // The window index of the seek position was outside the bounds of the timeline.
+      throw new IllegalSeekPositionException(timeline, seekPosition.windowIndex,
+          seekPosition.windowPositionUs);
+    }
+    if (timeline == seekTimeline) {
+      // Our internal timeline is the seek timeline, so the mapped position is correct.
+      return periodPosition;
+    }
+    // Attempt to find the mapped period in the internal timeline.
+    int periodIndex = timeline.getIndexOfPeriod(
+        seekTimeline.getPeriod(periodPosition.first, period, true).uid);
+    if (periodIndex != C.INDEX_UNSET) {
+      // We successfully located the period in the internal timeline.
+      return Pair.create(periodIndex, periodPosition.second);
+    }
+    // Try and find a subsequent period from the seek timeline in the internal timeline.
+    periodIndex = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
+    if (periodIndex != C.INDEX_UNSET) {
+      // We found one. Map the SeekPosition onto the corresponding default position.
+      return getPeriodPosition(timeline.getPeriod(periodIndex, period).windowIndex, C.TIME_UNSET);
+    }
+    // We didn't find one. Give up.
+    return null;
+  }
 
-    // Find the default initial position in the window and seek to it.
-    Pair<Integer, Long> defaultPosition = getDefaultPosition(newPeriodIndex);
-    newPeriodIndex = defaultPosition.first;
-    long newPlayingPositionUs = defaultPosition.second;
+  /**
+   * Calls {@link #getPeriodPosition(Timeline, int, long)} using the current timeline.
+   */
+  private Pair<Integer, Long> getPeriodPosition(int windowIndex, long windowPositionUs) {
+    return getPeriodPosition(timeline, windowIndex, windowPositionUs);
+  }
 
-    playbackInfo = new PlaybackInfo(newPeriodIndex, newPlayingPositionUs);
-    eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
+  /**
+   * Calls {@link #getPeriodPosition(Timeline, int, long, long)} with a zero default position
+   * projection.
+   */
+  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
+      long windowPositionUs) {
+    return getPeriodPosition(timeline, windowIndex, windowPositionUs, 0);
   }
 
-  private Pair<Integer, Long> getDefaultPosition(int periodIndex) {
-    timeline.getPeriod(periodIndex, period);
-    timeline.getWindow(period.windowIndex, window);
-    periodIndex = window.firstPeriodIndex;
-    long periodPositionUs = window.getPositionInFirstPeriodUs()
-        + window.getDefaultPositionUs();
-    timeline.getPeriod(periodIndex, period);
-    while (periodIndex < window.lastPeriodIndex
-        && periodPositionUs > period.getDurationMs()) {
-      periodPositionUs -= period.getDurationUs();
-      timeline.getPeriod(periodIndex++, period);
+  /**
+   * Converts (windowIndex, windowPositionUs) to the corresponding (periodIndex, periodPositionUs).
+   *
+   * @param timeline The timeline containing the window.
+   * @param windowIndex The window index.
+   * @param windowPositionUs The window time, or {@link C#TIME_UNSET} to use the window's default
+   *     start position.
+   * @param defaultPositionProjectionUs If {@code windowPositionUs} is {@link C#TIME_UNSET}, the
+   *     duration into the future by which the window's position should be projected.
+   * @return The corresponding (periodIndex, periodPositionUs), or null if {@code #windowPositionUs}
+   *     is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
+   *     position could not be projected by {@code defaultPositionProjectionUs}.
+   */
+  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
+      long windowPositionUs, long defaultPositionProjectionUs) {
+    Assertions.checkIndex(windowIndex, 0, timeline.getWindowCount());
+    timeline.getWindow(windowIndex, window, false, defaultPositionProjectionUs);
+    if (windowPositionUs == C.TIME_UNSET) {
+      windowPositionUs = window.getDefaultPositionUs();
+      if (windowPositionUs == C.TIME_UNSET) {
+        return null;
+      }
+    }
+    int periodIndex = window.firstPeriodIndex;
+    long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
+    long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();
+    while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
+        && periodIndex < window.lastPeriodIndex) {
+      periodPositionUs -= periodDurationUs;
+      periodDurationUs = timeline.getPeriod(++periodIndex, period).getDurationUs();
     }
     return Pair.create(periodIndex, periodPositionUs);
   }
@@ -937,48 +1098,8 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       return;
     }
 
-    if (loadingPeriodHolder == null
-        || (loadingPeriodHolder.isFullyBuffered() && !loadingPeriodHolder.isLast
-        && bufferAheadPeriodCount < MAXIMUM_BUFFER_AHEAD_PERIODS)) {
-      // We don't have a loading period or it's fully loaded, so try and create the next one.
-      int newLoadingPeriodIndex = loadingPeriodHolder == null ? playbackInfo.periodIndex
-          : loadingPeriodHolder.index + 1;
-      if (newLoadingPeriodIndex >= timeline.getPeriodCount()) {
-        // The period is not available yet.
-        mediaSource.maybeThrowSourceInfoRefreshError();
-      } else {
-        int windowIndex = timeline.getPeriod(newLoadingPeriodIndex, period).windowIndex;
-        boolean isFirstPeriodInWindow = newLoadingPeriodIndex
-            == timeline.getWindow(windowIndex, window).firstPeriodIndex;
-        long periodStartPositionUs = loadingPeriodHolder == null ? playbackInfo.positionUs
-            : (isFirstPeriodInWindow ? C.TIME_UNSET : 0);
-        if (periodStartPositionUs == C.TIME_UNSET) {
-          // This is the first period of a new window or we don't have a start position, so seek to
-          // the default position for the window.
-          Pair<Integer, Long> defaultPosition = getDefaultPosition(newLoadingPeriodIndex);
-          newLoadingPeriodIndex = defaultPosition.first;
-          periodStartPositionUs = defaultPosition.second;
-        }
-        Object newPeriodUid = timeline.getPeriod(newLoadingPeriodIndex, period, true).uid;
-        MediaPeriod newMediaPeriod = mediaSource.createPeriod(newLoadingPeriodIndex,
-            loadControl.getAllocator(), periodStartPositionUs);
-        newMediaPeriod.prepare(this);
-        MediaPeriodHolder<T> newPeriodHolder = new MediaPeriodHolder<>(renderers,
-            rendererCapabilities, trackSelector, mediaSource, newMediaPeriod, newPeriodUid,
-            periodStartPositionUs);
-        timeline.getWindow(windowIndex, window);
-        newPeriodHolder.setIndex(timeline, window, newLoadingPeriodIndex);
-        if (loadingPeriodHolder != null) {
-          loadingPeriodHolder.setNext(newPeriodHolder);
-          newPeriodHolder.rendererPositionOffsetUs = loadingPeriodHolder.rendererPositionOffsetUs
-              + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs();
-        }
-        bufferAheadPeriodCount++;
-        loadingPeriodHolder = newPeriodHolder;
-        setIsLoading(true);
-      }
-    }
-
+    // Update the loading period if required.
+    maybeUpdateLoadingPeriod();
     if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
       setIsLoading(false);
     } else if (loadingPeriodHolder != null && loadingPeriodHolder.needsContinueLoading) {
@@ -991,43 +1112,62 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     // Update the playing and reading periods.
-    while (playingPeriodHolder != readingPeriodHolder && playingPeriodHolder.next != null
+    while (playingPeriodHolder != readingPeriodHolder
         && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
       playingPeriodHolder.release();
       setPlayingPeriodHolder(playingPeriodHolder.next);
-      bufferAheadPeriodCount--;
       playbackInfo = new PlaybackInfo(playingPeriodHolder.index,
           playingPeriodHolder.startPositionUs);
       updatePlaybackPositions();
       eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
     }
-    updateTimelineState();
 
     if (readingPeriodHolder.isLast) {
-      // The renderers have their final SampleStreams.
-      for (Renderer renderer : enabledRenderers) {
-        renderer.setCurrentStreamIsFinal();
+      for (int i = 0; i < renderers.length; i++) {
+        Renderer renderer = renderers[i];
+        SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
+        // Defer setting the stream as final until the renderer has actually consumed the whole
+        // stream in case of playlist changes that cause the stream to be no longer final.
+        if (sampleStream != null && renderer.getStream() == sampleStream
+            && renderer.hasReadStreamToEnd()) {
+          renderer.setCurrentStreamFinal();
+        }
       }
       return;
     }
 
-    for (Renderer renderer : enabledRenderers) {
-      if (!renderer.hasReadStreamToEnd()) {
+    for (int i = 0; i < renderers.length; i++) {
+      Renderer renderer = renderers[i];
+      SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
+      if (renderer.getStream() != sampleStream
+          || (sampleStream != null && !renderer.hasReadStreamToEnd())) {
         return;
       }
     }
+
     if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
-      TrackSelections<T> oldTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
       readingPeriodHolder = readingPeriodHolder.next;
-      TrackSelections<T> newTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
+
+      boolean initialDiscontinuity =
+          readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
       for (int i = 0; i < renderers.length; i++) {
         Renderer renderer = renderers[i];
-        TrackSelection oldSelection = oldTrackSelections.get(i);
-        TrackSelection newSelection = newTrackSelections.get(i);
-        if (oldSelection != null) {
-          if (newSelection != null) {
+        TrackSelection oldSelection = oldTrackSelectorResult.selections.get(i);
+        if (oldSelection == null) {
+          // The renderer has no current stream and will be enabled when we play the next period.
+        } else if (initialDiscontinuity) {
+          // The new period starts with a discontinuity, so the renderer will play out all data then
+          // be disabled and re-enabled when it starts playing the next period.
+          renderer.setCurrentStreamFinal();
+        } else if (!renderer.isCurrentStreamFinal()) {
+          TrackSelection newSelection = newTrackSelectorResult.selections.get(i);
+          RendererConfiguration oldConfig = oldTrackSelectorResult.rendererConfigurations[i];
+          RendererConfiguration newConfig = newTrackSelectorResult.rendererConfigurations[i];
+          if (newSelection != null && newConfig.equals(oldConfig)) {
             // Replace the renderer's SampleStream so the transition to playing the next period can
             // be seamless.
             Format[] formats = new Format[newSelection.length()];
@@ -1035,52 +1175,122 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
               formats[j] = newSelection.getFormat(j);
             }
             renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
-                readingPeriodHolder.rendererPositionOffsetUs);
+                readingPeriodHolder.getRendererOffset());
           } else {
-            // The renderer will be disabled when transitioning to playing the next period. Mark the
-            // SampleStream as final to play out any remaining data.
-            renderer.setCurrentStreamIsFinal();
+            // The renderer will be disabled when transitioning to playing the next period, either
+            // because there's no new selection or because a configuration change is required. Mark
+            // the SampleStream as final to play out any remaining data.
+            renderer.setCurrentStreamFinal();
           }
         }
       }
     }
   }
 
+  private void maybeUpdateLoadingPeriod() throws IOException {
+    int newLoadingPeriodIndex;
+    if (loadingPeriodHolder == null) {
+      newLoadingPeriodIndex = playbackInfo.periodIndex;
+    } else {
+      int loadingPeriodIndex = loadingPeriodHolder.index;
+      if (loadingPeriodHolder.isLast || !loadingPeriodHolder.isFullyBuffered()
+          || timeline.getPeriod(loadingPeriodIndex, period).getDurationUs() == C.TIME_UNSET) {
+        // Either the existing loading period is the last period, or we are not ready to advance to
+        // loading the next period because it hasn't been fully buffered or its duration is unknown.
+        return;
+      }
+      if (playingPeriodHolder != null
+          && loadingPeriodIndex - playingPeriodHolder.index == MAXIMUM_BUFFER_AHEAD_PERIODS) {
+        // We are already buffering the maximum number of periods ahead.
+        return;
+      }
+      newLoadingPeriodIndex = loadingPeriodHolder.index + 1;
+    }
+
+    if (newLoadingPeriodIndex >= timeline.getPeriodCount()) {
+      // The next period is not available yet.
+      mediaSource.maybeThrowSourceInfoRefreshError();
+      return;
+    }
+
+    long newLoadingPeriodStartPositionUs;
+    if (loadingPeriodHolder == null) {
+      newLoadingPeriodStartPositionUs = playbackInfo.positionUs;
+    } else {
+      int newLoadingWindowIndex = timeline.getPeriod(newLoadingPeriodIndex, period).windowIndex;
+      if (newLoadingPeriodIndex
+          != timeline.getWindow(newLoadingWindowIndex, window).firstPeriodIndex) {
+        // We're starting to buffer a new period in the current window. Always start from the
+        // beginning of the period.
+        newLoadingPeriodStartPositionUs = 0;
+      } else {
+        // We're starting to buffer a new window. When playback transitions to this window we'll
+        // want it to be from its default start position. The expected delay until playback
+        // transitions is equal the duration of media that's currently buffered (assuming no
+        // interruptions). Hence we project the default start position forward by the duration of
+        // the buffer, and start buffering from this point.
+        long defaultPositionProjectionUs = loadingPeriodHolder.getRendererOffset()
+            + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs()
+            - rendererPositionUs;
+        Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline, newLoadingWindowIndex,
+            C.TIME_UNSET, Math.max(0, defaultPositionProjectionUs));
+        if (defaultPosition == null) {
+          return;
+        }
+
+        newLoadingPeriodIndex = defaultPosition.first;
+        newLoadingPeriodStartPositionUs = defaultPosition.second;
+      }
+    }
+
+    long rendererPositionOffsetUs = loadingPeriodHolder == null
+        ? newLoadingPeriodStartPositionUs + RENDERER_TIMESTAMP_OFFSET_US
+        : (loadingPeriodHolder.getRendererOffset()
+            + timeline.getPeriod(loadingPeriodHolder.index, period).getDurationUs());
+    timeline.getPeriod(newLoadingPeriodIndex, period, true);
+    boolean isLastPeriod = newLoadingPeriodIndex == timeline.getPeriodCount() - 1
+        && !timeline.getWindow(period.windowIndex, window).isDynamic;
+    MediaPeriodHolder newPeriodHolder = new MediaPeriodHolder(renderers, rendererCapabilities,
+        rendererPositionOffsetUs, trackSelector, loadControl, mediaSource, period.uid,
+        newLoadingPeriodIndex, isLastPeriod, newLoadingPeriodStartPositionUs);
+    if (loadingPeriodHolder != null) {
+      loadingPeriodHolder.next = newPeriodHolder;
+    }
+    loadingPeriodHolder = newPeriodHolder;
+    loadingPeriodHolder.mediaPeriod.prepare(this);
+    setIsLoading(true);
+  }
+
   private void handlePeriodPrepared(MediaPeriod period) throws ExoPlaybackException {
     if (loadingPeriodHolder == null || loadingPeriodHolder.mediaPeriod != period) {
       // Stale event.
       return;
     }
-    loadingPeriodHolder.handlePrepared(loadingPeriodHolder.startPositionUs, loadControl);
+    loadingPeriodHolder.handlePrepared();
     if (playingPeriodHolder == null) {
       // This is the first prepared period, so start playing it.
       readingPeriodHolder = loadingPeriodHolder;
+      resetRendererPosition(readingPeriodHolder.startPositionUs);
       setPlayingPeriodHolder(readingPeriodHolder);
-      if (playbackInfo.startPositionUs == C.TIME_UNSET) {
-        // Update the playback info when seeking to a default position.
-        playbackInfo = new PlaybackInfo(playingPeriodHolder.index,
-            playingPeriodHolder.startPositionUs);
-        resetRendererPosition(playbackInfo.startPositionUs);
-        updatePlaybackPositions();
-        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
-      }
-      updateTimelineState();
     }
     maybeContinueLoading();
   }
 
   private void handleContinueLoadingRequested(MediaPeriod period) {
     if (loadingPeriodHolder == null || loadingPeriodHolder.mediaPeriod != period) {
+      // Stale event.
       return;
     }
     maybeContinueLoading();
   }
 
   private void maybeContinueLoading() {
-    long nextLoadPositionUs = loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
-    if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
-      long loadingPeriodPositionUs = rendererPositionUs
-          - loadingPeriodHolder.rendererPositionOffsetUs;
+    long nextLoadPositionUs = !loadingPeriodHolder.prepared ? 0
+        : loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
+    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
+      setIsLoading(false);
+    } else {
+      long loadingPeriodPositionUs = loadingPeriodHolder.toPeriodTime(rendererPositionUs);
       long bufferedDurationUs = nextLoadPositionUs - loadingPeriodPositionUs;
       boolean continueLoading = loadControl.shouldContinueLoading(bufferedDurationUs);
       setIsLoading(continueLoading);
@@ -1090,31 +1300,36 @@ private void maybeContinueLoading() {
       } else {
         loadingPeriodHolder.needsContinueLoading = true;
       }
-    } else {
-      setIsLoading(false);
     }
   }
 
-  private void releasePeriodHoldersFrom(MediaPeriodHolder<T> periodHolder) {
+  private void releasePeriodHoldersFrom(MediaPeriodHolder periodHolder) {
     while (periodHolder != null) {
       periodHolder.release();
       periodHolder = periodHolder.next;
     }
   }
 
-  private void setPlayingPeriodHolder(MediaPeriodHolder<T> periodHolder)
-      throws ExoPlaybackException {
+  private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPlaybackException {
+    if (playingPeriodHolder == periodHolder) {
+      return;
+    }
+
     int enabledRendererCount = 0;
     boolean[] rendererWasEnabledFlags = new boolean[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      TrackSelection newSelection = periodHolder.trackSelections.get(i);
+      TrackSelection newSelection = periodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
-        // The renderer should be enabled when playing the new period.
         enabledRendererCount++;
-      } else if (rendererWasEnabledFlags[i]) {
-        // The renderer should be disabled when playing the new period.
+      }
+      if (rendererWasEnabledFlags[i] && (newSelection == null
+          || (renderer.isCurrentStreamFinal()
+          && renderer.getStream() == playingPeriodHolder.sampleStreams[i]))) {
+        // The renderer should be disabled before playing the next period, either because it's not
+        // needed to play the next period, or because we need to re-enable it as its current stream
+        // is final and it's not reading ahead.
         if (renderer == rendererMediaClockSource) {
           // Sync standaloneMediaClock so that it can take over timing responsibilities.
           standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
@@ -1126,30 +1341,23 @@ private void setPlayingPeriodHolder(MediaPeriodHolder<T> periodHolder)
       }
     }
 
-    trackSelector.onSelectionActivated(periodHolder.trackSelections);
     playingPeriodHolder = periodHolder;
+    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult).sendToTarget();
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
-  private void updateTimelineState() {
-    long playingPeriodDurationUs = timeline.getPeriod(playingPeriodHolder.index, period)
-        .getDurationUs();
-    isTimelineReady = playingPeriodDurationUs == C.TIME_UNSET
-        || playbackInfo.positionUs < playingPeriodDurationUs
-        || (playingPeriodHolder.next != null && playingPeriodHolder.next.prepared);
-    isTimelineEnded = playingPeriodHolder.isLast;
-  }
-
   private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRendererCount)
       throws ExoPlaybackException {
     enabledRenderers = new Renderer[enabledRendererCount];
     enabledRendererCount = 0;
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
-      TrackSelection newSelection = playingPeriodHolder.trackSelections.get(i);
+      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
         enabledRenderers[enabledRendererCount++] = renderer;
         if (renderer.getState() == Renderer.STATE_DISABLED) {
+          RendererConfiguration rendererConfiguration =
+              playingPeriodHolder.trackSelectorResult.rendererConfigurations[i];
           // The renderer needs enabling with its new track selection.
           boolean playing = playWhenReady && state == ExoPlayer.STATE_READY;
           // Consider as joining only if the renderer was previously disabled.
@@ -1160,8 +1368,8 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
             formats[j] = newSelection.getFormat(j);
           }
           // Enable the renderer.
-          renderer.enable(formats, playingPeriodHolder.sampleStreams[i], rendererPositionUs,
-              joining, playingPeriodHolder.rendererPositionOffsetUs);
+          renderer.enable(rendererConfiguration, formats, playingPeriodHolder.sampleStreams[i],
+              rendererPositionUs, joining, playingPeriodHolder.getRendererOffset());
           MediaClock mediaClock = renderer.getMediaClock();
           if (mediaClock != null) {
             if (rendererMediaClock != null) {
@@ -1183,52 +1391,66 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
   /**
    * Holds a {@link MediaPeriod} with information required to play it as part of a timeline.
    */
-  private static final class MediaPeriodHolder<T> {
+  private static final class MediaPeriodHolder {
 
     public final MediaPeriod mediaPeriod;
     public final Object uid;
-
     public final SampleStream[] sampleStreams;
     public final boolean[] mayRetainStreamFlags;
+    public final long rendererPositionOffsetUs;
 
     public int index;
     public long startPositionUs;
     public boolean isLast;
     public boolean prepared;
     public boolean hasEnabledTracks;
-    public long rendererPositionOffsetUs;
-    public MediaPeriodHolder<T> next;
+    public MediaPeriodHolder next;
     public boolean needsContinueLoading;
+    public TrackSelectorResult trackSelectorResult;
 
     private final Renderer[] renderers;
     private final RendererCapabilities[] rendererCapabilities;
-    private final TrackSelector<T> trackSelector;
+    private final TrackSelector trackSelector;
+    private final LoadControl loadControl;
     private final MediaSource mediaSource;
 
-    private TrackSelections<T> trackSelections;
-    private TrackSelections<T> periodTrackSelections;
+    private TrackSelectorResult periodTrackSelectorResult;
 
     public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
-        TrackSelector<T> trackSelector, MediaSource mediaSource, MediaPeriod mediaPeriod,
-        Object uid, long positionUs) {
+        long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
+        MediaSource mediaSource, Object periodUid, int periodIndex, boolean isLastPeriod,
+        long startPositionUs) {
       this.renderers = renderers;
       this.rendererCapabilities = rendererCapabilities;
+      this.rendererPositionOffsetUs = rendererPositionOffsetUs;
       this.trackSelector = trackSelector;
+      this.loadControl = loadControl;
       this.mediaSource = mediaSource;
-      this.mediaPeriod = mediaPeriod;
-      this.uid = Assertions.checkNotNull(uid);
+      this.uid = Assertions.checkNotNull(periodUid);
+      this.index = periodIndex;
+      this.isLast = isLastPeriod;
+      this.startPositionUs = startPositionUs;
       sampleStreams = new SampleStream[renderers.length];
       mayRetainStreamFlags = new boolean[renderers.length];
-      startPositionUs = positionUs;
+      mediaPeriod = mediaSource.createPeriod(periodIndex, loadControl.getAllocator(),
+          startPositionUs);
     }
 
-    public void setNext(MediaPeriodHolder<T> next) {
-      this.next = next;
+    public long toRendererTime(long periodTimeUs) {
+      return periodTimeUs + getRendererOffset();
     }
 
-    public void setIndex(Timeline timeline, Timeline.Window window, int periodIndex) {
-      this.index = periodIndex;
-      isLast = index == timeline.getPeriodCount() - 1 && !window.isDynamic;
+    public long toPeriodTime(long rendererTimeUs) {
+      return rendererTimeUs - getRendererOffset();
+    }
+
+    public long getRendererOffset() {
+      return rendererPositionOffsetUs - startPositionUs;
+    }
+
+    public void setIndex(int index, boolean isLast) {
+      this.index = index;
+      this.isLast = isLast;
     }
 
     public boolean isFullyBuffered() {
@@ -1236,41 +1458,39 @@ public boolean isFullyBuffered() {
           && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
     }
 
-    public void handlePrepared(long positionUs, LoadControl loadControl)
-        throws ExoPlaybackException {
+    public void handlePrepared() throws ExoPlaybackException {
       prepared = true;
       selectTracks();
-      startPositionUs = updatePeriodTrackSelection(positionUs, loadControl, false);
+      startPositionUs = updatePeriodTrackSelection(startPositionUs, false);
     }
 
     public boolean selectTracks() throws ExoPlaybackException {
-      TrackSelections<T> newTrackSelections = trackSelector.selectTracks(rendererCapabilities,
+      TrackSelectorResult selectorResult = trackSelector.selectTracks(rendererCapabilities,
           mediaPeriod.getTrackGroups());
-      if (newTrackSelections.equals(periodTrackSelections)) {
+      if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
         return false;
       }
-      trackSelections = newTrackSelections;
+      trackSelectorResult = selectorResult;
       return true;
     }
 
-    public long updatePeriodTrackSelection(long positionUs, LoadControl loadControl,
-        boolean forceRecreateStreams) throws ExoPlaybackException {
-      return updatePeriodTrackSelection(positionUs, loadControl, forceRecreateStreams,
+    public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams) {
+      return updatePeriodTrackSelection(positionUs, forceRecreateStreams,
           new boolean[renderers.length]);
     }
 
-    public long updatePeriodTrackSelection(long positionUs, LoadControl loadControl,
-        boolean forceRecreateStreams, boolean[] streamResetFlags) throws ExoPlaybackException {
+    public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams,
+        boolean[] streamResetFlags) {
+      TrackSelectionArray trackSelections = trackSelectorResult.selections;
       for (int i = 0; i < trackSelections.length; i++) {
         mayRetainStreamFlags[i] = !forceRecreateStreams
-            && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),
-            trackSelections.get(i));
+            && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
       }
 
       // Disable streams on the period and get new streams for updated/newly-enabled tracks.
       positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
           sampleStreams, streamResetFlags, positionUs);
-      periodTrackSelections = trackSelections;
+      periodTrackSelectorResult = trackSelectorResult;
 
       // Update whether we have enabled tracks and sanity check the expected streams are non-null.
       hasEnabledTracks = false;
@@ -1284,7 +1504,7 @@ public long updatePeriodTrackSelection(long positionUs, LoadControl loadControl,
       }
 
       // The track selection has changed.
-      loadControl.onTracksSelected(renderers, mediaPeriod.getTrackGroups(), trackSelections);
+      loadControl.onTracksSelected(renderers, trackSelectorResult.groups, trackSelections);
       return positionUs;
     }
 
@@ -1299,4 +1519,18 @@ public void release() {
 
   }
 
+  private static final class SeekPosition {
+
+    public final Timeline timeline;
+    public final int windowIndex;
+    public final long windowPositionUs;
+
+    public SeekPosition(Timeline timeline, int windowIndex, long windowPositionUs) {
+      this.timeline = timeline;
+      this.windowIndex = windowIndex;
+      this.windowPositionUs = windowPositionUs;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 23e6d4d593..5100acbbd8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  String VERSION = "2.0.3";
+  String VERSION = "2.2.0";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  int VERSION_INT = 2000003;
+  int VERSION_INT = 2002000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
@@ -45,5 +45,5 @@
    * trace enabled.
    */
   boolean TRACE_ENABLED = true;
- 
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/Format.java b/library/src/main/java/com/google/android/exoplayer2/Format.java
index 550e6ab1d8..0b558153fd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Format.java
@@ -21,6 +21,7 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
@@ -57,6 +58,10 @@
    * Codecs of the format as described in RFC 6381, or null if unknown or not applicable.
    */
   public final String codecs;
+  /**
+   * Metadata, or null if unknown or not applicable.
+   */
+  public final Metadata metadata;
 
   // Container specific.
 
@@ -173,19 +178,23 @@
    */
   public final String language;
 
-  // Lazily initialized hashcode and framework media format.
+  /**
+   * The Accessibility channel, or {@link #NO_VALUE} if not known or applicable.
+   */
+  public final int accessibilityChannel;
 
+  // Lazily initialized hashcode.
   private int hashCode;
-  private MediaFormat frameworkMediaFormat;
 
   // Video.
 
   public static Format createVideoContainerFormat(String id, String containerMimeType,
       String sampleMimeType, String codecs, int bitrate, int width, int height,
-      float frameRate, List<byte[]> initializationData) {
+      float frameRate, List<byte[]> initializationData, @C.SelectionFlags int selectionFlags) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, width,
         height, frameRate, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, initializationData, null);
+        NO_VALUE, NO_VALUE, selectionFlags, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, null, null);
   }
 
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
@@ -210,8 +219,8 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
       byte[] projectionData, @C.StereoMode int stereoMode, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, width, height,
         frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, initializationData,
-        drmInitData);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, drmInitData, null);
   }
 
   // Audio.
@@ -221,8 +230,8 @@ public static Format createAudioContainerFormat(String id, String containerMimeT
       List<byte[]> initializationData, @C.SelectionFlags int selectionFlags, String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, channelCount, sampleRate, NO_VALUE,
-        NO_VALUE, NO_VALUE, selectionFlags, language, OFFSET_SAMPLE_RELATIVE, initializationData,
-        null);
+        NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, null, null);
   }
 
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
@@ -239,18 +248,18 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
       @C.SelectionFlags int selectionFlags, String language) {
     return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
         sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
-        selectionFlags, language);
+        selectionFlags, language, null);
   }
 
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
       @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
       List<byte[]> initializationData, DrmInitData drmInitData,
-      @C.SelectionFlags int selectionFlags, String language) {
+      @C.SelectionFlags int selectionFlags, String language, Metadata metadata) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, channelCount, sampleRate, pcmEncoding,
-        encoderDelay, encoderPadding, selectionFlags, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, drmInitData);
+        encoderDelay, encoderPadding, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, drmInitData, metadata);
   }
 
   // Text.
@@ -258,23 +267,46 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
   public static Format createTextContainerFormat(String id, String containerMimeType,
       String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
       String language) {
+    return createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
+        selectionFlags, language, NO_VALUE);
+  }
+
+  public static Format createTextContainerFormat(String id, String containerMimeType,
+      String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
+      String language, int accessibilityChannel) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, selectionFlags, language, OFFSET_SAMPLE_RELATIVE, null, null);
+        NO_VALUE, NO_VALUE, selectionFlags, language, accessibilityChannel,
+        OFFSET_SAMPLE_RELATIVE, null, null, null);
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, @C.SelectionFlags int selectionFlags, String language, DrmInitData drmInitData) {
     return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
-        drmInitData, OFFSET_SAMPLE_RELATIVE);
+        NO_VALUE, drmInitData, OFFSET_SAMPLE_RELATIVE);
+  }
+
+  public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
+      int bitrate, @C.SelectionFlags int selectionFlags, String language, int accessibilityChannel,
+      DrmInitData drmInitData) {
+    return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
+        accessibilityChannel, drmInitData, OFFSET_SAMPLE_RELATIVE);
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, @C.SelectionFlags int selectionFlags, String language, DrmInitData drmInitData,
       long subsampleOffsetUs) {
+    return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
+        NO_VALUE, drmInitData, subsampleOffsetUs);
+  }
+
+  public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
+      int bitrate, @C.SelectionFlags int selectionFlags, String language,
+      int accessibilityChannel, DrmInitData drmInitData, long subsampleOffsetUs) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, selectionFlags, language, subsampleOffsetUs, null, drmInitData);
+        NO_VALUE, selectionFlags, language, accessibilityChannel, subsampleOffsetUs, null,
+        drmInitData, null);
   }
 
   // Image.
@@ -283,23 +315,33 @@ public static Format createImageSampleFormat(String id, String sampleMimeType, S
       int bitrate, List<byte[]> initializationData, String language, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, language, OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData);
+        NO_VALUE, 0, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData,
+        null);
   }
 
   // Generic.
 
-  public static Format createContainerFormat(String id, String containerMimeType, String codecs,
-      String sampleMimeType, int bitrate) {
+  public static Format createContainerFormat(String id, String containerMimeType,
+      String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
+      String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, null, null);
+        NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null,
+        null);
+  }
+
+  public static Format createSampleFormat(String id, String sampleMimeType,
+      long subsampleOffsetUs) {
+    return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, null, drmInitData);
+        NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, drmInitData, null);
   }
 
   /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
@@ -307,7 +349,8 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
       float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
       int channelCount, int sampleRate, @C.PcmEncoding int pcmEncoding, int encoderDelay,
       int encoderPadding, @C.SelectionFlags int selectionFlags, String language,
-      long subsampleOffsetUs, List<byte[]> initializationData, DrmInitData drmInitData) {
+      int accessibilityChannel, long subsampleOffsetUs, List<byte[]> initializationData,
+      DrmInitData drmInitData, Metadata metadata) {
     this.id = id;
     this.containerMimeType = containerMimeType;
     this.sampleMimeType = sampleMimeType;
@@ -328,10 +371,12 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
     this.encoderPadding = encoderPadding;
     this.selectionFlags = selectionFlags;
     this.language = language;
+    this.accessibilityChannel = accessibilityChannel;
     this.subsampleOffsetUs = subsampleOffsetUs;
     this.initializationData = initializationData == null ? Collections.<byte[]>emptyList()
         : initializationData;
     this.drmInitData = drmInitData;
+    this.metadata = metadata;
   }
 
   @SuppressWarnings("ResourceType")
@@ -357,6 +402,7 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
     encoderPadding = in.readInt();
     selectionFlags = in.readInt();
     language = in.readString();
+    accessibilityChannel = in.readInt();
     subsampleOffsetUs = in.readLong();
     int initializationDataSize = in.readInt();
     initializationData = new ArrayList<>(initializationDataSize);
@@ -364,20 +410,23 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
       initializationData.add(in.createByteArray());
     }
     drmInitData = in.readParcelable(DrmInitData.class.getClassLoader());
+    metadata = in.readParcelable(Metadata.class.getClassLoader());
   }
 
   public Format copyWithMaxInputSize(int maxInputSize) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithContainerInfo(String id, String codecs, int bitrate, int width, int height,
@@ -385,7 +434,8 @@ public Format copyWithContainerInfo(String id, String codecs, int bitrate, int w
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithManifestFormatInfo(Format manifestFormat,
@@ -401,21 +451,32 @@ public Format copyWithManifestFormatInfo(Format manifestFormat,
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
         channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding, selectionFlags,
-        language, subsampleOffsetUs, initializationData, drmInitData);
+        language, accessibilityChannel, subsampleOffsetUs, initializationData, drmInitData,
+        metadata);
   }
 
   public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   public Format copyWithDrmInitData(DrmInitData drmInitData) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
-        selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
+  }
+
+  public Format copyWithMetadata(Metadata metadata) {
+    return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
+        width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
+        stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
+        selectionFlags, language, accessibilityChannel, subsampleOffsetUs, initializationData,
+        drmInitData, metadata);
   }
 
   /**
@@ -432,31 +493,28 @@ public int getPixelCount() {
   @SuppressLint("InlinedApi")
   @TargetApi(16)
   public final MediaFormat getFrameworkMediaFormatV16() {
-    if (frameworkMediaFormat == null) {
-      MediaFormat format = new MediaFormat();
-      format.setString(MediaFormat.KEY_MIME, sampleMimeType);
-      maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
-      maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
-      maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
-      maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
-      maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
-      maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
-      maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
-      maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
-      maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
-      maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
-      for (int i = 0; i < initializationData.size(); i++) {
-        format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
-      }
-      frameworkMediaFormat = format;
+    MediaFormat format = new MediaFormat();
+    format.setString(MediaFormat.KEY_MIME, sampleMimeType);
+    maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
+    maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
+    maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
+    maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
+    maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
+    maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
+    maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
+    maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
+    maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
+    maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
+    for (int i = 0; i < initializationData.size(); i++) {
+      format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
     }
-    return frameworkMediaFormat;
+    return format;
   }
 
   @Override
   public String toString() {
     return "Format(" + id + ", " + containerMimeType + ", " + sampleMimeType + ", " + bitrate + ", "
-        + ", " + language + ", [" + width + ", " + height + ", " + frameRate + "]"
+        + language + ", [" + width + ", " + height + ", " + frameRate + "]"
         + ", [" + channelCount + ", " + sampleRate + "])";
   }
 
@@ -474,7 +532,9 @@ public int hashCode() {
       result = 31 * result + channelCount;
       result = 31 * result + sampleRate;
       result = 31 * result + (language == null ? 0 : language.hashCode());
+      result = 31 * result + accessibilityChannel;
       result = 31 * result + (drmInitData == null ? 0 : drmInitData.hashCode());
+      result = 31 * result + (metadata == null ? 0 : metadata.hashCode());
       hashCode = result;
     }
     return hashCode;
@@ -498,10 +558,12 @@ public boolean equals(Object obj) {
         || encoderPadding != other.encoderPadding || subsampleOffsetUs != other.subsampleOffsetUs
         || selectionFlags != other.selectionFlags || !Util.areEqual(id, other.id)
         || !Util.areEqual(language, other.language)
+        || accessibilityChannel != other.accessibilityChannel
         || !Util.areEqual(containerMimeType, other.containerMimeType)
         || !Util.areEqual(sampleMimeType, other.sampleMimeType)
         || !Util.areEqual(codecs, other.codecs)
         || !Util.areEqual(drmInitData, other.drmInitData)
+        || !Util.areEqual(metadata, other.metadata)
         || !Arrays.equals(projectionData, other.projectionData)
         || initializationData.size() != other.initializationData.size()) {
       return false;
@@ -535,6 +597,38 @@ private static void maybeSetFloatV16(MediaFormat format, String key, float value
     }
   }
 
+  // Utility methods
+
+  /**
+   * Returns a prettier {@link String} than {@link #toString()}, intended for logging.
+   */
+  public static String toLogString(Format format) {
+    if (format == null) {
+      return "null";
+    }
+    StringBuilder builder = new StringBuilder();
+    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
+    if (format.bitrate != Format.NO_VALUE) {
+      builder.append(", bitrate=").append(format.bitrate);
+    }
+    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
+      builder.append(", res=").append(format.width).append("x").append(format.height);
+    }
+    if (format.frameRate != Format.NO_VALUE) {
+      builder.append(", fps=").append(format.frameRate);
+    }
+    if (format.channelCount != Format.NO_VALUE) {
+      builder.append(", channels=").append(format.channelCount);
+    }
+    if (format.sampleRate != Format.NO_VALUE) {
+      builder.append(", sample_rate=").append(format.sampleRate);
+    }
+    if (format.language != null) {
+      builder.append(", language=").append(format.language);
+    }
+    return builder.toString();
+  }
+
   // Parcelable implementation.
 
   @Override
@@ -567,6 +661,7 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeInt(encoderPadding);
     dest.writeInt(selectionFlags);
     dest.writeString(language);
+    dest.writeInt(accessibilityChannel);
     dest.writeLong(subsampleOffsetUs);
     int initializationDataSize = initializationData.size();
     dest.writeInt(initializationDataSize);
@@ -574,6 +669,7 @@ public void writeToParcel(Parcel dest, int flags) {
       dest.writeByteArray(initializationData.get(i));
     }
     dest.writeParcelable(drmInitData, 0);
+    dest.writeParcelable(metadata, 0);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/IllegalSeekPositionException.java b/library/src/main/java/com/google/android/exoplayer2/IllegalSeekPositionException.java
new file mode 100644
index 0000000000..baa1cf3f79
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/IllegalSeekPositionException.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+/**
+ * Thrown when an attempt is made to seek to a position that does not exist in the player's
+ * {@link Timeline}.
+ */
+public final class IllegalSeekPositionException extends IllegalStateException {
+
+  /**
+   * The {@link Timeline} in which the seek was attempted.
+   */
+  public final Timeline timeline;
+  /**
+   * The index of the window being seeked to.
+   */
+  public final int windowIndex;
+  /**
+   * The seek position in the specified window.
+   */
+  public final long positionMs;
+
+  /**
+   * @param timeline The {@link Timeline} in which the seek was attempted.
+   * @param windowIndex The index of the window being seeked to.
+   * @param positionMs The seek position in the specified window.
+   */
+  public IllegalSeekPositionException(Timeline timeline, int windowIndex, long positionMs) {
+    this.timeline = timeline;
+    this.windowIndex = windowIndex;
+    this.positionMs = positionMs;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/LoadControl.java b/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
index 6176c6085b..c092480222 100644
--- a/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
@@ -17,7 +17,7 @@
 
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 
 /**
@@ -38,7 +38,7 @@
    * @param trackSelections The track selections that were made.
    */
   void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
-      TrackSelections<?> trackSelections);
+      TrackSelectionArray trackSelections);
 
   /**
    * Called by the player when stopped.
diff --git a/library/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
index f5bc9141e1..e16caec980 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -92,6 +92,7 @@
    * This method may be called when the renderer is in the following states:
    * {@link #STATE_DISABLED}.
    *
+   * @param configuration The renderer configuration.
    * @param formats The enabled formats.
    * @param stream The {@link SampleStream} from which the renderer should consume.
    * @param positionUs The player's current position.
@@ -100,8 +101,8 @@
    *     before they are rendered.
    * @throws ExoPlaybackException If an error occurs.
    */
-  void enable(Format[] formats, SampleStream stream, long positionUs, boolean joining,
-      long offsetUs) throws ExoPlaybackException;
+  void enable(RendererConfiguration configuration, Format[] formats, SampleStream stream,
+      long positionUs, boolean joining, long offsetUs) throws ExoPlaybackException;
 
   /**
    * Starts the renderer, meaning that calls to {@link #render(long, long)} will cause media to be
@@ -149,7 +150,13 @@ void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
    * This method may be called when the renderer is in the following states:
    * {@link #STATE_ENABLED}, {@link #STATE_STARTED}.
    */
-  void setCurrentStreamIsFinal();
+  void setCurrentStreamFinal();
+
+  /**
+   * Returns whether the current {@link SampleStream} will be the final one supplied before the
+   * renderer is next disabled or reset.
+   */
+  boolean isCurrentStreamFinal();
 
   /**
    * Throws an error that's preventing the renderer from reading from its {@link SampleStream}. Does
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
index 4312bff632..151453c12c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
@@ -79,6 +79,20 @@
    */
   int ADAPTIVE_NOT_SUPPORTED = 0b0000;
 
+  /**
+   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
+   * {@link #TUNNELING_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}.
+   */
+  int TUNNELING_SUPPORT_MASK = 0b10000;
+  /**
+   * The {@link Renderer} supports tunneled output.
+   */
+  int TUNNELING_SUPPORTED = 0b10000;
+  /**
+   * The {@link Renderer} does not support tunneled output.
+   */
+  int TUNNELING_NOT_SUPPORTED = 0b00000;
+
   /**
    * Returns the track type that the {@link Renderer} handles. For example, a video renderer will
    * return {@link C#TRACK_TYPE_VIDEO}, an audio renderer will return {@link C#TRACK_TYPE_AUDIO}, a
@@ -91,7 +105,7 @@
 
   /**
    * Returns the extent to which the {@link Renderer} supports a given format. The returned value is
-   * the bitwise OR of two properties:
+   * the bitwise OR of three properties:
    * <ul>
    * <li>The level of support for the format itself. One of {@link #FORMAT_HANDLED},
    * {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_SUBTYPE} and
@@ -99,9 +113,12 @@
    * <li>The level of support for adapting from the format to another format of the same mime type.
    * One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
    * {@link #ADAPTIVE_NOT_SUPPORTED}.</li>
+   * <li>The level of support for tunneling. One of {@link #TUNNELING_SUPPORTED} and
+   * {@link #TUNNELING_NOT_SUPPORTED}.</li>
    * </ul>
    * The individual properties can be retrieved by performing a bitwise AND with
-   * {@link #FORMAT_SUPPORT_MASK} and {@link #ADAPTIVE_SUPPORT_MASK} respectively.
+   * {@link #FORMAT_SUPPORT_MASK}, {@link #ADAPTIVE_SUPPORT_MASK} and
+   * {@link #TUNNELING_SUPPORT_MASK} respectively.
    *
    * @param format The format.
    * @return The extent to which the renderer is capable of supporting the given format.
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
new file mode 100644
index 0000000000..93bbd1e4b6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+/**
+ * The configuration of a {@link Renderer}.
+ */
+public final class RendererConfiguration {
+
+  /**
+   * The default configuration.
+   */
+  public static final RendererConfiguration DEFAULT =
+      new RendererConfiguration(C.AUDIO_SESSION_ID_UNSET);
+
+  /**
+   * The audio session id to use for tunneling, or {@link C#AUDIO_SESSION_ID_UNSET} if tunneling
+   * should not be enabled.
+   */
+  public final int tunnelingAudioSessionId;
+
+  /**
+   * @param tunnelingAudioSessionId The audio session id to use for tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  public RendererConfiguration(int tunnelingAudioSessionId) {
+    this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    RendererConfiguration other = (RendererConfiguration) obj;
+    return tunnelingAudioSessionId == other.tunnelingAudioSessionId;
+  }
+
+  @Override
+  public int hashCode() {
+    return tunnelingAudioSessionId;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 4b673d3750..298e528246 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -18,10 +18,10 @@
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.SurfaceTexture;
-import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.media.PlaybackParams;
 import android.os.Handler;
+import android.support.annotation.IntDef;
 import android.util.Log;
 import android.view.Surface;
 import android.view.SurfaceHolder;
@@ -29,22 +29,23 @@
 import android.view.TextureView;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
-import com.google.android.exoplayer2.metadata.id3.Id3Frame;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextRenderer;
-import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.List;
@@ -54,7 +55,7 @@
  * be obtained from {@link ExoPlayerFactory}.
  */
 @TargetApi(16)
-public final class SimpleExoPlayer implements ExoPlayer {
+public class SimpleExoPlayer implements ExoPlayer {
 
   /**
    * A listener for video rendering information from a {@link SimpleExoPlayer}.
@@ -86,15 +87,35 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
      */
     void onRenderedFirstFrame();
 
-    /**
-     * Called when a video track is no longer selected.
-     */
-    void onVideoTracksDisabled();
-
   }
 
+  /**
+   * Modes for using extension renderers.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
+  public @interface ExtensionRendererMode {}
+  /**
+   * Do not allow use of extension renderers.
+   */
+  public static final int EXTENSION_RENDERER_MODE_OFF = 0;
+  /**
+   * Allow use of extension renderers. Extension renderers are indexed after core renderers of the
+   * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
+   * prefer to use a core renderer to an extension renderer in the case that both are able to play
+   * a given track.
+   */
+  public static final int EXTENSION_RENDERER_MODE_ON = 1;
+  /**
+   * Allow use of extension renderers. Extension renderers are indexed before core renderers of the
+   * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
+   * prefer to use an extension renderer to a core renderer in the case that both are able to play
+   * a given track.
+   */
+  public static final int EXTENSION_RENDERER_MODE_PREFER = 2;
+
   private static final String TAG = "SimpleExoPlayer";
-  private static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
+  protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
 
   private final ExoPlayer player;
   private final Renderer[] renderers;
@@ -103,41 +124,38 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private final int videoRendererCount;
   private final int audioRendererCount;
 
-  private boolean videoTracksEnabled;
   private Format videoFormat;
   private Format audioFormat;
 
   private Surface surface;
   private boolean ownsSurface;
+  @C.VideoScalingMode
+  private int videoScalingMode;
   private SurfaceHolder surfaceHolder;
   private TextureView textureView;
   private TextRenderer.Output textOutput;
-  private MetadataRenderer.Output<List<Id3Frame>> id3Output;
+  private MetadataRenderer.Output metadataOutput;
   private VideoListener videoListener;
   private AudioRendererEventListener audioDebugListener;
   private VideoRendererEventListener videoDebugListener;
   private DecoderCounters videoDecoderCounters;
   private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
-  private float volume;
+  @C.StreamType
+  private int audioStreamType;
+  private float audioVolume;
   private PlaybackParamsHolder playbackParamsHolder;
 
-  /* package */ SimpleExoPlayer(Context context, TrackSelector<?> trackSelector,
-      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      boolean preferExtensionDecoders, long allowedVideoJoiningTimeMs) {
+  protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadControl loadControl,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs) {
     mainHandler = new Handler();
     componentListener = new ComponentListener();
-    trackSelector.addListener(componentListener);
 
     // Build the renderers.
     ArrayList<Renderer> renderersList = new ArrayList<>();
-    if (preferExtensionDecoders) {
-      buildExtensionRenderers(renderersList, allowedVideoJoiningTimeMs);
-      buildRenderers(context, drmSessionManager, renderersList, allowedVideoJoiningTimeMs);
-    } else {
-      buildRenderers(context, drmSessionManager, renderersList, allowedVideoJoiningTimeMs);
-      buildExtensionRenderers(renderersList, allowedVideoJoiningTimeMs);
-    }
+    buildRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+        allowedVideoJoiningTimeMs, renderersList);
     renderers = renderersList.toArray(new Renderer[renderersList.size()]);
 
     // Obtain counts of video and audio renderers.
@@ -157,31 +175,41 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
     this.audioRendererCount = audioRendererCount;
 
     // Set initial values.
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    volume = 1;
+    audioVolume = 1;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    audioStreamType = C.STREAM_TYPE_DEFAULT;
+    videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
     // Build the player and associated objects.
     player = new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
 
   /**
-   * Returns the number of renderers.
+   * Sets the video scaling mode.
+   * <p>
+   * Note that the scaling mode only applies if a {@link MediaCodec}-based video {@link Renderer} is
+   * enabled and if the output surface is owned by a {@link android.view.SurfaceView}.
    *
-   * @return The number of renderers.
+   * @param videoScalingMode The video scaling mode.
    */
-  public int getRendererCount() {
-    return renderers.length;
+  public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
+    this.videoScalingMode = videoScalingMode;
+    ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
+    int count = 0;
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SCALING_MODE,
+            videoScalingMode);
+      }
+    }
+    player.sendMessages(messages);
   }
 
   /**
-   * Returns the track type that the renderer at a given index handles.
-   *
-   * @see Renderer#getTrackType()
-   * @param index The index of the renderer.
-   * @return One of the {@code TRACK_TYPE_*} constants defined in {@link C}.
+   * Returns the video scaling mode.
    */
-  public int getRendererType(int index) {
-    return renderers[index].getTrackType();
+  public @C.VideoScalingMode int getVideoScalingMode() {
+    return videoScalingMode;
   }
 
   /**
@@ -258,18 +286,48 @@ public void setVideoTextureView(TextureView textureView) {
     }
   }
 
+  /**
+   * Sets the stream type for audio playback (see {@link C.StreamType} and
+   * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}). If the stream type
+   * is not set, audio renderers use {@link C#STREAM_TYPE_DEFAULT}.
+   * <p>
+   * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+   * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+   * share the same routing, so a new audio session id will be generated.
+   *
+   * @param audioStreamType The stream type for audio playback.
+   */
+  public void setAudioStreamType(@C.StreamType int audioStreamType) {
+    this.audioStreamType = audioStreamType;
+    ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
+    int count = 0;
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_STREAM_TYPE, audioStreamType);
+      }
+    }
+    player.sendMessages(messages);
+  }
+
+  /**
+   * Returns the stream type for audio playback.
+   */
+  public @C.StreamType int getAudioStreamType() {
+    return audioStreamType;
+  }
+
   /**
    * Sets the audio volume, with 0 being silence and 1 being unity gain.
    *
-   * @param volume The volume.
+   * @param audioVolume The audio volume.
    */
-  public void setVolume(float volume) {
-    this.volume = volume;
+  public void setVolume(float audioVolume) {
+    this.audioVolume = audioVolume;
     ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
     int count = 0;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_VOLUME, volume);
+        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_VOLUME, audioVolume);
       }
     }
     player.sendMessages(messages);
@@ -279,7 +337,7 @@ public void setVolume(float volume) {
    * Returns the audio volume, with 0 being silence and 1 being unity gain.
    */
   public float getVolume() {
-    return volume;
+    return audioVolume;
   }
 
   /**
@@ -333,7 +391,7 @@ public Format getAudioFormat() {
   }
 
   /**
-   * Returns the audio session identifier, or {@code AudioTrack.SESSION_ID_NOT_SET} if not set.
+   * Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set.
    */
   public int getAudioSessionId() {
     return audioSessionId;
@@ -390,12 +448,12 @@ public void setTextOutput(TextRenderer.Output output) {
   }
 
   /**
-   * Sets a listener to receive ID3 metadata events.
+   * Sets a listener to receive metadata events.
    *
    * @param output The output.
    */
-  public void setId3Output(MetadataRenderer.Output<List<Id3Frame>> output) {
-    id3Output = output;
+  public void setMetadataOutput(MetadataRenderer.Output output) {
+    metadataOutput = output;
   }
 
   // ExoPlayer implementation
@@ -421,8 +479,8 @@ public void prepare(MediaSource mediaSource) {
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
-    player.prepare(mediaSource, resetPosition, resetTimeline);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
@@ -487,6 +545,36 @@ public void blockingSendMessages(ExoPlayerMessage... messages) {
     player.blockingSendMessages(messages);
   }
 
+  @Override
+  public int getRendererCount() {
+    return player.getRendererCount();
+  }
+
+  @Override
+  public int getRendererType(int index) {
+    return player.getRendererType(index);
+  }
+
+  @Override
+  public TrackGroupArray getCurrentTrackGroups() {
+    return player.getCurrentTrackGroups();
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return player.getCurrentTrackSelections();
+  }
+
+  @Override
+  public Timeline getCurrentTimeline() {
+    return player.getCurrentTimeline();
+  }
+
+  @Override
+  public Object getCurrentManifest() {
+    return player.getCurrentManifest();
+  }
+
   @Override
   public int getCurrentPeriodIndex() {
     return player.getCurrentPeriodIndex();
@@ -518,64 +606,108 @@ public int getBufferedPercentage() {
   }
 
   @Override
-  public Timeline getCurrentTimeline() {
-    return player.getCurrentTimeline();
+  public boolean isCurrentWindowDynamic() {
+    return player.isCurrentWindowDynamic();
   }
 
   @Override
-  public Object getCurrentManifest() {
-    return player.getCurrentManifest();
+  public boolean isCurrentWindowSeekable() {
+    return player.isCurrentWindowSeekable();
   }
 
-  // Internal methods.
+  // Renderer building.
+
+  private void buildRenderers(Context context, Handler mainHandler,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs,
+      ArrayList<Renderer> out) {
+    buildVideoRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+        componentListener, allowedVideoJoiningTimeMs, out);
+    buildAudioRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+        componentListener, out);
+    buildTextRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
+    buildMetadataRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
+    buildMiscellaneousRenderers(context, mainHandler, extensionRendererMode, out);
+  }
+
+  /**
+   * Builds video renderers for use by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param mainHandler A handler associated with the main thread's looper.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   * not be used for DRM protected playbacks.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param eventListener An event listener.
+   * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video renderers
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildVideoRenderers(Context context, Handler mainHandler,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @ExtensionRendererMode int extensionRendererMode, VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
+    out.add(new MediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
+        allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, eventListener,
+        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+
+    if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
+      return;
+    }
+    int extensionRendererIndex = out.size();
+    if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
+      extensionRendererIndex--;
+    }
 
-  private void buildRenderers(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, ArrayList<Renderer> renderersList,
-      long allowedVideoJoiningTimeMs) {
-    MediaCodecVideoRenderer videoRenderer = new MediaCodecVideoRenderer(context,
-        MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
-        allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, componentListener,
-        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
-    renderersList.add(videoRenderer);
-
-    Renderer audioRenderer = new MediaCodecAudioRenderer(MediaCodecSelector.DEFAULT,
-        drmSessionManager, true, mainHandler, componentListener,
-        AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
-    renderersList.add(audioRenderer);
-
-    Renderer textRenderer = new TextRenderer(componentListener, mainHandler.getLooper());
-    renderersList.add(textRenderer);
-
-    MetadataRenderer<List<Id3Frame>> id3Renderer = new MetadataRenderer<>(componentListener,
-        mainHandler.getLooper(), new Id3Decoder());
-    renderersList.add(id3Renderer);
-  }
-
-  private void buildExtensionRenderers(ArrayList<Renderer> renderersList,
-      long allowedVideoJoiningTimeMs) {
-    // Load extension renderers using reflection so that demo app doesn't depend on them.
-    // Class.forName(<class name>) appears for each renderer so that automated tools like proguard
-    // can detect the use of reflection (see http://proguard.sourceforge.net/FAQ.html#forname).
     try {
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
       Constructor<?> constructor = clazz.getConstructor(boolean.class, long.class, Handler.class,
           VideoRendererEventListener.class, int.class);
-      renderersList.add((Renderer) constructor.newInstance(true, allowedVideoJoiningTimeMs,
-          mainHandler, componentListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+      Renderer renderer = (Renderer) constructor.newInstance(true, allowedVideoJoiningTimeMs,
+          mainHandler, componentListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+      out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibvpxVideoRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
+  }
+
+  /**
+   * Builds audio renderers for use by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param mainHandler A handler associated with the main thread's looper.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   * not be used for DRM protected playbacks.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param eventListener An event listener.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildAudioRenderers(Context context, Handler mainHandler,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @ExtensionRendererMode int extensionRendererMode, AudioRendererEventListener eventListener,
+      ArrayList<Renderer> out) {
+    out.add(new MediaCodecAudioRenderer(MediaCodecSelector.DEFAULT, drmSessionManager, true,
+        mainHandler, eventListener, AudioCapabilities.getCapabilities(context)));
+
+    if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
+      return;
+    }
+    int extensionRendererIndex = out.size();
+    if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
+      extensionRendererIndex--;
+    }
 
     try {
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
           AudioRendererEventListener.class);
-      renderersList.add((Renderer) constructor.newInstance(mainHandler, componentListener));
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+      out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibopusAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
@@ -588,7 +720,8 @@ private void buildExtensionRenderers(ArrayList<Renderer> renderersList,
           Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
           AudioRendererEventListener.class);
-      renderersList.add((Renderer) constructor.newInstance(mainHandler, componentListener));
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+      out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibflacAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
@@ -601,7 +734,8 @@ private void buildExtensionRenderers(ArrayList<Renderer> renderersList,
           Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
           AudioRendererEventListener.class);
-      renderersList.add((Renderer) constructor.newInstance(mainHandler, componentListener));
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+      out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded FfmpegAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
@@ -610,6 +744,51 @@ private void buildExtensionRenderers(ArrayList<Renderer> renderersList,
     }
   }
 
+  /**
+   * Builds text renderers for use by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param mainHandler A handler associated with the main thread's looper.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param output An output for the renderers.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildTextRenderers(Context context, Handler mainHandler,
+      @ExtensionRendererMode int extensionRendererMode, TextRenderer.Output output,
+      ArrayList<Renderer> out) {
+    out.add(new TextRenderer(output, mainHandler.getLooper()));
+  }
+
+  /**
+   * Builds metadata renderers for use by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param mainHandler A handler associated with the main thread's looper.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param output An output for the renderers.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildMetadataRenderers(Context context, Handler mainHandler,
+      @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
+      ArrayList<Renderer> out) {
+    out.add(new MetadataRenderer(output, mainHandler.getLooper()));
+  }
+
+  /**
+   * Builds any miscellaneous renderers used by the player.
+   *
+   * @param context The {@link Context} associated with the player.
+   * @param mainHandler A handler associated with the main thread's looper.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param out An array to which the built renderers should be appended.
+   */
+  protected void buildMiscellaneousRenderers(Context context, Handler mainHandler,
+      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+    // Do nothing.
+  }
+
+  // Internal methods.
+
   private void removeSurfaceCallbacks() {
     if (textureView != null) {
       if (textureView.getSurfaceTextureListener() != componentListener) {
@@ -650,9 +829,8 @@ private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
   }
 
   private final class ComponentListener implements VideoRendererEventListener,
-      AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output<List<Id3Frame>>,
-      SurfaceHolder.Callback, TextureView.SurfaceTextureListener,
-      TrackSelector.EventListener<Object> {
+      AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output,
+      SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
 
     // VideoRendererEventListener implementation
 
@@ -770,7 +948,7 @@ public void onAudioDisabled(DecoderCounters counters) {
       }
       audioFormat = null;
       audioDecoderCounters = null;
-      audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     }
 
     // TextRenderer.Output implementation
@@ -782,12 +960,12 @@ public void onCues(List<Cue> cues) {
       }
     }
 
-    // MetadataRenderer.Output<List<Id3Frame>> implementation
+    // MetadataRenderer.Output implementation
 
     @Override
-    public void onMetadata(List<Id3Frame> id3Frames) {
-      if (id3Output != null) {
-        id3Output.onMetadata(id3Frames);
+    public void onMetadata(Metadata metadata) {
+      if (metadataOutput != null) {
+        metadataOutput.onMetadata(metadata);
       }
     }
 
@@ -831,23 +1009,6 @@ public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
       // Do nothing.
     }
 
-    // TrackSelector.EventListener implementation
-
-    @Override
-    public void onTrackSelectionsChanged(TrackSelections<?> trackSelections) {
-      boolean videoTracksEnabled = false;
-      for (int i = 0; i < renderers.length; i++) {
-        if (renderers[i].getTrackType() == C.TRACK_TYPE_VIDEO && trackSelections.get(i) != null) {
-          videoTracksEnabled = true;
-          break;
-        }
-      }
-      if (videoListener != null && SimpleExoPlayer.this.videoTracksEnabled && !videoTracksEnabled) {
-        videoListener.onVideoTracksDisabled();
-      }
-      SimpleExoPlayer.this.videoTracksEnabled = videoTracksEnabled;
-    }
-
   }
 
   @TargetApi(23)
diff --git a/library/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/src/main/java/com/google/android/exoplayer2/Timeline.java
index b394ecabf8..333dd25cbe 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -91,6 +91,46 @@
  */
 public abstract class Timeline {
 
+  /**
+   * An empty timeline.
+   */
+  public static final Timeline EMPTY = new Timeline() {
+
+    @Override
+    public int getWindowCount() {
+      return 0;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return 0;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      return C.INDEX_UNSET;
+    }
+
+  };
+
+  /**
+   * Returns whether the timeline is empty.
+   */
+  public final boolean isEmpty() {
+    return getWindowCount() == 0;
+  }
+
   /**
    * Returns the number of windows in the timeline.
    */
@@ -114,10 +154,26 @@ public final Window getWindow(int windowIndex, Window window) {
    * @param windowIndex The index of the window.
    * @param window The {@link Window} to populate. Must not be null.
    * @param setIds Whether {@link Window#id} should be populated. If false, the field will be set to
-   * null. The caller should pass false for efficiency reasons unless the field is required.
+   *     null. The caller should pass false for efficiency reasons unless the field is required.
    * @return The populated {@link Window}, for convenience.
    */
-  public abstract Window getWindow(int windowIndex, Window window, boolean setIds);
+  public Window getWindow(int windowIndex, Window window, boolean setIds) {
+    return getWindow(windowIndex, window, setIds, 0);
+  }
+
+  /**
+   * Populates a {@link Window} with data for the window at the specified index.
+   *
+   * @param windowIndex The index of the window.
+   * @param window The {@link Window} to populate. Must not be null.
+   * @param setIds Whether {@link Window#id} should be populated. If false, the field will be set to
+   *     null. The caller should pass false for efficiency reasons unless the field is required.
+   * @param defaultPositionProjectionUs A duration into the future that the populated window's
+   *     default start position should be projected.
+   * @return The populated {@link Window}, for convenience.
+   */
+  public abstract Window getWindow(int windowIndex, Window window, boolean setIds,
+      long defaultPositionProjectionUs);
 
   /**
    * Returns the number of periods in the timeline.
@@ -181,8 +237,8 @@ public final Period getPeriod(int periodIndex, Period period) {
     public long presentationStartTimeMs;
 
     /**
-     * The windows start time in milliseconds since the epoch, or {@link C#TIME_UNSET} if unknown or
-     * not applicable. For informational purposes only.
+     * The window's start time in milliseconds since the epoch, or {@link C#TIME_UNSET} if unknown
+     * or not applicable. For informational purposes only.
      */
     public long windowStartTimeMs;
 
@@ -206,9 +262,24 @@ public final Period getPeriod(int periodIndex, Period period) {
      */
     public int lastPeriodIndex;
 
-    private long defaultPositionUs;
-    private long durationUs;
-    private long positionInFirstPeriodUs;
+    /**
+     * The default position relative to the start of the window at which to begin playback, in
+     * microseconds. May be {@link C#TIME_UNSET} if and only if the window was populated with a
+     * non-zero default position projection, and if the specified projection cannot be performed
+     * whilst remaining within the bounds of the window.
+     */
+    public long defaultPositionUs;
+
+    /**
+     * The duration of this window in microseconds, or {@link C#TIME_UNSET} if unknown.
+     */
+    public long durationUs;
+
+    /**
+     * The position of the start of this window relative to the start of the first period belonging
+     * to it, in microseconds.
+     */
+    public long positionInFirstPeriodUs;
 
     /**
      * Sets the data held by this window.
@@ -231,7 +302,9 @@ public Window set(Object id, long presentationStartTimeMs, long windowStartTimeM
 
     /**
      * Returns the default position relative to the start of the window at which to begin playback,
-     * in milliseconds.
+     * in milliseconds. May be {@link C#TIME_UNSET} if and only if the window was populated with a
+     * non-zero default position projection, and if the specified projection cannot be performed
+     * whilst remaining within the bounds of the window.
      */
     public long getDefaultPositionMs() {
       return C.usToMs(defaultPositionUs);
@@ -239,7 +312,9 @@ public long getDefaultPositionMs() {
 
     /**
      * Returns the default position relative to the start of the window at which to begin playback,
-     * in microseconds.
+     * in microseconds. May be {@link C#TIME_UNSET} if and only if the window was populated with a
+     * non-zero default position projection, and if the specified projection cannot be performed
+     * whilst remaining within the bounds of the window.
      */
     public long getDefaultPositionUs() {
       return defaultPositionUs;
@@ -303,7 +378,11 @@ public long getPositionInFirstPeriodUs() {
      */
     public int windowIndex;
 
-    private long durationUs;
+    /**
+     * The duration of this period in microseconds, or {@link C#TIME_UNSET} if unknown.
+     */
+    public long durationUs;
+
     private long positionInWindowUs;
 
     /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
index d0ad44f8da..b5ee052924 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
@@ -27,4 +27,15 @@ public AudioDecoderException(String detailMessage) {
     super(detailMessage);
   }
 
+  /**
+   * @param detailMessage The detail message for this exception.
+   * @param cause the cause (which is saved for later retrieval by the
+   *     {@link #getCause()} method).  (A <tt>null</tt> value is
+   *     permitted, and indicates that the cause is nonexistent or
+   *     unknown.)
+   */
+  public AudioDecoderException(String detailMessage, Throwable cause) {
+    super(detailMessage, cause);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
index 87f6546e1f..71049c9de8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
@@ -15,7 +15,9 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.media.AudioAttributes;
 import android.media.AudioFormat;
 import android.media.AudioTimestamp;
 import android.media.PlaybackParams;
@@ -23,36 +25,72 @@
 import android.os.SystemClock;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 
 /**
  * Plays audio data. The implementation delegates to an {@link android.media.AudioTrack} and handles
  * playback position smoothing, non-blocking writes and reconfiguration.
  * <p>
  * Before starting playback, specify the input format by calling
- * {@link #configure(String, int, int, int, int)}. Next call {@link #initialize(int)}, optionally
- * specifying an audio session.
+ * {@link #configure(String, int, int, int, int)}. Optionally call {@link #setAudioSessionId(int)},
+ * {@link #setStreamType(int)}, {@link #enableTunnelingV21(int)} and {@link #disableTunneling()}
+ * to configure audio playback. These methods may be called after writing data to the track, in
+ * which case it will be reinitialized as required.
  * <p>
  * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
  * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
  * <p>
- * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. If
- * {@link #isInitialized()} returns {@code false} after the call, it is necessary to call
- * {@link #initialize(int)} before writing more data.
+ * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. The track
+ * will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
  * <p>
- * The underlying {@link android.media.AudioTrack} is created by {@link #initialize(int)} and
- * released by {@link #reset()} (and {@link #configure(String, int, int, int, int)} unless the input
- * format is unchanged). It is safe to call {@link #initialize(int)} after calling {@link #reset()}
- * without reconfiguration.
+ * Calling {@link #reset()} releases the underlying {@link android.media.AudioTrack} (and so does
+ * calling {@link #configure(String, int, int, int, int)} unless the format is unchanged). It is
+ * safe to call {@link #handleBuffer(ByteBuffer, long)} after {@link #reset()} without calling
+ * {@link #configure(String, int, int, int, int)}.
  * <p>
- * Call {@link #release()} when the instance is no longer required.
+ * Call {@link #handleEndOfStream()} to play out all data when no more input buffers will be
+ * provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset}. Call
+ * {@link #release()} when the instance is no longer required.
  */
 public final class AudioTrack {
 
+  /**
+   * Listener for audio track events.
+   */
+  public interface Listener {
+
+    /**
+     * Called when the audio track has been initialized with a newly generated audio session id.
+     *
+     * @param audioSessionId The newly generated audio session id.
+     */
+    void onAudioSessionId(int audioSessionId);
+
+    /**
+     * Called when the audio track handles a buffer whose timestamp is discontinuous with the last
+     * buffer handled since it was reset.
+     */
+    void onPositionDiscontinuity();
+
+    /**
+     * Called when the audio track underruns.
+     *
+     * @param bufferSize The size of the track's buffer, in bytes.
+     * @param bufferSizeMs The size of the track's buffer, in milliseconds, if it is configured for
+     *     PCM output. {@link C#TIME_UNSET} if it is configured for passthrough output, as the
+     *     buffered media can have a variable bitrate so the duration may be unknown.
+     * @param elapsedSinceLastFeedMs The time since the track was last fed data, in milliseconds.
+     */
+    void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+
+  }
+
   /**
    * Thrown when a failure occurs initializing an {@link android.media.AudioTrack}.
    */
@@ -84,13 +122,15 @@ public InitializationException(int audioTrackState, int sampleRate, int channelC
   public static final class WriteException extends Exception {
 
     /**
-     * An error value returned from {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * The error value returned from {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public final int errorCode;
 
     /**
-     * @param errorCode An error value returned from
-     *     {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * @param errorCode The error value returned from
+     *     {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public WriteException(int errorCode) {
       super("AudioTrack write failed: " + errorCode);
@@ -114,20 +154,6 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
 
   }
 
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer was discontinuous.
-   */
-  public static final int RESULT_POSITION_DISCONTINUITY = 1;
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer can be released.
-   */
-  public static final int RESULT_BUFFER_CONSUMED = 2;
-
-  /**
-   * Represents an unset {@link android.media.AudioTrack} session identifier.
-   */
-  public static final int SESSION_ID_NOT_SET = 0;
-
   /**
    * Returned by {@link #getCurrentPositionUs} when the position is not set.
    */
@@ -151,20 +177,54 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
    */
   private static final int BUFFER_MULTIPLICATION_FACTOR = 4;
 
+  /**
+   * @see android.media.AudioTrack#PLAYSTATE_STOPPED
+   */
+  private static final int PLAYSTATE_STOPPED = android.media.AudioTrack.PLAYSTATE_STOPPED;
+  /**
+   * @see android.media.AudioTrack#PLAYSTATE_PAUSED
+   */
+  private static final int PLAYSTATE_PAUSED = android.media.AudioTrack.PLAYSTATE_PAUSED;
+  /**
+   * @see android.media.AudioTrack#PLAYSTATE_PLAYING
+   */
+  private static final int PLAYSTATE_PLAYING = android.media.AudioTrack.PLAYSTATE_PLAYING;
+  /**
+   * @see android.media.AudioTrack#ERROR_BAD_VALUE
+   */
+  private static final int ERROR_BAD_VALUE = android.media.AudioTrack.ERROR_BAD_VALUE;
+  /**
+   * @see android.media.AudioTrack#MODE_STATIC
+   */
+  private static final int MODE_STATIC = android.media.AudioTrack.MODE_STATIC;
+  /**
+   * @see android.media.AudioTrack#MODE_STREAM
+   */
+  private static final int MODE_STREAM = android.media.AudioTrack.MODE_STREAM;
+  /**
+   * @see android.media.AudioTrack#STATE_INITIALIZED
+   */
+  private static final int STATE_INITIALIZED = android.media.AudioTrack.STATE_INITIALIZED;
+  /**
+   * @see android.media.AudioTrack#WRITE_NON_BLOCKING
+   */
+  @SuppressLint("InlinedApi")
+  private static final int WRITE_NON_BLOCKING = android.media.AudioTrack.WRITE_NON_BLOCKING;
+
   private static final String TAG = "AudioTrack";
 
   /**
    * AudioTrack timestamps are deemed spurious if they are offset from the system clock by more
    * than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_AUDIO_TIMESTAMP_OFFSET_US = 5 * C.MICROS_PER_SECOND;
 
   /**
    * AudioTrack latencies are deemed impossibly large if they are greater than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
@@ -195,19 +255,21 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   public static boolean failOnSpuriousAudioTimestamp = false;
 
   private final AudioCapabilities audioCapabilities;
-  private final int streamType;
+  private final Listener listener;
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
 
   /**
-   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize(int)}).
+   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}).
    */
   private android.media.AudioTrack keepSessionIdAudioTrack;
 
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
+  @C.StreamType
+  private int streamType;
   @C.Encoding
   private int sourceEncoding;
   @C.Encoding
@@ -217,6 +279,9 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private int bufferSize;
   private long bufferSizeUs;
 
+  private ByteBuffer avSyncHeader;
+  private int bytesUntilNextAvSync;
+
   private int nextPlayheadOffsetIndex;
   private int playheadOffsetCount;
   private long smoothedPlayheadOffsetUs;
@@ -241,13 +306,19 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private ByteBuffer resampledBuffer;
   private boolean useResampledBuffer;
 
+  private boolean playing;
+  private int audioSessionId;
+  private boolean tunneling;
+  private boolean hasData;
+  private long lastFeedElapsedRealtimeMs;
+
   /**
    * @param audioCapabilities The current audio capabilities.
-   * @param streamType The type of audio stream for the underlying {@link android.media.AudioTrack}.
+   * @param listener Listener for audio track events.
    */
-  public AudioTrack(AudioCapabilities audioCapabilities, int streamType) {
+  public AudioTrack(AudioCapabilities audioCapabilities, Listener listener) {
     this.audioCapabilities = audioCapabilities;
-    this.streamType = streamType;
+    this.listener = listener;
     releasingConditionVariable = new ConditionVariable(true);
     if (Util.SDK_INT >= 18) {
       try {
@@ -267,6 +338,8 @@ public AudioTrack(AudioCapabilities audioCapabilities, int streamType) {
     playheadOffsets = new long[MAX_PLAYHEAD_OFFSET_COUNT];
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
+    streamType = C.STREAM_TYPE_DEFAULT;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
   /**
@@ -280,14 +353,6 @@ public boolean isPassthroughSupported(String mimeType) {
         && audioCapabilities.supportsEncoding(getEncodingForMimeType(mimeType));
   }
 
-  /**
-   * Returns whether the audio track has been successfully initialized via {@link #initialize} and
-   * not yet {@link #reset}.
-   */
-  public boolean isInitialized() {
-    return audioTrack != null;
-  }
-
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
    * {@link #CURRENT_POSITION_NOT_SET} if it is not yet available.
@@ -304,7 +369,7 @@ public long getCurrentPositionUs(boolean sourceEnded) {
       return CURRENT_POSITION_NOT_SET;
     }
 
-    if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PLAYING) {
+    if (audioTrack.getPlayState() == PLAYSTATE_PLAYING) {
       maybeSampleSyncParams();
     }
 
@@ -325,7 +390,7 @@ public long getCurrentPositionUs(boolean sourceEnded) {
         // The AudioTrack has started, but we don't have any samples to compute a smoothed position.
         currentPositionUs = audioTrackUtil.getPlaybackHeadPositionUs() + startMediaTimeUs;
       } else {
-        // getPlayheadPositionUs() only has a granularity of ~20ms, so we base the position off the
+        // getPlayheadPositionUs() only has a granularity of ~20 ms, so we base the position off the
         // system clock (and a smoothed offset between it and the playhead position) so as to
         // prevent jitter in the reported positions.
         currentPositionUs = systemClockUs + smoothedPlayheadOffsetUs + startMediaTimeUs;
@@ -382,7 +447,29 @@ public void configure(String mimeType, int channelCount, int sampleRate,
         throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
     }
 
+    // Workaround for overly strict channel configuration checks on nVidia Shield.
+    if (Util.SDK_INT <= 23 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER)) {
+      switch (channelCount) {
+        case 7:
+          channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
+          break;
+        case 3:
+        case 5:
+          channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
+          break;
+        default:
+          break;
+      }
+    }
+
     boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
+
+    // Workaround for Nexus Player not reporting support for mono passthrough.
+    // (See [Internal: b/34268671].)
+    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && passthrough && channelCount == 1) {
+      channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
+    }
+
     @C.Encoding int sourceEncoding;
     if (passthrough) {
       sourceEncoding = getEncodingForMimeType(mimeType);
@@ -423,7 +510,7 @@ public void configure(String mimeType, int channelCount, int sampleRate,
     } else {
       int minBufferSize =
           android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, targetEncoding);
-      Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
+      Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
       int maxAppBufferSize = (int) Math.max(minBufferSize,
@@ -435,14 +522,7 @@ public void configure(String mimeType, int channelCount, int sampleRate,
     bufferSizeUs = passthrough ? C.TIME_UNSET : framesToDurationUs(pcmBytesToFrames(bufferSize));
   }
 
-  /**
-   * Initializes the audio track for writing new buffers using {@link #handleBuffer}.
-   *
-   * @param sessionId Audio track session identifier to re-use, or {@link #SESSION_ID_NOT_SET} to
-   *     create a new one.
-   * @return The new (or re-used) session identifier.
-   */
-  public int initialize(int sessionId) throws InitializationException {
+  private void initialize() throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -450,23 +530,26 @@ public int initialize(int sessionId) throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    if (sessionId == SESSION_ID_NOT_SET) {
+    if (tunneling) {
+      audioTrack = createHwAvSyncAudioTrackV21(sampleRate, channelConfig, targetEncoding,
+          bufferSize, audioSessionId);
+    } else if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM);
+          targetEncoding, bufferSize, MODE_STREAM);
     } else {
       // Re-attach to the same audio session.
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
+          targetEncoding, bufferSize, MODE_STREAM, audioSessionId);
     }
     checkAudioTrackInitialized();
 
-    sessionId = audioTrack.getAudioSessionId();
+    int audioSessionId = audioTrack.getAudioSessionId();
     if (enablePreV21AudioSessionWorkaround) {
       if (Util.SDK_INT < 21) {
         // The workaround creates an audio track with a two byte buffer on the same session, and
         // does not release it until this object is released, which keeps the session active.
         if (keepSessionIdAudioTrack != null
-            && sessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
+            && audioSessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
           releaseKeepSessionIdAudioTrack();
         }
         if (keepSessionIdAudioTrack == null) {
@@ -475,46 +558,25 @@ public int initialize(int sessionId) throws InitializationException {
           @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
-              channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STATIC, sessionId);
+              channelConfig, encoding, bufferSize, MODE_STATIC, audioSessionId);
         }
       }
     }
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      listener.onAudioSessionId(audioSessionId);
+    }
 
     audioTrackUtil.reconfigure(audioTrack, needsPassthroughWorkarounds());
-    setAudioTrackVolume();
-    return sessionId;
-  }
-
-  /**
-   * Returns the size of this {@link AudioTrack}'s buffer in bytes.
-   * <p>
-   * The value returned from this method may change as a result of calling one of the
-   * {@link #configure} methods.
-   *
-   * @return The size of the buffer in bytes.
-   */
-  public int getBufferSize() {
-    return bufferSize;
-  }
-
-  /**
-   * Returns the size of the buffer in microseconds for PCM {@link AudioTrack}s, or
-   * {@link C#TIME_UNSET} for passthrough {@link AudioTrack}s.
-   * <p>
-   * The value returned from this method may change as a result of calling one of the
-   * {@link #configure} methods.
-   *
-   * @return The size of the buffer in microseconds for PCM {@link AudioTrack}s, or
-   *     {@link C#TIME_UNSET} for passthrough {@link AudioTrack}s.
-   */
-  public long getBufferSizeUs() {
-    return bufferSizeUs;
+    setVolumeInternal();
+    hasData = false;
   }
 
   /**
    * Starts or resumes playing audio if the audio track has been initialized.
    */
   public void play() {
+    playing = true;
     if (isInitialized()) {
       resumeSystemTimeUs = System.nanoTime() / 1000;
       audioTrack.play();
@@ -535,23 +597,42 @@ public void handleDiscontinuity() {
    * Attempts to write data from a {@link ByteBuffer} to the audio track, starting from its current
    * position and ending at its limit (exclusive). The position of the {@link ByteBuffer} is
    * advanced by the number of bytes that were successfully written.
+   * {@link Listener#onPositionDiscontinuity()} will be called if {@code presentationTimeUs} is
+   * discontinuous with the last buffer handled since the track was reset.
    * <p>
-   * Returns a bit field containing {@link #RESULT_BUFFER_CONSUMED} if the data was written in full,
-   * and {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was discontinuous with previously
-   * written data.
-   * <p>
-   * If the data was not written in full then the same {@link ByteBuffer} must be provided to
-   * subsequent calls until it has been fully consumed, except in the case of an interleaving call
-   * to {@link #configure} or {@link #reset}.
+   * Returns whether the data was written in full. If the data was not written in full then the same
+   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
+   * except in the case of an interleaving call to {@link #reset()} (or an interleaving call to
+   * {@link #configure(String, int, int, int, int)} that caused the track to be reset).
    *
    * @param buffer The buffer containing audio data to play back.
    * @param presentationTimeUs Presentation timestamp of the next buffer in microseconds.
-   * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and
-   *     {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previously
-   *     written data.
+   * @return Whether the buffer was consumed fully.
+   * @throws InitializationException If an error occurs initializing the track.
    * @throws WriteException If an error occurs writing the audio data.
    */
-  public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
+  public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
+      throws InitializationException, WriteException {
+    if (!isInitialized()) {
+      initialize();
+      if (playing) {
+        play();
+      }
+    }
+
+    boolean hadData = hasData;
+    hasData = hasPendingData();
+    if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED) {
+      long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
+      listener.onUnderrun(bufferSize, C.usToMs(bufferSizeUs), elapsedSinceLastFeedMs);
+    }
+    boolean result = writeBuffer(buffer, presentationTimeUs);
+    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
+    return result;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  private boolean writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
     boolean isNewSourceBuffer = currentSourceBuffer == null;
     Assertions.checkState(isNewSourceBuffer || currentSourceBuffer == buffer);
     currentSourceBuffer = buffer;
@@ -559,27 +640,26 @@ public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
     if (needsPassthroughWorkarounds()) {
       // An AC-3 audio track continues to play data written while it is paused. Stop writing so its
       // buffer empties. See [Internal: b/18899620].
-      if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED) {
-        return 0;
+      if (audioTrack.getPlayState() == PLAYSTATE_PAUSED) {
+        return false;
       }
 
       // A new AC-3 audio track's playback position continues to increase from the old track's
       // position for a short time after is has been released. Avoid writing data until the playback
       // head position actually returns to zero.
-      if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_STOPPED
+      if (audioTrack.getPlayState() == PLAYSTATE_STOPPED
           && audioTrackUtil.getPlaybackHeadPosition() != 0) {
-        return 0;
+        return false;
       }
     }
 
-    int result = 0;
     if (isNewSourceBuffer) {
       // We're seeing this buffer for the first time.
 
       if (!currentSourceBuffer.hasRemaining()) {
         // The buffer is empty.
         currentSourceBuffer = null;
-        return RESULT_BUFFER_CONSUMED;
+        return true;
       }
 
       useResampledBuffer = targetEncoding != sourceEncoding;
@@ -612,7 +692,7 @@ public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
           // number of bytes submitted.
           startMediaTimeUs += (presentationTimeUs - expectedPresentationTimeUs);
           startMediaTimeState = START_IN_SYNC;
-          result |= RESULT_POSITION_DISCONTINUITY;
+          listener.onPositionDiscontinuity();
         }
       }
       if (Util.SDK_INT < 21) {
@@ -645,7 +725,9 @@ public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
         buffer.position(buffer.position() + bytesWritten);
       }
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
+      bytesWritten = tunneling
+          ? writeNonBlockingWithAvSyncV21(audioTrack, buffer, bytesRemaining, presentationTimeUs)
+          : writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
     }
 
     if (bytesWritten < 0) {
@@ -660,9 +742,9 @@ public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
         submittedEncodedFrames += framesPerEncodedSample;
       }
       currentSourceBuffer = null;
-      result |= RESULT_BUFFER_CONSUMED;
+      return true;
     }
-    return result;
+    return false;
   }
 
   /**
@@ -671,6 +753,7 @@ public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
   public void handleEndOfStream() {
     if (isInitialized()) {
       audioTrackUtil.handleEndOfStream(getSubmittedFrames());
+      bytesUntilNextAvSync = 0;
     }
   }
 
@@ -695,6 +778,68 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
     audioTrackUtil.setPlaybackParams(playbackParams);
   }
 
+  /**
+   * Sets the stream type for audio track. If the stream type has changed and if the audio track
+   * is not configured for use with tunneling, then the audio track is reset and the audio session
+   * id is cleared.
+   * <p>
+   * If the audio track is configured for use with tunneling then the stream type is ignored, the
+   * audio track is not reset and the audio session id is not cleared. The passed stream type will
+   * be used if the audio track is later re-configured into non-tunneled mode.
+   *
+   * @param streamType The {@link C.StreamType} to use for audio output.
+   */
+  public void setStreamType(@C.StreamType int streamType) {
+    if (this.streamType == streamType) {
+      return;
+    }
+    this.streamType = streamType;
+    if (tunneling) {
+      // The stream type is ignored in tunneling mode, so no need to reset.
+      return;
+    }
+    reset();
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+  }
+
+  /**
+   * Sets the audio session id. The audio track is reset if the audio session id has changed.
+   */
+  public void setAudioSessionId(int audioSessionId) {
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Enables tunneling. The audio track is reset if tunneling was previously disabled or if the
+   * audio session id has changed. Enabling tunneling requires platform API version 21 onwards.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use.
+   * @throws IllegalStateException Thrown if enabling tunneling on platform API version < 21.
+   */
+  public void enableTunnelingV21(int tunnelingAudioSessionId) {
+    Assertions.checkState(Util.SDK_INT >= 21);
+    if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
+      tunneling = true;
+      audioSessionId = tunnelingAudioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Disables tunneling. If tunneling was previously enabled then the audio track is reset and the
+   * audio session id is cleared.
+   */
+  public void disableTunneling() {
+    if (tunneling) {
+      tunneling = false;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+      reset();
+    }
+  }
+
   /**
    * Sets the playback volume.
    *
@@ -703,17 +848,17 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
   public void setVolume(float volume) {
     if (this.volume != volume) {
       this.volume = volume;
-      setAudioTrackVolume();
+      setVolumeInternal();
     }
   }
 
-  private void setAudioTrackVolume() {
+  private void setVolumeInternal() {
     if (!isInitialized()) {
       // Do nothing.
     } else if (Util.SDK_INT >= 21) {
-      setAudioTrackVolumeV21(audioTrack, volume);
+      setVolumeInternalV21(audioTrack, volume);
     } else {
-      setAudioTrackVolumeV3(audioTrack, volume);
+      setVolumeInternalV3(audioTrack, volume);
     }
   }
 
@@ -721,6 +866,7 @@ private void setAudioTrackVolume() {
    * Pauses playback.
    */
   public void pause() {
+    playing = false;
     if (isInitialized()) {
       resetSyncParams();
       audioTrackUtil.pause();
@@ -730,9 +876,9 @@ public void pause() {
   /**
    * Releases the underlying audio track asynchronously.
    * <p>
-   * Calling {@link #initialize(int)} will block until the audio track has been released, so it is
-   * safe to initialize immediately after a reset. The audio session may remain active until
-   * {@link #release()} is called.
+   * Calling {@link #handleBuffer(ByteBuffer, long)} will block until the audio track has been
+   * released, so it is safe to use the audio track immediately after a reset. The audio session may
+   * remain active until {@link #release()} is called.
    */
   public void reset() {
     if (isInitialized()) {
@@ -740,11 +886,13 @@ public void reset() {
       submittedEncodedFrames = 0;
       framesPerEncodedSample = 0;
       currentSourceBuffer = null;
+      avSyncHeader = null;
+      bytesUntilNextAvSync = 0;
       startMediaTimeState = START_NOT_SET;
       latencyUs = 0;
       resetSyncParams();
       int playState = audioTrack.getPlayState();
-      if (playState == android.media.AudioTrack.PLAYSTATE_PLAYING) {
+      if (playState == PLAYSTATE_PLAYING) {
         audioTrack.pause();
       }
       // AudioTrack.release can take some time, so we call it on a background thread.
@@ -772,6 +920,8 @@ public void run() {
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    playing = false;
   }
 
   /**
@@ -893,7 +1043,7 @@ private void maybeSampleSyncParams() {
    */
   private void checkAudioTrackInitialized() throws InitializationException {
     int state = audioTrack.getState();
-    if (state == android.media.AudioTrack.STATE_INITIALIZED) {
+    if (state == STATE_INITIALIZED) {
       return;
     }
     // The track is not successfully initialized. Release and null the track.
@@ -909,6 +1059,10 @@ private void checkAudioTrackInitialized() throws InitializationException {
     throw new InitializationException(state, sampleRate, channelConfig, bufferSize);
   }
 
+  private boolean isInitialized() {
+    return audioTrack != null;
+  }
+
   private long pcmBytesToFrames(long byteCount) {
     return byteCount / pcmFrameSize;
   }
@@ -951,10 +1105,30 @@ private boolean needsPassthroughWorkarounds() {
    */
   private boolean overrideHasPendingData() {
     return needsPassthroughWorkarounds()
-        && audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED
+        && audioTrack.getPlayState() == PLAYSTATE_PAUSED
         && audioTrack.getPlaybackHeadPosition() == 0;
   }
 
+  /**
+   * Instantiates an {@link android.media.AudioTrack} to be used with tunneling video playback.
+   */
+  @TargetApi(21)
+  private static android.media.AudioTrack createHwAvSyncAudioTrackV21(int sampleRate,
+      int channelConfig, int encoding, int bufferSize, int sessionId) {
+    AudioAttributes attributesBuilder = new AudioAttributes.Builder()
+        .setUsage(AudioAttributes.USAGE_MEDIA)
+        .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)
+        .setFlags(AudioAttributes.FLAG_HW_AV_SYNC)
+        .build();
+    AudioFormat format = new AudioFormat.Builder()
+        .setChannelMask(channelConfig)
+        .setEncoding(encoding)
+        .setSampleRate(sampleRate)
+        .build();
+    return new android.media.AudioTrack(attributesBuilder, format, bufferSize, MODE_STREAM,
+        sessionId);
+  }
+
   /**
    * Converts the provided buffer into 16-bit PCM.
    *
@@ -981,6 +1155,9 @@ private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, @C.PcmEncoding i
       case C.ENCODING_PCM_32BIT:
         resampledSize = size / 2;
         break;
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
       default:
         // Never happens.
         throw new IllegalStateException();
@@ -1016,6 +1193,9 @@ private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, @C.PcmEncoding i
           resampledBuffer.put(buffer.get(i + 3));
         }
         break;
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
       default:
         // Never happens.
         throw new IllegalStateException();
@@ -1054,18 +1234,57 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
   }
 
   @TargetApi(21)
-  private static int writeNonBlockingV21(
-      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
-    return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
+  private static int writeNonBlockingV21(android.media.AudioTrack audioTrack, ByteBuffer buffer,
+      int size) {
+    return audioTrack.write(buffer, size, WRITE_NON_BLOCKING);
+  }
+
+  @TargetApi(21)
+  private int writeNonBlockingWithAvSyncV21(android.media.AudioTrack audioTrack,
+      ByteBuffer buffer, int size, long presentationTimeUs) {
+    // TODO: Uncomment this when [Internal ref b/33627517] is clarified or fixed.
+    // if (Util.SDK_INT >= 23) {
+    //   // The underlying platform AudioTrack writes AV sync headers directly.
+    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    // }
+    if (avSyncHeader == null) {
+      avSyncHeader = ByteBuffer.allocate(16);
+      avSyncHeader.order(ByteOrder.BIG_ENDIAN);
+      avSyncHeader.putInt(0x55550001);
+    }
+    if (bytesUntilNextAvSync == 0) {
+      avSyncHeader.putInt(4, size);
+      avSyncHeader.putLong(8, presentationTimeUs * 1000);
+      avSyncHeader.position(0);
+      bytesUntilNextAvSync = size;
+    }
+    int avSyncHeaderBytesRemaining = avSyncHeader.remaining();
+    if (avSyncHeaderBytesRemaining > 0) {
+      int result = audioTrack.write(avSyncHeader, avSyncHeaderBytesRemaining, WRITE_NON_BLOCKING);
+      if (result < 0) {
+        bytesUntilNextAvSync = 0;
+        return result;
+      }
+      if (result < avSyncHeaderBytesRemaining) {
+        return 0;
+      }
+    }
+    int result = writeNonBlockingV21(audioTrack, buffer, size);
+    if (result < 0) {
+      bytesUntilNextAvSync = 0;
+      return result;
+    }
+    bytesUntilNextAvSync -= result;
+    return result;
   }
 
   @TargetApi(21)
-  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV21(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setVolume(volume);
   }
 
   @SuppressWarnings("deprecation")
-  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
@@ -1149,7 +1368,7 @@ public long getPlaybackHeadPosition() {
       }
 
       int state = audioTrack.getPlayState();
-      if (state == android.media.AudioTrack.PLAYSTATE_STOPPED) {
+      if (state == PLAYSTATE_STOPPED) {
         // The audio track hasn't been started.
         return 0;
       }
@@ -1159,7 +1378,7 @@ public long getPlaybackHeadPosition() {
         // Work around an issue with passthrough/direct AudioTracks on platform API versions 21/22
         // where the playback head position jumps back to zero on paused passthrough/direct audio
         // tracks. See [Internal: b/19187573].
-        if (state == android.media.AudioTrack.PLAYSTATE_PAUSED && rawPlaybackHeadPosition == 0) {
+        if (state == PLAYSTATE_PAUSED && rawPlaybackHeadPosition == 0) {
           passthroughWorkaroundPauseOffset = lastRawPlaybackHeadPosition;
         }
         rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;
@@ -1314,7 +1533,7 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
       playbackParams = (playbackParams != null ? playbackParams : new PlaybackParams())
           .allowDefaults();
       this.playbackParams = playbackParams;
-      this.playbackSpeed = playbackParams.getSpeed();
+      playbackSpeed = playbackParams.getSpeed();
       maybeApplyPlaybackParams();
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 66dd010a6f..f8501c3858 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -16,14 +16,12 @@
 package com.google.android.exoplayer2.audio;
 
 import android.annotation.TargetApi;
-import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.media.PlaybackParams;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
-import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -51,13 +49,9 @@
   private boolean passthroughEnabled;
   private android.media.MediaFormat passthroughMediaFormat;
   private int pcmEncoding;
-  private int audioSessionId;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
 
-  private boolean audioTrackHasData;
-  private long lastFeedElapsedRealtimeMs;
-
   /**
    * @param mediaCodecSelector A decoder selector.
    */
@@ -76,7 +70,8 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector) {
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys) {
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys) {
     this(mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, null, null);
   }
 
@@ -109,7 +104,7 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
       boolean playClearSamplesWithoutKeys, Handler eventHandler,
       AudioRendererEventListener eventListener) {
     this(mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
-        eventListener, null, AudioManager.STREAM_MUSIC);
+        eventListener, null);
   }
 
   /**
@@ -126,16 +121,13 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
-   * @param streamType The type of audio stream for the {@link AudioTrack}.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys, Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
-      int streamType) {
+      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities) {
     super(C.TRACK_TYPE_AUDIO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    audioTrack = new AudioTrack(audioCapabilities, streamType);
+    audioTrack = new AudioTrack(audioCapabilities, new AudioTrackListener());
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
@@ -146,8 +138,9 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     if (!MimeTypes.isAudio(mimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     if (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
-      return ADAPTIVE_NOT_SEAMLESS | FORMAT_HANDLED;
+      return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
     MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false);
     if (decoderInfo == null) {
@@ -160,7 +153,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
         && (format.channelCount == Format.NO_VALUE
         ||  decoderInfo.isAudioChannelCountSupportedV21(format.channelCount)));
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return ADAPTIVE_NOT_SEAMLESS | formatSupport;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
   }
 
   @Override
@@ -190,7 +183,8 @@ protected boolean allowPassthrough(String mimeType) {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) {
     if (passthroughEnabled) {
       // Override the MIME type used to configure the codec if we are using a passthrough decoder.
       passthroughMediaFormat = format.getFrameworkMediaFormatV16();
@@ -236,25 +230,42 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
   }
 
   /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op. One reason for overriding this method would be to
-   * instantiate and enable a {@link Virtualizer} in order to spatialize the audio channels. For
-   * this use case, any {@link Virtualizer} instances should be released in {@link #onDisabled()}
-   * (if not before).
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
    *
-   * @param audioSessionId The audio session id.
+   * @see AudioTrack.Listener#onAudioSessionId(int)
    */
   protected void onAudioSessionId(int audioSessionId) {
     // Do nothing.
   }
 
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
@@ -279,7 +290,6 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
       audioTrack.release();
     } finally {
@@ -330,56 +340,15 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       return true;
     }
 
-    if (!audioTrack.isInitialized()) {
-      // Initialize the AudioTrack now.
-      try {
-        if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-          audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-          eventDispatcher.audioSessionId(audioSessionId);
-          onAudioSessionId(audioSessionId);
-        } else {
-          audioTrack.initialize(audioSessionId);
-        }
-        audioTrackHasData = false;
-      } catch (AudioTrack.InitializationException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
-      }
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    } else {
-      // Check for AudioTrack underrun.
-      boolean audioTrackHadData = audioTrackHasData;
-      audioTrackHasData = audioTrack.hasPendingData();
-      if (audioTrackHadData && !audioTrackHasData && getState() == STATE_STARTED) {
-        long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
-        long bufferSizeMs = C.usToMs(audioTrack.getBufferSizeUs());
-        eventDispatcher.audioTrackUnderrun(audioTrack.getBufferSize(), bufferSizeMs,
-            elapsedSinceLastFeedMs);
-      }
-    }
-
-    int handleBufferResult;
     try {
-      handleBufferResult = audioTrack.handleBuffer(buffer, bufferPresentationTimeUs);
-      lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
-    } catch (AudioTrack.WriteException e) {
+      if (audioTrack.handleBuffer(buffer, bufferPresentationTimeUs)) {
+        codec.releaseOutputBuffer(bufferIndex, false);
+        decoderCounters.renderedOutputBufferCount++;
+        return true;
+      }
+    } catch (AudioTrack.InitializationException | AudioTrack.WriteException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      handleAudioTrackDiscontinuity();
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
-      codec.releaseOutputBuffer(bufferIndex, false);
-      decoderCounters.renderedOutputBufferCount++;
-      return true;
-    }
-
     return false;
   }
 
@@ -388,10 +357,6 @@ protected void onOutputStreamEnded() {
     audioTrack.handleEndOfStream();
   }
 
-  protected void handleAudioTrackDiscontinuity() {
-    // Do nothing
-  }
-
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     switch (messageType) {
@@ -401,10 +366,37 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
       case C.MSG_SET_PLAYBACK_PARAMS:
         audioTrack.setPlaybackParams((PlaybackParams) message);
         break;
+      case C.MSG_SET_STREAM_TYPE:
+        @C.StreamType int streamType = (Integer) message;
+        audioTrack.setStreamType(streamType);
+        break;
       default:
         super.handleMessage(messageType, message);
         break;
     }
   }
 
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      MediaCodecAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      MediaCodecAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 6f15945d9e..d23ee769dd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer2.audio;
 
-import android.media.AudioManager;
 import android.media.PlaybackParams;
+import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -29,16 +31,47 @@
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Decodes and renders audio using a {@link SimpleDecoder}.
  */
 public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+      REINITIALIZATION_STATE_WAIT_END_OF_STREAM})
+  private @interface ReinitializationState {}
+  /**
+   * The decoder does not need to be re-initialized.
+   */
+  private static final int REINITIALIZATION_STATE_NONE = 0;
+  /**
+   * The input format has changed in a way that requires the decoder to be re-initialized, but we
+   * haven't yet signaled an end of stream to the existing decoder. We need to do so in order to
+   * ensure that it outputs any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM = 1;
+  /**
+   * The input format has changed in a way that requires the decoder to be re-initialized, and we've
+   * signaled an end of stream to the existing decoder. We're waiting for the decoder to output an
+   * end of stream signal to indicate that it has output any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
+
+  private final boolean playClearSamplesWithoutKeys;
+
   private final EventDispatcher eventDispatcher;
+  private final AudioTrack audioTrack;
+  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
   private final FormatHolder formatHolder;
 
   private DecoderCounters decoderCounters;
@@ -47,17 +80,19 @@
         ? extends AudioDecoderException> decoder;
   private DecoderInputBuffer inputBuffer;
   private SimpleOutputBuffer outputBuffer;
+  private DrmSession<ExoMediaCrypto> drmSession;
+  private DrmSession<ExoMediaCrypto> pendingDrmSession;
+
+  @ReinitializationState
+  private int decoderReinitializationState;
+  private boolean decoderReceivedBuffers;
+  private boolean audioTrackNeedsConfigure;
 
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
-
-  private final AudioTrack audioTrack;
-  private int audioSessionId;
-
-  private boolean audioTrackHasData;
-  private long lastFeedElapsedRealtimeMs;
+  private boolean waitingForKeys;
 
   public SimpleDecoderAudioRenderer() {
     this(null, null);
@@ -70,7 +105,7 @@ public SimpleDecoderAudioRenderer() {
    */
   public SimpleDecoderAudioRenderer(Handler eventHandler,
       AudioRendererEventListener eventListener) {
-    this (eventHandler, eventListener, null, AudioManager.STREAM_MUSIC);
+    this(eventHandler, eventListener, null);
   }
 
   /**
@@ -79,16 +114,37 @@ public SimpleDecoderAudioRenderer(Handler eventHandler,
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
-   * @param streamType The type of audio stream for the {@link AudioTrack}.
+   */
+  public SimpleDecoderAudioRenderer(Handler eventHandler,
+      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities) {
+    this(eventHandler, eventListener, audioCapabilities, null, false);
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
+   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
    */
   public SimpleDecoderAudioRenderer(Handler eventHandler,
       AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
-      int streamType) {
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys) {
     super(C.TRACK_TYPE_AUDIO);
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    audioTrack = new AudioTrack(audioCapabilities, streamType);
+    audioTrack = new AudioTrack(audioCapabilities, new AudioTrackListener());
+    this.drmSessionManager = drmSessionManager;
     formatHolder = new FormatHolder();
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+    audioTrackNeedsConfigure = true;
   }
 
   @Override
@@ -96,6 +152,25 @@ public MediaClock getMediaClock() {
     return this;
   }
 
+  @Override
+  public final int supportsFormat(Format format) {
+    int formatSupport = supportsFormatInternal(format);
+    if (formatSupport == FORMAT_UNSUPPORTED_TYPE || formatSupport == FORMAT_UNSUPPORTED_SUBTYPE) {
+      return formatSupport;
+    }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
+  }
+
+  /**
+   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for
+   * {@link #supportsFormat(Format)}.
+   *
+   * @param format The format.
+   * @return The extent to which the renderer supports the format itself.
+   */
+  protected abstract int supportsFormatInternal(Format format);
+
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
@@ -109,43 +184,62 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
-    if (decoder == null) {
+    maybeInitDecoder();
+
+    if (decoder != null) {
       try {
-        long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-        TraceUtil.beginSection("createAudioDecoder");
-        decoder = createDecoder(inputFormat);
+        // Rendering loop.
+        TraceUtil.beginSection("drainAndFeed");
+        while (drainOutputBuffer()) {}
+        while (feedInputBuffer()) {}
         TraceUtil.endSection();
-        long codecInitializedTimestamp = SystemClock.elapsedRealtime();
-        eventDispatcher.decoderInitialized(decoder.getName(), codecInitializedTimestamp,
-            codecInitializedTimestamp - codecInitializingTimestamp);
-        decoderCounters.decoderInitCount++;
-      } catch (AudioDecoderException e) {
+      } catch (AudioTrack.InitializationException | AudioTrack.WriteException
+          | AudioDecoderException e) {
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
+      decoderCounters.ensureUpdated();
     }
+  }
 
-    // Rendering loop.
-    try {
-      TraceUtil.beginSection("drainAndFeed");
-      while (drainOutputBuffer()) {}
-      while (feedInputBuffer()) {}
-      TraceUtil.endSection();
-    } catch (AudioTrack.InitializationException | AudioTrack.WriteException
-        | AudioDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
-    }
-    decoderCounters.ensureUpdated();
+  /**
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
+   *
+   * @see AudioTrack.Listener#onAudioSessionId(int)
+   */
+  protected void onAudioSessionId(int audioSessionId) {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
   }
 
   /**
    * Creates a decoder for the given format.
    *
    * @param format The format for which a decoder is required.
+   * @param mediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted content.
+   *     Maybe null and can be ignored if decoder does not handle encrypted content.
    * @return The decoder.
    * @throws AudioDecoderException If an error occurred creating a suitable decoder.
    */
   protected abstract SimpleDecoder<DecoderInputBuffer, ? extends SimpleOutputBuffer,
-      ? extends AudioDecoderException> createDecoder(Format format) throws AudioDecoderException;
+      ? extends AudioDecoderException> createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+      throws AudioDecoderException;
 
   /**
    * Returns the format of audio buffers output by the decoder. Will not be called until the first
@@ -160,12 +254,8 @@ protected Format getOutputFormat() {
         null, null, 0, null);
   }
 
-  private boolean drainOutputBuffer() throws AudioDecoderException,
+  private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderException,
       AudioTrack.InitializationException, AudioTrack.WriteException {
-    if (outputStreamEnded) {
-      return false;
-    }
-
     if (outputBuffer == null) {
       outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
@@ -175,50 +265,29 @@ private boolean drainOutputBuffer() throws AudioDecoderException,
     }
 
     if (outputBuffer.isEndOfStream()) {
-      outputStreamEnded = true;
-      audioTrack.handleEndOfStream();
-      outputBuffer.release();
-      outputBuffer = null;
+      if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+        // We're waiting to re-initialize the decoder, and have now processed all final buffers.
+        releaseDecoder();
+        maybeInitDecoder();
+        // The audio track may need to be recreated once the new output format is known.
+        audioTrackNeedsConfigure = true;
+      } else {
+        outputBuffer.release();
+        outputBuffer = null;
+        outputStreamEnded = true;
+        audioTrack.handleEndOfStream();
+      }
       return false;
     }
 
-    if (!audioTrack.isInitialized()) {
+    if (audioTrackNeedsConfigure) {
       Format outputFormat = getOutputFormat();
       audioTrack.configure(outputFormat.sampleMimeType, outputFormat.channelCount,
           outputFormat.sampleRate, outputFormat.pcmEncoding, 0);
-      if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-        audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-        eventDispatcher.audioSessionId(audioSessionId);
-        onAudioSessionId(audioSessionId);
-      } else {
-        audioTrack.initialize(audioSessionId);
-      }
-      audioTrackHasData = false;
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    } else {
-      // Check for AudioTrack underrun.
-      boolean audioTrackHadData = audioTrackHasData;
-      audioTrackHasData = audioTrack.hasPendingData();
-      if (audioTrackHadData && !audioTrackHasData && getState() == STATE_STARTED) {
-        long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
-        long bufferSizeMs = C.usToMs(audioTrack.getBufferSizeUs());
-        eventDispatcher.audioTrackUnderrun(audioTrack.getBufferSize(), bufferSizeMs,
-            elapsedSinceLastFeedMs);
-      }
+      audioTrackNeedsConfigure = false;
     }
 
-    int handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs);
-    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+    if (audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs)) {
       decoderCounters.renderedOutputBufferCount++;
       outputBuffer.release();
       outputBuffer = null;
@@ -228,8 +297,10 @@ private boolean drainOutputBuffer() throws AudioDecoderException,
     return false;
   }
 
-  private boolean feedInputBuffer() throws AudioDecoderException {
-    if (inputStreamEnded) {
+  private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackException {
+    if (decoder == null || decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+        || inputStreamEnded) {
+      // We need to reinitialize the decoder or the input stream has ended.
       return false;
     }
 
@@ -240,7 +311,22 @@ private boolean feedInputBuffer() throws AudioDecoderException {
       }
     }
 
-    int result = readSource(formatHolder, inputBuffer);
+    if (decoderReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
+      inputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      decoderReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      return false;
+    }
+
+    int result;
+    if (waitingForKeys) {
+      // We've already read an encrypted sample into buffer, and are waiting for keys.
+      result = C.RESULT_BUFFER_READ;
+    } else {
+      result = readSource(formatHolder, inputBuffer);
+    }
+
     if (result == C.RESULT_NOTHING_READ) {
       return false;
     }
@@ -254,20 +340,45 @@ private boolean feedInputBuffer() throws AudioDecoderException {
       inputBuffer = null;
       return false;
     }
+    boolean bufferEncrypted = inputBuffer.isEncrypted();
+    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
+    if (waitingForKeys) {
+      return false;
+    }
     inputBuffer.flip();
     decoder.queueInputBuffer(inputBuffer);
+    decoderReceivedBuffers = true;
     decoderCounters.inputBufferCount++;
     inputBuffer = null;
     return true;
   }
 
-  private void flushDecoder() {
-    inputBuffer = null;
-    if (outputBuffer != null) {
-      outputBuffer.release();
-      outputBuffer = null;
+  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
+    if (drmSession == null) {
+      return false;
+    }
+    @DrmSession.State int drmSessionState = drmSession.getState();
+    if (drmSessionState == DrmSession.STATE_ERROR) {
+      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+    }
+    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS
+        && (bufferEncrypted || !playClearSamplesWithoutKeys);
+  }
+
+  private void flushDecoder() throws ExoPlaybackException {
+    waitingForKeys = false;
+    if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
+      releaseDecoder();
+      maybeInitDecoder();
+    } else {
+      inputBuffer = null;
+      if (outputBuffer != null) {
+        outputBuffer.release();
+        outputBuffer = null;
+      }
+      decoder.flush();
+      decoderReceivedBuffers = false;
     }
-    decoder.flush();
   }
 
   @Override
@@ -278,7 +389,7 @@ public boolean isEnded() {
   @Override
   public boolean isReady() {
     return audioTrack.hasPendingData()
-        || (inputFormat != null && (isSourceReady() || outputBuffer != null));
+        || (inputFormat != null && !waitingForKeys && (isSourceReady() || outputBuffer != null));
   }
 
   @Override
@@ -292,27 +403,20 @@ public long getPositionUs() {
     return currentPositionUs;
   }
 
-  /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op.
-   *
-   * @param audioSessionId The audio session id.
-   */
-  protected void onAudioSessionId(int audioSessionId) {
-    // Do nothing.
-  }
-
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
-  protected void onPositionReset(long positionUs, boolean joining) {
+  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     audioTrack.reset();
     currentPositionUs = positionUs;
     allowPositionDiscontinuity = true;
@@ -335,24 +439,81 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    inputBuffer = null;
-    outputBuffer = null;
     inputFormat = null;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    audioTrackNeedsConfigure = true;
+    waitingForKeys = false;
     try {
-      if (decoder != null) {
-        decoder.release();
-        decoder = null;
-        decoderCounters.decoderReleaseCount++;
-      }
+      releaseDecoder();
       audioTrack.release();
     } finally {
-      decoderCounters.ensureUpdated();
-      eventDispatcher.disabled(decoderCounters);
+      try {
+        if (drmSession != null) {
+          drmSessionManager.releaseSession(drmSession);
+        }
+      } finally {
+        try {
+          if (pendingDrmSession != null && pendingDrmSession != drmSession) {
+            drmSessionManager.releaseSession(pendingDrmSession);
+          }
+        } finally {
+          drmSession = null;
+          pendingDrmSession = null;
+          decoderCounters.ensureUpdated();
+          eventDispatcher.disabled(decoderCounters);
+        }
+      }
+    }
+  }
+
+  private void maybeInitDecoder() throws ExoPlaybackException {
+    if (decoder != null) {
+      return;
+    }
+
+    drmSession = pendingDrmSession;
+    ExoMediaCrypto mediaCrypto = null;
+    if (drmSession != null) {
+      @DrmSession.State int drmSessionState = drmSession.getState();
+      if (drmSessionState == DrmSession.STATE_ERROR) {
+        throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+      } else if (drmSessionState == DrmSession.STATE_OPENED
+          || drmSessionState == DrmSession.STATE_OPENED_WITH_KEYS) {
+        mediaCrypto = drmSession.getMediaCrypto();
+      } else {
+        // The drm session isn't open yet.
+        return;
+      }
     }
+
+    try {
+      long codecInitializingTimestamp = SystemClock.elapsedRealtime();
+      TraceUtil.beginSection("createAudioDecoder");
+      decoder = createDecoder(inputFormat, mediaCrypto);
+      TraceUtil.endSection();
+      long codecInitializedTimestamp = SystemClock.elapsedRealtime();
+      eventDispatcher.decoderInitialized(decoder.getName(), codecInitializedTimestamp,
+          codecInitializedTimestamp - codecInitializingTimestamp);
+      decoderCounters.decoderInitCount++;
+    } catch (AudioDecoderException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
+    }
+  }
+
+  private void releaseDecoder() {
+    if (decoder == null) {
+      return;
+    }
+
+    inputBuffer = null;
+    outputBuffer = null;
+    decoder.release();
+    decoder = null;
+    decoderCounters.decoderReleaseCount++;
+    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+    decoderReceivedBuffers = false;
   }
 
-  private boolean readFormat() {
+  private boolean readFormat() throws ExoPlaybackException {
     int result = readSource(formatHolder, null);
     if (result == C.RESULT_FORMAT_READ) {
       onInputFormatChanged(formatHolder.format);
@@ -361,8 +522,38 @@ private boolean readFormat() {
     return false;
   }
 
-  private void onInputFormatChanged(Format newFormat) {
+  private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+    Format oldFormat = inputFormat;
     inputFormat = newFormat;
+
+    boolean drmInitDataChanged = !Util.areEqual(inputFormat.drmInitData, oldFormat == null ? null
+        : oldFormat.drmInitData);
+    if (drmInitDataChanged) {
+      if (inputFormat.drmInitData != null) {
+        if (drmSessionManager == null) {
+          throw ExoPlaybackException.createForRenderer(
+              new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
+        }
+        pendingDrmSession = drmSessionManager.acquireSession(Looper.myLooper(),
+            inputFormat.drmInitData);
+        if (pendingDrmSession == drmSession) {
+          drmSessionManager.releaseSession(pendingDrmSession);
+        }
+      } else {
+        pendingDrmSession = null;
+      }
+    }
+
+    if (decoderReceivedBuffers) {
+      // Signal end of stream and wait for any final output buffers before re-initialization.
+      decoderReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
+    } else {
+      // There aren't any final output buffers, so release the decoder immediately.
+      releaseDecoder();
+      maybeInitDecoder();
+      audioTrackNeedsConfigure = true;
+    }
+
     eventDispatcher.inputFormatChanged(newFormat);
   }
 
@@ -375,10 +566,37 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
       case C.MSG_SET_PLAYBACK_PARAMS:
         audioTrack.setPlaybackParams((PlaybackParams) message);
         break;
+      case C.MSG_SET_STREAM_TYPE:
+        @C.StreamType int streamType = (Integer) message;
+        audioTrack.setStreamType(streamType);
+        break;
       default:
         super.handleMessage(messageType, message);
         break;
     }
   }
 
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      SimpleDecoderAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      SimpleDecoderAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DecryptionException.java b/library/src/main/java/com/google/android/exoplayer2/drm/DecryptionException.java
new file mode 100644
index 0000000000..6916b972b2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DecryptionException.java
@@ -0,0 +1,20 @@
+package com.google.android.exoplayer2.drm;
+
+/**
+ * An exception when doing drm decryption using the In-App Drm
+ */
+public class DecryptionException extends Exception {
+  private final int errorCode;
+
+  public DecryptionException(int errorCode, String message) {
+    super(message);
+    this.errorCode = errorCode;
+  }
+
+  /**
+   * Get error code
+   */
+  public int getErrorCode() {
+    return errorCode;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
similarity index 62%
rename from library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
rename to library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index f3c6595736..1cd8d8464d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -24,7 +24,10 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.IntDef;
 import android.text.TextUtils;
+import android.util.Log;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
@@ -33,18 +36,21 @@
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.HashMap;
+import java.util.Map;
 import java.util.UUID;
 
 /**
- * A {@link DrmSessionManager} that supports streaming playbacks using {@link MediaDrm}.
+ * A {@link DrmSessionManager} that supports playbacks using {@link MediaDrm}.
  */
 @TargetApi(18)
-public class StreamingDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
+public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
     DrmSession<T> {
 
   /**
-   * Listener of {@link StreamingDrmSessionManager} events.
+   * Listener of {@link DefaultDrmSessionManager} events.
    */
   public interface EventListener {
 
@@ -60,6 +66,16 @@
      */
     void onDrmSessionManagerError(Exception e);
 
+    /**
+     * Called each time offline keys are restored.
+     */
+    void onDrmKeysRestored();
+
+    /**
+     * Called each time offline keys are removed.
+     */
+    void onDrmKeysRemoved();
+
   }
 
   /**
@@ -67,9 +83,32 @@
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
 
+  /** Determines the action to be done after a session acquired. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({MODE_PLAYBACK, MODE_QUERY, MODE_DOWNLOAD, MODE_RELEASE})
+  public @interface Mode {}
+  /**
+   * Loads and refreshes (if necessary) a license for playback. Supports streaming and offline
+   * licenses.
+   */
+  public static final int MODE_PLAYBACK = 0;
+  /**
+   * Restores an offline license to allow its status to be queried. If the offline license is
+   * expired sets state to {@link #STATE_ERROR}.
+   */
+  public static final int MODE_QUERY = 1;
+  /** Downloads an offline license or renews an existing one. */
+  public static final int MODE_DOWNLOAD = 2;
+  /** Releases an existing offline license. */
+  public static final int MODE_RELEASE = 3;
+
+  private static final String TAG = "OfflineDrmSessionMngr";
+
   private static final int MSG_PROVISION = 0;
   private static final int MSG_KEYS = 1;
 
+  private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
+
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final ExoMediaDrm<T> mediaDrm;
@@ -85,14 +124,17 @@
   private HandlerThread requestHandlerThread;
   private Handler postRequestHandler;
 
+  private int mode;
   private int openCount;
   private boolean provisioningInProgress;
   @DrmSession.State
   private int state;
   private T mediaCrypto;
-  private Exception lastException;
-  private SchemeData schemeData;
+  private DrmSessionException lastException;
+  private byte[] schemeInitData;
+  private String schemeMimeType;
   private byte[] sessionId;
+  private byte[] offlineLicenseKeySetId;
 
   /**
    * Instantiates a new instance using the Widevine scheme.
@@ -105,7 +147,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
       MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
     return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters,
@@ -125,7 +167,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
       MediaDrmCallback callback, String customData, Handler eventHandler,
       EventListener eventListener) throws UnsupportedDrmException {
     HashMap<String, String> optionalKeyRequestParameters;
@@ -151,10 +193,10 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
       UUID uuid, MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
-    return new StreamingDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
+    return new DefaultDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
         optionalKeyRequestParameters, eventHandler, eventListener);
   }
 
@@ -168,7 +210,7 @@
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+  public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
       EventListener eventListener) {
     this.uuid = uuid;
@@ -179,6 +221,7 @@ public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCa
     this.eventListener = eventListener;
     mediaDrm.setOnEventListener(new MediaDrmEventListener());
     state = STATE_CLOSED;
+    mode = MODE_PLAYBACK;
   }
 
   /**
@@ -229,6 +272,35 @@ public final void setPropertyByteArray(String key, byte[] value) {
     mediaDrm.setPropertyByteArray(key, value);
   }
 
+  /**
+   * Sets the mode, which determines the role of sessions acquired from the instance. This must be
+   * called before {@link #acquireSession(Looper, DrmInitData)} is called.
+   *
+   * <p>By default, the mode is {@link #MODE_PLAYBACK} and a streaming license is requested when
+   * required.
+   *
+   * <p>{@code mode} must be one of these:
+   * <li>{@link #MODE_PLAYBACK}: If {@code offlineLicenseKeySetId} is null, a streaming license is
+   *     requested otherwise the offline license is restored.
+   * <li>{@link #MODE_QUERY}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is restored.
+   * <li>{@link #MODE_DOWNLOAD}: If {@code offlineLicenseKeySetId} is null, an offline license is
+   *     requested otherwise the offline license is renewed.
+   * <li>{@link #MODE_RELEASE}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is released.
+   *
+   * @param mode The mode to be set.
+   * @param offlineLicenseKeySetId The key set id of the license to be used with the given mode.
+   */
+  public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
+    Assertions.checkState(openCount == 0);
+    if (mode == MODE_QUERY || mode == MODE_RELEASE) {
+      Assertions.checkNotNull(offlineLicenseKeySetId);
+    }
+    this.mode = mode;
+    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+  }
+
   // DrmSessionManager implementation.
 
   @Override
@@ -248,18 +320,22 @@ public final void setPropertyByteArray(String key, byte[] value) {
     requestHandlerThread.start();
     postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
 
-    schemeData = drmInitData.get(uuid);
-    if (schemeData == null) {
-      onError(new IllegalStateException("Media does not support uuid: " + uuid));
-      return this;
-    }
-    if (Util.SDK_INT < 21) {
-      // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeData.data, C.WIDEVINE_UUID);
-      if (psshData == null) {
-        // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
-      } else {
-        schemeData = new SchemeData(C.WIDEVINE_UUID, schemeData.mimeType, psshData);
+    if (offlineLicenseKeySetId == null) {
+      SchemeData schemeData = drmInitData.get(uuid);
+      if (schemeData == null) {
+        onError(new IllegalStateException("Media does not support uuid: " + uuid));
+        return this;
+      }
+      schemeInitData = schemeData.data;
+      schemeMimeType = schemeData.mimeType;
+      if (Util.SDK_INT < 21) {
+        // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
+        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, C.WIDEVINE_UUID);
+        if (psshData == null) {
+          // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
+        } else {
+          schemeInitData = psshData;
+        }
       }
     }
     state = STATE_OPENING;
@@ -280,7 +356,8 @@ public void releaseSession(DrmSession<T> session) {
     postRequestHandler = null;
     requestHandlerThread.quit();
     requestHandlerThread = null;
-    schemeData = null;
+    schemeInitData = null;
+    schemeMimeType = null;
     mediaCrypto = null;
     lastException = null;
     if (sessionId != null) {
@@ -314,10 +391,25 @@ public boolean requiresSecureDecoderComponent(String mimeType) {
   }
 
   @Override
-  public final Exception getError() {
+  public final DrmSessionException getError() {
     return state == STATE_ERROR ? lastException : null;
   }
 
+  @Override
+  public Map<String, String> queryKeyStatus() {
+    // User may call this method rightfully even if state == STATE_ERROR. So only check if there is
+    // a sessionId
+    if (sessionId == null) {
+      throw new IllegalStateException();
+    }
+    return mediaDrm.queryKeyStatus(sessionId);
+  }
+
+  @Override
+  public byte[] getOfflineLicenseKeySetId() {
+    return offlineLicenseKeySetId;
+  }
+
   // Internal methods.
 
   private void openInternal(boolean allowProvisioning) {
@@ -325,7 +417,7 @@ private void openInternal(boolean allowProvisioning) {
       sessionId = mediaDrm.openSession();
       mediaCrypto = mediaDrm.createMediaCrypto(uuid, sessionId);
       state = STATE_OPENED;
-      postKeyRequest();
+      doLicense();
     } catch (NotProvisionedException e) {
       if (allowProvisioning) {
         postProvisionRequest();
@@ -363,20 +455,86 @@ private void onProvisionResponse(Object response) {
       if (state == STATE_OPENING) {
         openInternal(false);
       } else {
-        postKeyRequest();
+        doLicense();
       }
     } catch (DeniedByServerException e) {
       onError(e);
     }
   }
 
-  private void postKeyRequest() {
-    KeyRequest keyRequest;
+  private void doLicense() {
+    switch (mode) {
+      case MODE_PLAYBACK:
+      case MODE_QUERY:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_STREAMING);
+        } else {
+          if (restoreKeys()) {
+            long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
+            if (mode == MODE_PLAYBACK
+                && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
+              Log.d(TAG, "Offline license has expired or will expire soon. "
+                  + "Remaining seconds: " + licenseDurationRemainingSec);
+              postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+            } else if (licenseDurationRemainingSec <= 0) {
+              onError(new KeysExpiredException());
+            } else {
+              state = STATE_OPENED_WITH_KEYS;
+              if (eventHandler != null && eventListener != null) {
+                eventHandler.post(new Runnable() {
+                  @Override
+                  public void run() {
+                    eventListener.onDrmKeysRestored();
+                  }
+                });
+              }
+            }
+          }
+        }
+        break;
+      case MODE_DOWNLOAD:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+        } else {
+          // Renew
+          if (restoreKeys()) {
+            postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+          }
+        }
+        break;
+      case MODE_RELEASE:
+        if (restoreKeys()) {
+          postKeyRequest(offlineLicenseKeySetId, MediaDrm.KEY_TYPE_RELEASE);
+        }
+        break;
+    }
+  }
+
+  private boolean restoreKeys() {
+    try {
+      mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
+      return true;
+    } catch (Exception e) {
+      Log.e(TAG, "Error trying to restore Widevine keys.", e);
+      onError(e);
+    }
+    return false;
+  }
+
+  private long getLicenseDurationRemainingSec() {
+    if (!C.WIDEVINE_UUID.equals(uuid)) {
+      return Long.MAX_VALUE;
+    }
+    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
+    return Math.min(pair.first, pair.second);
+  }
+
+  private void postKeyRequest(byte[] scope, int keyType) {
     try {
-      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeData.data, schemeData.mimeType,
-          MediaDrm.KEY_TYPE_STREAMING, optionalKeyRequestParameters);
+      KeyRequest keyRequest = mediaDrm.getKeyRequest(scope, schemeInitData, schemeMimeType, keyType,
+          optionalKeyRequestParameters);
       postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
-    } catch (NotProvisionedException e) {
+    } catch (Exception e) {
       onKeysError(e);
     }
   }
@@ -393,15 +551,31 @@ private void onKeyResponse(Object response) {
     }
 
     try {
-      mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
-      state = STATE_OPENED_WITH_KEYS;
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            eventListener.onDrmKeysLoaded();
-          }
-        });
+      if (mode == MODE_RELEASE) {
+        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, (byte[]) response);
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysRemoved();
+            }
+          });
+        }
+      } else {
+        byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
+        if ((mode == MODE_DOWNLOAD || (mode == MODE_PLAYBACK && offlineLicenseKeySetId != null))
+            && keySetId != null && keySetId.length != 0) {
+          offlineLicenseKeySetId = keySetId;
+        }
+        state = STATE_OPENED_WITH_KEYS;
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysLoaded();
+            }
+          });
+        }
       }
     } catch (Exception e) {
       onKeysError(e);
@@ -417,7 +591,7 @@ private void onKeysError(Exception e) {
   }
 
   private void onError(final Exception e) {
-    lastException = e;
+    lastException = new DrmSessionException(e);
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable() {
         @Override
@@ -446,16 +620,21 @@ public void handleMessage(Message msg) {
       }
       switch (msg.what) {
         case MediaDrm.EVENT_KEY_REQUIRED:
-          postKeyRequest();
-          return;
+          doLicense();
+          break;
         case MediaDrm.EVENT_KEY_EXPIRED:
-          state = STATE_OPENED;
-          onError(new KeysExpiredException());
-          return;
+          // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
+          // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
+          // waiting for key response.
+          if (state == STATE_OPENED_WITH_KEYS) {
+            state = STATE_OPENED;
+            onError(new KeysExpiredException());
+          }
+          break;
         case MediaDrm.EVENT_PROVISION_REQUIRED:
           state = STATE_OPENED;
           postProvisionRequest();
-          return;
+          break;
       }
     }
 
@@ -466,7 +645,9 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(ExoMediaDrm<? extends T> md, byte[] sessionId, int event, int extra,
         byte[] data) {
-      mediaDrmHandler.sendEmptyMessage(event);
+      if (mode == MODE_PLAYBACK) {
+        mediaDrmHandler.sendEmptyMessage(event);
+      }
     }
 
   }
@@ -483,10 +664,10 @@ public void handleMessage(Message msg) {
       switch (msg.what) {
         case MSG_PROVISION:
           onProvisionResponse(msg.obj);
-          return;
+          break;
         case MSG_KEYS:
           onKeyResponse(msg.obj);
-          return;
+          break;
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index 6f84395072..4d64187a8b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -16,9 +16,11 @@
 package com.google.android.exoplayer2.drm;
 
 import android.annotation.TargetApi;
+import android.media.MediaDrm;
 import android.support.annotation.IntDef;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Map;
 
 /**
  * A DRM session.
@@ -26,6 +28,15 @@
 @TargetApi(16)
 public interface DrmSession<T extends ExoMediaCrypto> {
 
+  /** Wraps the exception which is the cause of the error state. */
+  class DrmSessionException extends Exception {
+
+    DrmSessionException(Exception e) {
+      super(e);
+    }
+
+  }
+
   /**
    * The state of the DRM session.
    */
@@ -96,6 +107,26 @@
    *
    * @return An exception if the state is {@link #STATE_ERROR}. Null otherwise.
    */
-  Exception getError();
+  DrmSessionException getError();
+
+  /**
+   * Returns an informative description of the key status for the session. The status is in the form
+   * of {name, value} pairs.
+   *
+   * <p>Since DRM license policies vary by vendor, the specific status field names are determined by
+   * each DRM vendor. Refer to your DRM provider documentation for definitions of the field names
+   * for a particular DRM engine plugin.
+   *
+   * @return A map of key status.
+   * @throws IllegalStateException If called when the session isn't opened.
+   * @see MediaDrm#queryKeyStatus(byte[])
+   */
+  Map<String, String> queryKeyStatus();
+
+  /**
+   * Returns the key set id of the offline license loaded into this session, if there is one. Null
+   * otherwise.
+   */
+  byte[] getOfflineLicenseKeySetId();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 65e41dd91e..e0c9ca5296 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -105,7 +105,7 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
     try {
       return Util.toByteArray(inputStream);
     } finally {
-      inputStream.close();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
new file mode 100644
index 0000000000..a11d65d4d3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import android.media.MediaDrm;
+import android.net.Uri;
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.EventListener;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.Mode;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
+import com.google.android.exoplayer2.source.chunk.InitializationChunk;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * Helper class to download, renew and release offline licenses. It utilizes {@link
+ * DefaultDrmSessionManager}.
+ */
+public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
+
+  private final ConditionVariable conditionVariable;
+  private final DefaultDrmSessionManager<T> drmSessionManager;
+  private final HandlerThread handlerThread;
+
+  /**
+   * Helper method to download a DASH manifest.
+   *
+   * @param dataSource The {@link HttpDataSource} from which the manifest should be read.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return An instance of {@link DashManifest}.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @see DashManifestParser
+   */
+  public static DashManifest downloadManifest(HttpDataSource dataSource, String manifestUriString)
+      throws IOException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(
+        dataSource, new DataSpec(Uri.parse(manifestUriString)));
+    try {
+      inputStream.open();
+      DashManifestParser parser = new DashManifestParser();
+      return parser.parse(dataSource.getUri(), inputStream);
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param licenseUrl The default license URL.
+   * @param httpDataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      String licenseUrl, Factory httpDataSourceFactory) throws UnsupportedDrmException {
+    return newWidevineInstance(
+        new HttpMediaDrmCallback(licenseUrl, httpDataSourceFactory, null), null);
+  }
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters)
+      throws UnsupportedDrmException {
+    return new OfflineLicenseHelper<>(FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID), callback,
+        optionalKeyRequestParameters);
+  }
+
+  /**
+   * Constructs an instance. Call {@link #releaseResources()} when you're done with it.
+   *
+   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public OfflineLicenseHelper(ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+      HashMap<String, String> optionalKeyRequestParameters) {
+    handlerThread = new HandlerThread("OfflineLicenseHelper");
+    handlerThread.start();
+
+    conditionVariable = new ConditionVariable();
+    EventListener eventListener = new EventListener() {
+      @Override
+      public void onDrmKeysLoaded() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmSessionManagerError(Exception e) {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRestored() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRemoved() {
+        conditionVariable.open();
+      }
+    };
+    drmSessionManager = new DefaultDrmSessionManager<>(C.WIDEVINE_UUID, mediaDrm, callback,
+        optionalKeyRequestParameters, new Handler(handlerThread.getLooper()), eventListener);
+  }
+
+  /** Releases the used resources. */
+  public void releaseResources() {
+    handlerThread.quit();
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, String manifestUriString)
+      throws IOException, InterruptedException, DrmSessionException {
+    return download(dataSource, downloadManifest(dataSource, manifestUriString));
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param dashManifest The {@link DashManifest} of the DASH content.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, DashManifest dashManifest)
+      throws IOException, InterruptedException, DrmSessionException {
+    // Get DrmInitData
+    // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
+    // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
+    if (dashManifest.getPeriodCount() < 1) {
+      return null;
+    }
+    Period period = dashManifest.getPeriod(0);
+    int adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
+    if (adaptationSetIndex == C.INDEX_UNSET) {
+      adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_AUDIO);
+      if (adaptationSetIndex == C.INDEX_UNSET) {
+        return null;
+      }
+    }
+    AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
+    if (adaptationSet.representations.isEmpty()) {
+      return null;
+    }
+    Representation representation = adaptationSet.representations.get(0);
+    DrmInitData drmInitData = representation.format.drmInitData;
+    if (drmInitData == null) {
+      InitializationChunk initializationChunk = loadInitializationChunk(dataSource, representation);
+      if (initializationChunk == null) {
+        return null;
+      }
+      Format sampleFormat = initializationChunk.getSampleFormat();
+      if (sampleFormat != null) {
+        drmInitData = sampleFormat.drmInitData;
+      }
+      if (drmInitData == null) {
+        return null;
+      }
+    }
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, drmInitData);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Renews an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be renewed.
+   * @return Renewed offline license key set id.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] renew(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, offlineLicenseKeySetId, null);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Releases an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be released.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public void release(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_RELEASE, offlineLicenseKeySetId, null);
+  }
+
+  /**
+   * Returns license and playback durations remaining in seconds of the given offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license.
+   */
+  public Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
+      throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    DrmSession<T> session = openBlockingKeyRequest(DefaultDrmSessionManager.MODE_QUERY,
+        offlineLicenseKeySetId, null);
+    Pair<Long, Long> licenseDurationRemainingSec =
+        WidevineUtil.getLicenseDurationRemainingSec(drmSessionManager);
+    drmSessionManager.releaseSession(session);
+    return licenseDurationRemainingSec;
+  }
+
+  private void blockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) throws DrmSessionException {
+    DrmSession<T> session = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
+        drmInitData);
+    DrmSessionException error = session.getError();
+    if (error != null) {
+      throw error;
+    }
+    drmSessionManager.releaseSession(session);
+  }
+
+  private DrmSession<T> openBlockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) {
+    drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);
+    conditionVariable.close();
+    DrmSession<T> session = drmSessionManager.acquireSession(handlerThread.getLooper(),
+        drmInitData);
+    // Block current thread until key loading is finished
+    conditionVariable.block();
+    return session;
+  }
+
+  private static InitializationChunk loadInitializationChunk(final DataSource dataSource,
+      final Representation representation) throws IOException, InterruptedException {
+    RangedUri rangedUri = representation.getInitializationUri();
+    if (rangedUri == null) {
+      return null;
+    }
+    DataSpec dataSpec = new DataSpec(rangedUri.resolveUri(representation.baseUrl), rangedUri.start,
+        rangedUri.length, representation.getCacheKey());
+    InitializationChunk initializationChunk = new InitializationChunk(dataSource, dataSpec,
+        representation.format, C.SELECTION_REASON_UNKNOWN, null /* trackSelectionData */,
+        newWrappedExtractor(representation.format));
+    initializationChunk.load();
+    return initializationChunk;
+  }
+
+  private static ChunkExtractorWrapper newWrappedExtractor(final Format format) {
+    final String mimeType = format.containerMimeType;
+    final boolean isWebm = mimeType.startsWith(MimeTypes.VIDEO_WEBM)
+        || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
+    final Extractor extractor = isWebm ? new MatroskaExtractor() : new FragmentedMp4Extractor();
+    return new ChunkExtractorWrapper(extractor, format, false /* preferManifestDrmInitData */,
+        false /* resendFormatOnInit */);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
new file mode 100644
index 0000000000..fc80cfb6fb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import java.util.Map;
+
+/**
+ * Utility methods for Widevine.
+ */
+public final class WidevineUtil {
+
+  /** Widevine specific key status field name for the remaining license duration, in seconds. */
+  public static final String PROPERTY_LICENSE_DURATION_REMAINING = "LicenseDurationRemaining";
+  /** Widevine specific key status field name for the remaining playback duration, in seconds. */
+  public static final String PROPERTY_PLAYBACK_DURATION_REMAINING = "PlaybackDurationRemaining";
+
+  private WidevineUtil() {}
+
+  /**
+   * Returns license and playback durations remaining in seconds.
+   *
+   * @return A {@link Pair} consisting of the remaining license and playback durations in seconds.
+   * @throws IllegalStateException If called when a session isn't opened.
+   * @param drmSession
+   */
+  public static Pair<Long, Long> getLicenseDurationRemainingSec(DrmSession drmSession) {
+    Map<String, String> keyStatus = drmSession.queryKeyStatus();
+    return new Pair<>(
+        getDurationRemainingSec(keyStatus, PROPERTY_LICENSE_DURATION_REMAINING),
+        getDurationRemainingSec(keyStatus, PROPERTY_PLAYBACK_DURATION_REMAINING));
+  }
+
+  private static long getDurationRemainingSec(Map<String, String> keyStatus, String property) {
+    if (keyStatus != null) {
+      try {
+        String value = keyStatus.get(property);
+        if (value != null) {
+          return Long.parseLong(value);
+        }
+      } catch (NumberFormatException e) {
+        // do nothing.
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index cb9e41aa62..b3bcd97048 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -226,13 +226,32 @@ public long getLargestQueuedTimestampUs() {
   }
 
   /**
-   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier, and if {@code timeUs} falls
+   * within the currently buffered media.
+   * <p>
+   * This method is equivalent to {@code skipToKeyframeBefore(timeUs, false)}.
    *
    * @param timeUs The seek time.
    * @return Whether the skip was successful.
    */
   public boolean skipToKeyframeBefore(long timeUs) {
-    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
+    return skipToKeyframeBefore(timeUs, false);
+  }
+
+  /**
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier. If
+   * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+   * falls within the buffer.
+   *
+   * @param timeUs The seek time.
+   * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+   *     of the buffer.
+   * @return Whether the skip was successful.
+   */
+  public boolean skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
+    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs, allowTimeBeyondBuffer);
     if (nextOffset == C.POSITION_UNSET) {
       return false;
     }
@@ -246,7 +265,8 @@ public boolean skipToKeyframeBefore(long timeUs) {
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.  May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
    * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
    *     be set if the buffer's timestamp is less than this value.
@@ -732,7 +752,8 @@ public synchronized long getLargestQueuedTimestampUs() {
      *     about the sample, but not its data. The size and absolute position of the data in the
      *     rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
      *     and the absolute position of the first byte that may still be required after the current
-     *     sample has been read.
+     *     sample has been read. May be null if the caller requires that the format of the stream be
+     *     read even if it's not changing.
      * @param downstreamFormat The current downstream {@link Format}. If the format of the next
      *     sample is different to the current downstream format then a format will be read.
      * @param extrasHolder The holder into which extra sample information should be written.
@@ -742,14 +763,14 @@ public synchronized long getLargestQueuedTimestampUs() {
     public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         Format downstreamFormat, BufferExtrasHolder extrasHolder) {
       if (queueSize == 0) {
-        if (upstreamFormat != null && upstreamFormat != downstreamFormat) {
+        if (upstreamFormat != null && (buffer == null || upstreamFormat != downstreamFormat)) {
           formatHolder.format = upstreamFormat;
           return C.RESULT_FORMAT_READ;
         }
         return C.RESULT_NOTHING_READ;
       }
 
-      if (formats[relativeReadIndex] != downstreamFormat) {
+      if (buffer == null || formats[relativeReadIndex] != downstreamFormat) {
         formatHolder.format = formats[relativeReadIndex];
         return C.RESULT_FORMAT_READ;
       }
@@ -775,20 +796,22 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
     }
 
     /**
-     * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+     * Attempts to locate the keyframe before or at the specified time. If
+     * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+     * falls within the buffer.
      *
      * @param timeUs The seek time.
+     * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+     *     of the buffer.
      * @return The offset of the keyframe's data if the keyframe was present.
      *     {@link C#POSITION_UNSET} otherwise.
      */
-    public synchronized long skipToKeyframeBefore(long timeUs) {
+    public synchronized long skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
       if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
         return C.POSITION_UNSET;
       }
 
-      int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
-      long lastTimeUs = timesUs[lastWriteIndex];
-      if (timeUs > lastTimeUs) {
+      if (timeUs > largestQueuedTimestampUs && !allowTimeBeyondBuffer) {
         return C.POSITION_UNSET;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 4120110afb..38b0325cba 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -93,9 +93,10 @@ int read(ExtractorInput input, PositionHolder seekPosition)
    * position} in the stream. Valid random access positions are the start of the stream and
    * positions that can be obtained from any {@link SeekMap} passed to the {@link ExtractorOutput}.
    *
-   * @param position The seek position.
+   * @param position The byte offset in the stream from which data will be provided.
+   * @param timeUs The seek time in microseconds.
    */
-  void seek(long position);
+  void seek(long position, long timeUs);
 
   /**
    * Releases all kept resources.
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java b/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
index 6eb9bc50de..7e2a1b4a23 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.extractor;
 
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.CommentFrame;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -65,6 +67,25 @@ public boolean setFromXingHeaderValue(int value) {
     return false;
   }
 
+  /**
+   * Populates the holder with data parsed from ID3 {@link Metadata}.
+   *
+   * @param metadata The metadata from which to parse the gapless information.
+   * @return Whether the holder was populated.
+   */
+  public boolean setFromMetadata(Metadata metadata) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Metadata.Entry entry = metadata.get(i);
+      if (entry instanceof CommentFrame) {
+        CommentFrame commentFrame = (CommentFrame) entry;
+        if (setFromComment(commentFrame.description, commentFrame.text)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
   /**
    * Populates the holder with data parsed from a gapless playback comment (stored in an ID3 header
    * or MPEG 4 user data), if valid and non-zero.
@@ -73,7 +94,7 @@ public boolean setFromXingHeaderValue(int value) {
    * @param data The comment's payload data.
    * @return Whether the holder was populated.
    */
-  public boolean setFromComment(String name, String data) {
+  private boolean setFromComment(String name, String data) {
     if (!GAPLESS_COMMENT_ID.equals(name)) {
       return false;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
index b48c4881d9..3ee87b47ea 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java
@@ -29,21 +29,17 @@
  */
 /* package */ final class AudioTagPayloadReader extends TagPayloadReader {
 
-  // Audio format
+  private static final int AUDIO_FORMAT_ALAW = 7;
+  private static final int AUDIO_FORMAT_ULAW = 8;
   private static final int AUDIO_FORMAT_AAC = 10;
 
-  // AAC PACKET TYPE
   private static final int AAC_PACKET_TYPE_SEQUENCE_HEADER = 0;
   private static final int AAC_PACKET_TYPE_AAC_RAW = 1;
 
-  // SAMPLING RATES
-  private static final int[] AUDIO_SAMPLING_RATE_TABLE = new int[] {
-      5500, 11000, 22000, 44000
-  };
-
   // State variables
   private boolean hasParsedAudioDataHeader;
   private boolean hasOutputFormat;
+  private int audioFormat;
 
   public AudioTagPayloadReader(TrackOutput output) {
     super(output);
@@ -58,13 +54,17 @@ public void seek() {
   protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatException {
     if (!hasParsedAudioDataHeader) {
       int header = data.readUnsignedByte();
-      int audioFormat = (header >> 4) & 0x0F;
-      int sampleRateIndex = (header >> 2) & 0x03;
-      if (sampleRateIndex < 0 || sampleRateIndex >= AUDIO_SAMPLING_RATE_TABLE.length) {
-        throw new UnsupportedFormatException("Invalid sample rate index: " + sampleRateIndex);
-      }
-      // TODO: Add support for MP3 and PCM.
-      if (audioFormat != AUDIO_FORMAT_AAC) {
+      audioFormat = (header >> 4) & 0x0F;
+      // TODO: Add support for MP3.
+      if (audioFormat == AUDIO_FORMAT_ALAW || audioFormat == AUDIO_FORMAT_ULAW) {
+        String type = audioFormat == AUDIO_FORMAT_ALAW ? MimeTypes.AUDIO_ALAW
+            : MimeTypes.AUDIO_ULAW;
+        int pcmEncoding = (header & 0x01) == 1 ? C.ENCODING_PCM_16BIT : C.ENCODING_PCM_8BIT;
+        Format format = Format.createAudioSampleFormat(null, type, null, Format.NO_VALUE,
+            Format.NO_VALUE, 1, 8000, pcmEncoding, null, null, 0, null);
+        output.format(format);
+        hasOutputFormat = true;
+      } else if (audioFormat != AUDIO_FORMAT_AAC) {
         throw new UnsupportedFormatException("Audio format not supported: " + audioFormat);
       }
       hasParsedAudioDataHeader = true;
@@ -78,22 +78,21 @@ protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatEx
   @Override
   protected void parsePayload(ParsableByteArray data, long timeUs) {
     int packetType = data.readUnsignedByte();
-    // Parse sequence header just in case it was not done before.
     if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
-      byte[] audioSpecifiConfig = new byte[data.bytesLeft()];
-      data.readBytes(audioSpecifiConfig, 0, audioSpecifiConfig.length);
+      // Parse the sequence header.
+      byte[] audioSpecificConfig = new byte[data.bytesLeft()];
+      data.readBytes(audioSpecificConfig, 0, audioSpecificConfig.length);
       Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
-          audioSpecifiConfig);
+          audioSpecificConfig);
       Format format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_AAC, null,
           Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
-          Collections.singletonList(audioSpecifiConfig), null, 0, null);
+          Collections.singletonList(audioSpecificConfig), null, 0, null);
       output.format(format);
       hasOutputFormat = true;
-    } else if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
-      // Sample audio AAC frames
-      int bytesToWrite = data.bytesLeft();
-      output.sampleData(data, bytesToWrite);
-      output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, bytesToWrite, 0, null);
+    } else if (audioFormat != AUDIO_FORMAT_AAC || packetType == AAC_PACKET_TYPE_AAC_RAW) {
+      int sampleSize = data.bytesLeft();
+      output.sampleData(data, sampleSize);
+      output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 9c3721d8fe..5b396749ac 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -126,7 +126,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     parserState = STATE_READING_FLV_HEADER;
     bytesToNextTagHeader = 0;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index bc2d891dab..970335e9d2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
@@ -84,6 +85,7 @@
   private static final String CODEC_ID_VORBIS = "A_VORBIS";
   private static final String CODEC_ID_OPUS = "A_OPUS";
   private static final String CODEC_ID_AAC = "A_AAC";
+  private static final String CODEC_ID_MP2 = "A_MPEG/L2";
   private static final String CODEC_ID_MP3 = "A_MPEG/L3";
   private static final String CODEC_ID_AC3 = "A_AC3";
   private static final String CODEC_ID_E_AC3 = "A_EAC3";
@@ -100,7 +102,6 @@
 
   private static final int VORBIS_MAX_INPUT_SIZE = 8192;
   private static final int OPUS_MAX_INPUT_SIZE = 5760;
-  private static final int MP3_MAX_INPUT_SIZE = 4096;
   private static final int ENCRYPTION_IV_SIZE = 8;
   private static final int TRACK_TYPE_AUDIO = 2;
 
@@ -317,7 +318,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     clusterTimecodeUs = C.TIME_UNSET;
     blockState = BLOCK_STATE_START;
     reader.reset();
@@ -431,18 +432,18 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         segmentContentPosition = contentPosition;
         segmentContentSize = contentSize;
-        return;
+        break;
       case ID_SEEK:
         seekEntryId = UNSET_ENTRY_ID;
         seekEntryPosition = C.POSITION_UNSET;
-        return;
+        break;
       case ID_CUES:
         cueTimesUs = new LongArray();
         cueClusterPositions = new LongArray();
-        return;
+        break;
       case ID_CUE_POINT:
         seenClusterPositionForCurrentCuePoint = false;
-        return;
+        break;
       case ID_CLUSTER:
         if (!sentSeekMap) {
           // We need to build cues before parsing the cluster.
@@ -456,21 +457,21 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
             sentSeekMap = true;
           }
         }
-        return;
+        break;
       case ID_BLOCK_GROUP:
         sampleSeenReferenceBlock = false;
-        return;
+        break;
       case ID_CONTENT_ENCODING:
         // TODO: check and fail if more than one content encoding is present.
-        return;
+        break;
       case ID_CONTENT_ENCRYPTION:
         currentTrack.hasContentEncryption = true;
-        return;
+        break;
       case ID_TRACK_ENTRY:
         currentTrack = new Track();
-        return;
+        break;
       default:
-        return;
+        break;
     }
   }
 
@@ -484,7 +485,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         if (durationTimecode != C.TIME_UNSET) {
           durationUs = scaleTimecodeToUs(durationTimecode);
         }
-        return;
+        break;
       case ID_SEEK:
         if (seekEntryId == UNSET_ENTRY_ID || seekEntryPosition == C.POSITION_UNSET) {
           throw new ParserException("Mandatory element SeekID or SeekPosition not found");
@@ -492,7 +493,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         if (seekEntryId == ID_CUES) {
           cuesContentPosition = seekEntryPosition;
         }
-        return;
+        break;
       case ID_CUES:
         if (!sentSeekMap) {
           extractorOutput.seekMap(buildSeekMap());
@@ -500,7 +501,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         } else {
           // We have already built the cues. Ignore.
         }
-        return;
+        break;
       case ID_BLOCK_GROUP:
         if (blockState != BLOCK_STATE_DATA) {
           // We've skipped this block (due to incompatible track number).
@@ -512,7 +513,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         commitSampleToOutput(tracks.get(blockTrackNumber), blockTimeUs);
         blockState = BLOCK_STATE_START;
-        return;
+        break;
       case ID_CONTENT_ENCODING:
         if (currentTrack.hasContentEncryption) {
           if (currentTrack.encryptionKeyId == null) {
@@ -521,29 +522,27 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           currentTrack.drmInitData = new DrmInitData(
               new SchemeData(C.UUID_NIL, MimeTypes.VIDEO_WEBM, currentTrack.encryptionKeyId));
         }
-        return;
+        break;
       case ID_CONTENT_ENCODINGS:
         if (currentTrack.hasContentEncryption && currentTrack.sampleStrippedBytes != null) {
           throw new ParserException("Combining encryption and compression is not supported");
         }
-        return;
+        break;
       case ID_TRACK_ENTRY:
-        if (tracks.get(currentTrack.number) == null && isCodecSupported(currentTrack.codecId)) {
+        if (isCodecSupported(currentTrack.codecId)) {
           currentTrack.initializeOutput(extractorOutput, currentTrack.number);
           tracks.put(currentTrack.number, currentTrack);
-        } else {
-          // We've seen this track entry before, or the codec is unsupported. Do nothing.
         }
         currentTrack = null;
-        return;
+        break;
       case ID_TRACKS:
         if (tracks.size() == 0) {
           throw new ParserException("No valid tracks were found");
         }
         extractorOutput.endTracks();
-        return;
+        break;
       default:
-        return;
+        break;
     }
   }
 
@@ -554,99 +553,99 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         if (value != 1) {
           throw new ParserException("EBMLReadVersion " + value + " not supported");
         }
-        return;
+        break;
       case ID_DOC_TYPE_READ_VERSION:
         // Validate that DocTypeReadVersion is supported. This extractor only supports up to v2.
         if (value < 1 || value > 2) {
           throw new ParserException("DocTypeReadVersion " + value + " not supported");
         }
-        return;
+        break;
       case ID_SEEK_POSITION:
         // Seek Position is the relative offset beginning from the Segment. So to get absolute
         // offset from the beginning of the file, we need to add segmentContentPosition to it.
         seekEntryPosition = value + segmentContentPosition;
-        return;
+        break;
       case ID_TIMECODE_SCALE:
         timecodeScale = value;
-        return;
+        break;
       case ID_PIXEL_WIDTH:
         currentTrack.width = (int) value;
-        return;
+        break;
       case ID_PIXEL_HEIGHT:
         currentTrack.height = (int) value;
-        return;
+        break;
       case ID_DISPLAY_WIDTH:
         currentTrack.displayWidth = (int) value;
-        return;
+        break;
       case ID_DISPLAY_HEIGHT:
         currentTrack.displayHeight = (int) value;
-        return;
+        break;
       case ID_DISPLAY_UNIT:
         currentTrack.displayUnit = (int) value;
-        return;
+        break;
       case ID_TRACK_NUMBER:
         currentTrack.number = (int) value;
-        return;
+        break;
       case ID_FLAG_DEFAULT:
         currentTrack.flagForced = value == 1;
-        return;
+        break;
       case ID_FLAG_FORCED:
         currentTrack.flagDefault = value == 1;
-        return;
+        break;
       case ID_TRACK_TYPE:
         currentTrack.type = (int) value;
-        return;
+        break;
       case ID_DEFAULT_DURATION:
         currentTrack.defaultSampleDurationNs = (int) value;
-        return;
+        break;
       case ID_CODEC_DELAY:
         currentTrack.codecDelayNs = value;
-        return;
+        break;
       case ID_SEEK_PRE_ROLL:
         currentTrack.seekPreRollNs = value;
-        return;
+        break;
       case ID_CHANNELS:
         currentTrack.channelCount = (int) value;
-        return;
+        break;
       case ID_AUDIO_BIT_DEPTH:
         currentTrack.audioBitDepth = (int) value;
-        return;
+        break;
       case ID_REFERENCE_BLOCK:
         sampleSeenReferenceBlock = true;
-        return;
+        break;
       case ID_CONTENT_ENCODING_ORDER:
         // This extractor only supports one ContentEncoding element and hence the order has to be 0.
         if (value != 0) {
           throw new ParserException("ContentEncodingOrder " + value + " not supported");
         }
-        return;
+        break;
       case ID_CONTENT_ENCODING_SCOPE:
         // This extractor only supports the scope of all frames.
         if (value != 1) {
           throw new ParserException("ContentEncodingScope " + value + " not supported");
         }
-        return;
+        break;
       case ID_CONTENT_COMPRESSION_ALGORITHM:
         // This extractor only supports header stripping.
         if (value != 3) {
           throw new ParserException("ContentCompAlgo " + value + " not supported");
         }
-        return;
+        break;
       case ID_CONTENT_ENCRYPTION_ALGORITHM:
         // Only the value 5 (AES) is allowed according to the WebM specification.
         if (value != 5) {
           throw new ParserException("ContentEncAlgo " + value + " not supported");
         }
-        return;
+        break;
       case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
         // Only the value 1 is allowed according to the WebM specification.
         if (value != 1) {
           throw new ParserException("AESSettingsCipherMode " + value + " not supported");
         }
-        return;
+        break;
       case ID_CUE_TIME:
         cueTimesUs.add(scaleTimecodeToUs(value));
-        return;
+        break;
       case ID_CUE_CLUSTER_POSITION:
         if (!seenClusterPositionForCurrentCuePoint) {
           // If there's more than one video/audio track, then there could be more than one
@@ -655,13 +654,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           cueClusterPositions.add(value);
           seenClusterPositionForCurrentCuePoint = true;
         }
-        return;
+        break;
       case ID_TIME_CODE:
         clusterTimecodeUs = scaleTimecodeToUs(value);
-        return;
+        break;
       case ID_BLOCK_DURATION:
         blockDurationUs = scaleTimecodeToUs(value);
-        return;
+        break;
       case ID_STEREO_MODE:
         int layout = (int) value;
         switch (layout) {
@@ -677,9 +676,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           default:
             break;
         }
-        return;
+        break;
       default:
-        return;
+        break;
     }
   }
 
@@ -687,12 +686,12 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
     switch (id) {
       case ID_DURATION:
         durationTimecode = (long) value;
-        return;
+        break;
       case ID_SAMPLING_FREQUENCY:
         currentTrack.sampleRate = (int) value;
-        return;
+        break;
       default:
-        return;
+        break;
     }
   }
 
@@ -703,15 +702,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         if (!DOC_TYPE_WEBM.equals(value) && !DOC_TYPE_MATROSKA.equals(value)) {
           throw new ParserException("DocType " + value + " not supported");
         }
-        return;
+        break;
       case ID_CODEC_ID:
         currentTrack.codecId = value;
-        return;
+        break;
       case ID_LANGUAGE:
         currentTrack.language = value;
-        return;
+        break;
       default:
-        return;
+        break;
     }
   }
 
@@ -723,24 +722,24 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         input.readFully(seekEntryIdBytes.data, 4 - contentSize, contentSize);
         seekEntryIdBytes.setPosition(0);
         seekEntryId = (int) seekEntryIdBytes.readUnsignedInt();
-        return;
+        break;
       case ID_CODEC_PRIVATE:
         currentTrack.codecPrivate = new byte[contentSize];
         input.readFully(currentTrack.codecPrivate, 0, contentSize);
-        return;
+        break;
       case ID_PROJECTION_PRIVATE:
         currentTrack.projectionData = new byte[contentSize];
         input.readFully(currentTrack.projectionData, 0, contentSize);
-        return;
+        break;
       case ID_CONTENT_COMPRESSION_SETTINGS:
         // This extractor only supports header stripping, so the payload is the stripped bytes.
         currentTrack.sampleStrippedBytes = new byte[contentSize];
         input.readFully(currentTrack.sampleStrippedBytes, 0, contentSize);
-        return;
+        break;
       case ID_CONTENT_ENCRYPTION_KEY_ID:
         currentTrack.encryptionKeyId = new byte[contentSize];
         input.readFully(currentTrack.encryptionKeyId, 0, contentSize);
-        return;
+        break;
       case ID_SIMPLE_BLOCK:
       case ID_BLOCK:
         // Please refer to http://www.matroska.org/technical/specs/index.html#simpleblock_structure
@@ -873,7 +872,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           writeSampleData(input, track, blockLacingSampleSizes[0]);
         }
 
-        return;
+        break;
       default:
         throw new ParserException("Unexpected id: " + id);
     }
@@ -1218,6 +1217,7 @@ private static boolean isCodecSupported(String codecId) {
         || CODEC_ID_OPUS.equals(codecId)
         || CODEC_ID_VORBIS.equals(codecId)
         || CODEC_ID_AAC.equals(codecId)
+        || CODEC_ID_MP2.equals(codecId)
         || CODEC_ID_MP3.equals(codecId)
         || CODEC_ID_AC3.equals(codecId)
         || CODEC_ID_E_AC3.equals(codecId)
@@ -1403,9 +1403,13 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           mimeType = MimeTypes.AUDIO_AAC;
           initializationData = Collections.singletonList(codecPrivate);
           break;
+        case CODEC_ID_MP2:
+          mimeType = MimeTypes.AUDIO_MPEG_L2;
+          maxInputSize = MpegAudioHeader.MAX_FRAME_SIZE_BYTES;
+          break;
         case CODEC_ID_MP3:
           mimeType = MimeTypes.AUDIO_MPEG;
-          maxInputSize = MP3_MAX_INPUT_SIZE;
+          maxInputSize = MpegAudioHeader.MAX_FRAME_SIZE_BYTES;
           break;
         case CODEC_ID_AC3:
           mimeType = MimeTypes.AUDIO_AC3;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/Sniffer.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/Sniffer.java
index 3d3e677881..a3fde6d455 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/Sniffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/Sniffer.java
@@ -40,7 +40,7 @@ public Sniffer() {
   }
 
   /**
-   * @see Extractor#sniff
+   * @see com.google.android.exoplayer2.extractor.Extractor#sniff(ExtractorInput)
    */
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     long inputLength = input.getLength();
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Id3Util.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Id3Util.java
deleted file mode 100644
index 53f18df844..0000000000
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Id3Util.java
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.mp3;
-
-import android.util.Pair;
-import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
-import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-import java.nio.charset.Charset;
-
-/**
- * Utility for parsing ID3 version 2 metadata in MP3 files.
- */
-/* package */ final class Id3Util {
-
-  /**
-   * The maximum valid length for metadata in bytes.
-   */
-  private static final int MAXIMUM_METADATA_SIZE = 3 * 1024 * 1024;
-
-  private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
-  private static final Charset[] CHARSET_BY_ENCODING = new Charset[] {Charset.forName("ISO-8859-1"),
-      Charset.forName("UTF-16LE"), Charset.forName("UTF-16BE"), Charset.forName("UTF-8")};
-
-  /**
-   * Peeks data from the input and parses ID3 metadata.
-   *
-   * @param input The {@link ExtractorInput} from which data should be peeked.
-   * @param out The {@link GaplessInfoHolder} to populate.
-   * @throws IOException If an error occurred peeking from the input.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public static void parseId3(ExtractorInput input, GaplessInfoHolder out)
-      throws IOException, InterruptedException {
-    ParsableByteArray scratch = new ParsableByteArray(10);
-    int peekedId3Bytes = 0;
-    while (true) {
-      input.peekFully(scratch.data, 0, 10);
-      scratch.setPosition(0);
-      if (scratch.readUnsignedInt24() != ID3_TAG) {
-        break;
-      }
-
-      int majorVersion = scratch.readUnsignedByte();
-      int minorVersion = scratch.readUnsignedByte();
-      int flags = scratch.readUnsignedByte();
-      int length = scratch.readSynchSafeInt();
-      if (!out.hasGaplessInfo() && canParseMetadata(majorVersion, minorVersion, flags, length)) {
-        byte[] frame = new byte[length];
-        input.peekFully(frame, 0, length);
-        parseGaplessInfo(new ParsableByteArray(frame), majorVersion, flags, out);
-      } else {
-        input.advancePeekPosition(length);
-      }
-
-      peekedId3Bytes += 10 + length;
-    }
-    input.resetPeekPosition();
-    input.advancePeekPosition(peekedId3Bytes);
-  }
-
-  private static boolean canParseMetadata(int majorVersion, int minorVersion, int flags,
-      int length) {
-    return minorVersion != 0xFF && majorVersion >= 2 && majorVersion <= 4
-        && length <= MAXIMUM_METADATA_SIZE
-        && !(majorVersion == 2 && ((flags & 0x3F) != 0 || (flags & 0x40) != 0))
-        && !(majorVersion == 3 && (flags & 0x1F) != 0)
-        && !(majorVersion == 4 && (flags & 0x0F) != 0);
-  }
-
-  private static void parseGaplessInfo(ParsableByteArray frame, int version, int flags,
-      GaplessInfoHolder out) {
-    unescape(frame, version, flags);
-
-    // Skip any extended header.
-    frame.setPosition(0);
-    if (version == 3 && (flags & 0x40) != 0) {
-      if (frame.bytesLeft() < 4) {
-        return;
-      }
-      int extendedHeaderSize = frame.readUnsignedIntToInt();
-      if (extendedHeaderSize > frame.bytesLeft()) {
-        return;
-      }
-      int paddingSize;
-      if (extendedHeaderSize >= 6) {
-        frame.skipBytes(2); // extended flags
-        paddingSize = frame.readUnsignedIntToInt();
-        frame.setPosition(4);
-        frame.setLimit(frame.limit() - paddingSize);
-        if (frame.bytesLeft() < extendedHeaderSize) {
-          return;
-        }
-      }
-      frame.skipBytes(extendedHeaderSize);
-    } else if (version == 4 && (flags & 0x40) != 0) {
-      if (frame.bytesLeft() < 4) {
-        return;
-      }
-      int extendedHeaderSize = frame.readSynchSafeInt();
-      if (extendedHeaderSize < 6 || extendedHeaderSize > frame.bytesLeft() + 4) {
-        return;
-      }
-      frame.setPosition(extendedHeaderSize);
-    }
-
-    // Extract gapless playback metadata stored in comments.
-    Pair<String, String> comment;
-    while ((comment = findNextComment(version, frame)) != null) {
-      if (comment.first.length() > 3) {
-        if (out.setFromComment(comment.first.substring(3), comment.second)) {
-          break;
-        }
-      }
-    }
-  }
-
-  private static Pair<String, String> findNextComment(int majorVersion, ParsableByteArray data) {
-    int frameSize;
-    while (true) {
-      if (majorVersion == 2) {
-        if (data.bytesLeft() < 6) {
-          return null;
-        }
-        String id = data.readString(3, Charset.forName("US-ASCII"));
-        if (id.equals("\0\0\0")) {
-          return null;
-        }
-        frameSize = data.readUnsignedInt24();
-        if (frameSize == 0 || frameSize > data.bytesLeft()) {
-          return null;
-        }
-        if (id.equals("COM")) {
-          break;
-        }
-      } else /* major == 3 || major == 4 */ {
-        if (data.bytesLeft() < 10) {
-          return null;
-        }
-        String id = data.readString(4, Charset.forName("US-ASCII"));
-        if (id.equals("\0\0\0\0")) {
-          return null;
-        }
-        frameSize = majorVersion == 4 ? data.readSynchSafeInt() : data.readUnsignedIntToInt();
-        if (frameSize == 0 || frameSize > data.bytesLeft() - 2) {
-          return null;
-        }
-        int flags = data.readUnsignedShort();
-        boolean compressedOrEncrypted = (majorVersion == 4 && (flags & 0x0C) != 0)
-            || (majorVersion == 3 && (flags & 0xC0) != 0);
-        if (!compressedOrEncrypted && id.equals("COMM")) {
-          break;
-        }
-      }
-      data.skipBytes(frameSize);
-    }
-
-    // The comment tag is at the reading position in data.
-    int encoding = data.readUnsignedByte();
-    if (encoding < 0 || encoding >= CHARSET_BY_ENCODING.length) {
-      return null;
-    }
-    Charset charset = CHARSET_BY_ENCODING[encoding];
-    String[] commentFields = data.readString(frameSize - 1, charset).split("\0");
-    return commentFields.length == 2 ? Pair.create(commentFields[0], commentFields[1]) : null;
-  }
-
-  private static boolean unescape(ParsableByteArray frame, int version, int flags) {
-    if (version != 4) {
-      if ((flags & 0x80) != 0) {
-        // Remove unsynchronization on ID3 version < 2.4.0.
-        byte[] bytes = frame.data;
-        int newLength = bytes.length;
-        for (int i = 0; i + 1 < newLength; i++) {
-          if ((bytes[i] & 0xFF) == 0xFF && bytes[i + 1] == 0x00) {
-            System.arraycopy(bytes, i + 2, bytes, i + 1, newLength - i - 2);
-            newLength--;
-          }
-        }
-        frame.setLimit(newLength);
-      }
-    } else {
-      // Remove unsynchronization on ID3 version 2.4.0.
-      if (canUnescapeVersion4(frame, false)) {
-        unescapeVersion4(frame, false);
-      } else if (canUnescapeVersion4(frame, true)) {
-        unescapeVersion4(frame, true);
-      } else {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private static boolean canUnescapeVersion4(ParsableByteArray frame,
-      boolean unsignedIntDataSizeHack) {
-    frame.setPosition(0);
-    while (frame.bytesLeft() >= 10) {
-      if (frame.readInt() == 0) {
-        return true;
-      }
-      long dataSize = frame.readUnsignedInt();
-      if (!unsignedIntDataSizeHack) {
-        // Parse the data size as a syncsafe integer.
-        if ((dataSize & 0x808080L) != 0) {
-          return false;
-        }
-        dataSize = (dataSize & 0x7F) | (((dataSize >> 8) & 0x7F) << 7)
-            | (((dataSize >> 16) & 0x7F) << 14) | (((dataSize >> 24) & 0x7F) << 21);
-      }
-      if (dataSize > frame.bytesLeft() - 2) {
-        return false;
-      }
-      int flags = frame.readUnsignedShort();
-      if ((flags & 1) != 0) {
-        if (frame.bytesLeft() < 4) {
-          return false;
-        }
-      }
-      frame.skipBytes((int) dataSize);
-    }
-    return true;
-  }
-
-  private static void unescapeVersion4(ParsableByteArray frame, boolean unsignedIntDataSizeHack) {
-    frame.setPosition(0);
-    byte[] bytes = frame.data;
-    while (frame.bytesLeft() >= 10) {
-      if (frame.readInt() == 0) {
-        return;
-      }
-      int dataSize =
-          unsignedIntDataSizeHack ? frame.readUnsignedIntToInt() : frame.readSynchSafeInt();
-      int flags = frame.readUnsignedShort();
-      int previousFlags = flags;
-      if ((flags & 1) != 0) {
-        // Strip data length indicator.
-        int offset = frame.getPosition();
-        System.arraycopy(bytes, offset + 4, bytes, offset, frame.bytesLeft() - 4);
-        dataSize -= 4;
-        flags &= ~1;
-        frame.setLimit(frame.limit() - 4);
-      }
-      if ((flags & 2) != 0) {
-        // Unescape 0xFF00 to 0xFF in the next dataSize bytes.
-        int readOffset = frame.getPosition() + 1;
-        int writeOffset = readOffset;
-        for (int i = 0; i + 1 < dataSize; i++) {
-          if ((bytes[readOffset - 1] & 0xFF) == 0xFF && bytes[readOffset] == 0) {
-            readOffset++;
-            dataSize--;
-          }
-          bytes[writeOffset++] = bytes[readOffset++];
-        }
-        frame.setLimit(frame.limit() - (readOffset - writeOffset));
-        System.arraycopy(bytes, readOffset, bytes, writeOffset, frame.bytesLeft() - readOffset);
-        flags &= ~2;
-      }
-      if (flags != previousFlags || unsignedIntDataSizeHack) {
-        int dataSizeOffset = frame.getPosition() - 6;
-        writeSyncSafeInteger(bytes, dataSizeOffset, dataSize);
-        bytes[dataSizeOffset + 4] = (byte) (flags >> 8);
-        bytes[dataSizeOffset + 5] = (byte) (flags & 0xFF);
-      }
-      frame.skipBytes(dataSize);
-    }
-  }
-
-  private static void writeSyncSafeInteger(byte[] bytes, int offset, int value) {
-    bytes[offset] = (byte) ((value >> 21) & 0x7F);
-    bytes[offset + 1] = (byte) ((value >> 14) & 0x7F);
-    bytes[offset + 2] = (byte) ((value >> 7) & 0x7F);
-    bytes[offset + 3] = (byte) (value & 0x7F);
-  }
-
-  private Id3Util() {}
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index ab501af1cb..9bdefeceaf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -27,6 +27,8 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
@@ -57,6 +59,10 @@
    * The maximum number of bytes to peek when sniffing, excluding the ID3 header, before giving up.
    */
   private static final int MAX_SNIFF_BYTES = MpegAudioHeader.MAX_FRAME_SIZE_BYTES;
+  /**
+   * Maximum length of data read into {@link #scratch}.
+   */
+  private static final int SCRATCH_LENGTH = 10;
 
   /**
    * Mask that includes the audio header values that must match between frames.
@@ -77,6 +83,7 @@
 
   private int synchronizedHeaderData;
 
+  private Metadata metadata;
   private Seeker seeker;
   private long basisTimeUs;
   private long samplesRead;
@@ -97,7 +104,7 @@ public Mp3Extractor() {
    */
   public Mp3Extractor(long forcedFirstSampleTimestampUs) {
     this.forcedFirstSampleTimestampUs = forcedFirstSampleTimestampUs;
-    scratch = new ParsableByteArray(4);
+    scratch = new ParsableByteArray(SCRATCH_LENGTH);
     synchronizedHeader = new MpegAudioHeader();
     gaplessInfoHolder = new GaplessInfoHolder();
     basisTimeUs = C.TIME_UNSET;
@@ -116,7 +123,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     synchronizedHeaderData = 0;
     basisTimeUs = C.TIME_UNSET;
     samplesRead = 0;
@@ -144,7 +151,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       trackOutput.format(Format.createAudioSampleFormat(null, synchronizedHeader.mimeType, null,
           Format.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, synchronizedHeader.channels,
           synchronizedHeader.sampleRate, Format.NO_VALUE, gaplessInfoHolder.encoderDelay,
-          gaplessInfoHolder.encoderPadding, null, null, 0, null));
+          gaplessInfoHolder.encoderPadding, null, null, 0, null, metadata));
     }
     return readSample(input);
   }
@@ -199,7 +206,7 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     int searchLimitBytes = sniffing ? MAX_SNIFF_BYTES : MAX_SYNC_BYTES;
     input.resetPeekPosition();
     if (input.getPosition() == 0) {
-      Id3Util.parseId3(input, gaplessInfoHolder);
+      peekId3Data(input);
       peekedId3Bytes = (int) input.getPeekPosition();
       if (!sniffing) {
         input.skipFully(peekedId3Bytes);
@@ -253,6 +260,45 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     return true;
   }
 
+  /**
+   * Peeks ID3 data from the input, including gapless playback information.
+   *
+   * @param input The {@link ExtractorInput} from which data should be peeked.
+   * @throws IOException If an error occurred peeking from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private void peekId3Data(ExtractorInput input) throws IOException, InterruptedException {
+    int peekedId3Bytes = 0;
+    while (true) {
+      input.peekFully(scratch.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+      scratch.setPosition(0);
+      if (scratch.readUnsignedInt24() != Id3Decoder.ID3_TAG) {
+        // Not an ID3 tag.
+        break;
+      }
+      scratch.skipBytes(3); // Skip major version, minor version and flags.
+      int framesLength = scratch.readSynchSafeInt();
+      int tagLength = Id3Decoder.ID3_HEADER_LENGTH + framesLength;
+
+      if (metadata == null) {
+        byte[] id3Data = new byte[tagLength];
+        System.arraycopy(scratch.data, 0, id3Data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+        input.peekFully(id3Data, Id3Decoder.ID3_HEADER_LENGTH, framesLength);
+        metadata = new Id3Decoder().decode(id3Data, tagLength);
+        if (metadata != null) {
+          gaplessInfoHolder.setFromMetadata(metadata);
+        }
+      } else {
+        input.advancePeekPosition(framesLength);
+      }
+
+      peekedId3Bytes += tagLength;
+    }
+
+    input.resetPeekPosition();
+    input.advancePeekPosition(peekedId3Bytes);
+  }
+
   /**
    * Returns a {@link Seeker} to seek using metadata read from {@code input}, which should provide
    * data from the start of the first frame in the stream. On returning, the input's position will
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index e93e9e3d9c..cc7e662336 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -52,6 +52,7 @@
   public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+  public static final int TYPE__mp3 = Util.getIntegerCodeForString(".mp3");
   public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
   public static final int TYPE_lpcm = Util.getIntegerCodeForString("lpcm");
   public static final int TYPE_sowt = Util.getIntegerCodeForString("sowt");
@@ -126,13 +127,15 @@
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
   public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
   public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
   public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
   public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
-  public static final int TYPE_DASHES = Util.getIntegerCodeForString("----");
+  public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
+  public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
 
   public final int type;
 
@@ -299,7 +302,7 @@ public static int parseFullAtomFlags(int fullAtomInt) {
    * @return The corresponding four character string.
    */
   public static String getAtomTypeString(int type) {
-    return "" + (char) (type >> 24)
+    return "" + (char) ((type >> 24) & 0xFF)
         + (char) ((type >> 16) & 0xFF)
         + (char) ((type >> 8) & 0xFF)
         + (char) (type & 0xFF);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 0b2d5ec330..5288a3e6ba 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -30,6 +31,7 @@
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.AvcConfig;
 import com.google.android.exoplayer2.video.HevcConfig;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -48,6 +50,7 @@
   private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
   private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
   private static final int TYPE_cenc = Util.getIntegerCodeForString("cenc");
+  private static final int TYPE_meta = Util.getIntegerCodeForString("meta");
 
   /**
    * Parses a trak atom (defined in 14496-12).
@@ -400,80 +403,54 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
    *
    * @param udtaAtom The udta (user data) atom to decode.
    * @param isQuickTime True for QuickTime media. False otherwise.
-   * @param out {@link GaplessInfoHolder} to populate with gapless playback information.
+   * @return Parsed metadata, or null.
    */
-  public static void parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime, GaplessInfoHolder out) {
+  public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
     if (isQuickTime) {
       // Meta boxes are regular boxes rather than full boxes in QuickTime. For now, don't try and
       // decode one.
-      return;
+      return null;
     }
     ParsableByteArray udtaData = udtaAtom.data;
     udtaData.setPosition(Atom.HEADER_SIZE);
     while (udtaData.bytesLeft() >= Atom.HEADER_SIZE) {
+      int atomPosition = udtaData.getPosition();
       int atomSize = udtaData.readInt();
       int atomType = udtaData.readInt();
       if (atomType == Atom.TYPE_meta) {
-        udtaData.setPosition(udtaData.getPosition() - Atom.HEADER_SIZE);
-        udtaData.setLimit(udtaData.getPosition() + atomSize);
-        parseMetaAtom(udtaData, out);
-        break;
+        udtaData.setPosition(atomPosition);
+        return parseMetaAtom(udtaData, atomPosition + atomSize);
       }
       udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
     }
+    return null;
   }
 
-  private static void parseMetaAtom(ParsableByteArray data, GaplessInfoHolder out) {
-    data.skipBytes(Atom.FULL_HEADER_SIZE);
-    ParsableByteArray ilst = new ParsableByteArray();
-    while (data.bytesLeft() >= Atom.HEADER_SIZE) {
-      int payloadSize = data.readInt() - Atom.HEADER_SIZE;
-      int atomType = data.readInt();
+  private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
+    meta.skipBytes(Atom.FULL_HEADER_SIZE);
+    while (meta.getPosition() < limit) {
+      int atomPosition = meta.getPosition();
+      int atomSize = meta.readInt();
+      int atomType = meta.readInt();
       if (atomType == Atom.TYPE_ilst) {
-        ilst.reset(data.data, data.getPosition() + payloadSize);
-        ilst.setPosition(data.getPosition());
-        parseIlst(ilst, out);
-        if (out.hasGaplessInfo()) {
-          return;
-        }
+        meta.setPosition(atomPosition);
+        return parseIlst(meta, atomPosition + atomSize);
       }
-      data.skipBytes(payloadSize);
+      meta.skipBytes(atomSize - Atom.HEADER_SIZE);
     }
+    return null;
   }
 
-  private static void parseIlst(ParsableByteArray ilst, GaplessInfoHolder out) {
-    while (ilst.bytesLeft() > 0) {
-      int position = ilst.getPosition();
-      int endPosition = position + ilst.readInt();
-      int type = ilst.readInt();
-      if (type == Atom.TYPE_DASHES) {
-        String lastCommentMean = null;
-        String lastCommentName = null;
-        String lastCommentData = null;
-        while (ilst.getPosition() < endPosition) {
-          int length = ilst.readInt() - Atom.FULL_HEADER_SIZE;
-          int key = ilst.readInt();
-          ilst.skipBytes(4);
-          if (key == Atom.TYPE_mean) {
-            lastCommentMean = ilst.readString(length);
-          } else if (key == Atom.TYPE_name) {
-            lastCommentName = ilst.readString(length);
-          } else if (key == Atom.TYPE_data) {
-            ilst.skipBytes(4);
-            lastCommentData = ilst.readString(length - 4);
-          } else {
-            ilst.skipBytes(length);
-          }
-        }
-        if (lastCommentName != null && lastCommentData != null
-            && "com.apple.iTunes".equals(lastCommentMean)) {
-          out.setFromComment(lastCommentName, lastCommentData);
-          break;
-        }
-      } else {
-        ilst.setPosition(endPosition);
+  private static Metadata parseIlst(ParsableByteArray ilst, int limit) {
+    ilst.skipBytes(Atom.HEADER_SIZE);
+    ArrayList<Metadata.Entry> entries = new ArrayList<>();
+    while (ilst.getPosition() < limit) {
+      Metadata.Entry entry = MetadataUtil.parseIlstElement(ilst);
+      if (entry != null) {
+        entries.add(entry);
       }
     }
+    return entries.isEmpty() ? null : new Metadata(entries);
   }
 
   /**
@@ -484,12 +461,9 @@ private static void parseIlst(ParsableByteArray ilst, GaplessInfoHolder out) {
    */
   private static long parseMvhd(ParsableByteArray mvhd) {
     mvhd.setPosition(Atom.HEADER_SIZE);
-
     int fullAtom = mvhd.readInt();
     int version = Atom.parseFullAtomVersion(fullAtom);
-
     mvhd.skipBytes(version == 0 ? 8 : 16);
-
     return mvhd.readUnsignedInt();
   }
 
@@ -568,6 +542,8 @@ private static int parseHdlr(ParsableByteArray hdlr) {
     } else if (trackType == TYPE_text || trackType == TYPE_sbtl || trackType == TYPE_subt
         || trackType == TYPE_clcp) {
       return C.TRACK_TYPE_TEXT;
+    } else if (trackType == TYPE_meta) {
+      return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
     }
@@ -627,7 +603,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
           || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
           || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
-          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt) {
+          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
+          || childAtomType == Atom.TYPE__mp3 || childAtomType == Atom.TYPE_alac) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             language, isQuickTime, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
@@ -644,9 +621,13 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
             MimeTypes.APPLICATION_TTML, null, Format.NO_VALUE, 0, language, drmInitData,
             0 /* subsample timing is absolute */);
       } else if (childAtomType == Atom.TYPE_c608) {
+        // Defined by the QuickTime File Format specification.
         out.format = Format.createTextSampleFormat(Integer.toString(trackId),
-            MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE, 0, language, drmInitData);
+            MimeTypes.APPLICATION_MP4CEA608, null, Format.NO_VALUE, 0, language, drmInitData);
         out.requiredSampleTransformation = Track.TRANSFORMATION_CEA608_CDAT;
+      } else if (childAtomType == Atom.TYPE_camm) {
+        out.format = Format.createSampleFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_CAMERA_MOTION, null, Format.NO_VALUE, drmInitData);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
@@ -856,6 +837,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_AMR_WB;
     } else if (atomType == Atom.TYPE_lpcm || atomType == Atom.TYPE_sowt) {
       mimeType = MimeTypes.AUDIO_RAW;
+    } else if (atomType == Atom.TYPE__mp3) {
+      mimeType = MimeTypes.AUDIO_MPEG;
+    } else if (atomType == Atom.TYPE_alac) {
+      mimeType = MimeTypes.AUDIO_ALAC;
     }
 
     byte[] initializationData = null;
@@ -893,6 +878,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
             language);
+      } else if (childAtomType == Atom.TYPE_alac) {
+        initializationData = new byte[childAtomSize];
+        parent.setPosition(childPosition);
+        parent.readBytes(initializationData, 0, childAtomSize);
       }
       childPosition += childAtomSize;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 9966125c46..f7cc42c48f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
@@ -30,20 +31,22 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Stack;
 import java.util.UUID;
@@ -65,15 +68,13 @@
 
   };
 
-  private static final String TAG = "FragmentedMp4Extractor";
-  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
-
   /**
    * Flags controlling the behavior of the extractor.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
-      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_SIDELOADED})
+      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_ENABLE_CEA608_TRACK,
+      FLAG_SIDELOADED})
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -87,12 +88,25 @@
    * Flag to ignore any tfdt boxes in the stream.
    */
   public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
+  /**
+   * Flag to indicate that the extractor should output an event message metadata track. Any event
+   * messages in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_EMSG_TRACK = 4;
+  /**
+   * Flag to indicate that the extractor should output a CEA-608 text track. Any CEA-608 messages
+   * contained within SEI NAL units in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_CEA608_TRACK = 8;
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
    */
-  private static final int FLAG_SIDELOADED = 4;
+  private static final int FLAG_SIDELOADED = 16;
 
+  private static final String TAG = "FragmentedMp4Extractor";
+  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
+  private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
 
@@ -114,6 +128,7 @@
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalLength;
+  private final ParsableByteArray nalPayload;
   private final ParsableByteArray encryptionSignalByte;
 
   // Adjusts sample timestamps.
@@ -123,6 +138,7 @@
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
+  private final LinkedList<MetadataSampleInfo> pendingMetadataSampleInfos;
 
   private int parserState;
   private int atomType;
@@ -130,8 +146,10 @@
   private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
   private long endOfMdatPosition;
+  private int pendingMetadataSampleBytes;
 
   private long durationUs;
+  private long segmentIndexEarliestPresentationTimeUs;
   private TrackBundle currentTrackBundle;
   private int sampleSize;
   private int sampleBytesWritten;
@@ -139,6 +157,8 @@
 
   // Extractor output.
   private ExtractorOutput extractorOutput;
+  private TrackOutput eventMessageTrackOutput;
+  private TrackOutput cea608TrackOutput;
 
   // Whether extractorOutput.seekMap has been called.
   private boolean haveOutputSeekMap;
@@ -169,11 +189,14 @@ public FragmentedMp4Extractor(@Flags int flags, Track sideloadedTrack,
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
+    nalPayload = new ParsableByteArray(1);
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
+    pendingMetadataSampleInfos = new LinkedList<>();
     trackBundles = new SparseArray<>();
     durationUs = C.TIME_UNSET;
+    segmentIndexEarliestPresentationTimeUs = C.TIME_UNSET;
     enterReadingAtomHeaderState();
   }
 
@@ -189,16 +212,19 @@ public void init(ExtractorOutput output) {
       TrackBundle bundle = new TrackBundle(output.track(0));
       bundle.init(sideloadedTrack, new DefaultSampleValues(0, 0, 0, 0));
       trackBundles.put(0, bundle);
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     }
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     int trackCount = trackBundles.size();
     for (int i = 0; i < trackCount; i++) {
       trackBundles.valueAt(i).reset();
     }
+    pendingMetadataSampleInfos.clear();
+    pendingMetadataSampleBytes = 0;
     containerAtoms.clear();
     enterReadingAtomHeaderState();
   }
@@ -257,6 +283,10 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       atomSize = atomHeader.readUnsignedLongToLong();
     }
 
+    if (atomSize < atomHeaderBytesRead) {
+      throw new ParserException("Atom size less than header length (unsupported).");
+    }
+
     long atomPosition = input.getPosition() - atomHeaderBytesRead;
     if (atomType == Atom.TYPE_moof) {
       // The data positions may be updated when parsing the tfhd/trun.
@@ -332,9 +362,12 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) throws ParserExce
     if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(leaf);
     } else if (leaf.type == Atom.TYPE_sidx) {
-      ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
-      extractorOutput.seekMap(segmentIndex);
+      Pair<Long, ChunkIndex> result = parseSidx(leaf.data, inputPosition);
+      segmentIndexEarliestPresentationTimeUs = result.first;
+      extractorOutput.seekMap(result.second);
       haveOutputSeekMap = true;
+    } else if (leaf.type == Atom.TYPE_emsg) {
+      onEmsgLeafAtomRead(leaf.data);
     }
   }
 
@@ -387,18 +420,19 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       // We need to create the track bundles.
       for (int i = 0; i < trackCount; i++) {
         Track track = tracks.valueAt(i);
-        trackBundles.put(track.id, new TrackBundle(extractorOutput.track(i)));
+        TrackBundle trackBundle = new TrackBundle(extractorOutput.track(i));
+        trackBundle.init(track, defaultSampleValuesArray.get(track.id));
+        trackBundles.put(track.id, trackBundle);
         durationUs = Math.max(durationUs, track.durationUs);
       }
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     } else {
       Assertions.checkState(trackBundles.size() == trackCount);
-    }
-
-    // Initialization of tracks and default sample values.
-    for (int i = 0; i < trackCount; i++) {
-      Track track = tracks.valueAt(i);
-      trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      for (int i = 0; i < trackCount; i++) {
+        Track track = tracks.valueAt(i);
+        trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      }
     }
   }
 
@@ -413,6 +447,51 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
     }
   }
 
+  private void maybeInitExtraTracks() {
+    if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
+      eventMessageTrackOutput = extractorOutput.track(trackBundles.size());
+      eventMessageTrackOutput.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG,
+          Format.OFFSET_SAMPLE_RELATIVE));
+    }
+    if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutput == null) {
+      cea608TrackOutput = extractorOutput.track(trackBundles.size() + 1);
+      cea608TrackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608,
+          null, Format.NO_VALUE, 0, null, null));
+    }
+  }
+
+  /**
+   * Handles an emsg atom (defined in 23009-1).
+   */
+  private void onEmsgLeafAtomRead(ParsableByteArray atom) {
+    if (eventMessageTrackOutput == null) {
+      return;
+    }
+    // Parse the event's presentation time delta.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    atom.readNullTerminatedString(); // schemeIdUri
+    atom.readNullTerminatedString(); // value
+    long timescale = atom.readUnsignedInt();
+    long presentationTimeDeltaUs =
+        Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
+    // Output the sample data.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    int sampleSize = atom.bytesLeft();
+    eventMessageTrackOutput.sampleData(atom, sampleSize);
+    // Output the sample metadata.
+    if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
+      // We can output the sample metadata immediately.
+      eventMessageTrackOutput.sampleMetadata(
+          segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+    } else {
+      // We need the first sample timestamp in the segment before we can output the metadata.
+      pendingMetadataSampleInfos.addLast(
+          new MetadataSampleInfo(presentationTimeDeltaUs, sampleSize));
+      pendingMetadataSampleBytes += sampleSize;
+    }
+  }
+
   /**
    * Parses a trex atom (defined in 14496-12).
    */
@@ -624,7 +703,7 @@ private static TrackBundle parseTfhd(ParsableByteArray tfhd,
     DefaultSampleValues defaultSampleValues = trackBundle.defaultSampleValues;
     int defaultSampleDescriptionIndex =
         ((atomFlags & 0x02 /* default_sample_description_index_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
+            ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
     int defaultSampleDuration = ((atomFlags & 0x08 /* default_sample_duration_present */) != 0)
         ? tfhd.readUnsignedIntToInt() : defaultSampleValues.duration;
     int defaultSampleSize = ((atomFlags & 0x10 /* default_sample_size_present */) != 0)
@@ -828,8 +907,13 @@ private static void parseSgpd(ParsableByteArray sbgp, ParsableByteArray sgpd, Tr
 
   /**
    * Parses a sidx atom (defined in 14496-12).
+   *
+   * @param atom The atom data.
+   * @param inputPosition The input position of the first byte after the atom.
+   * @return A pair consisting of the earliest presentation time in microseconds, and the parsed
+   *     {@link ChunkIndex}.
    */
-  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
+  private static Pair<Long, ChunkIndex> parseSidx(ParsableByteArray atom, long inputPosition)
       throws ParserException {
     atom.setPosition(Atom.HEADER_SIZE);
     int fullAtom = atom.readInt();
@@ -846,6 +930,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       earliestPresentationTime = atom.readUnsignedLongToLong();
       offset += atom.readUnsignedLongToLong();
     }
+    long earliestPresentationTimeUs = Util.scaleLargeTimestamp(earliestPresentationTime,
+        C.MICROS_PER_SECOND, timescale);
 
     atom.skipBytes(2);
 
@@ -856,7 +942,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
     long[] timesUs = new long[referenceCount];
 
     long time = earliestPresentationTime;
-    long timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);
+    long timeUs = earliestPresentationTimeUs;
     for (int i = 0; i < referenceCount; i++) {
       int firstInt = atom.readInt();
 
@@ -880,7 +966,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       offset += sizes[i];
     }
 
-    return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
+    return Pair.create(earliestPresentationTimeUs,
+        new ChunkIndex(sizes, offsets, durationsUs, timesUs));
   }
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
@@ -942,13 +1029,9 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
         // We skip bytes preceding the next sample to read.
         int bytesToSkip = (int) (nextDataPosition - input.getPosition());
         if (bytesToSkip < 0) {
-          if (nextDataPosition == currentTrackBundle.fragment.atomPosition) {
-            // Assume the sample data must be contiguous in the mdat with no preceeding data.
-            Log.w(TAG, "Offset to sample data was missing.");
-            bytesToSkip = 0;
-          } else {
-            throw new ParserException("Offset to sample data was negative.");
-          }
+          // Assume the sample data must be contiguous in the mdat with no preceding data.
+          Log.w(TAG, "Ignoring negative offset to sample data.");
+          bytesToSkip = 0;
         }
         input.skipFully(bytesToSkip);
         this.currentTrackBundle = currentTrackBundle;
@@ -996,6 +1079,26 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           output.sampleData(nalStartCode, 4);
           sampleBytesWritten += 4;
           sampleSize += nalUnitLengthFieldLengthDiff;
+          if (cea608TrackOutput != null) {
+            byte[] nalPayloadData = nalPayload.data;
+            // Peek the NAL unit type byte.
+            input.peekFully(nalPayloadData, 0, 1);
+            if ((nalPayloadData[0] & 0x1F) == NAL_UNIT_TYPE_SEI) {
+              // Read the whole SEI NAL unit into nalWrapper, including the NAL unit type byte.
+              nalPayload.reset(sampleCurrentNalBytesRemaining);
+              input.readFully(nalPayloadData, 0, sampleCurrentNalBytesRemaining);
+              // Write the SEI unit straight to the output.
+              output.sampleData(nalPayload, sampleCurrentNalBytesRemaining);
+              sampleBytesWritten += sampleCurrentNalBytesRemaining;
+              sampleCurrentNalBytesRemaining = 0;
+              // Unescape and process the SEI unit.
+              int unescapedLength = NalUnitUtil.unescapeStream(nalPayloadData, nalPayload.limit());
+              nalPayload.setPosition(1); // Skip the NAL unit type byte.
+              nalPayload.setLimit(unescapedLength);
+              CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L, nalPayload,
+                  cea608TrackOutput);
+            }
+          }
         } else {
           // Write the payload of the NAL unit.
           int writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
@@ -1025,6 +1128,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     }
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
+    while (!pendingMetadataSampleInfos.isEmpty()) {
+      MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
+      pendingMetadataSampleBytes -= sampleInfo.size;
+      eventMessageTrackOutput.sampleMetadata(
+          sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
+    }
+
     currentTrackBundle.currentSampleIndex++;
     currentTrackBundle.currentSampleInTrackRun++;
     if (currentTrackBundle.currentSampleInTrackRun
@@ -1130,7 +1241,7 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
         || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid
         || atom == Atom.TYPE_sbgp || atom == Atom.TYPE_sgpd || atom == Atom.TYPE_elst
-        || atom == Atom.TYPE_mehd;
+        || atom == Atom.TYPE_mehd || atom == Atom.TYPE_emsg;
   }
 
   /** Returns whether the extractor should decode a container atom with type {@code atom}. */
@@ -1140,6 +1251,21 @@ private static boolean shouldParseContainerAtom(int atom) {
         || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex || atom == Atom.TYPE_edts;
   }
 
+  /**
+   * Holds data corresponding to a metadata sample.
+   */
+  private static final class MetadataSampleInfo {
+
+    public final long presentationTimeDeltaUs;
+    public final int size;
+
+    public MetadataSampleInfo(long presentationTimeDeltaUs, int size) {
+      this.presentationTimeDeltaUs = presentationTimeDeltaUs;
+      this.size = size;
+    }
+
+  }
+
   /**
    * Holds data corresponding to a single track.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
new file mode 100644
index 0000000000..fed1694925
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import android.util.Log;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.ApicFrame;
+import com.google.android.exoplayer2.metadata.id3.CommentFrame;
+import com.google.android.exoplayer2.metadata.id3.Id3Frame;
+import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Parses metadata items stored in ilst atoms.
+ */
+/* package */ final class MetadataUtil {
+
+  private static final String TAG = "MetadataUtil";
+
+  // Codes that start with the copyright character (omitted) and have equivalent ID3 frames.
+  private static final int SHORT_TYPE_NAME_1 = Util.getIntegerCodeForString("nam");
+  private static final int SHORT_TYPE_NAME_2 = Util.getIntegerCodeForString("trk");
+  private static final int SHORT_TYPE_COMMENT = Util.getIntegerCodeForString("cmt");
+  private static final int SHORT_TYPE_YEAR = Util.getIntegerCodeForString("day");
+  private static final int SHORT_TYPE_ARTIST = Util.getIntegerCodeForString("ART");
+  private static final int SHORT_TYPE_ENCODER = Util.getIntegerCodeForString("too");
+  private static final int SHORT_TYPE_ALBUM = Util.getIntegerCodeForString("alb");
+  private static final int SHORT_TYPE_COMPOSER_1 = Util.getIntegerCodeForString("com");
+  private static final int SHORT_TYPE_COMPOSER_2 = Util.getIntegerCodeForString("wrt");
+  private static final int SHORT_TYPE_LYRICS = Util.getIntegerCodeForString("lyr");
+  private static final int SHORT_TYPE_GENRE = Util.getIntegerCodeForString("gen");
+
+  // Codes that have equivalent ID3 frames.
+  private static final int TYPE_COVER_ART = Util.getIntegerCodeForString("covr");
+  private static final int TYPE_GENRE = Util.getIntegerCodeForString("gnre");
+  private static final int TYPE_GROUPING = Util.getIntegerCodeForString("grp");
+  private static final int TYPE_DISK_NUMBER = Util.getIntegerCodeForString("disk");
+  private static final int TYPE_TRACK_NUMBER = Util.getIntegerCodeForString("trkn");
+  private static final int TYPE_TEMPO = Util.getIntegerCodeForString("tmpo");
+  private static final int TYPE_COMPILATION = Util.getIntegerCodeForString("cpil");
+  private static final int TYPE_ALBUM_ARTIST = Util.getIntegerCodeForString("aART");
+  private static final int TYPE_SORT_TRACK_NAME = Util.getIntegerCodeForString("sonm");
+  private static final int TYPE_SORT_ALBUM = Util.getIntegerCodeForString("soal");
+  private static final int TYPE_SORT_ARTIST = Util.getIntegerCodeForString("soar");
+  private static final int TYPE_SORT_ALBUM_ARTIST = Util.getIntegerCodeForString("soaa");
+  private static final int TYPE_SORT_COMPOSER = Util.getIntegerCodeForString("soco");
+
+  // Types that do not have equivalent ID3 frames.
+  private static final int TYPE_RATING = Util.getIntegerCodeForString("rtng");
+  private static final int TYPE_GAPLESS_ALBUM = Util.getIntegerCodeForString("pgap");
+  private static final int TYPE_TV_SORT_SHOW = Util.getIntegerCodeForString("sosn");
+  private static final int TYPE_TV_SHOW = Util.getIntegerCodeForString("tvsh");
+
+  // Type for items that are intended for internal use by the player.
+  private static final int TYPE_INTERNAL = Util.getIntegerCodeForString("----");
+
+  // Standard genres.
+  private static final String[] STANDARD_GENRES = new String[] {
+      // These are the official ID3v1 genres.
+      "Blues", "Classic Rock", "Country", "Dance", "Disco", "Funk", "Grunge", "Hip-Hop", "Jazz",
+      "Metal", "New Age", "Oldies", "Other", "Pop", "R&B", "Rap", "Reggae", "Rock", "Techno",
+      "Industrial", "Alternative", "Ska", "Death Metal", "Pranks", "Soundtrack", "Euro-Techno",
+      "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Fusion", "Trance", "Classical", "Instrumental",
+      "Acid", "House", "Game", "Sound Clip", "Gospel", "Noise", "AlternRock", "Bass", "Soul",
+      "Punk", "Space", "Meditative", "Instrumental Pop", "Instrumental Rock", "Ethnic", "Gothic",
+      "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream",
+      "Southern Rock", "Comedy", "Cult", "Gangsta", "Top 40", "Christian Rap", "Pop/Funk", "Jungle",
+      "Native American", "Cabaret", "New Wave", "Psychadelic", "Rave", "Showtunes", "Trailer",
+      "Lo-Fi", "Tribal", "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll",
+      "Hard Rock",
+      // These were made up by the authors of Winamp and later added to the ID3 spec.
+      "Folk", "Folk-Rock", "National Folk", "Swing", "Fast Fusion", "Bebob", "Latin", "Revival",
+      "Celtic", "Bluegrass", "Avantgarde", "Gothic Rock", "Progressive Rock", "Psychedelic Rock",
+      "Symphonic Rock", "Slow Rock", "Big Band", "Chorus", "Easy Listening", "Acoustic", "Humour",
+      "Speech", "Chanson", "Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus",
+      "Porn Groove", "Satire", "Slow Jam", "Club", "Tango", "Samba", "Folklore", "Ballad",
+      "Power Ballad", "Rhythmic Soul", "Freestyle", "Duet", "Punk Rock", "Drum Solo", "A capella",
+      "Euro-House", "Dance Hall",
+      // These were med up by the authors of Winamp but have not been added to the ID3 spec.
+      "Goa", "Drum & Bass", "Club-House", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk",
+      "Polsk Punk", "Beat", "Christian Gangsta Rap", "Heavy Metal", "Black Metal", "Crossover",
+      "Contemporary Christian", "Christian Rock", "Merengue", "Salsa", "Thrash Metal", "Anime",
+      "Jpop", "Synthpop"
+  };
+
+  private static final String LANGUAGE_UNDEFINED = "und";
+
+  private MetadataUtil() {}
+
+  /**
+   * Parses a single ilst element from a {@link ParsableByteArray}. The element is read starting
+   * from the current position of the {@link ParsableByteArray}, and the position is advanced by
+   * the size of the element. The position is advanced even if the element's type is unrecognized.
+   *
+   * @param ilst Holds the data to be parsed.
+   * @return The parsed element, or null if the element's type was not recognized.
+   */
+  public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
+    int position = ilst.getPosition();
+    int endPosition = position + ilst.readInt();
+    int type = ilst.readInt();
+    int typeTopByte = (type >> 24) & 0xFF;
+    try {
+      if (typeTopByte == '\u00A9' /* Copyright char */
+          || typeTopByte == '\uFFFD' /* Replacement char */) {
+        int shortType = type & 0x00FFFFFF;
+        if (shortType == SHORT_TYPE_COMMENT) {
+          return parseCommentAttribute(type, ilst);
+        } else if (shortType == SHORT_TYPE_NAME_1 || shortType == SHORT_TYPE_NAME_2) {
+          return parseTextAttribute(type, "TIT2", ilst);
+        } else if (shortType == SHORT_TYPE_COMPOSER_1 || shortType == SHORT_TYPE_COMPOSER_2) {
+          return parseTextAttribute(type, "TCOM", ilst);
+        } else if (shortType == SHORT_TYPE_YEAR) {
+          return parseTextAttribute(type, "TDRC", ilst);
+        } else if (shortType == SHORT_TYPE_ARTIST) {
+          return parseTextAttribute(type, "TPE1", ilst);
+        } else if (shortType == SHORT_TYPE_ENCODER) {
+          return parseTextAttribute(type, "TSSE", ilst);
+        } else if (shortType == SHORT_TYPE_ALBUM) {
+          return parseTextAttribute(type, "TALB", ilst);
+        } else if (shortType == SHORT_TYPE_LYRICS) {
+          return parseTextAttribute(type, "USLT", ilst);
+        } else if (shortType == SHORT_TYPE_GENRE) {
+          return parseTextAttribute(type, "TCON", ilst);
+        } else if (shortType == TYPE_GROUPING) {
+          return parseTextAttribute(type, "TIT1", ilst);
+        }
+      } else if (type == TYPE_GENRE) {
+        return parseStandardGenreAttribute(ilst);
+      } else if (type == TYPE_DISK_NUMBER) {
+        return parseIndexAndCountAttribute(type, "TPOS", ilst);
+      } else if (type == TYPE_TRACK_NUMBER) {
+        return parseIndexAndCountAttribute(type, "TRCK", ilst);
+      } else if (type == TYPE_TEMPO) {
+        return parseUint8Attribute(type, "TBPM", ilst, true, false);
+      } else if (type == TYPE_COMPILATION) {
+        return parseUint8Attribute(type, "TCMP", ilst, true, true);
+      } else if (type == TYPE_COVER_ART) {
+        return parseCoverArt(ilst);
+      } else if (type == TYPE_ALBUM_ARTIST) {
+        return parseTextAttribute(type, "TPE2", ilst);
+      } else if (type == TYPE_SORT_TRACK_NAME) {
+        return parseTextAttribute(type, "TSOT", ilst);
+      } else if (type == TYPE_SORT_ALBUM) {
+        return parseTextAttribute(type, "TSO2", ilst);
+      } else if (type == TYPE_SORT_ARTIST) {
+        return parseTextAttribute(type, "TSOA", ilst);
+      } else if (type == TYPE_SORT_ALBUM_ARTIST) {
+        return parseTextAttribute(type, "TSOP", ilst);
+      } else if (type == TYPE_SORT_COMPOSER) {
+        return parseTextAttribute(type, "TSOC", ilst);
+      } else if (type == TYPE_RATING) {
+        return parseUint8Attribute(type, "ITUNESADVISORY", ilst, false, false);
+      } else if (type == TYPE_GAPLESS_ALBUM) {
+        return parseUint8Attribute(type, "ITUNESGAPLESS", ilst, false, true);
+      } else if (type == TYPE_TV_SORT_SHOW) {
+        return parseTextAttribute(type, "TVSHOWSORT", ilst);
+      } else if (type == TYPE_TV_SHOW) {
+        return parseTextAttribute(type, "TVSHOW", ilst);
+      } else if (type == TYPE_INTERNAL) {
+        return parseInternalAttribute(ilst, endPosition);
+      }
+      Log.d(TAG, "Skipped unknown metadata entry: " + Atom.getAtomTypeString(type));
+      return null;
+    } finally {
+      ilst.setPosition(endPosition);
+    }
+  }
+
+  private static TextInformationFrame parseTextAttribute(int type, String id,
+      ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      String value = data.readNullTerminatedString(atomSize - 16);
+      return new TextInformationFrame(id, null, value);
+    }
+    Log.w(TAG, "Failed to parse text attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      String value = data.readNullTerminatedString(atomSize - 16);
+      return new CommentFrame(LANGUAGE_UNDEFINED, value, value);
+    }
+    Log.w(TAG, "Failed to parse comment attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static Id3Frame parseUint8Attribute(int type, String id, ParsableByteArray data,
+      boolean isTextInformationFrame, boolean isBoolean) {
+    int value = parseUint8AttributeValue(data);
+    if (isBoolean) {
+      value = Math.min(1, value);
+    }
+    if (value >= 0) {
+      return isTextInformationFrame ? new TextInformationFrame(id, null, Integer.toString(value))
+          : new CommentFrame(LANGUAGE_UNDEFINED, id, Integer.toString(value));
+    }
+    Log.w(TAG, "Failed to parse uint8 attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static TextInformationFrame parseIndexAndCountAttribute(int type, String attributeName,
+      ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data && atomSize >= 22) {
+      data.skipBytes(10); // version (1), flags (3), empty (4), empty (2)
+      int index = data.readUnsignedShort();
+      if (index > 0) {
+        String value = "" + index;
+        int count = data.readUnsignedShort();
+        if (count > 0) {
+          value += "/" + count;
+        }
+        return new TextInformationFrame(attributeName, null, value);
+      }
+    }
+    Log.w(TAG, "Failed to parse index/count attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArray data) {
+    int genreCode = parseUint8AttributeValue(data);
+    String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
+        ? STANDARD_GENRES[genreCode - 1] : null;
+    if (genreString != null) {
+      return new TextInformationFrame("TCON", null, genreString);
+    }
+    Log.w(TAG, "Failed to parse standard genre code");
+    return null;
+  }
+
+  private static ApicFrame parseCoverArt(ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      int fullVersionInt = data.readInt();
+      int flags = Atom.parseFullAtomFlags(fullVersionInt);
+      String mimeType = flags == 13 ? "image/jpeg" : flags == 14 ? "image/png" : null;
+      if (mimeType == null) {
+        Log.w(TAG, "Unrecognized cover art flags: " + flags);
+        return null;
+      }
+      data.skipBytes(4); // empty (4)
+      byte[] pictureData = new byte[atomSize - 16];
+      data.readBytes(pictureData, 0, pictureData.length);
+      return new ApicFrame(mimeType, null, 3 /* Cover (front) */, pictureData);
+    }
+    Log.w(TAG, "Failed to parse cover art attribute");
+    return null;
+  }
+
+  private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPosition) {
+    String domain = null;
+    String name = null;
+    int dataAtomPosition = -1;
+    int dataAtomSize = -1;
+    while (data.getPosition() < endPosition) {
+      int atomPosition = data.getPosition();
+      int atomSize = data.readInt();
+      int atomType = data.readInt();
+      data.skipBytes(4); // version (1), flags (3)
+      if (atomType == Atom.TYPE_mean) {
+        domain = data.readNullTerminatedString(atomSize - 12);
+      } else if (atomType == Atom.TYPE_name) {
+        name = data.readNullTerminatedString(atomSize - 12);
+      } else {
+        if (atomType == Atom.TYPE_data) {
+          dataAtomPosition = atomPosition;
+          dataAtomSize = atomSize;
+        }
+        data.skipBytes(atomSize - 12);
+      }
+    }
+    if (!"com.apple.iTunes".equals(domain) || !"iTunSMPB".equals(name) || dataAtomPosition == -1) {
+      // We're only interested in iTunSMPB.
+      return null;
+    }
+    data.setPosition(dataAtomPosition);
+    data.skipBytes(16); // size (4), type (4), version (1), flags (3), empty (4)
+    String value = data.readNullTerminatedString(dataAtomSize - 16);
+    return new CommentFrame(LANGUAGE_UNDEFINED, name, value);
+  }
+
+  private static int parseUint8AttributeValue(ParsableByteArray data) {
+    data.skipBytes(4); // atomSize
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      return data.readUnsignedByte();
+    }
+    Log.w(TAG, "Failed to parse uint8 attribute value");
+    return -1;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 467ec7a4fa..3759a80fd4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -27,11 +28,14 @@
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Stack;
@@ -53,11 +57,15 @@
 
   };
 
-  // Parser states.
-  private static final int STATE_AFTER_SEEK = 0;
-  private static final int STATE_READING_ATOM_HEADER = 1;
-  private static final int STATE_READING_ATOM_PAYLOAD = 2;
-  private static final int STATE_READING_SAMPLE = 3;
+  /**
+   * Parser states.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STATE_READING_ATOM_HEADER, STATE_READING_ATOM_PAYLOAD, STATE_READING_SAMPLE})
+  private @interface State {}
+  private static final int STATE_READING_ATOM_HEADER = 0;
+  private static final int STATE_READING_ATOM_PAYLOAD = 1;
+  private static final int STATE_READING_SAMPLE = 2;
 
   // Brand stored in the ftyp atom for QuickTime media.
   private static final int BRAND_QUICKTIME = Util.getIntegerCodeForString("qt  ");
@@ -75,6 +83,7 @@
   private final ParsableByteArray atomHeader;
   private final Stack<ContainerAtom> containerAtoms;
 
+  @State
   private int parserState;
   private int atomType;
   private long atomSize;
@@ -95,7 +104,6 @@ public Mp4Extractor() {
     containerAtoms = new Stack<>();
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
-    enterReadingAtomHeaderState();
   }
 
   @Override
@@ -109,12 +117,16 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     containerAtoms.clear();
     atomHeaderBytesRead = 0;
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
-    parserState = STATE_AFTER_SEEK;
+    if (position == 0) {
+      enterReadingAtomHeaderState();
+    } else if (tracks != null) {
+      updateSampleIndices(timeUs);
+    }
   }
 
   @Override
@@ -127,13 +139,6 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
     while (true) {
       switch (parserState) {
-        case STATE_AFTER_SEEK:
-          if (input.getPosition() == 0) {
-            enterReadingAtomHeaderState();
-          } else {
-            parserState = STATE_READING_SAMPLE;
-          }
-          break;
         case STATE_READING_ATOM_HEADER:
           if (!readAtomHeader(input)) {
             return RESULT_END_OF_INPUT;
@@ -144,8 +149,10 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
             return RESULT_SEEK;
           }
           break;
-        default:
+        case STATE_READING_SAMPLE:
           return readSample(input, seekPosition);
+        default:
+          throw new IllegalStateException();
       }
     }
   }
@@ -172,8 +179,6 @@ public long getPosition(long timeUs) {
         // Handle the case where the requested time is before the first synchronization sample.
         sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
       }
-      track.sampleIndex = sampleIndex;
-
       long offset = sampleTable.offsets[sampleIndex];
       if (offset < earliestSamplePosition) {
         earliestSamplePosition = offset;
@@ -310,10 +315,14 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
 
+    Metadata metadata = null;
     GaplessInfoHolder gaplessInfoHolder = new GaplessInfoHolder();
     Atom.LeafAtom udta = moov.getLeafAtomOfType(Atom.TYPE_udta);
     if (udta != null) {
-      AtomParsers.parseUdta(udta, isQuickTime, gaplessInfoHolder);
+      metadata = AtomParsers.parseUdta(udta, isQuickTime);
+      if (metadata != null) {
+        gaplessInfoHolder.setFromMetadata(metadata);
+      }
     }
 
     for (int i = 0; i < moov.containerChildren.size(); i++) {
@@ -340,9 +349,14 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
       // Allow ten source samples per output sample, like the platform extractor.
       int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
       Format format = track.format.copyWithMaxInputSize(maxInputSize);
-      if (track.type == C.TRACK_TYPE_AUDIO && gaplessInfoHolder.hasGaplessInfo()) {
-        format = format.copyWithGaplessInfo(gaplessInfoHolder.encoderDelay,
-            gaplessInfoHolder.encoderPadding);
+      if (track.type == C.TRACK_TYPE_AUDIO) {
+        if (gaplessInfoHolder.hasGaplessInfo()) {
+          format = format.copyWithGaplessInfo(gaplessInfoHolder.encoderDelay,
+              gaplessInfoHolder.encoderPadding);
+        }
+        if (metadata != null) {
+          format = format.copyWithMetadata(metadata);
+        }
       }
       mp4Track.trackOutput.format(format);
 
@@ -468,6 +482,21 @@ private int getTrackIndexOfEarliestCurrentSample() {
     return earliestSampleTrackIndex;
   }
 
+  /**
+   * Updates every track's sample index to point its latest sync sample before/at {@code timeUs}.
+   */
+  private void updateSampleIndices(long timeUs) {
+    for (Mp4Track track : tracks) {
+      TrackSampleTable sampleTable = track.sampleTable;
+      int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+      if (sampleIndex == C.INDEX_UNSET) {
+        // Handle the case where the requested time is before the first synchronization sample.
+        sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+      }
+      track.sampleIndex = sampleIndex;
+    }
+  }
+
   /**
    * Returns whether the extractor should decode a leaf atom with type {@code atom}.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
index c6e5d46b8e..5470e2badc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
@@ -45,7 +45,6 @@
 
   private int state;
   private long totalGranules;
-  private volatile long queriedGranule;
   private long positionBeforeSeekToEnd;
   private long targetGranule;
 
@@ -59,13 +58,21 @@
    * @param startPosition Start position of the payload (inclusive).
    * @param endPosition End position of the payload (exclusive).
    * @param streamReader StreamReader instance which owns this OggSeeker
+   * @param firstPayloadPageSize The total size of the first payload page, in bytes.
+   * @param firstPayloadPageGranulePosition The granule position of the first payload page.
    */
-  public DefaultOggSeeker(long startPosition, long endPosition, StreamReader streamReader) {
+  public DefaultOggSeeker(long startPosition, long endPosition, StreamReader streamReader,
+      int firstPayloadPageSize, long firstPayloadPageGranulePosition) {
     Assertions.checkArgument(startPosition >= 0 && endPosition > startPosition);
     this.streamReader = streamReader;
     this.startPosition = startPosition;
     this.endPosition = endPosition;
-    this.state = STATE_SEEK_TO_END;
+    if (firstPayloadPageSize == endPosition - startPosition) {
+      totalGranules = firstPayloadPageGranulePosition;
+      state = STATE_IDLE;
+    } else {
+      state = STATE_SEEK_TO_END;
+    }
   }
 
   @Override
@@ -77,9 +84,9 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
         positionBeforeSeekToEnd = input.getPosition();
         state = STATE_READ_LAST_PAGE;
         // Seek to the end just before the last page of stream to get the duration.
-        long lastPagePosition = endPosition - OggPageHeader.MAX_PAGE_SIZE;
-        if (lastPagePosition > positionBeforeSeekToEnd) {
-          return lastPagePosition;
+        long lastPageSearchPosition = endPosition - OggPageHeader.MAX_PAGE_SIZE;
+        if (lastPageSearchPosition > positionBeforeSeekToEnd) {
+          return lastPageSearchPosition;
         }
         // Fall through.
       case STATE_READ_LAST_PAGE:
@@ -106,9 +113,9 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
   }
 
   @Override
-  public long startSeek() {
+  public long startSeek(long timeUs) {
     Assertions.checkArgument(state == STATE_IDLE || state == STATE_SEEK);
-    targetGranule = queriedGranule;
+    targetGranule = timeUs == 0 ? 0 : streamReader.convertTimeToGranule(timeUs);
     state = STATE_SEEK;
     resetSeeking();
     return targetGranule;
@@ -214,11 +221,10 @@ public boolean isSeekable() {
     @Override
     public long getPosition(long timeUs) {
       if (timeUs == 0) {
-        queriedGranule = 0;
         return startPosition;
       }
-      queriedGranule = streamReader.convertTimeToGranule(timeUs);
-      return getEstimatedPosition(startPosition, queriedGranule, DEFAULT_OFFSET);
+      long granule = streamReader.convertTimeToGranule(timeUs);
+      return getEstimatedPosition(startPosition, granule, DEFAULT_OFFSET);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
index 0353933982..f4da6e3960 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
@@ -127,12 +127,15 @@ private int getFlacFrameBlockSize(ParsableByteArray packet) {
     private static final int METADATA_LENGTH_OFFSET = 1;
     private static final int SEEK_POINT_SIZE = 18;
 
-    private long[] sampleNumbers;
-    private long[] offsets;
-    private long firstFrameOffset = -1;
-    private volatile long queriedGranule;
-    private volatile long seekedGranule;
-    private long currentGranule = -1;
+    private long[] seekPointGranules;
+    private long[] seekPointOffsets;
+    private long firstFrameOffset;
+    private long pendingSeekGranule;
+
+    public FlacOggSeeker() {
+      firstFrameOffset = -1;
+      pendingSeekGranule = -1;
+    }
 
     public void setFirstFrameOffset(long firstFrameOffset) {
       this.firstFrameOffset = firstFrameOffset;
@@ -141,40 +144,40 @@ public void setFirstFrameOffset(long firstFrameOffset) {
     /**
      * Parses a FLAC file seek table metadata structure and initializes internal fields.
      *
-     * @param data
-     *     A ParsableByteArray including whole seek table metadata block. Its position should be set
-     *     to the beginning of the block.
+     * @param data A {@link ParsableByteArray} including whole seek table metadata block. Its
+     *     position should be set to the beginning of the block.
      * @see <a href="https://xiph.org/flac/format.html#metadata_block_seektable">FLAC format
-     * METADATA_BLOCK_SEEKTABLE</a>
+     *     METADATA_BLOCK_SEEKTABLE</a>
      */
     public void parseSeekTable(ParsableByteArray data) {
       data.skipBytes(METADATA_LENGTH_OFFSET);
       int length = data.readUnsignedInt24();
       int numberOfSeekPoints = length / SEEK_POINT_SIZE;
-
-      sampleNumbers = new long[numberOfSeekPoints];
-      offsets = new long[numberOfSeekPoints];
-
+      seekPointGranules = new long[numberOfSeekPoints];
+      seekPointOffsets = new long[numberOfSeekPoints];
       for (int i = 0; i < numberOfSeekPoints; i++) {
-        sampleNumbers[i] = data.readLong();
-        offsets[i] = data.readLong();
+        seekPointGranules[i] = data.readLong();
+        seekPointOffsets[i] = data.readLong();
         data.skipBytes(2); // Skip "Number of samples in the target frame."
       }
     }
 
     @Override
     public long read(ExtractorInput input) throws IOException, InterruptedException {
-      if (currentGranule >= 0) {
-        currentGranule = -currentGranule - 2;
-        return currentGranule;
+      if (pendingSeekGranule >= 0) {
+        long result = -(pendingSeekGranule + 2);
+        pendingSeekGranule = -1;
+        return result;
       }
       return -1;
     }
 
     @Override
-    public synchronized long startSeek() {
-      currentGranule = seekedGranule;
-      return queriedGranule;
+    public long startSeek(long timeUs) {
+      long granule = convertTimeToGranule(timeUs);
+      int index = Util.binarySearchFloor(seekPointGranules, granule, true, true);
+      pendingSeekGranule = seekPointGranules[index];
+      return granule;
     }
 
     @Override
@@ -188,11 +191,10 @@ public boolean isSeekable() {
     }
 
     @Override
-    public synchronized long getPosition(long timeUs) {
-      queriedGranule = convertTimeToGranule(timeUs);
-      int index = Util.binarySearchFloor(sampleNumbers, queriedGranule, true, true);
-      seekedGranule = sampleNumbers[index];
-      return firstFrameOffset + offsets[index];
+    public long getPosition(long timeUs) {
+      long granule = convertTimeToGranule(timeUs);
+      int index = Util.binarySearchFloor(seekPointGranules, granule, true, true);
+      return firstFrameOffset + seekPointOffsets[index];
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
index 116dedf1ce..5f41126737 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
@@ -82,8 +82,8 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
-    streamReader.seek(position);
+  public void seek(long position, long timeUs) {
+    streamReader.seek(position, timeUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
index efe6ed0fdf..aa88e5bf89 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggSeeker.java
@@ -35,9 +35,10 @@
   /**
    * Initializes a seek operation.
    *
+   * @param timeUs The seek position in microseconds.
    * @return The granule position targeted by the seek.
    */
-  long startSeek();
+  long startSeek(long timeUs);
 
   /**
    * Reads data from the {@link ExtractorInput} to build the {@link SeekMap} or to continue a
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
index 108743c764..8ed8a4a01d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OpusReader.java
@@ -81,7 +81,7 @@ protected boolean readHeaders(ParsableByteArray packet, long position, SetupData
 
       setupData.format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_OPUS, null,
           Format.NO_VALUE, Format.NO_VALUE, channelCount, SAMPLE_RATE, initializationData, null, 0,
-          "und");
+          null);
       headerRead = true;
     } else {
       boolean headerPacket = packet.readInt() == OPUS_CODE;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
index aa3f8e2353..6424155bd9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java
@@ -81,15 +81,15 @@ protected void reset(boolean headerData) {
   }
 
   /**
-   * @see Extractor#seek(long)
+   * @see Extractor#seek(long, long)
    */
-  final void seek(long position) {
+  final void seek(long position, long timeUs) {
     oggPacket.reset();
     if (position == 0) {
       reset(!seekMapSet);
     } else {
       if (state != STATE_READ_HEADERS) {
-        targetGranule = oggSeeker.startSeek();
+        targetGranule = oggSeeker.startSeek(timeUs);
         state = STATE_READ_PAYLOAD;
       }
     }
@@ -144,7 +144,10 @@ private int readHeaders(ExtractorInput input) throws IOException, InterruptedExc
     } else if (input.getLength() == C.LENGTH_UNSET) {
       oggSeeker = new UnseekableOggSeeker();
     } else {
-      oggSeeker = new DefaultOggSeeker(payloadStartPosition, input.getLength(), this);
+      OggPageHeader firstPayloadPageHeader = oggPacket.getPageHeader();
+      oggSeeker = new DefaultOggSeeker(payloadStartPosition, input.getLength(), this,
+          firstPayloadPageHeader.headerSize + firstPayloadPageHeader.bodySize,
+          firstPayloadPageHeader.granulePosition);
     }
 
     setupData = null;
@@ -159,7 +162,7 @@ private int readPayload(ExtractorInput input, PositionHolder seekPosition)
       seekPosition.position = position;
       return Extractor.RESULT_SEEK;
     } else if (position < -1) {
-      onSeekEnd(-position - 2);
+      onSeekEnd(-(position + 2));
     }
     if (!seekMapSet) {
       SeekMap seekMap = oggSeeker.createSeekMap();
@@ -229,7 +232,7 @@ protected abstract boolean readHeaders(ParsableByteArray packet, long position,
   /**
    * Called on end of seeking.
    *
-   * @param currentGranule Current granule at the current position of input.
+   * @param currentGranule The granule at the current input position.
    */
   protected void onSeekEnd(long currentGranule) {
     this.currentGranule = currentGranule;
@@ -243,7 +246,7 @@ public long read(ExtractorInput input) throws IOException, InterruptedException
     }
 
     @Override
-    public long startSeek() {
+    public long startSeek(long timeUs) {
       return 0;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java
index c6c9efc0f7..ae52e80299 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java
@@ -26,7 +26,7 @@
 /* package */ final class VorbisBitArray {
 
   public final byte[] data;
-  private int limit;
+  private final int limit;
   private int byteOffset;
   private int bitOffset;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
index ea9458a657..f9957aebe5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
@@ -24,7 +24,6 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -45,9 +44,10 @@
   private static final int STATE_READING_TIMESTAMP_AND_COUNT = 1;
   private static final int STATE_READING_SAMPLES = 2;
 
+  private final Format format;
+
   private final ParsableByteArray dataScratch;
 
-  private ExtractorOutput extractorOutput;
   private TrackOutput trackOutput;
 
   private int parserState;
@@ -56,20 +56,18 @@
   private int remainingSampleCount;
   private int sampleBytesWritten;
 
-  public RawCcExtractor() {
+  public RawCcExtractor(Format format) {
+    this.format = format;
     dataScratch = new ParsableByteArray(SCRATCH_SIZE);
     parserState = STATE_READING_HEADER;
   }
 
   @Override
   public void init(ExtractorOutput output) {
-    this.extractorOutput = output;
-    extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
-    trackOutput = extractorOutput.track(0);
-    extractorOutput.endTracks();
-
-    trackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608,
-        null, Format.NO_VALUE, 0, null, null));
+    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+    trackOutput = output.track(0);
+    output.endTracks();
+    trackOutput.format(format);
   }
 
   @Override
@@ -85,8 +83,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     while (true) {
       switch (parserState) {
         case STATE_READING_HEADER:
-          parseHeader(input);
-          parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          if (parseHeader(input)) {
+            parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          } else {
+            return RESULT_END_OF_INPUT;
+          }
           break;
         case STATE_READING_TIMESTAMP_AND_COUNT:
           if (parseTimestampAndSampleCount(input)) {
@@ -107,7 +108,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     parserState = STATE_READING_HEADER;
   }
 
@@ -116,14 +117,18 @@ public void release() {
     // Do nothing
   }
 
-  private void parseHeader(ExtractorInput input) throws IOException, InterruptedException {
+  private boolean parseHeader(ExtractorInput input) throws IOException, InterruptedException {
     dataScratch.reset();
-    input.readFully(dataScratch.data, 0, HEADER_SIZE);
-    if (dataScratch.readInt() != HEADER_ID) {
-      throw new IOException("Input not RawCC");
+    if (input.readFully(dataScratch.data, 0, HEADER_SIZE, true)) {
+      if (dataScratch.readInt() != HEADER_ID) {
+        throw new IOException("Input not RawCC");
+      }
+      version = dataScratch.readUnsignedByte();
+      // no versions use the flag fields yet
+      return true;
+    } else {
+      return false;
     }
-    version = dataScratch.readUnsignedByte();
-    // no versions use the flag fields yet
   }
 
   private boolean parseTimestampAndSampleCount(ExtractorInput input) throws IOException,
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 7fc8b429a8..e714928c20 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -23,7 +23,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -119,13 +119,13 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     reader = new Ac3Reader(); // TODO: Add support for embedded ID3.
-    reader.init(output, new TrackIdGenerator(0, 1));
+    reader.createTracks(output, new TrackIdGenerator(0, 1));
     output.endTracks();
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     startedPacket = false;
     reader.seek();
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index a9d3319f87..52faa8c673 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -20,13 +20,14 @@
 import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
  * Parses a continuous (E-)AC-3 byte stream and extracts individual samples.
  */
-/* package */ final class Ac3Reader extends ElementaryStreamReader {
+/* package */ final class Ac3Reader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -82,7 +83,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator generator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator generator) {
     output = extractorOutput.track(generator.getNextId());
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 7a9cbd4bb1..f7dadd51b2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -22,7 +22,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -128,13 +128,13 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     reader = new AdtsReader(true);
-    reader.init(output, new TrackIdGenerator(0, 1));
+    reader.createTracks(output, new TrackIdGenerator(0, 1));
     output.endTracks();
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     startedPacket = false;
     reader.seek();
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index d0474f7e44..47cb217fc7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
@@ -32,7 +33,7 @@
 /**
  * Parses a continuous ADTS byte stream and extracts individual frames.
  */
-/* package */ final class AdtsReader extends ElementaryStreamReader {
+/* package */ final class AdtsReader implements ElementaryStreamReader {
 
   private static final String TAG = "AdtsReader";
 
@@ -106,7 +107,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
     if (exposeId3) {
       id3Output = extractorOutput.track(idGenerator.getNextId());
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
similarity index 54%
rename from library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java
rename to library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 58a0e55f02..31aa88d11a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -16,67 +16,80 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.support.annotation.IntDef;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
 /**
- * Default implementation for {@link ElementaryStreamReader.Factory}.
+ * Default implementation for {@link TsPayloadReader.Factory}.
  */
-public final class DefaultStreamReaderFactory implements ElementaryStreamReader.Factory {
+public final class DefaultTsPayloadReaderFactory implements TsPayloadReader.Factory {
 
   /**
    * Flags controlling elementary stream readers behaviour.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_ALLOW_NON_IDR_KEYFRAMES, FLAG_IGNORE_AAC_STREAM,
-      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS})
+      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS, FLAG_IGNORE_SPLICE_INFO_STREAM})
   public @interface Flags {
   }
   public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
   public static final int FLAG_IGNORE_AAC_STREAM = 2;
   public static final int FLAG_IGNORE_H264_STREAM = 4;
   public static final int FLAG_DETECT_ACCESS_UNITS = 8;
+  public static final int FLAG_IGNORE_SPLICE_INFO_STREAM = 16;
 
   @Flags
   private final int flags;
 
-  public DefaultStreamReaderFactory() {
+  public DefaultTsPayloadReaderFactory() {
     this(0);
   }
 
-  public DefaultStreamReaderFactory(@Flags int flags) {
+  public DefaultTsPayloadReaderFactory(@Flags int flags) {
     this.flags = flags;
   }
 
   @Override
-  public ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo) {
+  public SparseArray<TsPayloadReader> createInitialPayloadReaders() {
+    return new SparseArray<>();
+  }
+
+  @Override
+  public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
     switch (streamType) {
       case TsExtractor.TS_STREAM_TYPE_MPA:
       case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
-        return new MpegAudioReader(esInfo.language);
+        return new PesReader(new MpegAudioReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AAC:
-        return (flags & FLAG_IGNORE_AAC_STREAM) != 0 ? null
-            : new AdtsReader(false, esInfo.language);
+        return isSet(FLAG_IGNORE_AAC_STREAM)
+            ? null : new PesReader(new AdtsReader(false, esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_AC3:
       case TsExtractor.TS_STREAM_TYPE_E_AC3:
-        return new Ac3Reader(esInfo.language);
+        return new PesReader(new Ac3Reader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_DTS:
       case TsExtractor.TS_STREAM_TYPE_HDMV_DTS:
-        return new DtsReader(esInfo.language);
+        return new PesReader(new DtsReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_H262:
-        return new H262Reader();
+        return new PesReader(new H262Reader());
       case TsExtractor.TS_STREAM_TYPE_H264:
-        return (flags & FLAG_IGNORE_H264_STREAM) != 0 ? null
-            : new H264Reader((flags & FLAG_ALLOW_NON_IDR_KEYFRAMES) != 0,
-                (flags & FLAG_DETECT_ACCESS_UNITS) != 0);
+        return isSet(FLAG_IGNORE_H264_STREAM) ? null : new PesReader(
+            new H264Reader(isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS)));
       case TsExtractor.TS_STREAM_TYPE_H265:
-        return new H265Reader();
+        return new PesReader(new H265Reader());
+      case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
+        return isSet(FLAG_IGNORE_SPLICE_INFO_STREAM)
+            ? null : new SectionReader(new SpliceInfoSectionReader());
       case TsExtractor.TS_STREAM_TYPE_ID3:
-        return new Id3Reader();
+        return new PesReader(new Id3Reader());
       default:
         return null;
     }
   }
 
+  private boolean isSet(@Flags int flag) {
+    return (flags & flag) != 0;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index 42223ef285..9707685295 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -20,12 +20,13 @@
 import com.google.android.exoplayer2.audio.DtsUtil;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
  * Parses a continuous DTS byte stream and extracts individual samples.
  */
-/* package */ final class DtsReader extends ElementaryStreamReader {
+/* package */ final class DtsReader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -77,7 +78,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index e2efbebb43..57bcf31fc5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -22,82 +22,21 @@
 /**
  * Extracts individual samples from an elementary media stream, preserving original order.
  */
-public abstract class ElementaryStreamReader {
-
-  /**
-   * Factory of {@link ElementaryStreamReader} instances.
-   */
-  public interface Factory {
-
-    /**
-     * Returns an {@link ElementaryStreamReader} for a given PMT entry. May return null if the
-     * stream type is not supported or if the stream already has a reader assigned to it.
-     *
-     * @param streamType Stream type value as defined in the PMT entry or associated descriptors.
-     * @param esInfo Information associated to the elementary stream provided in the PMT.
-     * @return An {@link ElementaryStreamReader} for the elementary streams carried by the provided
-     *     pid. {@code null} if the stream is not supported or if it should be ignored.
-     */
-    ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo);
-
-  }
-
-  /**
-   * Holds descriptor information associated with an elementary stream.
-   */
-  public static final class EsInfo {
-
-    public final int streamType;
-    public String language;
-    public byte[] descriptorBytes;
-
-    /**
-     * @param streamType The type of the stream as defined by the
-     *     {@link TsExtractor}{@code .TS_STREAM_TYPE_*}.
-     * @param language The language of the stream, as defined by ISO/IEC 13818-1, section 2.6.18.
-     * @param descriptorBytes The descriptor bytes associated to the stream.
-     */
-    public EsInfo(int streamType, String language, byte[] descriptorBytes) {
-      this.streamType = streamType;
-      this.language = language;
-      this.descriptorBytes = descriptorBytes;
-    }
-
-  }
-
-  /**
-   * Generates track ids for initializing {@link ElementaryStreamReader}s' {@link TrackOutput}s.
-   */
-  public static final class TrackIdGenerator {
-
-    private final int firstId;
-    private final int idIncrement;
-    private int generatedIdCount;
-
-    public TrackIdGenerator(int firstId, int idIncrement) {
-      this.firstId = firstId;
-      this.idIncrement = idIncrement;
-    }
-
-    public int getNextId() {
-      return firstId + idIncrement * generatedIdCount++;
-    }
-
-  }
+public interface ElementaryStreamReader {
 
   /**
    * Notifies the reader that a seek has occurred.
    */
-  public abstract void seek();
+  void seek();
 
   /**
    * Initializes the reader by providing outputs and ids for the tracks.
    *
    * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
-   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
    *     {@link TrackOutput}s.
    */
-  public abstract void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator);
+  void createTracks(ExtractorOutput extractorOutput, PesReader.TrackIdGenerator idGenerator);
 
   /**
    * Called when a packet starts.
@@ -105,18 +44,18 @@ public int getNextId() {
    * @param pesTimeUs The timestamp associated with the packet.
    * @param dataAlignmentIndicator The data alignment indicator associated with the packet.
    */
-  public abstract void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator);
+  void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator);
 
   /**
    * Consumes (possibly partial) data from the current packet.
    *
    * @param data The data to consume.
    */
-  public abstract void consume(ParsableByteArray data);
+  void consume(ParsableByteArray data);
 
   /**
    * Called when a packet ends.
    */
-  public abstract void packetFinished();
+  void packetFinished();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index fbfe7e1209..02ea6d7c4e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -29,7 +30,7 @@
 /**
  * Parses a continuous H262 byte stream and extracts individual frames.
  */
-/* package */ final class H262Reader extends ElementaryStreamReader {
+/* package */ final class H262Reader implements ElementaryStreamReader {
 
   private static final int START_PICTURE = 0x00;
   private static final int START_SEQUENCE_HEADER = 0xB3;
@@ -76,7 +77,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 6fee9ea6d7..ed4682d9b9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.NalUnitUtil.SpsData;
@@ -32,7 +33,7 @@
 /**
  * Parses a continuous H264 byte stream and extracts individual frames.
  */
-/* package */ final class H264Reader extends ElementaryStreamReader {
+/* package */ final class H264Reader implements ElementaryStreamReader {
 
   private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
@@ -86,7 +87,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
     sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
     seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index 6283371a19..a78169a054 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -29,7 +30,7 @@
 /**
  * Parses a continuous H.265 byte stream and extracts individual frames.
  */
-/* package */ final class H265Reader extends ElementaryStreamReader {
+/* package */ final class H265Reader implements ElementaryStreamReader {
 
   private static final String TAG = "H265Reader";
 
@@ -44,6 +45,7 @@
   private static final int SUFFIX_SEI_NUT = 40;
 
   private TrackOutput output;
+  private SampleReader sampleReader;
   private SeiReader seiReader;
 
   // State that should not be reset on seek.
@@ -56,7 +58,6 @@
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer prefixSei;
   private final NalUnitTargetBuffer suffixSei; // TODO: Are both needed?
-  private final SampleReader sampleReader;
   private long totalBytesWritten;
 
   // Per packet state that gets reset at the start of each packet.
@@ -72,7 +73,6 @@ public H265Reader() {
     pps = new NalUnitTargetBuffer(PPS_NUT, 128);
     prefixSei = new NalUnitTargetBuffer(PREFIX_SEI_NUT, 128);
     suffixSei = new NalUnitTargetBuffer(SUFFIX_SEI_NUT, 128);
-    sampleReader = new SampleReader(output);
     seiWrapper = new ParsableByteArray();
   }
 
@@ -89,8 +89,9 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
+    sampleReader = new SampleReader(output);
     seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index 2c657d4aca..c19bc9d14e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -15,17 +15,21 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
  * Parses ID3 data and extracts individual text information frames.
  */
-/* package */ final class Id3Reader extends ElementaryStreamReader {
+/* package */ final class Id3Reader implements ElementaryStreamReader {
+
+  private static final String TAG = "Id3Reader";
 
   private static final int ID3_HEADER_SIZE = 10;
 
@@ -51,7 +55,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
     output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE,
         null));
@@ -81,7 +85,14 @@ public void consume(ParsableByteArray data) {
           headerBytesAvailable);
       if (sampleBytesRead + headerBytesAvailable == ID3_HEADER_SIZE) {
         // We've finished reading the ID3 header. Extract the sample size.
-        id3Header.setPosition(6); // 'ID3' (3) + version (2) + flags (1)
+        id3Header.setPosition(0);
+        if ('I' != id3Header.readUnsignedByte() || 'D' != id3Header.readUnsignedByte()
+            || '3' != id3Header.readUnsignedByte()) {
+          Log.w(TAG, "Discarding invalid ID3 tag");
+          writingSample = false;
+          return;
+        }
+        id3Header.skipBytes(3); // version (2) + flags (1)
         sampleSize = ID3_HEADER_SIZE + id3Header.readSynchSafeInt();
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index d25d0703ae..c67e7ad0ab 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -20,12 +20,13 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
  * Parses a continuous MPEG Audio byte stream and extracts individual frames.
  */
-/* package */ final class MpegAudioReader extends ElementaryStreamReader {
+/* package */ final class MpegAudioReader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_HEADER = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -74,7 +75,7 @@ public void seek() {
   }
 
   @Override
-  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
     output = extractorOutput.track(idGenerator.getNextId());
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
new file mode 100644
index 0000000000..59696b9dea
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+
+/**
+ * Parses PES packet data and extracts samples.
+ */
+public final class PesReader implements TsPayloadReader {
+
+  private static final String TAG = "PesReader";
+
+  private static final int STATE_FINDING_HEADER = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_HEADER_EXTENSION = 2;
+  private static final int STATE_READING_BODY = 3;
+
+  private static final int HEADER_SIZE = 9;
+  private static final int MAX_HEADER_EXTENSION_SIZE = 10;
+  private static final int PES_SCRATCH_SIZE = 10; // max(HEADER_SIZE, MAX_HEADER_EXTENSION_SIZE)
+
+  private final ElementaryStreamReader reader;
+  private final ParsableBitArray pesScratch;
+
+  private int state;
+  private int bytesRead;
+
+  private TimestampAdjuster timestampAdjuster;
+  private boolean ptsFlag;
+  private boolean dtsFlag;
+  private boolean seenFirstDts;
+  private int extendedHeaderLength;
+  private int payloadSize;
+  private boolean dataAlignmentIndicator;
+  private long timeUs;
+
+  public PesReader(ElementaryStreamReader reader) {
+    this.reader = reader;
+    pesScratch = new ParsableBitArray(new byte[PES_SCRATCH_SIZE]);
+    state = STATE_FINDING_HEADER;
+  }
+
+  @Override
+  public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+      TrackIdGenerator idGenerator) {
+    this.timestampAdjuster = timestampAdjuster;
+    reader.createTracks(extractorOutput, idGenerator);
+  }
+
+  // TsPayloadReader implementation.
+
+  @Override
+  public final void seek() {
+    state = STATE_FINDING_HEADER;
+    bytesRead = 0;
+    seenFirstDts = false;
+    reader.seek();
+  }
+
+  @Override
+  public final void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+    if (payloadUnitStartIndicator) {
+      switch (state) {
+        case STATE_FINDING_HEADER:
+        case STATE_READING_HEADER:
+          // Expected.
+          break;
+        case STATE_READING_HEADER_EXTENSION:
+          Log.w(TAG, "Unexpected start indicator reading extended header");
+          break;
+        case STATE_READING_BODY:
+          // If payloadSize == -1 then the length of the previous packet was unspecified, and so
+          // we only know that it's finished now that we've seen the start of the next one. This
+          // is expected. If payloadSize != -1, then the length of the previous packet was known,
+          // but we didn't receive that amount of data. This is not expected.
+          if (payloadSize != -1) {
+            Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
+          }
+          // Either way, notify the reader that it has now finished.
+          reader.packetFinished();
+          break;
+      }
+      setState(STATE_READING_HEADER);
+    }
+
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_HEADER:
+          data.skipBytes(data.bytesLeft());
+          break;
+        case STATE_READING_HEADER:
+          if (continueRead(data, pesScratch.data, HEADER_SIZE)) {
+            setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
+          }
+          break;
+        case STATE_READING_HEADER_EXTENSION:
+          int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
+          // Read as much of the extended header as we're interested in, and skip the rest.
+          if (continueRead(data, pesScratch.data, readLength)
+              && continueRead(data, null, extendedHeaderLength)) {
+            parseHeaderExtension();
+            reader.packetStarted(timeUs, dataAlignmentIndicator);
+            setState(STATE_READING_BODY);
+          }
+          break;
+        case STATE_READING_BODY:
+          readLength = data.bytesLeft();
+          int padding = payloadSize == -1 ? 0 : readLength - payloadSize;
+          if (padding > 0) {
+            readLength -= padding;
+            data.setLimit(data.getPosition() + readLength);
+          }
+          reader.consume(data);
+          if (payloadSize != -1) {
+            payloadSize -= readLength;
+            if (payloadSize == 0) {
+              reader.packetFinished();
+              setState(STATE_READING_HEADER);
+            }
+          }
+          break;
+      }
+    }
+  }
+
+  private void setState(int state) {
+    this.state = state;
+    bytesRead = 0;
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read, or {@code null} to skip.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length has been reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    if (bytesToRead <= 0) {
+      return true;
+    } else if (target == null) {
+      source.skipBytes(bytesToRead);
+    } else {
+      source.readBytes(target, bytesRead, bytesToRead);
+    }
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  private boolean parseHeader() {
+    // Note: see ISO/IEC 13818-1, section 2.4.3.6 for detailed information on the format of
+    // the header.
+    pesScratch.setPosition(0);
+    int startCodePrefix = pesScratch.readBits(24);
+    if (startCodePrefix != 0x000001) {
+      Log.w(TAG, "Unexpected start code prefix: " + startCodePrefix);
+      payloadSize = -1;
+      return false;
+    }
+
+    pesScratch.skipBits(8); // stream_id.
+    int packetLength = pesScratch.readBits(16);
+    pesScratch.skipBits(5); // '10' (2), PES_scrambling_control (2), PES_priority (1)
+    dataAlignmentIndicator = pesScratch.readBit();
+    pesScratch.skipBits(2); // copyright (1), original_or_copy (1)
+    ptsFlag = pesScratch.readBit();
+    dtsFlag = pesScratch.readBit();
+    // ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
+    // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
+    pesScratch.skipBits(6);
+    extendedHeaderLength = pesScratch.readBits(8);
+
+    if (packetLength == 0) {
+      payloadSize = -1;
+    } else {
+      payloadSize = packetLength + 6 /* packetLength does not include the first 6 bytes */
+          - HEADER_SIZE - extendedHeaderLength;
+    }
+    return true;
+  }
+
+  private void parseHeaderExtension() {
+    pesScratch.setPosition(0);
+    timeUs = C.TIME_UNSET;
+    if (ptsFlag) {
+      pesScratch.skipBits(4); // '0010' or '0011'
+      long pts = (long) pesScratch.readBits(3) << 30;
+      pesScratch.skipBits(1); // marker_bit
+      pts |= pesScratch.readBits(15) << 15;
+      pesScratch.skipBits(1); // marker_bit
+      pts |= pesScratch.readBits(15);
+      pesScratch.skipBits(1); // marker_bit
+      if (!seenFirstDts && dtsFlag) {
+        pesScratch.skipBits(4); // '0011'
+        long dts = (long) pesScratch.readBits(3) << 30;
+        pesScratch.skipBits(1); // marker_bit
+        dts |= pesScratch.readBits(15) << 15;
+        pesScratch.skipBits(1); // marker_bit
+        dts |= pesScratch.readBits(15);
+        pesScratch.skipBits(1); // marker_bit
+        // Subsequent PES packets may have earlier presentation timestamps than this one, but they
+        // should all be greater than or equal to this packet's decode timestamp. We feed the
+        // decode timestamp to the adjuster here so that in the case that this is the first to be
+        // fed, the adjuster will be able to compute an offset to apply such that the adjusted
+        // presentation timestamps of all future packets are non-negative.
+        timestampAdjuster.adjustTsTimestamp(dts);
+        seenFirstDts = true;
+      }
+      timeUs = timestampAdjuster.adjustTsTimestamp(pts);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index b615a3e8ee..883fb8f880 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -23,10 +23,10 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 
 /**
@@ -127,7 +127,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     timestampAdjuster.reset();
     for (int i = 0; i < psPayloadReaders.size(); i++) {
       psPayloadReaders.valueAt(i).seek();
@@ -202,7 +202,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
         }
         if (elementaryStreamReader != null) {
           TrackIdGenerator idGenerator = new TrackIdGenerator(streamId, MAX_STREAM_ID_PLUS_ONE);
-          elementaryStreamReader.init(output, idGenerator);
+          elementaryStreamReader.createTracks(output, idGenerator);
           payloadReader = new PesReader(elementaryStreamReader, timestampAdjuster);
           psPayloadReaders.put(streamId, payloadReader);
         }
@@ -253,8 +253,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     private int extendedHeaderLength;
     private long timeUs;
 
-    public PesReader(ElementaryStreamReader pesPayloadReader,
-        TimestampAdjuster timestampAdjuster) {
+    public PesReader(ElementaryStreamReader pesPayloadReader, TimestampAdjuster timestampAdjuster) {
       this.pesPayloadReader = pesPayloadReader;
       this.timestampAdjuster = timestampAdjuster;
       pesScratch = new ParsableBitArray(new byte[PES_SCRATCH_SIZE]);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
new file mode 100644
index 0000000000..d6e6eadf3f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+
+/**
+ * Reads section data.
+ */
+public interface SectionPayloadReader {
+
+  /**
+   * Initializes the section payload reader.
+   *
+   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
+   *     {@link TrackOutput}s.
+   */
+  void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+      TrackIdGenerator idGenerator);
+
+  /**
+   * Called by a {@link SectionReader} when a full section is received.
+   *
+   * @param sectionData The data belonging to a section starting from the table_id. If
+   *     section_syntax_indicator is set to '1', {@code sectionData} excludes the CRC_32 field.
+   *     Otherwise, all bytes belonging to the table section are included.
+   */
+  void consume(ParsableByteArray sectionData);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
new file mode 100644
index 0000000000..d217cfcb7a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Reads section data packets and feeds the whole sections to a given {@link SectionPayloadReader}.
+ * Useful information on PSI sections can be found in ISO/IEC 13818-1, section 2.4.4.
+ */
+public final class SectionReader implements TsPayloadReader {
+
+  private static final int SECTION_HEADER_LENGTH = 3;
+  private static final int DEFAULT_SECTION_BUFFER_LENGTH = 32;
+  private static final int MAX_SECTION_LENGTH = 4098;
+
+  private final SectionPayloadReader reader;
+  private final ParsableByteArray sectionData;
+
+  private int totalSectionLength;
+  private int bytesRead;
+  private boolean sectionSyntaxIndicator;
+  private boolean waitingForPayloadStart;
+
+  public SectionReader(SectionPayloadReader reader) {
+    this.reader = reader;
+    sectionData = new ParsableByteArray(DEFAULT_SECTION_BUFFER_LENGTH);
+  }
+
+  @Override
+  public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+      TrackIdGenerator idGenerator) {
+    reader.init(timestampAdjuster, extractorOutput, idGenerator);
+    waitingForPayloadStart = true;
+  }
+
+  @Override
+  public void seek() {
+    waitingForPayloadStart = true;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+    int payloadStartPosition = C.POSITION_UNSET;
+    if (payloadUnitStartIndicator) {
+      int payloadStartOffset = data.readUnsignedByte();
+      payloadStartPosition = data.getPosition() + payloadStartOffset;
+    }
+
+    if (waitingForPayloadStart) {
+      if (!payloadUnitStartIndicator) {
+        return;
+      }
+      waitingForPayloadStart = false;
+      data.setPosition(payloadStartPosition);
+      bytesRead = 0;
+    }
+
+    while (data.bytesLeft() > 0) {
+      if (bytesRead < SECTION_HEADER_LENGTH) {
+        // Note: see ISO/IEC 13818-1, section 2.4.4.3 for detailed information on the format of
+        // the header.
+        if (bytesRead == 0) {
+          int tableId = data.readUnsignedByte();
+          data.setPosition(data.getPosition() - 1);
+          if (tableId == 0xFF /* forbidden value */) {
+            // No more sections in this ts packet.
+            waitingForPayloadStart = true;
+            return;
+          }
+        }
+        int headerBytesToRead = Math.min(data.bytesLeft(), SECTION_HEADER_LENGTH - bytesRead);
+        data.readBytes(sectionData.data, bytesRead, headerBytesToRead);
+        bytesRead += headerBytesToRead;
+        if (bytesRead == SECTION_HEADER_LENGTH) {
+          sectionData.reset(SECTION_HEADER_LENGTH);
+          sectionData.skipBytes(1); // Skip table id (8).
+          int secondHeaderByte = sectionData.readUnsignedByte();
+          int thirdHeaderByte = sectionData.readUnsignedByte();
+          sectionSyntaxIndicator = (secondHeaderByte & 0x80) != 0;
+          totalSectionLength =
+              (((secondHeaderByte & 0x0F) << 8) | thirdHeaderByte) + SECTION_HEADER_LENGTH;
+          if (sectionData.capacity() < totalSectionLength) {
+            // Ensure there is enough space to keep the whole section.
+            byte[] bytes = sectionData.data;
+            sectionData.reset(
+                Math.min(MAX_SECTION_LENGTH, Math.max(totalSectionLength, bytes.length * 2)));
+            System.arraycopy(bytes, 0, sectionData.data, 0, SECTION_HEADER_LENGTH);
+          }
+        }
+      } else {
+        // Reading the body.
+        int bodyBytesToRead = Math.min(data.bytesLeft(), totalSectionLength - bytesRead);
+        data.readBytes(sectionData.data, bytesRead, bodyBytesToRead);
+        bytesRead += bodyBytesToRead;
+        if (bytesRead == totalSectionLength) {
+          if (sectionSyntaxIndicator) {
+            // This section has common syntax as defined in ISO/IEC 13818-1, section 2.4.4.11.
+            if (Util.crc(sectionData.data, 0, totalSectionLength, 0xFFFFFFFF) != 0) {
+              // The CRC is invalid so discard the section.
+              waitingForPayloadStart = true;
+              return;
+            }
+            sectionData.reset(totalSectionLength - 4); // Exclude the CRC_32 field.
+          } else {
+            // This is a private section with private defined syntax.
+            sectionData.reset(totalSectionLength);
+          }
+          reader.consume(sectionData);
+          bytesRead = 0;
+        }
+      }
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index 4971c0c2b1..6e2e42d8e2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -15,10 +15,9 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
@@ -36,46 +35,7 @@ public SeiReader(TrackOutput output) {
   }
 
   public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
-    int b;
-    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
-      // Parse payload type.
-      int payloadType = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadType += b;
-      } while (b == 0xFF);
-      // Parse payload size.
-      int payloadSize = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadSize += b;
-      } while (b == 0xFF);
-      // Process the payload.
-      if (Cea608Decoder.isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
-        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
-        // + user_data_type_code (1).
-        seiBuffer.skipBytes(8);
-        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
-        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
-        seiBuffer.skipBytes(1);
-        int sampleBytes = 0;
-        for (int i = 0; i < ccCount; i++) {
-          int ccValidityAndType = seiBuffer.peekUnsignedByte() & 0x07;
-          // Check that validity == 1 and type == 0 (i.e. NTSC_CC_FIELD_1).
-          if (ccValidityAndType != 0x04) {
-            seiBuffer.skipBytes(3);
-          } else {
-            sampleBytes += 3;
-            output.sampleData(seiBuffer, 3);
-          }
-        }
-        output.sampleMetadata(pesTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleBytes, 0, null);
-        // Ignore trailing information in SEI, if any.
-        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
-      } else {
-        seiBuffer.skipBytes(payloadSize);
-      }
-    }
+    CeaUtil.consume(pesTimeUs, seiBuffer, output);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
new file mode 100644
index 0000000000..057fa636ce
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+
+/**
+ * Parses splice info sections as defined by SCTE35.
+ */
+public final class SpliceInfoSectionReader implements SectionPayloadReader {
+
+  private TimestampAdjuster timestampAdjuster;
+  private TrackOutput output;
+  private boolean formatDeclared;
+
+  @Override
+  public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+      TsPayloadReader.TrackIdGenerator idGenerator) {
+    this.timestampAdjuster = timestampAdjuster;
+    output = extractorOutput.track(idGenerator.getNextId());
+    output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35, null,
+        Format.NO_VALUE, null));
+  }
+
+  @Override
+  public void consume(ParsableByteArray sectionData) {
+    if (!formatDeclared) {
+      if (timestampAdjuster.getTimestampOffsetUs() == C.TIME_UNSET) {
+        // There is not enough information to initialize the timestamp adjuster.
+        return;
+      }
+      output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35,
+          timestampAdjuster.getTimestampOffsetUs()));
+      formatDeclared = true;
+    }
+    int sampleSize = sectionData.bytesLeft();
+    output.sampleData(sectionData, sampleSize);
+    output.sampleMetadata(timestampAdjuster.getLastAdjustedTimestampUs(), C.BUFFER_FLAG_KEY_FRAME,
+        sampleSize, 0, null);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index bac362d711..61d66afbc2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.util.Log;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
@@ -26,13 +25,13 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
-import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Arrays;
@@ -65,8 +64,7 @@
   public static final int TS_STREAM_TYPE_H264 = 0x1B;
   public static final int TS_STREAM_TYPE_H265 = 0x24;
   public static final int TS_STREAM_TYPE_ID3 = 0x15;
-
-  private static final String TAG = "TsExtractor";
+  public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
 
   private static final int TS_PACKET_SIZE = 188;
   private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
@@ -80,19 +78,19 @@
   private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
 
-  private final boolean mapByType;
+  private final boolean hlsMode;
   private final TimestampAdjuster timestampAdjuster;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
   private final SparseIntArray continuityCounters;
-  private final ElementaryStreamReader.Factory streamReaderFactory;
+  private final TsPayloadReader.Factory payloadReaderFactory;
   private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
   private final SparseBooleanArray trackIds;
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
   private boolean tracksEnded;
-  private ElementaryStreamReader id3Reader;
+  private TsPayloadReader id3Reader;
 
   public TsExtractor() {
     this(new TimestampAdjuster(0));
@@ -102,20 +100,20 @@ public TsExtractor() {
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    */
   public TsExtractor(TimestampAdjuster timestampAdjuster) {
-    this(timestampAdjuster, new DefaultStreamReaderFactory(), false);
+    this(timestampAdjuster, new DefaultTsPayloadReaderFactory(), false);
   }
 
   /**
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   * @param customReaderFactory Factory for injecting a custom set of elementary stream readers.
-   * @param mapByType True if {@link TrackOutput}s should be mapped by their type, false to map them
-   *     by their PID.
+   * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
+   * @param hlsMode Whether the extractor should be used in HLS mode. If true, {@link TrackOutput}s
+   *     are mapped by their type (instead of PID) and continuity counters are ignored.
    */
   public TsExtractor(TimestampAdjuster timestampAdjuster,
-      ElementaryStreamReader.Factory customReaderFactory, boolean mapByType) {
+      TsPayloadReader.Factory payloadReaderFactory, boolean hlsMode) {
     this.timestampAdjuster = timestampAdjuster;
-    this.streamReaderFactory = Assertions.checkNotNull(customReaderFactory);
-    this.mapByType = mapByType;
+    this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
+    this.hlsMode = hlsMode;
     tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
     trackIds = new SparseBooleanArray();
@@ -151,7 +149,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     timestampAdjuster.reset();
     tsPacketBuffer.reset();
     continuityCounters.clear();
@@ -213,16 +211,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     tsScratch.skipBits(2); // transport_scrambling_control
     boolean adaptationFieldExists = tsScratch.readBit();
     boolean payloadExists = tsScratch.readBit();
+
+    // Discontinuity check.
     boolean discontinuityFound = false;
     int continuityCounter = tsScratch.readBits(4);
-    int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-    continuityCounters.put(pid, continuityCounter);
-    if (previousCounter == continuityCounter) {
-      // Duplicate packet found.
-      tsPacketBuffer.setPosition(endOfPacket);
-      return RESULT_CONTINUE;
-    } else if (continuityCounter != (previousCounter + 1) % 16) {
-      discontinuityFound = true;
+    if (!hlsMode) {
+      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+      continuityCounters.put(pid, continuityCounter);
+      if (previousCounter == continuityCounter) {
+        if (payloadExists) {
+          // Duplicate packet found.
+          tsPacketBuffer.setPosition(endOfPacket);
+          return RESULT_CONTINUE;
+        }
+      } else if (continuityCounter != (previousCounter + 1) % 16) {
+        discontinuityFound = true;
+      }
     }
 
     // Skip the adaptation field.
@@ -239,7 +243,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
           payloadReader.seek();
         }
         tsPacketBuffer.setLimit(endOfPacket);
-        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator, output);
+        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
         Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
         tsPacketBuffer.setLimit(limit);
       }
@@ -254,95 +258,46 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
   private void resetPayloadReaders() {
     trackIds.clear();
     tsPayloadReaders.clear();
-    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
+    SparseArray<TsPayloadReader> initialPayloadReaders =
+        payloadReaderFactory.createInitialPayloadReaders();
+    int initialPayloadReadersSize = initialPayloadReaders.size();
+    for (int i = 0; i < initialPayloadReadersSize; i++) {
+      tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
+    }
+    tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
     id3Reader = null;
   }
 
-  /**
-   * Parses TS packet payload data.
-   */
-  private abstract static class TsPayloadReader {
-
-    /**
-     * Notifies the reader that a seek has occurred.
-     * <p>
-     * Following a call to this method, the data passed to the next invocation of
-     * {@link #consume(ParsableByteArray, boolean, ExtractorOutput)} will not be a continuation of
-     * the data that was previously passed. Hence the reader should reset any internal state.
-     */
-    public abstract void seek();
-
-    /**
-     * Consumes the payload of a TS packet.
-     *
-     * @param data The TS packet. The position will be set to the start of the payload.
-     * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
-     * @param output The output to which parsed data should be written.
-     */
-    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
-        ExtractorOutput output);
-
-  }
-
   /**
    * Parses Program Association Table data.
    */
-  private class PatReader extends TsPayloadReader {
+  private class PatReader implements SectionPayloadReader {
 
-    private final ParsableByteArray sectionData;
     private final ParsableBitArray patScratch;
 
-    private int sectionLength;
-    private int sectionBytesRead;
-    private int crc;
-
     public PatReader() {
-      sectionData = new ParsableByteArray();
       patScratch = new ParsableBitArray(new byte[4]);
     }
 
     @Override
-    public void seek() {
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TrackIdGenerator idGenerator) {
       // Do nothing.
     }
 
     @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
-        ExtractorOutput output) {
-      // Skip pointer.
-      if (payloadUnitStartIndicator) {
-        int pointerField = data.readUnsignedByte();
-        data.skipBytes(pointerField);
-
-        // Note: see ISO/IEC 13818-1, section 2.4.4.3 for detailed information on the format of
-        // the header.
-        data.readBytes(patScratch, 3);
-        patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), 0 (1), reserved (2)
-        sectionLength = patScratch.readBits(12);
-        sectionBytesRead = 0;
-        crc = Util.crc(patScratch.data, 0, 3, 0xFFFFFFFF);
-
-        sectionData.reset(sectionLength);
-      }
-
-      int bytesToRead = Math.min(data.bytesLeft(), sectionLength - sectionBytesRead);
-      data.readBytes(sectionData.data, sectionBytesRead, bytesToRead);
-      sectionBytesRead += bytesToRead;
-      if (sectionBytesRead < sectionLength) {
-        // Not yet fully read.
+    public void consume(ParsableByteArray sectionData) {
+      int tableId = sectionData.readUnsignedByte();
+      if (tableId != 0x00 /* program_association_section */) {
+        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
         return;
       }
-
-      if (Util.crc(sectionData.data, 0, sectionLength, crc) != 0) {
-        // CRC Invalid. The section gets discarded.
-        return;
-      }
-
+      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
       // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8)
-      sectionData.skipBytes(5);
+      sectionData.skipBytes(7);
 
-      int programCount = (sectionLength - 9) / 4;
+      int programCount = sectionData.bytesLeft() / 4;
       for (int i = 0; i < programCount; i++) {
         sectionData.readBytes(patScratch, 4);
         int programNumber = patScratch.readBits(16);
@@ -351,7 +306,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           patScratch.skipBits(13); // network_PID (13)
         } else {
           int pid = patScratch.readBits(13);
-          tsPayloadReaders.put(pid, new PmtReader(pid));
+          tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
         }
       }
     }
@@ -361,7 +316,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
   /**
    * Parses Program Map Table.
    */
-  private class PmtReader extends TsPayloadReader {
+  private class PmtReader implements SectionPayloadReader {
 
     private static final int TS_PMT_DESC_REGISTRATION = 0x05;
     private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
@@ -370,60 +325,30 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
     private static final int TS_PMT_DESC_DTS = 0x7B;
 
     private final ParsableBitArray pmtScratch;
-    private final ParsableByteArray sectionData;
     private final int pid;
 
-    private int sectionLength;
-    private int sectionBytesRead;
-    private int crc;
-
     public PmtReader(int pid) {
       pmtScratch = new ParsableBitArray(new byte[5]);
-      sectionData = new ParsableByteArray();
       this.pid = pid;
     }
 
     @Override
-    public void seek() {
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TrackIdGenerator idGenerator) {
       // Do nothing.
     }
 
     @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
-        ExtractorOutput output) {
-      if (payloadUnitStartIndicator) {
-        // Skip pointer.
-        int pointerField = data.readUnsignedByte();
-        data.skipBytes(pointerField);
-
-        // Note: see ISO/IEC 13818-1, section 2.4.4.8 for detailed information on the format of
-        // the header.
-        data.readBytes(pmtScratch, 3);
-        pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), 0 (1), reserved (2)
-        sectionLength = pmtScratch.readBits(12);
-        sectionBytesRead = 0;
-        crc = Util.crc(pmtScratch.data, 0, 3, 0xFFFFFFFF);
-
-        sectionData.reset(sectionLength);
-      }
-
-      int bytesToRead = Math.min(data.bytesLeft(), sectionLength - sectionBytesRead);
-      data.readBytes(sectionData.data, sectionBytesRead, bytesToRead);
-      sectionBytesRead += bytesToRead;
-      if (sectionBytesRead < sectionLength) {
-        // Not yet fully read.
+    public void consume(ParsableByteArray sectionData) {
+      int tableId = sectionData.readUnsignedByte();
+      if (tableId != 0x02 /* TS_program_map_section */) {
+        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
         return;
       }
-
-      if (Util.crc(sectionData.data, 0, sectionLength, crc) != 0) {
-        // CRC Invalid. The section gets discarded.
-        return;
-      }
-
-      // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
-      // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
-      // Skip the rest of the PMT header.
-      sectionData.skipBytes(7);
+      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12), program_number (16),
+      // reserved (2), version_number (5), current_next_indicator (1), // section_number (8),
+      // last_section_number (8), reserved (3), PCR_PID (13)
+      sectionData.skipBytes(9);
 
       // Read program_info_length.
       sectionData.readBytes(pmtScratch, 2);
@@ -433,16 +358,16 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if (mapByType && id3Reader == null) {
+      if (hlsMode && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See [Internal: b/20261500].
         EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, new byte[0]);
-        id3Reader = streamReaderFactory.createStreamReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
-        id3Reader.init(output, new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+        id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
+        id3Reader.init(timestampAdjuster, output,
+            new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
       }
 
-      int remainingEntriesLength = sectionLength - 9 /* Length of fields before descriptors */
-          - programInfoLength - 4 /* CRC length */;
+      int remainingEntriesLength = sectionData.bytesLeft();
       while (remainingEntriesLength > 0) {
         sectionData.readBytes(pmtScratch, 5);
         int streamType = pmtScratch.readBits(8);
@@ -456,25 +381,27 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         }
         remainingEntriesLength -= esInfoLength + 5;
 
-        int trackId = mapByType ? streamType : elementaryPid;
+        int trackId = hlsMode ? streamType : elementaryPid;
         if (trackIds.get(trackId)) {
           continue;
         }
         trackIds.put(trackId, true);
 
-        ElementaryStreamReader pesPayloadReader;
-        if (mapByType && streamType == TS_STREAM_TYPE_ID3) {
-          pesPayloadReader = id3Reader;
+        TsPayloadReader reader;
+        if (hlsMode && streamType == TS_STREAM_TYPE_ID3) {
+          reader = id3Reader;
         } else {
-          pesPayloadReader = streamReaderFactory.createStreamReader(streamType, esInfo);
-          pesPayloadReader.init(output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
+          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo);
+          if (reader != null) {
+            reader.init(timestampAdjuster, output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
+          }
         }
 
-        if (pesPayloadReader != null) {
-          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader, timestampAdjuster));
+        if (reader != null) {
+          tsPayloadReaders.put(elementaryPid, reader);
         }
       }
-      if (mapByType) {
+      if (hlsMode) {
         if (!tracksEnded) {
           output.endTracks();
         }
@@ -527,213 +454,10 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
       }
       data.setPosition(descriptorsEndPosition);
       return new EsInfo(streamType, language,
-          Arrays.copyOfRange(sectionData.data, descriptorsStartPosition, descriptorsEndPosition));
+          Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
     }
 
   }
 
-  /**
-   * Parses PES packet data and extracts samples.
-   */
-  private static final class PesReader extends TsPayloadReader {
-
-    private static final int STATE_FINDING_HEADER = 0;
-    private static final int STATE_READING_HEADER = 1;
-    private static final int STATE_READING_HEADER_EXTENSION = 2;
-    private static final int STATE_READING_BODY = 3;
-
-    private static final int HEADER_SIZE = 9;
-    private static final int MAX_HEADER_EXTENSION_SIZE = 10;
-    private static final int PES_SCRATCH_SIZE = 10; // max(HEADER_SIZE, MAX_HEADER_EXTENSION_SIZE)
-
-    private final ElementaryStreamReader pesPayloadReader;
-    private final TimestampAdjuster timestampAdjuster;
-    private final ParsableBitArray pesScratch;
-
-    private int state;
-    private int bytesRead;
-
-    private boolean ptsFlag;
-    private boolean dtsFlag;
-    private boolean seenFirstDts;
-    private int extendedHeaderLength;
-    private int payloadSize;
-    private boolean dataAlignmentIndicator;
-    private long timeUs;
-
-    public PesReader(ElementaryStreamReader pesPayloadReader,
-        TimestampAdjuster timestampAdjuster) {
-      this.pesPayloadReader = pesPayloadReader;
-      this.timestampAdjuster = timestampAdjuster;
-      pesScratch = new ParsableBitArray(new byte[PES_SCRATCH_SIZE]);
-      state = STATE_FINDING_HEADER;
-    }
-
-    @Override
-    public void seek() {
-      state = STATE_FINDING_HEADER;
-      bytesRead = 0;
-      seenFirstDts = false;
-      pesPayloadReader.seek();
-    }
-
-    @Override
-    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
-        ExtractorOutput output) {
-      if (payloadUnitStartIndicator) {
-        switch (state) {
-          case STATE_FINDING_HEADER:
-          case STATE_READING_HEADER:
-            // Expected.
-            break;
-          case STATE_READING_HEADER_EXTENSION:
-            Log.w(TAG, "Unexpected start indicator reading extended header");
-            break;
-          case STATE_READING_BODY:
-            // If payloadSize == -1 then the length of the previous packet was unspecified, and so
-            // we only know that it's finished now that we've seen the start of the next one. This
-            // is expected. If payloadSize != -1, then the length of the previous packet was known,
-            // but we didn't receive that amount of data. This is not expected.
-            if (payloadSize != -1) {
-              Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
-            }
-            // Either way, notify the reader that it has now finished.
-            pesPayloadReader.packetFinished();
-            break;
-        }
-        setState(STATE_READING_HEADER);
-      }
-
-      while (data.bytesLeft() > 0) {
-        switch (state) {
-          case STATE_FINDING_HEADER:
-            data.skipBytes(data.bytesLeft());
-            break;
-          case STATE_READING_HEADER:
-            if (continueRead(data, pesScratch.data, HEADER_SIZE)) {
-              setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
-            }
-            break;
-          case STATE_READING_HEADER_EXTENSION:
-            int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
-            // Read as much of the extended header as we're interested in, and skip the rest.
-            if (continueRead(data, pesScratch.data, readLength)
-                && continueRead(data, null, extendedHeaderLength)) {
-              parseHeaderExtension();
-              pesPayloadReader.packetStarted(timeUs, dataAlignmentIndicator);
-              setState(STATE_READING_BODY);
-            }
-            break;
-          case STATE_READING_BODY:
-            readLength = data.bytesLeft();
-            int padding = payloadSize == -1 ? 0 : readLength - payloadSize;
-            if (padding > 0) {
-              readLength -= padding;
-              data.setLimit(data.getPosition() + readLength);
-            }
-            pesPayloadReader.consume(data);
-            if (payloadSize != -1) {
-              payloadSize -= readLength;
-              if (payloadSize == 0) {
-                pesPayloadReader.packetFinished();
-                setState(STATE_READING_HEADER);
-              }
-            }
-            break;
-        }
-      }
-    }
-
-    private void setState(int state) {
-      this.state = state;
-      bytesRead = 0;
-    }
-
-    /**
-     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
-     * that the data should be written into {@code target} starting from an offset of zero.
-     *
-     * @param source The source from which to read.
-     * @param target The target into which data is to be read, or {@code null} to skip.
-     * @param targetLength The target length of the read.
-     * @return Whether the target length has been reached.
-     */
-    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
-      int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
-      if (bytesToRead <= 0) {
-        return true;
-      } else if (target == null) {
-        source.skipBytes(bytesToRead);
-      } else {
-        source.readBytes(target, bytesRead, bytesToRead);
-      }
-      bytesRead += bytesToRead;
-      return bytesRead == targetLength;
-    }
-
-    private boolean parseHeader() {
-      // Note: see ISO/IEC 13818-1, section 2.4.3.6 for detailed information on the format of
-      // the header.
-      pesScratch.setPosition(0);
-      int startCodePrefix = pesScratch.readBits(24);
-      if (startCodePrefix != 0x000001) {
-        Log.w(TAG, "Unexpected start code prefix: " + startCodePrefix);
-        payloadSize = -1;
-        return false;
-      }
-
-      pesScratch.skipBits(8); // stream_id.
-      int packetLength = pesScratch.readBits(16);
-      pesScratch.skipBits(5); // '10' (2), PES_scrambling_control (2), PES_priority (1)
-      dataAlignmentIndicator = pesScratch.readBit();
-      pesScratch.skipBits(2); // copyright (1), original_or_copy (1)
-      ptsFlag = pesScratch.readBit();
-      dtsFlag = pesScratch.readBit();
-      // ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
-      // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
-      pesScratch.skipBits(6);
-      extendedHeaderLength = pesScratch.readBits(8);
-
-      if (packetLength == 0) {
-        payloadSize = -1;
-      } else {
-        payloadSize = packetLength + 6 /* packetLength does not include the first 6 bytes */
-            - HEADER_SIZE - extendedHeaderLength;
-      }
-      return true;
-    }
-
-    private void parseHeaderExtension() {
-      pesScratch.setPosition(0);
-      timeUs = C.TIME_UNSET;
-      if (ptsFlag) {
-        pesScratch.skipBits(4); // '0010' or '0011'
-        long pts = (long) pesScratch.readBits(3) << 30;
-        pesScratch.skipBits(1); // marker_bit
-        pts |= pesScratch.readBits(15) << 15;
-        pesScratch.skipBits(1); // marker_bit
-        pts |= pesScratch.readBits(15);
-        pesScratch.skipBits(1); // marker_bit
-        if (!seenFirstDts && dtsFlag) {
-          pesScratch.skipBits(4); // '0011'
-          long dts = (long) pesScratch.readBits(3) << 30;
-          pesScratch.skipBits(1); // marker_bit
-          dts |= pesScratch.readBits(15) << 15;
-          pesScratch.skipBits(1); // marker_bit
-          dts |= pesScratch.readBits(15);
-          pesScratch.skipBits(1); // marker_bit
-          // Subsequent PES packets may have earlier presentation timestamps than this one, but they
-          // should all be greater than or equal to this packet's decode timestamp. We feed the
-          // decode timestamp to the adjuster here so that in the case that this is the first to be
-          // fed, the adjuster will be able to compute an offset to apply such that the adjusted
-          // presentation timestamps of all future packets are non-negative.
-          timestampAdjuster.adjustTsTimestamp(dts);
-          seenFirstDts = true;
-        }
-        timeUs = timestampAdjuster.adjustTsTimestamp(pts);
-      }
-    }
-
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
new file mode 100644
index 0000000000..5785c50a7b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import android.util.SparseArray;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+
+/**
+ * Parses TS packet payload data.
+ */
+public interface TsPayloadReader {
+
+  /**
+   * Factory of {@link TsPayloadReader} instances.
+   */
+  interface Factory {
+
+    /**
+     * Returns the initial mapping from PIDs to payload readers.
+     * <p>
+     * This method allows the injection of payload readers for reserved PIDs, excluding PID 0.
+     *
+     * @return A {@link SparseArray} that maps PIDs to payload readers.
+     */
+    SparseArray<TsPayloadReader> createInitialPayloadReaders();
+
+    /**
+     * Returns a {@link TsPayloadReader} for a given stream type and elementary stream information.
+     * May return null if the stream type is not supported.
+     *
+     * @param streamType Stream type value as defined in the PMT entry or associated descriptors.
+     * @param esInfo Information associated to the elementary stream provided in the PMT.
+     * @return A {@link TsPayloadReader} for the packet stream carried by the provided pid.
+     *     {@code null} if the stream is not supported.
+     */
+    TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo);
+
+  }
+
+  /**
+   * Holds information associated with a PMT entry.
+   */
+  final class EsInfo {
+
+    public final int streamType;
+    public final String language;
+    public final byte[] descriptorBytes;
+
+    /**
+     * @param streamType The type of the stream as defined by the
+     *     {@link TsExtractor}{@code .TS_STREAM_TYPE_*}.
+     * @param language The language of the stream, as defined by ISO/IEC 13818-1, section 2.6.18.
+     * @param descriptorBytes The descriptor bytes associated to the stream.
+     */
+    public EsInfo(int streamType, String language, byte[] descriptorBytes) {
+      this.streamType = streamType;
+      this.language = language;
+      this.descriptorBytes = descriptorBytes;
+    }
+
+  }
+
+  /**
+   * Generates track ids for initializing {@link TsPayloadReader}s' {@link TrackOutput}s.
+   */
+  final class TrackIdGenerator {
+
+    private final int firstId;
+    private final int idIncrement;
+    private int generatedIdCount;
+
+    public TrackIdGenerator(int firstId, int idIncrement) {
+      this.firstId = firstId;
+      this.idIncrement = idIncrement;
+    }
+
+    public int getNextId() {
+      return firstId + idIncrement * generatedIdCount++;
+    }
+
+  }
+
+  /**
+   * Initializes the payload reader.
+   *
+   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
+   * @param idGenerator A {@link PesReader.TrackIdGenerator} that generates unique track ids for the
+   *     {@link TrackOutput}s.
+   */
+  void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+      TrackIdGenerator idGenerator);
+
+  /**
+   * Notifies the reader that a seek has occurred.
+   * <p>
+   * Following a call to this method, the data passed to the next invocation of
+   * {@link #consume(ParsableByteArray, boolean)} will not be a continuation of the data that was
+   * previously passed. Hence the reader should reset any internal state.
+   */
+  void seek();
+
+  /**
+   * Consumes the payload of a TS packet.
+   *
+   * @param data The TS packet. The position will be set to the start of the payload.
+   * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
+   */
+  void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
index 017a26f0af..3d9f8166ab 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
@@ -66,7 +66,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     pendingBytes = 0;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 51c23172a7..6914b2f52c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -16,12 +16,15 @@
 package com.google.android.exoplayer2.mediacodec;
 
 import android.annotation.TargetApi;
+import android.graphics.Point;
 import android.media.MediaCodec;
 import android.media.MediaCodecInfo.AudioCapabilities;
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecInfo.VideoCapabilities;
+import android.util.Log;
 import android.util.Pair;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -32,6 +35,8 @@
 @TargetApi(16)
 public final class MediaCodecInfo {
 
+  public static final String TAG = "MediaCodecInfo";
+
   /**
    * The name of the decoder.
    * <p>
@@ -48,6 +53,14 @@
    */
   public final boolean adaptive;
 
+  /**
+   * Whether the decoder supports tunneling.
+   *
+   * @see CodecCapabilities#isFeatureSupported(String)
+   * @see CodecCapabilities#FEATURE_TunneledPlayback
+   */
+  public final boolean tunneling;
+
   private final String mimeType;
   private final CodecCapabilities capabilities;
 
@@ -83,6 +96,7 @@ private MediaCodecInfo(String name, String mimeType, CodecCapabilities capabilit
     this.mimeType = mimeType;
     this.capabilities = capabilities;
     adaptive = capabilities != null && isAdaptive(capabilities);
+    tunneling = capabilities != null && isTunneling(capabilities);
   }
 
   /**
@@ -111,6 +125,7 @@ public boolean isCodecSupported(String codec) {
       return true;
     }
     if (!mimeType.equals(codecMimeType)) {
+      logNoSupport("codec.mime " + codec + ", " + codecMimeType);
       return false;
     }
     Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(codec);
@@ -124,45 +139,73 @@ public boolean isCodecSupported(String codec) {
         return true;
       }
     }
+    logNoSupport("codec.profileLevel, " + codec + ", " + codecMimeType);
     return false;
   }
 
   /**
-   * Whether the decoder supports video with a specified width and height.
+   * Whether the decoder supports video with a given width, height and frame rate.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @return Whether the decoder supports video with the given width and height.
+   * @param frameRate Optional frame rate in frames per second. Ignored if set to
+   *     {@link Format#NO_VALUE} or any value less than or equal to 0.
+   * @return Whether the decoder supports video with the given width, height and frame rate.
    */
   @TargetApi(21)
-  public boolean isVideoSizeSupportedV21(int width, int height) {
+  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
     if (capabilities == null) {
+      logNoSupport("sizeAndRate.caps");
       return false;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
-    return videoCapabilities != null && videoCapabilities.isSizeSupported(width, height);
+    if (videoCapabilities == null) {
+      logNoSupport("sizeAndRate.vCaps");
+      return false;
+    }
+    if (!areSizeAndRateSupported(videoCapabilities, width, height, frameRate)) {
+      // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
+      // (b/31387661). If the video is vertical and the capabilities indicate support if the width
+      // and height are swapped, we assume that the vertical resolution is also supported.
+      if (width >= height
+          || !areSizeAndRateSupported(videoCapabilities, height, width, frameRate)) {
+        logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
+        return false;
+      }
+      logAssumedSupport("sizeAndRate.rotated, " + width + "x" + height + "x" + frameRate);
+    }
+    return true;
   }
 
   /**
-   * Whether the decoder supports video with a given width, height and frame rate.
+   * Returns the smallest video size greater than or equal to a specified size that also satisfies
+   * the {@link MediaCodec}'s width and height alignment requirements.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @param frameRate Frame rate in frames per second.
-   * @return Whether the decoder supports video with the given width, height and frame rate.
+   * @return The smallest video size greater than or equal to the specified size that also satisfies
+   *     the {@link MediaCodec}'s width and height alignment requirements, or null if not a video
+   *     codec.
    */
   @TargetApi(21)
-  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
+  public Point alignVideoSizeV21(int width, int height) {
     if (capabilities == null) {
-      return false;
+      logNoSupport("align.caps");
+      return null;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
-    return videoCapabilities != null && videoCapabilities.areSizeAndRateSupported(width, height,
-        frameRate);
+    if (videoCapabilities == null) {
+      logNoSupport("align.vCaps");
+      return null;
+    }
+    int widthAlignment = videoCapabilities.getWidthAlignment();
+    int heightAlignment = videoCapabilities.getHeightAlignment();
+    return new Point(Util.ceilDivide(width, widthAlignment) * widthAlignment,
+        Util.ceilDivide(height, heightAlignment) * heightAlignment);
   }
 
   /**
@@ -176,10 +219,19 @@ public boolean isVideoSizeAndRateSupportedV21(int width, int height, double fram
   @TargetApi(21)
   public boolean isAudioSampleRateSupportedV21(int sampleRate) {
     if (capabilities == null) {
+      logNoSupport("sampleRate.caps");
       return false;
     }
     AudioCapabilities audioCapabilities = capabilities.getAudioCapabilities();
-    return audioCapabilities != null && audioCapabilities.isSampleRateSupported(sampleRate);
+    if (audioCapabilities == null) {
+      logNoSupport("sampleRate.aCaps");
+      return false;
+    }
+    if (!audioCapabilities.isSampleRateSupported(sampleRate)) {
+      logNoSupport("sampleRate.support, " + sampleRate);
+      return false;
+    }
+    return true;
   }
 
   /**
@@ -193,10 +245,29 @@ public boolean isAudioSampleRateSupportedV21(int sampleRate) {
   @TargetApi(21)
   public boolean isAudioChannelCountSupportedV21(int channelCount) {
     if (capabilities == null) {
+      logNoSupport("channelCount.caps");
       return false;
     }
     AudioCapabilities audioCapabilities = capabilities.getAudioCapabilities();
-    return audioCapabilities != null && audioCapabilities.getMaxInputChannelCount() >= channelCount;
+    if (audioCapabilities == null) {
+      logNoSupport("channelCount.aCaps");
+      return false;
+    }
+    if (audioCapabilities.getMaxInputChannelCount() < channelCount) {
+      logNoSupport("channelCount.support, " + channelCount);
+      return false;
+    }
+    return true;
+  }
+
+  private void logNoSupport(String message) {
+    Log.d(TAG, "NoSupport [" + message + "] [" + name + ", " + mimeType + "] ["
+        + Util.DEVICE_DEBUG_INFO + "]");
+  }
+
+  private void logAssumedSupport(String message) {
+    Log.d(TAG, "AssumedSupport [" + message + "] [" + name + ", " + mimeType + "] ["
+        + Util.DEVICE_DEBUG_INFO + "]");
   }
 
   private static boolean isAdaptive(CodecCapabilities capabilities) {
@@ -208,4 +279,21 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
     return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
+  @TargetApi(21)
+  private static boolean areSizeAndRateSupported(VideoCapabilities capabilities, int width,
+      int height, double frameRate) {
+    return frameRate == Format.NO_VALUE || frameRate <= 0
+        ? capabilities.isSizeSupported(width, height)
+        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+  }
+
+  private static boolean isTunneling(CodecCapabilities capabilities) {
+    return Util.SDK_INT >= 21 && isTunnelingV21(capabilities);
+  }
+
+  @TargetApi(21)
+  private static boolean isTunnelingV21(CodecCapabilities capabilities) {
+    return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_TunneledPlayback);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 63a77e2215..9be1c59baf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -201,6 +201,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
+  private boolean waitingForFirstSyncFrame;
 
   protected DecoderCounters decoderCounters;
 
@@ -276,11 +277,14 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
   /**
    * Configures a newly created {@link MediaCodec}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param codec The {@link MediaCodec} to configure.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  protected abstract void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto);
+  protected abstract void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException;
 
   @SuppressWarnings("deprecation")
   protected final void maybeInitCodec() throws ExoPlaybackException {
@@ -345,7 +349,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(codec, format, mediaCrypto);
+      configureCodec(decoderInfo, codec, format, mediaCrypto);
       TraceUtil.endSection();
       TraceUtil.beginSection("startCodec");
       codec.start();
@@ -363,6 +367,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
         ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS) : C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     decoderCounters.decoderInitCount++;
   }
 
@@ -375,6 +380,10 @@ protected boolean shouldInitCodec() {
     return codec == null && format != null;
   }
 
+  protected final MediaCodec getCodec() {
+    return codec;
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
@@ -468,6 +477,9 @@ protected void onStopped() {
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
     if (format == null) {
       readFormat();
     }
@@ -494,6 +506,7 @@ protected void flushCodec() throws ExoPlaybackException {
     codecHotswapDeadlineMs = C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     shouldSkipOutputBuffer = false;
     decodeOnlyPresentationTimestamps.clear();
@@ -525,10 +538,9 @@ protected void flushCodec() throws ExoPlaybackException {
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
   private boolean feedInputBuffer() throws ExoPlaybackException {
-    if (inputStreamEnded
-        || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
-      // The input stream has ended, or we need to re-initialize the codec but are still waiting
-      // for the existing codec to output any final output buffers.
+    if (codec == null || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+        || inputStreamEnded) {
+      // We need to reinitialize the codec or the input stream has ended.
       return false;
     }
 
@@ -624,6 +636,16 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       }
       return false;
     }
+    if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
+      buffer.clear();
+      if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
+        // The buffer we just cleared contained reconfiguration data. We need to re-write this
+        // data into a subsequent buffer (if there is one).
+        codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+      }
+      return true;
+    }
+    waitingForFirstSyncFrame = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
@@ -842,10 +864,6 @@ protected long getDequeueOutputBufferTimeoutUs() {
   @SuppressWarnings("deprecation")
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
-    if (outputStreamEnded) {
-      return false;
-    }
-
     if (outputIndex < 0) {
       outputIndex = codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
       if (outputIndex >= 0) {
@@ -860,7 +878,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
           // The dequeued buffer indicates the end of the stream. Process it immediately.
           processEndOfStream();
           outputIndex = C.INDEX_UNSET;
-          return true;
+          return false;
         } else {
           // The dequeued buffer is a media buffer. Do some initial setup. The buffer will be
           // processed by calling processOutputBuffer (possibly multiple times) below.
@@ -881,7 +899,6 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         if (codecNeedsEosPropagationWorkaround && (inputStreamEnded
             || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
           processEndOfStream();
-          return true;
         }
         return false;
       }
@@ -1019,7 +1036,7 @@ private static boolean codecNeedsAdaptationWorkaround(String name) {
     return Util.SDK_INT < 24
         && ("OMX.Nvidia.h264.decode".equals(name) || "OMX.Nvidia.h264.decode.secure".equals(name))
         && ("flounder".equals(Util.DEVICE) || "flounder_lte".equals(Util.DEVICE)
-            || "grouper".equals(Util.DEVICE) || "tilapia".equals(Util.DEVICE));
+        || "grouper".equals(Util.DEVICE) || "tilapia".equals(Util.DEVICE));
   }
 
   /**
@@ -1066,7 +1083,10 @@ private static boolean codecNeedsEosPropagationWorkaround(String name) {
    *     buffer with {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} set. False otherwise.
    */
   private static boolean codecNeedsEosFlushWorkaround(String name) {
-    return Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name);
+    return (Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name))
+        || (Util.SDK_INT <= 19 && "hb2000".equals(Util.DEVICE)
+            && ("OMX.amlogic.avc.decoder.awesome".equals(name)
+                || "OMX.amlogic.avc.decoder.awesome.secure".equals(name)));
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index 250faaa993..bb946d76f9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -46,8 +46,7 @@ public MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
    *
    * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
-   *     exists.
+   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
   MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 2f9524b7f0..a3a2543461 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -23,6 +23,7 @@
 import android.text.TextUtils;
 import android.util.Log;
 import android.util.Pair;
+import android.util.SparseIntArray;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
@@ -63,8 +64,8 @@ private DecoderQueryException(Throwable cause) {
 
   // Codecs to constant mappings.
   // AVC.
-  private static final Map<Integer, Integer> AVC_PROFILE_NUMBER_TO_CONST;
-  private static final Map<Integer, Integer> AVC_LEVEL_NUMBER_TO_CONST;
+  private static final SparseIntArray AVC_PROFILE_NUMBER_TO_CONST;
+  private static final SparseIntArray AVC_LEVEL_NUMBER_TO_CONST;
   private static final String CODEC_ID_AVC1 = "avc1";
   private static final String CODEC_ID_AVC2 = "avc2";
   // HEVC.
@@ -80,7 +81,8 @@ private MediaCodecUtil() {}
   /**
    * Optional call to warm the codec cache for a given mime type.
    * <p>
-   * Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean)}.
+   * Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean)}
+   * and {@link #getDecoderInfos(String, boolean)}.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
@@ -177,11 +179,10 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
                 boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
                 if ((secureDecodersExplicit && key.secure == secure)
                     || (!secureDecodersExplicit && !key.secure)) {
-                  decoderInfos.add(
-                      MediaCodecInfo.newInstance(codecName, mimeType, capabilities));
+                  decoderInfos.add(MediaCodecInfo.newInstance(codecName, mimeType, capabilities));
                 } else if (!secureDecodersExplicit && secure) {
-                  decoderInfos.add(MediaCodecInfo.newInstance(codecName + ".secure",
-                      mimeType, capabilities));
+                  decoderInfos.add(MediaCodecInfo.newInstance(codecName + ".secure", mimeType,
+                      capabilities));
                   // It only makes sense to have one synthesized secure decoder, return immediately.
                   return decoderInfos;
                 }
@@ -222,6 +223,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
         && ("CIPAACDecoder".equals(name)
             || "CIPMP3Decoder".equals(name)
             || "CIPVorbisDecoder".equals(name)
+            || "CIPAMRNBDecoder".equals(name)
             || "AACDecoder".equals(name)
             || "MP3Decoder".equals(name))) {
       return false;
@@ -295,8 +297,9 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
         for (CodecProfileLevel profileLevel : decoderInfo.getProfileLevels()) {
           result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
         }
-        // We assume support for at least 360p.
-        result = Math.max(result, 480 * 360);
+        // We assume support for at least 480p (SDK_INT >= 21) or 360p (SDK_INT < 21), which are
+        // the levels mandated by the Android CDD.
+        result = Math.max(result, Util.SDK_INT >= 21 ? (720 * 480) : (480 * 360));
       }
       maxH264DecodableFrameSize = result;
     }
@@ -364,8 +367,8 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       Log.w(TAG, "Ignoring malformed AVC codec string: " + codec);
       return null;
     }
-    Integer profileInteger = null;
-    Integer levelInteger = null;
+    Integer profileInteger;
+    Integer levelInteger;
     try {
       if (codecsParts[1].length() == 6) {
         // Format: avc1.xxccyy, where xx is profile and yy level, both hexadecimal.
@@ -555,13 +558,13 @@ public boolean equals(Object obj) {
   }
 
   static {
-    AVC_PROFILE_NUMBER_TO_CONST = new HashMap<>();
+    AVC_PROFILE_NUMBER_TO_CONST = new SparseIntArray();
     AVC_PROFILE_NUMBER_TO_CONST.put(66, CodecProfileLevel.AVCProfileBaseline);
     AVC_PROFILE_NUMBER_TO_CONST.put(77, CodecProfileLevel.AVCProfileMain);
     AVC_PROFILE_NUMBER_TO_CONST.put(88, CodecProfileLevel.AVCProfileExtended);
     AVC_PROFILE_NUMBER_TO_CONST.put(100, CodecProfileLevel.AVCProfileHigh);
 
-    AVC_LEVEL_NUMBER_TO_CONST = new HashMap<>();
+    AVC_LEVEL_NUMBER_TO_CONST = new SparseIntArray();
     AVC_LEVEL_NUMBER_TO_CONST.put(10, CodecProfileLevel.AVCLevel1);
     // TODO: Find int for CodecProfileLevel.AVCLevel1b.
     AVC_LEVEL_NUMBER_TO_CONST.put(11, CodecProfileLevel.AVCLevel11);
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java b/library/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
new file mode 100644
index 0000000000..40c05a5602
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A collection of metadata entries.
+ */
+public final class Metadata implements Parcelable {
+
+  /**
+   * A metadata entry.
+   */
+  public interface Entry extends Parcelable {}
+
+  private final Entry[] entries;
+
+  /**
+   * @param entries The metadata entries.
+   */
+  public Metadata(Entry... entries) {
+    this.entries = entries == null ? new Entry[0] : entries;
+  }
+
+  /**
+   * @param entries The metadata entries.
+   */
+  public Metadata(List<? extends Entry> entries) {
+    if (entries != null) {
+      this.entries = new Entry[entries.size()];
+      entries.toArray(this.entries);
+    } else {
+      this.entries = new Entry[0];
+    }
+  }
+
+  /* package */ Metadata(Parcel in) {
+    entries = new Metadata.Entry[in.readInt()];
+    for (int i = 0; i < entries.length; i++) {
+      entries[i] = in.readParcelable(Entry.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of metadata entries.
+   */
+  public int length() {
+    return entries.length;
+  }
+
+  /**
+   * Returns the entry at the specified index.
+   *
+   * @param index The index of the entry.
+   * @return The entry at the specified index.
+   */
+  public Metadata.Entry get(int index) {
+    return entries[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    Metadata other = (Metadata) obj;
+    return Arrays.equals(entries, other.entries);
+  }
+
+  @Override
+  public int hashCode() {
+    return Arrays.hashCode(entries);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(entries.length);
+    for (Entry entry : entries) {
+      dest.writeParcelable(entry, 0);
+    }
+  }
+
+  public static final Parcelable.Creator<Metadata> CREATOR = new Parcelable.Creator<Metadata>() {
+    @Override
+    public Metadata createFromParcel(Parcel in) {
+      return new Metadata(in);
+    }
+
+    @Override
+    public Metadata[] newArray(int size) {
+      return new Metadata[0];
+    }
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
index 7cde1f243d..9137bad4fd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
@@ -17,27 +17,16 @@
 
 /**
  * Decodes metadata from binary data.
- *
- * @param <T> The type of the metadata.
  */
-public interface MetadataDecoder<T> {
-
-  /**
-   * Checks whether the decoder supports a given mime type.
-   *
-   * @param mimeType A metadata mime type.
-   * @return Whether the mime type is supported.
-   */
-  boolean canDecode(String mimeType);
+public interface MetadataDecoder {
 
   /**
-   * Decodes a metadata object from the provided binary data.
+   * Decodes a {@link Metadata} element from the provided input buffer.
    *
-   * @param data The raw binary data from which to decode the metadata.
-   * @param size The size of the input data.
+   * @param inputBuffer The input buffer to decode.
    * @return The decoded metadata object.
    * @throws MetadataDecoderException If a problem occurred decoding the data.
    */
-  T decode(byte[] data, int size) throws MetadataDecoderException;
+  Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
new file mode 100644
index 0000000000..414a8269d7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+/**
+ * A factory for {@link MetadataDecoder} instances.
+ */
+public interface MetadataDecoderFactory {
+
+  /**
+   * Returns whether the factory is able to instantiate a {@link MetadataDecoder} for the given
+   * {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return Whether the factory can instantiate a suitable {@link MetadataDecoder}.
+   */
+  boolean supportsFormat(Format format);
+
+  /**
+   * Creates a {@link MetadataDecoder} for the given {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return A new {@link MetadataDecoder}.
+   * @throws IllegalArgumentException If the {@link Format} is not supported.
+   */
+  MetadataDecoder createDecoder(Format format);
+
+  /**
+   * Default {@link MetadataDecoder} implementation.
+   * <p>
+   * The formats supported by this factory are:
+   * <ul>
+   * <li>ID3 ({@link Id3Decoder})</li>
+   * <li>EMSG ({@link EventMessageDecoder})</li>
+   * <li>SCTE-35 ({@link SpliceInfoDecoder})</li>
+   * </ul>
+   */
+  MetadataDecoderFactory DEFAULT = new MetadataDecoderFactory() {
+
+    @Override
+    public boolean supportsFormat(Format format) {
+      return getDecoderClass(format.sampleMimeType) != null;
+    }
+
+    @Override
+    public MetadataDecoder createDecoder(Format format) {
+      try {
+        Class<?> clazz = getDecoderClass(format.sampleMimeType);
+        if (clazz == null) {
+          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
+        }
+        return clazz.asSubclass(MetadataDecoder.class).getConstructor().newInstance();
+      } catch (Exception e) {
+        throw new IllegalStateException("Unexpected error instantiating decoder", e);
+      }
+    }
+
+    private Class<?> getDecoderClass(String mimeType) {
+      if (mimeType == null) {
+        return null;
+      }
+      try {
+        switch (mimeType) {
+          case MimeTypes.APPLICATION_ID3:
+            return Class.forName("com.google.android.exoplayer2.metadata.id3.Id3Decoder");
+          case MimeTypes.APPLICATION_EMSG:
+            return Class.forName("com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder");
+          case MimeTypes.APPLICATION_SCTE35:
+            return Class.forName("com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder");
+          default:
+            return null;
+        }
+      } catch (ClassNotFoundException e) {
+        return null;
+      }
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
new file mode 100644
index 0000000000..a09b565653
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+
+/**
+ * A {@link DecoderInputBuffer} for a {@link MetadataDecoder}.
+ */
+public final class MetadataInputBuffer extends DecoderInputBuffer {
+
+  /**
+   * An offset that must be added to the metadata's timestamps after it's been decoded, or
+   * {@link Format#OFFSET_SAMPLE_RELATIVE} if {@link #timeUs} should be added.
+   */
+  public long subsampleOffsetUs;
+
+  public MetadataInputBuffer() {
+    super(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index aca38a1258..550a13771f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -24,44 +24,51 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
-import java.nio.ByteBuffer;
 
 /**
  * A renderer for metadata.
- *
- * @param <T> The type of the metadata.
  */
-public final class MetadataRenderer<T> extends BaseRenderer implements Callback {
+public final class MetadataRenderer extends BaseRenderer implements Callback {
 
   /**
    * Receives output from a {@link MetadataRenderer}.
-   *
-   * @param <T> The type of the metadata.
    */
-  public interface Output<T> {
+  public interface Output {
 
     /**
      * Called each time there is a metadata associated with current playback time.
      *
      * @param metadata The metadata.
      */
-    void onMetadata(T metadata);
+    void onMetadata(Metadata metadata);
 
   }
 
   private static final int MSG_INVOKE_RENDERER = 0;
 
-  private final MetadataDecoder<T> metadataDecoder;
-  private final Output<T> output;
+  private final MetadataDecoderFactory decoderFactory;
+  private final Output output;
   private final Handler outputHandler;
   private final FormatHolder formatHolder;
-  private final DecoderInputBuffer buffer;
+  private final MetadataInputBuffer buffer;
 
+  private MetadataDecoder decoder;
   private boolean inputStreamEnded;
   private long pendingMetadataTimestamp;
-  private T pendingMetadata;
+  private Metadata pendingMetadata;
+
+  /**
+   * @param output The output.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
+   *     If the output makes use of standard Android UI components, then this should normally be the
+   *     looper associated with the application's main thread, which can be obtained using
+   *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
+   *     called directly on the player's internal rendering thread.
+   */
+  public MetadataRenderer(Output output, Looper outputLooper) {
+    this(output, outputLooper, MetadataDecoderFactory.DEFAULT);
+  }
 
   /**
    * @param output The output.
@@ -70,22 +77,26 @@
    *     looper associated with the application's main thread, which can be obtained using
    *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
    *     called directly on the player's internal rendering thread.
-   * @param metadataDecoder A decoder for the metadata.
+   * @param decoderFactory A factory from which to obtain {@link MetadataDecoder} instances.
    */
-  public MetadataRenderer(Output<T> output, Looper outputLooper,
-      MetadataDecoder<T> metadataDecoder) {
+  public MetadataRenderer(Output output, Looper outputLooper,
+      MetadataDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_METADATA);
     this.output = Assertions.checkNotNull(output);
     this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
-    this.metadataDecoder = Assertions.checkNotNull(metadataDecoder);
+    this.decoderFactory = Assertions.checkNotNull(decoderFactory);
     formatHolder = new FormatHolder();
-    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    buffer = new MetadataInputBuffer();
   }
 
   @Override
   public int supportsFormat(Format format) {
-    return metadataDecoder.canDecode(format.sampleMimeType) ? FORMAT_HANDLED
-        : FORMAT_UNSUPPORTED_TYPE;
+    return decoderFactory.supportsFormat(format) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+  }
+
+  @Override
+  protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
+    decoder = decoderFactory.createDecoder(formats[0]);
   }
 
   @Override
@@ -102,12 +113,16 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       if (result == C.RESULT_BUFFER_READ) {
         if (buffer.isEndOfStream()) {
           inputStreamEnded = true;
+        } else if (buffer.isDecodeOnly()) {
+          // Do nothing. Note this assumes that all metadata buffers can be decoded independently.
+          // If we ever need to support a metadata format where this is not the case, we'll need to
+          // pass the buffer to the decoder and discard the output.
         } else {
           pendingMetadataTimestamp = buffer.timeUs;
+          buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
+          buffer.flip();
           try {
-            buffer.flip();
-            ByteBuffer bufferData = buffer.data;
-            pendingMetadata = metadataDecoder.decode(bufferData.array(), bufferData.limit());
+            pendingMetadata = decoder.decode(buffer);
           } catch (MetadataDecoderException e) {
             throw ExoPlaybackException.createForRenderer(e, getIndex());
           }
@@ -124,6 +139,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
   @Override
   protected void onDisabled() {
     pendingMetadata = null;
+    decoder = null;
     super.onDisabled();
   }
 
@@ -137,7 +153,7 @@ public boolean isReady() {
     return true;
   }
 
-  private void invokeRenderer(T metadata) {
+  private void invokeRenderer(Metadata metadata) {
     if (outputHandler != null) {
       outputHandler.obtainMessage(MSG_INVOKE_RENDERER, metadata).sendToTarget();
     } else {
@@ -150,13 +166,13 @@ private void invokeRenderer(T metadata) {
   public boolean handleMessage(Message msg) {
     switch (msg.what) {
       case MSG_INVOKE_RENDERER:
-        invokeRendererInternal((T) msg.obj);
+        invokeRendererInternal((Metadata) msg.obj);
         return true;
     }
     return false;
   }
 
-  private void invokeRendererInternal(T metadata) {
+  private void invokeRendererInternal(Metadata metadata) {
     output.onMetadata(metadata);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
new file mode 100644
index 0000000000..9d6d0af60c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * An Event Message (emsg) as defined in ISO 23009-1.
+ */
+public final class EventMessage implements Metadata.Entry {
+
+  /**
+   * The message scheme.
+   */
+  public final String schemeIdUri;
+
+  /**
+   * The value for the event.
+   */
+  public final String value;
+
+  /**
+   * The duration of the event in milliseconds.
+   */
+  public final long durationMs;
+
+  /**
+   * The instance identifier.
+   */
+  public final long id;
+
+  /**
+   * The body of the message.
+   */
+  public final byte[] messageData;
+
+  // Lazily initialized hashcode.
+  private int hashCode;
+
+  /**
+   *
+   * @param schemeIdUri The message scheme.
+   * @param value The value for the event.
+   * @param durationMs The duration of the event in milliseconds.
+   * @param id The instance identifier.
+   * @param messageData The body of the message.
+   */
+  public EventMessage(String schemeIdUri, String value, long durationMs, long id,
+      byte[] messageData) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+    this.durationMs = durationMs;
+    this.id = id;
+    this.messageData = messageData;
+  }
+
+  /* package */ EventMessage(Parcel in) {
+    schemeIdUri = in.readString();
+    value = in.readString();
+    durationMs = in.readLong();
+    id = in.readLong();
+    messageData = in.createByteArray();
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      int result = 17;
+      result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
+      result = 31 * result + (value != null ? value.hashCode() : 0);
+      result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
+      result = 31 * result + (int) (id ^ (id >>> 32));
+      result = 31 * result + Arrays.hashCode(messageData);
+      hashCode = result;
+    }
+    return hashCode;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    EventMessage other = (EventMessage) obj;
+    return durationMs == other.durationMs && id == other.id
+        && Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value)
+        && Arrays.equals(messageData, other.messageData);
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(schemeIdUri);
+    dest.writeString(value);
+    dest.writeLong(durationMs);
+    dest.writeLong(id);
+    dest.writeByteArray(messageData);
+  }
+
+  public static final Parcelable.Creator<EventMessage> CREATOR =
+      new Parcelable.Creator<EventMessage>() {
+
+    @Override
+    public EventMessage createFromParcel(Parcel in) {
+      return new EventMessage(in);
+    }
+
+    @Override
+    public EventMessage[] newArray(int size) {
+      return new EventMessage[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
new file mode 100644
index 0000000000..fd6996aa80
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoder;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Decodes Event Message (emsg) atoms, as defined in ISO 23009-1.
+ * <p>
+ * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
+ * first byte of the scheme_id_uri field).
+ */
+public final class EventMessageDecoder implements MetadataDecoder {
+
+  @Override
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
+    ParsableByteArray emsgData = new ParsableByteArray(data, size);
+    String schemeIdUri = emsgData.readNullTerminatedString();
+    String value = emsgData.readNullTerminatedString();
+    long timescale = emsgData.readUnsignedInt();
+    emsgData.skipBytes(4); // presentation_time_delta
+    long durationMs = (emsgData.readUnsignedInt() * 1000) / timescale;
+    long id = emsgData.readUnsignedInt();
+    byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
index d2a04bdb94..c64be24a31 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ApicFrame.java
@@ -15,6 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
 /**
  * APIC (Attached Picture) ID3 frame.
  */
@@ -35,4 +40,58 @@ public ApicFrame(String mimeType, String description, int pictureType, byte[] pi
     this.pictureData = pictureData;
   }
 
+  /* package */ ApicFrame(Parcel in) {
+    super(ID);
+    mimeType = in.readString();
+    description = in.readString();
+    pictureType = in.readInt();
+    pictureData = in.createByteArray();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ApicFrame other = (ApicFrame) obj;
+    return pictureType == other.pictureType && Util.areEqual(mimeType, other.mimeType)
+        && Util.areEqual(description, other.description)
+        && Arrays.equals(pictureData, other.pictureData);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + pictureType;
+    result = 31 * result + (mimeType != null ? mimeType.hashCode() : 0);
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + Arrays.hashCode(pictureData);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(mimeType);
+    dest.writeString(description);
+    dest.writeInt(pictureType);
+    dest.writeByteArray(pictureData);
+  }
+
+  public static final Parcelable.Creator<ApicFrame> CREATOR = new Parcelable.Creator<ApicFrame>() {
+
+    @Override
+    public ApicFrame createFromParcel(Parcel in) {
+      return new ApicFrame(in);
+    }
+
+    @Override
+    public ApicFrame[] newArray(int size) {
+      return new ApicFrame[size];
+    }
+
+  };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
index 5bc4ce3829..f662c1d06f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/BinaryFrame.java
@@ -15,6 +15,10 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import android.os.Parcel;
+import android.os.Parcelable;
+import java.util.Arrays;
+
 /**
  * Binary ID3 frame.
  */
@@ -22,9 +26,55 @@
 
   public final byte[] data;
 
-  public BinaryFrame(String type, byte[] data) {
-    super(type);
+  public BinaryFrame(String id, byte[] data) {
+    super(id);
     this.data = data;
   }
 
+  /* package */ BinaryFrame(Parcel in) {
+    super(in.readString());
+    data = in.createByteArray();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    BinaryFrame other = (BinaryFrame) obj;
+    return id.equals(other.id) && Arrays.equals(data, other.data);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + id.hashCode();
+    result = 31 * result + Arrays.hashCode(data);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeByteArray(data);
+  }
+
+  public static final Parcelable.Creator<BinaryFrame> CREATOR =
+      new Parcelable.Creator<BinaryFrame>() {
+
+        @Override
+        public BinaryFrame createFromParcel(Parcel in) {
+          return new BinaryFrame(in);
+        }
+
+        @Override
+        public BinaryFrame[] newArray(int size) {
+          return new BinaryFrame[size];
+        }
+
+      };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
new file mode 100644
index 0000000000..c82f982aa7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter information ID3 frame.
+ */
+public final class ChapterFrame extends Id3Frame {
+
+  public static final String ID = "CHAP";
+
+  public final String chapterId;
+  public final int startTimeMs;
+  public final int endTimeMs;
+  /**
+   * The byte offset of the start of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long startOffset;
+  /**
+   * The byte offset of the end of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long endOffset;
+  private final Id3Frame[] subFrames;
+
+  public ChapterFrame(String chapterId, int startTimeMs, int endTimeMs, long startOffset,
+      long endOffset, Id3Frame[] subFrames) {
+    super(ID);
+    this.chapterId = chapterId;
+    this.startTimeMs = startTimeMs;
+    this.endTimeMs = endTimeMs;
+    this.startOffset = startOffset;
+    this.endOffset = endOffset;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterFrame(Parcel in) {
+    super(ID);
+    this.chapterId = in.readString();
+    this.startTimeMs = in.readInt();
+    this.endTimeMs = in.readInt();
+    this.startOffset = in.readLong();
+    this.endOffset = in.readLong();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterFrame other = (ChapterFrame) obj;
+    return startTimeMs == other.startTimeMs
+        && endTimeMs == other.endTimeMs
+        && startOffset == other.startOffset
+        && endOffset == other.endOffset
+        && Util.areEqual(chapterId, other.chapterId)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + startTimeMs;
+    result = 31 * result + endTimeMs;
+    result = 31 * result + (int) startOffset;
+    result = 31 * result + (int) endOffset;
+    result = 31 * result + (chapterId != null ? chapterId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(chapterId);
+    dest.writeInt(startTimeMs);
+    dest.writeInt(endTimeMs);
+    dest.writeLong(startOffset);
+    dest.writeLong(endOffset);
+    dest.writeInt(subFrames.length);
+    for (Id3Frame subFrame : subFrames) {
+      dest.writeParcelable(subFrame, 0);
+    }
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Creator<ChapterFrame> CREATOR = new Creator<ChapterFrame>() {
+
+    @Override
+    public ChapterFrame createFromParcel(Parcel in) {
+      return new ChapterFrame(in);
+    }
+
+    @Override
+    public ChapterFrame[] newArray(int size) {
+      return new ChapterFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
new file mode 100644
index 0000000000..d71d0863c7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter table of contents ID3 frame.
+ */
+public final class ChapterTocFrame extends Id3Frame {
+
+  public static final String ID = "CTOC";
+
+  public final String elementId;
+  public final boolean isRoot;
+  public final boolean isOrdered;
+  public final String[] children;
+  private final Id3Frame[] subFrames;
+
+  public ChapterTocFrame(String elementId, boolean isRoot, boolean isOrdered, String[] children,
+      Id3Frame[] subFrames) {
+    super(ID);
+    this.elementId = elementId;
+    this.isRoot = isRoot;
+    this.isOrdered = isOrdered;
+    this.children = children;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterTocFrame(Parcel in) {
+    super(ID);
+    this.elementId = in.readString();
+    this.isRoot = in.readByte() != 0;
+    this.isOrdered = in.readByte() != 0;
+    this.children = in.createStringArray();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterTocFrame other = (ChapterTocFrame) obj;
+    return isRoot == other.isRoot
+        && isOrdered == other.isOrdered
+        && Util.areEqual(elementId, other.elementId)
+        && Arrays.equals(children, other.children)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (isRoot ? 1 : 0);
+    result = 31 * result + (isOrdered ? 1 : 0);
+    result = 31 * result + (elementId != null ? elementId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(elementId);
+    dest.writeByte((byte) (isRoot ? 1 : 0));
+    dest.writeByte((byte) (isOrdered ? 1 : 0));
+    dest.writeStringArray(children);
+    dest.writeInt(subFrames.length);
+    for (int i = 0; i < subFrames.length; i++) {
+      dest.writeParcelable(subFrames[i], 0);
+    }
+  }
+
+  public static final Creator<ChapterTocFrame> CREATOR = new Creator<ChapterTocFrame>() {
+
+    @Override
+    public ChapterTocFrame createFromParcel(Parcel in) {
+      return new ChapterTocFrame(in);
+    }
+
+    @Override
+    public ChapterTocFrame[] newArray(int size) {
+      return new ChapterTocFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
new file mode 100644
index 0000000000..b7cc937ac4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/CommentFrame.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Comment ID3 frame.
+ */
+public final class CommentFrame extends Id3Frame {
+
+  public static final String ID = "COMM";
+
+  public final String language;
+  public final String description;
+  public final String text;
+
+  public CommentFrame(String language, String description, String text) {
+    super(ID);
+    this.language = language;
+    this.description = description;
+    this.text = text;
+  }
+
+  /* package */ CommentFrame(Parcel in) {
+    super(ID);
+    language = in.readString();
+    description = in.readString();
+    text = in.readString();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    CommentFrame other = (CommentFrame) obj;
+    return Util.areEqual(description, other.description) && Util.areEqual(language, other.language)
+        && Util.areEqual(text, other.text);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (language != null ? language.hashCode() : 0);
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (text != null ? text.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(language);
+    dest.writeString(text);
+  }
+
+  public static final Parcelable.Creator<CommentFrame> CREATOR =
+      new Parcelable.Creator<CommentFrame>() {
+
+        @Override
+        public CommentFrame createFromParcel(Parcel in) {
+          return new CommentFrame(in);
+        }
+
+        @Override
+        public CommentFrame[] newArray(int size) {
+          return new CommentFrame[size];
+        }
+
+      };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
index 4b77a69b27..79e145fc7c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/GeobFrame.java
@@ -15,6 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
 /**
  * GEOB (General Encapsulated Object) ID3 frame.
  */
@@ -35,4 +40,57 @@ public GeobFrame(String mimeType, String filename, String description, byte[] da
     this.data = data;
   }
 
+  /* package */ GeobFrame(Parcel in) {
+    super(ID);
+    mimeType = in.readString();
+    filename = in.readString();
+    description = in.readString();
+    data = in.createByteArray();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    GeobFrame other = (GeobFrame) obj;
+    return Util.areEqual(mimeType, other.mimeType) && Util.areEqual(filename, other.filename)
+        && Util.areEqual(description, other.description) && Arrays.equals(data, other.data);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (mimeType != null ? mimeType.hashCode() : 0);
+    result = 31 * result + (filename != null ? filename.hashCode() : 0);
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + Arrays.hashCode(data);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(mimeType);
+    dest.writeString(filename);
+    dest.writeString(description);
+    dest.writeByteArray(data);
+  }
+
+  public static final Parcelable.Creator<GeobFrame> CREATOR = new Parcelable.Creator<GeobFrame>() {
+
+    @Override
+    public GeobFrame createFromParcel(Parcel in) {
+      return new GeobFrame(in);
+    }
+
+    @Override
+    public GeobFrame[] newArray(int size) {
+      return new GeobFrame[size];
+    }
+
+  };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index 92c6efb530..16059ccfbf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -15,22 +15,35 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
-import com.google.android.exoplayer2.ParserException;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
-import com.google.android.exoplayer2.metadata.MetadataDecoderException;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 
 /**
- * Decodes individual TXXX text frames from raw ID3 data.
+ * Decodes ID3 tags.
  */
-public final class Id3Decoder implements MetadataDecoder<List<Id3Frame>> {
+public final class Id3Decoder implements MetadataDecoder {
+
+  private static final String TAG = "Id3Decoder";
+
+  /**
+   * The first three bytes of a well formed ID3 tag header.
+   */
+  public static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
+  /**
+   * Length of an ID3 tag header.
+   */
+  public static final int ID3_HEADER_LENGTH = 10;
 
   private static final int ID3_TEXT_ENCODING_ISO_8859_1 = 0;
   private static final int ID3_TEXT_ENCODING_UTF_16 = 1;
@@ -38,125 +51,277 @@
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
   @Override
-  public boolean canDecode(String mimeType) {
-    return mimeType.equals(MimeTypes.APPLICATION_ID3);
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    return decode(buffer.array(), buffer.limit());
   }
 
-  @Override
-  public List<Id3Frame> decode(byte[] data, int size) throws MetadataDecoderException {
+  /**
+   * Decodes ID3 tags.
+   *
+   * @param data The bytes to decode ID3 tags from.
+   * @param size Amount of bytes in {@code data} to read.
+   * @return A {@link Metadata} object containing the decoded ID3 tags.
+   */
+  public Metadata decode(byte[] data, int size) {
     List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
-    int id3Size = decodeId3Header(id3Data);
-
-    while (id3Size > 0) {
-      int frameId0 = id3Data.readUnsignedByte();
-      int frameId1 = id3Data.readUnsignedByte();
-      int frameId2 = id3Data.readUnsignedByte();
-      int frameId3 = id3Data.readUnsignedByte();
-      int frameSize = id3Data.readSynchSafeInt();
-      if (frameSize <= 1) {
-        break;
-      }
 
-      // Skip frame flags.
-      id3Data.skipBytes(2);
-
-      try {
-        Id3Frame frame;
-        if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
-          frame = decodeTxxxFrame(id3Data, frameSize);
-        } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
-          frame = decodePrivFrame(id3Data, frameSize);
-        } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
-          frame = decodeGeobFrame(id3Data, frameSize);
-        } else if (frameId0 == 'A' && frameId1 == 'P' && frameId2 == 'I' && frameId3 == 'C') {
-          frame = decodeApicFrame(id3Data, frameSize);
-        } else if (frameId0 == 'T') {
-          String id = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
-          frame = decodeTextInformationFrame(id3Data, frameSize, id);
+    Id3Header id3Header = decodeHeader(id3Data);
+    if (id3Header == null) {
+      return null;
+    }
+
+    int startPosition = id3Data.getPosition();
+    int framesSize = id3Header.framesSize;
+    if (id3Header.isUnsynchronized) {
+      framesSize = removeUnsynchronization(id3Data, id3Header.framesSize);
+    }
+    id3Data.setLimit(startPosition + framesSize);
+
+    boolean unsignedIntFrameSizeHack = false;
+    if (id3Header.majorVersion == 4) {
+      if (!validateV4Frames(id3Data, false)) {
+        if (validateV4Frames(id3Data, true)) {
+          unsignedIntFrameSizeHack = true;
         } else {
-          String id = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
-          frame = decodeBinaryFrame(id3Data, frameSize, id);
+          Log.w(TAG, "Failed to validate V4 ID3 tag");
+          return null;
         }
+      }
+    }
+
+    int frameHeaderSize = id3Header.majorVersion == 2 ? 6 : 10;
+    while (id3Data.bytesLeft() >= frameHeaderSize) {
+      Id3Frame frame = decodeFrame(id3Header.majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
+      if (frame != null) {
         id3Frames.add(frame);
-        id3Size -= frameSize + 10 /* header size */;
-      } catch (UnsupportedEncodingException e) {
-        throw new MetadataDecoderException("Unsupported encoding", e);
       }
     }
 
-    return Collections.unmodifiableList(id3Frames);
+    return new Metadata(id3Frames);
   }
 
-  private static int indexOfEos(byte[] data, int fromIndex, int encoding) {
-    int terminationPos = indexOfZeroByte(data, fromIndex);
+  /**
+   * @param data A {@link ParsableByteArray} from which the header should be read.
+   * @return The parsed header, or null if the ID3 tag is unsupported.
+   */
+  private static Id3Header decodeHeader(ParsableByteArray data) {
+    if (data.bytesLeft() < ID3_HEADER_LENGTH) {
+      Log.w(TAG, "Data too short to be an ID3 tag");
+      return null;
+    }
 
-    // For single byte encoding charsets, we're done.
-    if (encoding == ID3_TEXT_ENCODING_ISO_8859_1 || encoding == ID3_TEXT_ENCODING_UTF_8) {
-      return terminationPos;
+    int id = data.readUnsignedInt24();
+    if (id != ID3_TAG) {
+      Log.w(TAG, "Unexpected first three bytes of ID3 tag header: " + id);
+      return null;
     }
 
-    // Otherwise look for a second zero byte.
-    while (terminationPos < data.length - 1) {
-      if (terminationPos % 2 == 0 && data[terminationPos + 1] == (byte) 0) {
-        return terminationPos;
+    int majorVersion = data.readUnsignedByte();
+    data.skipBytes(1); // Skip minor version.
+    int flags = data.readUnsignedByte();
+    int framesSize = data.readSynchSafeInt();
+
+    if (majorVersion == 2) {
+      boolean isCompressed = (flags & 0x40) != 0;
+      if (isCompressed) {
+        Log.w(TAG, "Skipped ID3 tag with majorVersion=2 and undefined compression scheme");
+        return null;
       }
-      terminationPos = indexOfZeroByte(data, terminationPos + 1);
+    } else if (majorVersion == 3) {
+      boolean hasExtendedHeader = (flags & 0x40) != 0;
+      if (hasExtendedHeader) {
+        int extendedHeaderSize = data.readInt(); // Size excluding size field.
+        data.skipBytes(extendedHeaderSize);
+        framesSize -= (extendedHeaderSize + 4);
+      }
+    } else if (majorVersion == 4) {
+      boolean hasExtendedHeader = (flags & 0x40) != 0;
+      if (hasExtendedHeader) {
+        int extendedHeaderSize = data.readSynchSafeInt(); // Size including size field.
+        data.skipBytes(extendedHeaderSize - 4);
+        framesSize -= extendedHeaderSize;
+      }
+      boolean hasFooter = (flags & 0x10) != 0;
+      if (hasFooter) {
+        framesSize -= 10;
+      }
+    } else {
+      Log.w(TAG, "Skipped ID3 tag with unsupported majorVersion=" + majorVersion);
+      return null;
     }
 
-    return data.length;
+    // isUnsynchronized is advisory only in version 4. Frame level flags are used instead.
+    boolean isUnsynchronized = majorVersion < 4 && (flags & 0x80) != 0;
+    return new Id3Header(majorVersion, isUnsynchronized, framesSize);
   }
 
-  private static int indexOfZeroByte(byte[] data, int fromIndex) {
-    for (int i = fromIndex; i < data.length; i++) {
-      if (data[i] == (byte) 0) {
-        return i;
+  private static boolean validateV4Frames(ParsableByteArray id3Data,
+      boolean unsignedIntFrameSizeHack) {
+    int startPosition = id3Data.getPosition();
+    try {
+      while (id3Data.bytesLeft() >= 10) {
+        int id = id3Data.readInt();
+        int frameSize = id3Data.readUnsignedIntToInt();
+        int flags = id3Data.readUnsignedShort();
+        if (id == 0 && frameSize == 0 && flags == 0) {
+          return true;
+        } else {
+          if (!unsignedIntFrameSizeHack) {
+            // Parse the data size as a synchsafe integer, as per the spec.
+            if ((frameSize & 0x808080L) != 0) {
+              return false;
+            }
+            frameSize = (frameSize & 0xFF) | (((frameSize >> 8) & 0xFF) << 7)
+                | (((frameSize >> 16) & 0xFF) << 14) | (((frameSize >> 24) & 0xFF) << 21);
+          }
+          int minimumFrameSize = 0;
+          if ((flags & 0x0040) != 0 /* hasGroupIdentifier */) {
+            minimumFrameSize++;
+          }
+          if ((flags & 0x0001) != 0 /* hasDataLength */) {
+            minimumFrameSize += 4;
+          }
+          if (frameSize < minimumFrameSize) {
+            return false;
+          }
+          if (id3Data.bytesLeft() < frameSize) {
+            return false;
+          }
+          id3Data.skipBytes(frameSize); // flags
+        }
       }
+      return true;
+    } finally {
+      id3Data.setPosition(startPosition);
     }
-    return data.length;
-  }
-
-  private static int delimiterLength(int encodingByte) {
-    return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8)
-        ? 1 : 2;
   }
 
-  /**
-   * @param id3Buffer A {@link ParsableByteArray} from which data should be read.
-   * @return The size of ID3 frames in bytes, excluding the header and footer.
-   * @throws ParserException If ID3 file identifier != "ID3".
-   */
-  private static int decodeId3Header(ParsableByteArray id3Buffer) throws MetadataDecoderException {
-    int id1 = id3Buffer.readUnsignedByte();
-    int id2 = id3Buffer.readUnsignedByte();
-    int id3 = id3Buffer.readUnsignedByte();
-    if (id1 != 'I' || id2 != 'D' || id3 != '3') {
-      throw new MetadataDecoderException(String.format(Locale.US,
-          "Unexpected ID3 file identifier, expected \"ID3\", actual \"%c%c%c\".", id1, id2, id3));
-    }
-    id3Buffer.skipBytes(2); // Skip version.
-
-    int flags = id3Buffer.readUnsignedByte();
-    int id3Size = id3Buffer.readSynchSafeInt();
-
-    // Check if extended header presents.
-    if ((flags & 0x2) != 0) {
-      int extendedHeaderSize = id3Buffer.readSynchSafeInt();
-      if (extendedHeaderSize > 4) {
-        id3Buffer.skipBytes(extendedHeaderSize - 4);
+  private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
+      boolean unsignedIntFrameSizeHack, int frameHeaderSize) {
+    int frameId0 = id3Data.readUnsignedByte();
+    int frameId1 = id3Data.readUnsignedByte();
+    int frameId2 = id3Data.readUnsignedByte();
+    int frameId3 = majorVersion >= 3 ? id3Data.readUnsignedByte() : 0;
+
+    int frameSize;
+    if (majorVersion == 4) {
+      frameSize = id3Data.readUnsignedIntToInt();
+      if (!unsignedIntFrameSizeHack) {
+        frameSize = (frameSize & 0xFF) | (((frameSize >> 8) & 0xFF) << 7)
+            | (((frameSize >> 16) & 0xFF) << 14) | (((frameSize >> 24) & 0xFF) << 21);
       }
-      id3Size -= extendedHeaderSize;
+    } else if (majorVersion == 3) {
+      frameSize = id3Data.readUnsignedIntToInt();
+    } else /* id3Header.majorVersion == 2 */ {
+      frameSize = id3Data.readUnsignedInt24();
+    }
+
+    int flags = majorVersion >= 3 ? id3Data.readUnsignedShort() : 0;
+    if (frameId0 == 0 && frameId1 == 0 && frameId2 == 0 && frameId3 == 0 && frameSize == 0
+        && flags == 0) {
+      // We must be reading zero padding at the end of the tag.
+      id3Data.setPosition(id3Data.limit());
+      return null;
+    }
+
+    int nextFramePosition = id3Data.getPosition() + frameSize;
+    if (nextFramePosition > id3Data.limit()) {
+      Log.w(TAG, "Frame size exceeds remaining tag data");
+      id3Data.setPosition(id3Data.limit());
+      return null;
+    }
+
+    // Frame flags.
+    boolean isCompressed = false;
+    boolean isEncrypted = false;
+    boolean isUnsynchronized = false;
+    boolean hasDataLength = false;
+    boolean hasGroupIdentifier = false;
+    if (majorVersion == 3) {
+      isCompressed = (flags & 0x0080) != 0;
+      isEncrypted = (flags & 0x0040) != 0;
+      hasGroupIdentifier = (flags & 0x0020) != 0;
+      hasDataLength = isCompressed;
+    } else if (majorVersion == 4) {
+      hasGroupIdentifier = (flags & 0x0040) != 0;
+      isCompressed = (flags & 0x0008) != 0;
+      isEncrypted = (flags & 0x0004) != 0;
+      isUnsynchronized = (flags & 0x0002) != 0;
+      hasDataLength = (flags & 0x0001) != 0;
     }
 
-    // Check if footer presents.
-    if ((flags & 0x8) != 0) {
-      id3Size -= 10;
+    if (isCompressed || isEncrypted) {
+      Log.w(TAG, "Skipping unsupported compressed or encrypted frame");
+      id3Data.setPosition(nextFramePosition);
+      return null;
     }
 
-    return id3Size;
+    if (hasGroupIdentifier) {
+      frameSize--;
+      id3Data.skipBytes(1);
+    }
+    if (hasDataLength) {
+      frameSize -= 4;
+      id3Data.skipBytes(4);
+    }
+    if (isUnsynchronized) {
+      frameSize = removeUnsynchronization(id3Data, frameSize);
+    }
+
+    try {
+      Id3Frame frame;
+      if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X'
+          && (majorVersion == 2 || frameId3 == 'X')) {
+        frame = decodeTxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'T') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeTextInformationFrame(id3Data, frameSize, id);
+      } else if (frameId0 == 'W' && frameId1 == 'X' && frameId2 == 'X'
+          && (majorVersion == 2 || frameId3 == 'X')) {
+        frame = decodeWxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'W') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeUrlLinkFrame(id3Data, frameSize, id);
+      } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
+        frame = decodePrivFrame(id3Data, frameSize);
+      } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O'
+          && (frameId3 == 'B' || majorVersion == 2)) {
+        frame = decodeGeobFrame(id3Data, frameSize);
+      } else if (majorVersion == 2 ? (frameId0 == 'P' && frameId1 == 'I' && frameId2 == 'C')
+          : (frameId0 == 'A' && frameId1 == 'P' && frameId2 == 'I' && frameId3 == 'C')) {
+        frame = decodeApicFrame(id3Data, frameSize, majorVersion);
+      } else if (frameId0 == 'C' && frameId1 == 'O' && frameId2 == 'M'
+          && (frameId3 == 'M' || majorVersion == 2)) {
+        frame = decodeCommentFrame(id3Data, frameSize);
+      } else if (frameId0 == 'C' && frameId1 == 'H' && frameId2 == 'A' && frameId3 == 'P') {
+        frame = decodeChapterFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize);
+      } else if (frameId0 == 'C' && frameId1 == 'T' && frameId2 == 'O' && frameId3 == 'C') {
+        frame = decodeChapterTOCFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize);
+      } else {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeBinaryFrame(id3Data, frameSize, id);
+      }
+      return frame;
+    } catch (UnsupportedEncodingException e) {
+      Log.w(TAG, "Unsupported character encoding");
+      return null;
+    } finally {
+      id3Data.setPosition(nextFramePosition);
+    }
   }
 
-  private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
+  private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     int encoding = id3Data.readUnsignedByte();
     String charset = getCharsetName(encoding);
@@ -167,11 +332,74 @@ private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSiz
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    String value;
     int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
-    String value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    if (valueStartIndex < data.length) {
+      int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
+      value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    } else {
+      value = "";
+    }
 
-    return new TxxxFrame(description, value);
+    return new TextInformationFrame("TXXX", description, value);
+  }
+
+  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
+      int frameSize, String id) throws UnsupportedEncodingException {
+    if (frameSize <= 1) {
+      // Frame is empty or contains only the text encoding byte.
+      return new TextInformationFrame(id, null, "");
+    }
+
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int valueEndIndex = indexOfEos(data, 0, encoding);
+    String value = new String(data, 0, valueEndIndex, charset);
+
+    return new TextInformationFrame(id, null, value);
+  }
+
+  private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int descriptionEndIndex = indexOfEos(data, 0, encoding);
+    String description = new String(data, 0, descriptionEndIndex, charset);
+
+    String url;
+    int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    if (urlStartIndex < data.length) {
+      int urlEndIndex = indexOfZeroByte(data, urlStartIndex);
+      url = new String(data, urlStartIndex, urlEndIndex - urlStartIndex, "ISO-8859-1");
+    } else {
+      url = "";
+    }
+
+    return new UrlLinkFrame("WXXX", description, url);
+  }
+
+  private static UrlLinkFrame decodeUrlLinkFrame(ParsableByteArray id3Data, int frameSize,
+      String id) throws UnsupportedEncodingException {
+    if (frameSize == 0) {
+      // Frame is empty.
+      return new UrlLinkFrame(id, null, "");
+    }
+
+    byte[] data = new byte[frameSize];
+    id3Data.readBytes(data, 0, frameSize);
+
+    int urlEndIndex = indexOfZeroByte(data, 0);
+    String url = new String(data, 0, urlEndIndex, "ISO-8859-1");
+
+    return new UrlLinkFrame(id, null, url);
   }
 
   private static PrivFrame decodePrivFrame(ParsableByteArray id3Data, int frameSize)
@@ -215,16 +443,29 @@ private static GeobFrame decodeGeobFrame(ParsableByteArray id3Data, int frameSiz
     return new GeobFrame(mimeType, filename, description, objectData);
   }
 
-  private static ApicFrame decodeApicFrame(ParsableByteArray id3Data, int frameSize)
-      throws UnsupportedEncodingException {
+  private static ApicFrame decodeApicFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion) throws UnsupportedEncodingException {
     int encoding = id3Data.readUnsignedByte();
     String charset = getCharsetName(encoding);
 
     byte[] data = new byte[frameSize - 1];
     id3Data.readBytes(data, 0, frameSize - 1);
 
-    int mimeTypeEndIndex = indexOfZeroByte(data, 0);
-    String mimeType = new String(data, 0, mimeTypeEndIndex, "ISO-8859-1");
+    String mimeType;
+    int mimeTypeEndIndex;
+    if (majorVersion == 2) {
+      mimeTypeEndIndex = 2;
+      mimeType = "image/" + Util.toLowerInvariant(new String(data, 0, 3, "ISO-8859-1"));
+      if (mimeType.equals("image/jpg")) {
+        mimeType = "image/jpeg";
+      }
+    } else {
+      mimeTypeEndIndex = indexOfZeroByte(data, 0);
+      mimeType = Util.toLowerInvariant(new String(data, 0, mimeTypeEndIndex, "ISO-8859-1"));
+      if (mimeType.indexOf('/') == -1) {
+        mimeType = "image/" + mimeType;
+      }
+    }
 
     int pictureType = data[mimeTypeEndIndex + 1] & 0xFF;
 
@@ -239,18 +480,103 @@ private static ApicFrame decodeApicFrame(ParsableByteArray id3Data, int frameSiz
     return new ApicFrame(mimeType, description, pictureType, pictureData);
   }
 
-  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
-      int frameSize, String id) throws UnsupportedEncodingException {
+  private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
     int encoding = id3Data.readUnsignedByte();
     String charset = getCharsetName(encoding);
 
-    byte[] data = new byte[frameSize - 1];
-    id3Data.readBytes(data, 0, frameSize - 1);
+    byte[] data = new byte[3];
+    id3Data.readBytes(data, 0, 3);
+    String language = new String(data, 0, 3);
+
+    data = new byte[frameSize - 4];
+    id3Data.readBytes(data, 0, frameSize - 4);
 
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
-    return new TextInformationFrame(id, description);
+    String text;
+    int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    if (textStartIndex < data.length) {
+      int textEndIndex = indexOfEos(data, textStartIndex, encoding);
+      text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
+    } else {
+      text = "";
+    }
+
+    return new CommentFrame(language, description, text);
+  }
+
+  private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize)
+      throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int chapterIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String chapterId = new String(id3Data.data, framePosition, chapterIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(chapterIdEndIndex + 1);
+
+    int startTime = id3Data.readInt();
+    int endTime = id3Data.readInt();
+    long startOffset = id3Data.readUnsignedInt();
+    if (startOffset == 0xFFFFFFFFL) {
+      startOffset = C.POSITION_UNSET;
+    }
+    long endOffset = id3Data.readUnsignedInt();
+    if (endOffset == 0xFFFFFFFFL) {
+      endOffset = C.POSITION_UNSET;
+    }
+
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
+
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterFrame(chapterId, startTime, endTime, startOffset, endOffset, subFrameArray);
+  }
+
+  private static ChapterTocFrame decodeChapterTOCFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize)
+      throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int elementIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String elementId = new String(id3Data.data, framePosition, elementIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(elementIdEndIndex + 1);
+
+    int ctocFlags = id3Data.readUnsignedByte();
+    boolean isRoot = (ctocFlags & 0x0002) != 0;
+    boolean isOrdered = (ctocFlags & 0x0001) != 0;
+
+    int childCount = id3Data.readUnsignedByte();
+    String[] children = new String[childCount];
+    for (int i = 0; i < childCount; i++) {
+      int startIndex = id3Data.getPosition();
+      int endIndex = indexOfZeroByte(id3Data.data, startIndex);
+      children[i] = new String(id3Data.data, startIndex, endIndex - startIndex, "ISO-8859-1");
+      id3Data.setPosition(endIndex + 1);
+    }
+
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
+
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterTocFrame(elementId, isRoot, isOrdered, children, subFrameArray);
   }
 
   private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int frameSize,
@@ -261,8 +587,28 @@ private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int fram
     return new BinaryFrame(id, frame);
   }
 
+  /**
+   * Performs in-place removal of unsynchronization for {@code length} bytes starting from
+   * {@link ParsableByteArray#getPosition()}
+   *
+   * @param data Contains the data to be processed.
+   * @param length The length of the data to be processed.
+   * @return The length of the data after processing.
+   */
+  private static int removeUnsynchronization(ParsableByteArray data, int length) {
+    byte[] bytes = data.data;
+    for (int i = data.getPosition(); i + 1 < length; i++) {
+      if ((bytes[i] & 0xFF) == 0xFF && bytes[i + 1] == 0x00) {
+        System.arraycopy(bytes, i + 2, bytes, i + 1, length - i - 2);
+        length--;
+      }
+    }
+    return length;
+  }
+
   /**
    * Maps encoding byte from ID3v2 frame to a Charset.
+   *
    * @param encodingByte The value of encoding byte from ID3v2 frame.
    * @return Charset name.
    */
@@ -281,4 +627,51 @@ private static String getCharsetName(int encodingByte) {
     }
   }
 
+  private static int indexOfEos(byte[] data, int fromIndex, int encoding) {
+    int terminationPos = indexOfZeroByte(data, fromIndex);
+
+    // For single byte encoding charsets, we're done.
+    if (encoding == ID3_TEXT_ENCODING_ISO_8859_1 || encoding == ID3_TEXT_ENCODING_UTF_8) {
+      return terminationPos;
+    }
+
+    // Otherwise ensure an even index and look for a second zero byte.
+    while (terminationPos < data.length - 1) {
+      if (terminationPos % 2 == 0 && data[terminationPos + 1] == (byte) 0) {
+        return terminationPos;
+      }
+      terminationPos = indexOfZeroByte(data, terminationPos + 1);
+    }
+
+    return data.length;
+  }
+
+  private static int indexOfZeroByte(byte[] data, int fromIndex) {
+    for (int i = fromIndex; i < data.length; i++) {
+      if (data[i] == (byte) 0) {
+        return i;
+      }
+    }
+    return data.length;
+  }
+
+  private static int delimiterLength(int encodingByte) {
+    return (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8)
+        ? 1 : 2;
+  }
+
+  private static final class Id3Header {
+
+    private final int majorVersion;
+    private final boolean isUnsynchronized;
+    private final int framesSize;
+
+    public Id3Header(int majorVersion, boolean isUnsynchronized, int framesSize) {
+      this.majorVersion = majorVersion;
+      this.isUnsynchronized = isUnsynchronized;
+      this.framesSize = framesSize;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
index 903b32da4f..9948f730eb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Frame.java
@@ -15,10 +15,13 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
+
 /**
  * Base class for ID3 frames.
  */
-public abstract class Id3Frame {
+public abstract class Id3Frame implements Metadata.Entry {
 
   /**
    * The frame ID.
@@ -26,7 +29,12 @@
   public final String id;
 
   public Id3Frame(String id) {
-    this.id = id;
+    this.id = Assertions.checkNotNull(id);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
index bbfbd96b84..fe55f5ddc0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/PrivFrame.java
@@ -15,6 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
 /**
  * PRIV (Private) ID3 frame.
  */
@@ -31,4 +36,50 @@ public PrivFrame(String owner, byte[] privateData) {
     this.privateData = privateData;
   }
 
+  /* package */ PrivFrame(Parcel in) {
+    super(ID);
+    owner = in.readString();
+    privateData = in.createByteArray();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    PrivFrame other = (PrivFrame) obj;
+    return Util.areEqual(owner, other.owner) && Arrays.equals(privateData, other.privateData);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (owner != null ? owner.hashCode() : 0);
+    result = 31 * result + Arrays.hashCode(privateData);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(owner);
+    dest.writeByteArray(privateData);
+  }
+
+  public static final Parcelable.Creator<PrivFrame> CREATOR = new Parcelable.Creator<PrivFrame>() {
+
+    @Override
+    public PrivFrame createFromParcel(Parcel in) {
+      return new PrivFrame(in);
+    }
+
+    @Override
+    public PrivFrame[] newArray(int size) {
+      return new PrivFrame[size];
+    }
+
+  };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index ec05a8ff4b..6221062e33 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -15,16 +15,72 @@
  */
 package com.google.android.exoplayer2.metadata.id3;
 
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+
 /**
- * Text information ("T000" - "TZZZ", excluding "TXXX") ID3 frame.
+ * Text information ID3 frame.
  */
 public final class TextInformationFrame extends Id3Frame {
 
   public final String description;
+  public final String value;
 
-  public TextInformationFrame(String id, String description) {
+  public TextInformationFrame(String id, String description, String value) {
     super(id);
     this.description = description;
+    this.value = value;
+  }
+
+  /* package */ TextInformationFrame(Parcel in) {
+    super(in.readString());
+    description = in.readString();
+    value = in.readString();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    TextInformationFrame other = (TextInformationFrame) obj;
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(value, other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + id.hashCode();
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (value != null ? value.hashCode() : 0);
+    return result;
   }
 
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(description);
+    dest.writeString(value);
+  }
+
+  public static final Parcelable.Creator<TextInformationFrame> CREATOR =
+      new Parcelable.Creator<TextInformationFrame>() {
+
+        @Override
+        public TextInformationFrame createFromParcel(Parcel in) {
+          return new TextInformationFrame(in);
+        }
+
+        @Override
+        public TextInformationFrame[] newArray(int size) {
+          return new TextInformationFrame[size];
+        }
+
+      };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
new file mode 100644
index 0000000000..2148b921e1
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Url link ID3 frame.
+ */
+public final class UrlLinkFrame extends Id3Frame {
+
+  public final String description;
+  public final String url;
+
+  public UrlLinkFrame(String id, String description, String url) {
+    super(id);
+    this.description = description;
+    this.url = url;
+  }
+
+  /* package */ UrlLinkFrame(Parcel in) {
+    super(in.readString());
+    description = in.readString();
+    url = in.readString();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    UrlLinkFrame other = (UrlLinkFrame) obj;
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(url, other.url);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + id.hashCode();
+    result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (url != null ? url.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
+    dest.writeString(description);
+    dest.writeString(url);
+  }
+
+  public static final Parcelable.Creator<UrlLinkFrame> CREATOR =
+      new Parcelable.Creator<UrlLinkFrame>() {
+
+        @Override
+        public UrlLinkFrame createFromParcel(Parcel in) {
+          return new UrlLinkFrame(in);
+        }
+
+        @Override
+        public UrlLinkFrame[] newArray(int size) {
+          return new UrlLinkFrame[size];
+        }
+
+      };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
new file mode 100644
index 0000000000..beb4cb9b88
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/**
+ * Represents a private command as defined in SCTE35, Section 9.3.6.
+ */
+public final class PrivateCommand extends SpliceCommand {
+
+  public final long ptsAdjustment;
+  public final long identifier;
+  public final byte[] commandBytes;
+
+  private PrivateCommand(long identifier, byte[] commandBytes, long ptsAdjustment) {
+    this.ptsAdjustment = ptsAdjustment;
+    this.identifier = identifier;
+    this.commandBytes = commandBytes;
+  }
+
+  private PrivateCommand(Parcel in) {
+    ptsAdjustment = in.readLong();
+    identifier = in.readLong();
+    commandBytes = new byte[in.readInt()];
+    in.readByteArray(commandBytes);
+  }
+
+  /* package */ static PrivateCommand parseFromSection(ParsableByteArray sectionData,
+      int commandLength, long ptsAdjustment) {
+    long identifier = sectionData.readUnsignedInt();
+    byte[] privateBytes = new byte[commandLength - 4 /* identifier size */];
+    sectionData.readBytes(privateBytes, 0, privateBytes.length);
+    return new PrivateCommand(identifier, privateBytes, ptsAdjustment);
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeLong(ptsAdjustment);
+    dest.writeLong(identifier);
+    dest.writeInt(commandBytes.length);
+    dest.writeByteArray(commandBytes);
+  }
+
+  public static final Parcelable.Creator<PrivateCommand> CREATOR =
+      new Parcelable.Creator<PrivateCommand>() {
+
+    @Override
+    public PrivateCommand createFromParcel(Parcel in) {
+      return new PrivateCommand(in);
+    }
+
+    @Override
+    public PrivateCommand[] newArray(int size) {
+      return new PrivateCommand[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceCommand.java
similarity index 62%
rename from library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
rename to library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceCommand.java
index 6593c2f120..8dfa3b8942 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceCommand.java
@@ -13,22 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.metadata.id3;
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.metadata.Metadata;
 
 /**
- * TXXX (User defined text information) ID3 frame.
+ * Superclass for SCTE35 splice commands.
  */
-public final class TxxxFrame extends Id3Frame {
-
-  public static final String ID = "TXXX";
-
-  public final String description;
-  public final String value;
+public abstract class SpliceCommand implements Metadata.Entry {
 
-  public TxxxFrame(String description, String value) {
-    super(ID);
-    this.description = description;
-    this.value = value;
+  @Override
+  public int describeContents() {
+    return 0;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
new file mode 100644
index 0000000000..58c23d253a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoder;
+import com.google.android.exoplayer2.metadata.MetadataDecoderException;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
+
+/**
+ * Decodes splice info sections and produces splice commands.
+ */
+public final class SpliceInfoDecoder implements MetadataDecoder {
+
+  private static final int TYPE_SPLICE_NULL = 0x00;
+  private static final int TYPE_SPLICE_SCHEDULE = 0x04;
+  private static final int TYPE_SPLICE_INSERT = 0x05;
+  private static final int TYPE_TIME_SIGNAL = 0x06;
+  private static final int TYPE_PRIVATE_COMMAND = 0xFF;
+
+  private final ParsableByteArray sectionData;
+  private final ParsableBitArray sectionHeader;
+
+  private TimestampAdjuster timestampAdjuster;
+
+  public SpliceInfoDecoder() {
+    sectionData = new ParsableByteArray();
+    sectionHeader = new ParsableBitArray();
+  }
+
+  @Override
+  public Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException {
+    // Internal timestamps adjustment.
+    if (timestampAdjuster == null
+        || inputBuffer.subsampleOffsetUs != timestampAdjuster.getTimestampOffsetUs()) {
+      timestampAdjuster = new TimestampAdjuster(inputBuffer.timeUs);
+      timestampAdjuster.adjustSampleTimestamp(inputBuffer.timeUs - inputBuffer.subsampleOffsetUs);
+    }
+
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
+    sectionData.reset(data, size);
+    sectionHeader.reset(data, size);
+    // table_id(8), section_syntax_indicator(1), private_indicator(1), reserved(2),
+    // section_length(12), protocol_version(8), encrypted_packet(1), encryption_algorithm(6).
+    sectionHeader.skipBits(39);
+    long ptsAdjustment = sectionHeader.readBits(1);
+    ptsAdjustment = (ptsAdjustment << 32) | sectionHeader.readBits(32);
+    // cw_index(8), tier(12).
+    sectionHeader.skipBits(20);
+    int spliceCommandLength = sectionHeader.readBits(12);
+    int spliceCommandType = sectionHeader.readBits(8);
+    SpliceCommand command = null;
+    // Go to the start of the command by skipping all fields up to command_type.
+    sectionData.skipBytes(14);
+    switch (spliceCommandType) {
+      case TYPE_SPLICE_NULL:
+        command = new SpliceNullCommand();
+        break;
+      case TYPE_SPLICE_SCHEDULE:
+        command = SpliceScheduleCommand.parseFromSection(sectionData);
+        break;
+      case TYPE_SPLICE_INSERT:
+        command = SpliceInsertCommand.parseFromSection(sectionData, ptsAdjustment,
+            timestampAdjuster);
+        break;
+      case TYPE_TIME_SIGNAL:
+        command = TimeSignalCommand.parseFromSection(sectionData, ptsAdjustment, timestampAdjuster);
+        break;
+      case TYPE_PRIVATE_COMMAND:
+        command = PrivateCommand.parseFromSection(sectionData, spliceCommandLength, ptsAdjustment);
+        break;
+    }
+    return command == null ? new Metadata() : new Metadata(command);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
new file mode 100644
index 0000000000..7ce8b47e2a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Represents a splice insert command defined in SCTE35, Section 9.3.3.
+ */
+public final class SpliceInsertCommand extends SpliceCommand {
+
+  public final long spliceEventId;
+  public final boolean spliceEventCancelIndicator;
+  public final boolean outOfNetworkIndicator;
+  public final boolean programSpliceFlag;
+  public final boolean spliceImmediateFlag;
+  public final long programSplicePts;
+  public final long programSplicePlaybackPositionUs;
+  public final List<ComponentSplice> componentSpliceList;
+  public final boolean autoReturn;
+  public final long breakDuration;
+  public final int uniqueProgramId;
+  public final int availNum;
+  public final int availsExpected;
+
+  private SpliceInsertCommand(long spliceEventId, boolean spliceEventCancelIndicator,
+      boolean outOfNetworkIndicator, boolean programSpliceFlag, boolean spliceImmediateFlag,
+      long programSplicePts, long programSplicePlaybackPositionUs,
+      List<ComponentSplice> componentSpliceList, boolean autoReturn, long breakDuration,
+      int uniqueProgramId, int availNum, int availsExpected) {
+    this.spliceEventId = spliceEventId;
+    this.spliceEventCancelIndicator = spliceEventCancelIndicator;
+    this.outOfNetworkIndicator = outOfNetworkIndicator;
+    this.programSpliceFlag = programSpliceFlag;
+    this.spliceImmediateFlag = spliceImmediateFlag;
+    this.programSplicePts = programSplicePts;
+    this.programSplicePlaybackPositionUs = programSplicePlaybackPositionUs;
+    this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
+    this.autoReturn = autoReturn;
+    this.breakDuration = breakDuration;
+    this.uniqueProgramId = uniqueProgramId;
+    this.availNum = availNum;
+    this.availsExpected = availsExpected;
+  }
+
+  private SpliceInsertCommand(Parcel in) {
+    spliceEventId = in.readLong();
+    spliceEventCancelIndicator = in.readByte() == 1;
+    outOfNetworkIndicator = in.readByte() == 1;
+    programSpliceFlag = in.readByte() == 1;
+    spliceImmediateFlag = in.readByte() == 1;
+    programSplicePts = in.readLong();
+    programSplicePlaybackPositionUs = in.readLong();
+    int componentSpliceListSize = in.readInt();
+    List<ComponentSplice> componentSpliceList = new ArrayList<>(componentSpliceListSize);
+    for (int i = 0; i < componentSpliceListSize; i++) {
+      componentSpliceList.add(ComponentSplice.createFromParcel(in));
+    }
+    this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
+    autoReturn = in.readByte() == 1;
+    breakDuration = in.readLong();
+    uniqueProgramId = in.readInt();
+    availNum = in.readInt();
+    availsExpected = in.readInt();
+  }
+
+  /* package */ static SpliceInsertCommand parseFromSection(ParsableByteArray sectionData,
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
+    long spliceEventId = sectionData.readUnsignedInt();
+    // splice_event_cancel_indicator(1), reserved(7).
+    boolean spliceEventCancelIndicator = (sectionData.readUnsignedByte() & 0x80) != 0;
+    boolean outOfNetworkIndicator = false;
+    boolean programSpliceFlag = false;
+    boolean spliceImmediateFlag = false;
+    long programSplicePts = C.TIME_UNSET;
+    List<ComponentSplice> componentSplices = Collections.emptyList();
+    int uniqueProgramId = 0;
+    int availNum = 0;
+    int availsExpected = 0;
+    boolean autoReturn = false;
+    long duration = C.TIME_UNSET;
+    if (!spliceEventCancelIndicator) {
+      int headerByte = sectionData.readUnsignedByte();
+      outOfNetworkIndicator = (headerByte & 0x80) != 0;
+      programSpliceFlag = (headerByte & 0x40) != 0;
+      boolean durationFlag = (headerByte & 0x20) != 0;
+      spliceImmediateFlag = (headerByte & 0x10) != 0;
+      if (programSpliceFlag && !spliceImmediateFlag) {
+        programSplicePts = TimeSignalCommand.parseSpliceTime(sectionData, ptsAdjustment);
+      }
+      if (!programSpliceFlag) {
+        int componentCount = sectionData.readUnsignedByte();
+        componentSplices = new ArrayList<>(componentCount);
+        for (int i = 0; i < componentCount; i++) {
+          int componentTag = sectionData.readUnsignedByte();
+          long componentSplicePts = C.TIME_UNSET;
+          if (!spliceImmediateFlag) {
+            componentSplicePts = TimeSignalCommand.parseSpliceTime(sectionData, ptsAdjustment);
+          }
+          componentSplices.add(new ComponentSplice(componentTag, componentSplicePts,
+              timestampAdjuster.adjustTsTimestamp(componentSplicePts)));
+        }
+      }
+      if (durationFlag) {
+        long firstByte = sectionData.readUnsignedByte();
+        autoReturn = (firstByte & 0x80) != 0;
+        duration = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+      }
+      uniqueProgramId = sectionData.readUnsignedShort();
+      availNum = sectionData.readUnsignedByte();
+      availsExpected = sectionData.readUnsignedByte();
+    }
+    return new SpliceInsertCommand(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
+        programSpliceFlag, spliceImmediateFlag, programSplicePts,
+        timestampAdjuster.adjustTsTimestamp(programSplicePts), componentSplices, autoReturn,
+        duration, uniqueProgramId, availNum, availsExpected);
+  }
+
+  /**
+   * Holds splicing information for specific splice insert command components.
+   */
+  public static final class ComponentSplice {
+
+    public final int componentTag;
+    public final long componentSplicePts;
+    public final long componentSplicePlaybackPositionUs;
+
+    private ComponentSplice(int componentTag, long componentSplicePts,
+        long componentSplicePlaybackPositionUs) {
+      this.componentTag = componentTag;
+      this.componentSplicePts = componentSplicePts;
+      this.componentSplicePlaybackPositionUs = componentSplicePlaybackPositionUs;
+    }
+
+    public void writeToParcel(Parcel dest) {
+      dest.writeInt(componentTag);
+      dest.writeLong(componentSplicePts);
+      dest.writeLong(componentSplicePlaybackPositionUs);
+    }
+
+    public static ComponentSplice createFromParcel(Parcel in) {
+      return new ComponentSplice(in.readInt(), in.readLong(), in.readLong());
+    }
+
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeLong(spliceEventId);
+    dest.writeByte((byte) (spliceEventCancelIndicator ? 1 : 0));
+    dest.writeByte((byte) (outOfNetworkIndicator ? 1 : 0));
+    dest.writeByte((byte) (programSpliceFlag ? 1 : 0));
+    dest.writeByte((byte) (spliceImmediateFlag ? 1 : 0));
+    dest.writeLong(programSplicePts);
+    dest.writeLong(programSplicePlaybackPositionUs);
+    int componentSpliceListSize = componentSpliceList.size();
+    dest.writeInt(componentSpliceListSize);
+    for (int i = 0; i < componentSpliceListSize; i++) {
+      componentSpliceList.get(i).writeToParcel(dest);
+    }
+    dest.writeByte((byte) (autoReturn ? 1 : 0));
+    dest.writeLong(breakDuration);
+    dest.writeInt(uniqueProgramId);
+    dest.writeInt(availNum);
+    dest.writeInt(availsExpected);
+  }
+
+  public static final Parcelable.Creator<SpliceInsertCommand> CREATOR =
+      new Parcelable.Creator<SpliceInsertCommand>() {
+
+    @Override
+    public SpliceInsertCommand createFromParcel(Parcel in) {
+      return new SpliceInsertCommand(in);
+    }
+
+    @Override
+    public SpliceInsertCommand[] newArray(int size) {
+      return new SpliceInsertCommand[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceNullCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceNullCommand.java
new file mode 100644
index 0000000000..461d49ebb4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceNullCommand.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import android.os.Parcel;
+
+/**
+ * Represents a splice null command as defined in SCTE35, Section 9.3.1.
+ */
+public final class SpliceNullCommand extends SpliceCommand {
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    // Do nothing.
+  }
+
+  public static final Creator<SpliceNullCommand> CREATOR =
+      new Creator<SpliceNullCommand>() {
+
+    @Override
+    public SpliceNullCommand createFromParcel(Parcel in) {
+      return new SpliceNullCommand();
+    }
+
+    @Override
+    public SpliceNullCommand[] newArray(int size) {
+      return new SpliceNullCommand[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java
new file mode 100644
index 0000000000..9b391cea6c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceScheduleCommand.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Represents a splice schedule command as defined in SCTE35, Section 9.3.2.
+ */
+public final class SpliceScheduleCommand extends SpliceCommand {
+
+  /**
+   * Represents a splice event as contained in a {@link SpliceScheduleCommand}.
+   */
+  public static final class Event {
+
+    public final long spliceEventId;
+    public final boolean spliceEventCancelIndicator;
+    public final boolean outOfNetworkIndicator;
+    public final boolean programSpliceFlag;
+    public final long utcSpliceTime;
+    public final List<ComponentSplice> componentSpliceList;
+    public final boolean autoReturn;
+    public final long breakDuration;
+    public final int uniqueProgramId;
+    public final int availNum;
+    public final int availsExpected;
+
+    private Event(long spliceEventId, boolean spliceEventCancelIndicator,
+        boolean outOfNetworkIndicator, boolean programSpliceFlag,
+        List<ComponentSplice> componentSpliceList, long utcSpliceTime, boolean autoReturn,
+        long breakDuration, int uniqueProgramId, int availNum, int availsExpected) {
+      this.spliceEventId = spliceEventId;
+      this.spliceEventCancelIndicator = spliceEventCancelIndicator;
+      this.outOfNetworkIndicator = outOfNetworkIndicator;
+      this.programSpliceFlag = programSpliceFlag;
+      this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
+      this.utcSpliceTime = utcSpliceTime;
+      this.autoReturn = autoReturn;
+      this.breakDuration = breakDuration;
+      this.uniqueProgramId = uniqueProgramId;
+      this.availNum = availNum;
+      this.availsExpected = availsExpected;
+    }
+
+    private Event(Parcel in) {
+      this.spliceEventId = in.readLong();
+      this.spliceEventCancelIndicator = in.readByte() == 1;
+      this.outOfNetworkIndicator = in.readByte() == 1;
+      this.programSpliceFlag = in.readByte() == 1;
+      int componentSpliceListLength = in.readInt();
+      ArrayList<ComponentSplice> componentSpliceList = new ArrayList<>(componentSpliceListLength);
+      for (int i = 0; i < componentSpliceListLength; i++) {
+        componentSpliceList.add(ComponentSplice.createFromParcel(in));
+      }
+      this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
+      this.utcSpliceTime = in.readLong();
+      this.autoReturn = in.readByte() == 1;
+      this.breakDuration = in.readLong();
+      this.uniqueProgramId = in.readInt();
+      this.availNum = in.readInt();
+      this.availsExpected = in.readInt();
+    }
+
+    private static Event parseFromSection(ParsableByteArray sectionData) {
+      long spliceEventId = sectionData.readUnsignedInt();
+      // splice_event_cancel_indicator(1), reserved(7).
+      boolean spliceEventCancelIndicator = (sectionData.readUnsignedByte() & 0x80) != 0;
+      boolean outOfNetworkIndicator = false;
+      boolean programSpliceFlag = false;
+      long utcSpliceTime = C.TIME_UNSET;
+      ArrayList<ComponentSplice> componentSplices = new ArrayList<>();
+      int uniqueProgramId = 0;
+      int availNum = 0;
+      int availsExpected = 0;
+      boolean autoReturn = false;
+      long duration = C.TIME_UNSET;
+      if (!spliceEventCancelIndicator) {
+        int headerByte = sectionData.readUnsignedByte();
+        outOfNetworkIndicator = (headerByte & 0x80) != 0;
+        programSpliceFlag = (headerByte & 0x40) != 0;
+        boolean durationFlag = (headerByte & 0x20) != 0;
+        if (programSpliceFlag) {
+          utcSpliceTime = sectionData.readUnsignedInt();
+        }
+        if (!programSpliceFlag) {
+          int componentCount = sectionData.readUnsignedByte();
+          componentSplices = new ArrayList<>(componentCount);
+          for (int i = 0; i < componentCount; i++) {
+            int componentTag = sectionData.readUnsignedByte();
+            long componentUtcSpliceTime = sectionData.readUnsignedInt();
+            componentSplices.add(new ComponentSplice(componentTag, componentUtcSpliceTime));
+          }
+        }
+        if (durationFlag) {
+          long firstByte = sectionData.readUnsignedByte();
+          autoReturn = (firstByte & 0x80) != 0;
+          duration = ((firstByte & 0x01) << 32) | sectionData.readUnsignedInt();
+        }
+        uniqueProgramId = sectionData.readUnsignedShort();
+        availNum = sectionData.readUnsignedByte();
+        availsExpected = sectionData.readUnsignedByte();
+      }
+      return new Event(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
+          programSpliceFlag, componentSplices, utcSpliceTime, autoReturn, duration, uniqueProgramId,
+          availNum, availsExpected);
+    }
+
+    private void writeToParcel(Parcel dest) {
+      dest.writeLong(spliceEventId);
+      dest.writeByte((byte) (spliceEventCancelIndicator ? 1 : 0));
+      dest.writeByte((byte) (outOfNetworkIndicator ? 1 : 0));
+      dest.writeByte((byte) (programSpliceFlag ? 1 : 0));
+      int componentSpliceListSize = componentSpliceList.size();
+      dest.writeInt(componentSpliceListSize);
+      for (int i = 0; i < componentSpliceListSize; i++) {
+        componentSpliceList.get(i).writeToParcel(dest);
+      }
+      dest.writeLong(utcSpliceTime);
+      dest.writeByte((byte) (autoReturn ? 1 : 0));
+      dest.writeLong(breakDuration);
+      dest.writeInt(uniqueProgramId);
+      dest.writeInt(availNum);
+      dest.writeInt(availsExpected);
+    }
+
+    private static Event createFromParcel(Parcel in) {
+      return new Event(in);
+    }
+
+  }
+
+  /**
+   * Holds splicing information for specific splice schedule command components.
+   */
+  public static final class ComponentSplice {
+
+    public final int componentTag;
+    public final long utcSpliceTime;
+
+    private ComponentSplice(int componentTag, long utcSpliceTime) {
+      this.componentTag = componentTag;
+      this.utcSpliceTime = utcSpliceTime;
+    }
+
+    private static ComponentSplice createFromParcel(Parcel in) {
+      return new ComponentSplice(in.readInt(), in.readLong());
+    }
+
+    private void writeToParcel(Parcel dest) {
+      dest.writeInt(componentTag);
+      dest.writeLong(utcSpliceTime);
+    }
+
+  }
+
+  public final List<Event> events;
+
+  private SpliceScheduleCommand(List<Event> events) {
+    this.events = Collections.unmodifiableList(events);
+  }
+
+  private SpliceScheduleCommand(Parcel in) {
+    int eventsSize = in.readInt();
+    ArrayList<Event> events = new ArrayList<>(eventsSize);
+    for (int i = 0; i < eventsSize; i++) {
+      events.add(Event.createFromParcel(in));
+    }
+    this.events = Collections.unmodifiableList(events);
+  }
+
+  /* package */ static SpliceScheduleCommand parseFromSection(ParsableByteArray sectionData) {
+    int spliceCount = sectionData.readUnsignedByte();
+    ArrayList<Event> events = new ArrayList<>(spliceCount);
+    for (int i = 0; i < spliceCount; i++) {
+      events.add(Event.parseFromSection(sectionData));
+    }
+    return new SpliceScheduleCommand(events);
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    int eventsSize = events.size();
+    dest.writeInt(eventsSize);
+    for (int i = 0; i < eventsSize; i++) {
+      events.get(i).writeToParcel(dest);
+    }
+  }
+
+  public static final Parcelable.Creator<SpliceScheduleCommand> CREATOR =
+      new Parcelable.Creator<SpliceScheduleCommand>() {
+
+    @Override
+    public SpliceScheduleCommand createFromParcel(Parcel in) {
+      return new SpliceScheduleCommand(in);
+    }
+
+    @Override
+    public SpliceScheduleCommand[] newArray(int size) {
+      return new SpliceScheduleCommand[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
new file mode 100644
index 0000000000..f756b72d6d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+
+/**
+ * Represents a time signal command as defined in SCTE35, Section 9.3.4.
+ */
+public final class TimeSignalCommand extends SpliceCommand {
+
+  public final long ptsTime;
+  public final long playbackPositionUs;
+
+  private TimeSignalCommand(long ptsTime, long playbackPositionUs) {
+    this.ptsTime = ptsTime;
+    this.playbackPositionUs = playbackPositionUs;
+  }
+
+  /* package */ static TimeSignalCommand parseFromSection(ParsableByteArray sectionData,
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
+    long ptsTime = parseSpliceTime(sectionData, ptsAdjustment);
+    long playbackPositionUs = timestampAdjuster.adjustTsTimestamp(ptsTime);
+    return new TimeSignalCommand(ptsTime, playbackPositionUs);
+  }
+
+  /**
+   * Parses pts_time from splice_time(), defined in Section 9.4.1. Returns {@link C#TIME_UNSET}, if
+   * time_specified_flag is false.
+   *
+   * @param sectionData The section data from which the pts_time is parsed.
+   * @param ptsAdjustment The pts adjustment provided by the splice info section header.
+   * @return The pts_time defined by splice_time(), or {@link C#TIME_UNSET}, if time_specified_flag
+   *     is false.
+   */
+  /* package */ static long parseSpliceTime(ParsableByteArray sectionData, long ptsAdjustment) {
+    long firstByte = sectionData.readUnsignedByte();
+    long ptsTime = C.TIME_UNSET;
+    if ((firstByte & 0x80) != 0 /* time_specified_flag */) {
+      // See SCTE35 9.2.1 for more information about pts adjustment.
+      ptsTime = (firstByte & 0x01) << 32 | sectionData.readUnsignedInt();
+      ptsTime += ptsAdjustment;
+      ptsTime &= 0x1FFFFFFFFL;
+    }
+    return ptsTime;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeLong(ptsTime);
+    dest.writeLong(playbackPositionUs);
+  }
+
+  public static final Creator<TimeSignalCommand> CREATOR =
+      new Creator<TimeSignalCommand>() {
+
+    @Override
+    public TimeSignalCommand createFromParcel(Parcel in) {
+      return new TimeSignalCommand(in.readLong(), in.readLong());
+    }
+
+    @Override
+    public TimeSignalCommand[] newArray(int size) {
+      return new TimeSignalCommand[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java b/library/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
index 77b49f2be0..f97d4a1542 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer2.source;
 
-import static com.google.android.exoplayer2.C.usToMs;
-
 import android.os.Handler;
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
@@ -174,10 +172,21 @@ void onDownstreamFormatChanged(int trackType, Format trackFormat, int trackSelec
 
     private final Handler handler;
     private final AdaptiveMediaSourceEventListener listener;
+    private final long mediaTimeOffsetMs;
 
     public EventDispatcher(Handler handler, AdaptiveMediaSourceEventListener listener) {
+      this(handler, listener, 0);
+    }
+
+    public EventDispatcher(Handler handler, AdaptiveMediaSourceEventListener listener,
+        long mediaTimeOffsetMs) {
       this.handler = listener != null ? Assertions.checkNotNull(handler) : null;
       this.listener = listener;
+      this.mediaTimeOffsetMs = mediaTimeOffsetMs;
+    }
+
+    public EventDispatcher copyWithMediaTimeOffsetMs(long mediaTimeOffsetMs) {
+      return new EventDispatcher(handler, listener, mediaTimeOffsetMs);
     }
 
     public void loadStarted(DataSpec dataSpec, int dataType, long elapsedRealtimeMs) {
@@ -193,8 +202,8 @@ public void loadStarted(final DataSpec dataSpec, final int dataType, final int t
           @Override
           public void run() {
             listener.onLoadStarted(dataSpec, dataType, trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs),
-                elapsedRealtimeMs);
+                trackSelectionData, adjustMediaTime(mediaStartTimeUs),
+                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs);
           }
         });
       }
@@ -215,8 +224,8 @@ public void loadCompleted(final DataSpec dataSpec, final int dataType, final int
           @Override
           public void run() {
             listener.onLoadCompleted(dataSpec, dataType, trackType, trackFormat,
-                trackSelectionReason, trackSelectionData, usToMs(mediaStartTimeUs),
-                usToMs(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
+                trackSelectionReason, trackSelectionData, adjustMediaTime(mediaStartTimeUs),
+                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
           }
         });
       }
@@ -237,8 +246,8 @@ public void loadCanceled(final DataSpec dataSpec, final int dataType, final int
           @Override
           public void run() {
             listener.onLoadCanceled(dataSpec, dataType, trackType, trackFormat,
-                trackSelectionReason, trackSelectionData, usToMs(mediaStartTimeUs),
-                usToMs(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
+                trackSelectionReason, trackSelectionData, adjustMediaTime(mediaStartTimeUs),
+                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
           }
         });
       }
@@ -261,8 +270,9 @@ public void loadError(final DataSpec dataSpec, final int dataType, final int tra
           @Override
           public void run() {
             listener.onLoadError(dataSpec, dataType, trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, usToMs(mediaStartTimeUs), usToMs(mediaEndTimeUs),
-                elapsedRealtimeMs, loadDurationMs, bytesLoaded, error, wasCanceled);
+                trackSelectionData, adjustMediaTime(mediaStartTimeUs),
+                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded,
+                error, wasCanceled);
           }
         });
       }
@@ -274,8 +284,8 @@ public void upstreamDiscarded(final int trackType, final long mediaStartTimeUs,
         handler.post(new Runnable()  {
           @Override
           public void run() {
-            listener.onUpstreamDiscarded(trackType, usToMs(mediaStartTimeUs),
-                usToMs(mediaEndTimeUs));
+            listener.onUpstreamDiscarded(trackType, adjustMediaTime(mediaStartTimeUs),
+                adjustMediaTime(mediaEndTimeUs));
           }
         });
       }
@@ -289,12 +299,17 @@ public void downstreamFormatChanged(final int trackType, final Format trackForma
           @Override
           public void run() {
             listener.onDownstreamFormatChanged(trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, usToMs(mediaTimeUs));
+                trackSelectionData, adjustMediaTime(mediaTimeUs));
           }
         });
       }
     }
 
+    private long adjustMediaTime(long mediaTimeUs) {
+      long mediaTimeMs = C.usToMs(mediaTimeUs);
+      return mediaTimeMs == C.TIME_UNSET ? C.TIME_UNSET : mediaTimeOffsetMs + mediaTimeMs;
+    }
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
new file mode 100644
index 0000000000..b18eabf493
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+
+/**
+ * Wraps a {@link MediaPeriod} and clips its {@link SampleStream}s to provide a subsequence of their
+ * samples.
+ */
+public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
+
+  /**
+   * The {@link MediaPeriod} wrapped by this clipping media period.
+   */
+  public final MediaPeriod mediaPeriod;
+
+  private MediaPeriod.Callback callback;
+  private long startUs;
+  private long endUs;
+  private ClippingSampleStream[] sampleStreams;
+  private boolean pendingInitialDiscontinuity;
+
+  /**
+   * Creates a new clipping media period that provides a clipped view of the specified
+   * {@link MediaPeriod}'s sample streams.
+   * <p>
+   * The clipping start/end positions must be specified by calling {@link #setClipping(long, long)}
+   * on the playback thread before preparation completes.
+   *
+   * @param mediaPeriod The media period to clip.
+   */
+  public ClippingMediaPeriod(MediaPeriod mediaPeriod) {
+    this.mediaPeriod = mediaPeriod;
+    startUs = C.TIME_UNSET;
+    endUs = C.TIME_UNSET;
+    sampleStreams = new ClippingSampleStream[0];
+  }
+
+  /**
+   * Sets the clipping start/end times for this period, in microseconds.
+   *
+   * @param startUs The clipping start time, in microseconds.
+   * @param endUs The clipping end time, in microseconds, or {@link C#TIME_END_OF_SOURCE} to
+   *     indicate the end of the period.
+   */
+  public void setClipping(long startUs, long endUs) {
+    this.startUs = startUs;
+    this.endUs = endUs;
+  }
+
+  @Override
+  public void prepare(MediaPeriod.Callback callback) {
+    this.callback = callback;
+    mediaPeriod.prepare(this);
+  }
+
+  @Override
+  public void maybeThrowPrepareError() throws IOException {
+    mediaPeriod.maybeThrowPrepareError();
+  }
+
+  @Override
+  public TrackGroupArray getTrackGroups() {
+    return mediaPeriod.getTrackGroups();
+  }
+
+  @Override
+  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+    sampleStreams = new ClippingSampleStream[streams.length];
+    SampleStream[] internalStreams = new SampleStream[streams.length];
+    for (int i = 0; i < streams.length; i++) {
+      sampleStreams[i] = (ClippingSampleStream) streams[i];
+      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
+    }
+    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
+        internalStreams, streamResetFlags, positionUs + startUs);
+    Assertions.checkState(enablePositionUs == positionUs + startUs
+        || (enablePositionUs >= startUs
+        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
+    for (int i = 0; i < streams.length; i++) {
+      if (internalStreams[i] == null) {
+        sampleStreams[i] = null;
+      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
+        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
+            pendingInitialDiscontinuity);
+      }
+      streams[i] = sampleStreams[i];
+    }
+    return enablePositionUs - startUs;
+  }
+
+  @Override
+  public long readDiscontinuity() {
+    if (pendingInitialDiscontinuity) {
+      for (ClippingSampleStream sampleStream : sampleStreams) {
+        if (sampleStream != null) {
+          sampleStream.clearPendingDiscontinuity();
+        }
+      }
+      pendingInitialDiscontinuity = false;
+      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
+      long discontinuityUs = readDiscontinuity();
+      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
+    }
+    long discontinuityUs = mediaPeriod.readDiscontinuity();
+    if (discontinuityUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
+    Assertions.checkState(discontinuityUs >= startUs);
+    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
+    return discontinuityUs - startUs;
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
+    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return Math.max(0, bufferedPositionUs - startUs);
+  }
+
+  @Override
+  public long seekToUs(long positionUs) {
+    for (ClippingSampleStream sampleStream : sampleStreams) {
+      if (sampleStream != null) {
+        sampleStream.clearSentEos();
+      }
+    }
+    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
+    Assertions.checkState(seekUs == positionUs + startUs
+        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
+    return seekUs - startUs;
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
+    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return nextLoadPositionUs - startUs;
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
+    return mediaPeriod.continueLoading(positionUs + startUs);
+  }
+
+  // MediaPeriod.Callback implementation.
+
+  @Override
+  public void onPrepared(MediaPeriod mediaPeriod) {
+    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
+    // If the clipping start position is non-zero, the clipping sample streams will adjust
+    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
+    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
+    // which may be before the clipping start point. When the renderer reads a buffer with a
+    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
+    // read in the previous period. Renderer implementations may not allow this, so we signal a
+    // discontinuity which resets the renderers before they read the clipping sample stream.
+    pendingInitialDiscontinuity = startUs != 0;
+    callback.onPrepared(this);
+  }
+
+  @Override
+  public void onContinueLoadingRequested(MediaPeriod source) {
+    callback.onContinueLoadingRequested(this);
+  }
+
+  /**
+   * Wraps a {@link SampleStream} and clips its samples.
+   */
+  private static final class ClippingSampleStream implements SampleStream {
+
+    private final MediaPeriod mediaPeriod;
+    private final SampleStream stream;
+    private final long startUs;
+    private final long endUs;
+
+    private boolean pendingDiscontinuity;
+    private boolean sentEos;
+
+    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
+        long endUs, boolean pendingDiscontinuity) {
+      this.mediaPeriod = mediaPeriod;
+      this.stream = stream;
+      this.startUs = startUs;
+      this.endUs = endUs;
+      this.pendingDiscontinuity = pendingDiscontinuity;
+    }
+
+    public void clearPendingDiscontinuity() {
+      pendingDiscontinuity = false;
+    }
+
+    public void clearSentEos() {
+      sentEos = false;
+    }
+
+    @Override
+    public boolean isReady() {
+      return stream.isReady();
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      stream.maybeThrowError();
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+      if (pendingDiscontinuity) {
+        return C.RESULT_NOTHING_READ;
+      }
+      if (buffer == null) {
+        return stream.readData(formatHolder, null);
+      }
+      if (sentEos) {
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+      int result = stream.readData(formatHolder, buffer);
+      // TODO: Clear gapless playback metadata if a format was read (if applicable).
+      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
+          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
+          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
+        buffer.clear();
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        sentEos = true;
+        return C.RESULT_BUFFER_READ;
+      }
+      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
+        buffer.timeUs -= startUs;
+      }
+      return result;
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+      stream.skipToKeyframeBefore(startUs + timeUs);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
new file mode 100644
index 0000000000..be15a07726
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * {@link MediaSource} that wraps a source and clips its timeline based on specified start/end
+ * positions. The wrapped source may only have a single period/window and it must not be dynamic
+ * (live).
+ */
+public final class ClippingMediaSource implements MediaSource, MediaSource.Listener {
+
+  private final MediaSource mediaSource;
+  private final long startUs;
+  private final long endUs;
+  private final ArrayList<ClippingMediaPeriod> mediaPeriods;
+
+  private MediaSource.Listener sourceListener;
+  private ClippingTimeline clippingTimeline;
+
+  /**
+   * Creates a new clipping source that wraps the specified source.
+   *
+   * @param mediaSource The single-period, non-dynamic source to wrap.
+   * @param startPositionUs The start position within {@code mediaSource}'s timeline at which to
+   *     start providing samples, in microseconds.
+   * @param endPositionUs The end position within {@code mediaSource}'s timeline at which to stop
+   *     providing samples, in microseconds. Specify {@link C#TIME_END_OF_SOURCE} to provide samples
+   *     from the specified start point up to the end of the source.
+   */
+  public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long endPositionUs) {
+    Assertions.checkArgument(startPositionUs >= 0);
+    this.mediaSource = Assertions.checkNotNull(mediaSource);
+    startUs = startPositionUs;
+    endUs = endPositionUs;
+    mediaPeriods = new ArrayList<>();
+  }
+
+  @Override
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    this.sourceListener = listener;
+    mediaSource.prepareSource(player, false, this);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    mediaSource.maybeThrowSourceInfoRefreshError();
+  }
+
+  @Override
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+    ClippingMediaPeriod mediaPeriod = new ClippingMediaPeriod(
+        mediaSource.createPeriod(index, allocator, startUs + positionUs));
+    mediaPeriods.add(mediaPeriod);
+    mediaPeriod.setClipping(clippingTimeline.startUs, clippingTimeline.endUs);
+    return mediaPeriod;
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {
+    Assertions.checkState(mediaPeriods.remove(mediaPeriod));
+    mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+  }
+
+  @Override
+  public void releaseSource() {
+    mediaSource.releaseSource();
+  }
+
+  // MediaSource.Listener implementation.
+
+  @Override
+  public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    clippingTimeline = new ClippingTimeline(timeline, startUs, endUs);
+    sourceListener.onSourceInfoRefreshed(clippingTimeline, manifest);
+    long startUs = clippingTimeline.startUs;
+    long endUs = clippingTimeline.endUs == C.TIME_UNSET ? C.TIME_END_OF_SOURCE
+        : clippingTimeline.endUs;
+    int count = mediaPeriods.size();
+    for (int i = 0; i < count; i++) {
+      mediaPeriods.get(i).setClipping(startUs, endUs);
+    }
+  }
+
+  /**
+   * Provides a clipped view of a specified timeline.
+   */
+  private static final class ClippingTimeline extends Timeline {
+
+    private final Timeline timeline;
+    private final long startUs;
+    private final long endUs;
+
+    /**
+     * Creates a new clipping timeline that wraps the specified timeline.
+     *
+     * @param timeline The timeline to clip.
+     * @param startUs The number of microseconds to clip from the start of {@code timeline}.
+     * @param endUs The end position in microseconds for the clipped timeline relative to the start
+     *     of {@code timeline}, or {@link C#TIME_END_OF_SOURCE} to clip no samples from the end.
+     */
+    public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
+      Assertions.checkArgument(timeline.getWindowCount() == 1);
+      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+      Window window = timeline.getWindow(0, new Window(), false);
+      Assertions.checkArgument(!window.isDynamic);
+      long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : endUs;
+      if (window.durationUs != C.TIME_UNSET) {
+        Assertions.checkArgument(startUs == 0 || window.isSeekable);
+        Assertions.checkArgument(resolvedEndUs <= window.durationUs);
+        Assertions.checkArgument(startUs <= resolvedEndUs);
+      }
+      Period period = timeline.getPeriod(0, new Period());
+      Assertions.checkArgument(period.getPositionInWindowUs() == 0);
+      this.timeline = timeline;
+      this.startUs = startUs;
+      this.endUs = resolvedEndUs;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return 1;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      window = timeline.getWindow(0, window, setIds, defaultPositionProjectionUs);
+      window.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      if (window.defaultPositionUs != C.TIME_UNSET) {
+        window.defaultPositionUs = Math.max(window.defaultPositionUs, startUs);
+        window.defaultPositionUs = endUs == C.TIME_UNSET ? window.defaultPositionUs
+            : Math.min(window.defaultPositionUs, endUs);
+        window.defaultPositionUs -= startUs;
+      }
+      long startMs = C.usToMs(startUs);
+      if (window.presentationStartTimeMs != C.TIME_UNSET) {
+        window.presentationStartTimeMs += startMs;
+      }
+      if (window.windowStartTimeMs != C.TIME_UNSET) {
+        window.windowStartTimeMs += startMs;
+      }
+      return window;
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return 1;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      period = timeline.getPeriod(0, period, setIds);
+      period.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      return period;
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      return timeline.getIndexOfPeriod(uid);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 3b743c5fda..68552c99ed 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -17,6 +17,7 @@
 
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Util;
@@ -53,12 +54,12 @@ public ConcatenatingMediaSource(MediaSource... mediaSources) {
   }
 
   @Override
-  public void prepareSource(Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     this.listener = listener;
     for (int i = 0; i < mediaSources.length; i++) {
       if (!duplicateFlags[i]) {
         final int index = i;
-        mediaSources[i].prepareSource(new Listener() {
+        mediaSources[i].prepareSource(player, false, new Listener() {
           @Override
           public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
             handleSourceInfoRefreshed(index, timeline, manifest);
@@ -171,11 +172,13 @@ public int getWindowCount() {
     }
 
     @Override
-    public Window getWindow(int windowIndex, Window window, boolean setIds) {
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
       int sourceIndex = getSourceIndexForWindow(windowIndex);
       int firstWindowIndexInSource = getFirstWindowIndexInSource(sourceIndex);
       int firstPeriodIndexInSource = getFirstPeriodIndexInSource(sourceIndex);
-      timelines[sourceIndex].getWindow(windowIndex - firstWindowIndexInSource, window, setIds);
+      timelines[sourceIndex].getWindow(windowIndex - firstWindowIndexInSource, window, setIds,
+          defaultPositionProjectionUs);
       window.firstPeriodIndex += firstPeriodIndexInSource;
       window.lastPeriodIndex += firstPeriodIndexInSource;
       return window;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 27bd1f677f..5226043593 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -39,6 +39,7 @@
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
@@ -62,6 +63,7 @@
   private final ExtractorMediaSource.EventListener eventListener;
   private final MediaSource.Listener sourceListener;
   private final Allocator allocator;
+  private final String customCacheKey;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
   private final ConditionVariable loadCondition;
@@ -81,6 +83,8 @@
   private TrackGroupArray tracks;
   private long durationUs;
   private boolean[] trackEnabledStates;
+  private boolean[] trackIsAudioVideoFlags;
+  private boolean haveAudioVideoTracks;
   private long length;
 
   private long lastSeekPositionUs;
@@ -99,11 +103,13 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param sourceListener A listener to notify when the timeline has been loaded.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extractors,
       int minLoadableRetryCount, Handler eventHandler,
       ExtractorMediaSource.EventListener eventListener, MediaSource.Listener sourceListener,
-      Allocator allocator) {
+      Allocator allocator, String customCacheKey) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -111,6 +117,7 @@ public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extracto
     this.eventListener = eventListener;
     this.sourceListener = sourceListener;
     this.allocator = allocator;
+    this.customCacheKey = customCacheKey;
     loader = new Loader("Loader:ExtractorMediaPeriod");
     extractorHolder = new ExtractorHolder(extractors, this);
     loadCondition = new ConditionVariable();
@@ -229,7 +236,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
 
   @Override
   public boolean continueLoading(long playbackPositionUs) {
-    if (loadingFinished) {
+    if (loadingFinished || (prepared && enabledTrackCount == 0)) {
       return false;
     }
     boolean continuedLoading = loadCondition.open();
@@ -242,7 +249,7 @@ public boolean continueLoading(long playbackPositionUs) {
 
   @Override
   public long getNextLoadPositionUs() {
-    return getBufferedPositionUs();
+    return enabledTrackCount == 0 ? C.TIME_END_OF_SOURCE : getBufferedPositionUs();
   }
 
   @Override
@@ -260,11 +267,23 @@ public long getBufferedPositionUs() {
       return C.TIME_END_OF_SOURCE;
     } else if (isPendingReset()) {
       return pendingResetPositionUs;
+    }
+    long largestQueuedTimestampUs;
+    if (haveAudioVideoTracks) {
+      // Ignore non-AV tracks, which may be sparse or poorly interleaved.
+      largestQueuedTimestampUs = Long.MAX_VALUE;
+      int trackCount = sampleQueues.size();
+      for (int i = 0; i < trackCount; i++) {
+        if (trackIsAudioVideoFlags[i]) {
+          largestQueuedTimestampUs = Math.min(largestQueuedTimestampUs,
+              sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
+        }
+      }
     } else {
-      long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
-      return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
-          : largestQueuedTimestampUs;
+      largestQueuedTimestampUs = getLargestQueuedTimestampUs();
     }
+    return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
+        : largestQueuedTimestampUs;
   }
 
   @Override
@@ -405,10 +424,16 @@ private void maybeFinishPrepare() {
     }
     loadCondition.close();
     TrackGroup[] trackArray = new TrackGroup[trackCount];
+    trackIsAudioVideoFlags = new boolean[trackCount];
     trackEnabledStates = new boolean[trackCount];
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
-      trackArray[i] = new TrackGroup(sampleQueues.valueAt(i).getUpstreamFormat());
+      Format trackFormat = sampleQueues.valueAt(i).getUpstreamFormat();
+      trackArray[i] = new TrackGroup(trackFormat);
+      String mimeType = trackFormat.sampleMimeType;
+      boolean isAudioVideo = MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
+      trackIsAudioVideoFlags[i] = isAudioVideo;
+      haveAudioVideoTracks |= isAudioVideo;
     }
     tracks = new TrackGroupArray(trackArray);
     prepared = true;
@@ -433,7 +458,7 @@ private void startLoading() {
         pendingResetPositionUs = C.TIME_UNSET;
         return;
       }
-      loadable.setLoadPosition(seekMap.getPosition(pendingResetPositionUs));
+      loadable.setLoadPosition(seekMap.getPosition(pendingResetPositionUs), pendingResetPositionUs);
       pendingResetPositionUs = C.TIME_UNSET;
     }
     extractedSamplesCountAtStartOfLoad = getExtractedSamplesCount();
@@ -466,7 +491,7 @@ private void configureRetry(ExtractingLoadable loadable) {
       for (int i = 0; i < trackCount; i++) {
         sampleQueues.valueAt(i).reset(!prepared || trackEnabledStates[i]);
       }
-      loadable.setLoadPosition(0);
+      loadable.setLoadPosition(0, 0);
     }
   }
 
@@ -494,7 +519,7 @@ private boolean isPendingReset() {
   }
 
   private boolean isLoadableExceptionFatal(IOException e) {
-    return e instanceof ExtractorMediaSource.UnrecognizedInputFormatException;
+    return e instanceof UnrecognizedInputFormatException;
   }
 
   private void notifyLoadError(final IOException error) {
@@ -558,6 +583,7 @@ public void skipToKeyframeBefore(long timeUs) {
     private volatile boolean loadCanceled;
 
     private boolean pendingExtractorSeek;
+    private long seekTimeUs;
     private long length;
 
     public ExtractingLoadable(Uri uri, DataSource dataSource, ExtractorHolder extractorHolder,
@@ -571,8 +597,9 @@ public ExtractingLoadable(Uri uri, DataSource dataSource, ExtractorHolder extrac
       this.length = C.LENGTH_UNSET;
     }
 
-    public void setLoadPosition(long position) {
+    public void setLoadPosition(long position, long timeUs) {
       positionHolder.position = position;
+      seekTimeUs = timeUs;
       pendingExtractorSeek = true;
     }
 
@@ -593,15 +620,14 @@ public void load() throws IOException, InterruptedException {
         ExtractorInput input = null;
         try {
           long position = positionHolder.position;
-          length = dataSource.open(
-              new DataSpec(uri, position, C.LENGTH_UNSET, Util.sha1(uri.toString())));
+          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey));
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
           input = new DefaultExtractorInput(dataSource, position, length);
-          Extractor extractor = extractorHolder.selectExtractor(input);
+          Extractor extractor = extractorHolder.selectExtractor(input, dataSource.getUri());
           if (pendingExtractorSeek) {
-            extractor.seek(position);
+            extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
           }
           while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
@@ -619,7 +645,7 @@ public void load() throws IOException, InterruptedException {
           } else if (input != null) {
             positionHolder.position = input.getPosition();
           }
-          dataSource.close();
+          Util.closeQuietly(dataSource);
         }
       }
     }
@@ -651,13 +677,13 @@ public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput)
      * later calls.
      *
      * @param input The {@link ExtractorInput} from which data should be read.
+     * @param uri The {@link Uri} of the data.
      * @return An initialized extractor for reading {@code input}.
-     * @throws ExtractorMediaSource.UnrecognizedInputFormatException Thrown if the input format
-     *     could not be detected.
+     * @throws UnrecognizedInputFormatException Thrown if the input format could not be detected.
      * @throws IOException Thrown if the input could not be read.
      * @throws InterruptedException Thrown if the thread was interrupted.
      */
-    public Extractor selectExtractor(ExtractorInput input)
+    public Extractor selectExtractor(ExtractorInput input, Uri uri)
         throws IOException, InterruptedException {
       if (extractor != null) {
         return extractor;
@@ -675,7 +701,8 @@ public Extractor selectExtractor(ExtractorInput input)
         }
       }
       if (extractor == null) {
-        throw new ExtractorMediaSource.UnrecognizedInputFormatException(extractors);
+        throw new UnrecognizedInputFormatException("None of the available extractors ("
+            + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.", uri);
       }
       extractor.init(extractorOutput);
       return extractor;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index bf795241bc..c560616aae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -18,7 +18,7 @@
 import android.net.Uri;
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -26,7 +26,6 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -56,18 +55,6 @@
 
   }
 
-  /**
-   * Thrown if the input format could not recognized.
-   */
-  public static final class UnrecognizedInputFormatException extends ParserException {
-
-    public UnrecognizedInputFormatException(Extractor[] extractors) {
-      super("None of the available extractors ("
-          + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.");
-    }
-
-  }
-
   /**
    * The default minimum number of times to retry loading prior to failing for on-demand streams.
    */
@@ -92,6 +79,7 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final Timeline.Period period;
+  private final String customCacheKey;
 
   private MediaSource.Listener sourceListener;
   private Timeline timeline;
@@ -109,7 +97,25 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener) {
     this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
-        eventListener);
+        eventListener, null);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+   * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
+   *     possible formats are known, pass a factory that instantiates extractors for those formats.
+   *     Otherwise, pass a {@link DefaultExtractorsFactory} to use default extractors.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
+   */
+  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener,
+      String customCacheKey) {
+    this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
+        eventListener, customCacheKey);
   }
 
   /**
@@ -121,21 +127,24 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, int minLoadableRetryCount, Handler eventHandler,
-      EventListener eventListener) {
+      EventListener eventListener, String customCacheKey) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorsFactory = extractorsFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    this.customCacheKey = customCacheKey;
     period = new Timeline.Period();
   }
 
   @Override
-  public void prepareSource(MediaSource.Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     sourceListener = listener;
     timeline = new SinglePeriodTimeline(C.TIME_UNSET, false);
     listener.onSourceInfoRefreshed(timeline, null);
@@ -151,7 +160,7 @@ public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs)
     Assertions.checkArgument(index == 0);
     return new ExtractorMediaPeriod(uri, dataSourceFactory.createDataSource(),
         extractorsFactory.createExtractors(), minLoadableRetryCount, eventHandler, eventListener,
-        this, allocator);
+        this, allocator, customCacheKey);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 21455ed89d..d893d60262 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -18,6 +18,7 @@
 import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
@@ -59,8 +60,8 @@ public LoopingMediaSource(MediaSource childSource, int loopCount) {
   }
 
   @Override
-  public void prepareSource(final Listener listener) {
-    childSource.prepareSource(new Listener() {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, final Listener listener) {
+    childSource.prepareSource(player, false, new Listener() {
       @Override
       public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
         childPeriodCount = timeline.getPeriodCount();
@@ -118,8 +119,10 @@ public int getWindowCount() {
     }
 
     @Override
-    public Window getWindow(int windowIndex, Window window, boolean setIds) {
-      childTimeline.getWindow(windowIndex % childWindowCount, window, setIds);
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      childTimeline.getWindow(windowIndex % childWindowCount, window, setIds,
+          defaultPositionProjectionUs);
       int periodIndexOffset = (windowIndex / childWindowCount) * childPeriodCount;
       window.firstPeriodIndex += periodIndexOffset;
       window.lastPeriodIndex += periodIndexOffset;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index a3c1c88df4..31ee8df1e4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
 
@@ -47,6 +48,10 @@
    * <p>
    * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
    * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
+   * <p>
+   * If preparation succeeds and results in a source timeline change (e.g. the period duration
+   * becoming known), {@link MediaSource.Listener#onSourceInfoRefreshed(Timeline, Object)} will be
+   * called before {@code callback.onPrepared}.
    *
    * @param callback Callback to receive updates from this period, including being notified when
    *     preparation completes.
@@ -133,4 +138,32 @@ long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
    */
   long seekToUs(long positionUs);
 
+  // SequenceableLoader interface. Overridden to provide more specific documentation.
+
+  /**
+   * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
+   * <p>
+   * This method should only be called after the period has been prepared. It may be called when no
+   * tracks are selected.
+   */
+  @Override
+  long getNextLoadPositionUs();
+
+  /**
+   * Attempts to continue loading.
+   * <p>
+   * This method may be called both during and after the period has been prepared.
+   * <p>
+   * A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
+   * {@link Callback} passed to {@link #prepare(Callback)} to request that this method be called
+   * when the period is permitted to continue loading data. A period may do this both during and
+   * after preparation.
+   *
+   * @param positionUs The current playback position.
+   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
+   *     a different value than prior to the call. False otherwise.
+   */
+  @Override
+  boolean continueLoading(long positionUs);
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 709a92cbf5..f013e790f7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import java.io.IOException;
@@ -42,9 +43,14 @@
   /**
    * Starts preparation of the source.
    *
+   * @param player The player for which this source is being prepared.
+   * @param isTopLevelSource Whether this source has been passed directly to
+   *     {@link ExoPlayer#prepare(MediaSource)} or
+   *     {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}. If {@code false}, this source is
+   *     being prepared by another source (e.g. {@link ConcatenatingMediaSource}) for composition.
    * @param listener The listener for source events.
    */
-  void prepareSource(Listener listener);
+  void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener);
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
@@ -52,7 +58,9 @@
   void maybeThrowSourceInfoRefreshError() throws IOException;
 
   /**
-   * Returns a {@link MediaPeriod} corresponding to the period at the specified index.
+   * Returns a new {@link MediaPeriod} corresponding to the period at the specified {@code index}.
+   * This method may be called multiple times with the same index without an intervening call to
+   * {@link #releasePeriod(MediaPeriod)}.
    *
    * @param index The index of the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index cfab4b14aa..10c56e5576 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -149,9 +149,9 @@ public long readDiscontinuity() {
     }
     // It must be possible to seek enabled periods to the new position, if there is one.
     if (positionUs != C.TIME_UNSET) {
-      for (int i = 0; i < enabledPeriods.length; i++) {
-        if (enabledPeriods[i] != periods[0]
-            && enabledPeriods[i].seekToUs(positionUs) != positionUs) {
+      for (MediaPeriod enabledPeriod : enabledPeriods) {
+        if (enabledPeriod != periods[0]
+            && enabledPeriod.seekToUs(positionUs) != positionUs) {
           throw new IllegalStateException("Children seeked to different positions");
         }
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 7d5f78c1cd..417483cebc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import android.support.annotation.IntDef;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import java.io.IOException;
@@ -92,11 +93,11 @@ public MergingMediaSource(MediaSource... mediaSources) {
   }
 
   @Override
-  public void prepareSource(final Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     this.listener = listener;
     for (int i = 0; i < mediaSources.length; i++) {
       final int sourceIndex = i;
-      mediaSources[sourceIndex].prepareSource(new Listener() {
+      mediaSources[sourceIndex].prepareSource(player, false, new Listener() {
         @Override
         public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
           handleSourceInfoRefreshed(sourceIndex, timeline, manifest);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index 39374acb33..5ee70cd2ed 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -44,11 +44,17 @@
 
   /**
    * Attempts to read from the stream.
+   * <p>
+   * If no data is available then {@link C#RESULT_NOTHING_READ} is returned. If the format of the
+   * media is changing or if {@code buffer == null} then {@code formatHolder} is populated and
+   * {@link C#RESULT_FORMAT_READ} is returned. Else {@code buffer} is populated and
+   * {@link C#RESULT_BUFFER_READ} is returned.
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index f298d04432..ae367ef14c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -74,9 +74,18 @@ public int getWindowCount() {
   }
 
   @Override
-  public Window getWindow(int windowIndex, Window window, boolean setIds) {
+  public Window getWindow(int windowIndex, Window window, boolean setIds,
+      long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, 1);
     Object id = setIds ? ID : null;
+    long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
+    if (isDynamic) {
+      windowDefaultStartPositionUs += defaultPositionProjectionUs;
+      if (windowDefaultStartPositionUs > windowDurationUs) {
+        // The projection takes us beyond the end of the live window.
+        windowDefaultStartPositionUs = C.TIME_UNSET;
+      }
+    }
     return window.set(id, C.TIME_UNSET, C.TIME_UNSET, isSeekable, isDynamic,
         windowDefaultStartPositionUs, windowDurationUs, 0, 0, windowPositionInPeriodUs);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 1ad448bd12..c78bb5371b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -205,13 +206,13 @@ public void maybeThrowError() throws IOException {
 
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      if (streamState == STREAM_STATE_END_OF_STREAM) {
-        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
-        return C.RESULT_BUFFER_READ;
-      } else if (streamState == STREAM_STATE_SEND_FORMAT) {
+      if (buffer == null || streamState == STREAM_STATE_SEND_FORMAT) {
         formatHolder.format = format;
         streamState = STREAM_STATE_SEND_SAMPLE;
         return C.RESULT_FORMAT_READ;
+      } else if (streamState == STREAM_STATE_END_OF_STREAM) {
+        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
       }
 
       Assertions.checkState(streamState == STREAM_STATE_SEND_SAMPLE);
@@ -276,7 +277,7 @@ public void load() throws IOException, InterruptedException {
           result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
         }
       } finally {
-        dataSource.close();
+        Util.closeQuietly(dataSource);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 385bebfb88..f6ee84a6f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -84,7 +85,7 @@ public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Fo
   // MediaSource implementation.
 
   @Override
-  public void prepareSource(MediaSource.Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     listener.onSourceInfoRefreshed(timeline, null);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
index d562ec43e1..394cec891b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
@@ -23,6 +23,11 @@
  */
 public final class TrackGroupArray {
 
+  /**
+   * The empty array.
+   */
+  public static final TrackGroupArray EMPTY = new TrackGroupArray();
+
   /**
    * The number of groups in the array. Greater than or equal to zero.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
new file mode 100644
index 0000000000..508bf0e365
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.ParserException;
+
+/**
+ * Thrown if the input format was not recognized.
+ */
+public class UnrecognizedInputFormatException extends ParserException {
+
+  /**
+   * The {@link Uri} from which the unrecognized data was read.
+   */
+  public final Uri uri;
+
+  /**
+   * @param message The detail message for the exception.
+   * @param uri The {@link Uri} from which the unrecognized data was read.
+   */
+  public UnrecognizedInputFormatException(String message, Uri uri) {
+    super(message);
+    this.uri = uri;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index b9aa098b9d..2623d31cef 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -30,15 +30,15 @@
 /**
  * An {@link Extractor} wrapper for loading chunks containing a single track.
  * <p>
- * The wrapper allows switching of the {@link SingleTrackMetadataOutput} and {@link TrackOutput}
- * which receive parsed data.
+ * The wrapper allows switching of the {@link SeekMapOutput} and {@link TrackOutput} that receive
+ * parsed data.
  */
 public final class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
 
   /**
-   * Receives metadata associated with the track as extracted by the wrapped {@link Extractor}.
+   * Receives {@link SeekMap}s extracted by the wrapped {@link Extractor}.
    */
-  public interface SingleTrackMetadataOutput {
+  public interface SeekMapOutput {
 
     /**
      * @see ExtractorOutput#seekMap(SeekMap)
@@ -47,13 +47,14 @@
 
   }
 
-  private final Extractor extractor;
+  public final Extractor extractor;
+
   private final Format manifestFormat;
   private final boolean preferManifestDrmInitData;
   private final boolean resendFormatOnInit;
 
   private boolean extractorInitialized;
-  private SingleTrackMetadataOutput metadataOutput;
+  private SeekMapOutput seekMapOutput;
   private TrackOutput trackOutput;
   private Format sentFormat;
 
@@ -68,7 +69,7 @@
    * @param preferManifestDrmInitData Whether {@link DrmInitData} defined in {@code manifestFormat}
    *     should be preferred when the sample and manifest {@link Format}s are merged.
    * @param resendFormatOnInit Whether the extractor should resend the previous {@link Format} when
-   *     it is initialized via {@link #init(SingleTrackMetadataOutput, TrackOutput)}.
+   *     it is initialized via {@link #init(SeekMapOutput, TrackOutput)}.
    */
   public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat,
       boolean preferManifestDrmInitData, boolean resendFormatOnInit) {
@@ -79,40 +80,26 @@ public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat,
   }
 
   /**
-   * Initializes the extractor to output to the provided {@link SingleTrackMetadataOutput} and
+   * Initializes the extractor to output to the provided {@link SeekMapOutput} and
    * {@link TrackOutput} instances, and configures it to receive data from a new chunk.
    *
-   * @param metadataOutput The {@link SingleTrackMetadataOutput} that will receive metadata.
+   * @param seekMapOutput The {@link SeekMapOutput} that will receive extracted {@link SeekMap}s.
    * @param trackOutput The {@link TrackOutput} that will receive sample data.
    */
-  public void init(SingleTrackMetadataOutput metadataOutput, TrackOutput trackOutput) {
-    this.metadataOutput = metadataOutput;
+  public void init(SeekMapOutput seekMapOutput, TrackOutput trackOutput) {
+    this.seekMapOutput = seekMapOutput;
     this.trackOutput = trackOutput;
     if (!extractorInitialized) {
       extractor.init(this);
       extractorInitialized = true;
     } else {
-      extractor.seek(0);
+      extractor.seek(0, 0);
       if (resendFormatOnInit && sentFormat != null) {
         trackOutput.format(sentFormat);
       }
     }
   }
 
-  /**
-   * Reads from the provided {@link ExtractorInput}.
-   *
-   * @param input The {@link ExtractorInput} from which to read.
-   * @return One of {@link Extractor#RESULT_CONTINUE} and {@link Extractor#RESULT_END_OF_INPUT}.
-   * @throws IOException If an error occurred reading from the source.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public int read(ExtractorInput input) throws IOException, InterruptedException {
-    int result = extractor.read(input, null);
-    Assertions.checkState(result != Extractor.RESULT_SEEK);
-    return result;
-  }
-
   // ExtractorOutput implementation.
 
   @Override
@@ -130,7 +117,7 @@ public void endTracks() {
 
   @Override
   public void seekMap(SeekMap seekMap) {
-    metadataOutput.seekMap(seekMap);
+    seekMapOutput.seekMap(seekMap);
   }
 
   // TrackOutput implementation.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index bb2f9b214b..3955d64034 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -122,7 +122,8 @@ public long getBufferedPositionUs() {
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
     // If we're not pending a reset, see if we can seek within the sample queue.
-    boolean seekInsideBuffer = !isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
+    boolean seekInsideBuffer = !isPendingReset()
+        && sampleQueue.skipToKeyframeBefore(positionUs, positionUs < getNextLoadPositionUs());
     if (seekInsideBuffer) {
       // We succeeded. All we need to do is discard any chunks that we've moved past.
       while (mediaChunks.size() > 1
@@ -251,7 +252,7 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
 
   @Override
   public boolean continueLoading(long positionUs) {
-    if (loader.isLoading()) {
+    if (loadingFinished || loader.isLoading()) {
       return false;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java
index 6c085418bd..38e0c0d51f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkedTrackBlacklistUtil.java
@@ -51,9 +51,9 @@ public static boolean maybeBlacklistTrack(TrackSelection trackSelection, int tra
 
   /**
    * Blacklists {@code trackSelectionIndex} in {@code trackSelection} for
-   * {@code blacklistDurationMs} if {@code e} is an {@link InvalidResponseCodeException} with
-   * {@link InvalidResponseCodeException#responseCode} equal to 404 or 410. Else does nothing. Note
-   * that blacklisting will fail if the track is the only non-blacklisted track in the selection.
+   * {@code blacklistDurationMs} if calling {@link #shouldBlacklist(Exception)} for {@code e}
+   * returns true. Else does nothing. Note that blacklisting will fail if the track is the only
+   * non-blacklisted track in the selection.
    *
    * @param trackSelection The track selection.
    * @param trackSelectionIndex The index in the selection to consider blacklisting.
@@ -63,24 +63,33 @@ public static boolean maybeBlacklistTrack(TrackSelection trackSelection, int tra
    */
   public static boolean maybeBlacklistTrack(TrackSelection trackSelection, int trackSelectionIndex,
       Exception e, long blacklistDurationMs) {
-    if (trackSelection.length() == 1) {
-      // Blacklisting won't ever work if there's only one track in the selection.
-      return false;
+    if (shouldBlacklist(e)) {
+      boolean blacklisted = trackSelection.blacklist(trackSelectionIndex, blacklistDurationMs);
+      int responseCode = ((InvalidResponseCodeException) e).responseCode;
+      if (blacklisted) {
+        Log.w(TAG, "Blacklisted: duration=" + blacklistDurationMs + ", responseCode="
+            + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
+      } else {
+        Log.w(TAG, "Blacklisting failed (cannot blacklist last enabled track): responseCode="
+            + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
+      }
+      return blacklisted;
     }
+    return false;
+  }
+
+  /**
+   * Returns whether a loading error is an {@link InvalidResponseCodeException} with
+   * {@link InvalidResponseCodeException#responseCode} equal to 404 or 410.
+   *
+   * @param e The loading error.
+   * @return Wheter the loading error is an {@link InvalidResponseCodeException} with
+   *     {@link InvalidResponseCodeException#responseCode} equal to 404 or 410.
+   */
+  public static boolean shouldBlacklist(Exception e) {
     if (e instanceof InvalidResponseCodeException) {
-      InvalidResponseCodeException responseCodeException = (InvalidResponseCodeException) e;
-      int responseCode = responseCodeException.responseCode;
-      if (responseCode == 404 || responseCode == 410) {
-        boolean blacklisted = trackSelection.blacklist(trackSelectionIndex, blacklistDurationMs);
-        if (blacklisted) {
-          Log.w(TAG, "Blacklisted: duration=" + blacklistDurationMs + ", responseCode="
-              + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
-        } else {
-          Log.w(TAG, "Blacklisting failed (cannot blacklist last enabled track): responseCode="
-              + responseCode + ", format=" + trackSelection.getFormat(trackSelectionIndex));
-        }
-        return blacklisted;
-      }
+      int responseCode = ((InvalidResponseCodeException) e).responseCode;
+      return responseCode == 404 || responseCode == 410;
     }
     return false;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index 130dddc5eb..060e6130cf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -21,19 +21,21 @@
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SeekMapOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
  * A {@link BaseMediaChunk} that uses an {@link Extractor} to decode sample data.
  */
-public class ContainerMediaChunk extends BaseMediaChunk implements SingleTrackMetadataOutput {
+public class ContainerMediaChunk extends BaseMediaChunk implements SeekMapOutput {
 
-  private final ChunkExtractorWrapper extractorWrapper;
+  private final int chunkCount;
   private final long sampleOffsetUs;
+  private final ChunkExtractorWrapper extractorWrapper;
   private final Format sampleFormat;
 
   private volatile int bytesLoaded;
@@ -49,6 +51,9 @@
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
+   * @param chunkCount The number of chunks in the underlying media that are spanned by this
+   *     instance. Normally equal to one, but may be larger if multiple chunks as defined by the
+   *     underlying media are being merged into a single load.
    * @param sampleOffsetUs An offset to add to the sample timestamps parsed by the extractor.
    * @param extractorWrapper A wrapped extractor to use for parsing the data.
    * @param sampleFormat The {@link Format} of the samples in the chunk, if known. May be null if
@@ -56,15 +61,21 @@
    */
   public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
       int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, long sampleOffsetUs, ChunkExtractorWrapper extractorWrapper,
+      int chunkIndex, int chunkCount, long sampleOffsetUs, ChunkExtractorWrapper extractorWrapper,
       Format sampleFormat) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
-    this.extractorWrapper = extractorWrapper;
+    this.chunkCount = chunkCount;
     this.sampleOffsetUs = sampleOffsetUs;
+    this.extractorWrapper = extractorWrapper;
     this.sampleFormat = sampleFormat;
   }
 
+  @Override
+  public int getNextChunkIndex() {
+    return chunkIndex + chunkCount;
+  }
+
   @Override
   public boolean isLoadCompleted() {
     return loadCompleted;
@@ -75,7 +86,7 @@ public final long bytesLoaded() {
     return bytesLoaded;
   }
 
-  // SingleTrackMetadataOutput implementation.
+  // SeekMapOutput implementation.
 
   @Override
   public final void seekMap(SeekMap seekMap) {
@@ -110,15 +121,17 @@ public final void load() throws IOException, InterruptedException {
       }
       // Load and decode the sample data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
index 99653d323f..0846e7679d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Arrays;
 
@@ -96,7 +97,7 @@ public final void load() throws IOException, InterruptedException {
         consume(data, limit);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index 388dc63899..c8c3389830 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -22,9 +22,10 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SeekMapOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -32,7 +33,7 @@
 /**
  * A {@link Chunk} that uses an {@link Extractor} to decode initialization data for single track.
  */
-public final class InitializationChunk extends Chunk implements SingleTrackMetadataOutput,
+public final class InitializationChunk extends Chunk implements SeekMapOutput,
     TrackOutput {
 
   private final ChunkExtractorWrapper extractorWrapper;
@@ -85,7 +86,7 @@ public SeekMap getSeekMap() {
     return seekMap;
   }
 
-  // SingleTrackMetadataOutput implementation.
+  // SeekMapOutput implementation.
 
   @Override
   public void seekMap(SeekMap seekMap) {
@@ -142,15 +143,17 @@ public void load() throws IOException, InterruptedException {
       }
       // Load and decode the initialization data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
index d3e211c09f..3a02884fff 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
@@ -53,7 +53,7 @@ public MediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
   /**
    * Returns the next chunk index.
    */
-  public final int getNextChunkIndex() {
+  public int getNextChunkIndex() {
     return chunkIndex + 1;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
index 3033566950..d7be74535e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
@@ -98,7 +98,7 @@ public void load() throws IOException, InterruptedException {
       int sampleSize = bytesLoaded;
       trackOutput.sampleMetadata(startTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 766f1e0ebf..99845c057e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -21,6 +21,7 @@
 import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
@@ -29,11 +30,11 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
-import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.UtcTimingElement;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -81,6 +82,7 @@
 
   private static final String TAG = "DashMediaSource";
 
+  private final boolean sideloadedManifest;
   private final DataSource.Factory manifestDataSourceFactory;
   private final DashChunkSource.Factory chunkSourceFactory;
   private final int minLoadableRetryCount;
@@ -93,9 +95,10 @@
   private final Runnable refreshManifestRunnable;
   private final Runnable simulateManifestRefreshRunnable;
 
-  private MediaSource.Listener sourceListener;
+  private Listener sourceListener;
   private DataSource dataSource;
   private Loader loader;
+  private LoaderErrorThrower loaderErrorThrower;
 
   private Uri manifestUri;
   private long manifestLoadStartTimestamp;
@@ -106,6 +109,47 @@
 
   private int firstPeriodId;
 
+  /**
+   * Constructs an instance to play a given {@link DashManifest}, which must be static.
+   *
+   * @param manifest The manifest. {@link DashManifest#dynamic} must be false.
+   * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler, AdaptiveMediaSourceEventListener eventListener) {
+    this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
+        eventListener);
+  }
+
+  /**
+   * Constructs an instance to play a given {@link DashManifest}, which must be static.
+   *
+   * @param manifest The manifest. {@link DashManifest#dynamic} must be false.
+   * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount, Handler eventHandler, AdaptiveMediaSourceEventListener
+      eventListener) {
+    this(manifest, null, null, null, chunkSourceFactory, minLoadableRetryCount,
+        DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS, eventHandler, eventListener);
+  }
+
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be dynamic or
+   * static.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
   public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
       DashChunkSource.Factory chunkSourceFactory, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
@@ -114,32 +158,91 @@ public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFac
         eventHandler, eventListener);
   }
 
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be dynamic or
+   * static.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+   *     default start position should precede the end of the live window. Use
+   *     {@link #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by
+   *     the manifest, if present.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+      DashChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
+      long livePresentationDelayMs, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
+    this(manifestUri, manifestDataSourceFactory, new DashManifestParser(), chunkSourceFactory,
+        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+  }
+
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be dynamic or
+   * static.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param manifestParser A parser for loaded manifest data.
+   * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+   *     default start position should precede the end of the live window. Use
+   *     {@link #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by
+   *     the manifest, if present.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
   public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+      DashManifestParser manifestParser, DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount, long livePresentationDelayMs, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
+    this(null, manifestUri, manifestDataSourceFactory, manifestParser, chunkSourceFactory,
+        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+  }
+
+  private DashMediaSource(DashManifest manifest, Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory, DashManifestParser manifestParser,
       DashChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
       long livePresentationDelayMs, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
+    this.manifest = manifest;
     this.manifestUri = manifestUri;
     this.manifestDataSourceFactory = manifestDataSourceFactory;
+    this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.livePresentationDelayMs = livePresentationDelayMs;
+    sideloadedManifest = manifest != null;
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    manifestParser = new DashManifestParser(generateContentId());
-    manifestCallback = new ManifestCallback();
     manifestUriLock = new Object();
     periodsById = new SparseArray<>();
-    refreshManifestRunnable = new Runnable() {
-      @Override
-      public void run() {
-        startLoadingManifest();
-      }
-    };
-    simulateManifestRefreshRunnable = new Runnable() {
-      @Override
-      public void run() {
-        processManifest();
-      }
-    };
+    if (sideloadedManifest) {
+      Assertions.checkState(!manifest.dynamic);
+      manifestCallback = null;
+      refreshManifestRunnable = null;
+      simulateManifestRefreshRunnable = null;
+    } else {
+      manifestCallback = new ManifestCallback();
+      refreshManifestRunnable = new Runnable() {
+        @Override
+        public void run() {
+          startLoadingManifest();
+        }
+      };
+      simulateManifestRefreshRunnable = new Runnable() {
+        @Override
+        public void run() {
+          processManifest(false);
+        }
+      };
+    }
   }
 
   /**
@@ -156,24 +259,32 @@ public void replaceManifestUri(Uri manifestUri) {
   // MediaSource implementation.
 
   @Override
-  public void prepareSource(MediaSource.Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     sourceListener = listener;
-    dataSource = manifestDataSourceFactory.createDataSource();
-    loader = new Loader("Loader:DashMediaSource");
-    handler = new Handler();
-    startLoadingManifest();
+    if (sideloadedManifest) {
+      loaderErrorThrower = new LoaderErrorThrower.Dummy();
+      processManifest(false);
+    } else {
+      dataSource = manifestDataSourceFactory.createDataSource();
+      loader = new Loader("Loader:DashMediaSource");
+      loaderErrorThrower = loader;
+      handler = new Handler();
+      startLoadingManifest();
+    }
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    loader.maybeThrowError();
+    loaderErrorThrower.maybeThrowError();
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
-    DashMediaPeriod mediaPeriod = new DashMediaPeriod(firstPeriodId + index, manifest, index,
-        chunkSourceFactory, minLoadableRetryCount, eventDispatcher, elapsedRealtimeOffsetMs, loader,
-        allocator);
+  public MediaPeriod createPeriod(int periodIndex, Allocator allocator, long positionUs) {
+    EventDispatcher periodEventDispatcher = eventDispatcher.copyWithMediaTimeOffsetMs(
+        manifest.getPeriod(periodIndex).startMs);
+    DashMediaPeriod mediaPeriod = new DashMediaPeriod(firstPeriodId + periodIndex, manifest,
+        periodIndex, chunkSourceFactory, minLoadableRetryCount, periodEventDispatcher,
+        elapsedRealtimeOffsetMs, loaderErrorThrower, allocator);
     periodsById.put(mediaPeriod.id, mediaPeriod);
     return mediaPeriod;
   }
@@ -188,6 +299,7 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
   @Override
   public void releaseSource() {
     dataSource = null;
+    loaderErrorThrower = null;
     if (loader != null) {
       loader.release();
       loader = null;
@@ -246,11 +358,11 @@ public void releaseSource() {
       if (manifest.utcTiming != null) {
         resolveUtcTimingElement(manifest.utcTiming);
       } else {
-        processManifestAndScheduleRefresh();
+        processManifest(true);
       }
     } else {
       firstPeriodId += removedPeriodCount;
-      processManifestAndScheduleRefresh();
+      processManifest(true);
     }
   }
 
@@ -313,8 +425,8 @@ private void resolveUtcTimingElementDirect(UtcTimingElement timingElement) {
     try {
       long utcTimestamp = Util.parseXsDateTime(timingElement.value);
       onUtcTimestampResolved(utcTimestamp - manifestLoadEndTimestamp);
-    } catch (ParseException e) {
-      onUtcTimestampResolutionError(new ParserException(e));
+    } catch (ParserException e) {
+      onUtcTimestampResolutionError(e);
     }
   }
 
@@ -326,21 +438,16 @@ private void resolveUtcTimingElementHttp(UtcTimingElement timingElement,
 
   private void onUtcTimestampResolved(long elapsedRealtimeOffsetMs) {
     this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
-    processManifestAndScheduleRefresh();
+    processManifest(true);
   }
 
   private void onUtcTimestampResolutionError(IOException error) {
     Log.e(TAG, "Failed to resolve UtcTiming element.", error);
     // Be optimistic and continue in the hope that the device clock is correct.
-    processManifestAndScheduleRefresh();
-  }
-
-  private void processManifestAndScheduleRefresh() {
-    processManifest();
-    scheduleManifestRefresh();
+    processManifest(true);
   }
 
-  private void processManifest() {
+  private void processManifest(boolean scheduleRefresh) {
     // Update any periods.
     for (int i = 0; i < periodsById.size(); i++) {
       int id = periodsById.keyAt(i);
@@ -350,9 +457,8 @@ private void processManifest() {
         // This period has been removed from the manifest so it doesn't need to be updated.
       }
     }
-    // Remove any pending simulated updates.
-    handler.removeCallbacks(simulateManifestRefreshRunnable);
     // Update the window.
+    boolean windowChangingImplicitly = false;
     int lastPeriodIndex = manifest.getPeriodCount() - 1;
     PeriodSeekInfo firstPeriodSeekInfo = PeriodSeekInfo.createPeriodSeekInfo(manifest.getPeriod(0),
         manifest.getPeriodDurationUs(0));
@@ -383,8 +489,7 @@ private void processManifest() {
           currentStartTimeUs = manifest.getPeriodDurationUs(0);
         }
       }
-      // The window is changing implicitly. Post a simulated manifest refresh to update it.
-      handler.postDelayed(simulateManifestRefreshRunnable, NOTIFY_MANIFEST_INTERVAL_MS);
+      windowChangingImplicitly = true;
     }
     long windowDurationUs = currentEndTimeUs - currentStartTimeUs;
     for (int i = 0; i < manifest.getPeriodCount() - 1; i++) {
@@ -398,35 +503,13 @@ private void processManifest() {
             ? manifest.suggestedPresentationDelay : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
       }
       // Snap the default position to the start of the segment containing it.
-      long defaultStartPositionUs = windowDurationUs - C.msToUs(presentationDelayForManifestMs);
-      if (defaultStartPositionUs < MIN_LIVE_DEFAULT_START_POSITION_US) {
+      windowDefaultStartPositionUs = windowDurationUs - C.msToUs(presentationDelayForManifestMs);
+      if (windowDefaultStartPositionUs < MIN_LIVE_DEFAULT_START_POSITION_US) {
         // The default start position is too close to the start of the live window. Set it to the
         // minimum default start position provided the window is at least twice as big. Else set
         // it to the middle of the window.
-        defaultStartPositionUs = Math.min(MIN_LIVE_DEFAULT_START_POSITION_US, windowDurationUs / 2);
-      }
-
-      int periodIndex = 0;
-      long defaultStartPositionInPeriodUs = currentStartTimeUs + defaultStartPositionUs;
-      long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
-      while (periodIndex < manifest.getPeriodCount() - 1
-          && defaultStartPositionInPeriodUs >= periodDurationUs) {
-        defaultStartPositionInPeriodUs -= periodDurationUs;
-        periodIndex++;
-        periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
-      }
-      Period period = manifest.getPeriod(periodIndex);
-      int videoAdaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
-      if (videoAdaptationSetIndex != C.INDEX_UNSET) {
-        // If there are multiple video adaptation sets with unaligned segments, the initial time may
-        // not correspond to the start of a segment in both, but this is an edge case.
-        DashSegmentIndex index =
-            period.adaptationSets.get(videoAdaptationSetIndex).representations.get(0).getIndex();
-        int segmentNum = index.getSegmentNum(defaultStartPositionInPeriodUs, periodDurationUs);
-        windowDefaultStartPositionUs =
-            defaultStartPositionUs - defaultStartPositionInPeriodUs + index.getTimeUs(segmentNum);
-      } else {
-        windowDefaultStartPositionUs = defaultStartPositionUs;
+        windowDefaultStartPositionUs = Math.min(MIN_LIVE_DEFAULT_START_POSITION_US,
+            windowDurationUs / 2);
       }
     }
     long windowStartTimeMs = manifest.availabilityStartTime
@@ -435,6 +518,19 @@ private void processManifest() {
         firstPeriodId, currentStartTimeUs, windowDurationUs, windowDefaultStartPositionUs,
         manifest);
     sourceListener.onSourceInfoRefreshed(timeline, manifest);
+
+    if (!sideloadedManifest) {
+      // Remove any pending simulated refresh.
+      handler.removeCallbacks(simulateManifestRefreshRunnable);
+      // If the window is changing implicitly, post a simulated manifest refresh to update it.
+      if (windowChangingImplicitly) {
+        handler.postDelayed(simulateManifestRefreshRunnable, NOTIFY_MANIFEST_INTERVAL_MS);
+      }
+      // Schedule an explicit refresh if needed.
+      if (scheduleRefresh) {
+        scheduleManifestRefresh();
+      }
+    }
   }
 
   private void scheduleManifestRefresh() {
@@ -468,10 +564,6 @@ private long getNowUnixTimeUs() {
     }
   }
 
-  private String generateContentId() {
-    return Util.sha1(manifestUri.toString());
-  }
-
   private static final class PeriodSeekInfo {
 
     public static PeriodSeekInfo createPeriodSeekInfo(
@@ -559,8 +651,11 @@ public int getWindowCount() {
     }
 
     @Override
-    public Window getWindow(int windowIndex, Window window, boolean setIdentifier) {
+    public Window getWindow(int windowIndex, Window window, boolean setIdentifier,
+        long defaultPositionProjectionUs) {
       Assertions.checkIndex(windowIndex, 0, 1);
+      long windowDefaultStartPositionUs = getAdjustedWindowDefaultStartPositionUs(
+          defaultPositionProjectionUs);
       return window.set(null, presentationStartTimeMs, windowStartTimeMs, true /* isSeekable */,
           manifest.dynamic, windowDefaultStartPositionUs, windowDurationUs, 0,
           manifest.getPeriodCount() - 1, offsetInFirstPeriodUs);
@@ -576,6 +671,48 @@ public int getIndexOfPeriod(Object uid) {
           ? C.INDEX_UNSET : (periodId - firstPeriodId);
     }
 
+    private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProjectionUs) {
+      long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
+      if (!manifest.dynamic) {
+        return windowDefaultStartPositionUs;
+      }
+      if (defaultPositionProjectionUs > 0) {
+        windowDefaultStartPositionUs += defaultPositionProjectionUs;
+        if (windowDefaultStartPositionUs > windowDurationUs) {
+          // The projection takes us beyond the end of the live window.
+          return C.TIME_UNSET;
+        }
+      }
+      // Attempt to snap to the start of the corresponding video segment.
+      int periodIndex = 0;
+      long defaultStartPositionInPeriodUs = offsetInFirstPeriodUs + windowDefaultStartPositionUs;
+      long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
+      while (periodIndex < manifest.getPeriodCount() - 1
+          && defaultStartPositionInPeriodUs >= periodDurationUs) {
+        defaultStartPositionInPeriodUs -= periodDurationUs;
+        periodIndex++;
+        periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
+      }
+      com.google.android.exoplayer2.source.dash.manifest.Period period =
+          manifest.getPeriod(periodIndex);
+      int videoAdaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
+      if (videoAdaptationSetIndex == C.INDEX_UNSET) {
+        // No video adaptation set for snapping.
+        return windowDefaultStartPositionUs;
+      }
+      // If there are multiple video adaptation sets with unaligned segments, the initial time may
+      // not correspond to the start of a segment in both, but this is an edge case.
+      DashSegmentIndex snapIndex = period.adaptationSets.get(videoAdaptationSetIndex)
+          .representations.get(0).getIndex();
+      if (snapIndex == null) {
+        // Video adaptation set does not include an index for snapping.
+        return windowDefaultStartPositionUs;
+      }
+      int segmentNum = snapIndex.getSegmentNum(defaultStartPositionInPeriodUs, periodDurationUs);
+      return windowDefaultStartPositionUs + snapIndex.getTimeUs(segmentNum)
+          - defaultStartPositionInPeriodUs;
+    }
+
   }
 
   private final class ManifestCallback implements
@@ -628,11 +765,7 @@ public int onLoadError(ParsingLoadable<Long> loadable, long elapsedRealtimeMs,
     @Override
     public Long parse(Uri uri, InputStream inputStream) throws IOException {
       String firstLine = new BufferedReader(new InputStreamReader(inputStream)).readLine();
-      try {
-        return Util.parseXsDateTime(firstLine);
-      } catch (ParseException e) {
-        throw new ParserException(e);
-      }
+      return Util.parseXsDateTime(firstLine);
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
index 716c9ad844..56ea626120 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
@@ -25,15 +25,12 @@
 /* package */ final class DashWrappingSegmentIndex implements DashSegmentIndex {
 
   private final ChunkIndex chunkIndex;
-  private final String uri;
 
   /**
    * @param chunkIndex The {@link ChunkIndex} to wrap.
-   * @param uri The URI where the data is located.
    */
-  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri) {
+  public DashWrappingSegmentIndex(ChunkIndex chunkIndex) {
     this.chunkIndex = chunkIndex;
-    this.uri = uri;
   }
 
   @Override
@@ -58,7 +55,7 @@ public long getDurationUs(int segmentNum, long periodDurationUs) {
 
   @Override
   public RangedUri getSegmentUrl(int segmentNum) {
-    return new RangedUri(uri, null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
+    return new RangedUri(null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index a7c7389b2b..74d53d3e32 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
+import android.net.Uri;
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -54,9 +55,15 @@
   public static final class Factory implements DashChunkSource.Factory {
 
     private final DataSource.Factory dataSourceFactory;
+    private final int maxSegmentsPerLoad;
 
     public Factory(DataSource.Factory dataSourceFactory) {
+      this(dataSourceFactory, 1);
+    }
+
+    public Factory(DataSource.Factory dataSourceFactory, int maxSegmentsPerLoad) {
       this.dataSourceFactory = dataSourceFactory;
+      this.maxSegmentsPerLoad = maxSegmentsPerLoad;
     }
 
     @Override
@@ -65,7 +72,8 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
         TrackSelection trackSelection, long elapsedRealtimeOffsetMs) {
       DataSource dataSource = dataSourceFactory.createDataSource();
       return new DefaultDashChunkSource(manifestLoaderErrorThrower, manifest, periodIndex,
-          adaptationSetIndex, trackSelection, dataSource, elapsedRealtimeOffsetMs);
+          adaptationSetIndex, trackSelection, dataSource, elapsedRealtimeOffsetMs,
+          maxSegmentsPerLoad);
     }
 
   }
@@ -76,6 +84,7 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
   private final RepresentationHolder[] representationHolders;
   private final DataSource dataSource;
   private final long elapsedRealtimeOffsetMs;
+  private final int maxSegmentsPerLoad;
 
   private DashManifest manifest;
   private int periodIndex;
@@ -93,10 +102,13 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
    * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
    *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
    *     as the server's unix time minus the local elapsed time. If unknown, set to 0.
+   * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request.
+   *     Note that segments will only be combined if their {@link Uri}s are the same and if their
+   *     data ranges are adjacent.
    */
   public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
       DashManifest manifest, int periodIndex, int adaptationSetIndex, TrackSelection trackSelection,
-      DataSource dataSource, long elapsedRealtimeOffsetMs) {
+      DataSource dataSource, long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
     this.adaptationSetIndex = adaptationSetIndex;
@@ -104,6 +116,7 @@ public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
     this.dataSource = dataSource;
     this.periodIndex = periodIndex;
     this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
+    this.maxSegmentsPerLoad = maxSegmentsPerLoad;
 
     long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
     List<Representation> representations = getRepresentations();
@@ -172,10 +185,9 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
     }
     if (pendingInitializationUri != null || pendingIndexUri != null) {
       // We have initialization and/or index requests to make.
-      Chunk initializationChunk = newInitializationChunk(representationHolder, dataSource,
+      out.chunk = newInitializationChunk(representationHolder, dataSource,
           trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
           trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
-      out.chunk = initializationChunk;
       return;
     }
 
@@ -219,10 +231,10 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
       return;
     }
 
-    Chunk nextMediaChunk = newMediaChunk(representationHolder, dataSource,
-        trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
-        trackSelection.getSelectionData(), sampleFormat, segmentNum);
-    out.chunk = nextMediaChunk;
+    int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
+    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
+        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), sampleFormat,
+        segmentNum, maxSegmentCount);
   }
 
   @Override
@@ -241,8 +253,7 @@ public void onChunkLoadCompleted(Chunk chunk) {
       if (representationHolder.segmentIndex == null) {
         SeekMap seekMap = initializationChunk.getSeekMap();
         if (seekMap != null) {
-          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap,
-              initializationChunk.dataSpec.uri.toString());
+          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap);
         }
       }
     }
@@ -260,7 +271,7 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
       RepresentationHolder representationHolder =
           representationHolders[trackSelection.indexOf(chunk.trackFormat)];
       int lastAvailableSegmentNum = representationHolder.getLastSegmentNum();
-      if (((MediaChunk) chunk).chunkIndex >= lastAvailableSegmentNum) {
+      if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
         missingLastSegment = true;
         return true;
       }
@@ -284,44 +295,59 @@ private long getNowUnixTimeUs() {
     }
   }
 
-  private Chunk newInitializationChunk(RepresentationHolder representationHolder,
+  private static Chunk newInitializationChunk(RepresentationHolder representationHolder,
       DataSource dataSource, Format trackFormat, int trackSelectionReason,
       Object trackSelectionData, RangedUri initializationUri, RangedUri indexUri) {
     RangedUri requestUri;
+    String baseUrl = representationHolder.representation.baseUrl;
     if (initializationUri != null) {
       // It's common for initialization and index data to be stored adjacently. Attempt to merge
       // the two requests together to request both at once.
-      requestUri = initializationUri.attemptMerge(indexUri);
+      requestUri = initializationUri.attemptMerge(indexUri, baseUrl);
       if (requestUri == null) {
         requestUri = initializationUri;
       }
     } else {
       requestUri = indexUri;
     }
-    DataSpec dataSpec = new DataSpec(requestUri.getUri(), requestUri.start, requestUri.length,
-        representationHolder.representation.getCacheKey());
+    DataSpec dataSpec = new DataSpec(requestUri.resolveUri(baseUrl), requestUri.start,
+        requestUri.length, representationHolder.representation.getCacheKey());
     return new InitializationChunk(dataSource, dataSpec, trackFormat,
         trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
   }
 
-  private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSource dataSource,
-      Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, Format sampleFormat, int segmentNum) {
+  private static Chunk newMediaChunk(RepresentationHolder representationHolder,
+      DataSource dataSource, Format trackFormat, int trackSelectionReason,
+      Object trackSelectionData, Format sampleFormat, int firstSegmentNum, int maxSegmentCount) {
     Representation representation = representationHolder.representation;
-    long startTimeUs = representationHolder.getSegmentStartTimeUs(segmentNum);
-    long endTimeUs = representationHolder.getSegmentEndTimeUs(segmentNum);
-    RangedUri segmentUri = representationHolder.getSegmentUrl(segmentNum);
-    DataSpec dataSpec = new DataSpec(segmentUri.getUri(), segmentUri.start, segmentUri.length,
-        representation.getCacheKey());
-
+    long startTimeUs = representationHolder.getSegmentStartTimeUs(firstSegmentNum);
+    RangedUri segmentUri = representationHolder.getSegmentUrl(firstSegmentNum);
+    String baseUrl = representation.baseUrl;
     if (representationHolder.extractorWrapper == null) {
+      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum);
+      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
+          segmentUri.start, segmentUri.length, representation.getCacheKey());
       return new SingleSampleMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
-          trackSelectionData, startTimeUs, endTimeUs, segmentNum, trackFormat);
+          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, trackFormat);
     } else {
+      int segmentCount = 1;
+      for (int i = 1; i < maxSegmentCount; i++) {
+        RangedUri nextSegmentUri = representationHolder.getSegmentUrl(firstSegmentNum + i);
+        RangedUri mergedSegmentUri = segmentUri.attemptMerge(nextSegmentUri, baseUrl);
+        if (mergedSegmentUri == null) {
+          // Unable to merge segment fetches because the URIs do not merge.
+          break;
+        }
+        segmentUri = mergedSegmentUri;
+        segmentCount++;
+      }
+      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum + segmentCount - 1);
+      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
+          segmentUri.start, segmentUri.length, representation.getCacheKey());
       long sampleOffsetUs = -representation.presentationTimeOffsetUs;
       return new ContainerMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
-          trackSelectionData, startTimeUs, endTimeUs, segmentNum, sampleOffsetUs,
-          representationHolder.extractorWrapper, sampleFormat);
+          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, segmentCount,
+          sampleOffsetUs, representationHolder.extractorWrapper, sampleFormat);
     }
   }
 
@@ -348,7 +374,7 @@ public RepresentationHolder(long periodDurationUs, Representation representation
         boolean resendFormatOnInit = false;
         Extractor extractor;
         if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
-          extractor = new RawCcExtractor();
+          extractor = new RawCcExtractor(representation.format);
           resendFormatOnInit = true;
         } else if (mimeTypeIsWebm(containerMimeType)) {
           extractor = new MatroskaExtractor();
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
index 44da52f52c..097676b89f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
@@ -23,18 +23,49 @@
  */
 public class AdaptationSet {
 
-  public static final int UNSET_ID = -1;
+  /**
+   * Value of {@link #id} indicating no value is set.=
+   */
+  public static final int ID_UNSET = -1;
 
+  /**
+   * A non-negative identifier for the adaptation set that's unique in the scope of its containing
+   * period, or {@link #ID_UNSET} if not specified.
+   */
   public final int id;
 
+  /**
+   * The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   * {@code TRACK_TYPE_*} constants.
+   */
   public final int type;
 
+  /**
+   * The {@link Representation}s in the adaptation set.
+   */
   public final List<Representation> representations;
 
-  public AdaptationSet(int id, int type, List<Representation> representations) {
+  /**
+   * The accessibility descriptors in the adaptation set.
+   */
+  public final List<SchemeValuePair> accessibilityDescriptors;
+
+  /**
+   * @param id A non-negative identifier for the adaptation set that's unique in the scope of its
+   *     containing period, or {@link #ID_UNSET} if not specified.
+   * @param type The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   *     {@code TRACK_TYPE_*} constants.
+   * @param representations The {@link Representation}s in the adaptation set.
+   * @param accessibilityDescriptors The accessibility descriptors in the adaptation set.
+   */
+  public AdaptationSet(int id, int type, List<Representation> representations,
+      List<SchemeValuePair> accessibilityDescriptors) {
     this.id = id;
     this.type = type;
     this.representations = Collections.unmodifiableList(representations);
+    this.accessibilityDescriptors = accessibilityDescriptors == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(accessibilityDescriptors);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index b2f0ae6f98..1917399282 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -38,7 +38,6 @@
 import com.google.android.exoplayer2.util.XmlPullParserUtil;
 import java.io.IOException;
 import java.io.InputStream;
-import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
@@ -59,6 +58,10 @@
 
   private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))?");
 
+  private static final Pattern CEA_608_ACCESSIBILITY_PATTERN = Pattern.compile("CC([1-4])=.*");
+  private static final Pattern CEA_708_ACCESSIBILITY_PATTERN =
+      Pattern.compile("([1-9]|[1-5][0-9]|6[0-3])=.*");
+
   private final String contentId;
   private final XmlPullParserFactory xmlParserFactory;
 
@@ -94,13 +97,13 @@ public DashManifest parse(Uri uri, InputStream inputStream) throws IOException {
             "inputStream does not contain a valid media presentation description");
       }
       return parseMediaPresentationDescription(xpp, uri.toString());
-    } catch (XmlPullParserException | ParseException e) {
+    } catch (XmlPullParserException e) {
       throw new ParserException(e);
     }
   }
 
   protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
-      String baseUrl) throws XmlPullParserException, IOException, ParseException {
+      String baseUrl) throws XmlPullParserException, IOException {
     long availabilityStartTime = parseDateTime(xpp, "availabilityStartTime", C.TIME_UNSET);
     long durationMs = parseDuration(xpp, "mediaPresentationDuration", C.TIME_UNSET);
     long minBufferTimeMs = parseDuration(xpp, "minBufferTime", C.TIME_UNSET);
@@ -205,11 +208,11 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       } else if (XmlPullParserUtil.isStartTag(xpp, "AdaptationSet")) {
         adaptationSets.add(parseAdaptationSet(xpp, baseUrl, segmentBase));
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, null);
+        segmentBase = parseSegmentBase(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, null);
+        segmentBase = parseSegmentList(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, null);
+        segmentBase = parseSegmentTemplate(xpp, null);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Period"));
 
@@ -224,7 +227,7 @@ protected Period buildPeriod(String id, long startMs, List<AdaptationSet> adapta
 
   protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       SegmentBase segmentBase) throws XmlPullParserException, IOException {
-    int id = parseInt(xpp, "id", AdaptationSet.UNSET_ID);
+    int id = parseInt(xpp, "id", AdaptationSet.ID_UNSET);
     int contentType = parseContentType(xpp);
 
     String mimeType = xpp.getAttributeValue(null, "mimeType");
@@ -236,7 +239,10 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", Format.NO_VALUE);
     String language = xpp.getAttributeValue(null, "lang");
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
+    ArrayList<SchemeValuePair> accessibilityDescriptors = new ArrayList<>();
     List<RepresentationInfo> representationInfos = new ArrayList<>();
+    @C.SelectionFlags int selectionFlags = 0;
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -254,37 +260,45 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentComponent")) {
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkContentTypeConsistency(contentType, parseContentType(xpp));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Role")) {
+        selectionFlags |= parseRole(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
+        audioChannels = parseAudioChannelConfiguration(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
+        accessibilityDescriptors.add(parseAccessibility(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp, "Representation")) {
         RepresentationInfo representationInfo = parseRepresentation(xpp, baseUrl, mimeType, codecs,
-            width, height, frameRate, audioChannels, audioSamplingRate, language, segmentBase);
+            width, height, frameRate, audioChannels, audioSamplingRate, language,
+            selectionFlags, accessibilityDescriptors, segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
         representationInfos.add(representationInfo);
-      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
-        audioChannels = parseAudioChannelConfiguration(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, (SingleSegmentBase) segmentBase);
+        segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, (SegmentList) segmentBase);
+        segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase);
+        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
         parseAdaptationSetChild(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "AdaptationSet"));
 
+    // Build the representations.
     List<Representation> representations = new ArrayList<>(representationInfos.size());
     for (int i = 0; i < representationInfos.size(); i++) {
       representations.add(buildRepresentation(representationInfos.get(i), contentId,
-          drmSchemeDatas));
+          drmSchemeDatas, inbandEventStreams));
     }
 
-    return buildAdaptationSet(id, contentType, representations);
+    return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected AdaptationSet buildAdaptationSet(int id, int contentType,
-      List<Representation> representations) {
-    return new AdaptationSet(id, contentType, representations);
+      List<Representation> representations, List<SchemeValuePair> accessibilityDescriptors) {
+    return new AdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected int parseContentType(XmlPullParser xpp) {
@@ -304,8 +318,7 @@ protected int getContentType(Format format) {
       return C.TRACK_TYPE_VIDEO;
     } else if (MimeTypes.isAudio(sampleMimeType)) {
       return C.TRACK_TYPE_AUDIO;
-    } else if (mimeTypeIsRawText(sampleMimeType)
-        || MimeTypes.APPLICATION_RAWCC.equals(format.containerMimeType)) {
+    } else if (mimeTypeIsRawText(sampleMimeType)) {
       return C.TRACK_TYPE_TEXT;
     }
     return C.TRACK_TYPE_UNKNOWN;
@@ -348,6 +361,50 @@ protected SchemeData parseContentProtection(XmlPullParser xpp) throws XmlPullPar
     }
   }
 
+  /**
+   * Parses an InbandEventStream element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseInbandEventStream(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "InbandEventStream");
+  }
+
+  /**
+   * Parses an Accessibility element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseAccessibility(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "Accessibility");
+  }
+
+  /**
+   * Parses a Role element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return {@link C.SelectionFlags} parsed from the element.
+   */
+  protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOException {
+    String schemeIdUri = parseString(xpp, "schemeIdUri", null);
+    String value = parseString(xpp, "value", null);
+    do {
+      xpp.next();
+    } while (!XmlPullParserUtil.isEndTag(xpp, "Role"));
+    return "urn:mpeg:dash:role:2011".equals(schemeIdUri) && "main".equals(value)
+        ? C.SELECTION_FLAG_DEFAULT : 0;
+  }
+
   /**
    * Parses children of AdaptationSet elements not specifically parsed elsewhere.
    *
@@ -365,7 +422,9 @@ protected void parseAdaptationSetChild(XmlPullParser xpp)
   protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseUrl,
       String adaptationSetMimeType, String adaptationSetCodecs, int adaptationSetWidth,
       int adaptationSetHeight, float adaptationSetFrameRate, int adaptationSetAudioChannels,
-      int adaptationSetAudioSamplingRate, String adaptationSetLanguage, SegmentBase segmentBase)
+      int adaptationSetAudioSamplingRate, String adaptationSetLanguage,
+      @C.SelectionFlags int adaptationSetSelectionFlags,
+      List<SchemeValuePair> adaptationSetAccessibilityDescriptors, SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     int bandwidth = parseInt(xpp, "bandwidth", Format.NO_VALUE);
@@ -378,6 +437,7 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
     int audioChannels = adaptationSetAudioChannels;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", adaptationSetAudioSamplingRate);
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -390,64 +450,77 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
       } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
         audioChannels = parseAudioChannelConfiguration(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
-        segmentBase = parseSegmentBase(xpp, baseUrl, (SingleSegmentBase) segmentBase);
+        segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
-        segmentBase = parseSegmentList(xpp, baseUrl, (SegmentList) segmentBase);
+        segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
-        segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase);
+        segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentProtection")) {
         SchemeData contentProtection = parseContentProtection(xpp);
         if (contentProtection != null) {
           drmSchemeDatas.add(contentProtection);
         }
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
     Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
-        audioSamplingRate, bandwidth, adaptationSetLanguage, codecs);
-    segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase(baseUrl);
+        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetSelectionFlags,
+        adaptationSetAccessibilityDescriptors, codecs);
+    segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
-    return new RepresentationInfo(format, segmentBase, drmSchemeDatas);
+    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas, inbandEventStreams);
   }
 
   protected Format buildFormat(String id, String containerMimeType, int width, int height,
       float frameRate, int audioChannels, int audioSamplingRate, int bitrate, String language,
+      @C.SelectionFlags int selectionFlags, List<SchemeValuePair> accessibilityDescriptors,
       String codecs) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
     if (sampleMimeType != null) {
       if (MimeTypes.isVideo(sampleMimeType)) {
         return Format.createVideoContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, width, height, frameRate, null);
+            bitrate, width, height, frameRate, null, selectionFlags);
       } else if (MimeTypes.isAudio(sampleMimeType)) {
         return Format.createAudioContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, audioChannels, audioSamplingRate, null, 0, language);
+            bitrate, audioChannels, audioSamplingRate, null, selectionFlags, language);
       } else if (mimeTypeIsRawText(sampleMimeType)) {
+        int accessibilityChannel;
+        if (MimeTypes.APPLICATION_CEA608.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea608AccessibilityChannel(accessibilityDescriptors);
+        } else if (MimeTypes.APPLICATION_CEA708.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea708AccessibilityChannel(accessibilityDescriptors);
+        } else {
+          accessibilityChannel = Format.NO_VALUE;
+        }
         return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, 0, language);
-      } else {
-        return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
+            bitrate, selectionFlags, language, accessibilityChannel);
       }
-    } else {
-      return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
     }
+    return Format.createContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
+        selectionFlags, language);
   }
 
   protected Representation buildRepresentation(RepresentationInfo representationInfo,
-      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas) {
+      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas,
+      ArrayList<SchemeValuePair> extraInbandEventStreams) {
     Format format = representationInfo.format;
     ArrayList<SchemeData> drmSchemeDatas = representationInfo.drmSchemeDatas;
     drmSchemeDatas.addAll(extraDrmSchemeDatas);
     if (!drmSchemeDatas.isEmpty()) {
       format = format.copyWithDrmInitData(new DrmInitData(drmSchemeDatas));
     }
+    ArrayList<SchemeValuePair> inbandEventStremas = representationInfo.inbandEventStreams;
+    inbandEventStremas.addAll(extraInbandEventStreams);
     return Representation.newInstance(contentId, Representation.REVISION_ID_DEFAULT, format,
-        representationInfo.segmentBase);
+        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStremas);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
 
-  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, String baseUrl,
-      SingleSegmentBase parent) throws XmlPullParserException, IOException {
+  protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, SingleSegmentBase parent)
+      throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
@@ -466,21 +539,21 @@ protected SingleSegmentBase parseSegmentBase(XmlPullParser xpp, String baseUrl,
     do {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentBase"));
 
-    return buildSingleSegmentBase(initialization, timescale, presentationTimeOffset, baseUrl,
-        indexStart, indexLength);
+    return buildSingleSegmentBase(initialization, timescale, presentationTimeOffset, indexStart,
+        indexLength);
   }
 
   protected SingleSegmentBase buildSingleSegmentBase(RangedUri initialization, long timescale,
-      long presentationTimeOffset, String baseUrl, long indexStart, long indexLength) {
-    return new SingleSegmentBase(initialization, timescale, presentationTimeOffset, baseUrl,
-        indexStart, indexLength);
+      long presentationTimeOffset, long indexStart, long indexLength) {
+    return new SingleSegmentBase(initialization, timescale, presentationTimeOffset, indexStart,
+        indexLength);
   }
 
-  protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, SegmentList parent)
+  protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
       throws XmlPullParserException, IOException {
 
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
@@ -496,14 +569,14 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, Segmen
     do {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentURL")) {
         if (segments == null) {
           segments = new ArrayList<>();
         }
-        segments.add(parseSegmentUrl(xpp, baseUrl));
+        segments.add(parseSegmentUrl(xpp));
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "SegmentList"));
 
@@ -524,8 +597,8 @@ protected SegmentList buildSegmentList(RangedUri initialization, long timescale,
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl,
-      SegmentTemplate parent) throws XmlPullParserException, IOException {
+  protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplate parent)
+      throws XmlPullParserException, IOException {
     long timescale = parseLong(xpp, "timescale", parent != null ? parent.timescale : 1);
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
@@ -542,7 +615,7 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl
     do {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Initialization")) {
-        initialization = parseInitialization(xpp, baseUrl);
+        initialization = parseInitialization(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTimeline")) {
         timeline = parseSegmentTimeline(xpp);
       }
@@ -554,15 +627,15 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, String baseUrl
     }
 
     return buildSegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
+        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
   protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long timescale,
       long presentationTimeOffset, int startNumber, long duration,
       List<SegmentTimelineElement> timeline, UrlTemplate initializationTemplate,
-      UrlTemplate mediaTemplate, String baseUrl) {
+      UrlTemplate mediaTemplate) {
     return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
-        startNumber, duration, timeline, initializationTemplate, mediaTemplate, baseUrl);
+        startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
@@ -597,15 +670,15 @@ protected UrlTemplate parseUrlTemplate(XmlPullParser xpp, String name,
     return defaultValue;
   }
 
-  protected RangedUri parseInitialization(XmlPullParser xpp, String baseUrl) {
-    return parseRangedUrl(xpp, baseUrl, "sourceURL", "range");
+  protected RangedUri parseInitialization(XmlPullParser xpp) {
+    return parseRangedUrl(xpp, "sourceURL", "range");
   }
 
-  protected RangedUri parseSegmentUrl(XmlPullParser xpp, String baseUrl) {
-    return parseRangedUrl(xpp, baseUrl, "media", "mediaRange");
+  protected RangedUri parseSegmentUrl(XmlPullParser xpp) {
+    return parseRangedUrl(xpp, "media", "mediaRange");
   }
 
-  protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String urlAttribute,
+  protected RangedUri parseRangedUrl(XmlPullParser xpp, String urlAttribute,
       String rangeAttribute) {
     String urlText = xpp.getAttributeValue(null, urlAttribute);
     long rangeStart = 0;
@@ -618,12 +691,11 @@ protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String url
         rangeLength = Long.parseLong(rangeTextArray[1]) - rangeStart + 1;
       }
     }
-    return buildRangedUri(baseUrl, urlText, rangeStart, rangeLength);
+    return buildRangedUri(urlText, rangeStart, rangeLength);
   }
 
-  protected RangedUri buildRangedUri(String baseUrl, String urlText, long rangeStart,
-      long rangeLength) {
-    return new RangedUri(baseUrl, urlText, rangeStart, rangeLength);
+  protected RangedUri buildRangedUri(String urlText, long rangeStart, long rangeLength) {
+    return new RangedUri(urlText, rangeStart, rangeLength);
   }
 
   // AudioChannelConfiguration parsing.
@@ -653,6 +725,14 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
       return MimeTypes.getAudioMediaMimeType(codecs);
     } else if (MimeTypes.isVideo(containerMimeType)) {
       return MimeTypes.getVideoMediaMimeType(codecs);
+    } else if (mimeTypeIsRawText(containerMimeType)) {
+      return containerMimeType;
+    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
+      if ("stpp".equals(codecs)) {
+        return MimeTypes.APPLICATION_TTML;
+      } else if ("wvtt".equals(codecs)) {
+        return MimeTypes.APPLICATION_MP4VTT;
+      }
     } else if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
       if (codecs != null) {
         if (codecs.contains("cea708")) {
@@ -662,14 +742,6 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
         }
       }
       return null;
-    } else if (mimeTypeIsRawText(containerMimeType)) {
-      return containerMimeType;
-    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
-      if ("stpp".equals(codecs)) {
-        return MimeTypes.APPLICATION_TTML;
-      } else if ("wvtt".equals(codecs)) {
-        return MimeTypes.APPLICATION_MP4VTT;
-      }
     }
     return null;
   }
@@ -681,7 +753,11 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
    * @return Whether the mimeType is a text sample mimeType.
    */
   private static boolean mimeTypeIsRawText(String mimeType) {
-    return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
+    return MimeTypes.isText(mimeType)
+        || MimeTypes.APPLICATION_TTML.equals(mimeType)
+        || MimeTypes.APPLICATION_MP4VTT.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA708.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA608.equals(mimeType);
   }
 
   /**
@@ -727,6 +803,59 @@ private static int checkContentTypeConsistency(int firstType, int secondType) {
     }
   }
 
+  /**
+   * Parses a {@link SchemeValuePair} from an element.
+   *
+   * @param xpp The parser from which to read.
+   * @param tag The tag of the element being parsed.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return The parsed {@link SchemeValuePair}.
+   */
+  protected static SchemeValuePair parseSchemeValuePair(XmlPullParser xpp, String tag)
+      throws XmlPullParserException, IOException {
+    String schemeIdUri = parseString(xpp, "schemeIdUri", null);
+    String value = parseString(xpp, "value", null);
+    do {
+      xpp.next();
+    } while (!XmlPullParserUtil.isEndTag(xpp, tag));
+    return new SchemeValuePair(schemeIdUri, value);
+  }
+
+  protected static int parseCea608AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-608:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_608_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-608 channel number from: " + descriptor.value);
+        }
+      }
+    }
+    return Format.NO_VALUE;
+  }
+
+  protected static int parseCea708AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-708:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_708_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-708 service block number from: " + descriptor.value);
+        }
+      }
+    }
+    return Format.NO_VALUE;
+  }
+
   protected static float parseFrameRate(XmlPullParser xpp, float defaultValue) {
     float frameRate = defaultValue;
     String frameRateAttribute = xpp.getAttributeValue(null, "frameRate");
@@ -755,7 +884,7 @@ protected static long parseDuration(XmlPullParser xpp, String name, long default
   }
 
   protected static long parseDateTime(XmlPullParser xpp, String name, long defaultValue)
-      throws ParseException {
+      throws ParserException {
     String value = xpp.getAttributeValue(null, name);
     if (value == null) {
       return defaultValue;
@@ -788,14 +917,18 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
   private static final class RepresentationInfo {
 
     public final Format format;
+    public final String baseUrl;
     public final SegmentBase segmentBase;
     public final ArrayList<SchemeData> drmSchemeDatas;
+    public final ArrayList<SchemeValuePair> inbandEventStreams;
 
-    public RepresentationInfo(Format format, SegmentBase segmentBase,
-        ArrayList<SchemeData> drmSchemeDatas) {
+    public RepresentationInfo(Format format, String baseUrl, SegmentBase segmentBase,
+        ArrayList<SchemeData> drmSchemeDatas, ArrayList<SchemeValuePair> inbandEventStreams) {
       this.format = format;
+      this.baseUrl = baseUrl;
       this.segmentBase = segmentBase;
       this.drmSchemeDatas = drmSchemeDatas;
+      this.inbandEventStreams = inbandEventStreams;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
index 1d8b4fb300..269a63b7a9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
@@ -41,12 +41,12 @@
 
   /**
    * @param id The period identifier. May be null.
-   * @param start The start time of the period in milliseconds.
+   * @param startMs The start time of the period in milliseconds.
    * @param adaptationSets The adaptation sets belonging to the period.
    */
-  public Period(String id, long start, List<AdaptationSet> adaptationSets) {
+  public Period(String id, long startMs, List<AdaptationSet> adaptationSets) {
     this.id = id;
-    this.startMs = start;
+    this.startMs = startMs;
     this.adaptationSets = Collections.unmodifiableList(adaptationSets);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
index 1668526b22..c2a64718df 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RangedUri.java
@@ -17,11 +17,10 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.UriUtil;
 
 /**
- * Defines a range of data located at a {@link Uri}.
+ * Defines a range of data located at a reference uri.
  */
 public final class RangedUri {
 
@@ -35,12 +34,6 @@
    */
   public final long length;
 
-  // The URI is stored internally in two parts: reference URI and a base URI to use when
-  // resolving it. This helps optimize memory usage in the same way that DASH manifests allow many
-  // URLs to be expressed concisely in the form of a single BaseURL and many relative paths. Note
-  // that this optimization relies on the same object being passed as the base URI to many
-  // instances of this class.
-  private final String baseUri;
   private final String referenceUri;
 
   private int hashCode;
@@ -48,57 +41,59 @@
   /**
    * Constructs an ranged uri.
    *
-   * @param baseUri A uri that can form the base of the uri defined by the instance.
-   * @param referenceUri A reference uri that should be resolved with respect to {@code baseUri}.
+   * @param referenceUri The reference uri.
    * @param start The (zero based) index of the first byte of the range.
    * @param length The length of the range, or {@link C#LENGTH_UNSET} to indicate that the range is
    *     unbounded.
    */
-  public RangedUri(String baseUri, String referenceUri, long start, long length) {
-    Assertions.checkArgument(baseUri != null || referenceUri != null);
-    this.baseUri = baseUri;
-    this.referenceUri = referenceUri;
+  public RangedUri(String referenceUri, long start, long length) {
+    this.referenceUri = referenceUri == null ? "" : referenceUri;
     this.start = start;
     this.length = length;
   }
 
   /**
-   * Returns the {@link Uri} represented by the instance.
+   * Returns the resolved {@link Uri} represented by the instance.
    *
+   * @param baseUri The base Uri.
    * @return The {@link Uri} represented by the instance.
    */
-  public Uri getUri() {
+  public Uri resolveUri(String baseUri) {
     return UriUtil.resolveToUri(baseUri, referenceUri);
   }
 
   /**
-   * Returns the uri represented by the instance as a string.
+   * Returns the resolved uri represented by the instance as a string.
    *
+   * @param baseUri The base Uri.
    * @return The uri represented by the instance.
    */
-  public String getUriString() {
+  public String resolveUriString(String baseUri) {
     return UriUtil.resolve(baseUri, referenceUri);
   }
 
   /**
-   * Attempts to merge this {@link RangedUri} with another.
+   * Attempts to merge this {@link RangedUri} with another and an optional common base uri.
    * <p>
-   * A merge is successful if both instances define the same {@link Uri}, and if one starts the byte
-   * after the other ends, forming a contiguous region with no overlap.
+   * A merge is successful if both instances define the same {@link Uri} after resolution with the
+   * base uri, and if one starts the byte after the other ends, forming a contiguous region with
+   * no overlap.
    * <p>
    * If {@code other} is null then the merge is considered unsuccessful, and null is returned.
    *
    * @param other The {@link RangedUri} to merge.
+   * @param baseUri The optional base Uri.
    * @return The merged {@link RangedUri} if the merge was successful. Null otherwise.
    */
-  public RangedUri attemptMerge(RangedUri other) {
-    if (other == null || !getUriString().equals(other.getUriString())) {
+  public RangedUri attemptMerge(RangedUri other, String baseUri) {
+    final String resolvedUri = resolveUriString(baseUri);
+    if (other == null || !resolvedUri.equals(other.resolveUriString(baseUri))) {
       return null;
     } else if (length != C.LENGTH_UNSET && start + length == other.start) {
-      return new RangedUri(baseUri, referenceUri, start,
+      return new RangedUri(resolvedUri, start,
           other.length == C.LENGTH_UNSET ? C.LENGTH_UNSET : length + other.length);
     } else if (other.length != C.LENGTH_UNSET && other.start + other.length == start) {
-      return new RangedUri(baseUri, referenceUri, other.start,
+      return new RangedUri(resolvedUri, other.start,
           length == C.LENGTH_UNSET ? C.LENGTH_UNSET : other.length + length);
     } else {
       return null;
@@ -111,7 +106,7 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (int) start;
       result = 31 * result + (int) length;
-      result = 31 * result + getUriString().hashCode();
+      result = 31 * result + referenceUri.hashCode();
       hashCode = result;
     }
     return hashCode;
@@ -128,7 +123,7 @@ public boolean equals(Object obj) {
     RangedUri other = (RangedUri) obj;
     return this.start == other.start
         && this.length == other.length
-        && getUriString().equals(other.getUriString());
+        && referenceUri.equals(other.referenceUri);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index 9c6d2e1582..4146037e1c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -21,6 +21,8 @@
 import com.google.android.exoplayer2.source.dash.DashSegmentIndex;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.MultiSegmentBase;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * A DASH representation.
@@ -52,12 +54,19 @@
    * The format of the representation.
    */
   public final Format format;
+  /**
+   * The base URL of the representation.
+   */
+  public final String baseUrl;
   /**
    * The offset of the presentation timestamps in the media stream relative to media time.
    */
   public final long presentationTimeOffsetUs;
+  /**
+   * The in-band event streams in the representation. Never null, but may be empty.
+   */
+  public final List<SchemeValuePair> inbandEventStreams;
 
-  private final String cacheKey;
   private final RangedUri initializationUri;
 
   /**
@@ -66,12 +75,13 @@
    * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
+   * @param baseUrl The base URL.
    * @param segmentBase A segment base element for the representation.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase) {
-    return newInstance(contentId, revisionId, format, segmentBase, null);
+      String baseUrl, SegmentBase segmentBase) {
+    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
   }
 
   /**
@@ -80,31 +90,54 @@ public static Representation newInstance(String contentId, long revisionId, Form
    * @param contentId Identifies the piece of content to which this representation belongs.
    * @param revisionId Identifies the revision of the content.
    * @param format The format of the representation.
+   * @param baseUrl The base URL.
    * @param segmentBase A segment base element for the representation.
-   * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase, String customCacheKey) {
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams,
+        null);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param contentId Identifies the piece of content to which this representation belongs.
+   * @param revisionId Identifies the revision of the content.
+   * @param format The format of the representation.
+   * @param baseUrl The base URL of the representation.
+   * @param segmentBase A segment base element for the representation.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
+   * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null. This
+   *     parameter is ignored if {@code segmentBase} consists of multiple segments.
+   * @return The constructed instance.
+   */
+  public static Representation newInstance(String contentId, long revisionId, Format format,
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+      String customCacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
-      return new SingleSegmentRepresentation(contentId, revisionId, format,
-          (SingleSegmentBase) segmentBase, customCacheKey, C.LENGTH_UNSET);
+      return new SingleSegmentRepresentation(contentId, revisionId, format, baseUrl,
+          (SingleSegmentBase) segmentBase, inbandEventStreams, customCacheKey, C.LENGTH_UNSET);
     } else if (segmentBase instanceof MultiSegmentBase) {
-      return new MultiSegmentRepresentation(contentId, revisionId, format,
-          (MultiSegmentBase) segmentBase, customCacheKey);
+      return new MultiSegmentRepresentation(contentId, revisionId, format, baseUrl,
+          (MultiSegmentBase) segmentBase, inbandEventStreams);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
     }
   }
 
-  private Representation(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase, String customCacheKey) {
+  private Representation(String contentId, long revisionId, Format format, String baseUrl,
+      SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
     this.contentId = contentId;
     this.revisionId = revisionId;
     this.format = format;
-    this.cacheKey = customCacheKey != null ? customCacheKey
-        : contentId + "." + format.id + "." + revisionId;
+    this.baseUrl = baseUrl;
+    this.inbandEventStreams = inbandEventStreams == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(inbandEventStreams);
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
@@ -129,12 +162,10 @@ public RangedUri getInitializationUri() {
   public abstract DashSegmentIndex getIndex();
 
   /**
-   * Returns a cache key for the representation, in the format
-   * {@code contentId + "." + format.id + "." + revisionId}.
+   * Returns a cache key for the representation if a custom cache key or content id has been
+   * provided and there is only single segment.
    */
-  public String getCacheKey() {
-    return cacheKey;
-  }
+  public abstract String getCacheKey();
 
   /**
    * A DASH representation consisting of a single segment.
@@ -151,6 +182,7 @@ public String getCacheKey() {
      */
     public final long contentLength;
 
+    private final String cacheKey;
     private final RangedUri indexUri;
     private final SingleSegmentIndex segmentIndex;
 
@@ -163,38 +195,45 @@ public String getCacheKey() {
      * @param initializationEnd The offset of the last byte of initialization data.
      * @param indexStart The offset of the first byte of index data.
      * @param indexEnd The offset of the last byte of index data.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
         Format format, String uri, long initializationStart, long initializationEnd,
-        long indexStart, long indexEnd, String customCacheKey, long contentLength) {
-      RangedUri rangedUri = new RangedUri(uri, null, initializationStart,
+        long indexStart, long indexEnd, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
+      RangedUri rangedUri = new RangedUri(null, initializationStart,
           initializationEnd - initializationStart + 1);
-      SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, uri, indexStart,
+      SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, indexStart,
           indexEnd - indexStart + 1);
       return new SingleSegmentRepresentation(contentId, revisionId,
-          format, segmentBase, customCacheKey, contentLength);
+          format, uri, segmentBase, inbandEventStreams, customCacheKey, contentLength);
     }
 
     /**
      * @param contentId Identifies the piece of content to which this representation belongs.
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
+     * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        SingleSegmentBase segmentBase, String customCacheKey, long contentLength) {
-      super(contentId, revisionId, format, segmentBase, customCacheKey);
-      this.uri = Uri.parse(segmentBase.uri);
+        String baseUrl, SingleSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
+      this.uri = Uri.parse(baseUrl);
       this.indexUri = segmentBase.getIndex();
+      this.cacheKey = customCacheKey != null ? customCacheKey
+          : contentId != null ? contentId + "." + format.id + "." + revisionId : null;
       this.contentLength = contentLength;
       // If we have an index uri then the index is defined externally, and we shouldn't return one
       // directly. If we don't, then we can't do better than an index defining a single segment.
       segmentIndex = indexUri != null ? null
-          : new SingleSegmentIndex(new RangedUri(segmentBase.uri, null, 0, contentLength));
+          : new SingleSegmentIndex(new RangedUri(null, 0, contentLength));
     }
 
     @Override
@@ -207,6 +246,11 @@ public DashSegmentIndex getIndex() {
       return segmentIndex;
     }
 
+    @Override
+    public String getCacheKey() {
+      return cacheKey;
+    }
+
   }
 
   /**
@@ -221,12 +265,13 @@ public DashSegmentIndex getIndex() {
      * @param contentId Identifies the piece of content to which this representation belongs.
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
+     * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
-     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      */
     public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        MultiSegmentBase segmentBase, String customCacheKey) {
-      super(contentId, revisionId, format, segmentBase, customCacheKey);
+        String baseUrl, MultiSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.segmentBase = segmentBase;
     }
 
@@ -240,6 +285,11 @@ public DashSegmentIndex getIndex() {
       return this;
     }
 
+    @Override
+    public String getCacheKey() {
+      return null;
+    }
+
     // DashSegmentIndex implementation.
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
new file mode 100644
index 0000000000..470bf0f989
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * A pair consisting of a scheme ID and value.
+ */
+public class SchemeValuePair {
+
+  public final String schemeIdUri;
+  public final String value;
+
+  public SchemeValuePair(String schemeIdUri, String value) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    SchemeValuePair other = (SchemeValuePair) obj;
+    return Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * (schemeIdUri != null ? schemeIdUri.hashCode() : 0)
+        + (value != null ? value.hashCode() : 0);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index dec626c326..70a65e932a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -65,11 +65,6 @@ public long getPresentationTimeOffsetUs() {
    */
   public static class SingleSegmentBase extends SegmentBase {
 
-    /**
-     * The uri of the segment.
-     */
-    public final String uri;
-
     /* package */ final long indexStart;
     /* package */ final long indexLength;
 
@@ -79,27 +74,22 @@ public long getPresentationTimeOffsetUs() {
      * @param timescale The timescale in units per second.
      * @param presentationTimeOffset The presentation time offset. The value in seconds is the
      *     division of this value and {@code timescale}.
-     * @param uri The uri of the segment.
      * @param indexStart The byte offset of the index data in the segment.
      * @param indexLength The length of the index data in bytes.
      */
     public SingleSegmentBase(RangedUri initialization, long timescale, long presentationTimeOffset,
-        String uri, long indexStart, long indexLength) {
+        long indexStart, long indexLength) {
       super(initialization, timescale, presentationTimeOffset);
-      this.uri = uri;
       this.indexStart = indexStart;
       this.indexLength = indexLength;
     }
 
-    /**
-     * @param uri The uri of the segment.
-     */
-    public SingleSegmentBase(String uri) {
-      this(null, 1, 0, uri, 0, 0);
+    public SingleSegmentBase() {
+      this(null, 1, 0, 0, 0);
     }
 
     public RangedUri getIndex() {
-      return indexLength <= 0 ? null : new RangedUri(uri, null, indexStart, indexLength);
+      return indexLength <= 0 ? null : new RangedUri(null, indexStart, indexLength);
     }
 
   }
@@ -153,7 +143,7 @@ public int getSegmentNum(long timeUs, long periodDurationUs) {
       } else {
         // The high index cannot be unbounded. Identify the segment using binary search.
         while (lowIndex <= highIndex) {
-          int midIndex = (lowIndex + highIndex) / 2;
+          int midIndex = lowIndex + (highIndex - lowIndex) / 2;
           long midTimeUs = getSegmentTimeUs(midIndex);
           if (midTimeUs < timeUs) {
             lowIndex = midIndex + 1;
@@ -279,8 +269,6 @@ public boolean isExplicit() {
     /* package */ final UrlTemplate initializationTemplate;
     /* package */ final UrlTemplate mediaTemplate;
 
-    private final String baseUrl;
-
     /**
      * @param initialization A {@link RangedUri} corresponding to initialization data, if such data
      *     exists. The value of this parameter is ignored if {@code initializationTemplate} is
@@ -299,16 +287,14 @@ public boolean isExplicit() {
      *     such data exists. If non-null then the {@code initialization} parameter is ignored. If
      *     null then {@code initialization} will be used.
      * @param mediaTemplate A template defining the location of each media segment.
-     * @param baseUrl A url to use as the base for relative urls generated by the templates.
      */
     public SegmentTemplate(RangedUri initialization, long timescale, long presentationTimeOffset,
         int startNumber, long duration, List<SegmentTimelineElement> segmentTimeline,
-        UrlTemplate initializationTemplate, UrlTemplate mediaTemplate, String baseUrl) {
+        UrlTemplate initializationTemplate, UrlTemplate mediaTemplate) {
       super(initialization, timescale, presentationTimeOffset, startNumber,
           duration, segmentTimeline);
       this.initializationTemplate = initializationTemplate;
       this.mediaTemplate = mediaTemplate;
-      this.baseUrl = baseUrl;
     }
 
     @Override
@@ -316,7 +302,7 @@ public RangedUri getInitialization(Representation representation) {
       if (initializationTemplate != null) {
         String urlString = initializationTemplate.buildUri(representation.format.id, 0,
             representation.format.bitrate, 0);
-        return new RangedUri(baseUrl, urlString, 0, C.LENGTH_UNSET);
+        return new RangedUri(urlString, 0, C.LENGTH_UNSET);
       } else {
         return super.getInitialization(representation);
       }
@@ -332,7 +318,7 @@ public RangedUri getSegmentUrl(Representation representation, int sequenceNumber
       }
       String uriString = mediaTemplate.buildUri(representation.format.id, sequenceNumber,
           representation.format.bitrate, time);
-      return new RangedUri(baseUrl, uriString, 0, C.LENGTH_UNSET);
+      return new RangedUri(uriString, 0, C.LENGTH_UNSET);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 53d9e70d76..c7c66fbd61 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -17,34 +17,24 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
-import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.Extractor;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
-import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
-import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
-import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
-import com.google.android.exoplayer2.extractor.ts.DefaultStreamReaderFactory;
-import com.google.android.exoplayer2.extractor.ts.TsExtractor;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.chunk.DataChunk;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.Arrays;
@@ -65,7 +55,7 @@ public HlsChunkHolder() {
     }
 
     /**
-     * The chunk.
+     * The chunk to be loaded next.
      */
     public Chunk chunk;
 
@@ -75,9 +65,9 @@ public HlsChunkHolder() {
     public boolean endOfStream;
 
     /**
-     * Milliseconds to wait before retrying.
+     * Indicates that the chunk source is waiting for the referred playlist to be refreshed.
      */
-    public long retryInMs;
+    public HlsUrl playlist;
 
     /**
      * Clears the holder.
@@ -85,43 +75,21 @@ public HlsChunkHolder() {
     public void clear() {
       chunk = null;
       endOfStream = false;
-      retryInMs = C.TIME_UNSET;
+      playlist = null;
     }
 
   }
 
-  /**
-   * The default time for which a media playlist should be blacklisted.
-   */
-  public static final long DEFAULT_PLAYLIST_BLACKLIST_MS = 60000;
-  /**
-   * Subtracted value to lookup position when switching between variants in live streams to avoid
-   * gaps in playback in case playlist drift apart.
-   */
-  private static final double LIVE_VARIANT_SWITCH_SAFETY_EXTRA_SECS = 2.0;
-  private static final String AAC_FILE_EXTENSION = ".aac";
-  private static final String AC3_FILE_EXTENSION = ".ac3";
-  private static final String EC3_FILE_EXTENSION = ".ec3";
-  private static final String MP3_FILE_EXTENSION = ".mp3";
-  private static final String MP4_FILE_EXTENSION = ".mp4";
-  private static final String VTT_FILE_EXTENSION = ".vtt";
-  private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
-
-  private final String baseUri;
   private final DataSource dataSource;
-  private final HlsPlaylistParser playlistParser;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
-  private final HlsMasterPlaylist.HlsUrl[] variants;
-  private final HlsMediaPlaylist[] variantPlaylists;
+  private final HlsUrl[] variants;
+  private final HlsPlaylistTracker playlistTracker;
   private final TrackGroup trackGroup;
-  private final long[] variantLastPlaylistLoadTimesMs;
 
+  private boolean isTimestampMaster;
   private byte[] scratchSpace;
-  private boolean live;
-  private long durationUs;
   private IOException fatalError;
 
-  private HlsInitializationChunk lastLoadedInitializationChunk;
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
@@ -133,22 +101,19 @@ public void clear() {
   private TrackSelection trackSelection;
 
   /**
-   * @param baseUri The playlist's base uri.
+   * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
    * @param variants The available variants.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
    */
-  public HlsChunkSource(String baseUri, HlsMasterPlaylist.HlsUrl[] variants, DataSource dataSource,
-      TimestampAdjusterProvider timestampAdjusterProvider) {
-    this.baseUri = baseUri;
+  public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
+      DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
+    this.playlistTracker = playlistTracker;
     this.variants = variants;
     this.dataSource = dataSource;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
-    playlistParser = new HlsPlaylistParser();
-    variantPlaylists = new HlsMediaPlaylist[variants.length];
-    variantLastPlaylistLoadTimesMs = new long[variants.length];
 
     Format[] variantFormats = new Format[variants.length];
     int[] initialTrackSelection = new int[variants.length];
@@ -172,20 +137,6 @@ public void maybeThrowError() throws IOException {
     }
   }
 
-  /**
-   * Returns whether this is a live playback.
-   */
-  public boolean isLive() {
-    return live;
-  }
-
-  /**
-   * Returns the duration of the source, or {@link C#TIME_UNSET} if the duration is unknown.
-   */
-  public long getDurationUs() {
-    return durationUs;
-  }
-
   /**
    * Returns the track group exposed by the source.
    */
@@ -209,13 +160,23 @@ public void reset() {
     fatalError = null;
   }
 
+  /**
+   * Sets whether this chunk source is responsible for initializing timestamp adjusters.
+   *
+   * @param isTimestampMaster True if this chunk source is responsible for initializing timestamp
+   *     adjusters.
+   */
+  public void setIsTimestampMaster(boolean isTimestampMaster) {
+    this.isTimestampMaster = isTimestampMaster;
+  }
+
   /**
    * Returns the next chunk to load.
    * <p>
    * If a chunk is available then {@link HlsChunkHolder#chunk} is set. If the end of the stream has
    * been reached then {@link HlsChunkHolder#endOfStream} is set. If a chunk is not available but
-   * the end of the stream has not been reached, {@link HlsChunkHolder#retryInMs} is set to contain
-   * the amount of milliseconds to wait before retrying.
+   * the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
+   * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
    *
    * @param previous The most recently loaded media chunk.
    * @param playbackPositionUs The current playback position. If {@code previous} is null then this
@@ -226,80 +187,63 @@ public void reset() {
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
     int oldVariantIndex = previous == null ? C.INDEX_UNSET
         : trackGroup.indexOf(previous.trackFormat);
-
     // Use start time of the previous chunk rather than its end time because switching format will
     // require downloading overlapping segments.
     long bufferedDurationUs = previous == null ? 0
-        : Math.max(0, previous.getAdjustedStartTimeUs() - playbackPositionUs);
+        : Math.max(0, previous.startTimeUs - playbackPositionUs);
+
+    // Select the variant.
     trackSelection.updateSelectedTrack(bufferedDurationUs);
-    int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
-
-    boolean switchingVariant = oldVariantIndex != newVariantIndex;
-    HlsMediaPlaylist mediaPlaylist = variantPlaylists[newVariantIndex];
-    if (mediaPlaylist == null) {
-      // We don't have the media playlist for the next variant. Request it now.
-      out.chunk = newMediaPlaylistChunk(newVariantIndex, trackSelection.getSelectionReason(),
-          trackSelection.getSelectionData());
+    int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
+
+    boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
+    HlsUrl selectedUrl = variants[selectedVariantIndex];
+    if (!playlistTracker.isSnapshotValid(selectedUrl)) {
+      out.playlist = selectedUrl;
+      // Retry when playlist is refreshed.
       return;
     }
+    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
 
+    // Select the chunk.
     int chunkMediaSequence;
-    if (live) {
-      if (previous == null) {
-        // When playing a live stream, the starting chunk will be the third counting from the live
-        // edge.
-        chunkMediaSequence = Math.max(0, mediaPlaylist.segments.size() - 3)
-            + mediaPlaylist.mediaSequence;
-        // TODO: Bring this back for live window seeking.
-        // chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
-        //     true, true) + mediaPlaylist.mediaSequence;
+    if (previous == null || switchingVariant) {
+      long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;
+      if (!mediaPlaylist.hasEndTag && targetPositionUs > mediaPlaylist.getEndTimeUs()) {
+        // If the playlist is too old to contain the chunk, we need to refresh it.
+        chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
       } else {
-        chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
-            newVariantIndex);
-        if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
+            targetPositionUs - mediaPlaylist.startTimeUs, true,
+            !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
+        if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
-          newVariantIndex = oldVariantIndex;
-          mediaPlaylist = variantPlaylists[newVariantIndex];
-          chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
-              newVariantIndex);
-          if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-            fatalError = new BehindLiveWindowException();
-            return;
-          }
+          selectedVariantIndex = oldVariantIndex;
+          selectedUrl = variants[selectedVariantIndex];
+          mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
+          chunkMediaSequence = previous.getNextChunkIndex();
         }
       }
     } else {
-      // Not live.
-      if (previous == null) {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
-            true, true) + mediaPlaylist.mediaSequence;
-      } else if (switchingVariant) {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
-            previous.startTimeUs, true, true) + mediaPlaylist.mediaSequence;
-      } else {
-        chunkMediaSequence = previous.getNextChunkIndex();
-      }
+      chunkMediaSequence = previous.getNextChunkIndex();
+    }
+    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+      fatalError = new BehindLiveWindowException();
+      return;
     }
 
     int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
     if (chunkIndex >= mediaPlaylist.segments.size()) {
-      if (!mediaPlaylist.live) {
+      if (mediaPlaylist.hasEndTag) {
         out.endOfStream = true;
       } else /* Live */ {
-        long msToRerequestLiveMediaPlaylist = msToRerequestLiveMediaPlaylist(newVariantIndex);
-        if (msToRerequestLiveMediaPlaylist <= 0) {
-          out.chunk = newMediaPlaylistChunk(newVariantIndex,
-              trackSelection.getSelectionReason(), trackSelection.getSelectionData());
-        } else {
-          // 10 milliseconds are added to the wait to make sure the playlist is refreshed when
-          // getNextChunk() is called.
-          out.retryInMs = msToRerequestLiveMediaPlaylist + 10;
-        }
+        out.playlist = selectedUrl;
       }
       return;
     }
 
+    // Handle encryption.
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
 
     // Check if encryption is specified.
@@ -307,7 +251,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, newVariantIndex,
+        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
             trackSelection.getSelectionReason(), trackSelection.getSelectionData());
         return;
       }
@@ -318,152 +262,29 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       clearEncryptionData();
     }
 
-    // Compute start and end times, and the sequence number of the next chunk.
-    long startTimeUs;
-    if (live) {
-      if (previous == null) {
-        startTimeUs = 0;
-      } else if (switchingVariant) {
-        startTimeUs = previous.getAdjustedStartTimeUs();
-      } else {
-        startTimeUs = previous.getAdjustedEndTimeUs();
-      }
-    } else /* Not live */ {
-      startTimeUs = segment.startTimeUs;
-    }
-    long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
-    Format format = variants[newVariantIndex].format;
-
-    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
-
-    // Configure the extractor that will read the chunk.
-    Extractor extractor;
-    boolean useInitializedExtractor = lastLoadedInitializationChunk != null
-        && lastLoadedInitializationChunk.format == format;
-    boolean needNewExtractor = previous == null
-        || previous.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
-        || format != previous.trackFormat;
-    boolean extractorNeedsInit = true;
-    boolean isTimestampMaster = false;
-    TimestampAdjuster timestampAdjuster = null;
-    String lastPathSegment = chunkUri.getLastPathSegment();
-    if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
-      // TODO: Inject a timestamp adjuster and use it along with ID3 PRIV tag values with owner
-      // identifier com.apple.streaming.transportStreamTimestamp. This may also apply to the MP3
-      // case below.
-      extractor = new AdtsExtractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
-      extractor = new Ac3Extractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
-      extractor = new Mp3Extractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
-        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
-      timestampAdjuster = timestampAdjusterProvider.getAdjuster(segment.discontinuitySequenceNumber,
-          startTimeUs);
-      extractor = new WebvttExtractor(format.language, timestampAdjuster);
-    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
-      isTimestampMaster = true;
-      if (needNewExtractor) {
-        if (useInitializedExtractor) {
-          extractor = lastLoadedInitializationChunk.extractor;
-        } else {
-          timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-              segment.discontinuitySequenceNumber, startTimeUs);
-          extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
-        }
-      } else {
-        extractor = previous.extractor;
-      }
-    } else if (needNewExtractor) {
-      // MPEG-2 TS segments, but we need a new extractor.
-      isTimestampMaster = true;
-      if (useInitializedExtractor) {
-        extractor = lastLoadedInitializationChunk.extractor;
-      } else {
-        timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-            segment.discontinuitySequenceNumber, startTimeUs);
-        // This flag ensures the change of pid between streams does not affect the sample queues.
-        @DefaultStreamReaderFactory.Flags
-        int esReaderFactoryFlags = 0;
-        String codecs = variants[newVariantIndex].format.codecs;
-        if (!TextUtils.isEmpty(codecs)) {
-          // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
-          // exist. If we know from the codec attribute that they don't exist, then we can
-          // explicitly ignore them even if they're declared.
-          if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-            esReaderFactoryFlags |= DefaultStreamReaderFactory.FLAG_IGNORE_AAC_STREAM;
-          }
-          if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-            esReaderFactoryFlags |= DefaultStreamReaderFactory.FLAG_IGNORE_H264_STREAM;
-          }
-        }
-        extractor = new TsExtractor(timestampAdjuster,
-            new DefaultStreamReaderFactory(esReaderFactoryFlags), true);
-      }
-    } else {
-      // MPEG-2 TS segments, and we need to continue using the same extractor.
-      extractor = previous.extractor;
-      extractorNeedsInit = false;
+    DataSpec initDataSpec = null;
+    Segment initSegment = mediaPlaylist.initializationSegment;
+    if (initSegment != null) {
+      Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
+      initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
+          initSegment.byterangeLength, null);
     }
 
-    if (needNewExtractor && mediaPlaylist.initializationSegment != null
-        && !useInitializedExtractor) {
-      out.chunk = buildInitializationChunk(mediaPlaylist, extractor, format);
-      return;
-    }
+    // Compute start time of the next chunk.
+    long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+    int discontinuitySequence = mediaPlaylist.discontinuitySequence
+        + segment.relativeDiscontinuitySequence;
+    TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
+        discontinuitySequence, startTimeUs);
 
-    lastLoadedInitializationChunk = null;
     // Configure the data source and spec for the chunk.
+    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
-    out.chunk = new HlsMediaChunk(dataSource, dataSpec, format,
+    out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, selectedUrl,
         trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-        startTimeUs, endTimeUs, chunkMediaSequence, segment.discontinuitySequenceNumber,
-        isTimestampMaster, timestampAdjuster, extractor, extractorNeedsInit, switchingVariant,
-        encryptionKey, encryptionIv);
-  }
-
-  /**
-   * Returns the media sequence number of a chunk in a new variant for a live stream variant switch.
-   *
-   * @param previousChunkIndex The index of the last chunk in the old variant.
-   * @param oldVariantIndex The index of the old variant.
-   * @param newVariantIndex The index of the new variant.
-   * @return Media sequence number of the chunk to switch to in a live stream in the variant that
-   *     corresponds to the given {@code newVariantIndex}.
-   */
-  private int getLiveNextChunkSequenceNumber(int previousChunkIndex, int oldVariantIndex,
-      int newVariantIndex) {
-    if (oldVariantIndex == newVariantIndex) {
-      return previousChunkIndex + 1;
-    }
-    HlsMediaPlaylist oldMediaPlaylist = variantPlaylists[oldVariantIndex];
-    HlsMediaPlaylist newMediaPlaylist = variantPlaylists[newVariantIndex];
-    double offsetToLiveInstantSecs = 0;
-    for (int i = previousChunkIndex - oldMediaPlaylist.mediaSequence;
-         i < oldMediaPlaylist.segments.size(); i++) {
-      offsetToLiveInstantSecs += oldMediaPlaylist.segments.get(i).durationSecs;
-    }
-    long currentTimeMs = SystemClock.elapsedRealtime();
-    offsetToLiveInstantSecs +=
-        (double) (currentTimeMs - variantLastPlaylistLoadTimesMs[oldVariantIndex]) / 1000;
-    offsetToLiveInstantSecs += LIVE_VARIANT_SWITCH_SAFETY_EXTRA_SECS;
-    offsetToLiveInstantSecs -=
-        (double) (currentTimeMs - variantLastPlaylistLoadTimesMs[newVariantIndex]) / 1000;
-    if (offsetToLiveInstantSecs < 0) {
-      // The instant we are looking for is not contained in the playlist, we need it to be
-      // refreshed.
-      return newMediaPlaylist.mediaSequence + newMediaPlaylist.segments.size() + 1;
-    }
-    for (int i = newMediaPlaylist.segments.size() - 1; i >= 0; i--) {
-      offsetToLiveInstantSecs -= newMediaPlaylist.segments.get(i).durationSecs;
-      if (offsetToLiveInstantSecs < 0) {
-        return newMediaPlaylist.mediaSequence + i;
-      }
-    }
-    // We have fallen behind the live window.
-    return newMediaPlaylist.mediaSequence - 1;
+        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence, discontinuitySequence,
+        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv);
   }
 
   /**
@@ -473,13 +294,7 @@ private int getLiveNextChunkSequenceNumber(int previousChunkIndex, int oldVarian
    * @param chunk The chunk whose load has been completed.
    */
   public void onChunkLoadCompleted(Chunk chunk) {
-    if (chunk instanceof HlsInitializationChunk) {
-      lastLoadedInitializationChunk = (HlsInitializationChunk) chunk;
-    } else if (chunk instanceof MediaPlaylistChunk) {
-      MediaPlaylistChunk mediaPlaylistChunk = (MediaPlaylistChunk) chunk;
-      scratchSpace = mediaPlaylistChunk.getDataHolder();
-      setMediaPlaylist(mediaPlaylistChunk.variantIndex, mediaPlaylistChunk.getResult());
-    } else if (chunk instanceof EncryptionKeyChunk) {
+    if (chunk instanceof EncryptionKeyChunk) {
       EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
       scratchSpace = encryptionKeyChunk.getDataHolder();
       setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
@@ -493,45 +308,31 @@ public void onChunkLoadCompleted(Chunk chunk) {
    *
    * @param chunk The chunk whose load encountered the error.
    * @param cancelable Whether the load can be canceled.
-   * @param e The error.
+   * @param error The error.
    * @return Whether the load should be canceled.
    */
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException e) {
+  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
     return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-        trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), e);
-  }
-
-  // Private methods.
-
-  private HlsInitializationChunk buildInitializationChunk(HlsMediaPlaylist mediaPlaylist,
-      Extractor extractor, Format format) {
-    Segment initSegment = mediaPlaylist.initializationSegment;
-    // The initialization segment is required before the actual media chunk.
-    Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
-    DataSpec initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
-        initSegment.byterangeLength, null);
-    return new HlsInitializationChunk(dataSource, initDataSpec,
-        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), extractor,
-        format);
+        trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
   }
 
-  private long msToRerequestLiveMediaPlaylist(int variantIndex) {
-    HlsMediaPlaylist mediaPlaylist = variantPlaylists[variantIndex];
-    long timeSinceLastMediaPlaylistLoadMs =
-        SystemClock.elapsedRealtime() - variantLastPlaylistLoadTimesMs[variantIndex];
-    // Don't re-request media playlist more often than one-half of the target duration.
-    return (mediaPlaylist.targetDurationSecs * 1000) / 2 - timeSinceLastMediaPlaylistLoadMs;
+  /**
+   * Called when a playlist is blacklisted.
+   *
+   * @param url The url that references the blacklisted playlist.
+   * @param blacklistMs The amount of milliseconds for which the playlist was blacklisted.
+   */
+  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+    int trackGroupIndex = trackGroup.indexOf(url.format);
+    if (trackGroupIndex != C.INDEX_UNSET) {
+      int trackSelectionIndex = trackSelection.indexOf(trackGroupIndex);
+      if (trackSelectionIndex != C.INDEX_UNSET) {
+        trackSelection.blacklist(trackSelectionIndex, blacklistMs);
+      }
+    }
   }
 
-  private MediaPlaylistChunk newMediaPlaylistChunk(int variantIndex, int trackSelectionReason,
-      Object trackSelectionData) {
-    Uri mediaPlaylistUri = UriUtil.resolveToUri(baseUri, variants[variantIndex].url);
-    DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNSET, null,
-        DataSpec.FLAG_ALLOW_GZIP);
-    return new MediaPlaylistChunk(dataSource, dataSpec, variants[variantIndex].format,
-        trackSelectionReason, trackSelectionData, scratchSpace, playlistParser, variantIndex,
-        mediaPlaylistUri);
-  }
+  // Private methods.
 
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
       int trackSelectionReason, Object trackSelectionData) {
@@ -567,13 +368,6 @@ private void clearEncryptionData() {
     encryptionIv = null;
   }
 
-  private void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist) {
-    variantLastPlaylistLoadTimesMs[variantIndex] = SystemClock.elapsedRealtime();
-    variantPlaylists[variantIndex] = mediaPlaylist;
-    live |= mediaPlaylist.live;
-    durationUs = live ? C.TIME_UNSET : mediaPlaylist.durationUs;
-  }
-
   // Private classes.
 
   /**
@@ -622,38 +416,6 @@ public Object getSelectionData() {
 
   }
 
-  private static final class MediaPlaylistChunk extends DataChunk {
-
-    public final int variantIndex;
-
-    private final HlsPlaylistParser playlistParser;
-    private final Uri playlistUri;
-
-    private HlsMediaPlaylist result;
-
-    public MediaPlaylistChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-        int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace,
-        HlsPlaylistParser playlistParser, int variantIndex,
-        Uri playlistUri) {
-      super(dataSource, dataSpec, C.DATA_TYPE_MANIFEST, trackFormat, trackSelectionReason,
-          trackSelectionData, scratchSpace);
-      this.variantIndex = variantIndex;
-      this.playlistParser = playlistParser;
-      this.playlistUri = playlistUri;
-    }
-
-    @Override
-    protected void consume(byte[] data, int limit) throws IOException {
-      result = (HlsMediaPlaylist) playlistParser.parse(playlistUri,
-          new ByteArrayInputStream(data, 0, limit));
-    }
-
-    public HlsMediaPlaylist getResult() {
-      return result;
-    }
-
-  }
-
   private static final class EncryptionKeyChunk extends DataChunk {
 
     public final String iv;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java
deleted file mode 100644
index c571b2f9df..0000000000
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
-import com.google.android.exoplayer2.extractor.Extractor;
-import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.source.chunk.Chunk;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.Util;
-
-import java.io.IOException;
-
-/**
- * An HLS initialization chunk. Provides the extractor with information required for extracting the
- * samples.
- */
-/* package */ final class HlsInitializationChunk extends Chunk {
-
-  public final Format format;
-
-  public final Extractor extractor;
-
-  private int bytesLoaded;
-  private volatile boolean loadCanceled;
-
-  public HlsInitializationChunk(DataSource dataSource, DataSpec dataSpec, int trackSelectionReason,
-      Object trackSelectionData, Extractor extractor, Format format) {
-    super(dataSource, dataSpec, C.TRACK_TYPE_DEFAULT, null, trackSelectionReason,
-        trackSelectionData, C.TIME_UNSET, C.TIME_UNSET);
-    this.extractor = extractor;
-    this.format = format;
-  }
-
-  /**
-   * Sets the {@link HlsSampleStreamWrapper} that will receive the sample format information from
-   * the initialization chunk.
-   *
-   * @param output The output that will receive the format information.
-   */
-  public void init(HlsSampleStreamWrapper output) {
-    extractor.init(output);
-  }
-
-  @Override
-  public long bytesLoaded() {
-    return bytesLoaded;
-  }
-
-  @Override
-  public void cancelLoad() {
-    loadCanceled = true;
-  }
-
-  @Override
-  public boolean isLoadCanceled() {
-    return loadCanceled;
-  }
-
-  @Override
-  public void load() throws IOException, InterruptedException {
-    DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
-    try {
-      ExtractorInput input = new DefaultExtractorInput(dataSource,
-          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
-      try {
-        int result = Extractor.RESULT_CONTINUE;
-        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
-        }
-      } finally {
-        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
-      }
-    } finally {
-      dataSource.close();
-    }
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 5c316a5653..924d3d3ece 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -15,14 +15,28 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import com.google.android.exoplayer2.Format;
+import android.text.TextUtils;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
+import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
+import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
+import com.google.android.exoplayer2.extractor.ts.TsExtractor;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -34,6 +48,17 @@
 
   private static final AtomicInteger UID_SOURCE = new AtomicInteger();
 
+  private static final String PRIV_TIMESTAMP_FRAME_OWNER =
+      "com.apple.streaming.transportStreamTimestamp";
+
+  private static final String AAC_FILE_EXTENSION = ".aac";
+  private static final String AC3_FILE_EXTENSION = ".ac3";
+  private static final String EC3_FILE_EXTENSION = ".ec3";
+  private static final String MP3_FILE_EXTENSION = ".mp3";
+  private static final String MP4_FILE_EXTENSION = ".mp4";
+  private static final String VTT_FILE_EXTENSION = ".vtt";
+  private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
+
   /**
    * A unique identifier for the chunk.
    */
@@ -45,58 +70,83 @@
   public final int discontinuitySequenceNumber;
 
   /**
-   * The extractor into which this chunk is being consumed.
+   * The url of the playlist from which this chunk was obtained.
    */
-  public final Extractor extractor;
+  public final HlsUrl hlsUrl;
 
+  private final DataSource initDataSource;
+  private final DataSpec initDataSpec;
   private final boolean isEncrypted;
-  private final boolean extractorNeedsInit;
-  private final boolean shouldSpliceIn;
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
+  private final String lastPathSegment;
+  private final Extractor previousExtractor;
+  private final boolean shouldSpliceIn;
+  private final boolean needNewExtractor;
+
+  private final boolean isPackedAudio;
+  private final Id3Decoder id3Decoder;
+  private final ParsableByteArray id3Data;
 
+  private Extractor extractor;
+  private int initSegmentBytesLoaded;
   private int bytesLoaded;
+  private boolean initLoadCompleted;
   private HlsSampleStreamWrapper extractorOutput;
-  private long adjustedEndTimeUs;
   private volatile boolean loadCanceled;
   private volatile boolean loadCompleted;
 
   /**
    * @param dataSource The source from which the data should be loaded.
    * @param dataSpec Defines the data to be loaded.
-   * @param trackFormat See {@link #trackFormat}.
+   * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
+   * @param hlsUrl The url of the playlist from which this chunk was obtained.
    * @param trackSelectionReason See {@link #trackSelectionReason}.
    * @param trackSelectionData See {@link #trackSelectionData}.
-   * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
-   * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
+   * @param startTimeUs The start time of the chunk in microseconds.
+   * @param endTimeUs The end time of the chunk in microseconds.
    * @param chunkIndex The media sequence number of the chunk.
    * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
    * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
    * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
-   * @param extractor The extractor to decode samples from the data.
-   * @param extractorNeedsInit Whether the extractor needs initializing with the target
-   *     {@link HlsSampleStreamWrapper}.
-   * @param shouldSpliceIn Whether the samples parsed from this chunk should be spliced into any
-   *     samples already queued to the {@link HlsSampleStreamWrapper}.
+   * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
    * @param encryptionKey For AES encryption chunks, the encryption key.
    * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
    */
-  public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, int discontinuitySequenceNumber, boolean isMasterTimestampSource,
-      TimestampAdjuster timestampAdjuster, Extractor extractor, boolean extractorNeedsInit,
-      boolean shouldSpliceIn, byte[] encryptionKey, byte[] encryptionIv) {
-    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, trackFormat,
+  public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
+      HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
+      long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
+      boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
+      HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
+    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
         trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
-    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+    this.initDataSpec = initDataSpec;
+    this.hlsUrl = hlsUrl;
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
-    this.extractor = extractor;
-    this.extractorNeedsInit = extractorNeedsInit;
-    this.shouldSpliceIn = shouldSpliceIn;
+    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     // Note: this.dataSource and dataSource may be different.
-    adjustedEndTimeUs = startTimeUs;
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+    lastPathSegment = dataSpec.uri.getLastPathSegment();
+    isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
+        || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
+        || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
+    if (previousChunk != null) {
+      id3Decoder = previousChunk.id3Decoder;
+      id3Data = previousChunk.id3Data;
+      previousExtractor = previousChunk.extractor;
+      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
+      needNewExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+          || shouldSpliceIn;
+    } else {
+      id3Decoder = isPackedAudio ? new Id3Decoder() : null;
+      id3Data = isPackedAudio ? new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH) : null;
+      previousExtractor = null;
+      shouldSpliceIn = false;
+      needNewExtractor = true;
+    }
+    initDataSource = dataSource;
     uid = UID_SOURCE.getAndIncrement();
   }
 
@@ -109,23 +159,6 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackForma
   public void init(HlsSampleStreamWrapper output) {
     extractorOutput = output;
     output.init(uid, shouldSpliceIn);
-    if (extractorNeedsInit) {
-      extractor.init(output);
-    }
-  }
-
-  /**
-   * Returns the presentation time in microseconds of the first sample in the chunk.
-   */
-  public long getAdjustedStartTimeUs() {
-    return adjustedEndTimeUs - getDurationUs();
-  }
-
-  /**
-   * Returns the presentation time in microseconds of the last sample in the chunk
-   */
-  public long getAdjustedEndTimeUs() {
-    return adjustedEndTimeUs;
   }
 
   @Override
@@ -152,6 +185,42 @@ public boolean isLoadCanceled() {
 
   @Override
   public void load() throws IOException, InterruptedException {
+    if (extractor == null && !isPackedAudio) {
+      // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
+      extractor = createExtractor();
+    }
+    maybeLoadInitData();
+    if (!loadCanceled) {
+      loadMedia();
+    }
+  }
+
+  // Internal loading methods.
+
+  private void maybeLoadInitData() throws IOException, InterruptedException {
+    if (previousExtractor == extractor || initLoadCompleted || initDataSpec == null) {
+      // According to spec, for packed audio, initDataSpec is expected to be null.
+      return;
+    }
+    DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
+    try {
+      ExtractorInput input = new DefaultExtractorInput(initDataSource,
+          initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
+      try {
+        int result = Extractor.RESULT_CONTINUE;
+        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+          result = extractor.read(input, null);
+        }
+      } finally {
+        initSegmentBytesLoaded = (int) (input.getPosition() - initDataSpec.absoluteStreamPosition);
+      }
+    } finally {
+      Util.closeQuietly(dataSource);
+    }
+    initLoadCompleted = true;
+  }
+
+  private void loadMedia() throws IOException, InterruptedException {
     // If we previously fed part of this chunk to the extractor, we need to skip it this time. For
     // encrypted content we need to skip the data by reading it through the source, so as to ensure
     // correct decryption of the remainder of the chunk. For clear content, we can request the
@@ -165,34 +234,88 @@ public void load() throws IOException, InterruptedException {
       loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
       skipLoadedBytes = false;
     }
+    if (!isMasterTimestampSource) {
+      timestampAdjuster.waitUntilInitialized();
+    }
     try {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+      if (extractor == null) {
+        // Media segment format is packed audio.
+        long id3Timestamp = peekId3PrivTimestamp(input);
+        if (id3Timestamp == C.TIME_UNSET) {
+          throw new ParserException("ID3 PRIV timestamp missing.");
+        }
+        extractor = buildPackedAudioExtractor(timestampAdjuster.adjustTsTimestamp(id3Timestamp));
+      }
       if (skipLoadedBytes) {
         input.skipFully(bytesLoaded);
       }
       try {
         int result = Extractor.RESULT_CONTINUE;
-        if (!isMasterTimestampSource && timestampAdjuster != null) {
-          timestampAdjuster.waitUntilInitialized();
-        }
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
           result = extractor.read(input, null);
         }
-        long adjustedEndTimeUs = extractorOutput.getLargestQueuedTimestampUs();
-        if (adjustedEndTimeUs != Long.MIN_VALUE) {
-          this.adjustedEndTimeUs = adjustedEndTimeUs;
-        }
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
 
-  // Private methods
+  /**
+   * Peek the presentation timestamp of the first sample in the chunk from an ID3 PRIV as defined
+   * in the HLS spec, version 20, Section 3.4. Returns {@link C#TIME_UNSET} if the frame is not
+   * found. This method only modifies the peek position.
+   *
+   * @param input The {@link ExtractorInput} to obtain the PRIV frame from.
+   * @return The parsed, adjusted timestamp in microseconds
+   * @throws IOException If an error occurred peeking from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
+    input.resetPeekPosition();
+    if (!input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH, true)) {
+      return C.TIME_UNSET;
+    }
+    id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
+    int id = id3Data.readUnsignedInt24();
+    if (id != Id3Decoder.ID3_TAG) {
+      return C.TIME_UNSET;
+    }
+    id3Data.skipBytes(3); // version(2), flags(1).
+    int id3Size = id3Data.readSynchSafeInt();
+    int requiredCapacity = id3Size + Id3Decoder.ID3_HEADER_LENGTH;
+    if (requiredCapacity > id3Data.capacity()) {
+      byte[] data = id3Data.data;
+      id3Data.reset(requiredCapacity);
+      System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+    }
+    if (!input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size, true)) {
+      return C.TIME_UNSET;
+    }
+    Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
+    if (metadata == null) {
+      return C.TIME_UNSET;
+    }
+    int metadataLength = metadata.length();
+    for (int i = 0; i < metadataLength; i++) {
+      Metadata.Entry frame = metadata.get(i);
+      if (frame instanceof PrivFrame) {
+        PrivFrame privFrame = (PrivFrame) frame;
+        if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
+          System.arraycopy(privFrame.privateData, 0, id3Data.data, 0, 8 /* timestamp size */);
+          id3Data.reset(8);
+          return id3Data.readLong();
+        }
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+  // Internal factory methods.
 
   /**
    * If the content is encrypted, returns an {@link Aes128DataSource} that wraps the original in
@@ -206,4 +329,60 @@ private static DataSource buildDataSource(DataSource dataSource, byte[] encrypti
     return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
   }
 
+  private Extractor createExtractor() {
+    // Select the extractor that will read the chunk.
+    Extractor extractor;
+    boolean usingNewExtractor = true;
+    if (MimeTypes.TEXT_VTT.equals(hlsUrl.format.sampleMimeType)
+        || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
+      extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
+    } else if (!needNewExtractor) {
+      // Only reuse TS and fMP4 extractors.
+      usingNewExtractor = false;
+      extractor = previousExtractor;
+    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
+      extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
+    } else {
+      // MPEG-2 TS segments, but we need a new extractor.
+      // This flag ensures the change of pid between streams does not affect the sample queues.
+      @DefaultTsPayloadReaderFactory.Flags
+      int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
+      String codecs = trackFormat.codecs;
+      if (!TextUtils.isEmpty(codecs)) {
+        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+        // exist. If we know from the codec attribute that they don't exist, then we can
+        // explicitly ignore them even if they're declared.
+        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
+          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
+        }
+        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
+          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
+        }
+      }
+      extractor = new TsExtractor(timestampAdjuster,
+          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
+    }
+    if (usingNewExtractor) {
+      extractor.init(extractorOutput);
+    }
+    return extractor;
+  }
+
+  private Extractor buildPackedAudioExtractor(long startTimeUs) {
+    Extractor extractor;
+    if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
+      extractor = new AdtsExtractor(startTimeUs);
+    } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
+      extractor = new Ac3Extractor(startTimeUs);
+    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
+      extractor = new Mp3Extractor(startTimeUs);
+    } else {
+      throw new IllegalArgumentException("Unkown extension for audio file: " + lastPathSegment);
+    }
+    extractor.init(extractorOutput);
+    return extractor;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index f4c8177f21..6082372b05 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -15,30 +15,22 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
-import android.net.Uri;
 import android.os.Handler;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.ParserException;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
 import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
-import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.Loader;
-import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -48,61 +40,44 @@
 /**
  * A {@link MediaPeriod} that loads an HLS stream.
  */
-/* package */ final class HlsMediaPeriod implements MediaPeriod,
-    Loader.Callback<ParsingLoadable<HlsPlaylist>>, HlsSampleStreamWrapper.Callback  {
+public final class HlsMediaPeriod implements MediaPeriod, HlsSampleStreamWrapper.Callback,
+    HlsPlaylistTracker.PlaylistEventListener {
 
-  private final Uri manifestUri;
+  private final HlsPlaylistTracker playlistTracker;
   private final DataSource.Factory dataSourceFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
-  private final MediaSource.Listener sourceListener;
   private final Allocator allocator;
   private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
-  private final HlsPlaylistParser manifestParser;
   private final Handler continueLoadingHandler;
-  private final Loader manifestFetcher;
   private final long preparePositionUs;
-  private final Runnable continueLoadingRunnable;
 
   private Callback callback;
   private int pendingPrepareCount;
-  private HlsPlaylist playlist;
   private boolean seenFirstTrackSelection;
-  private long durationUs;
-  private boolean isLive;
   private TrackGroupArray trackGroups;
   private HlsSampleStreamWrapper[] sampleStreamWrappers;
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
   private CompositeSequenceableLoader sequenceableLoader;
 
-  public HlsMediaPeriod(Uri manifestUri, DataSource.Factory dataSourceFactory,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher,
-      MediaSource.Listener sourceListener, Allocator allocator,
+  public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, DataSource.Factory dataSourceFactory,
+      int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
       long positionUs) {
-    this.manifestUri = manifestUri;
+    this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
-    this.sourceListener = sourceListener;
     this.allocator = allocator;
     streamWrapperIndices = new IdentityHashMap<>();
     timestampAdjusterProvider = new TimestampAdjusterProvider();
-    manifestParser = new HlsPlaylistParser();
     continueLoadingHandler = new Handler();
-    manifestFetcher = new Loader("Loader:ManifestFetcher");
     preparePositionUs = positionUs;
-    continueLoadingRunnable = new Runnable() {
-      @Override
-      public void run() {
-        callback.onContinueLoadingRequested(HlsMediaPeriod.this);
-      }
-    };
   }
 
   public void release() {
+    playlistTracker.removeListener(this);
     continueLoadingHandler.removeCallbacksAndMessages(null);
-    manifestFetcher.release();
     if (sampleStreamWrappers != null) {
       for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
         sampleStreamWrapper.release();
@@ -112,18 +87,14 @@ public void release() {
 
   @Override
   public void prepare(Callback callback) {
+    playlistTracker.addListener(this);
     this.callback = callback;
-    ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(
-        dataSourceFactory.createDataSource(), manifestUri, C.DATA_TYPE_MANIFEST, manifestParser);
-    long elapsedRealtimeMs = manifestFetcher.startLoading(loadable, this, minLoadableRetryCount);
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, elapsedRealtimeMs);
+    buildAndPrepareSampleStreamWrappers();
   }
 
   @Override
   public void maybeThrowPrepareError() throws IOException {
-    if (sampleStreamWrappers == null) {
-      manifestFetcher.maybeThrowError();
-    } else {
+    if (sampleStreamWrappers != null) {
       for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
         sampleStreamWrapper.maybeThrowPrepareError();
       }
@@ -192,6 +163,18 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     // Update the local state.
     enabledSampleStreamWrappers = new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
     enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
+
+    // The first enabled sample stream wrapper is responsible for intializing the timestamp
+    // adjuster. This way, if present, variants are responsible. Otherwise, audio renditions are.
+    // If only subtitles are present, then text renditions are used for timestamp adjustment
+    // initialization.
+    if (enabledSampleStreamWrappers.length > 0) {
+      enabledSampleStreamWrappers[0].setIsTimestampMaster(true);
+      for (int i = 1; i < enabledSampleStreamWrappers.length; i++) {
+        enabledSampleStreamWrappers[i].setIsTimestampMaster(false);
+      }
+    }
+
     sequenceableLoader = new CompositeSequenceableLoader(enabledSampleStreamWrappers);
     if (seenFirstTrackSelection && selectedNewTracks) {
       seekToUs(positionUs);
@@ -235,8 +218,6 @@ public long getBufferedPositionUs() {
 
   @Override
   public long seekToUs(long positionUs) {
-    // Treat all seeks into non-seekable media as being to t=0.
-    positionUs = isLive ? 0 : positionUs;
     timestampAdjusterProvider.reset();
     for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
       sampleStreamWrapper.seekTo(positionUs);
@@ -244,33 +225,6 @@ public long seekToUs(long positionUs) {
     return positionUs;
   }
 
-  // Loader.Callback implementation.
-
-  @Override
-  public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs) {
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
-    playlist = loadable.getResult();
-    buildAndPrepareSampleStreamWrappers();
-  }
-
-  @Override
-  public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, boolean released) {
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
-  }
-
-  @Override
-  public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, IOException error) {
-    boolean isFatal = error instanceof ParserException;
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, elapsedRealtimeMs, loadDurationMs,
-        loadable.bytesLoaded(), error, isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
-  }
-
   // HlsSampleStreamWrapper.Callback implementation.
 
   @Override
@@ -279,10 +233,6 @@ public void onPrepared() {
       return;
     }
 
-    // The wrapper at index 0 is the one of type TRACK_TYPE_DEFAULT.
-    durationUs = sampleStreamWrappers[0].getDurationUs();
-    isLive = sampleStreamWrappers[0].isLive();
-
     int totalTrackGroupCount = 0;
     for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
       totalTrackGroupCount += sampleStreamWrapper.getTrackGroups().length;
@@ -297,16 +247,11 @@ public void onPrepared() {
     }
     trackGroups = new TrackGroupArray(trackGroupArray);
     callback.onPrepared(this);
-
-    // TODO[playlists]: Calculate the window.
-    Timeline timeline = new SinglePeriodTimeline(durationUs, durationUs, 0, 0, !isLive, isLive);
-    sourceListener.onSourceInfoRefreshed(timeline, playlist);
   }
 
   @Override
-  public void onContinueLoadingRequiredInMs(final HlsSampleStreamWrapper sampleStreamWrapper,
-      long delayMs) {
-    continueLoadingHandler.postDelayed(continueLoadingRunnable, delayMs);
+  public void onPlaylistRefreshRequired(HlsUrl url) {
+    playlistTracker.refreshPlaylist(url);
   }
 
   @Override
@@ -318,28 +263,31 @@ public void onContinueLoadingRequested(HlsSampleStreamWrapper sampleStreamWrappe
     callback.onContinueLoadingRequested(this);
   }
 
-  // Internal methods.
+  // PlaylistListener implementation.
 
-  private void buildAndPrepareSampleStreamWrappers() {
-    String baseUri = playlist.baseUri;
-    if (playlist instanceof HlsMediaPlaylist) {
-      HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[] {
-          HlsMasterPlaylist.HlsUrl.createMediaPlaylistHlsUrl(playlist.baseUri)};
-      sampleStreamWrappers = new HlsSampleStreamWrapper[] {
-          buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT, baseUri, variants, null, null)};
-      pendingPrepareCount = 1;
-      sampleStreamWrappers[0].continuePreparing();
-      return;
+  @Override
+  public void onPlaylistChanged() {
+    continuePreparingOrLoading();
+  }
+
+  @Override
+  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+    for (HlsSampleStreamWrapper streamWrapper : sampleStreamWrappers) {
+      streamWrapper.onPlaylistBlacklisted(url, blacklistMs);
     }
+    continuePreparingOrLoading();
+  }
 
-    HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+  // Internal methods.
 
+  private void buildAndPrepareSampleStreamWrappers() {
+    HlsMasterPlaylist masterPlaylist = playlistTracker.getMasterPlaylist();
     // Build the default stream wrapper.
-    List<HlsMasterPlaylist.HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
-    ArrayList<HlsMasterPlaylist.HlsUrl> definiteVideoVariants = new ArrayList<>();
-    ArrayList<HlsMasterPlaylist.HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
+    List<HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
+    ArrayList<HlsUrl> definiteVideoVariants = new ArrayList<>();
+    ArrayList<HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
     for (int i = 0; i < selectedVariants.size(); i++) {
-      HlsMasterPlaylist.HlsUrl variant = selectedVariants.get(i);
+      HlsUrl variant = selectedVariants.get(i);
       if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
         definiteVideoVariants.add(variant);
       } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
@@ -358,51 +306,64 @@ private void buildAndPrepareSampleStreamWrappers() {
     } else {
       // Leave the enabled variants unchanged. They're likely either all video or all audio.
     }
-    List<HlsMasterPlaylist.HlsUrl> audioVariants = masterPlaylist.audios;
-    List<HlsMasterPlaylist.HlsUrl> subtitleVariants = masterPlaylist.subtitles;
-    sampleStreamWrappers = new HlsSampleStreamWrapper[(selectedVariants.isEmpty() ? 0 : 1)
-        + audioVariants.size() + subtitleVariants.size()];
+    List<HlsUrl> audioRenditions = masterPlaylist.audios;
+    List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
+    sampleStreamWrappers = new HlsSampleStreamWrapper[1 /* variants */ + audioRenditions.size()
+        + subtitleRenditions.size()];
     int currentWrapperIndex = 0;
     pendingPrepareCount = sampleStreamWrappers.length;
-    if (!selectedVariants.isEmpty()) {
-      HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
-      selectedVariants.toArray(variants);
-      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
-          baseUri, variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-      sampleStreamWrapper.continuePreparing();
-    }
+
+    Assertions.checkArgument(!selectedVariants.isEmpty());
+    HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
+    selectedVariants.toArray(variants);
+    HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
+        variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
+    sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+    sampleStreamWrapper.setIsTimestampMaster(true);
+    sampleStreamWrapper.continuePreparing();
+
+    // TODO: Build video stream wrappers here.
 
     // Build audio stream wrappers.
-    for (int i = 0; i < audioVariants.size(); i++) {
-      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
-          baseUri, new HlsMasterPlaylist.HlsUrl[] {audioVariants.get(i)}, null, null);
+    for (int i = 0; i < audioRenditions.size(); i++) {
+      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
+          new HlsUrl[] {audioRenditions.get(i)}, null, null);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
       sampleStreamWrapper.continuePreparing();
     }
 
     // Build subtitle stream wrappers.
-    for (int i = 0; i < subtitleVariants.size(); i++) {
-      HlsMasterPlaylist.HlsUrl url = subtitleVariants.get(i);
-      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT,
-          baseUri, new HlsMasterPlaylist.HlsUrl[] {url}, null, null);
+    for (int i = 0; i < subtitleRenditions.size(); i++) {
+      HlsUrl url = subtitleRenditions.get(i);
+      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null,
+          null);
       sampleStreamWrapper.prepareSingleTrack(url.format);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     }
   }
 
-  private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, String baseUri,
-      HlsMasterPlaylist.HlsUrl[] variants, Format muxedAudioFormat, Format muxedCaptionFormat) {
+  private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
+      Format muxedAudioFormat, Format muxedCaptionFormat) {
     DataSource dataSource = dataSourceFactory.createDataSource();
-    HlsChunkSource defaultChunkSource = new HlsChunkSource(baseUri, variants, dataSource,
+    HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants, dataSource,
         timestampAdjusterProvider);
     return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator,
         preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
         eventDispatcher);
   }
 
-  private static boolean variantHasExplicitCodecWithPrefix(HlsMasterPlaylist.HlsUrl variant,
-      String prefix) {
+  private void continuePreparingOrLoading() {
+    if (trackGroups != null) {
+      callback.onContinueLoadingRequested(this);
+    } else {
+      // Some of the wrappers were waiting for their media playlist to prepare.
+      for (HlsSampleStreamWrapper wrapper : sampleStreamWrappers) {
+        wrapper.continuePreparing();
+      }
+    }
+  }
+
+  private static boolean variantHasExplicitCodecWithPrefix(HlsUrl variant, String prefix) {
     String codecs = variant.format.codecs;
     if (TextUtils.isEmpty(codecs)) {
       return false;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index b8b6c033b3..10e12f0ec6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -18,19 +18,25 @@
 import android.net.Uri;
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.List;
 
 /**
  * An HLS {@link MediaSource}.
  */
-public final class HlsMediaSource implements MediaSource {
+public final class HlsMediaSource implements MediaSource,
+    HlsPlaylistTracker.PrimaryPlaylistListener {
 
   /**
    * The default minimum number of times to retry loading data prior to failing.
@@ -42,7 +48,8 @@
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
 
-  private MediaSource.Listener sourceListener;
+  private HlsPlaylistTracker playlistTracker;
+  private Listener sourceListener;
 
   public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
@@ -60,22 +67,24 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
   }
 
   @Override
-  public void prepareSource(MediaSource.Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    Assertions.checkState(playlistTracker == null);
+    playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
+        minLoadableRetryCount, this);
     sourceListener = listener;
-    // TODO: Defer until the playlist has been loaded.
-    listener.onSourceInfoRefreshed(new SinglePeriodTimeline(C.TIME_UNSET, false), null);
+    playlistTracker.start();
   }
 
   @Override
-  public void maybeThrowSourceInfoRefreshError() {
-    // Do nothing.
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    playlistTracker.maybeThrowPlaylistRefreshError();
   }
 
   @Override
   public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
-    return new HlsMediaPeriod(manifestUri, dataSourceFactory, minLoadableRetryCount,
-        eventDispatcher, sourceListener, allocator, positionUs);
+    return new HlsMediaPeriod(playlistTracker, dataSourceFactory, minLoadableRetryCount,
+        eventDispatcher, allocator, positionUs);
   }
 
   @Override
@@ -85,7 +94,35 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
+    if (playlistTracker != null) {
+      playlistTracker.release();
+      playlistTracker = null;
+    }
     sourceListener = null;
   }
 
+  @Override
+  public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
+    SinglePeriodTimeline timeline;
+    long windowDefaultStartPositionUs = playlist.startOffsetUs;
+    if (playlistTracker.isLive()) {
+      long periodDurationUs = playlist.hasEndTag ? (playlist.startTimeUs + playlist.durationUs)
+          : C.TIME_UNSET;
+      List<HlsMediaPlaylist.Segment> segments = playlist.segments;
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = segments.isEmpty() ? 0
+            : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
+      }
+      timeline = new SinglePeriodTimeline(periodDurationUs, playlist.durationUs,
+          playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
+    } else /* not live */ {
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = 0;
+      }
+      timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
+          playlist.durationUs, playlist.startTimeUs, windowDefaultStartPositionUs, true, false);
+    }
+    sourceListener.onSourceInfoRefreshed(timeline, playlist);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index c63cf3e5a4..04fe8a093c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -26,7 +26,7 @@
 /* package */ final class HlsSampleStream implements SampleStream {
 
   public final int group;
-  
+
   private final HlsSampleStreamWrapper sampleStreamWrapper;
 
   public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index fe756da0ef..a9bbddb69c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -32,6 +32,8 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.Chunk;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.Loader;
@@ -58,10 +60,10 @@
     void onPrepared();
 
     /**
-     * Called to schedule a {@link #continueLoading(long)} call.
+     * Called to schedule a {@link #continueLoading(long)} call when the playlist referred by the
+     * given url changes.
      */
-    void onContinueLoadingRequiredInMs(HlsSampleStreamWrapper sampleStreamSource,
-        long delayMs);
+    void onPlaylistRefreshRequired(HlsMasterPlaylist.HlsUrl playlistUrl);
 
   }
 
@@ -164,14 +166,6 @@ public void maybeThrowPrepareError() throws IOException {
     maybeThrowError();
   }
 
-  public long getDurationUs() {
-    return chunkSource.getDurationUs();
-  }
-
-  public boolean isLive() {
-    return chunkSource.isLive();
-  }
-
   public TrackGroupArray getTrackGroups() {
     return trackGroups;
   }
@@ -281,6 +275,14 @@ public long getLargestQueuedTimestampUs() {
     return largestQueuedTimestampUs;
   }
 
+  public void setIsTimestampMaster(boolean isTimestampMaster) {
+    chunkSource.setIsTimestampMaster(isTimestampMaster);
+  }
+
+  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+    chunkSource.onPlaylistBlacklisted(url, blacklistMs);
+  }
+
   // SampleStream implementation.
 
   /* package */ boolean isReady(int group) {
@@ -331,7 +333,7 @@ private boolean finishedReadingChunk(HlsMediaChunk chunk) {
 
   @Override
   public boolean continueLoading(long positionUs) {
-    if (loader.isLoading()) {
+    if (loadingFinished || loader.isLoading()) {
       return false;
     }
 
@@ -340,7 +342,7 @@ public boolean continueLoading(long positionUs) {
         nextChunkHolder);
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
-    long retryInMs = nextChunkHolder.retryInMs;
+    HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
     nextChunkHolder.clear();
 
     if (endOfStream) {
@@ -349,9 +351,8 @@ public boolean continueLoading(long positionUs) {
     }
 
     if (loadable == null) {
-      if (retryInMs != C.TIME_UNSET) {
-        Assertions.checkState(chunkSource.isLive());
-        callback.onContinueLoadingRequiredInMs(this, retryInMs);
+      if (playlistToLoad != null) {
+        callback.onPlaylistRefreshRequired(playlistToLoad);
       }
       return false;
     }
@@ -361,8 +362,6 @@ public boolean continueLoading(long positionUs) {
       HlsMediaChunk mediaChunk = (HlsMediaChunk) loadable;
       mediaChunk.init(this);
       mediaChunks.add(mediaChunk);
-    } else if (loadable instanceof HlsInitializationChunk) {
-      ((HlsInitializationChunk) loadable).init(this);
     }
     long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
     eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
index 624e5fa4f8..41fb2c1512 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.util.SparseArray;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Provides {@link TimestampAdjuster} instances for use during HLS playbacks.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
index f565fdf9ea..c8928ce65d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
@@ -24,12 +24,12 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.regex.Matcher;
@@ -79,7 +79,7 @@ public void init(ExtractorOutput output) {
   }
 
   @Override
-  public void seek(long position) {
+  public void seek(long position, long timeUs) {
     // This extractor is only used for the HLS use case, which should not call this method.
     throw new IllegalStateException();
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index c0d4890b44..b7426fd03d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -40,7 +40,7 @@
 
     public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
       Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null,
-          Format.NO_VALUE);
+          Format.NO_VALUE, 0, null);
       return new HlsUrl(null, baseUri, format, null, null, null);
     }
 
@@ -73,4 +73,10 @@ public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> aud
     this.muxedCaptionFormat = muxedCaptionFormat;
   }
 
+  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
+    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
+    List<HlsUrl> emptyList = Collections.emptyList();
+    return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null, null);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 5aa0c8a3d8..b8d8d69af4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -15,7 +15,11 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -29,9 +33,9 @@
   public static final class Segment implements Comparable<Long> {
 
     public final String url;
-    public final double durationSecs;
-    public final int discontinuitySequenceNumber;
-    public final long startTimeUs;
+    public final long durationUs;
+    public final int relativeDiscontinuitySequence;
+    public final long relativeStartTimeUs;
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
     public final String encryptionIV;
@@ -42,13 +46,13 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
       this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
     }
 
-    public Segment(String uri, double durationSecs, int discontinuitySequenceNumber,
-        long startTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
+    public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
+        long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
         long byterangeOffset, long byterangeLength) {
       this.url = uri;
-      this.durationSecs = durationSecs;
-      this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-      this.startTimeUs = startTimeUs;
+      this.durationUs = durationUs;
+      this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
+      this.relativeStartTimeUs = relativeStartTimeUs;
       this.isEncrypted = isEncrypted;
       this.encryptionKeyUri = encryptionKeyUri;
       this.encryptionIV = encryptionIV;
@@ -57,38 +61,116 @@ public Segment(String uri, double durationSecs, int discontinuitySequenceNumber,
     }
 
     @Override
-    public int compareTo(Long startTimeUs) {
-      return this.startTimeUs > startTimeUs ? 1 : (this.startTimeUs < startTimeUs ? -1 : 0);
+    public int compareTo(Long relativeStartTimeUs) {
+      return this.relativeStartTimeUs > relativeStartTimeUs
+          ? 1 : (this.relativeStartTimeUs < relativeStartTimeUs ? -1 : 0);
     }
+
   }
 
-  public static final String ENCRYPTION_METHOD_NONE = "NONE";
-  public static final String ENCRYPTION_METHOD_AES_128 = "AES-128";
+  /**
+   * Type of the playlist as specified by #EXT-X-PLAYLIST-TYPE.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
+  public @interface PlaylistType {}
+  public static final int PLAYLIST_TYPE_UNKNOWN = 0;
+  public static final int PLAYLIST_TYPE_VOD = 1;
+  public static final int PLAYLIST_TYPE_EVENT = 2;
 
+  @PlaylistType
+  public final int playlistType;
+  public final long startOffsetUs;
+  public final long startTimeUs;
+  public final boolean hasDiscontinuitySequence;
+  public final int discontinuitySequence;
   public final int mediaSequence;
-  public final int targetDurationSecs;
   public final int version;
+  public final long targetDurationUs;
+  public final boolean hasEndTag;
+  public final boolean hasProgramDateTime;
   public final Segment initializationSegment;
   public final List<Segment> segments;
-  public final boolean live;
   public final long durationUs;
 
-  public HlsMediaPlaylist(String baseUri, int mediaSequence, int targetDurationSecs, int version,
-      boolean live, Segment initializationSegment, List<Segment> segments) {
+  public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
+      long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
+      int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
+      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments) {
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
+    this.playlistType = playlistType;
+    this.startTimeUs = startTimeUs;
+    this.hasDiscontinuitySequence = hasDiscontinuitySequence;
+    this.discontinuitySequence = discontinuitySequence;
     this.mediaSequence = mediaSequence;
-    this.targetDurationSecs = targetDurationSecs;
     this.version = version;
-    this.live = live;
+    this.targetDurationUs = targetDurationUs;
+    this.hasEndTag = hasEndTag;
+    this.hasProgramDateTime = hasProgramDateTime;
     this.initializationSegment = initializationSegment;
-    this.segments = segments;
-
+    this.segments = Collections.unmodifiableList(segments);
     if (!segments.isEmpty()) {
       Segment last = segments.get(segments.size() - 1);
-      durationUs = last.startTimeUs + (long) (last.durationSecs * C.MICROS_PER_SECOND);
+      durationUs = last.relativeStartTimeUs + last.durationUs;
     } else {
       durationUs = 0;
     }
+    this.startOffsetUs = startOffsetUs == C.TIME_UNSET ? C.TIME_UNSET
+        : startOffsetUs >= 0 ? startOffsetUs : durationUs + startOffsetUs;
+  }
+
+  /**
+   * Returns whether this playlist is newer than {@code other}.
+   *
+   * @param other The playlist to compare.
+   * @return Whether this playlist is newer than {@code other}.
+   */
+  public boolean isNewerThan(HlsMediaPlaylist other) {
+    if (other == null || mediaSequence > other.mediaSequence) {
+      return true;
+    }
+    if (mediaSequence < other.mediaSequence) {
+      return false;
+    }
+    // The media sequences are equal.
+    int segmentCount = segments.size();
+    int otherSegmentCount = other.segments.size();
+    return segmentCount > otherSegmentCount
+        || (segmentCount == otherSegmentCount && hasEndTag && !other.hasEndTag);
+  }
+
+  public long getEndTimeUs() {
+    return startTimeUs + durationUs;
+  }
+
+  /**
+   * Returns a playlist identical to this one except for the start time, the discontinuity sequence
+   * and {@code hasDiscontinuitySequence} values. The first two are set to the specified values,
+   * {@code hasDiscontinuitySequence} is set to true.
+   *
+   * @param startTimeUs The start time for the returned playlist.
+   * @param discontinuitySequence The discontinuity sequence for the returned playlist.
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs, true,
+        discontinuitySequence, mediaSequence, version, targetDurationUs, hasEndTag,
+        hasProgramDateTime, initializationSegment, segments);
+  }
+
+  /**
+   * Returns a playlist identical to this one except that an end tag is added. If an end tag is
+   * already present then the playlist will return itself.
+   *
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWithEndTag() {
+    if (this.hasEndTag) {
+      return this;
+    }
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs,
+        hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
+        true, hasProgramDateTime, initializationSegment, segments);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 21cc75765f..a211417501 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -19,15 +19,16 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
@@ -39,15 +40,20 @@
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
+  private static final String PLAYLIST_HEADER = "#EXTM3U";
+
   private static final String TAG_VERSION = "#EXT-X-VERSION";
+  private static final String TAG_PLAYLIST_TYPE = "#EXT-X-PLAYLIST-TYPE";
   private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
   private static final String TAG_MEDIA = "#EXT-X-MEDIA";
+  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
   private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
   private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
+  private static final String TAG_PROGRAM_DATE_TIME = "#EXT-X-PROGRAM-DATE-TIME";
   private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
   private static final String TAG_MEDIA_DURATION = "#EXTINF";
   private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
-  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
+  private static final String TAG_START = "#EXT-X-START";
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
@@ -63,21 +69,19 @@
   private static final String BOOLEAN_TRUE = "YES";
   private static final String BOOLEAN_FALSE = "NO";
 
-  private static final Pattern REGEX_GROUP_ID = Pattern.compile("GROUP-ID=\"(.+?)\"");
-  private static final Pattern REGEX_VIDEO = Pattern.compile("VIDEO=\"(.+?)\"");
-  private static final Pattern REGEX_AUDIO = Pattern.compile("AUDIO=\"(.+?)\"");
-  private static final Pattern REGEX_CLOSED_CAPTIONS = Pattern.compile("CLOSED-CAPTIONS=\"(.+?)\"");
-  private static final Pattern REGEX_SUBTITLES = Pattern.compile("SUBTITLES=\"(.+?)\"");
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
-  private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
   private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
       + ":(\\d+)\\b");
+  private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
+  private static final Pattern REGEX_PLAYLIST_TYPE = Pattern.compile(TAG_PLAYLIST_TYPE
+      + ":(.+)\\b");
   private static final Pattern REGEX_MEDIA_SEQUENCE = Pattern.compile(TAG_MEDIA_SEQUENCE
       + ":(\\d+)\\b");
   private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
       + ":([\\d\\.]+)\\b");
+  private static final Pattern REGEX_TIME_OFFSET = Pattern.compile("TIME-OFFSET=([\\d\\.]+)\\b");
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
@@ -101,6 +105,10 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
     Queue<String> extraLines = new LinkedList<>();
     String line;
     try {
+      if (!checkPlaylistHeader(reader)) {
+        throw new UnrecognizedInputFormatException("Input does not start with the #EXTM3U header.",
+            uri);
+      }
       while ((line = reader.readLine()) != null) {
         line = line.trim();
         if (line.isEmpty()) {
@@ -123,11 +131,40 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
         }
       }
     } finally {
-      reader.close();
+      Util.closeQuietly(reader);
     }
     throw new ParserException("Failed to parse the playlist, could not identify any tags.");
   }
 
+  private static boolean checkPlaylistHeader(BufferedReader reader) throws IOException {
+    int last = reader.read();
+    if (last == 0xEF) {
+      if (reader.read() != 0xBB || reader.read() != 0xBF) {
+        return false;
+      }
+      // The playlist contains a Byte Order Mark, which gets discarded.
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, true, last);
+    int playlistHeaderLength = PLAYLIST_HEADER.length();
+    for (int i = 0; i < playlistHeaderLength; i++) {
+      if (last != PLAYLIST_HEADER.charAt(i)) {
+        return false;
+      }
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, false, last);
+    return Util.isLinebreak(last);
+  }
+
+  private static int skipIgnorableWhitespace(BufferedReader reader, boolean skipLinebreaks, int c)
+      throws IOException {
+    while (c != -1 && Character.isWhitespace(c) && (skipLinebreaks || !Util.isLinebreak(c))) {
+      c = reader.read();
+    }
+    return c;
+  }
+
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
@@ -194,7 +231,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         line = iterator.next();
         String name = Integer.toString(variants.size());
         Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
-            codecs, bitrate, width, height, Format.NO_VALUE, null);
+            codecs, bitrate, width, height, Format.NO_VALUE, null, 0);
         variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
       }
     }
@@ -211,15 +248,20 @@ private static int parseSelectionFlags(String line) {
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
+    @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
+    long startOffsetUs = C.TIME_UNSET;
     int mediaSequence = 0;
-    int targetDurationSecs = 0;
     int version = 1; // Default version == 1.
-    boolean live = true;
+    long targetDurationUs = C.TIME_UNSET;
+    boolean hasEndTag = false;
     Segment initializationSegment = null;
     List<Segment> segments = new ArrayList<>();
 
-    double segmentDurationSecs = 0.0;
-    int discontinuitySequenceNumber = 0;
+    long segmentDurationUs = 0;
+    boolean hasDiscontinuitySequence = false;
+    int playlistDiscontinuitySequence = 0;
+    int relativeDiscontinuitySequence = 0;
+    long playlistStartTimeUs = 0;
     long segmentStartTimeUs = 0;
     long segmentByteRangeOffset = 0;
     long segmentByteRangeLength = C.LENGTH_UNSET;
@@ -232,7 +274,18 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-      if (line.startsWith(TAG_INIT_SEGMENT)) {
+      if (line.startsWith(TAG_PLAYLIST_TYPE)) {
+        String playlistTypeString = parseStringAttr(line, REGEX_PLAYLIST_TYPE);
+        if ("VOD".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_VOD;
+        } else if ("EVENT".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_EVENT;
+        } else {
+          throw new ParserException("Illegal playlist type: " + playlistTypeString);
+        }
+      } else if (line.startsWith(TAG_START)) {
+        startOffsetUs = (long) (parseDoubleAttr(line, REGEX_TIME_OFFSET) * C.MICROS_PER_SECOND);
+      } else if (line.startsWith(TAG_INIT_SEGMENT)) {
         String uri = parseStringAttr(line, REGEX_URI);
         String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
         if (byteRange != null) {
@@ -246,14 +299,15 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         segmentByteRangeOffset = 0;
         segmentByteRangeLength = C.LENGTH_UNSET;
       } else if (line.startsWith(TAG_TARGET_DURATION)) {
-        targetDurationSecs = parseIntAttr(line, REGEX_TARGET_DURATION);
+        targetDurationUs = parseIntAttr(line, REGEX_TARGET_DURATION) * C.MICROS_PER_SECOND;
       } else if (line.startsWith(TAG_MEDIA_SEQUENCE)) {
         mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
         segmentMediaSequence = mediaSequence;
       } else if (line.startsWith(TAG_VERSION)) {
         version = parseIntAttr(line, REGEX_VERSION);
       } else if (line.startsWith(TAG_MEDIA_DURATION)) {
-        segmentDurationSecs = parseDoubleAttr(line, REGEX_MEDIA_DURATION);
+        segmentDurationUs =
+            (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
         String method = parseStringAttr(line, REGEX_METHOD);
         isEncrypted = METHOD_AES128.equals(method);
@@ -272,9 +326,16 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
         }
       } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
-        discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
+        hasDiscontinuitySequence = true;
+        playlistDiscontinuitySequence = Integer.parseInt(line.substring(line.indexOf(':') + 1));
       } else if (line.equals(TAG_DISCONTINUITY)) {
-        discontinuitySequenceNumber++;
+        relativeDiscontinuitySequence++;
+      } else if (line.startsWith(TAG_PROGRAM_DATE_TIME)) {
+        if (playlistStartTimeUs == 0) {
+          long programDatetimeUs =
+              C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
+          playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
+        }
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
         if (!isEncrypted) {
@@ -288,21 +349,22 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
-        segments.add(new Segment(line, segmentDurationSecs, discontinuitySequenceNumber,
+        segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
             segmentByteRangeOffset, segmentByteRangeLength));
-        segmentStartTimeUs += (long) (segmentDurationSecs * C.MICROS_PER_SECOND);
-        segmentDurationSecs = 0.0;
+        segmentStartTimeUs += segmentDurationUs;
+        segmentDurationUs = 0;
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
           segmentByteRangeOffset += segmentByteRangeLength;
         }
         segmentByteRangeLength = C.LENGTH_UNSET;
       } else if (line.equals(TAG_ENDLIST)) {
-        live = false;
+        hasEndTag = true;
       }
     }
-    return new HlsMediaPlaylist(baseUri, mediaSequence, targetDurationSecs, version, live,
-        initializationSegment, Collections.unmodifiableList(segments));
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, playlistStartTimeUs,
+        hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
+        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
   }
 
   private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
new file mode 100644
index 0000000000..356aa0b466
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -0,0 +1,538 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import android.net.Uri;
+import android.os.Handler;
+import android.os.SystemClock;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.UriUtil;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+
+/**
+ * Tracks playlists linked to a provided playlist url. The provided url might reference an HLS
+ * master playlist or a media playlist.
+ */
+public final class HlsPlaylistTracker implements Loader.Callback<ParsingLoadable<HlsPlaylist>> {
+
+  /**
+   * Listener for primary playlist changes.
+   */
+  public interface PrimaryPlaylistListener {
+
+    /**
+     * Called when the primary playlist changes.
+     *
+     * @param mediaPlaylist The primary playlist new snapshot.
+     */
+    void onPrimaryPlaylistRefreshed(HlsMediaPlaylist mediaPlaylist);
+
+  }
+
+  /**
+   * Called on playlist loading events.
+   */
+  public interface PlaylistEventListener {
+
+    /**
+     * Called a playlist changes.
+     */
+    void onPlaylistChanged();
+
+    /**
+     * Called if an error is encountered while loading a playlist.
+     *
+     * @param url The loaded url that caused the error.
+     * @param blacklistDurationMs The number of milliseconds for which the playlist has been
+     *     blacklisted.
+     */
+    void onPlaylistBlacklisted(HlsUrl url, long blacklistDurationMs);
+
+  }
+
+  /**
+   * The minimum number of milliseconds that a url is kept as primary url, if no
+   * {@link #getPlaylistSnapshot} call is made for that url.
+   */
+  private static final long PRIMARY_URL_KEEPALIVE_MS = 15000;
+
+  private final Uri initialPlaylistUri;
+  private final DataSource.Factory dataSourceFactory;
+  private final HlsPlaylistParser playlistParser;
+  private final int minRetryCount;
+  private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
+  private final Handler playlistRefreshHandler;
+  private final PrimaryPlaylistListener primaryPlaylistListener;
+  private final List<PlaylistEventListener> listeners;
+  private final Loader initialPlaylistLoader;
+  private final EventDispatcher eventDispatcher;
+
+  private HlsMasterPlaylist masterPlaylist;
+  private HlsUrl primaryHlsUrl;
+  private HlsMediaPlaylist primaryUrlSnapshot;
+  private boolean isLive;
+
+  /**
+   * @param initialPlaylistUri Uri for the initial playlist of the stream. Can refer a media
+   *     playlist or a master playlist.
+   * @param dataSourceFactory A factory for {@link DataSource} instances.
+   * @param eventDispatcher A dispatcher to notify of events.
+   * @param minRetryCount The minimum number of times the load must be retried before blacklisting a
+   *     playlist.
+   * @param primaryPlaylistListener A callback for the primary playlist change events.
+   */
+  public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceFactory,
+      EventDispatcher eventDispatcher, int minRetryCount,
+      PrimaryPlaylistListener primaryPlaylistListener) {
+    this.initialPlaylistUri = initialPlaylistUri;
+    this.dataSourceFactory = dataSourceFactory;
+    this.eventDispatcher = eventDispatcher;
+    this.minRetryCount = minRetryCount;
+    this.primaryPlaylistListener = primaryPlaylistListener;
+    listeners = new ArrayList<>();
+    initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
+    playlistParser = new HlsPlaylistParser();
+    playlistBundles = new IdentityHashMap<>();
+    playlistRefreshHandler = new Handler();
+  }
+
+  /**
+   * Registers a listener to receive events from the playlist tracker.
+   *
+   * @param listener The listener.
+   */
+  public void addListener(PlaylistEventListener listener) {
+    listeners.add(listener);
+  }
+
+  /**
+   * Unregisters a listener.
+   *
+   * @param listener The listener to unregister.
+   */
+  public void removeListener(PlaylistEventListener listener) {
+    listeners.remove(listener);
+  }
+
+  /**
+   * Starts tracking all the playlists related to the provided Uri.
+   */
+  public void start() {
+    ParsingLoadable<HlsPlaylist> masterPlaylistLoadable = new ParsingLoadable<>(
+        dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST,
+        playlistParser);
+    initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
+  }
+
+  /**
+   * Returns the master playlist.
+   *
+   * @return The master playlist. Null if the initial playlist has yet to be loaded.
+   */
+  public HlsMasterPlaylist getMasterPlaylist() {
+    return masterPlaylist;
+  }
+
+  /**
+   * Returns the most recent snapshot available of the playlist referenced by the provided
+   * {@link HlsUrl}.
+   *
+   * @param url The {@link HlsUrl} corresponding to the requested media playlist.
+   * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
+   *     be null if no snapshot has been loaded yet.
+   */
+  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
+    HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
+    if (snapshot != null) {
+      maybeSetPrimaryUrl(url);
+    }
+    return snapshot;
+  }
+
+  /**
+   * Returns whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   * valid, meaning all the segments referenced by the playlist are expected to be available. If the
+   * playlist is not valid then some of the segments may no longer be available.
+
+   * @param url The {@link HlsUrl}.
+   * @return Whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   *     valid.
+   */
+  public boolean isSnapshotValid(HlsUrl url) {
+    return playlistBundles.get(url).isSnapshotValid();
+  }
+
+  /**
+   * Releases the playlist tracker.
+   */
+  public void release() {
+    initialPlaylistLoader.release();
+    for (MediaPlaylistBundle bundle : playlistBundles.values()) {
+      bundle.release();
+    }
+    playlistRefreshHandler.removeCallbacksAndMessages(null);
+    playlistBundles.clear();
+  }
+
+  /**
+   * If the tracker is having trouble refreshing the primary playlist or loading an irreplaceable
+   * playlist, this method throws the underlying error. Otherwise, does nothing.
+   *
+   * @throws IOException The underlying error.
+   */
+  public void maybeThrowPlaylistRefreshError() throws IOException {
+    initialPlaylistLoader.maybeThrowError();
+    if (primaryHlsUrl != null) {
+      playlistBundles.get(primaryHlsUrl).mediaPlaylistLoader.maybeThrowError();
+    }
+  }
+
+  /**
+   * Triggers a playlist refresh and whitelists it.
+   *
+   * @param url The {@link HlsUrl} of the playlist to be refreshed.
+   */
+  public void refreshPlaylist(HlsUrl url) {
+    playlistBundles.get(url).loadPlaylist();
+  }
+
+  /**
+   * Returns whether this is live content.
+   *
+   * @return True if the content is live. False otherwise.
+   */
+  public boolean isLive() {
+    return isLive;
+  }
+
+  // Loader.Callback implementation.
+
+  @Override
+  public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+      long loadDurationMs) {
+    HlsPlaylist result = loadable.getResult();
+    HlsMasterPlaylist masterPlaylist;
+    boolean isMediaPlaylist = result instanceof HlsMediaPlaylist;
+    if (isMediaPlaylist) {
+      masterPlaylist = HlsMasterPlaylist.createSingleVariantMasterPlaylist(result.baseUri);
+    } else /* result instanceof HlsMasterPlaylist */ {
+      masterPlaylist = (HlsMasterPlaylist) result;
+    }
+    this.masterPlaylist = masterPlaylist;
+    primaryHlsUrl = masterPlaylist.variants.get(0);
+    ArrayList<HlsUrl> urls = new ArrayList<>();
+    urls.addAll(masterPlaylist.variants);
+    urls.addAll(masterPlaylist.audios);
+    urls.addAll(masterPlaylist.subtitles);
+    createBundles(urls);
+    MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
+    if (isMediaPlaylist) {
+      // We don't need to load the playlist again. We can use the same result.
+      primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result);
+    } else {
+      primaryBundle.loadPlaylist();
+    }
+    eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+        loadDurationMs, loadable.bytesLoaded());
+  }
+
+  @Override
+  public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+      long loadDurationMs, boolean released) {
+    eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+        loadDurationMs, loadable.bytesLoaded());
+  }
+
+  @Override
+  public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+      long loadDurationMs, IOException error) {
+    boolean isFatal = error instanceof ParserException;
+    eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+        loadDurationMs, loadable.bytesLoaded(), error, isFatal);
+    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
+  }
+
+  // Internal methods.
+
+  private boolean maybeSelectNewPrimaryUrl() {
+    List<HlsUrl> variants = masterPlaylist.variants;
+    int variantsSize = variants.size();
+    long currentTimeMs = SystemClock.elapsedRealtime();
+    for (int i = 0; i < variantsSize; i++) {
+      MediaPlaylistBundle bundle = playlistBundles.get(variants.get(i));
+      if (currentTimeMs > bundle.blacklistUntilMs) {
+        primaryHlsUrl = bundle.playlistUrl;
+        bundle.loadPlaylist();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private void maybeSetPrimaryUrl(HlsUrl url) {
+    if (!masterPlaylist.variants.contains(url)
+        || (primaryUrlSnapshot != null && primaryUrlSnapshot.hasEndTag)) {
+      // Only allow variant urls to be chosen as primary. Also prevent changing the primary url if
+      // the last primary snapshot contains an end tag.
+      return;
+    }
+    MediaPlaylistBundle currentPrimaryBundle = playlistBundles.get(primaryHlsUrl);
+    long primarySnapshotAccessAgeMs =
+        currentPrimaryBundle.lastSnapshotAccessTimeMs - SystemClock.elapsedRealtime();
+    if (primarySnapshotAccessAgeMs > PRIMARY_URL_KEEPALIVE_MS) {
+      primaryHlsUrl = url;
+      playlistBundles.get(primaryHlsUrl).loadPlaylist();
+    }
+  }
+
+  private void createBundles(List<HlsUrl> urls) {
+    int listSize = urls.size();
+    long currentTimeMs = SystemClock.elapsedRealtime();
+    for (int i = 0; i < listSize; i++) {
+      HlsUrl url = urls.get(i);
+      MediaPlaylistBundle bundle = new MediaPlaylistBundle(url, currentTimeMs);
+      playlistBundles.put(urls.get(i), bundle);
+    }
+  }
+
+  /**
+   * Called by the bundles when a snapshot changes.
+   *
+   * @param url The url of the playlist.
+   * @param newSnapshot The new snapshot.
+   * @return True if a refresh should be scheduled.
+   */
+  private boolean onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
+    if (url == primaryHlsUrl) {
+      if (primaryUrlSnapshot == null) {
+        // This is the first primary url snapshot.
+        isLive = !newSnapshot.hasEndTag;
+      }
+      primaryUrlSnapshot = newSnapshot;
+      primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);
+    }
+    int listenersSize = listeners.size();
+    for (int i = 0; i < listenersSize; i++) {
+      listeners.get(i).onPlaylistChanged();
+    }
+    // If the primary playlist is not the final one, we should schedule a refresh.
+    return url == primaryHlsUrl && !newSnapshot.hasEndTag;
+  }
+
+  private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
+    int listenersSize = listeners.size();
+    for (int i = 0; i < listenersSize; i++) {
+      listeners.get(i).onPlaylistBlacklisted(url, blacklistMs);
+    }
+  }
+
+  private HlsMediaPlaylist getLatestPlaylistSnapshot(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (!loadedPlaylist.isNewerThan(oldPlaylist)) {
+      if (loadedPlaylist.hasEndTag) {
+        // If the loaded playlist has an end tag but is not newer than the old playlist then we have
+        // an inconsistent state. This is typically caused by the server incorrectly resetting the
+        // media sequence when appending the end tag. We resolve this case as best we can by
+        // returning the old playlist with the end tag appended.
+        return oldPlaylist.copyWithEndTag();
+      } else {
+        return oldPlaylist;
+      }
+    }
+    long startTimeUs = getLoadedPlaylistStartTimeUs(oldPlaylist, loadedPlaylist);
+    int discontinuitySequence = getLoadedPlaylistDiscontinuitySequence(oldPlaylist, loadedPlaylist);
+    return loadedPlaylist.copyWith(startTimeUs, discontinuitySequence);
+  }
+
+  private long getLoadedPlaylistStartTimeUs(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasProgramDateTime) {
+      return loadedPlaylist.startTimeUs;
+    }
+    long primarySnapshotStartTimeUs = primaryUrlSnapshot != null
+        ? primaryUrlSnapshot.startTimeUs : 0;
+    if (oldPlaylist == null) {
+      return primarySnapshotStartTimeUs;
+    }
+    int oldPlaylistSize = oldPlaylist.segments.size();
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.startTimeUs + firstOldOverlappingSegment.relativeStartTimeUs;
+    } else if (oldPlaylistSize == loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence) {
+      return oldPlaylist.getEndTimeUs();
+    } else {
+      // No segments overlap, we assume the new playlist start coincides with the primary playlist.
+      return primarySnapshotStartTimeUs;
+    }
+  }
+
+  private int getLoadedPlaylistDiscontinuitySequence(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasDiscontinuitySequence) {
+      return loadedPlaylist.discontinuitySequence;
+    }
+    // TODO: Improve cross-playlist discontinuity adjustment.
+    int primaryUrlDiscontinuitySequence = primaryUrlSnapshot != null
+        ? primaryUrlSnapshot.discontinuitySequence : 0;
+    if (oldPlaylist == null) {
+      return primaryUrlDiscontinuitySequence;
+    }
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.discontinuitySequence
+          + firstOldOverlappingSegment.relativeDiscontinuitySequence
+          - loadedPlaylist.segments.get(0).relativeDiscontinuitySequence;
+    }
+    return primaryUrlDiscontinuitySequence;
+  }
+
+  private static Segment getFirstOldOverlappingSegment(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    int mediaSequenceOffset = loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence;
+    List<Segment> oldSegments = oldPlaylist.segments;
+    return mediaSequenceOffset < oldSegments.size() ? oldSegments.get(mediaSequenceOffset) : null;
+  }
+
+  /**
+   * Holds all information related to a specific Media Playlist.
+   */
+  private final class MediaPlaylistBundle implements Loader.Callback<ParsingLoadable<HlsPlaylist>>,
+      Runnable {
+
+    private final HlsUrl playlistUrl;
+    private final Loader mediaPlaylistLoader;
+    private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
+
+    private HlsMediaPlaylist playlistSnapshot;
+    private long lastSnapshotLoadMs;
+    private long lastSnapshotAccessTimeMs;
+    private long blacklistUntilMs;
+
+    public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {
+      this.playlistUrl = playlistUrl;
+      lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
+      mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
+      mediaPlaylistLoadable = new ParsingLoadable<>(dataSourceFactory.createDataSource(),
+          UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url), C.DATA_TYPE_MANIFEST,
+          playlistParser);
+    }
+
+    public HlsMediaPlaylist getPlaylistSnapshot() {
+      lastSnapshotAccessTimeMs = SystemClock.elapsedRealtime();
+      return playlistSnapshot;
+    }
+
+    public boolean isSnapshotValid() {
+      if (playlistSnapshot == null) {
+        return false;
+      }
+      long currentTimeMs = SystemClock.elapsedRealtime();
+      long snapshotValidityDurationMs = Math.max(30000, C.usToMs(playlistSnapshot.durationUs));
+      return playlistSnapshot.hasEndTag
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_EVENT
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_VOD
+          || lastSnapshotLoadMs + snapshotValidityDurationMs > currentTimeMs;
+    }
+
+    public void release() {
+      mediaPlaylistLoader.release();
+    }
+
+    public void loadPlaylist() {
+      blacklistUntilMs = 0;
+      if (!mediaPlaylistLoader.isLoading()) {
+        mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
+      }
+    }
+
+    // Loader.Callback implementation.
+
+    @Override
+    public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+        long loadDurationMs) {
+      processLoadedPlaylist((HlsMediaPlaylist) loadable.getResult());
+      eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+          loadDurationMs, loadable.bytesLoaded());
+    }
+
+    @Override
+    public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+        long loadDurationMs, boolean released) {
+      eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+          loadDurationMs, loadable.bytesLoaded());
+    }
+
+    @Override
+    public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+        long loadDurationMs, IOException error) {
+      boolean isFatal = error instanceof ParserException;
+      eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+          loadDurationMs, loadable.bytesLoaded(), error, isFatal);
+      if (isFatal) {
+        return Loader.DONT_RETRY_FATAL;
+      }
+      boolean shouldRetry = true;
+      if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {
+        blacklistUntilMs =
+            SystemClock.elapsedRealtime() + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;
+        notifyPlaylistBlacklisting(playlistUrl,
+            ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);
+        shouldRetry = primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
+      }
+      return shouldRetry ? Loader.RETRY : Loader.DONT_RETRY;
+    }
+
+    // Runnable implementation.
+
+    @Override
+    public void run() {
+      loadPlaylist();
+    }
+
+    // Internal methods.
+
+    private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
+      HlsMediaPlaylist oldPlaylist = playlistSnapshot;
+      lastSnapshotLoadMs = SystemClock.elapsedRealtime();
+      playlistSnapshot = getLatestPlaylistSnapshot(oldPlaylist, loadedPlaylist);
+      long refreshDelayUs = C.TIME_UNSET;
+      if (playlistSnapshot != oldPlaylist) {
+        if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
+          refreshDelayUs = playlistSnapshot.targetDurationUs;
+        }
+      } else if (!playlistSnapshot.hasEndTag) {
+        refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
+      }
+      if (refreshDelayUs != C.TIME_UNSET) {
+        // See HLS spec v20, section 6.3.4 for more information on media playlist refreshing.
+        playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index f51280e0b9..aa197806e2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -218,7 +218,7 @@ private static MediaChunk newMediaChunk(Format format, DataSource dataSource, Ur
     // To convert them the absolute timestamps, we need to set sampleOffsetUs to chunkStartTimeUs.
     long sampleOffsetUs = chunkStartTimeUs;
     return new ContainerMediaChunk(dataSource, dataSpec, format, trackSelectionReason,
-        trackSelectionData, chunkStartTimeUs, chunkEndTimeUs, chunkIndex, sampleOffsetUs,
+        trackSelectionData, chunkStartTimeUs, chunkEndTimeUs, chunkIndex, 1, sampleOffsetUs,
         extractorWrapper, format);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index d328e5ecf2..0125d45525 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -19,6 +19,7 @@
 import android.os.Handler;
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
@@ -32,6 +33,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.Loader;
+import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -64,7 +66,7 @@
   private static final long MIN_LIVE_DEFAULT_START_POSITION_US = 5000000;
 
   private final Uri manifestUri;
-  private final DataSource.Factory dataSourceFactory;
+  private final DataSource.Factory manifestDataSourceFactory;
   private final SsChunkSource.Factory chunkSourceFactory;
   private final int minLoadableRetryCount;
   private final long livePresentationDelayMs;
@@ -72,15 +74,57 @@
   private final SsManifestParser manifestParser;
   private final ArrayList<SsMediaPeriod> mediaPeriods;
 
-  private MediaSource.Listener sourceListener;
+  private Listener sourceListener;
   private DataSource manifestDataSource;
   private Loader manifestLoader;
+  private LoaderErrorThrower manifestLoaderErrorThrower;
 
   private long manifestLoadStartTimestamp;
   private SsManifest manifest;
 
   private Handler manifestRefreshHandler;
 
+  /**
+   * Constructs an instance to play a given {@link SsManifest}, which must not be live.
+   *
+   * @param manifest The manifest. {@link SsManifest#isLive} must be false.
+   * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler, AdaptiveMediaSourceEventListener eventListener) {
+    this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT,
+        eventHandler, eventListener);
+  }
+
+  /**
+   * Constructs an instance to play a given {@link SsManifest}, which must not be live.
+   *
+   * @param manifest The manifest. {@link SsManifest#isLive} must be false.
+   * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
+    this(manifest, null, null, null, chunkSourceFactory, minLoadableRetryCount,
+        DEFAULT_LIVE_PRESENTATION_DELAY_MS, eventHandler, eventListener);
+  }
+
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be live or
+   * on-demand.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
   public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
       SsChunkSource.Factory chunkSourceFactory, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
@@ -89,42 +133,97 @@ public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFacto
         eventListener);
   }
 
-  public SsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be live or
+   * on-demand.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+   *     default start position should precede the end of the live window.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+      SsChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
+      long livePresentationDelayMs, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
+    this(manifestUri, manifestDataSourceFactory, new SsManifestParser(), chunkSourceFactory,
+        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+  }
+
+  /**
+   * Constructs an instance to play the manifest at a given {@link Uri}, which may be live or
+   * on-demand.
+   *
+   * @param manifestUri The manifest {@link Uri}.
+   * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+   *     to load (and refresh) the manifest.
+   * @param manifestParser A parser for loaded manifest data.
+   * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+   * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+   *     default start position should precede the end of the live window.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+      SsManifestParser manifestParser, SsChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount, long livePresentationDelayMs, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
+    this(null, manifestUri, manifestDataSourceFactory, manifestParser, chunkSourceFactory,
+        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+  }
+
+  private SsMediaSource(SsManifest manifest, Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory, SsManifestParser manifestParser,
       SsChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
       long livePresentationDelayMs, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
-    this.manifestUri = Util.toLowerInvariant(manifestUri.getLastPathSegment()).equals("manifest")
-        ? manifestUri : Uri.withAppendedPath(manifestUri, "Manifest");
-    this.dataSourceFactory = dataSourceFactory;
+    Assertions.checkState(manifest == null || !manifest.isLive);
+    this.manifest = manifest;
+    this.manifestUri = manifestUri == null ? null
+        : Util.toLowerInvariant(manifestUri.getLastPathSegment()).equals("manifest") ? manifestUri
+            : Uri.withAppendedPath(manifestUri, "Manifest");
+    this.manifestDataSourceFactory = manifestDataSourceFactory;
+    this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.livePresentationDelayMs = livePresentationDelayMs;
     this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    manifestParser = new SsManifestParser();
     mediaPeriods = new ArrayList<>();
   }
 
   // MediaSource implementation.
 
   @Override
-  public void prepareSource(MediaSource.Listener listener) {
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     sourceListener = listener;
-    manifestDataSource = dataSourceFactory.createDataSource();
-    manifestLoader = new Loader("Loader:Manifest");
-    manifestRefreshHandler = new Handler();
-    startLoadingManifest();
+    if (manifest != null) {
+      manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
+      processManifest();
+    } else {
+      manifestDataSource = manifestDataSourceFactory.createDataSource();
+      manifestLoader = new Loader("Loader:Manifest");
+      manifestLoaderErrorThrower = manifestLoader;
+      manifestRefreshHandler = new Handler();
+      startLoadingManifest();
+    }
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    manifestLoader.maybeThrowError();
+    manifestLoaderErrorThrower.maybeThrowError();
   }
 
   @Override
   public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
     SsMediaPeriod period = new SsMediaPeriod(manifest, chunkSourceFactory, minLoadableRetryCount,
-        eventDispatcher, manifestLoader, allocator);
+        eventDispatcher, manifestLoaderErrorThrower, allocator);
     mediaPeriods.add(period);
     return period;
   }
@@ -160,6 +259,29 @@ public void onLoadCompleted(ParsingLoadable<SsManifest> loadable, long elapsedRe
         loadDurationMs, loadable.bytesLoaded());
     manifest = loadable.getResult();
     manifestLoadStartTimestamp = elapsedRealtimeMs - loadDurationMs;
+    processManifest();
+    scheduleManifestRefresh();
+  }
+
+  @Override
+  public void onLoadCanceled(ParsingLoadable<SsManifest> loadable, long elapsedRealtimeMs,
+      long loadDurationMs, boolean released) {
+    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
+        loadDurationMs, loadable.bytesLoaded());
+  }
+
+  @Override
+  public int onLoadError(ParsingLoadable<SsManifest> loadable, long elapsedRealtimeMs,
+      long loadDurationMs, IOException error) {
+    boolean isFatal = error instanceof ParserException;
+    eventDispatcher.loadError(loadable.dataSpec, loadable.type, elapsedRealtimeMs, loadDurationMs,
+        loadable.bytesLoaded(), error, isFatal);
+    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
+  }
+
+  // Internal methods
+
+  private void processManifest() {
     for (int i = 0; i < mediaPeriods.size(); i++) {
       mediaPeriods.get(i).updateManifest(manifest);
     }
@@ -198,27 +320,8 @@ public void onLoadCompleted(ParsingLoadable<SsManifest> loadable, long elapsedRe
       timeline = new SinglePeriodTimeline(manifest.durationUs, isSeekable);
     }
     sourceListener.onSourceInfoRefreshed(timeline, manifest);
-    scheduleManifestRefresh();
   }
 
-  @Override
-  public void onLoadCanceled(ParsingLoadable<SsManifest> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, boolean released) {
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
-  }
-
-  @Override
-  public int onLoadError(ParsingLoadable<SsManifest> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, IOException error) {
-    boolean isFatal = error instanceof ParserException;
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, elapsedRealtimeMs, loadDurationMs,
-        loadable.bytesLoaded(), error, isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
-  }
-
-  // Internal methods
-
   private void scheduleManifestRefresh() {
     if (!manifest.isLive) {
       return;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index b17a424ee6..3ca5f8d997 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -625,7 +625,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         List<byte[]> codecSpecificData = buildCodecSpecificData(
             parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA));
         format = Format.createVideoContainerFormat(id, MimeTypes.VIDEO_MP4, sampleMimeType, null,
-            bitrate, width, height, Format.NO_VALUE, codecSpecificData);
+            bitrate, width, height, Format.NO_VALUE, codecSpecificData, 0);
       } else if (type == C.TRACK_TYPE_AUDIO) {
         sampleMimeType = sampleMimeType == null ? MimeTypes.AUDIO_AAC : sampleMimeType;
         int channels = parseRequiredInt(parser, KEY_CHANNELS);
@@ -644,8 +644,8 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType,
             null, bitrate, 0, language);
       } else {
-        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, null, sampleMimeType,
-            bitrate);
+        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType, null,
+            bitrate, 0, null);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 93b1dc1d9a..c4c5a7e4ca 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Color;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -36,19 +37,23 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
   public @interface AnchorType {}
+
   /**
    * An unset anchor or line type value.
    */
   public static final int TYPE_UNSET = Integer.MIN_VALUE;
+
   /**
    * Anchors the left (for horizontal positions) or top (for vertical positions) edge of the cue
    * box.
    */
   public static final int ANCHOR_TYPE_START = 0;
+
   /**
    * Anchors the middle of the cue box.
    */
   public static final int ANCHOR_TYPE_MIDDLE = 1;
+
   /**
    * Anchors the right (for horizontal positions) or bottom (for vertical positions) edge of the cue
    * box.
@@ -61,10 +66,12 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
   public @interface LineType {}
+
   /**
    * Value for {@link #lineType} when {@link #line} is a fractional position.
    */
   public static final int LINE_TYPE_FRACTION = 0;
+
   /**
    * Value for {@link #lineType} when {@link #line} is a line number.
    */
@@ -74,10 +81,12 @@
    * The cue text. Note the {@link CharSequence} may be decorated with styling spans.
    */
   public final CharSequence text;
+
   /**
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
@@ -86,6 +95,7 @@
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
    */
+
   public final float line;
   /**
    * The type of the {@link #line} value.
@@ -95,11 +105,24 @@
    * <p>
    * {@link #LINE_TYPE_NUMBER} indicates that {@link #line} is a line number, where the size of each
    * line is taken to be the size of the first line of the cue. When {@link #line} is greater than
-   * or equal to 0, lines count from the start of the viewport (the first line is numbered 0). When
-   * {@link #line} is negative, lines count from the end of the viewport (the last line is numbered
-   * -1). For horizontal text the size of the first line of the cue is its height, and the start
-   * and end of the viewport are the top and bottom respectively.
+   * or equal to 0 lines count from the start of the viewport, with 0 indicating zero offset from
+   * the start edge. When {@link #line} is negative lines count from the end of the viewport, with
+   * -1 indicating zero offset from the end edge. For horizontal text the line spacing is the height
+   * of the first line of the cue, and the start and end of the viewport are the top and bottom
+   * respectively.
+   * <p>
+   * Note that it's particularly important to consider the effect of {@link #lineAnchor} when using
+   * {@link #LINE_TYPE_NUMBER}. {@code (line == 0 && lineAnchor == ANCHOR_TYPE_START)} positions a
+   * (potentially multi-line) cue at the very top of the viewport.
+   * {@code (line == -1 && lineAnchor == ANCHOR_TYPE_END)} positions a (potentially multi-line) cue
+   * at the very bottom of the viewport. {@code (line == 0 && lineAnchor == ANCHOR_TYPE_END)}
+   * and {@code (line == -1 && lineAnchor == ANCHOR_TYPE_START)} position cues entirely outside of
+   * the viewport. {@code (line == 1 && lineAnchor == ANCHOR_TYPE_END)} positions a cue so that only
+   * the last line is visible at the top of the viewport.
+   * {@code (line == -2 && lineAnchor == ANCHOR_TYPE_START)} position a cue so that only its first
+   * line is visible at the bottom of the viewport.
    */
+
   @LineType
   public final int lineType;
   /**
@@ -110,6 +133,7 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the top, middle and bottom of the cue box
    * respectively.
    */
+
   @AnchorType
   public final int lineAnchor;
   /**
@@ -121,6 +145,7 @@
    * text.
    */
   public final float position;
+
   /**
    * The cue box anchor positioned by {@link #position}. One of {@link #ANCHOR_TYPE_START},
    * {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
@@ -131,12 +156,23 @@
    */
   @AnchorType
   public final int positionAnchor;
+
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
    */
   public final float size;
 
+  /**
+   * Specifies whether or not the {@link #windowColor} property is set.
+   */
+  public final boolean windowColorSet;
+
+  /**
+   * The fill color of the window.
+   */
+  public final int windowColor;
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +195,25 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size, false,
+        Color.BLACK);
+  }
+
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   */
+  public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +222,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.windowColorSet = windowColorSet;
+    this.windowColor = windowColor;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleOutputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleOutputBuffer.java
index 1a69cd7ebd..b2c25631f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleOutputBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleOutputBuffer.java
@@ -20,7 +20,7 @@
  */
 /* package */ final class SimpleSubtitleOutputBuffer extends SubtitleOutputBuffer {
 
-  private SimpleSubtitleDecoder owner;
+  private final SimpleSubtitleDecoder owner;
 
   /**
    * @param owner The decoder that owns this buffer.
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index 2cbc1ab622..077fc8848b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.text.cea.Cea708Decoder;
 import com.google.android.exoplayer2.text.subrip.SubripDecoder;
 import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
 import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
@@ -58,6 +59,7 @@
    * <li>SubRip ({@link SubripDecoder})</li>
    * <li>TX3G ({@link Tx3gDecoder})</li>
    * <li>Cea608 ({@link Cea608Decoder})</li>
+   * <li>Cea708 ({@link Cea708Decoder})</li>
    * </ul>
    */
   SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
@@ -74,13 +76,25 @@ public SubtitleDecoder createDecoder(Format format) {
         if (clazz == null) {
           throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
         }
-        return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
+        if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
+            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
+          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(String.class, Integer.TYPE)
+              .newInstance(format.sampleMimeType, format.accessibilityChannel);
+        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
+          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
+              .newInstance(format.accessibilityChannel);
+        } else {
+          return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
+        }
       } catch (Exception e) {
         throw new IllegalStateException("Unexpected error instantiating decoder", e);
       }
     }
 
     private Class<?> getDecoderClass(String mimeType) {
+      if (mimeType == null) {
+        return null;
+      }
       try {
         switch (mimeType) {
           case MimeTypes.TEXT_VTT:
@@ -94,7 +108,10 @@ public SubtitleDecoder createDecoder(Format format) {
           case MimeTypes.APPLICATION_TX3G:
             return Class.forName("com.google.android.exoplayer2.text.tx3g.Tx3gDecoder");
           case MimeTypes.APPLICATION_CEA608:
+          case MimeTypes.APPLICATION_MP4CEA608:
             return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
+          case MimeTypes.APPLICATION_CEA708:
+            return Class.forName("com.google.android.exoplayer2.text.cea.Cea708Decoder");
           default:
             return null;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index e28363f9e4..8dbde1be5e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -114,19 +114,11 @@ protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) {
-    inputStreamEnded = false;
-    outputStreamEnded = false;
-    if (subtitle != null) {
-      subtitle.release();
-      subtitle = null;
-    }
-    if (nextSubtitle != null) {
-      nextSubtitle.release();
-      nextSubtitle = null;
-    }
-    nextInputBuffer = null;
     clearOutput();
+    resetBuffers();
     decoder.flush();
+    inputStreamEnded = false;
+    outputStreamEnded = false;
   }
 
   @Override
@@ -220,18 +212,10 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
 
   @Override
   protected void onDisabled() {
-    if (subtitle != null) {
-      subtitle.release();
-      subtitle = null;
-    }
-    if (nextSubtitle != null) {
-      nextSubtitle.release();
-      nextSubtitle = null;
-    }
+    clearOutput();
+    resetBuffers();
     decoder.release();
     decoder = null;
-    nextInputBuffer = null;
-    clearOutput();
     super.onDisabled();
   }
 
@@ -247,6 +231,19 @@ public boolean isReady() {
     return true;
   }
 
+  private void resetBuffers() {
+    nextInputBuffer = null;
+    nextSubtitleEventIndex = C.INDEX_UNSET;
+    if (subtitle != null) {
+      subtitle.release();
+      subtitle = null;
+    }
+    if (nextSubtitle != null) {
+      nextSubtitle.release();
+      nextSubtitle = null;
+    }
+  }
+
   private long getNextEventTime() {
     return ((nextSubtitleEventIndex == C.INDEX_UNSET)
         || (nextSubtitleEventIndex >= subtitle.getEventTimeCount())) ? Long.MAX_VALUE
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 2715b0cbe0..7324c94288 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -15,35 +15,64 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
-import android.text.TextUtils;
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.text.Layout.Alignment;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.CharacterStyle;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
 
 /**
  * A {@link SubtitleDecoder} for CEA-608 (also known as "line 21 captions" and "EIA-608").
  */
 public final class Cea608Decoder extends CeaDecoder {
 
-  private static final int NTSC_CC_FIELD_1 = 0x00;
   private static final int CC_VALID_FLAG = 0x04;
+  private static final int CC_TYPE_FLAG = 0x02;
+  private static final int CC_FIELD_FLAG = 0x01;
 
-  private static final int PAYLOAD_TYPE_CC = 4;
-  private static final int COUNTRY_CODE = 0xB5;
-  private static final int PROVIDER_CODE = 0x31;
-  private static final int USER_ID = 0x47413934; // "GA94"
-  private static final int USER_DATA_TYPE_CODE = 0x3;
+  private static final int NTSC_CC_FIELD_1 = 0x00;
+  private static final int NTSC_CC_FIELD_2 = 0x01;
+  private static final int CC_VALID_608_ID = 0x04;
 
   private static final int CC_MODE_UNKNOWN = 0;
   private static final int CC_MODE_ROLL_UP = 1;
   private static final int CC_MODE_POP_ON = 2;
   private static final int CC_MODE_PAINT_ON = 3;
 
+  private static final int[] ROW_INDICES = new int[] {11, 1, 3, 12, 14, 5, 7, 9};
+  private static final int[] COLUMN_INDICES = new int[] {0, 4, 8, 12, 16, 20, 24, 28};
+  private static final int[] COLORS = new int[] {
+      Color.WHITE,
+      Color.GREEN,
+      Color.BLUE,
+      Color.CYAN,
+      Color.RED,
+      Color.YELLOW,
+      Color.MAGENTA,
+  };
+
   // The default number of rows to display in roll-up captions mode.
   private static final int DEFAULT_CAPTIONS_ROW_COUNT = 4;
 
+  // An implied first byte for packets that are only 2 bytes long, consisting of marker bits
+  // (0b11111) + valid bit (0b1) + NTSC field 1 type bits (0b00).
+  private static final byte CC_IMPLICIT_DATA_HEADER = (byte) 0xFC;
+
   /**
    * Command initiating pop-on style captioning. Subsequent data should be loaded into a
    * non-displayed memory and held there until the {@link #CTRL_END_OF_CAPTION} command is received,
@@ -81,12 +110,10 @@
   private static final byte CTRL_ERASE_DISPLAYED_MEMORY = 0x2C;
   private static final byte CTRL_CARRIAGE_RETURN = 0x2D;
   private static final byte CTRL_ERASE_NON_DISPLAYED_MEMORY = 0x2E;
+  private static final byte CTRL_DELETE_TO_END_OF_ROW = 0x24;
 
   private static final byte CTRL_BACKSPACE = 0x21;
 
-  private static final byte CTRL_MISC_CHAN_1 = 0x14;
-  private static final byte CTRL_MISC_CHAN_2 = 0x1C;
-
   // Basic North American 608 CC char set, mostly ASCII. Indexed by (char-0x20).
   private static final int[] BASIC_CHARACTER_SET = new int[] {
     0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,     //   ! " # $ % & '
@@ -156,26 +183,40 @@
   };
 
   private final ParsableByteArray ccData;
+  private final int packetLength;
+  private final int selectedField;
+  private final LinkedList<CueBuilder> cueBuilders;
 
-  private final StringBuilder captionStringBuilder;
+  private CueBuilder currentCueBuilder;
+  private List<Cue> cues;
+  private List<Cue> lastCues;
 
   private int captionMode;
   private int captionRowCount;
-  private String captionString;
-
-  private String lastCaptionString;
 
   private boolean repeatableControlSet;
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
 
-  public Cea608Decoder() {
+  public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
-
-    captionStringBuilder = new StringBuilder();
+    cueBuilders = new LinkedList<>();
+    currentCueBuilder = new CueBuilder(CC_MODE_UNKNOWN, DEFAULT_CAPTIONS_ROW_COUNT);
+    packetLength = MimeTypes.APPLICATION_MP4CEA608.equals(mimeType) ? 2 : 3;
+    switch (accessibilityChannel) {
+      case 3:
+      case 4:
+        selectedField = 2;
+        break;
+      case 1:
+      case 2:
+      case Format.NO_VALUE:
+      default:
+        selectedField = 1;
+    }
 
     setCaptionMode(CC_MODE_UNKNOWN);
-    captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
+    resetCueBuilders();
   }
 
   @Override
@@ -186,11 +227,11 @@ public String getName() {
   @Override
   public void flush() {
     super.flush();
+    cues = null;
+    lastCues = null;
     setCaptionMode(CC_MODE_UNKNOWN);
+    resetCueBuilders();
     captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
-    captionStringBuilder.setLength(0);
-    captionString = null;
-    lastCaptionString = null;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
@@ -203,13 +244,13 @@ public void release() {
 
   @Override
   protected boolean isNewSubtitleDataAvailable() {
-    return !TextUtils.equals(captionString, lastCaptionString);
+    return cues != lastCues;
   }
 
   @Override
   protected Subtitle createSubtitle() {
-    lastCaptionString = captionString;
-    return new CeaSubtitle(new Cue(captionString));
+    lastCues = cues;
+    return new CeaSubtitle(cues);
   }
 
   @Override
@@ -217,14 +258,23 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
     ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
     boolean captionDataProcessed = false;
     boolean isRepeatableControl = false;
-    while (ccData.bytesLeft() > 0) {
-      byte ccTypeAndValid = (byte) (ccData.readUnsignedByte() & 0x07);
-      byte ccData1 = (byte) (ccData.readUnsignedByte() & 0x7F);
-      byte ccData2 = (byte) (ccData.readUnsignedByte() & 0x7F);
-
-      // Only examine valid NTSC_CC_FIELD_1 packets
-      if (ccTypeAndValid != (CC_VALID_FLAG | NTSC_CC_FIELD_1)) {
-        // TODO: Add support for NTSC_CC_FIELD_2 packets
+    while (ccData.bytesLeft() >= packetLength) {
+      byte ccDataHeader = packetLength == 2 ? CC_IMPLICIT_DATA_HEADER
+          : (byte) ccData.readUnsignedByte();
+      byte ccData1 = (byte) (ccData.readUnsignedByte() & 0x7F); // strip the parity bit
+      byte ccData2 = (byte) (ccData.readUnsignedByte() & 0x7F); // strip the parity bit
+
+      // Only examine valid CEA-608 packets
+      // TODO: We're currently ignoring the top 5 marker bits, which should all be 1s according
+      // to the CEA-608 specification. We need to determine if the data should be handled
+      // differently when that is not the case.
+      if ((ccDataHeader & (CC_VALID_FLAG | CC_TYPE_FLAG)) != CC_VALID_608_ID) {
+        continue;
+      }
+
+      // Only examine packets within the selected field
+      if ((selectedField == 1 && (ccDataHeader & CC_FIELD_FLAG) != NTSC_CC_FIELD_1)
+          || (selectedField == 2 && (ccDataHeader & CC_FIELD_FLAG) != NTSC_CC_FIELD_2)) {
         continue;
       }
 
@@ -232,49 +282,47 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
       if (ccData1 == 0 && ccData2 == 0) {
         continue;
       }
+
       // If we've reached this point then there is data to process; flag that work has been done.
       captionDataProcessed = true;
 
       // Special North American character set.
-      // ccData1 - P|0|0|1|C|0|0|1
-      // ccData2 - P|0|1|1|X|X|X|X
-      if ((ccData1 == 0x11 || ccData1 == 0x19) && ((ccData2 & 0x70) == 0x30)) {
-        // TODO: Make use of the channel bit
-        captionStringBuilder.append(getSpecialChar(ccData2));
+      // ccData1 - 0|0|0|1|C|0|0|1
+      // ccData2 - 0|0|1|1|X|X|X|X
+      if (((ccData1 & 0xF7) == 0x11) && ((ccData2 & 0xF0) == 0x30)) {
+        // TODO: Make use of the channel toggle
+        currentCueBuilder.append(getSpecialChar(ccData2));
         continue;
       }
 
       // Extended Western European character set.
-      // ccData1 - P|0|0|1|C|0|1|S
-      // ccData2 - P|0|1|X|X|X|X|X
-      if ((ccData2 & 0x60) == 0x20) {
-        // Extended Spanish/Miscellaneous and French character set (S = 0).
-        if (ccData1 == 0x12 || ccData1 == 0x1A) {
-          // TODO: Make use of the channel bit
-          backspace(); // Remove standard equivalent of the special extended char.
-          captionStringBuilder.append(getExtendedEsFrChar(ccData2));
-          continue;
-        }
-
-        // Extended Portuguese and German/Danish character set (S = 1).
-        if (ccData1 == 0x13 || ccData1 == 0x1B) {
-          // TODO: Make use of the channel bit
-          backspace(); // Remove standard equivalent of the special extended char.
-          captionStringBuilder.append(getExtendedPtDeChar(ccData2));
-          continue;
+      // ccData1 - 0|0|0|1|C|0|1|S
+      // ccData2 - 0|0|1|X|X|X|X|X
+      if (((ccData1 & 0xF6) == 0x12) && (ccData2 & 0xE0) == 0x20) {
+        // TODO: Make use of the channel toggle
+        // Remove standard equivalent of the special extended char before appending new one
+        currentCueBuilder.backspace();
+        if ((ccData1 & 0x01) == 0x00) {
+          // Extended Spanish/Miscellaneous and French character set (S = 0).
+          currentCueBuilder.append(getExtendedEsFrChar(ccData2));
+        } else {
+          // Extended Portuguese and German/Danish character set (S = 1).
+          currentCueBuilder.append(getExtendedPtDeChar(ccData2));
         }
+        continue;
       }
 
       // Control character.
-      if (ccData1 < 0x20) {
+      // ccData1 - 0|0|0|X|X|X|X|X
+      if ((ccData1 & 0xE0) == 0x00) {
         isRepeatableControl = handleCtrl(ccData1, ccData2);
         continue;
       }
 
       // Basic North American character set.
-      captionStringBuilder.append(getChar(ccData1));
-      if (ccData2 >= 0x20) {
-        captionStringBuilder.append(getChar(ccData2));
+      currentCueBuilder.append(getChar(ccData1));
+      if ((ccData2 & 0xE0) != 0x00) {
+        currentCueBuilder.append(getChar(ccData2));
       }
     }
 
@@ -283,34 +331,106 @@ protected void decode(SubtitleInputBuffer inputBuffer) {
         repeatableControlSet = false;
       }
       if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
-        captionString = getDisplayCaption();
+        cues = getDisplayCues();
       }
     }
   }
 
   private boolean handleCtrl(byte cc1, byte cc2) {
     boolean isRepeatableControl = isRepeatable(cc1);
+
+    // Most control commands are sent twice in succession to ensure they are received properly.
+    // We don't want to process duplicate commands, so if we see the same repeatable command twice
+    // in a row, ignore the second one.
     if (isRepeatableControl) {
       if (repeatableControlSet
           && repeatableControlCc1 == cc1
           && repeatableControlCc2 == cc2) {
+        // This is a duplicate. Clear the repeatable control flag and return.
         repeatableControlSet = false;
         return true;
       } else {
+        // This is a repeatable command, but we haven't see it yet, so set the repeabable control
+        // flag (to ensure we ignore the next one should it be a duplicate) and continue processing
+        // the command.
         repeatableControlSet = true;
         repeatableControlCc1 = cc1;
         repeatableControlCc2 = cc2;
       }
     }
-    if (isMiscCode(cc1, cc2)) {
-      handleMiscCode(cc2);
+
+    if (isMidrowCtrlCode(cc1, cc2)) {
+      handleMidrowCtrl(cc2);
     } else if (isPreambleAddressCode(cc1, cc2)) {
-      // TODO: Add better handling of this with specific positioning.
-      maybeAppendNewline();
+      handlePreambleAddressCode(cc1, cc2);
+    } else if (isTabCtrlCode(cc1, cc2)) {
+      currentCueBuilder.tab(cc2 - 0x20);
+    } else if (isMiscCode(cc1, cc2)) {
+      handleMiscCode(cc2);
     }
+
     return isRepeatableControl;
   }
 
+  private void handleMidrowCtrl(byte cc2) {
+    // TODO: support the extended styles (i.e. backgrounds and transparencies)
+
+    // cc2 - 0|0|1|0|ATRBT|U
+    // ATRBT is the 3-byte encoded attribute, and U is the underline toggle
+    boolean isUnderlined = (cc2 & 0x01) == 0x01;
+    currentCueBuilder.setUnderline(isUnderlined);
+
+    int attribute = (cc2 >> 1) & 0x0F;
+    if (attribute == 0x07) {
+      currentCueBuilder.setMidrowStyle(new StyleSpan(Typeface.ITALIC), 2);
+      currentCueBuilder.setMidrowStyle(new ForegroundColorSpan(Color.WHITE), 1);
+    } else {
+      currentCueBuilder.setMidrowStyle(new ForegroundColorSpan(COLORS[attribute]), 1);
+    }
+  }
+
+  private void handlePreambleAddressCode(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|E|ROW
+    // C is the channel toggle, E is the extended flag, and ROW is the encoded row
+    int row = ROW_INDICES[cc1 & 0x07];
+    // TODO: Make use of the channel toggle
+    // TODO: support the extended address and style
+
+    // cc2 - 0|1|N|ATTRBTE|U
+    // N is the next row down toggle, ATTRBTE is the 4-byte encoded attribute, and U is the
+    // underline toggle.
+    boolean nextRowDown = (cc2 & 0x20) != 0;
+    if (nextRowDown) {
+      row++;
+    }
+
+    if (row != currentCueBuilder.getRow()) {
+      if (captionMode != CC_MODE_ROLL_UP && !currentCueBuilder.isEmpty()) {
+        currentCueBuilder = new CueBuilder(captionMode, captionRowCount);
+        cueBuilders.add(currentCueBuilder);
+      }
+      currentCueBuilder.setRow(row);
+    }
+
+    if ((cc2 & 0x01) == 0x01) {
+      currentCueBuilder.setPreambleStyle(new UnderlineSpan());
+    }
+
+    // cc2 - 0|1|N|0|STYLE|U
+    // cc2 - 0|1|N|1|CURSR|U
+    int attribute = cc2 >> 1 & 0x0F;
+    if (attribute <= 0x07) {
+      if (attribute == 0x07) {
+        currentCueBuilder.setPreambleStyle(new StyleSpan(Typeface.ITALIC));
+        currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(Color.WHITE));
+      } else {
+        currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(COLORS[attribute]));
+      }
+    } else {
+      currentCueBuilder.setIndent(COLUMN_INDICES[attribute & 0x07]);
+    }
+  }
+
   private void handleMiscCode(byte cc2) {
     switch (cc2) {
       case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
@@ -339,68 +459,43 @@ private void handleMiscCode(byte cc2) {
 
     switch (cc2) {
       case CTRL_ERASE_DISPLAYED_MEMORY:
-        captionString = null;
+        cues = null;
         if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
-          captionStringBuilder.setLength(0);
+          resetCueBuilders();
         }
-        return;
+        break;
       case CTRL_ERASE_NON_DISPLAYED_MEMORY:
-        captionStringBuilder.setLength(0);
-        return;
+        resetCueBuilders();
+        break;
       case CTRL_END_OF_CAPTION:
-        captionString = getDisplayCaption();
-        captionStringBuilder.setLength(0);
-        return;
+        cues = getDisplayCues();
+        resetCueBuilders();
+        break;
       case CTRL_CARRIAGE_RETURN:
-        maybeAppendNewline();
-        return;
-      case CTRL_BACKSPACE:
-        if (captionStringBuilder.length() > 0) {
-          captionStringBuilder.setLength(captionStringBuilder.length() - 1);
+        // carriage returns only apply to rollup captions; don't bother if we don't have anything
+        // to add a carriage return to
+        if (captionMode == CC_MODE_ROLL_UP && !currentCueBuilder.isEmpty()) {
+          currentCueBuilder.rollUp();
         }
-        return;
-    }
-  }
-
-  private void backspace() {
-    if (captionStringBuilder.length() > 0) {
-      captionStringBuilder.setLength(captionStringBuilder.length() - 1);
-    }
-  }
-
-  private void maybeAppendNewline() {
-    int buildLength = captionStringBuilder.length();
-    if (buildLength > 0 && captionStringBuilder.charAt(buildLength - 1) != '\n') {
-      captionStringBuilder.append('\n');
+        break;
+      case CTRL_BACKSPACE:
+        currentCueBuilder.backspace();
+        break;
+      case CTRL_DELETE_TO_END_OF_ROW:
+        // TODO: implement
+        break;
     }
   }
 
-  private String getDisplayCaption() {
-    int buildLength = captionStringBuilder.length();
-    if (buildLength == 0) {
-      return null;
-    }
-
-    boolean endsWithNewline = captionStringBuilder.charAt(buildLength - 1) == '\n';
-    if (buildLength == 1 && endsWithNewline) {
-      return null;
-    }
-
-    int endIndex = endsWithNewline ? buildLength - 1 : buildLength;
-    if (captionMode != CC_MODE_ROLL_UP) {
-      return captionStringBuilder.substring(0, endIndex);
-    }
-
-    int startIndex = 0;
-    int searchBackwardFromIndex = endIndex;
-    for (int i = 0; i < captionRowCount && searchBackwardFromIndex != -1; i++) {
-      searchBackwardFromIndex = captionStringBuilder.lastIndexOf("\n", searchBackwardFromIndex - 1);
-    }
-    if (searchBackwardFromIndex != -1) {
-      startIndex = searchBackwardFromIndex + 1;
+  private List<Cue> getDisplayCues() {
+    List<Cue> displayCues = new ArrayList<>();
+    for (int i = 0; i < cueBuilders.size(); i++) {
+      Cue cue = cueBuilders.get(i).build();
+      if (cue != null) {
+        displayCues.add(cue);
+      }
     }
-    captionStringBuilder.delete(0, startIndex);
-    return captionStringBuilder.substring(0, endIndex - startIndex);
+    return displayCues;
   }
 
   private void setCaptionMode(int captionMode) {
@@ -410,20 +505,26 @@ private void setCaptionMode(int captionMode) {
 
     this.captionMode = captionMode;
     // Clear the working memory.
-    captionStringBuilder.setLength(0);
+    resetCueBuilders();
     if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_UNKNOWN) {
       // When switching to roll-up or unknown, we also need to clear the caption.
-      captionString = null;
+      cues = null;
     }
   }
 
+  private void resetCueBuilders() {
+    currentCueBuilder.reset(captionMode, captionRowCount);
+    cueBuilders.clear();
+    cueBuilders.add(currentCueBuilder);
+  }
+
   private static char getChar(byte ccData) {
     int index = (ccData & 0x7F) - 0x20;
     return (char) BASIC_CHARACTER_SET[index];
   }
 
   private static char getSpecialChar(byte ccData) {
-    int index = ccData & 0xF;
+    int index = ccData & 0x0F;
     return (char) SPECIAL_CHARACTER_SET[index];
   }
 
@@ -437,42 +538,248 @@ private static char getExtendedPtDeChar(byte ccData) {
     return (char) SPECIAL_PT_DE_CHARACTER_SET[index];
   }
 
-  private static boolean isMiscCode(byte cc1, byte cc2) {
-    return (cc1 == CTRL_MISC_CHAN_1 || cc1 == CTRL_MISC_CHAN_2)
-        && (cc2 >= 0x20 && cc2 <= 0x2F);
+  private static boolean isMidrowCtrlCode(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|0|0|1
+    // cc2 - 0|0|1|0|X|X|X|X
+    return ((cc1 & 0xF7) == 0x11) && ((cc2 & 0xF0) == 0x20);
   }
 
   private static boolean isPreambleAddressCode(byte cc1, byte cc2) {
-    return (cc1 >= 0x10 && cc1 <= 0x1F) && (cc2 >= 0x40 && cc2 <= 0x7F);
+    // cc1 - 0|0|0|1|C|X|X|X
+    // cc2 - 0|1|X|X|X|X|X|X
+    return ((cc1 & 0xF0) == 0x10) && ((cc2 & 0xC0) == 0x40);
+  }
+
+  private static boolean isTabCtrlCode(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|1|1|1
+    // cc2 - 0|0|1|0|0|0|0|1 to 0|0|1|0|0|0|1|1
+    return ((cc1 & 0xF7) == 0x17) && (cc2 >= 0x21 && cc2 <= 0x23);
+  }
+
+  private static boolean isMiscCode(byte cc1, byte cc2) {
+    // cc1 - 0|0|0|1|C|1|0|0
+    // cc2 - 0|0|1|0|X|X|X|X
+    return ((cc1 & 0xF7) == 0x14) && ((cc2 & 0xF0) == 0x20);
   }
 
   private static boolean isRepeatable(byte cc1) {
-    return cc1 >= 0x10 && cc1 <= 0x1F;
+    // cc1 - 0|0|0|1|X|X|X|X
+    return (cc1 & 0xF0) == 0x10;
   }
 
-  /**
-   * Inspects an sei message to determine whether it contains CEA-608.
-   * <p>
-   * The position of {@code payload} is left unchanged.
-   *
-   * @param payloadType The payload type of the message.
-   * @param payloadLength The length of the payload.
-   * @param payload A {@link ParsableByteArray} containing the payload.
-   * @return Whether the sei message contains CEA-608.
-   */
-  public static boolean isSeiMessageCea608(int payloadType, int payloadLength,
-      ParsableByteArray payload) {
-    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
-      return false;
-    }
-    int startPosition = payload.getPosition();
-    int countryCode = payload.readUnsignedByte();
-    int providerCode = payload.readUnsignedShort();
-    int userIdentifier = payload.readInt();
-    int userDataTypeCode = payload.readUnsignedByte();
-    payload.setPosition(startPosition);
-    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
-        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
+  private static class CueBuilder {
+
+    private static final int POSITION_UNSET = -1;
+
+    // 608 captions define a 15 row by 32 column screen grid. These constants convert from 608
+    // positions to normalized screen position.
+    private static final int SCREEN_CHARWIDTH = 32;
+    private static final int BASE_ROW = 15;
+
+    private final List<CharacterStyle> preambleStyles;
+    private final List<CueStyle> midrowStyles;
+    private final List<SpannableString> rolledUpCaptions;
+    private final SpannableStringBuilder captionStringBuilder;
+
+    private int row;
+    private int indent;
+    private int tabOffset;
+    private int captionMode;
+    private int captionRowCount;
+    private int underlineStartPosition;
+
+    public CueBuilder(int captionMode, int captionRowCount) {
+      preambleStyles = new ArrayList<>();
+      midrowStyles = new ArrayList<>();
+      rolledUpCaptions = new LinkedList<>();
+      captionStringBuilder = new SpannableStringBuilder();
+      reset(captionMode, captionRowCount);
+    }
+
+    public void reset(int captionMode, int captionRowCount) {
+      preambleStyles.clear();
+      midrowStyles.clear();
+      rolledUpCaptions.clear();
+      captionStringBuilder.clear();
+      row = BASE_ROW;
+      indent = 0;
+      tabOffset = 0;
+      this.captionMode = captionMode;
+      this.captionRowCount = captionRowCount;
+      underlineStartPosition = POSITION_UNSET;
+    }
+
+    public boolean isEmpty() {
+      return preambleStyles.isEmpty() && midrowStyles.isEmpty() && rolledUpCaptions.isEmpty()
+          && captionStringBuilder.length() == 0;
+    }
+
+    public void backspace() {
+      int length = captionStringBuilder.length();
+      if (length > 0) {
+        captionStringBuilder.delete(length - 1, length);
+      }
+    }
+
+    public int getRow() {
+      return row;
+    }
+
+    public void setRow(int row) {
+      this.row = row;
+    }
+
+    public void rollUp() {
+      rolledUpCaptions.add(buildSpannableString());
+      captionStringBuilder.clear();
+      preambleStyles.clear();
+      midrowStyles.clear();
+      underlineStartPosition = POSITION_UNSET;
+
+      int numRows = Math.min(captionRowCount, row);
+      while (rolledUpCaptions.size() >= numRows) {
+        rolledUpCaptions.remove(0);
+      }
+    }
+
+    public void setIndent(int indent) {
+      this.indent = indent;
+    }
+
+    public void tab(int tabs) {
+      tabOffset += tabs;
+    }
+
+    public void setPreambleStyle(CharacterStyle style) {
+      preambleStyles.add(style);
+    }
+
+    public void setMidrowStyle(CharacterStyle style, int nextStyleIncrement) {
+      midrowStyles.add(new CueStyle(style, captionStringBuilder.length(), nextStyleIncrement));
+    }
+
+    public void setUnderline(boolean enabled) {
+      if (enabled) {
+        underlineStartPosition = captionStringBuilder.length();
+      } else if (underlineStartPosition != POSITION_UNSET) {
+        // underline spans won't overlap, so it's safe to modify the builder directly with them
+        captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+            captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        underlineStartPosition = POSITION_UNSET;
+      }
+    }
+
+    public void append(char text) {
+      captionStringBuilder.append(text);
+    }
+
+    public SpannableString buildSpannableString() {
+      int length = captionStringBuilder.length();
+
+      // preamble styles apply to the entire cue
+      for (int i = 0; i < preambleStyles.size(); i++) {
+        captionStringBuilder.setSpan(preambleStyles.get(i), 0, length,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      }
+
+      // midrow styles only apply to part of the cue, and after preamble styles
+      for (int i = 0; i < midrowStyles.size(); i++) {
+        CueStyle cueStyle = midrowStyles.get(i);
+        int end = (i < midrowStyles.size() - cueStyle.nextStyleIncrement)
+            ? midrowStyles.get(i + cueStyle.nextStyleIncrement).start
+            : length;
+        captionStringBuilder.setSpan(cueStyle.style, cueStyle.start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      }
+
+      // special case for midrow underlines that went to the end of the cue
+      if (underlineStartPosition != POSITION_UNSET) {
+        captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition, length,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+      }
+
+      return new SpannableString(captionStringBuilder);
+    }
+
+    public Cue build() {
+      SpannableStringBuilder cueString = new SpannableStringBuilder();
+      // Add any rolled up captions, separated by new lines.
+      for (int i = 0; i < rolledUpCaptions.size(); i++) {
+        cueString.append(rolledUpCaptions.get(i));
+        cueString.append('\n');
+      }
+      // Add the current line.
+      cueString.append(buildSpannableString());
+
+      if (cueString.length() == 0) {
+        // The cue is empty.
+        return null;
+      }
+
+      float position;
+      int positionAnchor;
+      // The number of empty columns before the start of the text, in the range [0-31].
+      int startPadding = indent + tabOffset;
+      // The number of empty columns after the end of the text, in the same range.
+      int endPadding = SCREEN_CHARWIDTH - startPadding - cueString.length();
+      int startEndPaddingDelta = startPadding - endPadding;
+      if (captionMode == CC_MODE_POP_ON && Math.abs(startEndPaddingDelta) < 3) {
+        // Treat approximately centered pop-on captions are middle aligned.
+        position = 0.5f;
+        positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
+      } else if (captionMode == CC_MODE_POP_ON && startEndPaddingDelta > 0) {
+        // Treat pop-on captions with less padding at the end than the start as end aligned.
+        position = (float) (SCREEN_CHARWIDTH - endPadding) / SCREEN_CHARWIDTH;
+        // Adjust the position to fit within the safe area.
+        position = position * 0.8f + 0.1f;
+        positionAnchor = Cue.ANCHOR_TYPE_END;
+      } else {
+        // For all other cases assume start aligned.
+        position = (float) startPadding / SCREEN_CHARWIDTH;
+        // Adjust the position to fit within the safe area.
+        position = position * 0.8f + 0.1f;
+        positionAnchor = Cue.ANCHOR_TYPE_START;
+      }
+
+      int lineAnchor;
+      int line;
+      // Note: Row indices are in the range [1-15].
+      if (captionMode == CC_MODE_ROLL_UP || row > (BASE_ROW / 2)) {
+        lineAnchor = Cue.ANCHOR_TYPE_END;
+        line = row - BASE_ROW;
+        // Two line adjustments. The first is because line indices from the bottom of the window
+        // start from -1 rather than 0. The second is a blank row to act as the safe area.
+        line -= 2;
+      } else {
+        lineAnchor = Cue.ANCHOR_TYPE_START;
+        // Line indices from the top of the window start from 0, but we want a blank row to act as
+        // the safe area. As a result no adjustment is necessary.
+        line = row;
+      }
+
+      return new Cue(cueString, Alignment.ALIGN_NORMAL, line, Cue.LINE_TYPE_NUMBER, lineAnchor,
+          position, positionAnchor, Cue.DIMEN_UNSET);
+    }
+
+    @Override
+    public String toString() {
+      return captionStringBuilder.toString();
+    }
+
+    private static class CueStyle {
+
+      public final CharacterStyle style;
+      public final int start;
+      public final int nextStyleIncrement;
+
+      public CueStyle(CharacterStyle style, int start, int nextStyleIncrement) {
+        this.style = style;
+        this.start = start;
+        this.nextStyleIncrement = nextStyleIncrement;
+      }
+
+    }
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
new file mode 100644
index 0000000000..e63d1d4118
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.text.Layout.Alignment;
+import com.google.android.exoplayer2.text.Cue;
+
+/**
+ * A {@link Cue} for CEA-708.
+ */
+/* package */ final class Cea708Cue extends Cue implements Comparable<Cea708Cue> {
+
+  /**
+   * An unset priority.
+   */
+  public static final int PRIORITY_UNSET = -1;
+
+  /**
+   * The priority of the cue box.
+   */
+  public final int priority;
+
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   * @param priority See (@link #priority}.
+   */
+  public Cea708Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor, int priority) {
+    super(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+        windowColorSet, windowColor);
+    this.priority = priority;
+  }
+
+  @Override
+  public int compareTo(Cea708Cue other) {
+    if (other.priority < priority) {
+      return -1;
+    } else if (other.priority > priority) {
+      return 1;
+    }
+    return 0;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
new file mode 100644
index 0000000000..5ca5ce1270
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -0,0 +1,1225 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.text.Layout.Alignment;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.BackgroundColorSpan;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Cue.AnchorType;
+import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.text.SubtitleDecoder;
+import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A {@link SubtitleDecoder} for CEA-708 (also known as "EIA-708").
+ *
+ * <p>This implementation does not provide full compatibility with the CEA-708 specification. Note
+ * that only the default pen/text and window/cue colors (i.e. text with
+ * {@link CueBuilder#COLOR_SOLID_WHITE} foreground and {@link CueBuilder#COLOR_SOLID_BLACK}
+ * background, and cues with {@link CueBuilder#COLOR_SOLID_BLACK} fill) will be overridden with
+ * device accessibility settings; all others will use the colors and opacity specified by the
+ * caption data.
+ */
+public final class Cea708Decoder extends CeaDecoder {
+
+  private static final String TAG = "Cea708Decoder";
+
+  private static final int NUM_WINDOWS = 8;
+
+  private static final int DTVCC_PACKET_DATA = 0x02;
+  private static final int DTVCC_PACKET_START = 0x03;
+  private static final int CC_VALID_FLAG = 0x04;
+
+  // Base Commands
+  private static final int GROUP_C0_END = 0x1F;  // Miscellaneous Control Codes
+  private static final int GROUP_G0_END = 0x7F;  // ASCII Printable Characters
+  private static final int GROUP_C1_END = 0x9F;  // Captioning Command Control Codes
+  private static final int GROUP_G1_END = 0xFF;  // ISO 8859-1 LATIN-1 Character Set
+
+  // Extended Commands
+  private static final int GROUP_C2_END = 0x1F;  // Extended Control Code Set 1
+  private static final int GROUP_G2_END = 0x7F;  // Extended Miscellaneous Characters
+  private static final int GROUP_C3_END = 0x9F;  // Extended Control Code Set 2
+  private static final int GROUP_G3_END = 0xFF;  // Future Expansion
+
+  // Group C0 Commands
+  private static final int COMMAND_NUL = 0x00;        // Nul
+  private static final int COMMAND_ETX = 0x03;        // EndOfText
+  private static final int COMMAND_BS = 0x08;         // Backspace
+  private static final int COMMAND_FF = 0x0C;         // FormFeed (Flush)
+  private static final int COMMAND_CR = 0x0D;         // CarriageReturn
+  private static final int COMMAND_HCR = 0x0E;        // ClearLine
+  private static final int COMMAND_EXT1 = 0x10;       // Extended Control Code Flag
+  private static final int COMMAND_EXT1_START = 0x11;
+  private static final int COMMAND_EXT1_END = 0x17;
+  private static final int COMMAND_P16_START = 0x18;
+  private static final int COMMAND_P16_END = 0x1F;
+
+  // Group C1 Commands
+  private static final int COMMAND_CW0 = 0x80;  // SetCurrentWindow to 0
+  private static final int COMMAND_CW1 = 0x81;  // SetCurrentWindow to 1
+  private static final int COMMAND_CW2 = 0x82;  // SetCurrentWindow to 2
+  private static final int COMMAND_CW3 = 0x83;  // SetCurrentWindow to 3
+  private static final int COMMAND_CW4 = 0x84;  // SetCurrentWindow to 4
+  private static final int COMMAND_CW5 = 0x85;  // SetCurrentWindow to 5
+  private static final int COMMAND_CW6 = 0x86;  // SetCurrentWindow to 6
+  private static final int COMMAND_CW7 = 0x87;  // SetCurrentWindow to 7
+  private static final int COMMAND_CLW = 0x88;  // ClearWindows (+1 byte)
+  private static final int COMMAND_DSW = 0x89;  // DisplayWindows (+1 byte)
+  private static final int COMMAND_HDW = 0x8A;  // HideWindows (+1 byte)
+  private static final int COMMAND_TGW = 0x8B;  // ToggleWindows (+1 byte)
+  private static final int COMMAND_DLW = 0x8C;  // DeleteWindows (+1 byte)
+  private static final int COMMAND_DLY = 0x8D;  // Delay (+1 byte)
+  private static final int COMMAND_DLC = 0x8E;  // DelayCancel
+  private static final int COMMAND_RST = 0x8F;  // Reset
+  private static final int COMMAND_SPA = 0x90;  // SetPenAttributes (+2 bytes)
+  private static final int COMMAND_SPC = 0x91;  // SetPenColor (+3 bytes)
+  private static final int COMMAND_SPL = 0x92;  // SetPenLocation (+2 bytes)
+  private static final int COMMAND_SWA = 0x97;  // SetWindowAttributes (+4 bytes)
+  private static final int COMMAND_DF0 = 0x98;  // DefineWindow 0 (+6 bytes)
+  private static final int COMMAND_DF1 = 0x99;  // DefineWindow 1 (+6 bytes)
+  private static final int COMMAND_DF2 = 0x9A;  // DefineWindow 2 (+6 bytes)
+  private static final int COMMAND_DF3 = 0x9B;  // DefineWindow 3 (+6 bytes)
+  private static final int COMMAND_DS4 = 0x9C;  // DefineWindow 4 (+6 bytes)
+  private static final int COMMAND_DF5 = 0x9D;  // DefineWindow 5 (+6 bytes)
+  private static final int COMMAND_DF6 = 0x9E;  // DefineWindow 6 (+6 bytes)
+  private static final int COMMAND_DF7 = 0x9F;  // DefineWindow 7 (+6 bytes)
+
+  // G0 Table Special Chars
+  private static final int CHARACTER_MN = 0x7F;  // MusicNote
+
+  // G2 Table Special Chars
+  private static final int CHARACTER_TSP = 0x20;
+  private static final int CHARACTER_NBTSP = 0x21;
+  private static final int CHARACTER_ELLIPSIS = 0x25;
+  private static final int CHARACTER_BIG_CARONS = 0x2A;
+  private static final int CHARACTER_BIG_OE = 0x2C;
+  private static final int CHARACTER_SOLID_BLOCK = 0x30;
+  private static final int CHARACTER_OPEN_SINGLE_QUOTE = 0x31;
+  private static final int CHARACTER_CLOSE_SINGLE_QUOTE = 0x32;
+  private static final int CHARACTER_OPEN_DOUBLE_QUOTE = 0x33;
+  private static final int CHARACTER_CLOSE_DOUBLE_QUOTE = 0x34;
+  private static final int CHARACTER_BOLD_BULLET = 0x35;
+  private static final int CHARACTER_TM = 0x39;
+  private static final int CHARACTER_SMALL_CARONS = 0x3A;
+  private static final int CHARACTER_SMALL_OE = 0x3C;
+  private static final int CHARACTER_SM = 0x3D;
+  private static final int CHARACTER_DIAERESIS_Y = 0x3F;
+  private static final int CHARACTER_ONE_EIGHTH = 0x76;
+  private static final int CHARACTER_THREE_EIGHTHS = 0x77;
+  private static final int CHARACTER_FIVE_EIGHTHS = 0x78;
+  private static final int CHARACTER_SEVEN_EIGHTHS = 0x79;
+  private static final int CHARACTER_VERTICAL_BORDER = 0x7A;
+  private static final int CHARACTER_UPPER_RIGHT_BORDER = 0x7B;
+  private static final int CHARACTER_LOWER_LEFT_BORDER = 0x7C;
+  private static final int CHARACTER_HORIZONTAL_BORDER = 0x7D;
+  private static final int CHARACTER_LOWER_RIGHT_BORDER = 0x7E;
+  private static final int CHARACTER_UPPER_LEFT_BORDER = 0x7F;
+
+  private final ParsableByteArray ccData;
+  private final ParsableBitArray serviceBlockPacket;
+
+  private final int selectedServiceNumber;
+  private final CueBuilder[] cueBuilders;
+
+  private CueBuilder currentCueBuilder;
+  private List<Cue> cues;
+  private List<Cue> lastCues;
+
+  private DtvCcPacket currentDtvCcPacket;
+  private int currentWindow;
+
+  public Cea708Decoder(int accessibilityChannel) {
+    ccData = new ParsableByteArray();
+    serviceBlockPacket = new ParsableBitArray();
+    selectedServiceNumber = (accessibilityChannel == Format.NO_VALUE) ? 1 : accessibilityChannel;
+
+    cueBuilders = new CueBuilder[NUM_WINDOWS];
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i] = new CueBuilder();
+    }
+
+    currentCueBuilder = cueBuilders[0];
+    resetCueBuilders();
+  }
+
+  @Override
+  public String getName() {
+    return "Cea708Decoder";
+  }
+
+  @Override
+  public void flush() {
+    super.flush();
+    cues = null;
+    lastCues = null;
+    currentWindow = 0;
+    currentCueBuilder = cueBuilders[currentWindow];
+    resetCueBuilders();
+    currentDtvCcPacket = null;
+  }
+
+  @Override
+  protected boolean isNewSubtitleDataAvailable() {
+    return cues != lastCues;
+  }
+
+  @Override
+  protected Subtitle createSubtitle() {
+    lastCues = cues;
+    return new CeaSubtitle(cues);
+  }
+
+  @Override
+  protected void decode(SubtitleInputBuffer inputBuffer) {
+    ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
+    while (ccData.bytesLeft() >= 3) {
+      int ccTypeAndValid = (ccData.readUnsignedByte() & 0x07);
+
+      int ccType = ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
+      boolean ccValid = (ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
+      byte ccData1 = (byte) ccData.readUnsignedByte();
+      byte ccData2 = (byte) ccData.readUnsignedByte();
+
+      // Ignore any non-CEA-708 data
+      if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
+        continue;
+      }
+
+      if (!ccValid) {
+        finalizeCurrentPacket();
+        continue;
+      }
+
+      if (ccType == DTVCC_PACKET_START) {
+        finalizeCurrentPacket();
+
+        int sequenceNumber = (ccData1 & 0xC0) >> 6; // first 2 bits
+        int packetSize = ccData1 & 0x3F; // last 6 bits
+        if (packetSize == 0) {
+          packetSize = 64;
+        }
+
+        currentDtvCcPacket = new DtvCcPacket(sequenceNumber, packetSize);
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      } else {
+        // The only remaining valid packet type is DTVCC_PACKET_DATA
+        Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
+
+        if (currentDtvCcPacket == null) {
+          Log.e(TAG, "Encountered DTVCC_PACKET_DATA before DTVCC_PACKET_START");
+          continue;
+        }
+
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData1;
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      }
+
+      if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
+        finalizeCurrentPacket();
+      }
+    }
+  }
+
+  private void finalizeCurrentPacket() {
+    if (currentDtvCcPacket == null) {
+      // No packet to finalize;
+      return;
+    }
+
+    processCurrentPacket();
+    currentDtvCcPacket = null;
+  }
+
+  private void processCurrentPacket() {
+    if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
+      Log.w(TAG, "DtvCcPacket ended prematurely; size is " + (currentDtvCcPacket.packetSize * 2 - 1)
+          + ", but current index is " + currentDtvCcPacket.currentIndex + " (sequence number "
+          + currentDtvCcPacket.sequenceNumber + ")");
+    }
+
+    serviceBlockPacket.reset(currentDtvCcPacket.packetData, currentDtvCcPacket.currentIndex);
+
+    int serviceNumber = serviceBlockPacket.readBits(3);
+    int blockSize = serviceBlockPacket.readBits(5);
+    if (serviceNumber == 7) {
+      // extended service numbers
+      serviceBlockPacket.skipBits(2);
+      serviceNumber += serviceBlockPacket.readBits(6);
+    }
+
+    // Ignore packets in which blockSize is 0
+    if (blockSize == 0) {
+      if (serviceNumber != 0) {
+        Log.w(TAG, "serviceNumber is non-zero (" + serviceNumber + ") when blockSize is 0");
+      }
+      return;
+    }
+
+    if (serviceNumber != selectedServiceNumber) {
+      return;
+    }
+
+    while (serviceBlockPacket.bitsLeft() > 0) {
+      int command = serviceBlockPacket.readBits(8);
+      if (command != COMMAND_EXT1) {
+        if (command <= GROUP_C0_END) {
+          handleC0Command(command);
+        } else if (command <= GROUP_G0_END) {
+          handleG0Character(command);
+        } else if (command <= GROUP_C1_END) {
+          handleC1Command(command);
+          // Cues are always updated after a C1 command
+          cues = getDisplayCues();
+        } else if (command <= GROUP_G1_END) {
+          handleG1Character(command);
+        } else {
+          Log.w(TAG, "Invalid base command: " + command);
+        }
+      } else {
+        // Read the extended command
+        command = serviceBlockPacket.readBits(8);
+        if (command <= GROUP_C2_END) {
+          handleC2Command(command);
+        } else if (command <= GROUP_G2_END) {
+          handleG2Character(command);
+        } else if (command <= GROUP_C3_END) {
+          handleC3Command(command);
+        } else if (command <= GROUP_G3_END) {
+          handleG3Character(command);
+        } else {
+          Log.w(TAG, "Invalid extended command: " + command);
+        }
+      }
+    }
+  }
+
+  private void handleC0Command(int command) {
+    switch (command) {
+      case COMMAND_NUL:
+        // Do nothing.
+        break;
+      case COMMAND_ETX:
+        cues = getDisplayCues();
+        break;
+      case COMMAND_BS:
+        currentCueBuilder.backspace();
+        break;
+      case COMMAND_FF:
+        resetCueBuilders();
+        break;
+      case COMMAND_CR:
+        currentCueBuilder.append('\n');
+        break;
+      case COMMAND_HCR:
+        // TODO: Add support for this command.
+        break;
+      default:
+        if (command >= COMMAND_EXT1_START && command <= COMMAND_EXT1_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_EXT1 Command: " + command);
+          serviceBlockPacket.skipBits(8);
+        } else if (command >= COMMAND_P16_START && command <= COMMAND_P16_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_P16 Command: " + command);
+          serviceBlockPacket.skipBits(16);
+        } else {
+          Log.w(TAG, "Invalid C0 command: " + command);
+        }
+    }
+  }
+
+  private void handleC1Command(int command) {
+    int window;
+    switch (command) {
+      case COMMAND_CW0:
+      case COMMAND_CW1:
+      case COMMAND_CW2:
+      case COMMAND_CW3:
+      case COMMAND_CW4:
+      case COMMAND_CW5:
+      case COMMAND_CW6:
+      case COMMAND_CW7:
+        window = (command - COMMAND_CW0);
+        if (currentWindow != window) {
+          currentWindow = window;
+          currentCueBuilder = cueBuilders[window];
+        }
+        break;
+      case COMMAND_CLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].clear();
+          }
+        }
+        break;
+      case COMMAND_DSW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(true);
+          }
+        }
+        break;
+      case COMMAND_HDW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(false);
+          }
+        }
+        break;
+      case COMMAND_TGW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            CueBuilder cueBuilder = cueBuilders[NUM_WINDOWS - i];
+            cueBuilder.setVisibility(!cueBuilder.isVisible());
+          }
+        }
+        break;
+      case COMMAND_DLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].reset();
+          }
+        }
+        break;
+      case COMMAND_DLY:
+        // TODO: Add support for delay commands.
+        serviceBlockPacket.skipBits(8);
+        break;
+      case COMMAND_DLC:
+        // TODO: Add support for delay commands.
+        break;
+      case COMMAND_RST:
+        resetCueBuilders();
+        break;
+      case COMMAND_SPA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenAttributes();
+        }
+        break;
+      case COMMAND_SPC:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(24);
+        } else {
+          handleSetPenColor();
+        }
+        break;
+      case COMMAND_SPL:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenLocation();
+        }
+        break;
+      case COMMAND_SWA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(32);
+        } else {
+          handleSetWindowAttributes();
+        }
+        break;
+      case COMMAND_DF0:
+      case COMMAND_DF1:
+      case COMMAND_DF2:
+      case COMMAND_DF3:
+      case COMMAND_DS4:
+      case COMMAND_DF5:
+      case COMMAND_DF6:
+      case COMMAND_DF7:
+        window = (command - COMMAND_DF0);
+        handleDefineWindow(window);
+        break;
+      default:
+        Log.w(TAG, "Invalid C1 command: " + command);
+    }
+  }
+
+  private void handleC2Command(int command) {
+    // C2 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x0F) {
+      // Do nothing.
+    } else if (command <= 0x0F) {
+      serviceBlockPacket.skipBits(8);
+    } else if (command <= 0x17) {
+      serviceBlockPacket.skipBits(16);
+    } else if (command <= 0x1F) {
+      serviceBlockPacket.skipBits(24);
+    }
+  }
+
+  private void handleC3Command(int command) {
+    // C3 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x87) {
+      serviceBlockPacket.skipBits(32);
+    } else if (command <= 0x8F) {
+      serviceBlockPacket.skipBits(40);
+    } else if (command <= 0x9F) {
+      // 90-9F are variable length codes; the first byte defines the header with the first
+      // 2 bits specifying the type and the last 6 bits specifying the remaining length of the
+      // command in bytes
+      serviceBlockPacket.skipBits(2);
+      int length = serviceBlockPacket.readBits(6);
+      serviceBlockPacket.skipBits(8 * length);
+    }
+  }
+
+  private void handleG0Character(int characterCode) {
+    if (characterCode == CHARACTER_MN) {
+      currentCueBuilder.append('\u266B');
+    } else {
+      currentCueBuilder.append((char) (characterCode & 0xFF));
+    }
+  }
+
+  private void handleG1Character(int characterCode) {
+    currentCueBuilder.append((char) (characterCode & 0xFF));
+  }
+
+  private void handleG2Character(int characterCode) {
+    switch (characterCode) {
+      case CHARACTER_TSP:
+        currentCueBuilder.append('\u0020');
+        break;
+      case CHARACTER_NBTSP:
+        currentCueBuilder.append('\u00A0');
+        break;
+      case CHARACTER_ELLIPSIS:
+        currentCueBuilder.append('\u2026');
+        break;
+      case CHARACTER_BIG_CARONS:
+        currentCueBuilder.append('\u0160');
+        break;
+      case CHARACTER_BIG_OE:
+        currentCueBuilder.append('\u0152');
+        break;
+      case CHARACTER_SOLID_BLOCK:
+        currentCueBuilder.append('\u2588');
+        break;
+      case CHARACTER_OPEN_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2018');
+        break;
+      case CHARACTER_CLOSE_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2019');
+        break;
+      case CHARACTER_OPEN_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201C');
+        break;
+      case CHARACTER_CLOSE_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201D');
+        break;
+      case CHARACTER_BOLD_BULLET:
+        currentCueBuilder.append('\u2022');
+        break;
+      case CHARACTER_TM:
+        currentCueBuilder.append('\u2122');
+        break;
+      case CHARACTER_SMALL_CARONS:
+        currentCueBuilder.append('\u0161');
+        break;
+      case CHARACTER_SMALL_OE:
+        currentCueBuilder.append('\u0153');
+        break;
+      case CHARACTER_SM:
+        currentCueBuilder.append('\u2120');
+        break;
+      case CHARACTER_DIAERESIS_Y:
+        currentCueBuilder.append('\u0178');
+        break;
+      case CHARACTER_ONE_EIGHTH:
+        currentCueBuilder.append('\u215B');
+        break;
+      case CHARACTER_THREE_EIGHTHS:
+        currentCueBuilder.append('\u215C');
+        break;
+      case CHARACTER_FIVE_EIGHTHS:
+        currentCueBuilder.append('\u215D');
+        break;
+      case CHARACTER_SEVEN_EIGHTHS:
+        currentCueBuilder.append('\u215E');
+        break;
+      case CHARACTER_VERTICAL_BORDER:
+        currentCueBuilder.append('\u2502');
+        break;
+      case CHARACTER_UPPER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2510');
+        break;
+      case CHARACTER_LOWER_LEFT_BORDER:
+        currentCueBuilder.append('\u2514');
+        break;
+      case CHARACTER_HORIZONTAL_BORDER:
+        currentCueBuilder.append('\u2500');
+        break;
+      case CHARACTER_LOWER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2518');
+        break;
+      case CHARACTER_UPPER_LEFT_BORDER:
+        currentCueBuilder.append('\u250C');
+        break;
+      default:
+        Log.w(TAG, "Invalid G2 character: " + characterCode);
+        // The CEA-708 specification doesn't specify what to do in the case of an unexpected
+        // value in the G2 character range, so we ignore it.
+    }
+  }
+
+  private void handleG3Character(int characterCode) {
+    if (characterCode == 0xA0) {
+      currentCueBuilder.append('\u33C4');
+    } else {
+      Log.w(TAG, "Invalid G3 character: " + characterCode);
+      // Substitute any unsupported G3 character with an underscore as per CEA-708 specification.
+      currentCueBuilder.append('_');
+    }
+  }
+
+  private void handleSetPenAttributes() {
+    // the SetPenAttributes command contains 2 bytes of data
+    // first byte
+    int textTag = serviceBlockPacket.readBits(4);
+    int offset = serviceBlockPacket.readBits(2);
+    int penSize = serviceBlockPacket.readBits(2);
+    // second byte
+    boolean italicsToggle = serviceBlockPacket.readBit();
+    boolean underlineToggle = serviceBlockPacket.readBit();
+    int edgeType = serviceBlockPacket.readBits(3);
+    int fontStyle = serviceBlockPacket.readBits(3);
+
+    currentCueBuilder.setPenAttributes(textTag, offset, penSize, italicsToggle, underlineToggle,
+        edgeType, fontStyle);
+  }
+
+  private void handleSetPenColor() {
+    // the SetPenColor command contains 3 bytes of data
+    // first byte
+    int foregroundO = serviceBlockPacket.readBits(2);
+    int foregroundR = serviceBlockPacket.readBits(2);
+    int foregroundG = serviceBlockPacket.readBits(2);
+    int foregroundB = serviceBlockPacket.readBits(2);
+    int foregroundColor = CueBuilder.getArgbColorFromCeaColor(foregroundR, foregroundG, foregroundB,
+        foregroundO);
+    // second byte
+    int backgroundO = serviceBlockPacket.readBits(2);
+    int backgroundR = serviceBlockPacket.readBits(2);
+    int backgroundG = serviceBlockPacket.readBits(2);
+    int backgroundB = serviceBlockPacket.readBits(2);
+    int backgroundColor = CueBuilder.getArgbColorFromCeaColor(backgroundR, backgroundG, backgroundB,
+        backgroundO);
+    // third byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int edgeR = serviceBlockPacket.readBits(2);
+    int edgeG = serviceBlockPacket.readBits(2);
+    int edgeB = serviceBlockPacket.readBits(2);
+    int edgeColor = CueBuilder.getArgbColorFromCeaColor(edgeR, edgeG, edgeB);
+
+    currentCueBuilder.setPenColor(foregroundColor, backgroundColor, edgeColor);
+  }
+
+  private void handleSetPenLocation() {
+    // the SetPenLocation command contains 2 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(4);
+    int row = serviceBlockPacket.readBits(4);
+    // second byte
+    serviceBlockPacket.skipBits(2);
+    int column = serviceBlockPacket.readBits(6);
+
+    currentCueBuilder.setPenLocation(row, column);
+  }
+
+  private void handleSetWindowAttributes() {
+    // the SetWindowAttributes command contains 4 bytes of data
+    // first byte
+    int fillO = serviceBlockPacket.readBits(2);
+    int fillR = serviceBlockPacket.readBits(2);
+    int fillG = serviceBlockPacket.readBits(2);
+    int fillB = serviceBlockPacket.readBits(2);
+    int fillColor = CueBuilder.getArgbColorFromCeaColor(fillR, fillG, fillB, fillO);
+    // second byte
+    int borderType = serviceBlockPacket.readBits(2); // only the lower 2 bits of borderType
+    int borderR = serviceBlockPacket.readBits(2);
+    int borderG = serviceBlockPacket.readBits(2);
+    int borderB = serviceBlockPacket.readBits(2);
+    int borderColor = CueBuilder.getArgbColorFromCeaColor(borderR, borderG, borderB);
+    // third byte
+    if (serviceBlockPacket.readBit()) {
+      borderType |= 0x04; // set the top bit of the 3-bit borderType
+    }
+    boolean wordWrapToggle = serviceBlockPacket.readBit();
+    int printDirection = serviceBlockPacket.readBits(2);
+    int scrollDirection = serviceBlockPacket.readBits(2);
+    int justification = serviceBlockPacket.readBits(2);
+    // fourth byte
+    // Note that we don't intend to support display effects
+    serviceBlockPacket.skipBits(8); // effectSpeed(4), effectDirection(2), displayEffect(2)
+
+    currentCueBuilder.setWindowAttributes(fillColor, borderColor, wordWrapToggle, borderType,
+        printDirection, scrollDirection, justification);
+  }
+
+  private void handleDefineWindow(int window) {
+    CueBuilder cueBuilder = cueBuilders[window];
+
+    // the DefineWindow command contains 6 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(2); // null padding
+    boolean visible = serviceBlockPacket.readBit();
+    boolean rowLock = serviceBlockPacket.readBit();
+    boolean columnLock = serviceBlockPacket.readBit();
+    int priority = serviceBlockPacket.readBits(3);
+    // second byte
+    boolean relativePositioning = serviceBlockPacket.readBit();
+    int verticalAnchor = serviceBlockPacket.readBits(7);
+    // third byte
+    int horizontalAnchor = serviceBlockPacket.readBits(8);
+    // fourth byte
+    int anchorId = serviceBlockPacket.readBits(4);
+    int rowCount = serviceBlockPacket.readBits(4);
+    // fifth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int columnCount = serviceBlockPacket.readBits(6);
+    // sixth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int windowStyle = serviceBlockPacket.readBits(3);
+    int penStyle = serviceBlockPacket.readBits(3);
+
+    cueBuilder.defineWindow(visible, rowLock, columnLock, priority, relativePositioning,
+        verticalAnchor, horizontalAnchor, rowCount, columnCount, anchorId, windowStyle, penStyle);
+  }
+
+  private List<Cue> getDisplayCues() {
+    List<Cea708Cue> displayCues = new ArrayList<>();
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      if (!cueBuilders[i].isEmpty() && cueBuilders[i].isVisible()) {
+        displayCues.add(cueBuilders[i].build());
+      }
+    }
+    Collections.sort(displayCues);
+    return Collections.<Cue>unmodifiableList(displayCues);
+  }
+
+  private void resetCueBuilders() {
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i].reset();
+    }
+  }
+
+  private static final class DtvCcPacket {
+
+    public final int sequenceNumber;
+    public final int packetSize;
+    public final byte[] packetData;
+
+    int currentIndex;
+
+    public DtvCcPacket(int sequenceNumber, int packetSize) {
+      this.sequenceNumber = sequenceNumber;
+      this.packetSize = packetSize;
+      packetData = new byte[2 * packetSize - 1];
+      currentIndex = 0;
+    }
+
+  }
+
+  // TODO: There is a lot of overlap between Cea708Decoder.CueBuilder and Cea608Decoder.CueBuilder
+  // which could be refactored into a separate class.
+  private static final class CueBuilder {
+
+    private static final int RELATIVE_CUE_SIZE = 99;
+    private static final int VERTICAL_SIZE = 74;
+    private static final int HORIZONTAL_SIZE = 209;
+
+    private static final int DEFAULT_PRIORITY = 4;
+
+    private static final int MAXIMUM_ROW_COUNT = 15;
+
+    private static final int JUSTIFICATION_LEFT = 0;
+    private static final int JUSTIFICATION_RIGHT = 1;
+    private static final int JUSTIFICATION_CENTER = 2;
+    private static final int JUSTIFICATION_FULL = 3;
+
+    private static final int DIRECTION_LEFT_TO_RIGHT = 0;
+    private static final int DIRECTION_RIGHT_TO_LEFT = 1;
+    private static final int DIRECTION_TOP_TO_BOTTOM = 2;
+    private static final int DIRECTION_BOTTOM_TO_TOP = 3;
+
+    // TODO: Add other border/edge types when utilized.
+    private static final int BORDER_AND_EDGE_TYPE_NONE = 0;
+    private static final int BORDER_AND_EDGE_TYPE_UNIFORM = 3;
+
+    public static final int COLOR_SOLID_WHITE = getArgbColorFromCeaColor(2, 2, 2, 0);
+    public static final int COLOR_SOLID_BLACK = getArgbColorFromCeaColor(0, 0, 0, 0);
+    public static final int COLOR_TRANSPARENT = getArgbColorFromCeaColor(0, 0, 0, 3);
+
+    // TODO: Add other sizes when utilized.
+    private static final int PEN_SIZE_STANDARD = 1;
+
+    // TODO: Add other pen font styles when utilized.
+    private static final int PEN_FONT_STYLE_DEFAULT = 0;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS = 1;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS = 2;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS = 3;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS = 4;
+
+    // TODO: Add other pen offsets when utilized.
+    private static final int PEN_OFFSET_NORMAL = 1;
+
+    // The window style properties are specified in the CEA-708 specification.
+    private static final int[] WINDOW_STYLE_JUSTIFICATION = new int[]{
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_LEFT,
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_CENTER,
+        JUSTIFICATION_LEFT
+    };
+    private static final int[] WINDOW_STYLE_PRINT_DIRECTION = new int[]{
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_TOP_TO_BOTTOM
+    };
+    private static final int[] WINDOW_STYLE_SCROLL_DIRECTION = new int[]{
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_RIGHT_TO_LEFT
+    };
+    private static final boolean[] WINDOW_STYLE_WORD_WRAP = new boolean[]{
+        false, false, false, true, true, true, false
+    };
+    private static final int[] WINDOW_STYLE_FILL = new int[]{
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK
+    };
+
+    // The pen style properties are specified in the CEA-708 specification.
+    private static final int[] PEN_STYLE_FONT_STYLE = new int[]{
+        PEN_FONT_STYLE_DEFAULT, PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS, PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS
+    };
+    private static final int[] PEN_STYLE_EDGE_TYPE = new int[]{
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE,
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_UNIFORM,
+        BORDER_AND_EDGE_TYPE_UNIFORM
+    };
+    private static final int[] PEN_STYLE_BACKGROUND = new int[]{
+        COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_TRANSPARENT};
+
+    private final List<SpannableString> rolledUpCaptions;
+    private final SpannableStringBuilder captionStringBuilder;
+
+    // Window/Cue properties
+    private boolean defined;
+    private boolean visible;
+    private int priority;
+    private boolean relativePositioning;
+    private int verticalAnchor;
+    private int horizontalAnchor;
+    private int anchorId;
+    private int rowCount;
+    private boolean rowLock;
+    private int justification;
+    private int windowStyleId;
+    private int penStyleId;
+    private int windowFillColor;
+
+    // Pen/Text properties
+    private int italicsStartPosition;
+    private int underlineStartPosition;
+    private int foregroundColorStartPosition;
+    private int foregroundColor;
+    private int backgroundColorStartPosition;
+    private int backgroundColor;
+
+    public CueBuilder() {
+      rolledUpCaptions = new LinkedList<>();
+      captionStringBuilder = new SpannableStringBuilder();
+      reset();
+    }
+
+    public boolean isEmpty() {
+      return !isDefined() || (rolledUpCaptions.isEmpty() && captionStringBuilder.length() == 0);
+    }
+
+    public void reset() {
+      clear();
+
+      defined = false;
+      visible = false;
+      priority = DEFAULT_PRIORITY;
+      relativePositioning = false;
+      verticalAnchor = 0;
+      horizontalAnchor = 0;
+      anchorId = 0;
+      rowCount = MAXIMUM_ROW_COUNT;
+      rowLock = true;
+      justification = JUSTIFICATION_LEFT;
+      windowStyleId = 0;
+      penStyleId = 0;
+      windowFillColor = COLOR_SOLID_BLACK;
+
+      foregroundColor = COLOR_SOLID_WHITE;
+      backgroundColor = COLOR_SOLID_BLACK;
+    }
+
+    public void clear() {
+      rolledUpCaptions.clear();
+      captionStringBuilder.clear();
+      italicsStartPosition = C.POSITION_UNSET;
+      underlineStartPosition = C.POSITION_UNSET;
+      foregroundColorStartPosition = C.POSITION_UNSET;
+      backgroundColorStartPosition = C.POSITION_UNSET;
+    }
+
+    public boolean isDefined() {
+      return defined;
+    }
+
+    public void setVisibility(boolean visible) {
+      this.visible = visible;
+    }
+
+    public boolean isVisible() {
+      return visible;
+    }
+
+    public void defineWindow(boolean visible, boolean rowLock, boolean columnLock, int priority,
+        boolean relativePositioning, int verticalAnchor, int horizontalAnchor, int rowCount,
+        int columnCount, int anchorId, int windowStyleId, int penStyleId) {
+      this.defined = true;
+      this.visible = visible;
+      this.rowLock = rowLock;
+      this.priority = priority;
+      this.relativePositioning = relativePositioning;
+      this.verticalAnchor = verticalAnchor;
+      this.horizontalAnchor = horizontalAnchor;
+      this.anchorId = anchorId;
+
+      // Decoders must add one to rowCount to get the desired number of rows.
+      if (this.rowCount != rowCount + 1) {
+        this.rowCount = rowCount + 1;
+
+        // Trim any rolled up captions that are no longer valid, if applicable.
+        while ((rowLock && (rolledUpCaptions.size() >= this.rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      }
+
+      // TODO: Add support for column lock and count.
+
+      if (windowStyleId != 0 && this.windowStyleId != windowStyleId) {
+        this.windowStyleId = windowStyleId;
+        // windowStyleId is 1-based.
+        int windowStyleIdIndex = windowStyleId - 1;
+        // Note that Border type and border color are the same for all window styles.
+        setWindowAttributes(WINDOW_STYLE_FILL[windowStyleIdIndex], COLOR_TRANSPARENT,
+            WINDOW_STYLE_WORD_WRAP[windowStyleIdIndex], BORDER_AND_EDGE_TYPE_NONE,
+            WINDOW_STYLE_PRINT_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_SCROLL_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_JUSTIFICATION[windowStyleIdIndex]);
+      }
+
+      if (penStyleId != 0 && this.penStyleId != penStyleId) {
+        this.penStyleId = penStyleId;
+        // penStyleId is 1-based.
+        int penStyleIdIndex = penStyleId - 1;
+        // Note that pen size, offset, italics, underline, foreground color, and foreground
+        // opacity are the same for all pen styles.
+        setPenAttributes(0, PEN_OFFSET_NORMAL, PEN_SIZE_STANDARD, false, false,
+            PEN_STYLE_EDGE_TYPE[penStyleIdIndex], PEN_STYLE_FONT_STYLE[penStyleIdIndex]);
+        setPenColor(COLOR_SOLID_WHITE, PEN_STYLE_BACKGROUND[penStyleIdIndex], COLOR_SOLID_BLACK);
+      }
+    }
+
+
+    public void setWindowAttributes(int fillColor, int borderColor, boolean wordWrapToggle,
+        int borderType, int printDirection, int scrollDirection, int justification) {
+      this.windowFillColor = fillColor;
+      // TODO: Add support for border color and types.
+      // TODO: Add support for word wrap.
+      // TODO: Add support for other scroll directions.
+      // TODO: Add support for other print directions.
+      this.justification = justification;
+
+    }
+
+    public void setPenAttributes(int textTag, int offset, int penSize, boolean italicsToggle,
+        boolean underlineToggle, int edgeType, int fontStyle) {
+      // TODO: Add support for text tags.
+      // TODO: Add support for other offsets.
+      // TODO: Add support for other pen sizes.
+
+      if (italicsStartPosition != C.POSITION_UNSET) {
+        if (!italicsToggle) {
+          captionStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          italicsStartPosition = C.POSITION_UNSET;
+        }
+      } else if (italicsToggle) {
+        italicsStartPosition = captionStringBuilder.length();
+      }
+
+      if (underlineStartPosition != C.POSITION_UNSET) {
+        if (!underlineToggle) {
+          captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          underlineStartPosition = C.POSITION_UNSET;
+        }
+      } else if (underlineToggle) {
+        underlineStartPosition = captionStringBuilder.length();
+      }
+
+      // TODO: Add support for edge types.
+      // TODO: Add support for other font styles.
+    }
+
+    public void setPenColor(int foregroundColor, int backgroundColor, int edgeColor) {
+      if (foregroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.foregroundColor != foregroundColor) {
+          captionStringBuilder.setSpan(new ForegroundColorSpan(this.foregroundColor),
+              foregroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (foregroundColor != COLOR_SOLID_WHITE) {
+        foregroundColorStartPosition = captionStringBuilder.length();
+        this.foregroundColor = foregroundColor;
+      }
+
+      if (backgroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.backgroundColor != backgroundColor) {
+          captionStringBuilder.setSpan(new BackgroundColorSpan(this.backgroundColor),
+              backgroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (backgroundColor != COLOR_SOLID_BLACK) {
+        backgroundColorStartPosition = captionStringBuilder.length();
+        this.backgroundColor = backgroundColor;
+      }
+
+      // TODO: Add support for edge color.
+    }
+
+    public void setPenLocation(int row, int column) {
+      // TODO: Support moving the pen location with a window.
+    }
+
+    public void backspace() {
+      int length = captionStringBuilder.length();
+      if (length > 0) {
+        captionStringBuilder.delete(length - 1, length);
+      }
+    }
+
+    public void append(char text) {
+      if (text == '\n') {
+        rolledUpCaptions.add(buildSpannableString());
+        captionStringBuilder.clear();
+
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          italicsStartPosition = 0;
+        }
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          underlineStartPosition = 0;
+        }
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          foregroundColorStartPosition = 0;
+        }
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          backgroundColorStartPosition = 0;
+        }
+
+        while ((rowLock && (rolledUpCaptions.size() >= rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      } else {
+        captionStringBuilder.append(text);
+      }
+    }
+
+    public SpannableString buildSpannableString() {
+      SpannableStringBuilder spannableStringBuilder =
+          new SpannableStringBuilder(captionStringBuilder);
+      int length = spannableStringBuilder.length();
+
+      if (length > 0) {
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new ForegroundColorSpan(foregroundColor),
+              foregroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new BackgroundColorSpan(backgroundColor),
+              backgroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+
+      return new SpannableString(spannableStringBuilder);
+    }
+
+    public Cea708Cue build() {
+      if (isEmpty()) {
+        // The cue is empty.
+        return null;
+      }
+
+      SpannableStringBuilder cueString = new SpannableStringBuilder();
+
+      // Add any rolled up captions, separated by new lines.
+      for (int i = 0; i < rolledUpCaptions.size(); i++) {
+        cueString.append(rolledUpCaptions.get(i));
+        cueString.append('\n');
+      }
+      // Add the current line.
+      cueString.append(buildSpannableString());
+
+      // TODO: Add support for right-to-left languages (i.e. where right would correspond to normal
+      // alignment).
+      Alignment alignment;
+      switch (justification) {
+        case JUSTIFICATION_FULL:
+          // TODO: Add support for full justification.
+        case JUSTIFICATION_LEFT:
+          alignment = Alignment.ALIGN_NORMAL;
+          break;
+        case JUSTIFICATION_RIGHT:
+          alignment = Alignment.ALIGN_OPPOSITE;
+          break;
+        case JUSTIFICATION_CENTER:
+          alignment = Alignment.ALIGN_CENTER;
+          break;
+        default:
+          throw new IllegalArgumentException("Unexpected justification value: " + justification);
+      }
+
+      float position;
+      float line;
+      if (relativePositioning) {
+        position = (float) horizontalAnchor / RELATIVE_CUE_SIZE;
+        line = (float) verticalAnchor / RELATIVE_CUE_SIZE;
+      } else {
+        position = (float) horizontalAnchor / HORIZONTAL_SIZE;
+        line = (float) verticalAnchor / VERTICAL_SIZE;
+      }
+      // Apply screen-edge padding to the line and position.
+      position = (position * 0.9f) + 0.05f;
+      line = (line * 0.9f) + 0.05f;
+
+      // anchorId specifies where the anchor should be placed on the caption cue/window. The 9
+      // possible configurations are as follows:
+      //   0-----1-----2
+      //   |           |
+      //   3     4     5
+      //   |           |
+      //   6-----7-----8
+      @AnchorType int verticalAnchorType;
+      if (anchorId % 3 == 0) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId % 3 == 1) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        verticalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+      // TODO: Add support for right-to-left languages (i.e. where start is on the right).
+      @AnchorType int horizontalAnchorType;
+      if (anchorId / 3 == 0) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId / 3 == 1) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+
+      boolean windowColorSet = (windowFillColor != COLOR_SOLID_BLACK);
+
+      return new Cea708Cue(cueString, alignment, line, Cue.LINE_TYPE_FRACTION, verticalAnchorType,
+          position, horizontalAnchorType, Cue.DIMEN_UNSET, windowColorSet, windowFillColor,
+          priority);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue) {
+      return getArgbColorFromCeaColor(red, green, blue, 0);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue, int opacity) {
+      Assertions.checkIndex(red, 0, 4);
+      Assertions.checkIndex(green, 0, 4);
+      Assertions.checkIndex(blue, 0, 4);
+      Assertions.checkIndex(opacity, 0, 4);
+
+      int alpha;
+      switch (opacity) {
+        case 0:
+        case 1:
+          // Note the value of '1' is actually FLASH, but we don't support that.
+          alpha = 255;
+          break;
+        case 2:
+          alpha = 127;
+          break;
+        case 3:
+          alpha = 0;
+          break;
+        default:
+          alpha = 255;
+      }
+
+      // TODO: Add support for the Alternative Minimum Color List or the full 64 RGB combinations.
+
+      // Return values based on the Minimum Color List
+      return Color.argb(alpha,
+          (red > 1 ? 255 : 0),
+          (green > 1 ? 255 : 0),
+          (blue > 1 ? 255 : 0));
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
index ae92d7fab8..f479050d57 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.text.cea;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
@@ -109,7 +110,7 @@ public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderExceptio
         Subtitle subtitle = createSubtitle();
         if (!inputBuffer.isDecodeOnly()) {
           SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
-          outputBuffer.setContent(inputBuffer.timeUs, subtitle, 0);
+          outputBuffer.setContent(inputBuffer.timeUs, subtitle, Format.OFFSET_SAMPLE_RELATIVE);
           releaseInputBuffer(inputBuffer);
           return outputBuffer;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
index 5becefe106..7da2054a08 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.util.Assertions;
 import java.util.Collections;
 import java.util.List;
 
@@ -28,19 +30,15 @@
   private final List<Cue> cues;
 
   /**
-   * @param cue The subtitle cue.
+   * @param cues The subtitle cues.
    */
-  public CeaSubtitle(Cue cue) {
-    if (cue == null) {
-      cues = Collections.emptyList();
-    } else {
-      cues = Collections.singletonList(cue);
-    }
+  public CeaSubtitle(List<Cue> cues) {
+    this.cues = cues;
   }
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    return 0;
+    return timeUs < 0 ? 0 : C.INDEX_UNSET;
   }
 
   @Override
@@ -50,13 +48,13 @@ public int getEventTimeCount() {
 
   @Override
   public long getEventTime(int index) {
+    Assertions.checkArgument(index == 0);
     return 0;
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return cues;
-
+    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
new file mode 100644
index 0000000000..3053debfcf
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/**
+ * Utility methods for handling CEA-608/708 messages.
+ */
+public final class CeaUtil {
+
+  private static final int PAYLOAD_TYPE_CC = 4;
+  private static final int COUNTRY_CODE = 0xB5;
+  private static final int PROVIDER_CODE = 0x31;
+  private static final int USER_ID = 0x47413934; // "GA94"
+  private static final int USER_DATA_TYPE_CODE = 0x3;
+
+  /**
+   * Consumes the unescaped content of an SEI NAL unit, writing the content of any CEA-608 messages
+   * as samples to the provided output.
+   *
+   * @param presentationTimeUs The presentation time in microseconds for any samples.
+   * @param seiBuffer The unescaped SEI NAL unit data, excluding the NAL unit start code and type.
+   * @param output The output to which any samples should be written.
+   */
+  public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
+      TrackOutput output) {
+    int b;
+    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
+      // Parse payload type.
+      int payloadType = 0;
+      do {
+        b = seiBuffer.readUnsignedByte();
+        payloadType += b;
+      } while (b == 0xFF);
+      // Parse payload size.
+      int payloadSize = 0;
+      do {
+        b = seiBuffer.readUnsignedByte();
+        payloadSize += b;
+      } while (b == 0xFF);
+      // Process the payload.
+      if (isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
+        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
+        // + user_data_type_code (1).
+        seiBuffer.skipBytes(8);
+        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
+        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
+        // Ignore em_data (1)
+        seiBuffer.skipBytes(1);
+        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
+        // + cc_data_1 (8) + cc_data_2 (8).
+        int sampleLength = ccCount * 3;
+        output.sampleData(seiBuffer, sampleLength);
+        output.sampleMetadata(presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
+        // Ignore trailing information in SEI, if any.
+        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
+      } else {
+        seiBuffer.skipBytes(payloadSize);
+      }
+    }
+  }
+
+  /**
+   * Inspects an sei message to determine whether it contains CEA-608.
+   * <p>
+   * The position of {@code payload} is left unchanged.
+   *
+   * @param payloadType The payload type of the message.
+   * @param payloadLength The length of the payload.
+   * @param payload A {@link ParsableByteArray} containing the payload.
+   * @return Whether the sei message contains CEA-608.
+   */
+  private static boolean isSeiMessageCea608(int payloadType, int payloadLength,
+      ParsableByteArray payload) {
+    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
+      return false;
+    }
+    int startPosition = payload.getPosition();
+    int countryCode = payload.readUnsignedByte();
+    int providerCode = payload.readUnsignedShort();
+    int userIdentifier = payload.readInt();
+    int userDataTypeCode = payload.readUnsignedByte();
+    payload.setPosition(startPosition);
+    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
+        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
+  }
+
+  private CeaUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
index 43a93353c3..a848022ba9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/subrip/SubripDecoder.java
@@ -34,9 +34,9 @@
 
   private static final String TAG = "SubripDecoder";
 
-  private static final Pattern SUBRIP_TIMING_LINE = Pattern.compile("(\\S*)\\s*-->\\s*(\\S*)");
-  private static final Pattern SUBRIP_TIMESTAMP =
-      Pattern.compile("(?:(\\d+):)?(\\d+):(\\d+),(\\d+)");
+  private static final String SUBRIP_TIMECODE = "(?:(\\d+):)?(\\d+):(\\d+),(\\d+)";
+  private static final Pattern SUBRIP_TIMING_LINE =
+      Pattern.compile("\\s*(" + SUBRIP_TIMECODE + ")\\s*-->\\s*(" + SUBRIP_TIMECODE + ")?\\s*");
 
   private final StringBuilder textBuilder;
 
@@ -50,7 +50,6 @@ protected SubripSubtitle decode(byte[] bytes, int length) {
     ArrayList<Cue> cues = new ArrayList<>();
     LongArray cueTimesUs = new LongArray();
     ParsableByteArray subripData = new ParsableByteArray(bytes, length);
-    boolean haveEndTimecode;
     String currentLine;
 
     while ((currentLine = subripData.readLine()) != null) {
@@ -68,15 +67,14 @@ protected SubripSubtitle decode(byte[] bytes, int length) {
       }
 
       // Read and parse the timing line.
-      haveEndTimecode = false;
+      boolean haveEndTimecode = false;
       currentLine = subripData.readLine();
       Matcher matcher = SUBRIP_TIMING_LINE.matcher(currentLine);
-      if (matcher.find()) {
-        cueTimesUs.add(parseTimecode(matcher.group(1)));
-        String endTimecode = matcher.group(2);
-        if (!TextUtils.isEmpty(endTimecode)) {
+      if (matcher.matches()) {
+        cueTimesUs.add(parseTimecode(matcher, 1));
+        if (!TextUtils.isEmpty(matcher.group(6))) {
           haveEndTimecode = true;
-          cueTimesUs.add(parseTimecode(matcher.group(2)));
+          cueTimesUs.add(parseTimecode(matcher, 6));
         }
       } else {
         Log.w(TAG, "Skipping invalid timing: " + currentLine);
@@ -105,15 +103,11 @@ protected SubripSubtitle decode(byte[] bytes, int length) {
     return new SubripSubtitle(cuesArray, cueTimesUsArray);
   }
 
-  private static long parseTimecode(String s) throws NumberFormatException {
-    Matcher matcher = SUBRIP_TIMESTAMP.matcher(s);
-    if (!matcher.matches()) {
-      throw new NumberFormatException("has invalid format");
-    }
-    long timestampMs = Long.parseLong(matcher.group(1)) * 60 * 60 * 1000;
-    timestampMs += Long.parseLong(matcher.group(2)) * 60 * 1000;
-    timestampMs += Long.parseLong(matcher.group(3)) * 1000;
-    timestampMs += Long.parseLong(matcher.group(4));
+  private static long parseTimecode(Matcher matcher, int groupOffset) {
+    long timestampMs = Long.parseLong(matcher.group(groupOffset + 1)) * 60 * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 2)) * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 3)) * 1000;
+    timestampMs += Long.parseLong(matcher.group(groupOffset + 4));
     return timestampMs * 1000;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtil.java b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtil.java
index bb89b05603..21333081c6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtil.java
@@ -92,21 +92,22 @@ public static void applyStylesToSpan(SpannableStringBuilder builder,
       builder.setSpan(new AlignmentSpan.Standard(style.getTextAlign()), start, end,
           Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
-    if (style.getFontSizeUnit() != TtmlStyle.UNSPECIFIED) {
-      switch (style.getFontSizeUnit()) {
-        case TtmlStyle.FONT_SIZE_UNIT_PIXEL:
-          builder.setSpan(new AbsoluteSizeSpan((int) style.getFontSize(), true), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-        case TtmlStyle.FONT_SIZE_UNIT_EM:
-          builder.setSpan(new RelativeSizeSpan(style.getFontSize()), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-        case TtmlStyle.FONT_SIZE_UNIT_PERCENT:
-          builder.setSpan(new RelativeSizeSpan(style.getFontSize() / 100), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-      }
+    switch (style.getFontSizeUnit()) {
+      case TtmlStyle.FONT_SIZE_UNIT_PIXEL:
+        builder.setSpan(new AbsoluteSizeSpan((int) style.getFontSize(), true), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case TtmlStyle.FONT_SIZE_UNIT_EM:
+        builder.setSpan(new RelativeSizeSpan(style.getFontSize()), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case TtmlStyle.FONT_SIZE_UNIT_PERCENT:
+        builder.setSpan(new RelativeSizeSpan(style.getFontSize() / 100), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case TtmlStyle.UNSPECIFIED:
+        // Do nothing.
+        break;
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
index b7345e0b5f..932d4a6bed 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
@@ -256,7 +256,13 @@ private static void parseLineAttribute(String s, WebvttCue.Builder builder)
     if (s.endsWith("%")) {
       builder.setLine(WebvttParserUtil.parsePercentage(s)).setLineType(Cue.LINE_TYPE_FRACTION);
     } else {
-      builder.setLine(Integer.parseInt(s)).setLineType(Cue.LINE_TYPE_NUMBER);
+      int lineNumber = Integer.parseInt(s);
+      if (lineNumber < 0) {
+        // WebVTT defines line -1 as last visible row when lineAnchor is ANCHOR_TYPE_START, where-as
+        // Cue defines it to be the first row that's not visible.
+        lineNumber--;
+      }
+      builder.setLine(lineNumber).setLineType(Cue.LINE_TYPE_NUMBER);
     }
   }
 
@@ -413,21 +419,22 @@ private static void applyStyleToText(SpannableStringBuilder spannedText, WebvttC
       spannedText.setSpan(new AlignmentSpan.Standard(style.getTextAlign()), start, end,
           Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
-    if (style.getFontSizeUnit() != WebvttCssStyle.UNSPECIFIED) {
-      switch (style.getFontSizeUnit()) {
-        case WebvttCssStyle.FONT_SIZE_UNIT_PIXEL:
-          spannedText.setSpan(new AbsoluteSizeSpan((int) style.getFontSize(), true), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-        case WebvttCssStyle.FONT_SIZE_UNIT_EM:
-          spannedText.setSpan(new RelativeSizeSpan(style.getFontSize()), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-        case WebvttCssStyle.FONT_SIZE_UNIT_PERCENT:
-          spannedText.setSpan(new RelativeSizeSpan(style.getFontSize() / 100), start, end,
-              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-          break;
-      }
+    switch (style.getFontSizeUnit()) {
+      case WebvttCssStyle.FONT_SIZE_UNIT_PIXEL:
+        spannedText.setSpan(new AbsoluteSizeSpan((int) style.getFontSize(), true), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case WebvttCssStyle.FONT_SIZE_UNIT_EM:
+        spannedText.setSpan(new RelativeSizeSpan(style.getFontSize()), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case WebvttCssStyle.FONT_SIZE_UNIT_PERCENT:
+        spannedText.setSpan(new RelativeSizeSpan(style.getFontSize() / 100), start, end,
+            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        break;
+      case WebvttCssStyle.UNSPECIFIED:
+        // Do nothing.
+        break;
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 81d79ac055..f62d5d9075 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -17,7 +17,6 @@
 
 import android.content.Context;
 import android.graphics.Point;
-import android.os.Handler;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -56,6 +55,7 @@
     public final int maxVideoWidth;
     public final int maxVideoHeight;
     public final boolean exceedVideoConstraintsIfNecessary;
+    public final boolean exceedRendererCapabilitiesIfNecessary;
     public final int viewportWidth;
     public final int viewportHeight;
     public final boolean orientationMayChange;
@@ -68,13 +68,14 @@
      *   <li>Adaptation between different mime types is not allowed.</li>
      *   <li>Non seamless adaptation is allowed.</li>
      *   <li>No max limit for video width/height.</li>
-     *   <li>Video constraints are ignored if no supported selection can be made otherwise.</li>
+     *   <li>Video constraints are exceeded if no supported selection can be made otherwise.</li>
+     *   <li>Renderer capabilities are exceeded if no supported selection can be made.</li>
      *   <li>No viewport width/height constraints are set.</li>
      * </ul>
      */
     public Parameters() {
-      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, Integer.MAX_VALUE,
-          Integer.MAX_VALUE, true);
+      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, true,
+          Integer.MAX_VALUE, Integer.MAX_VALUE, true);
     }
 
     /**
@@ -87,8 +88,10 @@ public Parameters() {
      * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
      * @param maxVideoWidth Maximum allowed video width.
      * @param maxVideoHeight Maximum allowed video height.
-     * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
-     *     can be made otherwise. False to force constraints anyway.
+     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
+     *     selection can be made otherwise.
+     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
+     *     selection can be made otherwise.
      * @param viewportWidth Viewport width in pixels.
      * @param viewportHeight Viewport height in pixels.
      * @param orientationMayChange Whether orientation may change during playback.
@@ -96,7 +99,8 @@ public Parameters() {
     public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
         boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
         int maxVideoWidth, int maxVideoHeight, boolean exceedVideoConstraintsIfNecessary,
-        int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+        boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
+        boolean orientationMayChange) {
       this.preferredAudioLanguage = preferredAudioLanguage;
       this.preferredTextLanguage = preferredTextLanguage;
       this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
@@ -104,6 +108,7 @@ public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
       this.maxVideoWidth = maxVideoWidth;
       this.maxVideoHeight = maxVideoHeight;
       this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
       this.viewportWidth = viewportWidth;
       this.viewportHeight = viewportHeight;
       this.orientationMayChange = orientationMayChange;
@@ -125,7 +130,8 @@ public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight, orientationMayChange);
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -141,9 +147,9 @@ public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -157,9 +163,9 @@ public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiven
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -173,9 +179,9 @@ public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdapt
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -190,9 +196,9 @@ public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -217,8 +223,8 @@ public Parameters withoutVideoSizeConstraints() {
      * Returns a {@link Parameters} instance with the provided
      * {@code exceedVideoConstraintsIfNecessary} value.
      *
-     * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
-     *     can be made otherwise. False to force constraints anyway.
+     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
+     *     selection can be made otherwise.
      * @return A {@link Parameters} instance with the provided
      *     {@code exceedVideoConstraintsIfNecessary} value.
      */
@@ -228,9 +234,29 @@ public Parameters withExceedVideoConstraintsIfNecessary(
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided
+     * {@code exceedRendererCapabilitiesIfNecessary} value.
+     *
+     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
+     *     selection can be made otherwise.
+     * @return A {@link Parameters} instance with the provided
+     *     {@code exceedRendererCapabilitiesIfNecessary} value.
+     */
+    public Parameters withExceedRendererCapabilitiesIfNecessary(
+        boolean exceedRendererCapabilitiesIfNecessary) {
+      if (exceedRendererCapabilitiesIfNecessary == this.exceedRendererCapabilitiesIfNecessary) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -248,9 +274,9 @@ public Parameters withViewportSize(int viewportWidth, int viewportHeight,
         return this;
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
-          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
-          orientationMayChange);
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+          viewportHeight, orientationMayChange);
     }
 
     /**
@@ -290,6 +316,7 @@ public boolean equals(Object obj) {
           && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
           && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
           && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
+          && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
           && orientationMayChange == other.orientationMayChange
           && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
           && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
@@ -305,6 +332,7 @@ public int hashCode() {
       result = 31 * result + maxVideoWidth;
       result = 31 * result + maxVideoHeight;
       result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
+      result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
       result = 31 * result + (orientationMayChange ? 1 : 0);
       result = 31 * result + viewportWidth;
       result = 31 * result + viewportHeight;
@@ -320,33 +348,27 @@ public int hashCode() {
    */
   private static final float FRACTION_TO_CONSIDER_FULLSCREEN = 0.98f;
   private static final int[] NO_TRACKS = new int[0];
+  private static final int WITHIN_RENDERER_CAPABILITIES_BONUS = 1000;
 
   private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
-  private final AtomicReference<Parameters> params;
+  private final AtomicReference<Parameters> paramsReference;
 
   /**
    * Constructs an instance that does not support adaptive video.
-   *
-   * @param eventHandler A handler to use when delivering events to listeners. May be null if
-   *     listeners will not be added.
    */
-  public DefaultTrackSelector(Handler eventHandler) {
-    this(eventHandler, null);
+  public DefaultTrackSelector() {
+    this(null);
   }
 
   /**
    * Constructs an instance that uses a factory to create adaptive video track selections.
    *
-   * @param eventHandler A handler to use when delivering events to listeners. May be null if
-   *     listeners will not be added.
    * @param adaptiveVideoTrackSelectionFactory A factory for adaptive video {@link TrackSelection}s,
    *     or null if the selector should not support adaptive video.
    */
-  public DefaultTrackSelector(Handler eventHandler,
-      TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
-    super(eventHandler);
+  public DefaultTrackSelector(TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
     this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
-    params = new AtomicReference<>(new Parameters());
+    paramsReference = new AtomicReference<>(new Parameters());
   }
 
   /**
@@ -355,8 +377,8 @@ public DefaultTrackSelector(Handler eventHandler,
    * @param params The parameters for track selection.
    */
   public void setParameters(Parameters params) {
-    if (!this.params.get().equals(params)) {
-      this.params.set(Assertions.checkNotNull(params));
+    Assertions.checkNotNull(params);
+    if (!paramsReference.getAndSet(params).equals(params)) {
       invalidate();
     }
   }
@@ -367,7 +389,7 @@ public void setParameters(Parameters params) {
    * @return The current selection parameters.
    */
   public Parameters getParameters() {
-    return params.get();
+    return paramsReference.get();
   }
 
   // MappingTrackSelector implementation.
@@ -378,7 +400,7 @@ public Parameters getParameters() {
       throws ExoPlaybackException {
     // Make a track selection for each renderer.
     TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
-    Parameters params = this.params.get();
+    Parameters params = paramsReference.get();
     for (int i = 0; i < rendererCapabilities.length; i++) {
       switch (rendererCapabilities[i].getTrackType()) {
         case C.TRACK_TYPE_VIDEO:
@@ -387,20 +409,23 @@ public Parameters getParameters() {
               params.maxVideoHeight, params.allowNonSeamlessAdaptiveness,
               params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
               params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
-              params.exceedVideoConstraintsIfNecessary);
+              params.exceedVideoConstraintsIfNecessary,
+              params.exceedRendererCapabilitiesIfNecessary);
           break;
         case C.TRACK_TYPE_AUDIO:
           rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
-              rendererFormatSupports[i], params.preferredAudioLanguage);
+              rendererFormatSupports[i], params.preferredAudioLanguage,
+              params.exceedRendererCapabilitiesIfNecessary);
           break;
         case C.TRACK_TYPE_TEXT:
           rendererTrackSelections[i] = selectTextTrack(rendererTrackGroupArrays[i],
               rendererFormatSupports[i], params.preferredTextLanguage,
-              params.preferredAudioLanguage);
+              params.preferredAudioLanguage, params.exceedRendererCapabilitiesIfNecessary);
           break;
         default:
           rendererTrackSelections[i] = selectOtherTrack(rendererCapabilities[i].getTrackType(),
-              rendererTrackGroupArrays[i], rendererFormatSupports[i]);
+              rendererTrackGroupArrays[i], rendererFormatSupports[i],
+              params.exceedRendererCapabilitiesIfNecessary);
           break;
       }
     }
@@ -414,7 +439,8 @@ protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilit
       boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
       int viewportHeight, boolean orientationMayChange,
       TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
-      boolean exceedConstraintsIfNecessary) throws ExoPlaybackException {
+      boolean exceedConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary)
+      throws ExoPlaybackException {
     TrackSelection selection = null;
     if (adaptiveVideoTrackSelectionFactory != null) {
       selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
@@ -424,7 +450,8 @@ protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilit
     }
     if (selection == null) {
       selection = selectFixedVideoTrack(groups, formatSupport, maxVideoWidth, maxVideoHeight,
-          viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary);
+          viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary,
+          exceedRendererCapabilitiesIfNecessary);
     }
     return selection;
   }
@@ -520,7 +547,7 @@ private static void filterAdaptiveTrackCountForMimeType(TrackGroup group, int[]
 
   private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeType,
       int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight) {
-    return isSupported(formatSupport) && ((formatSupport & requiredAdaptiveSupport) != 0)
+    return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)
         && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
         && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
         && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
@@ -528,37 +555,53 @@ private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeT
 
   private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
       int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary) {
+      int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary,
+      boolean exceedRendererCapabilitiesIfNecessary) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
+    int selectedTrackScore = 0;
+    int selectedBitrate = Format.NO_VALUE;
     int selectedPixelCount = Format.NO_VALUE;
-    boolean selectedIsWithinConstraints = false;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
-      TrackGroup group = groups.get(groupIndex);
-      List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(group, viewportWidth,
-          viewportHeight, orientationMayChange);
+      TrackGroup trackGroup = groups.get(groupIndex);
+      List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(trackGroup,
+          viewportWidth, viewportHeight, orientationMayChange);
       int[] trackFormatSupport = formatSupport[groupIndex];
-      for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex])) {
-          Format format = group.getFormat(trackIndex);
+      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
+          Format format = trackGroup.getFormat(trackIndex);
           boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
               && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
               && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
-          int pixelCount = format.getPixelCount();
-          boolean selectTrack;
-          if (selectedIsWithinConstraints) {
-            selectTrack = isWithinConstraints
-                && comparePixelCounts(pixelCount, selectedPixelCount) > 0;
-          } else {
-            selectTrack = isWithinConstraints || (exceedConstraintsIfNecessary
-                && (selectedGroup == null
-                || comparePixelCounts(pixelCount, selectedPixelCount) < 0));
+          if (!isWithinConstraints && !exceedConstraintsIfNecessary) {
+            // Track should not be selected.
+            continue;
+          }
+          int trackScore = isWithinConstraints ? 2 : 1;
+          if (isSupported(trackFormatSupport[trackIndex], false)) {
+            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+          }
+          boolean selectTrack = trackScore > selectedTrackScore;
+          if (trackScore == selectedTrackScore) {
+            // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If we're
+            // within constraints prefer a higher pixel count (or bitrate), else prefer a lower
+            // count (or bitrate). If still tied then prefer the first track (i.e. the one that's
+            // already selected).
+            int comparisonResult;
+            int formatPixelCount = format.getPixelCount();
+            if (formatPixelCount != selectedPixelCount) {
+              comparisonResult = compareFormatValues(format.getPixelCount(), selectedPixelCount);
+            } else {
+              comparisonResult = compareFormatValues(format.bitrate, selectedBitrate);
+            }
+            selectTrack = isWithinConstraints ? comparisonResult > 0 : comparisonResult < 0;
           }
           if (selectTrack) {
-            selectedGroup = group;
+            selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
-            selectedPixelCount = pixelCount;
-            selectedIsWithinConstraints = isWithinConstraints;
+            selectedTrackScore = trackScore;
+            selectedBitrate = format.bitrate;
+            selectedPixelCount = format.getPixelCount();
           }
         }
       }
@@ -568,24 +611,23 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
   }
 
   /**
-   * Compares two pixel counts for order. A known pixel count is considered greater than
+   * Compares two format values for order. A known value is considered greater than
    * {@link Format#NO_VALUE}.
    *
-   * @param first The first pixel count.
-   * @param second The second pixel count.
-   * @return A negative integer if the first pixel count is less than the second. Zero if they are
-   *     equal. A positive integer if the first pixel count is greater than the second.
+   * @param first The first value.
+   * @param second The second value.
+   * @return A negative integer if the first value is less than the second. Zero if they are equal.
+   *     A positive integer if the first value is greater than the second.
    */
-  private static int comparePixelCounts(int first, int second) {
+  private static int compareFormatValues(int first, int second) {
     return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
         : (second == Format.NO_VALUE ? 1 : (first - second));
   }
 
-
   // Audio track selection implementation.
 
   protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
-      String preferredAudioLanguage) {
+      String preferredAudioLanguage, boolean exceedRendererCapabilitiesIfNecessary) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
@@ -593,7 +635,7 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
       TrackGroup trackGroup = groups.get(groupIndex);
       int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex])) {
+        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
           boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           int trackScore;
@@ -608,6 +650,9 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
           } else {
             trackScore = 1;
           }
+          if (isSupported(trackFormatSupport[trackIndex], false)) {
+            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+          }
           if (trackScore > selectedTrackScore) {
             selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
@@ -623,7 +668,8 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
   // Text track selection implementation.
 
   protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatSupport,
-      String preferredTextLanguage, String preferredAudioLanguage) {
+      String preferredTextLanguage, String preferredAudioLanguage,
+      boolean exceedRendererCapabilitiesIfNecessary) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
@@ -631,7 +677,7 @@ protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatS
       TrackGroup trackGroup = groups.get(groupIndex);
       int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex])) {
+        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
           boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           boolean isForced = (format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0;
@@ -656,7 +702,11 @@ protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatS
               trackScore = 1;
             }
           } else {
-            trackScore = 0;
+            // Track should not be selected.
+            continue;
+          }
+          if (isSupported(trackFormatSupport[trackIndex], false)) {
+            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
           }
           if (trackScore > selectedTrackScore) {
             selectedGroup = trackGroup;
@@ -673,7 +723,7 @@ protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatS
   // General track selection methods.
 
   protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
-      int[][] formatSupport) {
+      int[][] formatSupport, boolean exceedRendererCapabilitiesIfNecessary) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
@@ -681,10 +731,13 @@ protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
       TrackGroup trackGroup = groups.get(groupIndex);
       int[] trackFormatSupport = formatSupport[groupIndex];
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex])) {
+        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
           boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           int trackScore = isDefault ? 2 : 1;
+          if (isSupported(trackFormatSupport[trackIndex], false)) {
+            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+          }
           if (trackScore > selectedTrackScore) {
             selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
@@ -697,12 +750,13 @@ protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
         : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
   }
 
-  private static boolean isSupported(int formatSupport) {
-    return (formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK)
-        == RendererCapabilities.FORMAT_HANDLED;
+  protected static boolean isSupported(int formatSupport, boolean allowExceedsCapabilities) {
+    int maskedSupport = formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK;
+    return maskedSupport == RendererCapabilities.FORMAT_HANDLED || (allowExceedsCapabilities
+        && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
   }
 
-  private static boolean formatHasLanguage(Format format, String language) {
+  protected static boolean formatHasLanguage(Format format, String language) {
     return language != null && language.equals(Util.normalizeLanguageCode(format.language));
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 3826ee4668..690723cf15 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -15,14 +15,15 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.os.Handler;
+import android.content.Context;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -32,7 +33,7 @@
  * Base class for {@link TrackSelector}s that first establish a mapping between {@link TrackGroup}s
  * and renderers, and then from that mapping create a {@link TrackSelection} for each renderer.
  */
-public abstract class MappingTrackSelector extends TrackSelector<MappedTrackInfo> {
+public abstract class MappingTrackSelector extends TrackSelector {
 
   /**
    * A track selection override.
@@ -70,8 +71,8 @@ public TrackSelection createTrackSelection(TrackGroupArray groups) {
      * Returns whether this override contains the specified track index.
      */
     public boolean containsTrack(int track) {
-      for (int i = 0; i < tracks.length; i++) {
-        if (tracks[i] == track) {
+      for (int overrideTrack : tracks) {
+        if (overrideTrack == track) {
           return true;
         }
       }
@@ -82,15 +83,22 @@ public boolean containsTrack(int track) {
 
   private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
   private final SparseBooleanArray rendererDisabledFlags;
+  private int tunnelingAudioSessionId;
 
-  /**
-   * @param eventHandler A handler to use when delivering events to listeners added via
-   *     {@link #addListener(EventListener)}.
-   */
-  public MappingTrackSelector(Handler eventHandler) {
-    super(eventHandler);
+  private MappedTrackInfo currentMappedTrackInfo;
+
+  public MappingTrackSelector() {
     selectionOverrides = new SparseArray<>();
     rendererDisabledFlags = new SparseBooleanArray();
+    tunnelingAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
+  }
+
+  /**
+   * Returns the mapping information associated with the current track selections, or null if no
+   * selection is currently active.
+   */
+  public final MappedTrackInfo getCurrentMappedTrackInfo() {
+    return currentMappedTrackInfo;
   }
 
   /**
@@ -134,8 +142,6 @@ public final boolean getRendererDisabled(int rendererIndex) {
    * @param groups The {@link TrackGroupArray} for which the override should be applied.
    * @param override The override.
    */
-  // TODO - Don't allow overrides that select unsupported tracks, unless some flag has been
-  // explicitly set by the user to indicate that they want this.
   public final void setSelectionOverride(int rendererIndex, TrackGroupArray groups,
       SelectionOverride override) {
     Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
@@ -221,12 +227,28 @@ public final void clearSelectionOverrides() {
     invalidate();
   }
 
+  /**
+   * Enables or disables tunneling. To enable tunneling, pass an audio session id to use when in
+   * tunneling mode. Session ids can be generated using
+   * {@link C#generateAudioSessionIdV21(Context)}. To disable tunneling pass
+   * {@link C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
+   * supported by the audio and video renderers for the selected tracks.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
+   */
+  public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
+    if (this.tunnelingAudioSessionId != tunnelingAudioSessionId) {
+      this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+      invalidate();
+    }
+  }
+
   // TrackSelector implementation.
 
   @Override
-  public final TrackSelections<MappedTrackInfo> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException {
+  public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException {
     // Structures into which data will be written during the selection. The extra item at the end
     // of each array is to store data associated with track groups that cannot be associated with
     // any renderer.
@@ -294,7 +316,25 @@ public final void clearSelectionOverrides() {
     MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
         rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
         unassociatedTrackGroupArray);
-    return new TrackSelections<>(mappedTrackInfo, trackSelections);
+
+    // Initialize the renderer configurations to the default configuration for all renderers with
+    // selections, and null otherwise.
+    RendererConfiguration[] rendererConfigurations =
+        new RendererConfiguration[rendererCapabilities.length];
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      rendererConfigurations[i] = trackSelections[i] != null ? RendererConfiguration.DEFAULT : null;
+    }
+    // Configure audio and video renderers to use tunneling if appropriate.
+    maybeConfigureRenderersForTunneling(rendererCapabilities, rendererTrackGroupArrays,
+        rendererFormatSupports, rendererConfigurations, trackSelections, tunnelingAudioSessionId);
+
+    return new TrackSelectorResult(trackGroups, new TrackSelectionArray(trackSelections),
+        mappedTrackInfo, rendererConfigurations);
+  }
+
+  @Override
+  public final void onSelectionActivated(Object info) {
+    currentMappedTrackInfo = (MappedTrackInfo) info;
   }
 
   /**
@@ -336,15 +376,16 @@ public final void clearSelectionOverrides() {
   private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
       throws ExoPlaybackException {
     int bestRendererIndex = rendererCapabilities.length;
-    int bestSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
+    int bestFormatSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
     for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
       RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
       for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        int trackSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex));
-        if (trackSupportLevel > bestSupportLevel) {
+        int formatSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex))
+            & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        if (formatSupportLevel > bestFormatSupportLevel) {
           bestRendererIndex = rendererIndex;
-          bestSupportLevel = trackSupportLevel;
-          if (bestSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
+          bestFormatSupportLevel = formatSupportLevel;
+          if (bestFormatSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
             // We can't do better.
             return bestRendererIndex;
           }
@@ -391,6 +432,94 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
     return mixedMimeTypeAdaptationSupport;
   }
 
+  /**
+   * Determines whether tunneling should be enabled, replacing {@link RendererConfiguration}s in
+   * {@code rendererConfigurations} with configurations that enable tunneling on the appropriate
+   * renderers if so.
+   *
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
+   *     {@link TrackSelection}s are to be generated.
+   * @param rendererTrackGroupArrays An array of {@link TrackGroupArray}s where each entry
+   *     corresponds to the renderer of equal index in {@code renderers}.
+   * @param rendererFormatSupports Maps every available track to a specific level of support as
+   *     defined by the renderer {@code FORMAT_*} constants.
+   * @param rendererConfigurations The renderer configurations. Configurations may be replaced with
+   *     ones that enable tunneling as a result of this call.
+   * @param trackSelections The renderer track selections.
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  private static void maybeConfigureRenderersForTunneling(
+      RendererCapabilities[] rendererCapabilities, TrackGroupArray[] rendererTrackGroupArrays,
+      int[][][] rendererFormatSupports, RendererConfiguration[] rendererConfigurations,
+      TrackSelection[] trackSelections, int tunnelingAudioSessionId) {
+    if (tunnelingAudioSessionId == C.AUDIO_SESSION_ID_UNSET) {
+      return;
+    }
+    // Check whether we can enable tunneling. To enable tunneling we require exactly one audio and
+    // one video renderer to support tunneling and have a selection.
+    int tunnelingAudioRendererIndex = -1;
+    int tunnelingVideoRendererIndex = -1;
+    boolean enableTunneling = true;
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      int rendererType = rendererCapabilities[i].getTrackType();
+      TrackSelection trackSelection = trackSelections[i];
+      if ((rendererType == C.TRACK_TYPE_AUDIO || rendererType == C.TRACK_TYPE_VIDEO)
+          && trackSelection != null) {
+        if (rendererSupportsTunneling(rendererFormatSupports[i], rendererTrackGroupArrays[i],
+            trackSelection)) {
+          if (rendererType == C.TRACK_TYPE_AUDIO) {
+            if (tunnelingAudioRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingAudioRendererIndex = i;
+            }
+          } else {
+            if (tunnelingVideoRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingVideoRendererIndex = i;
+            }
+          }
+        }
+      }
+    }
+    enableTunneling &= tunnelingAudioRendererIndex != -1 && tunnelingVideoRendererIndex != -1;
+    if (enableTunneling) {
+      RendererConfiguration tunnelingRendererConfiguration =
+          new RendererConfiguration(tunnelingAudioSessionId);
+      rendererConfigurations[tunnelingAudioRendererIndex] = tunnelingRendererConfiguration;
+      rendererConfigurations[tunnelingVideoRendererIndex] = tunnelingRendererConfiguration;
+    }
+  }
+
+  /**
+   * Returns whether a renderer supports tunneling for a {@link TrackSelection}.
+   *
+   * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each
+   *     track, indexed by group index and track index (in that order).
+   * @param trackGroups The {@link TrackGroupArray}s for the renderer.
+   * @param selection The track selection.
+   * @return Whether the renderer supports tunneling for the {@link TrackSelection}.
+   */
+  private static boolean rendererSupportsTunneling(int[][] formatSupport,
+      TrackGroupArray trackGroups, TrackSelection selection) {
+    if (selection == null) {
+      return false;
+    }
+    int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+    for (int i = 0; i < selection.length(); i++) {
+      int trackFormatSupport = formatSupport[trackGroupIndex][selection.getIndexInTrackGroup(i)];
+      if ((trackFormatSupport & RendererCapabilities.TUNNELING_SUPPORT_MASK)
+          != RendererCapabilities.TUNNELING_SUPPORTED) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * Provides track information for each renderer.
    */
@@ -401,20 +530,29 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
      */
     public static final int RENDERER_SUPPORT_NO_TRACKS = 0;
     /**
-     * The renderer has associated tracks, but cannot play any of them.
+     * The renderer has associated tracks, but all are of unsupported types.
      */
-    public static final int RENDERER_SUPPORT_UNPLAYABLE_TRACKS = 1;
+    public static final int RENDERER_SUPPORT_UNSUPPORTED_TRACKS = 1;
+    /**
+     * The renderer has associated tracks and at least one is of a supported type, but all of the
+     * tracks whose types are supported exceed the renderer's capabilities.
+     */
+    public static final int RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS = 2;
+    /**
+     * The renderer has associated tracks and can play at least one of them.
+     */
+    public static final int RENDERER_SUPPORT_PLAYABLE_TRACKS = 3;
+
     /**
-     * The renderer has associated tracks, and can play at least one of them.
+     * The number of renderers to which tracks are mapped.
      */
-    public static final int RENDERER_SUPPORT_PLAYABLE_TRACKS = 2;
+    public final int length;
 
     private final int[] rendererTrackTypes;
     private final TrackGroupArray[] trackGroups;
     private final int[] mixedMimeTypeAdaptiveSupport;
     private final int[][][] formatSupport;
     private final TrackGroupArray unassociatedTrackGroups;
-    private final int rendererCount;
 
     /**
      * @param rendererTrackTypes The track type supported by each renderer.
@@ -433,7 +571,7 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
       this.formatSupport = formatSupport;
       this.mixedMimeTypeAdaptiveSupport = mixedMimeTypeAdaptiveSupport;
       this.unassociatedTrackGroups = unassociatedTrackGroups;
-      this.rendererCount = trackGroups.length;
+      this.length = trackGroups.length;
     }
 
     /**
@@ -451,21 +589,49 @@ public TrackGroupArray getTrackGroups(int rendererIndex) {
      *
      * @param rendererIndex The renderer index.
      * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
-     *     {@link #RENDERER_SUPPORT_UNPLAYABLE_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+     *     {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
+     *     {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
      */
     public int getRendererSupport(int rendererIndex) {
-      boolean hasTracks = false;
+      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
       int[][] rendererFormatSupport = formatSupport[rendererIndex];
       for (int i = 0; i < rendererFormatSupport.length; i++) {
         for (int j = 0; j < rendererFormatSupport[i].length; j++) {
-          hasTracks = true;
-          if ((rendererFormatSupport[i][j] & RendererCapabilities.FORMAT_SUPPORT_MASK)
-              == RendererCapabilities.FORMAT_HANDLED) {
-            return RENDERER_SUPPORT_PLAYABLE_TRACKS;
+          int trackRendererSupport;
+          switch (rendererFormatSupport[i][j] & RendererCapabilities.FORMAT_SUPPORT_MASK) {
+            case RendererCapabilities.FORMAT_HANDLED:
+              return RENDERER_SUPPORT_PLAYABLE_TRACKS;
+            case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
+              trackRendererSupport = RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS;
+              break;
+            default:
+              trackRendererSupport = RENDERER_SUPPORT_UNSUPPORTED_TRACKS;
+              break;
           }
+          bestRendererSupport = Math.max(bestRendererSupport, trackRendererSupport);
+        }
+      }
+      return bestRendererSupport;
+    }
+
+    /**
+     * Returns the best level of support obtained from {@link #getRendererSupport(int)} for all
+     * renderers of the specified track type. If no renderers exist for the specified type then
+     * {@link #RENDERER_SUPPORT_NO_TRACKS} is returned.
+     *
+     * @param trackType The track type. One of the {@link C} {@code TRACK_TYPE_*} constants.
+     * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
+     *     {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
+     *     {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+     */
+    public int getTrackTypeRendererSupport(int trackType) {
+      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
+      for (int i = 0; i < length; i++) {
+        if (rendererTrackTypes[i] == trackType) {
+          bestRendererSupport = Math.max(bestRendererSupport, getRendererSupport(i));
         }
       }
-      return hasTracks ? RENDERER_SUPPORT_UNPLAYABLE_TRACKS : RENDERER_SUPPORT_NO_TRACKS;
+      return bestRendererSupport;
     }
 
     /**
@@ -562,25 +728,6 @@ public TrackGroupArray getUnassociatedTrackGroups() {
       return unassociatedTrackGroups;
     }
 
-    /**
-     * Returns true if tracks of the specified type exist and have been associated with renderers,
-     * but are all unplayable. Returns false in all other cases.
-     *
-     * @param trackType The track type.
-     * @return True if tracks of the specified type exist, if at least one renderer exists that
-     *     handles tracks of the specified type, and if all of the tracks if the specified type are
-     *     unplayable. False in all other cases.
-     */
-    public boolean hasOnlyUnplayableTracks(int trackType) {
-      int rendererSupport = RENDERER_SUPPORT_NO_TRACKS;
-      for (int i = 0; i < rendererCount; i++) {
-        if (rendererTrackTypes[i] == trackType) {
-          rendererSupport = Math.max(rendererSupport, getRendererSupport(i));
-        }
-      }
-      return rendererSupport == RENDERER_SUPPORT_UNPLAYABLE_TRACKS;
-    }
-
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
similarity index 85%
rename from library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java
rename to library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
index 31ed838310..809e571f10 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
@@ -20,12 +20,8 @@
 /**
  * The result of a {@link TrackSelector} operation.
  */
-public final class TrackSelections<T> {
+public final class TrackSelectionArray {
 
-  /**
-   * Opaque information associated with the result.
-   */
-  public final T info;
   /**
    * The number of selections in the result. Greater than or equal to zero.
    */
@@ -37,11 +33,9 @@
   private int hashCode;
 
   /**
-   * @param info Opaque information associated with the result.
    * @param trackSelections The selections. Must not be null, but may contain null elements.
    */
-  public TrackSelections(T info, TrackSelection... trackSelections) {
-    this.info = info;
+  public TrackSelectionArray(TrackSelection... trackSelections) {
     this.trackSelections = trackSelections;
     this.length = trackSelections.length;
   }
@@ -81,7 +75,7 @@ public boolean equals(Object obj) {
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    TrackSelections<?> other = (TrackSelections<?>) obj;
+    TrackSelectionArray other = (TrackSelectionArray) obj;
     return Arrays.equals(trackSelections, other.trackSelections);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 41c62f6e0e..6c9fbfcb00 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -15,15 +15,12 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.os.Handler;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.util.Assertions;
-import java.util.concurrent.CopyOnWriteArraySet;
 
 /** Selects tracks to be consumed by available renderers. */
-public abstract class TrackSelector<T> {
+public abstract class TrackSelector {
 
   /**
    * Notified when previous selections by a {@link TrackSelector} are no longer valid.
@@ -37,55 +34,7 @@
 
   }
 
-  /** Listener of {@link TrackSelector} events. */
-  public interface EventListener<T> {
-
-    /**
-     * Called when the track selections have changed.
-     *
-     * @param trackSelections The new track selections.
-     */
-    void onTrackSelectionsChanged(TrackSelections<? extends T> trackSelections);
-  }
-
-  private final Handler eventHandler;
-  private final CopyOnWriteArraySet<MappingTrackSelector.EventListener<? super T>> listeners;
-
   private InvalidationListener listener;
-  private TrackSelections<T> activeSelections;
-
-  /**
-   * @param eventHandler A handler to use when delivering events to listeners added via {@link
-   *     #addListener(EventListener)}.
-   */
-  public TrackSelector(Handler eventHandler) {
-    this.eventHandler = Assertions.checkNotNull(eventHandler);
-    this.listeners = new CopyOnWriteArraySet<>();
-  }
-
-  /**
-   * Registers a listener to receive events from the selector. The listener's methods will be called
-   * using the {@link Handler} that was passed to the constructor.
-   *
-   * @param listener The listener to register.
-   */
-  public final void addListener(EventListener<? super T> listener) {
-    listeners.add(listener);
-  }
-
-  /**
-   * Unregister a listener. The listener will no longer receive events from the selector.
-   *
-   * @param listener The listener to unregister.
-   */
-  public final void removeListener(EventListener<? super T> listener) {
-    listeners.remove(listener);
-  }
-
-  /** Returns the current track selections. */
-  public final TrackSelections<T> getCurrentSelections() {
-    return activeSelections;
-  }
 
   /**
    * Initializes the selector.
@@ -97,28 +46,24 @@ public final void init(InvalidationListener listener) {
   }
 
   /**
-   * Generates {@link TrackSelections} for the renderers.
+   * Performs a track selection for renderers.
    *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which {@link
-   *     TrackSelection}s are to be generated.
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which tracks
+   *     are to be selected.
    * @param trackGroups The available track groups.
-   * @return The track selections.
+   * @return A {@link TrackSelectorResult} describing the track selections.
    * @throws ExoPlaybackException If an error occurs selecting tracks.
    */
-  public abstract TrackSelections<T> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException;
+  public abstract TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException;
 
   /**
-   * Called when {@link TrackSelections} previously generated by {@link
-   * #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
+   * Called when a {@link TrackSelectorResult} previously generated by
+   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} is activated.
    *
-   * @param activeSelections The activated {@link TrackSelections}.
+   * @param info The value of {@link TrackSelectorResult#info} in the activated result.
    */
-  public final void onSelectionActivated(TrackSelections<T> activeSelections) {
-    this.activeSelections = activeSelections;
-    notifyTrackSelectionsChanged(activeSelections);
-  }
+  public abstract void onSelectionActivated(Object info);
 
   /**
    * Invalidates all previously generated track selections.
@@ -129,18 +74,4 @@ protected final void invalidate() {
     }
   }
 
-  private void notifyTrackSelectionsChanged(final TrackSelections<T> activeSelections) {
-    if (eventHandler != null) {
-      eventHandler.post(
-          new Runnable() {
-            @Override
-            public void run() {
-              for (EventListener<? super T> listener : listeners) {
-                listener.onTrackSelectionsChanged(activeSelections);
-              }
-            }
-          });
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
new file mode 100644
index 0000000000..5cdb157570
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * The result of a {@link TrackSelector} operation.
+ */
+public final class TrackSelectorResult {
+
+  /**
+   * The groups provided to the {@link TrackSelector}.
+   */
+  public final TrackGroupArray groups;
+  /**
+   * A {@link TrackSelectionArray} containing the selection for each renderer.
+   */
+  public final TrackSelectionArray selections;
+  /**
+   * An opaque object that will be returned to {@link TrackSelector#onSelectionActivated(Object)}
+   * should the selections be activated.
+   */
+  public final Object info;
+  /**
+   * A {@link RendererConfiguration} for each renderer, to be used with the selections.
+   */
+  public final RendererConfiguration[] rendererConfigurations;
+
+  /**
+   * @param groups The groups provided to the {@link TrackSelector}.
+   * @param selections A {@link TrackSelectionArray} containing the selection for each renderer.
+   * @param info An opaque object that will be returned to
+   *     {@link TrackSelector#onSelectionActivated(Object)} should the selections be activated.
+   * @param rendererConfigurations A {@link RendererConfiguration} for each renderer, to be used
+   *     with the selections.
+   */
+  public TrackSelectorResult(TrackGroupArray groups, TrackSelectionArray selections, Object info,
+      RendererConfiguration[] rendererConfigurations) {
+    this.groups = groups;
+    this.selections = selections;
+    this.info = info;
+    this.rendererConfigurations = rendererConfigurations;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for all renderers.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other) {
+    if (other == null) {
+      return false;
+    }
+    for (int i = 0; i < selections.length; i++) {
+      if (!isEquivalent(other, i)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for the renderer at the given index.
+   * The results are equivalent if they have equal track selections and configurations for the
+   * renderer.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @param index The renderer index to check for equivalence.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other, int index) {
+    if (other == null) {
+      return false;
+    }
+    return Util.areEqual(selections.get(index), other.selections.get(index))
+        && Util.areEqual(rendererConfigurations[index], other.rendererConfigurations[index]);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index e6f18c882b..d3034a8bc8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -17,16 +17,26 @@
 
 import android.content.Context;
 import android.content.res.TypedArray;
+import android.support.annotation.IntDef;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 
 import com.google.android.exoplayer2.R;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * A {@link FrameLayout} that resizes itself to match a specified aspect ratio.
  */
 public final class AspectRatioFrameLayout extends FrameLayout {
 
+  /**
+   * Resize modes for {@link AspectRatioFrameLayout}.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({RESIZE_MODE_FIT, RESIZE_MODE_FIXED_WIDTH, RESIZE_MODE_FIXED_HEIGHT, RESIZE_MODE_FILL})
+  public @interface ResizeMode {}
+
   /**
    * Either the width or height is decreased to obtain the desired aspect ratio.
    */
@@ -39,6 +49,10 @@
    * The height is fixed and the width is increased or decreased to obtain the desired aspect ratio.
    */
   public static final int RESIZE_MODE_FIXED_HEIGHT = 2;
+  /**
+   * The specified aspect ratio is ignored.
+   */
+  public static final int RESIZE_MODE_FILL = 3;
 
   /**
    * The {@link FrameLayout} will not resize itself if the fractional difference between its natural
@@ -85,12 +99,11 @@ public void setAspectRatio(float widthHeightRatio) {
   }
 
   /**
-   * Sets the resize mode which can be of value {@link #RESIZE_MODE_FIT},
-   * {@link #RESIZE_MODE_FIXED_HEIGHT} or {@link #RESIZE_MODE_FIXED_WIDTH}.
+   * Sets the resize mode.
    *
    * @param resizeMode The resize mode.
    */
-  public void setResizeMode(int resizeMode) {
+  public void setResizeMode(@ResizeMode int resizeMode) {
     if (this.resizeMode != resizeMode) {
       this.resizeMode = resizeMode;
       requestLayout();
@@ -100,7 +113,7 @@ public void setResizeMode(int resizeMode) {
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-    if (videoAspectRatio == 0) {
+    if (resizeMode == RESIZE_MODE_FILL || videoAspectRatio <= 0) {
       // Aspect ratio not set.
       return;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index af38836fc9..1bf5b59a4a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -22,6 +22,8 @@
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 
 /**
  * A helper class for periodically updating a {@link TextView} with debug information obtained from
@@ -98,6 +100,11 @@ public void onPlayerError(ExoPlaybackException error) {
     // Do nothing.
   }
 
+  @Override
+  public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
+    // Do nothing.
+  }
+
   // Runnable implementation.
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 3823f1760e..dc3c398357 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ui;
 
+import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.os.SystemClock;
@@ -23,7 +24,6 @@
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.FrameLayout;
-import android.widget.ImageButton;
 import android.widget.SeekBar;
 import android.widget.TextView;
 import com.google.android.exoplayer2.C;
@@ -31,12 +31,116 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.R;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Formatter;
 import java.util.Locale;
 
 /**
- * A view to control video playback of an {@link ExoPlayer}.
+ * A view for controlling {@link ExoPlayer} instances.
+ * <p>
+ * A PlaybackControlView can be customized by setting attributes (or calling corresponding methods),
+ * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ * The following attributes can be set on a PlaybackControlView when used in a layout XML file:
+ * <p>
+ * <ul>
+ *   <li><b>{@code show_timeout}</b> - The time between the last user interaction and the controls
+ *       being automatically hidden, in milliseconds. Use zero if the controls should not
+ *       automatically timeout.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShowTimeoutMs(int)}</li>
+ *         <li>Default: {@link #DEFAULT_SHOW_TIMEOUT_MS}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
+ *       rewind button, in milliseconds. Use zero to disable the rewind button.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setRewindIncrementMs(int)}</li>
+ *         <li>Default: {@link #DEFAULT_REWIND_MS}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setFastForwardIncrementMs(int)}</li>
+ *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
+ *       below for more details.
+ *       <ul>
+ *         <li>Corresponding method: None</li>
+ *         <li>Default: {@code R.id.exo_playback_control_view}</li>
+ *       </ul>
+ *   </li>
+ * </ul>
+ *
+ * <h3>Overriding the layout file</h3>
+ * To customize the layout of PlaybackControlView throughout your app, or just for certain
+ * configurations, you can define {@code exo_playback_control_view.xml} layout files in your
+ * application {@code res/layout*} directories. These layouts will override the one provided by the
+ * ExoPlayer library, and will be inflated for use by PlaybackControlView. The view identifies and
+ * binds its children by looking for the following ids:
+ * <p>
+ * <ul>
+ *   <li><b>{@code exo_play}</b> - The play button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_pause}</b> - The pause button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_ffwd}</b> - The fast forward button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_rew}</b> - The rewind button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_prev}</b> - The previous track button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_next}</b> - The next track button.
+ *       <ul>
+ *         <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
+ *       <ul>
+ *         <li>Type: {@link TextView}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_duration}</b> - Text view displaying the current media duration.
+ *       <ul>
+ *         <li>Type: {@link TextView}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_progress}</b> - Seek bar that's updated during playback and allows seeking.
+ *       <ul>
+ *         <li>Type: {@link SeekBar}</li>
+ *       </ul>
+ *   </li>
+ * </ul>
+ * <p>
+ * All child views are optional and so can be omitted if not required, however where defined they
+ * must be of the expected type.
+ *
+ * <h3>Specifying a custom layout file</h3>
+ * Defining your own {@code exo_playback_control_view.xml} is useful to customize the layout of
+ * PlaybackControlView throughout your application. It's also possible to customize the layout for a
+ * single instance in a layout file. This is achieved by setting the {@code controller_layout_id}
+ * attribute on a PlaybackControlView. This will cause the specified layout to be inflated instead
+ * of {@code exo_playback_control_view.xml} for only the instance on which the attribute is set.
  */
 public class PlaybackControlView extends FrameLayout {
 
@@ -44,14 +148,45 @@
    * Listener to be notified about changes of the visibility of the UI control.
    */
   public interface VisibilityListener {
+
     /**
      * Called when the visibility changes.
      *
      * @param visibility The new visibility. Either {@link View#VISIBLE} or {@link View#GONE}.
      */
     void onVisibilityChange(int visibility);
+
   }
 
+  /**
+   * Dispatches seek operations to the player.
+   */
+  public interface SeekDispatcher {
+
+    /**
+     * @param player The player to seek.
+     * @param windowIndex The index of the window.
+     * @param positionMs The seek position in the specified window, or {@link C#TIME_UNSET} to seek
+     *     to the window's default position.
+     * @return True if the seek was dispatched. False otherwise.
+     */
+    boolean dispatchSeek(ExoPlayer player, int windowIndex, long positionMs);
+
+  }
+
+  /**
+   * Default {@link SeekDispatcher} that dispatches seeks to the player without modification.
+   */
+  public static final SeekDispatcher DEFAULT_SEEK_DISPATCHER = new SeekDispatcher() {
+
+    @Override
+    public boolean dispatchSeek(ExoPlayer player, int windowIndex, long positionMs) {
+      player.seekTo(windowIndex, positionMs);
+      return true;
+    }
+
+  };
+
   public static final int DEFAULT_FAST_FORWARD_MS = 15000;
   public static final int DEFAULT_REWIND_MS = 5000;
   public static final int DEFAULT_SHOW_TIMEOUT_MS = 5000;
@@ -62,19 +197,22 @@
   private final ComponentListener componentListener;
   private final View previousButton;
   private final View nextButton;
-  private final ImageButton playButton;
-  private final TextView time;
-  private final TextView timeCurrent;
-  private final SeekBar progressBar;
+  private final View playButton;
+  private final View pauseButton;
   private final View fastForwardButton;
   private final View rewindButton;
+  private final TextView durationView;
+  private final TextView positionView;
+  private final SeekBar progressBar;
   private final StringBuilder formatBuilder;
   private final Formatter formatter;
   private final Timeline.Window currentWindow;
 
   private ExoPlayer player;
+  private SeekDispatcher seekDispatcher;
   private VisibilityListener visibilityListener;
 
+  private boolean isAttachedToWindow;
   private boolean dragging;
   private int rewindMs;
   private int fastForwardMs;
@@ -106,6 +244,7 @@ public PlaybackControlView(Context context, AttributeSet attrs) {
   public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
 
+    int controllerLayoutId = R.layout.exo_playback_control_view;
     rewindMs = DEFAULT_REWIND_MS;
     fastForwardMs = DEFAULT_FAST_FORWARD_MS;
     showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
@@ -117,32 +256,52 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
         fastForwardMs = a.getInt(R.styleable.PlaybackControlView_fastforward_increment,
             fastForwardMs);
         showTimeoutMs = a.getInt(R.styleable.PlaybackControlView_show_timeout, showTimeoutMs);
+        controllerLayoutId = a.getResourceId(R.styleable.PlaybackControlView_controller_layout_id,
+            controllerLayoutId);
       } finally {
         a.recycle();
       }
     }
-
     currentWindow = new Timeline.Window();
     formatBuilder = new StringBuilder();
     formatter = new Formatter(formatBuilder, Locale.getDefault());
     componentListener = new ComponentListener();
+    seekDispatcher = DEFAULT_SEEK_DISPATCHER;
 
-    LayoutInflater.from(context).inflate(R.layout.exo_playback_control_view, this);
-    time = (TextView) findViewById(R.id.time);
-    timeCurrent = (TextView) findViewById(R.id.time_current);
-    progressBar = (SeekBar) findViewById(R.id.mediacontroller_progress);
-    progressBar.setOnSeekBarChangeListener(componentListener);
-    progressBar.setMax(PROGRESS_BAR_MAX);
-    playButton = (ImageButton) findViewById(R.id.play);
-    playButton.setOnClickListener(componentListener);
-    previousButton = findViewById(R.id.prev);
-    previousButton.setOnClickListener(componentListener);
-    nextButton = findViewById(R.id.next);
-    nextButton.setOnClickListener(componentListener);
-    rewindButton = findViewById(R.id.rew);
-    rewindButton.setOnClickListener(componentListener);
-    fastForwardButton = findViewById(R.id.ffwd);
-    fastForwardButton.setOnClickListener(componentListener);
+    LayoutInflater.from(context).inflate(controllerLayoutId, this);
+    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+
+    durationView = (TextView) findViewById(R.id.exo_duration);
+    positionView = (TextView) findViewById(R.id.exo_position);
+    progressBar = (SeekBar) findViewById(R.id.exo_progress);
+    if (progressBar != null) {
+      progressBar.setOnSeekBarChangeListener(componentListener);
+      progressBar.setMax(PROGRESS_BAR_MAX);
+    }
+    playButton = findViewById(R.id.exo_play);
+    if (playButton != null) {
+      playButton.setOnClickListener(componentListener);
+    }
+    pauseButton = findViewById(R.id.exo_pause);
+    if (pauseButton != null) {
+      pauseButton.setOnClickListener(componentListener);
+    }
+    previousButton = findViewById(R.id.exo_prev);
+    if (previousButton != null) {
+      previousButton.setOnClickListener(componentListener);
+    }
+    nextButton = findViewById(R.id.exo_next);
+    if (nextButton != null) {
+      nextButton.setOnClickListener(componentListener);
+    }
+    rewindButton = findViewById(R.id.exo_rew);
+    if (rewindButton != null) {
+      rewindButton.setOnClickListener(componentListener);
+    }
+    fastForwardButton = findViewById(R.id.exo_ffwd);
+    if (fastForwardButton != null) {
+      fastForwardButton.setOnClickListener(componentListener);
+    }
   }
 
   /**
@@ -180,10 +339,21 @@ public void setVisibilityListener(VisibilityListener listener) {
     this.visibilityListener = listener;
   }
 
+  /**
+   * Sets the {@link SeekDispatcher}.
+   *
+   * @param seekDispatcher The {@link SeekDispatcher}, or null to use
+   *     {@link #DEFAULT_SEEK_DISPATCHER}.
+   */
+  public void setSeekDispatcher(SeekDispatcher seekDispatcher) {
+    this.seekDispatcher = seekDispatcher == null ? DEFAULT_SEEK_DISPATCHER : seekDispatcher;
+  }
+
   /**
    * Sets the rewind increment in milliseconds.
    *
-   * @param rewindMs The rewind increment in milliseconds.
+   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+   *     rewind button to be disabled.
    */
   public void setRewindIncrementMs(int rewindMs) {
     this.rewindMs = rewindMs;
@@ -193,7 +363,8 @@ public void setRewindIncrementMs(int rewindMs) {
   /**
    * Sets the fast forward increment in milliseconds.
    *
-   * @param fastForwardMs The fast forward increment in milliseconds.
+   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+   *     cause the fast forward button to be disabled.
    */
   public void setFastForwardIncrementMs(int fastForwardMs) {
     this.fastForwardMs = fastForwardMs;
@@ -233,6 +404,7 @@ public void show() {
         visibilityListener.onVisibilityChange(getVisibility());
       }
       updateAll();
+      requestPlayPauseFocus();
     }
     // Call hideAfterTimeout even if already visible to reset the timeout.
     hideAfterTimeout();
@@ -264,7 +436,7 @@ private void hideAfterTimeout() {
     removeCallbacks(hideAction);
     if (showTimeoutMs > 0) {
       hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs;
-      if (isAttachedToWindow()) {
+      if (isAttachedToWindow) {
         postDelayed(hideAction, showTimeoutMs);
       }
     } else {
@@ -279,27 +451,34 @@ private void updateAll() {
   }
 
   private void updatePlayPauseButton() {
-    if (!isVisible() || !isAttachedToWindow()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
+    boolean requestPlayPauseFocus = false;
     boolean playing = player != null && player.getPlayWhenReady();
-    String contentDescription = getResources().getString(
-        playing ? R.string.exo_controls_pause_description : R.string.exo_controls_play_description);
-    playButton.setContentDescription(contentDescription);
-    playButton.setImageResource(
-        playing ? R.drawable.exo_controls_pause : R.drawable.exo_controls_play);
+    if (playButton != null) {
+      requestPlayPauseFocus |= playing && playButton.isFocused();
+      playButton.setVisibility(playing ? View.GONE : View.VISIBLE);
+    }
+    if (pauseButton != null) {
+      requestPlayPauseFocus |= !playing && pauseButton.isFocused();
+      pauseButton.setVisibility(!playing ? View.GONE : View.VISIBLE);
+    }
+    if (requestPlayPauseFocus) {
+      requestPlayPauseFocus();
+    }
   }
 
   private void updateNavigation() {
-    if (!isVisible() || !isAttachedToWindow()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
     Timeline currentTimeline = player != null ? player.getCurrentTimeline() : null;
-    boolean haveTimeline = currentTimeline != null;
+    boolean haveNonEmptyTimeline = currentTimeline != null && !currentTimeline.isEmpty();
     boolean isSeekable = false;
     boolean enablePrevious = false;
     boolean enableNext = false;
-    if (haveTimeline) {
+    if (haveNonEmptyTimeline) {
       int currentWindowIndex = player.getCurrentWindowIndex();
       currentTimeline.getWindow(currentWindowIndex, currentWindow);
       isSeekable = currentWindow.isSeekable;
@@ -311,25 +490,32 @@ private void updateNavigation() {
     setButtonEnabled(enableNext, nextButton);
     setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
     setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
-    progressBar.setEnabled(isSeekable);
+    if (progressBar != null) {
+      progressBar.setEnabled(isSeekable);
+    }
   }
 
   private void updateProgress() {
-    if (!isVisible() || !isAttachedToWindow()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
     long duration = player == null ? 0 : player.getDuration();
     long position = player == null ? 0 : player.getCurrentPosition();
-    time.setText(stringForTime(duration));
-    if (!dragging) {
-      timeCurrent.setText(stringForTime(position));
+    if (durationView != null) {
+      durationView.setText(stringForTime(duration));
     }
-    if (!dragging) {
-      progressBar.setProgress(progressBarValue(position));
+    if (positionView != null && !dragging) {
+      positionView.setText(stringForTime(position));
+    }
+
+    if (progressBar != null) {
+      if (!dragging) {
+        progressBar.setProgress(progressBarValue(position));
+      }
+      long bufferedPosition = player == null ? 0 : player.getBufferedPosition();
+      progressBar.setSecondaryProgress(progressBarValue(bufferedPosition));
+      // Remove scheduled updates.
     }
-    long bufferedPosition = player == null ? 0 : player.getBufferedPosition();
-    progressBar.setSecondaryProgress(progressBarValue(bufferedPosition));
-    // Remove scheduled updates.
     removeCallbacks(updateProgressAction);
     // Schedule an update if necessary.
     int playbackState = player == null ? ExoPlayer.STATE_IDLE : player.getPlaybackState();
@@ -347,16 +533,33 @@ private void updateProgress() {
     }
   }
 
+  private void requestPlayPauseFocus() {
+    boolean playing = player != null && player.getPlayWhenReady();
+    if (!playing && playButton != null) {
+      playButton.requestFocus();
+    } else if (playing && pauseButton != null) {
+      pauseButton.requestFocus();
+    }
+  }
+
   private void setButtonEnabled(boolean enabled, View view) {
+    if (view == null) {
+      return;
+    }
     view.setEnabled(enabled);
     if (Util.SDK_INT >= 11) {
-      view.setAlpha(enabled ? 1f : 0.3f);
+      setViewAlphaV11(view, enabled ? 1f : 0.3f);
       view.setVisibility(VISIBLE);
     } else {
       view.setVisibility(enabled ? VISIBLE : INVISIBLE);
     }
   }
 
+  @TargetApi(11)
+  private void setViewAlphaV11(View view, float alpha) {
+    view.setAlpha(alpha);
+  }
+
   private String stringForTime(long timeMs) {
     if (timeMs == C.TIME_UNSET) {
       timeMs = 0;
@@ -383,29 +586,29 @@ private long positionValue(int progress) {
 
   private void previous() {
     Timeline currentTimeline = player.getCurrentTimeline();
-    if (currentTimeline == null) {
+    if (currentTimeline.isEmpty()) {
       return;
     }
     int currentWindowIndex = player.getCurrentWindowIndex();
     currentTimeline.getWindow(currentWindowIndex, currentWindow);
     if (currentWindowIndex > 0 && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
         || (currentWindow.isDynamic && !currentWindow.isSeekable))) {
-      player.seekToDefaultPosition(currentWindowIndex - 1);
+      seekTo(currentWindowIndex - 1, C.TIME_UNSET);
     } else {
-      player.seekTo(0);
+      seekTo(0);
     }
   }
 
   private void next() {
     Timeline currentTimeline = player.getCurrentTimeline();
-    if (currentTimeline == null) {
+    if (currentTimeline.isEmpty()) {
       return;
     }
     int currentWindowIndex = player.getCurrentWindowIndex();
     if (currentWindowIndex < currentTimeline.getWindowCount() - 1) {
-      player.seekToDefaultPosition(currentWindowIndex + 1);
+      seekTo(currentWindowIndex + 1, C.TIME_UNSET);
     } else if (currentTimeline.getWindow(currentWindowIndex, currentWindow, false).isDynamic) {
-      player.seekToDefaultPosition();
+      seekTo(currentWindowIndex, C.TIME_UNSET);
     }
   }
 
@@ -413,19 +616,33 @@ private void rewind() {
     if (rewindMs <= 0) {
       return;
     }
-    player.seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
+    seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
   }
 
   private void fastForward() {
     if (fastForwardMs <= 0) {
       return;
     }
-    player.seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
+    seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
+  }
+
+  private void seekTo(long positionMs) {
+    seekTo(player.getCurrentWindowIndex(), positionMs);
+  }
+
+  private void seekTo(int windowIndex, long positionMs) {
+    boolean dispatched = seekDispatcher.dispatchSeek(player, windowIndex, positionMs);
+    if (!dispatched) {
+      // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
+      // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
+      updateProgress();
+    }
   }
 
   @Override
   public void onAttachedToWindow() {
     super.onAttachedToWindow();
+    isAttachedToWindow = true;
     if (hideAtMs != C.TIME_UNSET) {
       long delayMs = hideAtMs - SystemClock.uptimeMillis();
       if (delayMs <= 0) {
@@ -440,46 +657,73 @@ public void onAttachedToWindow() {
   @Override
   public void onDetachedFromWindow() {
     super.onDetachedFromWindow();
+    isAttachedToWindow = false;
     removeCallbacks(updateProgressAction);
     removeCallbacks(hideAction);
   }
 
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
-    if (player == null || event.getAction() != KeyEvent.ACTION_DOWN) {
-      return super.dispatchKeyEvent(event);
-    }
-    switch (event.getKeyCode()) {
-      case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
-      case KeyEvent.KEYCODE_DPAD_RIGHT:
-        fastForward();
-        break;
-      case KeyEvent.KEYCODE_MEDIA_REWIND:
-      case KeyEvent.KEYCODE_DPAD_LEFT:
-        rewind();
-        break;
-      case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-        player.setPlayWhenReady(!player.getPlayWhenReady());
-        break;
-      case KeyEvent.KEYCODE_MEDIA_PLAY:
-        player.setPlayWhenReady(true);
-        break;
-      case KeyEvent.KEYCODE_MEDIA_PAUSE:
-        player.setPlayWhenReady(false);
-        break;
-      case KeyEvent.KEYCODE_MEDIA_NEXT:
-        next();
-        break;
-      case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-        previous();
-        break;
-      default:
-        return false;
+    boolean handled = dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+    if (handled) {
+      show();
+    }
+    return handled;
+  }
+
+  /**
+   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
+   * events will be handled.
+   *
+   * @param event A key event.
+   * @return Whether the key event was handled.
+   */
+  public boolean dispatchMediaKeyEvent(KeyEvent event) {
+    int keyCode = event.getKeyCode();
+    if (player == null || !isHandledMediaKey(keyCode)) {
+      return false;
+    }
+    if (event.getAction() == KeyEvent.ACTION_DOWN) {
+      switch (keyCode) {
+        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+          fastForward();
+          break;
+        case KeyEvent.KEYCODE_MEDIA_REWIND:
+          rewind();
+          break;
+        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+          player.setPlayWhenReady(!player.getPlayWhenReady());
+          break;
+        case KeyEvent.KEYCODE_MEDIA_PLAY:
+          player.setPlayWhenReady(true);
+          break;
+        case KeyEvent.KEYCODE_MEDIA_PAUSE:
+          player.setPlayWhenReady(false);
+          break;
+        case KeyEvent.KEYCODE_MEDIA_NEXT:
+          next();
+          break;
+        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+          previous();
+          break;
+        default:
+          break;
+      }
     }
     show();
     return true;
   }
 
+  private static boolean isHandledMediaKey(int keyCode) {
+    return keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
+        || keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE
+        || keyCode == KeyEvent.KEYCODE_MEDIA_NEXT
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+  }
+
   private final class ComponentListener implements ExoPlayer.EventListener,
       SeekBar.OnSeekBarChangeListener, OnClickListener {
 
@@ -492,14 +736,22 @@ public void onStartTrackingTouch(SeekBar seekBar) {
     @Override
     public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
       if (fromUser) {
-        timeCurrent.setText(stringForTime(positionValue(progress)));
+        long position = positionValue(progress);
+        if (positionView != null) {
+          positionView.setText(stringForTime(position));
+        }
+        if (player != null && !dragging) {
+          seekTo(position);
+        }
       }
     }
 
     @Override
     public void onStopTrackingTouch(SeekBar seekBar) {
       dragging = false;
-      player.seekTo(positionValue(seekBar.getProgress()));
+      if (player != null) {
+        seekTo(positionValue(seekBar.getProgress()));
+      }
       hideAfterTimeout();
     }
 
@@ -526,6 +778,11 @@ public void onLoadingChanged(boolean isLoading) {
       // Do nothing.
     }
 
+    @Override
+    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
+      // Do nothing.
+    }
+
     @Override
     public void onPlayerError(ExoPlaybackException error) {
       // Do nothing.
@@ -533,17 +790,20 @@ public void onPlayerError(ExoPlaybackException error) {
 
     @Override
     public void onClick(View view) {
-      Timeline currentTimeline = player.getCurrentTimeline();
-      if (nextButton == view) {
-        next();
-      } else if (previousButton == view) {
-        previous();
-      } else if (fastForwardButton == view) {
-        fastForward();
-      } else if (rewindButton == view && currentTimeline != null) {
-        rewind();
-      } else if (playButton == view) {
-        player.setPlayWhenReady(!player.getPlayWhenReady());
+      if (player != null) {
+        if (nextButton == view) {
+          next();
+        } else if (previousButton == view) {
+          previous();
+        } else if (fastForwardButton == view) {
+          fastForward();
+        } else if (rewindButton == view) {
+          rewind();
+        } else if (playButton == view) {
+          player.setPlayWhenReady(true);
+        } else if (pauseButton == view) {
+          player.setPlayWhenReady(false);
+        }
       }
       hideAfterTimeout();
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index 51955ccef3..3349e05eda 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -18,6 +18,8 @@
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -27,30 +29,164 @@
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
+import android.widget.ImageView;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.R;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.ApicFrame;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode;
+import com.google.android.exoplayer2.ui.PlaybackControlView.SeekDispatcher;
+import com.google.android.exoplayer2.util.Assertions;
 import java.util.List;
 
 /**
- * Displays a video stream.
+ * A high level view for {@link SimpleExoPlayer} media playbacks. It displays video, subtitles and
+ * album art during playback, and displays playback controls using a {@link PlaybackControlView}.
+ * <p>
+ * A SimpleExoPlayerView can be customized by setting attributes (or calling corresponding methods),
+ * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ * The following attributes can be set on a SimpleExoPlayerView when used in a layout XML file:
+ * <p>
+ * <ul>
+ *   <li><b>{@code use_artwork}</b> - Whether artwork is used if available in audio streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setUseArtwork(boolean)}</li>
+ *         <li>Default: {@code true}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
+ *       streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}</li>
+ *         <li>Default: {@code null}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code use_controller}</b> - Whether playback controls are displayed.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setUseController(boolean)}</li>
+ *         <li>Default: {@code true}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
+ *       Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setResizeMode(int)}</li>
+ *         <li>Default: {@code fit}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
+ *       values are {@code surface_view}, {@code texture_view} and {@code none}. Using {@code none}
+ *       is recommended for audio only applications, since creating the surface can be expensive.
+ *       Using {@code surface_view} is recommended for video applications.
+ *       <ul>
+ *         <li>Corresponding method: None</li>
+ *         <li>Default: {@code surface_view}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
+ *       for more details.
+ *       <ul>
+ *         <li>Corresponding method: None</li>
+ *         <li>Default: {@code R.id.exo_simple_player_view}</li>
+ *       </ul>
+ *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
+ *       inflated by the child {@link PlaybackControlView}. See below for more details.
+ *       <ul>
+ *         <li>Corresponding method: None</li>
+ *         <li>Default: {@code R.id.exo_playback_control_view}</li>
+ *       </ul>
+ *   <li>All attributes that can be set on a {@link PlaybackControlView} can also be set on a
+ *       SimpleExoPlayerView, and will be propagated to the inflated {@link PlaybackControlView}.
+ *   </li>
+ * </ul>
+ *
+ * <h3>Overriding the layout file</h3>
+ * To customize the layout of SimpleExoPlayerView throughout your app, or just for certain
+ * configurations, you can define {@code exo_simple_player_view.xml} layout files in your
+ * application {@code res/layout*} directories. These layouts will override the one provided by the
+ * ExoPlayer library, and will be inflated for use by SimpleExoPlayerView. The view identifies and
+ * binds its children by looking for the following ids:
+ * <p>
+ * <ul>
+ *   <li><b>{@code exo_content_frame}</b> - A frame whose aspect ratio is resized based on the video
+ *       or album art of the media being played, and the configured {@code resize_mode}. The video
+ *       surface view is inflated into this frame as its first child.
+ *       <ul>
+ *         <li>Type: {@link AspectRatioFrameLayout}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
+ *       view is typically an opaque view that covers the video surface view, thereby obscuring it
+ *       when visible.
+ *       <ul>
+ *        <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_subtitles}</b> - Displays subtitles.
+ *       <ul>
+ *        <li>Type: {@link SubtitleView}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_artwork}</b> - Displays album art.
+ *       <ul>
+ *        <li>Type: {@link ImageView}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_controller_placeholder}</b> - A placeholder that's replaced with the inflated
+ *       {@link PlaybackControlView}.
+ *       <ul>
+ *        <li>Type: {@link View}</li>
+ *       </ul>
+ *   </li>
+ *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
+ *       <ul>
+ *        <li>Type: {@link FrameLayout}</li>
+ *       </ul>
+ *   </li>
+ * </ul>
+ * <p>
+ * All child views are optional and so can be omitted if not required, however where defined they
+ * must be of the expected type.
+ *
+ * <h3>Specifying a custom layout file</h3>
+ * Defining your own {@code exo_simple_player_view.xml} is useful to customize the layout of
+ * SimpleExoPlayerView throughout your application. It's also possible to customize the layout for a
+ * single instance in a layout file. This is achieved by setting the {@code player_layout_id}
+ * attribute on a SimpleExoPlayerView. This will cause the specified layout to be inflated instead
+ * of {@code exo_simple_player_view.xml} for only the instance on which the attribute is set.
  */
 @TargetApi(16)
 public final class SimpleExoPlayerView extends FrameLayout {
 
-  private final View surfaceView;
+  private static final int SURFACE_TYPE_NONE = 0;
+  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
+  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
+
+  private final AspectRatioFrameLayout contentFrame;
   private final View shutterView;
-  private final SubtitleView subtitleLayout;
-  private final AspectRatioFrameLayout layout;
+  private final View surfaceView;
+  private final ImageView artworkView;
+  private final SubtitleView subtitleView;
   private final PlaybackControlView controller;
   private final ComponentListener componentListener;
+  private final FrameLayout overlayFrameLayout;
 
   private SimpleExoPlayer player;
-  private boolean useController = true;
+  private boolean useController;
+  private boolean useArtwork;
+  private Bitmap defaultArtwork;
   private int controllerShowTimeoutMs;
 
   public SimpleExoPlayerView(Context context) {
@@ -64,23 +200,25 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs) {
   public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
 
-    boolean useTextureView = false;
+    int playerLayoutId = R.layout.exo_simple_player_view;
+    boolean useArtwork = true;
+    int defaultArtworkId = 0;
+    boolean useController = true;
+    int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
     int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
-    int rewindMs = PlaybackControlView.DEFAULT_REWIND_MS;
-    int fastForwardMs = PlaybackControlView.DEFAULT_FAST_FORWARD_MS;
     int controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;
     if (attrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
           R.styleable.SimpleExoPlayerView, 0, 0);
       try {
+        playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,
+            playerLayoutId);
+        useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);
+        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,
+            defaultArtworkId);
         useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);
-        useTextureView = a.getBoolean(R.styleable.SimpleExoPlayerView_use_texture_view,
-            useTextureView);
-        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode,
-            AspectRatioFrameLayout.RESIZE_MODE_FIT);
-        rewindMs = a.getInt(R.styleable.SimpleExoPlayerView_rewind_increment, rewindMs);
-        fastForwardMs = a.getInt(R.styleable.SimpleExoPlayerView_fastforward_increment,
-            fastForwardMs);
+        surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);
+        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);
         controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,
             controllerShowTimeoutMs);
       } finally {
@@ -88,28 +226,65 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
       }
     }
 
-    LayoutInflater.from(context).inflate(R.layout.exo_simple_player_view, this);
+    LayoutInflater.from(context).inflate(playerLayoutId, this);
     componentListener = new ComponentListener();
-    layout = (AspectRatioFrameLayout) findViewById(R.id.video_frame);
-    layout.setResizeMode(resizeMode);
-    shutterView = findViewById(R.id.shutter);
-    subtitleLayout = (SubtitleView) findViewById(R.id.subtitles);
-    subtitleLayout.setUserDefaultStyle();
-    subtitleLayout.setUserDefaultTextSize();
-
-    controller = (PlaybackControlView) findViewById(R.id.control);
-    controller.hide();
-    controller.setRewindIncrementMs(rewindMs);
-    controller.setFastForwardIncrementMs(fastForwardMs);
-    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
+    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+
+    // Content frame.
+    contentFrame = (AspectRatioFrameLayout) findViewById(R.id.exo_content_frame);
+    if (contentFrame != null) {
+      setResizeModeRaw(contentFrame, resizeMode);
+    }
+
+    // Shutter view.
+    shutterView = findViewById(R.id.exo_shutter);
+
+    // Create a surface view and insert it into the content frame, if there is one.
+    if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
+      ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
+          ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+      surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context)
+          : new SurfaceView(context);
+      surfaceView.setLayoutParams(params);
+      contentFrame.addView(surfaceView, 0);
+    } else {
+      surfaceView = null;
+    }
 
-    View view = useTextureView ? new TextureView(context) : new SurfaceView(context);
-    ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
-        ViewGroup.LayoutParams.MATCH_PARENT,
-        ViewGroup.LayoutParams.MATCH_PARENT);
-    view.setLayoutParams(params);
-    surfaceView = view;
-    layout.addView(surfaceView, 0);
+    // Overlay frame layout.
+    overlayFrameLayout = (FrameLayout) findViewById(R.id.exo_overlay);
+
+    // Artwork view.
+    artworkView = (ImageView) findViewById(R.id.exo_artwork);
+    this.useArtwork = useArtwork && artworkView != null;
+    if (defaultArtworkId != 0) {
+      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
+    }
+
+    // Subtitle view.
+    subtitleView = (SubtitleView) findViewById(R.id.exo_subtitles);
+    if (subtitleView != null) {
+      subtitleView.setUserDefaultStyle();
+      subtitleView.setUserDefaultTextSize();
+    }
+
+    // Playback control view.
+    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
+    if (controllerPlaceholder != null) {
+      // Note: rewindMs and fastForwardMs are passed via attrs, so we don't need to make explicit
+      // calls to set them.
+      this.controller = new PlaybackControlView(context, attrs);
+      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
+      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
+      int controllerIndex = parent.indexOfChild(controllerPlaceholder);
+      parent.removeView(controllerPlaceholder);
+      parent.addView(controller, controllerIndex);
+    } else {
+      this.controller = null;
+    }
+    this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0;
+    this.useController = useController && controller != null;
+    hideController();
   }
 
   /**
@@ -140,6 +315,9 @@ public void setPlayer(SimpleExoPlayer player) {
     if (useController) {
       controller.setPlayer(player);
     }
+    if (shutterView != null) {
+      shutterView.setVisibility(VISIBLE);
+    }
     if (player != null) {
       if (surfaceView instanceof TextureView) {
         player.setVideoTextureView((TextureView) surfaceView);
@@ -150,21 +328,61 @@ public void setPlayer(SimpleExoPlayer player) {
       player.addListener(componentListener);
       player.setTextOutput(componentListener);
       maybeShowController(false);
+      updateForCurrentTrackSelections();
     } else {
-      shutterView.setVisibility(VISIBLE);
-      controller.hide();
+      hideController();
+      hideArtwork();
     }
   }
 
   /**
-   * Sets the resize mode which can be of value {@link AspectRatioFrameLayout#RESIZE_MODE_FIT},
-   * {@link AspectRatioFrameLayout#RESIZE_MODE_FIXED_HEIGHT} or
-   * {@link AspectRatioFrameLayout#RESIZE_MODE_FIXED_WIDTH}.
+   * Sets the resize mode.
    *
    * @param resizeMode The resize mode.
    */
-  public void setResizeMode(int resizeMode) {
-    layout.setResizeMode(resizeMode);
+  public void setResizeMode(@ResizeMode int resizeMode) {
+    Assertions.checkState(contentFrame != null);
+    contentFrame.setResizeMode(resizeMode);
+  }
+
+  /**
+   * Returns whether artwork is displayed if present in the media.
+   */
+  public boolean getUseArtwork() {
+    return useArtwork;
+  }
+
+  /**
+   * Sets whether artwork is displayed if present in the media.
+   *
+   * @param useArtwork Whether artwork is displayed.
+   */
+  public void setUseArtwork(boolean useArtwork) {
+    Assertions.checkState(!useArtwork || artworkView != null);
+    if (this.useArtwork != useArtwork) {
+      this.useArtwork = useArtwork;
+      updateForCurrentTrackSelections();
+    }
+  }
+
+  /**
+   * Returns the default artwork to display.
+   */
+  public Bitmap getDefaultArtwork() {
+    return defaultArtwork;
+  }
+
+  /**
+   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+   * present in the media.
+   *
+   * @param defaultArtwork the default artwork to display.
+   */
+  public void setDefaultArtwork(Bitmap defaultArtwork) {
+    if (this.defaultArtwork != defaultArtwork) {
+      this.defaultArtwork = defaultArtwork;
+      updateForCurrentTrackSelections();
+    }
   }
 
   /**
@@ -181,18 +399,48 @@ public boolean getUseController() {
    * @param useController Whether playback controls should be enabled.
    */
   public void setUseController(boolean useController) {
+    Assertions.checkState(!useController || controller != null);
     if (this.useController == useController) {
       return;
     }
     this.useController = useController;
     if (useController) {
       controller.setPlayer(player);
-    } else {
+    } else if (controller != null) {
       controller.hide();
       controller.setPlayer(null);
     }
   }
 
+  /**
+   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
+   * events will be handled. Does nothing if playback controls are disabled.
+   *
+   * @param event A key event.
+   * @return Whether the key event was handled.
+   */
+  public boolean dispatchMediaKeyEvent(KeyEvent event) {
+    return useController && controller.dispatchMediaKeyEvent(event);
+  }
+
+  /**
+   * Shows the playback controls. Does nothing if playback controls are disabled.
+   */
+  public void showController() {
+    if (useController) {
+      maybeShowController(true);
+    }
+  }
+
+  /**
+   * Hides the playback controls. Does nothing if playback controls are disabled.
+   */
+  public void hideController() {
+    if (controller != null) {
+      controller.hide();
+    }
+  }
+
   /**
    * Returns the playback controls timeout. The playback controls are automatically hidden after
    * this duration of time has elapsed without user input and with playback or buffering in
@@ -213,6 +461,7 @@ public int getControllerShowTimeoutMs() {
    *     the controller to remain visible indefinitely.
    */
   public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
+    Assertions.checkState(controller != null);
     this.controllerShowTimeoutMs = controllerShowTimeoutMs;
   }
 
@@ -222,15 +471,28 @@ public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
    * @param listener The listener to be notified about visibility changes.
    */
   public void setControllerVisibilityListener(PlaybackControlView.VisibilityListener listener) {
+    Assertions.checkState(controller != null);
     controller.setVisibilityListener(listener);
   }
 
+  /**
+   * Sets the {@link SeekDispatcher}.
+   *
+   * @param seekDispatcher The {@link SeekDispatcher}, or null to use
+   *     {@link PlaybackControlView#DEFAULT_SEEK_DISPATCHER}.
+   */
+  public void setSeekDispatcher(SeekDispatcher seekDispatcher) {
+    Assertions.checkState(controller != null);
+    controller.setSeekDispatcher(seekDispatcher);
+  }
+
   /**
    * Sets the rewind increment in milliseconds.
    *
    * @param rewindMs The rewind increment in milliseconds.
    */
   public void setRewindIncrementMs(int rewindMs) {
+    Assertions.checkState(controller != null);
     controller.setRewindIncrementMs(rewindMs);
   }
 
@@ -240,19 +502,41 @@ public void setRewindIncrementMs(int rewindMs) {
    * @param fastForwardMs The fast forward increment in milliseconds.
    */
   public void setFastForwardIncrementMs(int fastForwardMs) {
+    Assertions.checkState(controller != null);
     controller.setFastForwardIncrementMs(fastForwardMs);
   }
 
   /**
-   * Get the view onto which video is rendered. This is either a {@link SurfaceView} (default)
+   * Gets the view onto which video is rendered. This is either a {@link SurfaceView} (default)
    * or a {@link TextureView} if the {@code use_texture_view} view attribute has been set to true.
    *
-   * @return either a {@link SurfaceView} or a {@link TextureView}.
+   * @return Either a {@link SurfaceView} or a {@link TextureView}.
    */
   public View getVideoSurfaceView() {
     return surfaceView;
   }
 
+  /**
+   * Gets the overlay {@link FrameLayout}, which can be populated with UI elements to show on top of
+   * the player.
+   *
+   * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
+   *     the overlay is not present.
+   */
+  public FrameLayout getOverlayFrameLayout() {
+    return overlayFrameLayout;
+  }
+
+  /**
+   * Gets the {@link SubtitleView}.
+   *
+   * @return The {@link SubtitleView}, or {@code null} if the layout has been customized and the
+   *     subtitle view is not present.
+   */
+  public SubtitleView getSubtitleView() {
+    return subtitleView;
+  }
+
   @Override
   public boolean onTouchEvent(MotionEvent ev) {
     if (!useController || player == null || ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
@@ -275,11 +559,6 @@ public boolean onTrackballEvent(MotionEvent ev) {
     return true;
   }
 
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    return useController ? controller.dispatchKeyEvent(event) : super.dispatchKeyEvent(event);
-  }
-
   private void maybeShowController(boolean isForced) {
     if (!useController || player == null) {
       return;
@@ -294,6 +573,84 @@ private void maybeShowController(boolean isForced) {
     }
   }
 
+  private void updateForCurrentTrackSelections() {
+    if (player == null) {
+      return;
+    }
+    TrackSelectionArray selections = player.getCurrentTrackSelections();
+    for (int i = 0; i < selections.length; i++) {
+      if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
+        // Video enabled so artwork must be hidden. If the shutter is closed, it will be opened in
+        // onRenderedFirstFrame().
+        hideArtwork();
+        return;
+      }
+    }
+    // Video disabled so the shutter must be closed.
+    if (shutterView != null) {
+      shutterView.setVisibility(VISIBLE);
+    }
+    // Display artwork if enabled and available, else hide it.
+    if (useArtwork) {
+      for (int i = 0; i < selections.length; i++) {
+        TrackSelection selection = selections.get(i);
+        if (selection != null) {
+          for (int j = 0; j < selection.length(); j++) {
+            Metadata metadata = selection.getFormat(j).metadata;
+            if (metadata != null && setArtworkFromMetadata(metadata)) {
+              return;
+            }
+          }
+        }
+      }
+      if (setArtworkFromBitmap(defaultArtwork)) {
+        return;
+      }
+    }
+    // Artwork disabled or unavailable.
+    hideArtwork();
+  }
+
+  private boolean setArtworkFromMetadata(Metadata metadata) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Metadata.Entry metadataEntry = metadata.get(i);
+      if (metadataEntry instanceof ApicFrame) {
+        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
+        return setArtworkFromBitmap(bitmap);
+      }
+    }
+    return false;
+  }
+
+  private boolean setArtworkFromBitmap(Bitmap bitmap) {
+    if (bitmap != null) {
+      int bitmapWidth = bitmap.getWidth();
+      int bitmapHeight = bitmap.getHeight();
+      if (bitmapWidth > 0 && bitmapHeight > 0) {
+        if (contentFrame != null) {
+          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
+        }
+        artworkView.setImageBitmap(bitmap);
+        artworkView.setVisibility(VISIBLE);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private void hideArtwork() {
+    if (artworkView != null) {
+      artworkView.setImageResource(android.R.color.transparent); // Clears any bitmap reference.
+      artworkView.setVisibility(INVISIBLE);
+    }
+  }
+
+  @SuppressWarnings("ResourceType")
+  private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
+    aspectRatioFrame.setResizeMode(resizeMode);
+  }
+
   private final class ComponentListener implements SimpleExoPlayer.VideoListener,
       TextRenderer.Output, ExoPlayer.EventListener {
 
@@ -301,7 +658,9 @@ private void maybeShowController(boolean isForced) {
 
     @Override
     public void onCues(List<Cue> cues) {
-      subtitleLayout.onCues(cues);
+      if (subtitleView != null) {
+        subtitleView.onCues(cues);
+      }
     }
 
     // SimpleExoPlayer.VideoListener implementation
@@ -309,17 +668,22 @@ public void onCues(List<Cue> cues) {
     @Override
     public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
         float pixelWidthHeightRatio) {
-      layout.setAspectRatio(height == 0 ? 1 : (width * pixelWidthHeightRatio) / height);
+      if (contentFrame != null) {
+        float aspectRatio = height == 0 ? 1 : (width * pixelWidthHeightRatio) / height;
+        contentFrame.setAspectRatio(aspectRatio);
+      }
     }
 
     @Override
     public void onRenderedFirstFrame() {
-      shutterView.setVisibility(GONE);
+      if (shutterView != null) {
+        shutterView.setVisibility(INVISIBLE);
+      }
     }
 
     @Override
-    public void onVideoTracksDisabled() {
-      shutterView.setVisibility(VISIBLE);
+    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
+      updateForCurrentTrackSelections();
     }
 
     // ExoPlayer.EventListener implementation
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index 8c3ac77cb2..04f3b986bd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -146,9 +146,13 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       // Nothing to draw.
       return;
     }
+
+    int windowColor = cue.windowColorSet ? cue.windowColor : style.windowColor;
+
     if (!applyEmbeddedStyles) {
       // Strip out any embedded styling.
       cueText = cueText.toString();
+      windowColor = style.windowColor;
     }
     if (areCharSequencesEqual(this.cueText, cueText)
         && Util.areEqual(this.cueTextAlignment, cue.textAlignment)
@@ -161,7 +165,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
         && this.applyEmbeddedStyles == applyEmbeddedStyles
         && this.foregroundColor == style.foregroundColor
         && this.backgroundColor == style.backgroundColor
-        && this.windowColor == style.windowColor
+        && this.windowColor == windowColor
         && this.edgeType == style.edgeType
         && this.edgeColor == style.edgeColor
         && Util.areEqual(this.textPaint.getTypeface(), style.typeface)
@@ -187,7 +191,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
     this.applyEmbeddedStyles = applyEmbeddedStyles;
     this.foregroundColor = style.foregroundColor;
     this.backgroundColor = style.backgroundColor;
-    this.windowColor = style.windowColor;
+    this.windowColor = windowColor;
     this.edgeType = style.edgeType;
     this.edgeColor = style.edgeColor;
     this.textPaint.setTypeface(style.typeface);
@@ -252,7 +256,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
         if (cueLine >= 0) {
           anchorPosition = Math.round(cueLine * firstLineHeight) + parentTop;
         } else {
-          anchorPosition = Math.round(cueLine * firstLineHeight) + parentBottom;
+          anchorPosition = Math.round((cueLine + 1) * firstLineHeight) + parentBottom;
         }
       }
       textTop = cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 0c8d9ef92e..49516ab6f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -122,10 +122,10 @@ public void setFixedTextSize(int unit, float size) {
 
   /**
    * Sets the text size to one derived from {@link CaptioningManager#getFontScale()}, or to a
-   * default size on API level 19 and earlier.
+   * default size before API level 19.
    */
   public void setUserDefaultTextSize() {
-    float fontScale = Util.SDK_INT >= 19 ? getUserCaptionFontScaleV19() : 1f;
+    float fontScale = Util.SDK_INT >= 19 && !isInEditMode() ? getUserCaptionFontScaleV19() : 1f;
     setFractionalTextSize(DEFAULT_TEXT_SIZE_FRACTION * fontScale);
   }
 
@@ -180,10 +180,11 @@ public void setApplyEmbeddedStyles(boolean applyEmbeddedStyles) {
 
   /**
    * Sets the caption style to be equivalent to the one returned by
-   * {@link CaptioningManager#getUserStyle()}, or to a default style on API level 19 and earlier.
+   * {@link CaptioningManager#getUserStyle()}, or to a default style before API level 19.
    */
   public void setUserDefaultStyle() {
-    setStyle(Util.SDK_INT >= 19 ? getUserCaptionStyleV19() : CaptionStyleCompat.DEFAULT);
+    setStyle(Util.SDK_INT >= 19 && !isInEditMode()
+        ? getUserCaptionStyleV19() : CaptionStyleCompat.DEFAULT);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index 0ddf17cbe9..4a2354e180 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -65,7 +65,7 @@
    * @param buffer The buffer into which the read data should be stored.
    * @param offset The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is avaliable
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is available
    *     because the end of the opened range has been reached.
    * @throws IOException If an error occurs reading from the source.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
index ae591d889b..c4296bd6f6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
@@ -67,20 +67,12 @@ public void open() throws IOException {
   @Override
   public int read() throws IOException {
     int length = read(singleByteArray);
-    if (length == -1) {
-      return -1;
-    }
-    totalBytesRead++;
-    return singleByteArray[0] & 0xFF;
+    return length == -1 ? -1 : (singleByteArray[0] & 0xFF);
   }
 
   @Override
   public int read(byte[] buffer) throws IOException {
-    int bytesRead = read(buffer, 0, buffer.length);
-    if (bytesRead != -1) {
-      totalBytesRead += bytesRead;
-    }
-    return bytesRead;
+    return read(buffer, 0, buffer.length);
   }
 
   @Override
@@ -96,15 +88,6 @@ public int read(byte[] buffer, int offset, int length) throws IOException {
     }
   }
 
-  @Override
-  public long skip(long byteCount) throws IOException {
-    Assertions.checkState(!closed);
-    checkOpened();
-    long bytesSkipped = super.skip(byteCount);
-    totalBytesRead += bytesSkipped;
-    return bytesSkipped;
-  }
-
   @Override
   public void close() throws IOException {
     if (!closed) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index d251446976..133e71f6e2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -32,7 +32,7 @@
    * The flags that apply to any request for data.
    */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP})
+  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
   public @interface Flags {}
   /**
    * Permits an underlying network stack to request that the server use gzip compression.
@@ -45,7 +45,10 @@
    * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from
    * {@link DataSource#read(byte[], int, int)} will be the decompressed data.
    */
-  public static final int FLAG_ALLOW_GZIP = 1;
+  public static final int FLAG_ALLOW_GZIP = 1 << 0;
+
+  /** Permits content to be cached even if its length can not be resolved. */
+  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1;
 
   /**
    * The source from which data should be read.
@@ -76,7 +79,8 @@
    */
   public final String key;
   /**
-   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} is the only supported flag.
+   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} and
+   * {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} are the only supported flags.
    */
   @Flags
   public final int flags;
@@ -167,6 +171,15 @@ public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long posi
     this.flags = flags;
   }
 
+  /**
+   * Returns whether the given flag is set.
+   *
+   * @param flag Flag to be checked if it is set.
+   */
+  public boolean isFlagSet(@Flags int flag) {
+    return (this.flags & flag) == flag;
+  }
+
   @Override
   public String toString() {
     return "DataSpec[" + uri + ", " + Arrays.toString(postBody) + ", " + absoluteStreamPosition
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index b326c41b18..ca0fda9399 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -230,7 +230,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
-    if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
+    if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
       if (dataSpec.length != C.LENGTH_UNSET) {
         bytesToRead = dataSpec.length;
       } else {
@@ -343,7 +343,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     byte[] postBody = dataSpec.postBody;
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index dcfed59145..615eb4df97 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 
 /** A {@link Factory} that produces {@link DefaultHttpDataSource} instances. */
-public final class DefaultHttpDataSourceFactory implements Factory {
+public final class DefaultHttpDataSourceFactory extends BaseFactory {
 
   private final String userAgent;
   private final TransferListener<? super DataSource> listener;
@@ -75,8 +76,9 @@ public DefaultHttpDataSourceFactory(String userAgent,
   }
 
   @Override
-  public DefaultHttpDataSource createDataSource() {
+  protected DefaultHttpDataSource createDataSourceInternal() {
     return new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
         readTimeoutMillis, allowCrossProtocolRedirects);
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index f915ee4e24..8df8624102 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -17,11 +17,13 @@
 
 import android.support.annotation.IntDef;
 import android.text.TextUtils;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -38,6 +40,86 @@
     @Override
     HttpDataSource createDataSource();
 
+    /**
+     * Sets a default request header field for {@link HttpDataSource} instances subsequently
+     * created by the factory. Previously created instances are not affected.
+     *
+     * @param name The name of the header field.
+     * @param value The value of the field.
+     */
+    void setDefaultRequestProperty(String name, String value);
+
+    /**
+     * Clears a default request header field for {@link HttpDataSource} instances subsequently
+     * created by the factory. Previously created instances are not affected.
+     *
+     * @param name The name of the header field.
+     */
+    void clearDefaultRequestProperty(String name);
+
+    /**
+     * Clears all default request header fields for all {@link HttpDataSource} instances
+     * subsequently created by the factory.  Previously created instances are not affected.
+     */
+    void clearAllDefaultRequestProperties();
+
+  }
+
+  /**
+   * Base implementation of {@link Factory} that sets default request properties.
+   */
+  abstract class BaseFactory implements Factory {
+
+    private final HashMap<String, String> requestProperties;
+
+    public BaseFactory() {
+      requestProperties = new HashMap<>();
+    }
+
+    @Override
+    public final HttpDataSource createDataSource() {
+      HttpDataSource dataSource = createDataSourceInternal();
+      synchronized (requestProperties) {
+        for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+          dataSource.setRequestProperty(property.getKey(), property.getValue());
+        }
+      }
+      return dataSource;
+    }
+
+    @Override
+    public final void setDefaultRequestProperty(String name, String value) {
+      Assertions.checkNotNull(name);
+      Assertions.checkNotNull(value);
+      synchronized (requestProperties) {
+        requestProperties.put(name, value);
+      }
+    }
+
+    @Override
+    public final void clearDefaultRequestProperty(String name) {
+      Assertions.checkNotNull(name);
+      synchronized (requestProperties) {
+        requestProperties.remove(name);
+      }
+    }
+
+    @Override
+    public final void clearAllDefaultRequestProperties() {
+      synchronized (requestProperties) {
+        requestProperties.clear();
+      }
+    }
+
+    /**
+     * Called by {@link #createDataSource()} to create a {@link HttpDataSource} instance without
+     * default request properties set. Default request properties will be set by
+     * {@link #createDataSource()} before the instance is returned.
+     *
+     * @return A {@link HttpDataSource} instance without default request properties set.
+     */
+    protected abstract HttpDataSource createDataSourceInternal();
+
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/LoaderErrorThrower.java b/library/src/main/java/com/google/android/exoplayer2/upstream/LoaderErrorThrower.java
index e5d62378b3..4f9e9fa5e6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/LoaderErrorThrower.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/LoaderErrorThrower.java
@@ -43,4 +43,21 @@
    */
   void maybeThrowError(int minRetryCount) throws IOException;
 
+  /**
+   * A {@link LoaderErrorThrower} that never throws.
+   */
+  final class Dummy implements LoaderErrorThrower {
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      // Do nothing.
+    }
+
+    @Override
+    public void maybeThrowError(int minRetryCount) throws IOException {
+      // Do nothing.
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index 9059f3817f..c25638ac86 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -113,8 +114,8 @@ public final void load() throws IOException, InterruptedException {
       inputStream.open();
       result = parser.parse(dataSource.getUri(), inputStream);
     } finally {
-      inputStream.close();
       bytesLoaded = inputStream.bytesRead();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 3a9ea0cff0..0b7b85b8c3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -54,7 +54,7 @@ public RawResourceDataSourceException(IOException e) {
    * @param rawResourceId A raw resource identifier (i.e. a constant defined in {@code R.raw}).
    * @return The corresponding {@link Uri}.
    */
-  public static final Uri buildRawResourceUri(int rawResourceId) {
+  public static Uri buildRawResourceUri(int rawResourceId) {
     return Uri.parse(RAW_RESOURCE_SCHEME + ":///" + rawResourceId);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index a8a8de4361..8dcfe75670 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.NavigableSet;
 import java.util.Set;
 
@@ -60,6 +61,21 @@
     void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan);
 
   }
+  
+  /**
+   * Thrown when an error is encountered when writing data.
+   */
+  class CacheException extends IOException {
+
+    public CacheException(String message) {
+      super(message);
+    }
+
+    public CacheException(IOException cause) {
+      super(cause);
+    }
+
+  }
 
   /**
    * Registers a listener to listen for changes to a given key.
@@ -125,7 +141,7 @@
    * @return The {@link CacheSpan}.
    * @throws InterruptedException
    */
-  CacheSpan startReadWrite(String key, long position) throws InterruptedException;
+  CacheSpan startReadWrite(String key, long position) throws InterruptedException, CacheException;
 
   /**
    * Same as {@link #startReadWrite(String, long)}. However, if the cache entry is locked, then
@@ -135,7 +151,7 @@
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}. Or null if the cache entry is locked.
    */
-  CacheSpan startReadWriteNonBlocking(String key, long position);
+  CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
 
   /**
    * Obtains a cache file into which data can be written. Must only be called when holding a
@@ -147,7 +163,7 @@
    *     is enough space in the cache.
    * @return The file into which data should be written.
    */
-  File startFile(String key, long position, long maxLength);
+  File startFile(String key, long position, long maxLength) throws CacheException;
 
   /**
    * Commits a file into the cache. Must only be called when holding a corresponding hole
@@ -155,7 +171,7 @@
    *
    * @param file A newly written cache file.
    */
-  void commitFile(File file);
+  void commitFile(File file) throws CacheException;
 
   /**
    * Releases a {@link CacheSpan} obtained from {@link #startReadWrite(String, long)} which
@@ -170,7 +186,7 @@
    *
    * @param span The {@link CacheSpan} to remove.
    */
-  void removeSpan(CacheSpan span);
+  void removeSpan(CacheSpan span) throws CacheException;
 
  /**
   * Queries if a range is entirely available in the cache.
@@ -187,10 +203,8 @@
    *
    * @param key The cache key for the data.
    * @param length The length of the data.
-   * @return Whether the length was set successfully. Returns false if the length conflicts with the
-   *     existing contents of the cache.
    */
-  boolean setContentLength(String key, long length);
+  void setContentLength(String key, long length) throws CacheException;
 
   /**
    * Returns the content length for the given key if one set, or {@link
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 96c198b4c9..71397bd403 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -18,12 +18,14 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
 
 /**
  * Writes data into a cache.
@@ -32,17 +34,20 @@
 
   private final Cache cache;
   private final long maxCacheFileSize;
+  private final int bufferSize;
 
   private DataSpec dataSpec;
   private File file;
-  private FileOutputStream outputStream;
+  private OutputStream outputStream;
+  private FileOutputStream underlyingFileOutputStream;
   private long outputStreamBytesWritten;
   private long dataSpecBytesWritten;
+  private ReusableBufferedOutputStream bufferedOutputStream;
 
   /**
    * Thrown when IOException is encountered when writing data into sink.
    */
-  public static class CacheDataSinkException extends IOException {
+  public static class CacheDataSinkException extends CacheException {
 
     public CacheDataSinkException(IOException cause) {
       super(cause);
@@ -50,7 +55,6 @@ public CacheDataSinkException(IOException cause) {
 
   }
 
-
   /**
    * @param cache The cache into which data should be written.
    * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
@@ -58,27 +62,42 @@ public CacheDataSinkException(IOException cause) {
    *    multiple cache files.
    */
   public CacheDataSink(Cache cache, long maxCacheFileSize) {
+    this(cache, maxCacheFileSize, 0);
+  }
+
+  /**
+   * @param cache The cache into which data should be written.
+   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
+   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
+   *    multiple cache files.
+   * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
+   *    value disables buffering.
+   */
+  public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
     this.cache = Assertions.checkNotNull(cache);
     this.maxCacheFileSize = maxCacheFileSize;
+    this.bufferSize = bufferSize;
   }
 
   @Override
   public void open(DataSpec dataSpec) throws CacheDataSinkException {
-    this.dataSpec = dataSpec;
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec.length == C.LENGTH_UNSET
+        && !dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH)) {
+      this.dataSpec = null;
       return;
     }
+    this.dataSpec = dataSpec;
     dataSpecBytesWritten = 0;
     try {
       openNextOutputStream();
-    } catch (FileNotFoundException e) {
+    } catch (IOException e) {
       throw new CacheDataSinkException(e);
     }
   }
 
   @Override
   public void write(byte[] buffer, int offset, int length) throws CacheDataSinkException {
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -102,7 +121,7 @@ public void write(byte[] buffer, int offset, int length) throws CacheDataSinkExc
 
   @Override
   public void close() throws CacheDataSinkException {
-    if (dataSpec == null || dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -112,13 +131,27 @@ public void close() throws CacheDataSinkException {
     }
   }
 
-  private void openNextOutputStream() throws FileNotFoundException {
+  private void openNextOutputStream() throws IOException {
+    long maxLength = dataSpec.length == C.LENGTH_UNSET ? maxCacheFileSize
+        : Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize);
     file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
-        Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize));
-    outputStream = new FileOutputStream(file);
+        maxLength);
+    underlyingFileOutputStream = new FileOutputStream(file);
+    if (bufferSize > 0) {
+      if (bufferedOutputStream == null) {
+        bufferedOutputStream = new ReusableBufferedOutputStream(underlyingFileOutputStream,
+            bufferSize);
+      } else {
+        bufferedOutputStream.reset(underlyingFileOutputStream);
+      }
+      outputStream = bufferedOutputStream;
+    } else {
+      outputStream = underlyingFileOutputStream;
+    }
     outputStreamBytesWritten = 0;
   }
 
+  @SuppressWarnings("ThrowFromFinallyBlock")
   private void closeCurrentOutputStream() throws IOException {
     if (outputStream == null) {
       return;
@@ -127,17 +160,18 @@ private void closeCurrentOutputStream() throws IOException {
     boolean success = false;
     try {
       outputStream.flush();
-      outputStream.getFD().sync();
+      underlyingFileOutputStream.getFD().sync();
       success = true;
     } finally {
       Util.closeQuietly(outputStream);
+      outputStream = null;
+      File fileToCommit = file;
+      file = null;
       if (success) {
-        cache.commitFile(file);
+        cache.commitFile(fileToCommit);
       } else {
-        file.delete();
+        fileToCommit.delete();
       }
-      outputStream = null;
-      file = null;
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
index 95def56b8e..0c8c006e2c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Sink Project
+ * Copyright (C) 2016 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 727eb068ce..9b29984d06 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -17,7 +17,6 @@
 
 import android.net.Uri;
 import android.support.annotation.IntDef;
-import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -25,7 +24,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.TeeDataSource;
-import com.google.android.exoplayer2.upstream.cache.CacheDataSink.CacheDataSinkException;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.lang.annotation.Retention;
@@ -51,7 +50,7 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_BLOCK_ON_CACHE, FLAG_IGNORE_CACHE_ON_ERROR,
-      FLAG_CACHE_UNBOUNDED_REQUESTS})
+      FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS})
   public @interface Flags {}
   /**
    * A flag indicating whether we will block reads if the cache key is locked. If this flag is
@@ -67,11 +66,9 @@
   public static final int FLAG_IGNORE_CACHE_ON_ERROR = 1 << 1;
 
   /**
-   * A flag indicating whether the response is cached if the range of the request is unbounded.
-   * Disabled by default because, as a side effect, this may allow streams with every chunk from a
-   * separate URL cached which is broken currently.
+   * A flag indicating that the cache should be bypassed for requests whose lengths are unset.
    */
-  public static final int FLAG_CACHE_UNBOUNDED_REQUESTS = 1 << 2;
+  public static final int FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS = 1 << 2;
 
   /**
    * Listener of {@link CacheDataSource} events.
@@ -88,8 +85,6 @@
 
   }
 
-  private static final String TAG = "CacheDataSource";
-
   private final Cache cache;
   private final DataSource cacheReadDataSource;
   private final DataSource cacheWriteDataSource;
@@ -98,7 +93,7 @@
 
   private final boolean blockOnCache;
   private final boolean ignoreCacheOnError;
-  private final boolean bypassUnboundedRequests;
+  private final boolean ignoreCacheForUnsetLengthRequests;
 
   private DataSource currentDataSource;
   private boolean currentRequestUnbounded;
@@ -127,8 +122,8 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags) {
    *
    * @param cache The cache.
    * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_CACHE_UNBOUNDED_REQUESTS} or 0.
+   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE} and {@link
+   *     #FLAG_IGNORE_CACHE_ON_ERROR} or 0.
    * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the cached data size
    *     exceeds this value, then the data will be fragmented into multiple cache files. The
    *     finer-grained this is the finer-grained the eviction policy can be.
@@ -148,8 +143,8 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
    * @param upstream A {@link DataSource} for reading data not in the cache.
    * @param cacheReadDataSource A {@link DataSource} for reading data from the cache.
    * @param cacheWriteDataSink A {@link DataSink} for writing data to the cache.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_CACHE_UNBOUNDED_REQUESTS} or 0.
+   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE} and {@link
+   *     #FLAG_IGNORE_CACHE_ON_ERROR} or 0.
    * @param eventListener An optional {@link EventListener} to receive events.
    */
   public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
@@ -158,7 +153,8 @@ public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDat
     this.cacheReadDataSource = cacheReadDataSource;
     this.blockOnCache = (flags & FLAG_BLOCK_ON_CACHE) != 0;
     this.ignoreCacheOnError = (flags & FLAG_IGNORE_CACHE_ON_ERROR) != 0;
-    this.bypassUnboundedRequests = (flags & FLAG_CACHE_UNBOUNDED_REQUESTS) == 0;
+    this.ignoreCacheForUnsetLengthRequests =
+        (flags & FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS) != 0;
     this.upstreamDataSource = upstream;
     if (cacheWriteDataSink != null) {
       this.cacheWriteDataSource = new TeeDataSource(upstream, cacheWriteDataSink);
@@ -173,10 +169,10 @@ public long open(DataSpec dataSpec) throws IOException {
     try {
       uri = dataSpec.uri;
       flags = dataSpec.flags;
-      key = dataSpec.key;
+      key = dataSpec.key != null ? dataSpec.key : uri.toString();
       readPosition = dataSpec.position;
       currentRequestIgnoresCache = (ignoreCacheOnError && seenCacheError)
-          || (bypassUnboundedRequests && dataSpec.length == C.LENGTH_UNSET);
+          || (dataSpec.length == C.LENGTH_UNSET && ignoreCacheForUnsetLengthRequests);
       if (dataSpec.length != C.LENGTH_UNSET || currentRequestIgnoresCache) {
         bytesRemaining = dataSpec.length;
       } else {
@@ -334,18 +330,15 @@ private boolean openNextSource(boolean initial) throws IOException {
     // bytesRemaining == C.LENGTH_UNSET) and got a resolved length from open() request
     if (currentRequestUnbounded && currentBytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining = currentBytesRemaining;
-      // If writing into cache
-      if (lockedSpan != null) {
-        setContentLength(dataSpec.position + bytesRemaining);
-      }
+      setContentLength(dataSpec.position + bytesRemaining);
     }
     return successful;
   }
 
-  private void setContentLength(long length) {
-    if (!cache.setContentLength(key, length)) {
-      Log.e(TAG, "cache.setContentLength(" + length + ") failed. cache.getContentLength() = "
-          + cache.getContentLength(key));
+  private void setContentLength(long length) throws IOException {
+    // If writing into cache
+    if (currentDataSource == cacheWriteDataSource) {
+      cache.setContentLength(key, length);
     }
   }
 
@@ -366,7 +359,7 @@ private void closeCurrentSource() throws IOException {
   }
 
   private void handleBeforeThrow(IOException exception) {
-    if (currentDataSource == cacheReadDataSource || exception instanceof CacheDataSinkException) {
+    if (currentDataSource == cacheReadDataSource || exception instanceof CacheException) {
       seenCacheError = true;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
index 627bb7e2f4..8944b45033 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
@@ -22,7 +22,7 @@
 public interface CacheEvictor extends Cache.Listener {
 
   /**
-   * Called when cache has beeen initialized.
+   * Called when cache has been initialized.
    */
   void onCacheInitialized();
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
index d706f4f006..fb96c0fb0e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
@@ -16,21 +16,12 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Util;
 import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * Defines a span of data that may or may not be cached (as indicated by {@link #isCached}).
  */
-public final class CacheSpan implements Comparable<CacheSpan> {
-
-  private static final String SUFFIX = ".v2.exo";
-  private static final Pattern CACHE_FILE_PATTERN_V1 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
-  private static final Pattern CACHE_FILE_PATTERN_V2 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
+public class CacheSpan implements Comparable<CacheSpan> {
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -57,64 +48,34 @@
    */
   public final long lastAccessTimestamp;
 
-  public static File getCacheFileName(File cacheDir, String key, long offset,
-      long lastAccessTimestamp) {
-    return new File(cacheDir,
-        Util.escapeFileName(key) + "." + offset + "." + lastAccessTimestamp + SUFFIX);
-  }
-
-  public static CacheSpan createLookup(String key, long position) {
-    return new CacheSpan(key, position, C.LENGTH_UNSET, false, C.TIME_UNSET, null);
-  }
-
-  public static CacheSpan createOpenHole(String key, long position) {
-    return new CacheSpan(key, position, C.LENGTH_UNSET, false, C.TIME_UNSET, null);
-  }
-
-  public static CacheSpan createClosedHole(String key, long position, long length) {
-    return new CacheSpan(key, position, length, false, C.TIME_UNSET, null);
-  }
-
   /**
-   * Creates a cache span from an underlying cache file.
+   * Creates a hole CacheSpan which isn't cached, has no last access time and no file associated.
    *
-   * @param file The cache file.
-   * @return The span, or null if the file name is not correctly formatted.
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
+   *     open-ended hole.
    */
-  public static CacheSpan createCacheEntry(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(file.getName());
-    if (!matcher.matches()) {
-      return null;
-    }
-    String key = Util.unescapeFileName(matcher.group(1));
-    return key == null ? null : createCacheEntry(
-        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
+  public CacheSpan(String key, long position, long length) {
+    this(key, position, length, C.TIME_UNSET, null);
   }
 
-  static File upgradeIfNeeded(File file) {
-    Matcher matcher = CACHE_FILE_PATTERN_V1.matcher(file.getName());
-    if (!matcher.matches()) {
-      return file;
-    }
-    String key = matcher.group(1); // Keys were not escaped in version 1.
-    File newCacheFile = getCacheFileName(file.getParentFile(), key,
-        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
-    file.renameTo(newCacheFile);
-    return newCacheFile;
-  }
-
-  private static CacheSpan createCacheEntry(String key, long position, long lastAccessTimestamp,
-      File file) {
-    return new CacheSpan(key, position, file.length(), true, lastAccessTimestamp, file);
-  }
-
-  // Visible for testing.
-  CacheSpan(String key, long position, long length, boolean isCached,
-      long lastAccessTimestamp, File file) {
+  /**
+   * Creates a CacheSpan.
+   *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
+   *     open-ended hole.
+   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if
+   *     {@link #isCached} is false.
+   * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
+   */
+  public CacheSpan(String key, long position, long length, long lastAccessTimestamp, File file) {
     this.key = key;
     this.position = position;
     this.length = length;
-    this.isCached = isCached;
+    this.isCached = file != null;
     this.file = file;
     this.lastAccessTimestamp = lastAccessTimestamp;
   }
@@ -127,15 +88,10 @@ public boolean isOpenEnded() {
   }
 
   /**
-   * Renames the file underlying this cache span to update its last access time.
-   *
-   * @return A {@link CacheSpan} representing the updated cache file.
+   * Returns whether this is a hole {@link CacheSpan}.
    */
-  public CacheSpan touch() {
-    long now = System.currentTimeMillis();
-    File newCacheFile = getCacheFileName(file.getParentFile(), key, position, now);
-    file.renameTo(newCacheFile);
-    return createCacheEntry(key, position, now, newCacheFile);
+  public boolean isHoleSpan() {
+    return !isCached;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
new file mode 100644
index 0000000000..c744a176ad
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.TreeSet;
+
+/**
+ * Defines the cached content for a single stream.
+ */
+/*package*/ final class CachedContent {
+
+  /**
+   * The cache file id that uniquely identifies the original stream.
+   */
+  public final int id;
+  /**
+   * The cache key that uniquely identifies the original stream.
+   */
+  public final String key;
+  /**
+   * The cached spans of this content.
+   */
+  private final TreeSet<SimpleCacheSpan> cachedSpans;
+  /**
+   * The length of the original stream, or {@link C#LENGTH_UNSET} if the length is unknown.
+   */
+  private long length;
+
+  /**
+   * Reads an instance from a {@link DataInputStream}.
+   *
+   * @param input Input stream containing values needed to initialize CachedContent instance.
+   * @throws IOException If an error occurs during reading values.
+   */
+  public CachedContent(DataInputStream input) throws IOException {
+    this(input.readInt(), input.readUTF(), input.readLong());
+  }
+
+  /**
+   * Creates a CachedContent.
+   *
+   * @param id The cache file id.
+   * @param key The cache stream key.
+   * @param length The length of the original stream.
+   */
+  public CachedContent(int id, String key, long length) {
+    this.id = id;
+    this.key = key;
+    this.length = length;
+    this.cachedSpans = new TreeSet<>();
+  }
+
+  /**
+   * Writes the instance to a {@link DataOutputStream}.
+   *
+   * @param output Output stream to store the values.
+   * @throws IOException If an error occurs during writing values to output.
+   */
+  public void writeToStream(DataOutputStream output) throws IOException {
+    output.writeInt(id);
+    output.writeUTF(key);
+    output.writeLong(length);
+  }
+
+  /** Returns the length of the content. */
+  public long getLength() {
+    return length;
+  }
+
+  /** Sets the length of the content. */
+  public void setLength(long length) {
+    this.length = length;
+  }
+
+  /** Adds the given {@link SimpleCacheSpan} which contains a part of the content. */
+  public void addSpan(SimpleCacheSpan span) {
+    cachedSpans.add(span);
+  }
+
+  /** Returns a set of all {@link SimpleCacheSpan}s. */
+  public TreeSet<SimpleCacheSpan> getSpans() {
+    return cachedSpans;
+  }
+
+  /**
+   * Returns the span containing the position. If there isn't one, it returns a hole span
+   * which defines the maximum extents of the hole in the cache.
+   */
+  public SimpleCacheSpan getSpan(long position) {
+    SimpleCacheSpan span = getSpanInternal(position);
+    if (!span.isCached) {
+      SimpleCacheSpan ceilEntry = cachedSpans.ceiling(span);
+      return ceilEntry == null ? SimpleCacheSpan.createOpenHole(key, position)
+          : SimpleCacheSpan.createClosedHole(key, position, ceilEntry.position - position);
+    }
+    return span;
+  }
+
+  /** Queries if a range is entirely available in the cache. */
+  public boolean isCached(long position, long length) {
+    SimpleCacheSpan floorSpan = getSpanInternal(position);
+    if (!floorSpan.isCached) {
+      // We don't have a span covering the start of the queried region.
+      return false;
+    }
+    long queryEndPosition = position + length;
+    long currentEndPosition = floorSpan.position + floorSpan.length;
+    if (currentEndPosition >= queryEndPosition) {
+      // floorSpan covers the queried region.
+      return true;
+    }
+    for (SimpleCacheSpan next : cachedSpans.tailSet(floorSpan, false)) {
+      if (next.position > currentEndPosition) {
+        // There's a hole in the cache within the queried region.
+        return false;
+      }
+      // We expect currentEndPosition to always equal (next.position + next.length), but
+      // perform a max check anyway to guard against the existence of overlapping spans.
+      currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
+      if (currentEndPosition >= queryEndPosition) {
+        // We've found spans covering the queried region.
+        return true;
+      }
+    }
+    // We ran out of spans before covering the queried region.
+    return false;
+  }
+
+  /**
+   * Copies the given span with an updated last access time. Passed span becomes invalid after this
+   * call.
+   *
+   * @param cacheSpan Span to be copied and updated.
+   * @return a span with the updated last access time.
+   * @throws CacheException If renaming of the underlying span file failed.
+   */
+  public SimpleCacheSpan touch(SimpleCacheSpan cacheSpan) throws CacheException {
+    // Remove the old span from the in-memory representation.
+    Assertions.checkState(cachedSpans.remove(cacheSpan));
+    // Obtain a new span with updated last access timestamp.
+    SimpleCacheSpan newCacheSpan = cacheSpan.copyWithUpdatedLastAccessTime(id);
+    // Rename the cache file
+    if (!cacheSpan.file.renameTo(newCacheSpan.file)) {
+      throw new CacheException("Renaming of " + cacheSpan.file + " to " + newCacheSpan.file
+          + " failed.");
+    }
+    // Add the updated span back into the in-memory representation.
+    cachedSpans.add(newCacheSpan);
+    return newCacheSpan;
+  }
+
+  /** Returns whether there are any spans cached. */
+  public boolean isEmpty() {
+    return cachedSpans.isEmpty();
+  }
+
+  /** Removes the given span from cache. */
+  public boolean removeSpan(CacheSpan span) {
+    if (cachedSpans.remove(span)) {
+      span.file.delete();
+      return true;
+    }
+    return false;
+  }
+
+  /** Calculates a hash code for the header of this {@code CachedContent}. */
+  public int headerHashCode() {
+    int result = id;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + (int) (length ^ (length >>> 32));
+    return result;
+  }
+
+  /**
+   * Returns the span containing the position. If there isn't one, it returns the lookup span it
+   * used for searching.
+   */
+  private SimpleCacheSpan getSpanInternal(long position) {
+    SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);
+    SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);
+    return floorSpan == null || floorSpan.position + floorSpan.length <= position ? lookupSpan
+        : floorSpan;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
new file mode 100644
index 0000000000..58cc70d68d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.util.Log;
+import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.AtomicFile;
+import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
+import com.google.android.exoplayer2.util.Util;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Set;
+import javax.crypto.Cipher;
+import javax.crypto.CipherInputStream;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * This class maintains the index of cached content.
+ */
+/*package*/ final class CachedContentIndex {
+
+  public static final String FILE_NAME = "cached_content_index.exi";
+
+  private static final int VERSION = 1;
+
+  private static final int FLAG_ENCRYPTED_INDEX = 1;
+
+  private static final String TAG = "CachedContentIndex";
+
+  private final HashMap<String, CachedContent> keyToContent;
+  private final SparseArray<String> idToKey;
+  private final AtomicFile atomicFile;
+  private final Cipher cipher;
+  private final SecretKeySpec secretKeySpec;
+  private boolean changed;
+  private ReusableBufferedOutputStream bufferedOutputStream;
+
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   */
+  public CachedContentIndex(File cacheDir) {
+    this(cacheDir, null);
+  }
+
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
+   *     The key must be 16 bytes long.
+   */
+  public CachedContentIndex(File cacheDir, byte[] secretKey) {
+    if (secretKey != null) {
+      Assertions.checkArgument(secretKey.length == 16);
+      try {
+        cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
+        secretKeySpec = new SecretKeySpec(secretKey, "AES");
+      } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
+        throw new IllegalStateException(e); // Should never happen.
+      }
+    } else {
+      cipher = null;
+      secretKeySpec = null;
+    }
+    keyToContent = new HashMap<>();
+    idToKey = new SparseArray<>();
+    atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
+  }
+
+  /** Loads the index file. */
+  public void load() {
+    Assertions.checkState(!changed);
+    if (!readFile()) {
+      atomicFile.delete();
+      keyToContent.clear();
+      idToKey.clear();
+    }
+  }
+
+  /** Stores the index data to index file if there is a change. */
+  public void store() throws CacheException {
+    if (!changed) {
+      return;
+    }
+    writeFile();
+    changed = false;
+  }
+
+  /**
+   * Adds the given key to the index if it isn't there already.
+   *
+   * @param key The cache key that uniquely identifies the original stream.
+   * @return A new or existing CachedContent instance with the given key.
+   */
+  public CachedContent add(String key) {
+    CachedContent cachedContent = keyToContent.get(key);
+    if (cachedContent == null) {
+      cachedContent = addNew(key, C.LENGTH_UNSET);
+    }
+    return cachedContent;
+  }
+
+  /** Returns a CachedContent instance with the given key or null if there isn't one. */
+  public CachedContent get(String key) {
+    return keyToContent.get(key);
+  }
+
+  /**
+   * Returns a Collection of all CachedContent instances in the index. The collection is backed by
+   * the {@code keyToContent} map, so changes to the map are reflected in the collection, and
+   * vice-versa. If the map is modified while an iteration over the collection is in progress
+   * (except through the iterator's own remove operation), the results of the iteration are
+   * undefined.
+   */
+  public Collection<CachedContent> getAll() {
+    return keyToContent.values();
+  }
+
+  /** Returns an existing or new id assigned to the given key. */
+  public int assignIdForKey(String key) {
+    return add(key).id;
+  }
+
+  /** Returns the key which has the given id assigned. */
+  public String getKeyForId(int id) {
+    return idToKey.get(id);
+  }
+
+  /**
+   * Removes {@link CachedContent} with the given key from index. It shouldn't contain any spans.
+   *
+   * @throws IllegalStateException If {@link CachedContent} isn't empty.
+   */
+  public void removeEmpty(String key) {
+    CachedContent cachedContent = keyToContent.remove(key);
+    if (cachedContent != null) {
+      Assertions.checkState(cachedContent.isEmpty());
+      idToKey.remove(cachedContent.id);
+      changed = true;
+    }
+  }
+
+  /** Removes empty {@link CachedContent} instances from index. */
+  public void removeEmpty() {
+    LinkedList<String> cachedContentToBeRemoved = new LinkedList<>();
+    for (CachedContent cachedContent : keyToContent.values()) {
+      if (cachedContent.isEmpty()) {
+        cachedContentToBeRemoved.add(cachedContent.key);
+      }
+    }
+    for (String key : cachedContentToBeRemoved) {
+      removeEmpty(key);
+    }
+  }
+
+  /**
+   * Returns a set of all content keys. The set is backed by the {@code keyToContent} map, so
+   * changes to the map are reflected in the set, and vice-versa. If the map is modified while an
+   * iteration over the set is in progress (except through the iterator's own remove operation), the
+   * results of the iteration are undefined.
+   */
+  public Set<String> getKeys() {
+    return keyToContent.keySet();
+  }
+
+  /**
+   * Sets the content length for the given key. A new {@link CachedContent} is added if there isn't
+   * one already with the given key.
+   */
+  public void setContentLength(String key, long length) {
+    CachedContent cachedContent = get(key);
+    if (cachedContent != null) {
+      if (cachedContent.getLength() != length) {
+        cachedContent.setLength(length);
+        changed = true;
+      }
+    } else {
+      addNew(key, length);
+    }
+  }
+
+  /**
+   * Returns the content length for the given key if one set, or {@link
+   * com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
+   */
+  public long getContentLength(String key) {
+    CachedContent cachedContent = get(key);
+    return cachedContent == null ? C.LENGTH_UNSET : cachedContent.getLength();
+  }
+
+  private boolean readFile() {
+    DataInputStream input = null;
+    try {
+      InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
+      input = new DataInputStream(inputStream);
+      int version = input.readInt();
+      if (version != VERSION) {
+        // Currently there is no other version
+        return false;
+      }
+
+      int flags = input.readInt();
+      if ((flags & FLAG_ENCRYPTED_INDEX) != 0) {
+        if (cipher == null) {
+          return false;
+        }
+        byte[] initializationVector = new byte[16];
+        input.readFully(initializationVector);
+        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+        try {
+          cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
+        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+          throw new IllegalStateException(e);
+        }
+        input = new DataInputStream(new CipherInputStream(inputStream, cipher));
+      } else {
+        if (cipher != null) {
+          changed = true; // Force index to be rewritten encrypted after read.
+        }
+      }
+
+      int count = input.readInt();
+      int hashCode = 0;
+      for (int i = 0; i < count; i++) {
+        CachedContent cachedContent = new CachedContent(input);
+        add(cachedContent);
+        hashCode += cachedContent.headerHashCode();
+      }
+      if (input.readInt() != hashCode) {
+        return false;
+      }
+    } catch (FileNotFoundException e) {
+      return false;
+    } catch (IOException e) {
+      Log.e(TAG, "Error reading cache content index file.", e);
+      return false;
+    } finally {
+      if (input != null) {
+        Util.closeQuietly(input);
+      }
+    }
+    return true;
+  }
+
+  private void writeFile() throws CacheException {
+    DataOutputStream output = null;
+    try {
+      OutputStream outputStream = atomicFile.startWrite();
+      if (bufferedOutputStream == null) {
+        bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
+      } else {
+        bufferedOutputStream.reset(outputStream);
+      }
+      output = new DataOutputStream(bufferedOutputStream);
+      output.writeInt(VERSION);
+
+      int flags = cipher != null ? FLAG_ENCRYPTED_INDEX : 0;
+      output.writeInt(flags);
+
+      if (cipher != null) {
+        byte[] initializationVector = new byte[16];
+        new Random().nextBytes(initializationVector);
+        output.write(initializationVector);
+        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
+        try {
+          cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
+        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
+          throw new IllegalStateException(e); // Should never happen.
+        }
+        output.flush();
+        output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
+      }
+
+      output.writeInt(keyToContent.size());
+      int hashCode = 0;
+      for (CachedContent cachedContent : keyToContent.values()) {
+        cachedContent.writeToStream(output);
+        hashCode += cachedContent.headerHashCode();
+      }
+      output.writeInt(hashCode);
+      atomicFile.endWrite(output);
+      // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
+      // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
+      output = null;
+    } catch (IOException e) {
+      throw new CacheException(e);
+    } finally {
+      Util.closeQuietly(output);
+    }
+  }
+
+  private void add(CachedContent cachedContent) {
+    keyToContent.put(cachedContent.key, cachedContent);
+    idToKey.put(cachedContent.id, cachedContent.key);
+  }
+
+  /** Adds the given CachedContent to the index. */
+  /*package*/ void addNew(CachedContent cachedContent) {
+    add(cachedContent);
+    changed = true;
+  }
+
+  private CachedContent addNew(String key, long length) {
+    int id = getNewId(idToKey);
+    CachedContent cachedContent = new CachedContent(id, key, length);
+    addNew(cachedContent);
+    return cachedContent;
+  }
+
+  /**
+   * Returns an id which isn't used in the given array. If the maximum id in the array is smaller
+   * than {@link java.lang.Integer#MAX_VALUE} it just returns the next bigger integer. Otherwise it
+   * returns the smallest unused non-negative integer.
+   */
+  //@VisibleForTesting
+  public static int getNewId(SparseArray<String> idToKey) {
+    int size = idToKey.size();
+    int id = size == 0 ? 0 : (idToKey.keyAt(size - 1) + 1);
+    if (id < 0) { // In case if we pass max int value.
+      // TODO optimization: defragmentation or binary search?
+      for (id = 0; id < size; id++) {
+        if (id != idToKey.keyAt(id)) {
+          break;
+        }
+      }
+    }
+    return id;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
new file mode 100644
index 0000000000..0f08ca40f2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.util.Log;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NavigableSet;
+import java.util.TreeSet;
+
+/**
+ * Utility class for efficiently tracking regions of data that are stored in a {@link Cache}
+ * for a given cache key.
+ */
+public final class CachedRegionTracker implements Cache.Listener {
+
+  private static final String TAG = "CachedRegionTracker";
+
+  public static final int NOT_CACHED = -1;
+  public static final int CACHED_TO_END = -2;
+
+  private final Cache cache;
+  private final String cacheKey;
+  private final ChunkIndex chunkIndex;
+
+  private final TreeSet<Region> regions;
+  private final Region lookupRegion;
+
+  public CachedRegionTracker(Cache cache, String cacheKey, ChunkIndex chunkIndex) {
+    this.cache = cache;
+    this.cacheKey = cacheKey;
+    this.chunkIndex = chunkIndex;
+    this.regions = new TreeSet<>();
+    this.lookupRegion = new Region(0, 0);
+
+    synchronized (this) {
+      NavigableSet<CacheSpan> cacheSpans = cache.addListener(cacheKey, this);
+      if (cacheSpans != null) {
+        // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
+        // which is why a descending iterator is used here.
+        Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
+        while (spanIterator.hasNext()) {
+          CacheSpan span = spanIterator.next();
+          mergeSpan(span);
+        }
+      }
+    }
+  }
+
+  public void release() {
+    cache.removeListener(cacheKey, this);
+  }
+
+  /**
+   * When provided with a byte offset, this method locates the cached region within which the
+   * offset falls, and returns the approximate end position in milliseconds of that region. If the
+   * byte offset does not fall within a cached region then {@link #NOT_CACHED} is returned.
+   * If the cached region extends to the end of the stream, {@link #CACHED_TO_END} is returned.
+   *
+   * @param byteOffset The byte offset in the underlying stream.
+   * @return The end position of the corresponding cache region, {@link #NOT_CACHED}, or
+   *     {@link #CACHED_TO_END}.
+   */
+  public synchronized int getRegionEndTimeMs(long byteOffset) {
+    lookupRegion.startOffset = byteOffset;
+    Region floorRegion = regions.floor(lookupRegion);
+    if (floorRegion == null || byteOffset > floorRegion.endOffset
+        || floorRegion.endOffsetIndex == -1) {
+      return NOT_CACHED;
+    }
+    int index = floorRegion.endOffsetIndex;
+    if (index == chunkIndex.length - 1
+        && floorRegion.endOffset == (chunkIndex.offsets[index] + chunkIndex.sizes[index])) {
+      return CACHED_TO_END;
+    }
+    long segmentFractionUs = (chunkIndex.durationsUs[index]
+        * (floorRegion.endOffset - chunkIndex.offsets[index])) / chunkIndex.sizes[index];
+    return (int) ((chunkIndex.timesUs[index] + segmentFractionUs) / 1000);
+  }
+
+  @Override
+  public synchronized void onSpanAdded(Cache cache, CacheSpan span) {
+    mergeSpan(span);
+  }
+
+  @Override
+  public synchronized void onSpanRemoved(Cache cache, CacheSpan span) {
+    Region removedRegion = new Region(span.position, span.position + span.length);
+
+    // Look up a region this span falls into.
+    Region floorRegion = regions.floor(removedRegion);
+    if (floorRegion == null) {
+      Log.e(TAG, "Removed a span we were not aware of");
+      return;
+    }
+
+    // Remove it.
+    regions.remove(floorRegion);
+
+    // Add new floor and ceiling regions, if necessary.
+    if (floorRegion.startOffset < removedRegion.startOffset) {
+      Region newFloorRegion = new Region(floorRegion.startOffset, removedRegion.startOffset);
+
+      int index = Arrays.binarySearch(chunkIndex.offsets, newFloorRegion.endOffset);
+      newFloorRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newFloorRegion);
+    }
+
+    if (floorRegion.endOffset > removedRegion.endOffset) {
+      Region newCeilingRegion = new Region(removedRegion.endOffset + 1, floorRegion.endOffset);
+      newCeilingRegion.endOffsetIndex = floorRegion.endOffsetIndex;
+      regions.add(newCeilingRegion);
+    }
+  }
+
+  @Override
+  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
+    // Do nothing.
+  }
+
+  private void mergeSpan(CacheSpan span) {
+    Region newRegion = new Region(span.position, span.position + span.length);
+    Region floorRegion = regions.floor(newRegion);
+    Region ceilingRegion = regions.ceiling(newRegion);
+    boolean floorConnects = regionsConnect(floorRegion, newRegion);
+    boolean ceilingConnects = regionsConnect(newRegion, ceilingRegion);
+
+    if (ceilingConnects) {
+      if (floorConnects) {
+        // Extend floorRegion to cover both newRegion and ceilingRegion.
+        floorRegion.endOffset = ceilingRegion.endOffset;
+        floorRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+      } else {
+        // Extend newRegion to cover ceilingRegion. Add it.
+        newRegion.endOffset = ceilingRegion.endOffset;
+        newRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+        regions.add(newRegion);
+      }
+      regions.remove(ceilingRegion);
+    } else if (floorConnects) {
+      // Extend floorRegion to the right to cover newRegion.
+      floorRegion.endOffset = newRegion.endOffset;
+      int index = floorRegion.endOffsetIndex;
+      while (index < chunkIndex.length - 1
+          && (chunkIndex.offsets[index + 1] <= floorRegion.endOffset)) {
+        index++;
+      }
+      floorRegion.endOffsetIndex = index;
+    } else {
+      // This is a new region.
+      int index = Arrays.binarySearch(chunkIndex.offsets, newRegion.endOffset);
+      newRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newRegion);
+    }
+  }
+
+  private boolean regionsConnect(Region lower, Region upper) {
+    return lower != null && upper != null && lower.endOffset == upper.startOffset;
+  }
+
+  private static class Region implements Comparable<Region> {
+
+    /**
+     * The first byte of the region (inclusive).
+     */
+    public long startOffset;
+    /**
+     * End offset of the region (exclusive).
+     */
+    public long endOffset;
+    /**
+     * The index in chunkIndex that contains the end offset. May be -1 if the end offset comes
+     * before the start of the first media chunk (i.e. if the end offset is within the stream
+     * header).
+     */
+    public int endOffsetIndex;
+
+    public Region(long position, long endOffset) {
+      this.startOffset = position;
+      this.endOffset = endOffset;
+    }
+
+    @Override
+    public int compareTo(Region another) {
+      return startOffset < another.startOffset ? -1
+          : startOffset == another.startOffset ? 0 : 1;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 791fb677f1..d2a84f65f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import java.util.Comparator;
 import java.util.TreeSet;
 
@@ -74,7 +75,11 @@ public int compare(CacheSpan lhs, CacheSpan rhs) {
 
   private void evictCache(Cache cache, long requiredSpace) {
     while (currentSize + requiredSpace > maxBytes) {
-      cache.removeSpan(leastRecentlyUsed.first());
+      try {
+        cache.removeSpan(leastRecentlyUsed.first());
+      } catch (CacheException e) {
+        // do nothing.
+      }
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index a2f2596ad5..e3e887c6ed 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -16,16 +16,13 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.os.ConditionVariable;
-
-import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map.Entry;
+import java.util.LinkedList;
 import java.util.NavigableSet;
 import java.util.Set;
 import java.util.TreeSet;
@@ -38,21 +35,36 @@
   private final File cacheDir;
   private final CacheEvictor evictor;
   private final HashMap<String, CacheSpan> lockedSpans;
-  private final HashMap<String, Pair<Long, TreeSet<CacheSpan>>> cachedSpans;
+  private final CachedContentIndex index;
   private final HashMap<String, ArrayList<Listener>> listeners;
   private long totalSpace = 0;
+  private CacheException initializationException;
 
   /**
    * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
    * the directory cannot be used to store other files.
    *
    * @param cacheDir A dedicated cache directory.
+   * @param evictor The evictor to be used.
    */
   public SimpleCache(File cacheDir, CacheEvictor evictor) {
+    this(cacheDir, evictor, null);
+  }
+
+  /**
+   * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
+   * the directory cannot be used to store other files.
+   *
+   * @param cacheDir A dedicated cache directory.
+   * @param evictor The evictor to be used.
+   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
+   *     The key must be 16 bytes long.
+   */
+  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey) {
     this.cacheDir = cacheDir;
     this.evictor = evictor;
     this.lockedSpans = new HashMap<>();
-    this.cachedSpans = new HashMap<>();
+    this.index = new CachedContentIndex(cacheDir, secretKey);
     this.listeners = new HashMap<>();
     // Start cache initialization.
     final ConditionVariable conditionVariable = new ConditionVariable();
@@ -61,7 +73,12 @@ public SimpleCache(File cacheDir, CacheEvictor evictor) {
       public void run() {
         synchronized (SimpleCache.this) {
           conditionVariable.open();
-          initialize();
+          try {
+            initialize();
+          } catch (CacheException e) {
+            initializationException = e;
+          }
+          SimpleCache.this.evictor.onCacheInitialized();
         }
       }
     }.start();
@@ -92,13 +109,13 @@ public synchronized void removeListener(String key, Listener listener) {
 
   @Override
   public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
-    TreeSet<CacheSpan> spansForKey = getSpansForKey(key);
-    return spansForKey == null ? null : new TreeSet<>(spansForKey);
+    CachedContent cachedContent = index.get(key);
+    return cachedContent == null ? null : new TreeSet<CacheSpan>(cachedContent.getSpans());
   }
 
   @Override
   public synchronized Set<String> getKeys() {
-    return new HashSet<>(cachedSpans.keySet());
+    return new HashSet<>(index.getKeys());
   }
 
   @Override
@@ -107,11 +124,10 @@ public synchronized long getCacheSpace() {
   }
 
   @Override
-  public synchronized CacheSpan startReadWrite(String key, long position)
-      throws InterruptedException {
-    CacheSpan lookupSpan = CacheSpan.createLookup(key, position);
+  public synchronized SimpleCacheSpan startReadWrite(String key, long position)
+      throws InterruptedException, CacheException {
     while (true) {
-      CacheSpan span = startReadWriteNonBlocking(lookupSpan);
+      SimpleCacheSpan span = startReadWriteNonBlocking(key, position);
       if (span != null) {
         return span;
       } else {
@@ -125,25 +141,25 @@ public synchronized CacheSpan startReadWrite(String key, long position)
   }
 
   @Override
-  public synchronized CacheSpan startReadWriteNonBlocking(String key, long position) {
-    return startReadWriteNonBlocking(CacheSpan.createLookup(key, position));
-  }
+  public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
+      throws CacheException {
+    if (initializationException != null) {
+      throw initializationException;
+    }
 
-  private synchronized CacheSpan startReadWriteNonBlocking(CacheSpan lookupSpan) {
-    CacheSpan cacheSpan = getSpan(lookupSpan);
+    SimpleCacheSpan cacheSpan = getSpan(key, position);
 
     // Read case.
     if (cacheSpan.isCached) {
       // Obtain a new span with updated last access timestamp.
-      CacheSpan newCacheSpan = cacheSpan.touch();
-      replaceSpan(cacheSpan, newCacheSpan);
+      SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
       notifySpanTouched(cacheSpan, newCacheSpan);
       return newCacheSpan;
     }
 
     // Write case, lock available.
-    if (!lockedSpans.containsKey(lookupSpan.key)) {
-      lockedSpans.put(lookupSpan.key, cacheSpan);
+    if (!lockedSpans.containsKey(key)) {
+      lockedSpans.put(key, cacheSpan);
       return cacheSpan;
     }
 
@@ -152,20 +168,22 @@ private synchronized CacheSpan startReadWriteNonBlocking(CacheSpan lookupSpan) {
   }
 
   @Override
-  public synchronized File startFile(String key, long position, long maxLength) {
+  public synchronized File startFile(String key, long position, long maxLength)
+      throws CacheException {
     Assertions.checkState(lockedSpans.containsKey(key));
     if (!cacheDir.exists()) {
       // For some reason the cache directory doesn't exist. Make a best effort to create it.
-      removeStaleSpans();
+      removeStaleSpansAndCachedContents();
       cacheDir.mkdirs();
     }
     evictor.onStartFile(this, key, position, maxLength);
-    return CacheSpan.getCacheFileName(cacheDir, key, position, System.currentTimeMillis());
+    return SimpleCacheSpan.getCacheFile(cacheDir, index.assignIdForKey(key), position,
+        System.currentTimeMillis());
   }
 
   @Override
-  public synchronized void commitFile(File file) {
-    CacheSpan span = CacheSpan.createCacheEntry(file);
+  public synchronized void commitFile(File file) throws CacheException {
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(file, index);
     Assertions.checkState(span != null);
     Assertions.checkState(lockedSpans.containsKey(span.key));
     // If the file doesn't exist, don't add it to the in-memory representation.
@@ -183,6 +201,7 @@ public synchronized void commitFile(File file) {
       Assertions.checkState((span.position + span.length) <= length);
     }
     addSpan(span);
+    index.store();
     notifyAll();
   }
 
@@ -193,67 +212,65 @@ public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
   }
 
   /**
-   * Returns the cache {@link CacheSpan} corresponding to the provided lookup {@link CacheSpan}.
-   * <p>
-   * If the lookup position is contained by an existing entry in the cache, then the returned
-   * {@link CacheSpan} defines the file in which the data is stored. If the lookup position is not
-   * contained by an existing entry, then the returned {@link CacheSpan} defines the maximum extents
-   * of the hole in the cache.
+   * Returns the cache {@link SimpleCacheSpan} corresponding to the provided lookup {@link
+   * SimpleCacheSpan}.
    *
-   * @param lookupSpan A lookup {@link CacheSpan} specifying a key and position.
-   * @return The corresponding cache {@link CacheSpan}.
+   * <p>If the lookup position is contained by an existing entry in the cache, then the returned
+   * {@link SimpleCacheSpan} defines the file in which the data is stored. If the lookup position is
+   * not contained by an existing entry, then the returned {@link SimpleCacheSpan} defines the
+   * maximum extents of the hole in the cache.
+   *
+   * @param key The key of the span being requested.
+   * @param position The position of the span being requested.
+   * @return The corresponding cache {@link SimpleCacheSpan}.
    */
-  private CacheSpan getSpan(CacheSpan lookupSpan) {
-    String key = lookupSpan.key;
-    long offset = lookupSpan.position;
-    TreeSet<CacheSpan> entries = getSpansForKey(key);
-    if (entries == null) {
-      return CacheSpan.createOpenHole(key, lookupSpan.position);
+  private SimpleCacheSpan getSpan(String key, long position) throws CacheException {
+    CachedContent cachedContent = index.get(key);
+    if (cachedContent == null) {
+      return SimpleCacheSpan.createOpenHole(key, position);
     }
-    CacheSpan floorSpan = entries.floor(lookupSpan);
-    if (floorSpan != null &&
-        floorSpan.position <= offset && offset < floorSpan.position + floorSpan.length) {
-      // The lookup position is contained within floorSpan.
-      if (floorSpan.file.exists()) {
-        return floorSpan;
-      } else {
+    while (true) {
+      SimpleCacheSpan span = cachedContent.getSpan(position);
+      if (span.isCached && !span.file.exists()) {
         // The file has been deleted from under us. It's likely that other files will have been
         // deleted too, so scan the whole in-memory representation.
-        removeStaleSpans();
-        return getSpan(lookupSpan);
+        removeStaleSpansAndCachedContents();
+        continue;
       }
+      return span;
     }
-    CacheSpan ceilEntry = entries.ceiling(lookupSpan);
-    return ceilEntry == null ? CacheSpan.createOpenHole(key, lookupSpan.position) :
-        CacheSpan.createClosedHole(key, lookupSpan.position,
-            ceilEntry.position - lookupSpan.position);
   }
 
   /**
    * Ensures that the cache's in-memory representation has been initialized.
    */
-  private void initialize() {
+  private void initialize() throws CacheException {
     if (!cacheDir.exists()) {
       cacheDir.mkdirs();
+      return;
     }
+
+    index.load();
+
     File[] files = cacheDir.listFiles();
     if (files == null) {
       return;
     }
     for (File file : files) {
-      if (file.length() == 0) {
-        file.delete();
+      if (file.getName().equals(CachedContentIndex.FILE_NAME)) {
+        continue;
+      }
+      SimpleCacheSpan span = file.length() > 0
+          ? SimpleCacheSpan.createCacheEntry(file, index) : null;
+      if (span != null) {
+        addSpan(span);
       } else {
-        file = CacheSpan.upgradeIfNeeded(file);
-        CacheSpan span = CacheSpan.createCacheEntry(file);
-        if (span == null) {
-          file.delete();
-        } else {
-          addSpan(span);
-        }
+        file.delete();
       }
     }
-    evictor.onCacheInitialized();
+
+    index.removeEmpty();
+    index.store();
   }
 
   /**
@@ -261,59 +278,47 @@ private void initialize() {
    *
    * @param span The span to be added.
    */
-  private void addSpan(CacheSpan span) {
-    Pair<Long, TreeSet<CacheSpan>> entryForKey = cachedSpans.get(span.key);
-    TreeSet<CacheSpan> spansForKey;
-    if (entryForKey == null) {
-      spansForKey = new TreeSet<>();
-      setKeyValue(span.key, C.LENGTH_UNSET, spansForKey);
-    } else {
-      spansForKey = entryForKey.second;
-    }
-    spansForKey.add(span);
+  private void addSpan(SimpleCacheSpan span) {
+    index.add(span.key).addSpan(span);
     totalSpace += span.length;
     notifySpanAdded(span);
   }
 
-  @Override
-  public synchronized void removeSpan(CacheSpan span) {
-    TreeSet<CacheSpan> spansForKey = getSpansForKey(span.key);
+  private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {
+    CachedContent cachedContent = index.get(span.key);
+    Assertions.checkState(cachedContent.removeSpan(span));
     totalSpace -= span.length;
-    Assertions.checkState(spansForKey.remove(span));
-    span.file.delete();
-    if (spansForKey.isEmpty()) {
-      cachedSpans.remove(span.key);
+    if (removeEmptyCachedContent && cachedContent.isEmpty()) {
+      index.removeEmpty(cachedContent.key);
+      index.store();
     }
     notifySpanRemoved(span);
   }
 
+  @Override
+  public synchronized void removeSpan(CacheSpan span) throws CacheException {
+    removeSpan(span, true);
+  }
+
   /**
    * Scans all of the cached spans in the in-memory representation, removing any for which files
    * no longer exist.
    */
-  private void removeStaleSpans() {
-    Iterator<Entry<String, Pair<Long, TreeSet<CacheSpan>>>> iterator =
-        cachedSpans.entrySet().iterator();
-    while (iterator.hasNext()) {
-      Entry<String, Pair<Long, TreeSet<CacheSpan>>> next = iterator.next();
-      Iterator<CacheSpan> spanIterator = next.getValue().second.iterator();
-      boolean isEmpty = true;
-      while (spanIterator.hasNext()) {
-        CacheSpan span = spanIterator.next();
+  private void removeStaleSpansAndCachedContents() throws CacheException {
+    LinkedList<CacheSpan> spansToBeRemoved = new LinkedList<>();
+    for (CachedContent cachedContent : index.getAll()) {
+      for (CacheSpan span : cachedContent.getSpans()) {
         if (!span.file.exists()) {
-          spanIterator.remove();
-          if (span.isCached) {
-            totalSpace -= span.length;
-          }
-          notifySpanRemoved(span);
-        } else {
-          isEmpty = false;
+          spansToBeRemoved.add(span);
         }
       }
-      if (isEmpty) {
-        iterator.remove();
-      }
     }
+    for (CacheSpan span : spansToBeRemoved) {
+      // Remove span but not CachedContent to prevent multiple index.store() calls.
+      removeSpan(span, false);
+    }
+    index.removeEmpty();
+    index.store();
   }
 
   private void notifySpanRemoved(CacheSpan span) {
@@ -326,7 +331,7 @@ private void notifySpanRemoved(CacheSpan span) {
     evictor.onSpanRemoved(this, span);
   }
 
-  private void notifySpanAdded(CacheSpan span) {
+  private void notifySpanAdded(SimpleCacheSpan span) {
     ArrayList<Listener> keyListeners = listeners.get(span.key);
     if (keyListeners != null) {
       for (int i = keyListeners.size() - 1; i >= 0; i--) {
@@ -336,7 +341,7 @@ private void notifySpanAdded(CacheSpan span) {
     evictor.onSpanAdded(this, span);
   }
 
-  private void notifySpanTouched(CacheSpan oldSpan, CacheSpan newSpan) {
+  private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
     ArrayList<Listener> keyListeners = listeners.get(oldSpan.key);
     if (keyListeners != null) {
       for (int i = keyListeners.size() - 1; i >= 0; i--) {
@@ -348,82 +353,19 @@ private void notifySpanTouched(CacheSpan oldSpan, CacheSpan newSpan) {
 
   @Override
   public synchronized boolean isCached(String key, long position, long length) {
-    TreeSet<CacheSpan> entries = getSpansForKey(key);
-    if (entries == null) {
-      return false;
-    }
-    CacheSpan lookupSpan = CacheSpan.createLookup(key, position);
-    CacheSpan floorSpan = entries.floor(lookupSpan);
-    if (floorSpan == null || floorSpan.position + floorSpan.length <= position) {
-      // We don't have a span covering the start of the queried region.
-      return false;
-    }
-    long queryEndPosition = position + length;
-    long currentEndPosition = floorSpan.position + floorSpan.length;
-    if (currentEndPosition >= queryEndPosition) {
-      // floorSpan covers the queried region.
-      return true;
-    }
-    for (CacheSpan next : entries.tailSet(floorSpan, false)) {
-      if (next.position > currentEndPosition) {
-        // There's a hole in the cache within the queried region.
-        return false;
-      }
-      // We expect currentEndPosition to always equal (next.position + next.length), but
-      // perform a max check anyway to guard against the existence of overlapping spans.
-      currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
-      if (currentEndPosition >= queryEndPosition) {
-        // We've found spans covering the queried region.
-        return true;
-      }
-    }
-    // We ran out of spans before covering the queried region.
-    return false;
+    CachedContent cachedContent = index.get(key);
+    return cachedContent != null && cachedContent.isCached(position, length);
   }
 
   @Override
-  public synchronized boolean setContentLength(String key, long length) {
-    Pair<Long, TreeSet<CacheSpan>> entryForKey = cachedSpans.get(key);
-    TreeSet<CacheSpan> entries;
-    if (entryForKey != null) {
-      entries = entryForKey.second;
-      if (entries != null && !entries.isEmpty()) {
-        CacheSpan last = entries.last();
-        long end = last.position + last.length;
-        if (end > length) {
-          return false;
-        }
-      }
-    } else {
-      entries = new TreeSet<>();
-    }
-    // TODO persist the length value
-    setKeyValue(key, length, entries);
-    return true;
+  public synchronized void setContentLength(String key, long length) throws CacheException {
+    index.setContentLength(key, length);
+    index.store();
   }
 
   @Override
   public synchronized long getContentLength(String key) {
-    Pair<Long, TreeSet<CacheSpan>> entryForKey = cachedSpans.get(key);
-    return entryForKey == null ? C.LENGTH_UNSET : entryForKey.first;
-  }
-
-
-  private TreeSet<CacheSpan> getSpansForKey(String key) {
-    Pair<Long, TreeSet<CacheSpan>> entryForKey = cachedSpans.get(key);
-    return entryForKey != null ? entryForKey.second : null;
-  }
-
-  private void setKeyValue(String key, long length, TreeSet<CacheSpan> entries) {
-    cachedSpans.put(key, Pair.create(length, entries));
-  }
-
-  private void replaceSpan(CacheSpan oldSpan, CacheSpan newSpan) {
-    // Remove the old span from the in-memory representation.
-    TreeSet<CacheSpan> spansForKey = getSpansForKey(oldSpan.key);
-    Assertions.checkState(spansForKey.remove(oldSpan));
-    // Add the updated span back into the in-memory representation.
-    spansForKey.add(newSpan);
+    return index.getContentLength(key);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
new file mode 100644
index 0000000000..8c5b7e26e7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * This class stores span metadata in filename.
+ */
+/*package*/ final class SimpleCacheSpan extends CacheSpan {
+
+  private static final String SUFFIX = ".v3.exo";
+  private static final Pattern CACHE_FILE_PATTERN_V1 = Pattern.compile(
+      "^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
+  private static final Pattern CACHE_FILE_PATTERN_V2 = Pattern.compile(
+      "^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
+  private static final Pattern CACHE_FILE_PATTERN_V3 = Pattern.compile(
+      "^(\\d+)\\.(\\d+)\\.(\\d+)\\.v3\\.exo$", Pattern.DOTALL);
+
+  public static File getCacheFile(File cacheDir, int id, long position,
+      long lastAccessTimestamp) {
+    return new File(cacheDir, id + "." + position + "." + lastAccessTimestamp + SUFFIX);
+  }
+
+  public static SimpleCacheSpan createLookup(String key, long position) {
+    return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
+  }
+
+  public static SimpleCacheSpan createOpenHole(String key, long position) {
+    return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
+  }
+
+  public static SimpleCacheSpan createClosedHole(String key, long position, long length) {
+    return new SimpleCacheSpan(key, position, length, C.TIME_UNSET, null);
+  }
+
+  /**
+   * Creates a cache span from an underlying cache file. Upgrades the file if necessary.
+   *
+   * @param file The cache file.
+   * @param index Cached content index.
+   * @return The span, or null if the file name is not correctly formatted, or if the id is not
+   *     present in the content index.
+   */
+  public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex index) {
+    String name = file.getName();
+    if (!name.endsWith(SUFFIX)) {
+      file = upgradeFile(file, index);
+      if (file == null) {
+        return null;
+      }
+      name = file.getName();
+    }
+
+    Matcher matcher = CACHE_FILE_PATTERN_V3.matcher(name);
+    if (!matcher.matches()) {
+      return null;
+    }
+    long length = file.length();
+    int id = Integer.parseInt(matcher.group(1));
+    String key = index.getKeyForId(id);
+    return key == null ? null : new SimpleCacheSpan(key, Long.parseLong(matcher.group(2)), length,
+        Long.parseLong(matcher.group(3)), file);
+  }
+
+  private static File upgradeFile(File file, CachedContentIndex index) {
+    String key;
+    String filename = file.getName();
+    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(filename);
+    if (matcher.matches()) {
+      key = Util.unescapeFileName(matcher.group(1));
+      if (key == null) {
+        return null;
+      }
+    } else {
+      matcher = CACHE_FILE_PATTERN_V1.matcher(filename);
+      if (!matcher.matches()) {
+        return null;
+      }
+      key = matcher.group(1); // Keys were not escaped in version 1.
+    }
+
+    File newCacheFile = getCacheFile(file.getParentFile(), index.assignIdForKey(key),
+        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
+    if (!file.renameTo(newCacheFile)) {
+      return null;
+    }
+    return newCacheFile;
+  }
+
+  private SimpleCacheSpan(String key, long position, long length, long lastAccessTimestamp,
+      File file) {
+    super(key, position, length, lastAccessTimestamp, file);
+  }
+
+  /**
+   * Returns a copy of this CacheSpan whose last access time stamp is set to current time. This
+   * doesn't copy or change the underlying cache file.
+   *
+   * @param id The cache file id.
+   * @return A {@link SimpleCacheSpan} with updated last access time stamp.
+   * @throws IllegalStateException If called on a non-cached span (i.e. {@link #isCached} is false).
+   */
+  public SimpleCacheSpan copyWithUpdatedLastAccessTime(int id) {
+    Assertions.checkState(isCached);
+    long now = System.currentTimeMillis();
+    File newCacheFile = getCacheFile(file.getParentFile(), id, position, now);
+    return new SimpleCacheSpan(key, position, length, now, newCacheFile);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
new file mode 100644
index 0000000000..ccf9a5b3f5
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A wrapping {@link DataSink} that encrypts the data being consumed.
+ */
+public final class AesCipherDataSink implements DataSink {
+
+  private final DataSink wrappedDataSink;
+  private final byte[] secretKey;
+  private final byte[] scratch;
+
+  private AesFlushingCipher cipher;
+
+  /**
+   * Create an instance whose {@code write} methods have the side effect of overwriting the input
+   * {@code data}. Use this constructor for maximum efficiency in the case that there is no
+   * requirement for the input data arrays to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink) {
+    this(secretKey, wrappedDataSink, null);
+  }
+
+  /**
+   * Create an instance whose {@code write} methods are free of side effects. Use this constructor
+   * when the input data arrays are required to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   * @param scratch Scratch space. Data is decrypted into this array before being written to the
+   *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
+   *     write is larger than the size of this array the write will still succeed, but multiple
+   *     cipher calls will be required to complete the operation.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, byte[] scratch) {
+    this.wrappedDataSink = wrappedDataSink;
+    this.secretKey = secretKey;
+    this.scratch = scratch;
+  }
+
+  @Override
+  public void open(DataSpec dataSpec) throws IOException {
+    wrappedDataSink.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+  }
+
+  @Override
+  public void write(byte[] data, int offset, int length) throws IOException {
+    if (scratch == null) {
+      // In-place mode. Writes over the input data.
+      cipher.updateInPlace(data, offset, length);
+      wrappedDataSink.write(data, offset, length);
+    } else {
+      // Use scratch space. The original data remains intact.
+      int bytesProcessed = 0;
+      while (bytesProcessed < length) {
+        int bytesToProcess = Math.min(length - bytesProcessed, scratch.length);
+        cipher.update(data, offset + bytesProcessed, bytesToProcess, scratch, 0);
+        wrappedDataSink.write(scratch, 0, bytesToProcess);
+        bytesProcessed += bytesToProcess;
+      }
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    wrappedDataSink.close();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
new file mode 100644
index 0000000000..26ac3b38fa
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A {@link DataSource} that decrypts the data read from an upstream source.
+ */
+public final class AesCipherDataSource implements DataSource {
+
+  private final DataSource upstream;
+  private final byte[] secretKey;
+
+  private AesFlushingCipher cipher;
+
+  public AesCipherDataSource(byte[] secretKey, DataSource upstream) {
+    this.upstream = upstream;
+    this.secretKey = secretKey;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    long dataLength = upstream.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+    return dataLength;
+  }
+
+  @Override
+  public int read(byte[] data, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    }
+    int read = upstream.read(data, offset, readLength);
+    if (read == C.RESULT_END_OF_INPUT) {
+      return C.RESULT_END_OF_INPUT;
+    }
+    cipher.updateInPlace(data, offset, read);
+    return read;
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    upstream.close();
+  }
+
+  @Override
+  public Uri getUri() {
+    return upstream.getUri();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
new file mode 100644
index 0000000000..e093eb3064
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.util.Assertions;
+import java.nio.ByteBuffer;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.Cipher;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * A flushing variant of a AES/CTR/NoPadding {@link Cipher}.
+ *
+ * Unlike a regular {@link Cipher}, the update methods of this class are guaranteed to process all
+ * of the bytes input (and hence output the same number of bytes).
+ */
+public final class AesFlushingCipher {
+
+  private final Cipher cipher;
+  private final int blockSize;
+  private final byte[] zerosBlock;
+  private final byte[] flushedBlock;
+
+  private int pendingXorBytes;
+
+  public AesFlushingCipher(int mode, byte[] secretKey, long nonce, long offset) {
+    try {
+      cipher = Cipher.getInstance("AES/CTR/NoPadding");
+      blockSize = cipher.getBlockSize();
+      zerosBlock = new byte[blockSize];
+      flushedBlock = new byte[blockSize];
+      long counter = offset / blockSize;
+      int startPadding = (int) (offset % blockSize);
+      cipher.init(mode, new SecretKeySpec(secretKey, cipher.getAlgorithm().split("/")[0]),
+          new IvParameterSpec(getInitializationVector(nonce, counter)));
+      if (startPadding != 0) {
+        updateInPlace(new byte[startPadding], 0, startPadding);
+      }
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
+        | InvalidAlgorithmParameterException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void updateInPlace(byte[] data, int offset, int length) {
+    update(data, offset, length, data, offset);
+  }
+
+  public void update(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    // If we previously flushed the cipher by inputting zeros up to a block boundary, then we need
+    // to manually transform the data that actually ended the block. See the comment below for more
+    // details.
+    while (pendingXorBytes > 0) {
+      out[outOffset] = (byte) (in[inOffset] ^ flushedBlock[blockSize - pendingXorBytes]);
+      outOffset++;
+      inOffset++;
+      pendingXorBytes--;
+      length--;
+      if (length == 0) {
+        return;
+      }
+    }
+
+    // Do the bulk of the update.
+    int written = nonFlushingUpdate(in, inOffset, length, out, outOffset);
+    if (length == written) {
+      return;
+    }
+
+    // We need to finish the block to flush out the remaining bytes. We do so by inputting zeros,
+    // so that the corresponding bytes output by the cipher are those that would have been XORed
+    // against the real end-of-block data to transform it. We store these bytes so that we can
+    // perform the transformation manually in the case of a subsequent call to this method with
+    // the real data.
+    int bytesToFlush = length - written;
+    Assertions.checkState(bytesToFlush < blockSize);
+    outOffset += written;
+    pendingXorBytes = blockSize - bytesToFlush;
+    written = nonFlushingUpdate(zerosBlock, 0, pendingXorBytes, flushedBlock, 0);
+    Assertions.checkState(written == blockSize);
+    // The first part of xorBytes contains the flushed data, which we copy out. The remainder
+    // contains the bytes that will be needed for manual transformation in a subsequent call.
+    for (int i = 0; i < bytesToFlush; i++) {
+      out[outOffset++] = flushedBlock[i];
+    }
+  }
+
+  private int nonFlushingUpdate(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    try {
+      return cipher.update(in, inOffset, length, out, outOffset);
+    } catch (ShortBufferException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  private byte[] getInitializationVector(long nonce, long counter) {
+    return ByteBuffer.allocate(16).putLong(nonce).putLong(counter).array();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
new file mode 100644
index 0000000000..ff8841fa9c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+/**
+ * Utility functions for the crypto package.
+ */
+/* package */ final class CryptoUtil {
+
+  private CryptoUtil() {}
+
+  /**
+   * Returns the hash value of the input as a long using the 64 bit FNV-1a hash function. The hash
+   * values produced by this function are less likely to collide than those produced by
+   * {@link #hashCode()}.
+   */
+  public static long getFNV64Hash(String input) {
+    if (input == null) {
+      return 0;
+    }
+
+    long hash = 0;
+    for (int i = 0; i < input.length(); i++) {
+      hash ^= input.charAt(i);
+      // This is equivalent to hash *= 0x100000001b3 (the FNV magic prime number).
+      hash += (hash << 1) + (hash << 4) + (hash << 5) + (hash << 7) + (hash << 8) + (hash << 40);
+    }
+    return hash;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
new file mode 100644
index 0000000000..c383c01453
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.util;
+
+import android.util.Log;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * A helper class for performing atomic operations on a file by creating a backup file until a write
+ * has successfully completed.
+ *
+ * <p>Atomic file guarantees file integrity by ensuring that a file has been completely written and
+ * sync'd to disk before removing its backup. As long as the backup file exists, the original file
+ * is considered to be invalid (left over from a previous attempt to write the file).
+ *
+ * <p>Atomic file does not confer any file locking semantics. Do not use this class when the file
+ * may be accessed or modified concurrently by multiple threads or processes. The caller is
+ * responsible for ensuring appropriate mutual exclusion invariants whenever it accesses the file.
+ */
+public final class AtomicFile {
+
+  private static final String TAG = "AtomicFile";
+
+  private final File baseName;
+  private final File backupName;
+
+  /**
+   * Create a new AtomicFile for a file located at the given File path. The secondary backup file
+   * will be the same file path with ".bak" appended.
+   */
+  public AtomicFile(File baseName) {
+    this.baseName = baseName;
+    backupName = new File(baseName.getPath() + ".bak");
+  }
+
+  /** Delete the atomic file. This deletes both the base and backup files. */
+  public void delete() {
+    baseName.delete();
+    backupName.delete();
+  }
+
+  /**
+   * Start a new write operation on the file. This returns an {@link OutputStream} to which you can
+   * write the new file data. If the whole data is written successfully you <em>must</em> call
+   * {@link #endWrite(OutputStream)}. On failure you should call {@link OutputStream#close()}
+   * only to free up resources used by it.
+   *
+   * <p>Example usage:
+   *
+   * <pre>
+   *   DataOutputStream dataOutput = null;
+   *   try {
+   *     OutputStream outputStream = atomicFile.startWrite();
+   *     dataOutput = new DataOutputStream(outputStream); // Wrapper stream
+   *     dataOutput.write(data1);
+   *     dataOutput.write(data2);
+   *     atomicFile.endWrite(dataOutput); // Pass wrapper stream
+   *   } finally{
+   *     if (dataOutput != null) {
+   *       dataOutput.close();
+   *     }
+   *   }
+   * </pre>
+   *
+   * <p>Note that if another thread is currently performing a write, this will simply replace
+   * whatever that thread is writing with the new file being written by this thread, and when the
+   * other thread finishes the write the new write operation will no longer be safe (or will be
+   * lost). You must do your own threading protection for access to AtomicFile.
+   */
+  public OutputStream startWrite() throws IOException {
+    // Rename the current file so it may be used as a backup during the next read
+    if (baseName.exists()) {
+      if (!backupName.exists()) {
+        if (!baseName.renameTo(backupName)) {
+          Log.w(TAG, "Couldn't rename file " + baseName + " to backup file " + backupName);
+        }
+      } else {
+        baseName.delete();
+      }
+    }
+    OutputStream str;
+    try {
+      str = new AtomicFileOutputStream(baseName);
+    } catch (FileNotFoundException e) {
+      File parent = baseName.getParentFile();
+      if (!parent.mkdirs()) {
+        throw new IOException("Couldn't create directory " + baseName);
+      }
+      try {
+        str = new AtomicFileOutputStream(baseName);
+      } catch (FileNotFoundException e2) {
+        throw new IOException("Couldn't create " + baseName);
+      }
+    }
+    return str;
+  }
+
+  /**
+   * Call when you have successfully finished writing to the stream returned by {@link
+   * #startWrite()}. This will close, sync, and commit the new data. The next attempt to read the
+   * atomic file will return the new file stream.
+   *
+   * @param str Outer-most wrapper OutputStream used to write to the stream returned by {@link
+   *     #startWrite()}.
+   * @see #startWrite()
+   */
+  public void endWrite(OutputStream str) throws IOException {
+    str.close();
+    // If close() throws exception, the next line is skipped.
+    backupName.delete();
+  }
+
+  /**
+   * Open the atomic file for reading. If there previously was an incomplete write, this will roll
+   * back to the last good data before opening for read.
+   *
+   * <p>Note that if another thread is currently performing a write, this will incorrectly consider
+   * it to be in the state of a bad write and roll back, causing the new data currently being
+   * written to be dropped. You must do your own threading protection for access to AtomicFile.
+   */
+  public InputStream openRead() throws FileNotFoundException {
+    restoreBackup();
+    return new FileInputStream(baseName);
+  }
+
+  private void restoreBackup() {
+    if (backupName.exists()) {
+      baseName.delete();
+      backupName.renameTo(baseName);
+    }
+  }
+
+  private static final class AtomicFileOutputStream extends OutputStream {
+
+    private final FileOutputStream fileOutputStream;
+    private boolean closed = false;
+
+    public AtomicFileOutputStream(File file) throws FileNotFoundException {
+      fileOutputStream = new FileOutputStream(file);
+    }
+
+    @Override
+    public void close() throws IOException {
+      if (closed) {
+        return;
+      }
+      closed = true;
+      flush();
+      try {
+        fileOutputStream.getFD().sync();
+      } catch (IOException e) {
+        Log.w(TAG, "Failed to sync file descriptor:", e);
+      }
+      fileOutputStream.close();
+    }
+
+    @Override
+    public void flush() throws IOException {
+      fileOutputStream.flush();
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+      fileOutputStream.write(b);
+    }
+
+    @Override
+    public void write(byte[] b) throws IOException {
+      fileOutputStream.write(b);
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+      fileOutputStream.write(b, off, len);
+    }
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index 4776e4d008..69d4229186 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -47,6 +47,8 @@
   public static final String AUDIO_MPEG_L1 = BASE_TYPE_AUDIO + "/mpeg-L1";
   public static final String AUDIO_MPEG_L2 = BASE_TYPE_AUDIO + "/mpeg-L2";
   public static final String AUDIO_RAW = BASE_TYPE_AUDIO + "/raw";
+  public static final String AUDIO_ALAW = BASE_TYPE_AUDIO + "/g711-alaw";
+  public static final String AUDIO_ULAW = BASE_TYPE_AUDIO + "/g711-mlaw";
   public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
   public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
   public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
@@ -58,22 +60,27 @@
   public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
   public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
   public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
+  public static final String AUDIO_ALAC = BASE_TYPE_AUDIO + "/alac";
 
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
 
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
+  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
   public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
   public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
-  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
-  public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4vtt";
+  public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4-vtt";
+  public static final String APPLICATION_MP4CEA608 = BASE_TYPE_APPLICATION + "/x-mp4-cea-608";
   public static final String APPLICATION_RAWCC = BASE_TYPE_APPLICATION + "/x-rawcc";
   public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
   public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
+  public static final String APPLICATION_SCTE35 = BASE_TYPE_APPLICATION + "/x-scte35";
+  public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
+  public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";
 
   private MimeTypes() {}
 
@@ -84,7 +91,7 @@ private MimeTypes() {}
    * @return Whether the top level type is audio.
    */
   public static boolean isAudio(String mimeType) {
-    return getTopLevelType(mimeType).equals(BASE_TYPE_AUDIO);
+    return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
   }
 
   /**
@@ -94,7 +101,7 @@ public static boolean isAudio(String mimeType) {
    * @return Whether the top level type is video.
    */
   public static boolean isVideo(String mimeType) {
-    return getTopLevelType(mimeType).equals(BASE_TYPE_VIDEO);
+    return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
   }
 
   /**
@@ -104,7 +111,7 @@ public static boolean isVideo(String mimeType) {
    * @return Whether the top level type is text.
    */
   public static boolean isText(String mimeType) {
-    return getTopLevelType(mimeType).equals(BASE_TYPE_TEXT);
+    return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
   }
 
   /**
@@ -114,7 +121,7 @@ public static boolean isText(String mimeType) {
    * @return Whether the top level type is application.
    */
   public static boolean isApplication(String mimeType) {
-    return getTopLevelType(mimeType).equals(BASE_TYPE_APPLICATION);
+    return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
   }
 
 
@@ -211,12 +218,16 @@ public static int getTrackType(String mimeType) {
     } else if (isVideo(mimeType)) {
       return C.TRACK_TYPE_VIDEO;
     } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
+        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_MP4CEA608.equals(mimeType)
         || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
         || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
         || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
         || APPLICATION_PGS.equals(mimeType)) {
       return C.TRACK_TYPE_TEXT;
-    } else if (APPLICATION_ID3.equals(mimeType)) {
+    } else if (APPLICATION_ID3.equals(mimeType)
+        || APPLICATION_EMSG.equals(mimeType)
+        || APPLICATION_SCTE35.equals(mimeType)
+        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
       return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
@@ -237,9 +248,12 @@ public static int getTrackTypeOfCodec(String codec) {
    * Returns the top-level type of {@code mimeType}.
    *
    * @param mimeType The mimeType whose top-level type is required.
-   * @return The top-level type.
+   * @return The top-level type, or null if the mimeType is null.
    */
   private static String getTopLevelType(String mimeType) {
+    if (mimeType == null) {
+      return null;
+    }
     int indexOfSlash = mimeType.indexOf('/');
     if (indexOfSlash == -1) {
       throw new IllegalArgumentException("Invalid mime type: " + mimeType);
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index b306fbf76e..ef4aa05cfe 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -300,9 +300,9 @@ public int readInt() {
    */
   public int readLittleEndianInt() {
     return (data[position++] & 0xFF)
-        | (data[position++]  & 0xFF) << 8
-        | (data[position++]  & 0xFF) << 16
-        | (data[position++]  & 0xFF) << 24;
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF) << 16
+        | (data[position++] & 0xFF) << 24;
   }
 
   /**
@@ -436,6 +436,49 @@ public String readString(int length, Charset charset) {
     return result;
   }
 
+  /**
+   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is discarded,
+   * if present.
+   *
+   * @param length The number of bytes to read.
+   * @return The string, not including any terminating NUL byte.
+   */
+  public String readNullTerminatedString(int length) {
+    if (length == 0) {
+      return "";
+    }
+    int stringLength = length;
+    int lastIndex = position + length - 1;
+    if (lastIndex < limit && data[lastIndex] == 0) {
+      stringLength--;
+    }
+    String result = new String(data, position, stringLength);
+    position += length;
+    return result;
+  }
+
+  /**
+   * Reads up to the next NUL byte (or the limit) as UTF-8 characters.
+   *
+   * @return The string not including any terminating NUL byte, or null if the end of the data has
+   *     already been reached.
+   */
+  public String readNullTerminatedString() {
+    if (bytesLeft() == 0) {
+      return null;
+    }
+    int stringLimit = position;
+    while (stringLimit < limit && data[stringLimit] != 0) {
+      stringLimit++;
+    }
+    String string = new String(data, position, stringLimit - position);
+    position = stringLimit;
+    if (position < limit) {
+      position++;
+    }
+    return string;
+  }
+
   /**
    * Reads a line of text.
    * <p>
@@ -443,15 +486,15 @@ public String readString(int length, Charset charset) {
    * ('\n'), or a carriage return followed immediately by a line feed ('\r\n'). The system's default
    * charset (UTF-8) is used.
    *
-   * @return A String containing the contents of the line, not including any line-termination
-   *     characters, or null if the end of the stream has been reached.
+   * @return The line not including any line-termination characters, or null if the end of the data
+   *     has already been reached.
    */
   public String readLine() {
     if (bytesLeft() == 0) {
       return null;
     }
     int lineLimit = position;
-    while (lineLimit < limit && data[lineLimit] != '\n' && data[lineLimit] != '\r') {
+    while (lineLimit < limit && !Util.isLinebreak(data[lineLimit])) {
       lineLimit++;
     }
     if (lineLimit - position >= 3 && data[position] == (byte) 0xEF
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java b/library/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
index cc6a17913b..fb61d3ba4a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/PriorityTaskManager.java
@@ -46,7 +46,7 @@ public PriorityTooLowException(int priority, int highestPriority) {
   private final PriorityQueue<Integer> queue;
   private int highestPriority;
 
-  private PriorityTaskManager() {
+  public PriorityTaskManager() {
     queue = new PriorityQueue<>(10, Collections.reverseOrder());
     highestPriority = Integer.MIN_VALUE;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
new file mode 100644
index 0000000000..1db3d2c1f4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This is a subclass of {@link BufferedOutputStream} with a {@link #reset(OutputStream)} method
+ * that allows an instance to be re-used with another underlying output stream.
+ */
+public final class ReusableBufferedOutputStream extends BufferedOutputStream {
+
+  private boolean closed;
+
+  public ReusableBufferedOutputStream(OutputStream out) {
+    super(out);
+  }
+
+  public ReusableBufferedOutputStream(OutputStream out, int size) {
+    super(out, size);
+  }
+
+  @Override
+  public void close() throws IOException {
+    closed = true;
+
+    Throwable thrown = null;
+    try {
+      flush();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      out.close();
+    } catch (Throwable e) {
+      if (thrown == null) {
+        thrown = e;
+      }
+    }
+    if (thrown != null) {
+      Util.sneakyThrow(thrown);
+    }
+  }
+
+  /**
+   * Resets this stream and uses the given output stream for writing. This stream must be closed
+   * before resetting.
+   *
+   * @param out New output stream to be used for writing.
+   * @throws IllegalStateException If the stream isn't closed.
+   */
+  public void reset(OutputStream out) {
+    Assertions.checkState(closed);
+    this.out = out;
+    count = 0;
+    closed = false;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index 8b1af1f0c8..c43b1929cb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -32,7 +32,7 @@
  * @see <a href="http://en.wikipedia.org/wiki/Moving_average">Wiki: Moving average</a>
  * @see <a href="http://en.wikipedia.org/wiki/Selection_algorithm">Wiki: Selection algorithm</a>
  */
-public final class SlidingPercentile {
+public class SlidingPercentile {
 
   // Orderings.
   private static final Comparator<Sample> INDEX_COMPARATOR = new Comparator<Sample>() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
similarity index 75%
rename from library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
rename to library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
index 4de4b38897..19c500202b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.extractor;
+package com.google.android.exoplayer2.util;
 
 import com.google.android.exoplayer2.C;
 
@@ -51,6 +51,34 @@ public TimestampAdjuster(long firstSampleTimestampUs) {
     lastSampleTimestamp = C.TIME_UNSET;
   }
 
+  /**
+   * Returns the last adjusted timestamp. If no timestamp has been adjusted, returns
+   * {@code firstSampleTimestampUs} as provided to the constructor. If this value is
+   * {@link #DO_NOT_OFFSET}, returns {@link C#TIME_UNSET}.
+   *
+   * @return The last adjusted timestamp. If not present, {@code firstSampleTimestampUs} is
+   *     returned unless equal to {@link #DO_NOT_OFFSET}, in which case {@link C#TIME_UNSET} is
+   *     returned.
+   */
+  public long getLastAdjustedTimestampUs() {
+    return lastSampleTimestamp != C.TIME_UNSET ? lastSampleTimestamp
+        : firstSampleTimestampUs != DO_NOT_OFFSET ? firstSampleTimestampUs : C.TIME_UNSET;
+  }
+
+  /**
+   * Returns the offset between the input of {@link #adjustSampleTimestamp(long)} and its output.
+   * If {@link #DO_NOT_OFFSET} was provided to the constructor, 0 is returned. If the timestamp
+   * adjuster is yet not initialized, {@link C#TIME_UNSET} is returned.
+   *
+   * @return The offset between {@link #adjustSampleTimestamp(long)}'s input and output.
+   *     {@link C#TIME_UNSET} if the adjuster is not yet initialized and 0 if timestamps should not
+   *     be offset.
+   */
+  public long getTimestampOffsetUs() {
+    return firstSampleTimestampUs == DO_NOT_OFFSET ? 0
+        : lastSampleTimestamp == C.TIME_UNSET ? C.TIME_UNSET : timestampOffsetUs;
+  }
+
   /**
    * Resets the instance to its initial state.
    */
@@ -65,6 +93,9 @@ public void reset() {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustTsTimestamp(long pts) {
+    if (pts == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     if (lastSampleTimestamp != C.TIME_UNSET) {
       // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
       // and we need to snap to the one closest to lastSampleTimestamp.
@@ -85,6 +116,9 @@ public long adjustTsTimestamp(long pts) {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustSampleTimestamp(long timeUs) {
+    if (timeUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     // Record the adjusted PTS to adjust for wraparound next time.
     if (lastSampleTimestamp != C.TIME_UNSET) {
       lastSampleTimestamp = timeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
index c4505fd8b9..e854c05165 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -31,19 +31,16 @@
 import android.view.WindowManager;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.nio.charset.Charset;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.text.ParseException;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collections;
@@ -67,7 +64,7 @@
    * overridden for local testing.
    */
   public static final int SDK_INT =
-      (Build.VERSION.SDK_INT == 23 && Build.VERSION.CODENAME.charAt(0) == 'N') ? 24
+      (Build.VERSION.SDK_INT == 25 && Build.VERSION.CODENAME.charAt(0) == 'O') ? 26
       : Build.VERSION.SDK_INT;
 
   /**
@@ -88,16 +85,21 @@
    */
   public static final String MODEL = Build.MODEL;
 
+  /**
+   * A concise description of the device that it can be useful to log for debugging purposes.
+   */
+  public static final String DEVICE_DEBUG_INFO = DEVICE + ", " + MODEL + ", " + MANUFACTURER + ", "
+      + SDK_INT;
+
   private static final String TAG = "Util";
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
       + "(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d+))?"
-      + "([Zz]|((\\+|\\-)(\\d\\d):(\\d\\d)))?");
+      + "([Zz]|((\\+|\\-)(\\d\\d):?(\\d\\d)))?");
   private static final Pattern XS_DURATION_PATTERN =
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
   private static final Pattern ESCAPED_CHARACTER_PATTERN = Pattern.compile("%([A-Fa-f0-9]{2})");
-  private static final char[] HEX_DIGITS = "0123456789ABCDEF".toCharArray();
 
   private Util() {}
 
@@ -208,20 +210,25 @@ public Thread newThread(Runnable r) {
    */
   public static void closeQuietly(DataSource dataSource) {
     try {
-      dataSource.close();
+      if (dataSource != null) {
+        dataSource.close();
+      }
     } catch (IOException e) {
       // Ignore.
     }
   }
 
   /**
-   * Closes an {@link OutputStream}, suppressing any {@link IOException} that may occur.
+   * Closes a {@link Closeable}, suppressing any {@link IOException} that may occur. Both {@link
+   * java.io.OutputStream} and {@link InputStream} are {@code Closeable}.
    *
-   * @param outputStream The {@link OutputStream} to close.
+   * @param closeable The {@link Closeable} to close.
    */
-  public static void closeQuietly(OutputStream outputStream) {
+  public static void closeQuietly(Closeable closeable) {
     try {
-      outputStream.close();
+      if (closeable != null) {
+        closeable.close();
+      }
     } catch (IOException e) {
       // Ignore.
     }
@@ -247,6 +254,16 @@ public static String normalizeLanguageCode(String language) {
     return value.getBytes(Charset.defaultCharset()); // UTF-8 is the default on Android.
   }
 
+  /**
+   * Returns whether the given character is a carriage return ('\r') or a line feed ('\n').
+   *
+   * @param c The character.
+   * @return Whether the given character is a linebreak.
+   */
+  public static boolean isLinebreak(int c) {
+    return c == '\n' || c == '\r';
+  }
+
   /**
    * Converts text to lower case using {@link Locale#US}.
    *
@@ -292,110 +309,167 @@ public static int constrainValue(int value, int min, int max) {
   }
 
   /**
-   * Returns the index of the largest value in an array that is less than (or optionally equal to)
-   * a specified value.
+   * Returns the index of the largest element in {@code array} that is less than (or optionally
+   * equal to) a specified {@code value}.
    * <p>
-   * The search is performed using a binary search algorithm, so the array must be sorted.
+   * The search is performed using a binary search algorithm, so the array must be sorted. If the
+   * array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the first one will be returned.
    *
-   * @param a The array to search.
+   * @param array The array to search.
    * @param value The value being searched for.
    * @param inclusive If the value is present in the array, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the largest value in the array that
-   *     is strictly less than the value.
+   *     index. If false then the returned index corresponds to the largest element strictly less
+   *     than the value.
    * @param stayInBounds If true, then 0 will be returned in the case that the value is smaller than
-   *     the smallest value in the array. If false then -1 will be returned.
+   *     the smallest element in the array. If false then -1 will be returned.
+   * @return The index of the largest element in {@code array} that is less than (or optionally
+   *     equal to) {@code value}.
    */
-  public static int binarySearchFloor(int[] a, int value, boolean inclusive, boolean stayInBounds) {
-    int index = Arrays.binarySearch(a, value);
-    index = index < 0 ? -(index + 2) : (inclusive ? index : (index - 1));
+  public static int binarySearchFloor(int[] array, int value, boolean inclusive,
+      boolean stayInBounds) {
+    int index = Arrays.binarySearch(array, value);
+    if (index < 0) {
+      index = -(index + 2);
+    } else {
+      while ((--index) >= 0 && array[index] == value) {}
+      if (inclusive) {
+        index++;
+      }
+    }
     return stayInBounds ? Math.max(0, index) : index;
   }
 
   /**
-   * Returns the index of the largest value in an array that is less than (or optionally equal to)
-   * a specified value.
+   * Returns the index of the largest element in {@code array} that is less than (or optionally
+   * equal to) a specified {@code value}.
    * <p>
-   * The search is performed using a binary search algorithm, so the array must be sorted.
+   * The search is performed using a binary search algorithm, so the array must be sorted. If the
+   * array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the first one will be returned.
    *
-   * @param a The array to search.
+   * @param array The array to search.
    * @param value The value being searched for.
    * @param inclusive If the value is present in the array, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the largest value in the array that
-   *     is strictly less than the value.
+   *     index. If false then the returned index corresponds to the largest element strictly less
+   *     than the value.
    * @param stayInBounds If true, then 0 will be returned in the case that the value is smaller than
-   *     the smallest value in the array. If false then -1 will be returned.
+   *     the smallest element in the array. If false then -1 will be returned.
+   * @return The index of the largest element in {@code array} that is less than (or optionally
+   *     equal to) {@code value}.
    */
-  public static int binarySearchFloor(long[] a, long value, boolean inclusive,
+  public static int binarySearchFloor(long[] array, long value, boolean inclusive,
       boolean stayInBounds) {
-    int index = Arrays.binarySearch(a, value);
-    index = index < 0 ? -(index + 2) : (inclusive ? index : (index - 1));
+    int index = Arrays.binarySearch(array, value);
+    if (index < 0) {
+      index = -(index + 2);
+    } else {
+      while ((--index) >= 0 && array[index] == value) {}
+      if (inclusive) {
+        index++;
+      }
+    }
     return stayInBounds ? Math.max(0, index) : index;
   }
 
   /**
-   * Returns the index of the smallest value in an array that is greater than (or optionally equal
-   * to) a specified value.
+   * Returns the index of the smallest element in {@code array} that is greater than (or optionally
+   * equal to) a specified {@code value}.
    * <p>
-   * The search is performed using a binary search algorithm, so the array must be sorted.
+   * The search is performed using a binary search algorithm, so the array must be sorted. If
+   * the array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the last one will be returned.
    *
-   * @param a The array to search.
+   * @param array The array to search.
    * @param value The value being searched for.
    * @param inclusive If the value is present in the array, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the largest value in the array that
-   *     is strictly less than the value.
+   *     index. If false then the returned index corresponds to the smallest element strictly
+   *     greater than the value.
    * @param stayInBounds If true, then {@code (a.length - 1)} will be returned in the case that the
-   *     value is greater than the largest value in the array. If false then {@code a.length} will
+   *     value is greater than the largest element in the array. If false then {@code a.length} will
    *     be returned.
+   * @return The index of the smallest element in {@code array} that is greater than (or optionally
+   *     equal to) {@code value}.
    */
-  public static int binarySearchCeil(long[] a, long value, boolean inclusive,
+  public static int binarySearchCeil(long[] array, long value, boolean inclusive,
       boolean stayInBounds) {
-    int index = Arrays.binarySearch(a, value);
-    index = index < 0 ? ~index : (inclusive ? index : (index + 1));
-    return stayInBounds ? Math.min(a.length - 1, index) : index;
+    int index = Arrays.binarySearch(array, value);
+    if (index < 0) {
+      index = ~index;
+    } else {
+      while ((++index) < array.length && array[index] == value) {}
+      if (inclusive) {
+        index--;
+      }
+    }
+    return stayInBounds ? Math.min(array.length - 1, index) : index;
   }
 
   /**
-   * Returns the index of the largest value in an list that is less than (or optionally equal to)
-   * a specified value.
+   * Returns the index of the largest element in {@code list} that is less than (or optionally equal
+   * to) a specified {@code value}.
    * <p>
-   * The search is performed using a binary search algorithm, so the list must be sorted.
+   * The search is performed using a binary search algorithm, so the list must be sorted. If the
+   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the first one will be returned.
    *
    * @param <T> The type of values being searched.
    * @param list The list to search.
    * @param value The value being searched for.
    * @param inclusive If the value is present in the list, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the largest value in the list that
-   *     is strictly less than the value.
+   *     index. If false then the returned index corresponds to the largest element strictly less
+   *     than the value.
    * @param stayInBounds If true, then 0 will be returned in the case that the value is smaller than
-   *     the smallest value in the list. If false then -1 will be returned.
+   *     the smallest element in the list. If false then -1 will be returned.
+   * @return The index of the largest element in {@code list} that is less than (or optionally equal
+   *     to) {@code value}.
    */
   public static <T> int binarySearchFloor(List<? extends Comparable<? super T>> list, T value,
       boolean inclusive, boolean stayInBounds) {
     int index = Collections.binarySearch(list, value);
-    index = index < 0 ? -(index + 2) : (inclusive ? index : (index - 1));
+    if (index < 0) {
+      index = -(index + 2);
+    } else {
+      while ((--index) >= 0 && list.get(index).compareTo(value) == 0) {}
+      if (inclusive) {
+        index++;
+      }
+    }
     return stayInBounds ? Math.max(0, index) : index;
   }
 
   /**
-   * Returns the index of the smallest value in an list that is greater than (or optionally equal
-   * to) a specified value.
+   * Returns the index of the smallest element in {@code list} that is greater than (or optionally
+   * equal to) a specified value.
    * <p>
-   * The search is performed using a binary search algorithm, so the list must be sorted.
+   * The search is performed using a binary search algorithm, so the list must be sorted. If the
+   * list contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the last one will be returned.
    *
    * @param <T> The type of values being searched.
    * @param list The list to search.
    * @param value The value being searched for.
    * @param inclusive If the value is present in the list, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the smallest value in the list that
-   *     is strictly greater than the value.
+   *     index. If false then the returned index corresponds to the smallest element strictly
+   *     greater than the value.
    * @param stayInBounds If true, then {@code (list.size() - 1)} will be returned in the case that
-   *     the value is greater than the largest value in the list. If false then {@code list.size()}
-   *     will be returned.
+   *     the value is greater than the largest element in the list. If false then
+   *     {@code list.size()} will be returned.
+   * @return The index of the smallest element in {@code list} that is greater than (or optionally
+   *     equal to) {@code value}.
    */
   public static <T> int binarySearchCeil(List<? extends Comparable<? super T>> list, T value,
       boolean inclusive, boolean stayInBounds) {
     int index = Collections.binarySearch(list, value);
-    index = index < 0 ? ~index : (inclusive ? index : (index + 1));
+    if (index < 0) {
+      index = ~index;
+    } else {
+      int listSize = list.size();
+      while ((++index) < listSize && list.get(index).compareTo(value) == 0) {}
+      if (inclusive) {
+        index--;
+      }
+    }
     return stayInBounds ? Math.min(list.size() - 1, index) : index;
   }
 
@@ -436,11 +510,12 @@ public static long parseXsDuration(String value) {
    *
    * @param value The attribute value to decode.
    * @return The parsed timestamp in milliseconds since the epoch.
+   * @throws ParserException if an error occurs parsing the dateTime attribute value.
    */
-  public static long parseXsDateTime(String value) throws ParseException {
+  public static long parseXsDateTime(String value) throws ParserException {
     Matcher matcher = XS_DATE_TIME_PATTERN.matcher(value);
     if (!matcher.matches()) {
-      throw new ParseException("Invalid date/time format: " + value, 0);
+      throw new ParserException("Invalid date/time format: " + value);
     }
 
     int timezoneShift;
@@ -630,21 +705,6 @@ public static int getIntegerCodeForString(String string) {
     return data;
   }
 
-  /**
-   * Returns a hex string representation of the given byte array.
-   *
-   * @param bytes The byte array.
-   */
-  public static String getHexString(byte[] bytes) {
-    char[] hexChars = new char[bytes.length * 2];
-    int i = 0;
-    for (byte v : bytes) {
-      hexChars[i++] = HEX_DIGITS[(v >> 4) & 0xf];
-      hexChars[i++] = HEX_DIGITS[v & 0xf];
-    }
-    return new String(hexChars);
-  }
-
   /**
    * Returns a string with comma delimited simple names of each object's class.
    *
@@ -851,6 +911,19 @@ public static String unescapeFileName(String fileName) {
     return builder.toString();
   }
 
+  /**
+   * A hacky method that always throws {@code t} even if {@code t} is a checked exception,
+   * and is not declared to be thrown.
+   */
+  public static void sneakyThrow(Throwable t) {
+    Util.<RuntimeException>sneakyThrowInternal(t);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void sneakyThrowInternal(Throwable t) throws T {
+    throw (T) t;
+  }
+
   /**
    * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
    * order.
@@ -869,22 +942,6 @@ public static int crc(byte[] bytes, int start, int end, int initialValue) {
     return initialValue;
   }
 
-  /**
-   * Returns the SHA-1 digest of {@code input} as a hex string.
-   *
-   * @param input The string whose SHA-1 digest is required.
-   */
-  public static String sha1(String input) {
-    try {
-      MessageDigest digest = MessageDigest.getInstance("SHA-1");
-      byte[] bytes = input.getBytes("UTF-8");
-      digest.update(bytes, 0, bytes.length);
-      return getHexString(digest.digest());
-    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   /**
    * Gets the physical size of the default display, in pixels.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index b5a01f0a28..280f004211 100644
--- a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -18,15 +18,19 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.graphics.Point;
 import android.media.MediaCodec;
+import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -53,10 +57,13 @@
   private static final String KEY_CROP_BOTTOM = "crop-bottom";
   private static final String KEY_CROP_TOP = "crop-top";
 
+  // Long edge length in pixels for standard video formats, in decreasing in order.
+  private static final int[] STANDARD_LONG_EDGE_VIDEO_PX = new int[] {
+      1920, 1600, 1440, 1280, 960, 854, 640, 540, 480};
+
   private final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
-  private final int videoScalingMode;
   private final int maxDroppedFramesToNotify;
   private final boolean deviceNeedsAutoFrcWorkaround;
 
@@ -64,6 +71,8 @@
   private CodecMaxValues codecMaxValues;
 
   private Surface surface;
+  @C.VideoScalingMode
+  private int scalingMode;
   private boolean renderedFirstFrame;
   private long joiningDeadlineMs;
   private long droppedFrameAccumulationStartTimeMs;
@@ -81,35 +90,32 @@
   private int lastReportedUnappliedRotationDegrees;
   private float lastReportedPixelWidthHeightRatio;
 
+  private boolean tunneling;
+  private int tunnelingAudioSessionId;
+  /* package */ OnFrameRenderedListenerV23 tunnelingOnFrameRenderedListener;
+
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
-   * @param videoScalingMode The scaling mode to pass to
-   *     {@link MediaCodec#setVideoScalingMode(int)}.
    */
-  public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      int videoScalingMode) {
-    this(context, mediaCodecSelector, videoScalingMode, 0);
+  public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector) {
+    this(context, mediaCodecSelector, 0);
   }
 
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
-   * @param videoScalingMode The scaling mode to pass to
-   *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    */
   public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      int videoScalingMode, long allowedJoiningTimeMs) {
-    this(context, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, null, -1);
+      long allowedJoiningTimeMs) {
+    this(context, mediaCodecSelector, allowedJoiningTimeMs, null, null, -1);
   }
 
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
-   * @param videoScalingMode The scaling mode to pass to
-   *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
@@ -119,17 +125,15 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
   public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      int videoScalingMode, long allowedJoiningTimeMs, Handler eventHandler,
-      VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
-    this(context, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
-        eventHandler, eventListener, maxDroppedFrameCountToNotify);
+      long allowedJoiningTimeMs, Handler eventHandler, VideoRendererEventListener eventListener,
+      int maxDroppedFrameCountToNotify) {
+    this(context, mediaCodecSelector, allowedJoiningTimeMs, null, false, eventHandler,
+        eventListener, maxDroppedFrameCountToNotify);
   }
 
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
-   * @param videoScalingMode The scaling mode to pass to
-   *     {@link MediaCodec#setVideoScalingMode(int)}.
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
    * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
@@ -146,12 +150,10 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
    *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
    */
   public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      int videoScalingMode, long allowedJoiningTimeMs,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      long allowedJoiningTimeMs, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys, Handler eventHandler,
       VideoRendererEventListener eventListener, int maxDroppedFramesToNotify) {
     super(C.TRACK_TYPE_VIDEO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    this.videoScalingMode = videoScalingMode;
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
     frameReleaseTimeHelper = new VideoFrameReleaseTimeHelper(context);
@@ -162,9 +164,8 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
     currentHeight = Format.NO_VALUE;
     currentPixelWidthHeightRatio = Format.NO_VALUE;
     pendingPixelWidthHeightRatio = Format.NO_VALUE;
-    lastReportedWidth = Format.NO_VALUE;
-    lastReportedHeight = Format.NO_VALUE;
-    lastReportedPixelWidthHeightRatio = Format.NO_VALUE;
+    scalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
+    clearLastReportedVideoSize();
   }
 
   @Override
@@ -190,25 +191,28 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     boolean decoderCapable = decoderInfo.isCodecSupported(format.codecs);
     if (decoderCapable && format.width > 0 && format.height > 0) {
       if (Util.SDK_INT >= 21) {
-        if (format.frameRate > 0) {
-          decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
-              format.frameRate);
-        } else {
-          decoderCapable = decoderInfo.isVideoSizeSupportedV21(format.width, format.height);
-        }
+        decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
+            format.frameRate);
       } else {
         decoderCapable = format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();
+        if (!decoderCapable) {
+          Log.d(TAG, "FalseCheck [legacyFrameSize, " + format.width + "x" + format.height + "] ["
+              + Util.DEVICE_DEBUG_INFO + "]");
+        }
       }
     }
 
     int adaptiveSupport = decoderInfo.adaptive ? ADAPTIVE_SEAMLESS : ADAPTIVE_NOT_SEAMLESS;
+    int tunnelingSupport = decoderInfo.tunneling ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return adaptiveSupport | formatSupport;
+    return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
+    tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    tunneling = tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET;
     eventDispatcher.enabled(decoderCounters);
     frameReleaseTimeHelper.enable();
   }
@@ -222,7 +226,7 @@ protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
-    renderedFirstFrame = false;
+    clearRenderedFirstFrame();
     consecutiveDroppedFrameCount = 0;
     joiningDeadlineMs = joining && allowedJoiningTimeMs > 0
         ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
@@ -267,10 +271,9 @@ protected void onDisabled() {
     currentHeight = Format.NO_VALUE;
     currentPixelWidthHeightRatio = Format.NO_VALUE;
     pendingPixelWidthHeightRatio = Format.NO_VALUE;
-    lastReportedWidth = Format.NO_VALUE;
-    lastReportedHeight = Format.NO_VALUE;
-    lastReportedPixelWidthHeightRatio = Format.NO_VALUE;
+    clearLastReportedVideoSize();
     frameReleaseTimeHelper.disable();
+    tunnelingOnFrameRenderedListener = null;
     try {
       super.onDisabled();
     } finally {
@@ -283,22 +286,31 @@ protected void onDisabled() {
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
       setSurface((Surface) message);
+    } else if (messageType == C.MSG_SET_SCALING_MODE) {
+      scalingMode = (Integer) message;
+      MediaCodec codec = getCodec();
+      if (codec != null) {
+        setVideoScalingMode(codec, scalingMode);
+      }
     } else {
       super.handleMessage(messageType, message);
     }
   }
 
   private void setSurface(Surface surface) throws ExoPlaybackException {
-    if (this.surface == surface) {
-      return;
-    }
-    renderedFirstFrame = false;
-    this.surface = surface;
-    int state = getState();
-    if (state == STATE_ENABLED || state == STATE_STARTED) {
-      releaseCodec();
-      maybeInitCodec();
+    // We only need to release and reinitialize the codec if the surface has changed.
+    if (this.surface != surface) {
+      this.surface = surface;
+      int state = getState();
+      if (state == STATE_ENABLED || state == STATE_STARTED) {
+        releaseCodec();
+        maybeInitCodec();
+      }
     }
+    // Clear state so that we always call the event listener with the video size and when a frame
+    // is rendered, even if the surface hasn't changed.
+    clearRenderedFirstFrame();
+    clearLastReportedVideoSize();
   }
 
   @Override
@@ -307,10 +319,15 @@ protected boolean shouldInitCodec() {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
-    codecMaxValues = getCodecMaxValues(format, streamFormats);
-    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround);
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException {
+    codecMaxValues = getCodecMaxValues(codecInfo, format, streamFormats);
+    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround,
+        tunnelingAudioSessionId);
     codec.configure(mediaFormat, surface, crypto, 0);
+    if (Util.SDK_INT >= 23 && tunneling) {
+      tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+    }
   }
 
   @Override
@@ -327,6 +344,13 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     pendingRotationDegrees = getRotationDegrees(newFormat);
   }
 
+  @Override
+  protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    if (Util.SDK_INT < 23 && tunneling) {
+      maybeNotifyRenderedFirstFrame();
+    }
+  }
+
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
@@ -354,7 +378,7 @@ protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat
       currentUnappliedRotationDegrees = pendingRotationDegrees;
     }
     // Must be applied each time the output format changes.
-    codec.setVideoScalingMode(videoScalingMode);
+    setVideoScalingMode(codec, scalingMode);
   }
 
   @Override
@@ -402,7 +426,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (earlyUs < -30000) {
+    if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
       // We're more than 30ms late rendering the frame.
       dropOutputBuffer(codec, bufferIndex);
       return true;
@@ -436,6 +460,19 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  /**
+   * Returns whether the buffer being processed should be dropped.
+   *
+   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
+   *     indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
+    // Drop the frame if we're more than 30ms late rendering the frame.
+    return earlyUs < -30000;
+  }
+
   private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
@@ -464,10 +501,7 @@ private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
-    if (!renderedFirstFrame) {
-      renderedFirstFrame = true;
-      eventDispatcher.renderedFirstFrame(surface);
-    }
+    maybeNotifyRenderedFirstFrame();
   }
 
   @TargetApi(21)
@@ -478,15 +512,64 @@ private void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long relea
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
+    maybeNotifyRenderedFirstFrame();
+  }
+
+  private void clearRenderedFirstFrame() {
+    renderedFirstFrame = false;
+    // The first frame notification is triggered by renderOutputBuffer or renderOutputBufferV21 for
+    // non-tunneled playback, onQueueInputBuffer for tunneled playback prior to API level 23, and
+    // OnFrameRenderedListenerV23.onFrameRenderedListener for tunneled playback on API level 23 and
+    // above.
+    if (Util.SDK_INT >= 23 && tunneling) {
+      MediaCodec codec = getCodec();
+      // If codec is null then the listener will be instantiated in configureCodec.
+      if (codec != null) {
+        tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+      }
+    }
+  }
+
+  /* package */ void maybeNotifyRenderedFirstFrame() {
     if (!renderedFirstFrame) {
       renderedFirstFrame = true;
       eventDispatcher.renderedFirstFrame(surface);
     }
   }
 
+  private void clearLastReportedVideoSize() {
+    lastReportedWidth = Format.NO_VALUE;
+    lastReportedHeight = Format.NO_VALUE;
+    lastReportedPixelWidthHeightRatio = Format.NO_VALUE;
+    lastReportedUnappliedRotationDegrees = Format.NO_VALUE;
+  }
+
+  private void maybeNotifyVideoSizeChanged() {
+    if (lastReportedWidth != currentWidth || lastReportedHeight != currentHeight
+        || lastReportedUnappliedRotationDegrees != currentUnappliedRotationDegrees
+        || lastReportedPixelWidthHeightRatio != currentPixelWidthHeightRatio) {
+      eventDispatcher.videoSizeChanged(currentWidth, currentHeight, currentUnappliedRotationDegrees,
+          currentPixelWidthHeightRatio);
+      lastReportedWidth = currentWidth;
+      lastReportedHeight = currentHeight;
+      lastReportedUnappliedRotationDegrees = currentUnappliedRotationDegrees;
+      lastReportedPixelWidthHeightRatio = currentPixelWidthHeightRatio;
+    }
+  }
+
+  private void maybeNotifyDroppedFrames() {
+    if (droppedFrames > 0) {
+      long now = SystemClock.elapsedRealtime();
+      long elapsedMs = now - droppedFrameAccumulationStartTimeMs;
+      eventDispatcher.droppedFrames(droppedFrames, elapsedMs);
+      droppedFrames = 0;
+      droppedFrameAccumulationStartTimeMs = now;
+    }
+  }
+
   @SuppressLint("InlinedApi")
   private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMaxValues,
-      boolean deviceNeedsAutoFrcWorkaround) {
+      boolean deviceNeedsAutoFrcWorkaround, int tunnelingAudioSessionId) {
     MediaFormat frameworkMediaFormat = format.getFrameworkMediaFormatV16();
     // Set the maximum adaptive video dimensions.
     frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);
@@ -499,36 +582,109 @@ private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMax
     if (deviceNeedsAutoFrcWorkaround) {
       frameworkMediaFormat.setInteger("auto-frc", 0);
     }
+    // Configure tunneling if enabled.
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      configureTunnelingV21(frameworkMediaFormat, tunnelingAudioSessionId);
+    }
     return frameworkMediaFormat;
   }
 
+  @TargetApi(21)
+  private static void configureTunnelingV21(MediaFormat mediaFormat, int tunnelingAudioSessionId) {
+    mediaFormat.setFeatureEnabled(CodecCapabilities.FEATURE_TunneledPlayback, true);
+    mediaFormat.setInteger(MediaFormat.KEY_AUDIO_SESSION_ID, tunnelingAudioSessionId);
+  }
+
   /**
    * Returns {@link CodecMaxValues} suitable for configuring a codec for {@code format} in a way
    * that will allow possible adaptation to other compatible formats in {@code streamFormats}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static CodecMaxValues getCodecMaxValues(Format format, Format[] streamFormats) {
+  private static CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
+      Format[] streamFormats) throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(format);
+    if (streamFormats.length == 1) {
+      // The single entry in streamFormats must correspond to the format for which the codec is
+      // being configured.
+      return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
+    }
+    boolean haveUnknownDimensions = false;
     for (Format streamFormat : streamFormats) {
       if (areAdaptationCompatible(format, streamFormat)) {
+        haveUnknownDimensions |= (streamFormat.width == Format.NO_VALUE
+            || streamFormat.height == Format.NO_VALUE);
         maxWidth = Math.max(maxWidth, streamFormat.width);
         maxHeight = Math.max(maxHeight, streamFormat.height);
         maxInputSize = Math.max(maxInputSize, getMaxInputSize(streamFormat));
       }
     }
+    if (haveUnknownDimensions) {
+      Log.w(TAG, "Resolutions unknown. Codec max resolution: " + maxWidth + "x" + maxHeight);
+      Point codecMaxSize = getCodecMaxSize(codecInfo, format);
+      if (codecMaxSize != null) {
+        maxWidth = Math.max(maxWidth, codecMaxSize.x);
+        maxHeight = Math.max(maxHeight, codecMaxSize.y);
+        maxInputSize = Math.max(maxInputSize,
+            getMaxInputSize(format.sampleMimeType, maxWidth, maxHeight));
+        Log.w(TAG, "Codec max resolution adjusted to: " + maxWidth + "x" + maxHeight);
+      }
+    }
     return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
   }
 
+  /**
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
+   * that will allow possible adaptation to other compatible formats that are expected to have the
+   * same aspect ratio, but whose sizes are unknown.
+   *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
+   * @param format The format for which the codec is being configured.
+   * @return The maximum video size to use, or null if the size of {@code format} should be used.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
+   */
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
+      throws DecoderQueryException {
+    boolean isVerticalVideo = format.height > format.width;
+    int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
+    int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
+    float aspectRatio = (float) formatShortEdgePx / formatLongEdgePx;
+    for (int longEdgePx : STANDARD_LONG_EDGE_VIDEO_PX) {
+      int shortEdgePx = (int) (longEdgePx * aspectRatio);
+      if (longEdgePx <= formatLongEdgePx || shortEdgePx <= formatShortEdgePx) {
+        // Don't return a size not larger than the format for which the codec is being configured.
+        return null;
+      } else if (Util.SDK_INT >= 21) {
+        Point alignedSize = codecInfo.alignVideoSizeV21(isVerticalVideo ? shortEdgePx : longEdgePx,
+            isVerticalVideo ? longEdgePx : shortEdgePx);
+        float frameRate = format.frameRate;
+        if (codecInfo.isVideoSizeAndRateSupportedV21(alignedSize.x, alignedSize.y, frameRate)) {
+          return alignedSize;
+        }
+      } else {
+        // Conservatively assume the codec requires 16px width and height alignment.
+        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
+              isVerticalVideo ? longEdgePx : shortEdgePx);
+        }
+      }
+    }
+    return null;
+  }
+
   /**
    * Returns a maximum input size for a given format.
    *
    * @param format The format.
-   * @return An maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
    *     determined.
    */
   private static int getMaxInputSize(Format format) {
@@ -536,8 +692,20 @@ private static int getMaxInputSize(Format format) {
       // The format defines an explicit maximum input size.
       return format.maxInputSize;
     }
+    return getMaxInputSize(format.sampleMimeType, format.width, format.height);
+  }
 
-    if (format.width == Format.NO_VALUE || format.height == Format.NO_VALUE) {
+  /**
+   * Returns a maximum input size for a given mime type, width and height.
+   *
+   * @param sampleMimeType The format mime type.
+   * @param width The width in pixels.
+   * @param height The height in pixels.
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   *     determined.
+   */
+  private static int getMaxInputSize(String sampleMimeType, int width, int height) {
+    if (width == Format.NO_VALUE || height == Format.NO_VALUE) {
       // We can't infer a maximum input size without video dimensions.
       return Format.NO_VALUE;
     }
@@ -545,10 +713,10 @@ private static int getMaxInputSize(Format format) {
     // Attempt to infer a maximum input size from the format.
     int maxPixels;
     int minCompressionRatio;
-    switch (format.sampleMimeType) {
+    switch (sampleMimeType) {
       case MimeTypes.VIDEO_H263:
       case MimeTypes.VIDEO_MP4V:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H264:
@@ -558,17 +726,17 @@ private static int getMaxInputSize(Format format) {
           return Format.NO_VALUE;
         }
         // Round up width/height to an integer number of macroblocks.
-        maxPixels = ((format.width + 15) / 16) * ((format.height + 15) / 16) * 16 * 16;
+        maxPixels = Util.ceilDivide(width, 16) * Util.ceilDivide(height, 16) * 16 * 16;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_VP8:
         // VPX does not specify a ratio so use the values from the platform's SoftVPX.cpp.
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H265:
       case MimeTypes.VIDEO_VP9:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 4;
         break;
       default:
@@ -579,27 +747,8 @@ private static int getMaxInputSize(Format format) {
     return (maxPixels * 3) / (2 * minCompressionRatio);
   }
 
-  private void maybeNotifyVideoSizeChanged() {
-    if (lastReportedWidth != currentWidth || lastReportedHeight != currentHeight
-        || lastReportedUnappliedRotationDegrees != currentUnappliedRotationDegrees
-        || lastReportedPixelWidthHeightRatio != currentPixelWidthHeightRatio) {
-      eventDispatcher.videoSizeChanged(currentWidth, currentHeight, currentUnappliedRotationDegrees,
-          currentPixelWidthHeightRatio);
-      lastReportedWidth = currentWidth;
-      lastReportedHeight = currentHeight;
-      lastReportedUnappliedRotationDegrees = currentUnappliedRotationDegrees;
-      lastReportedPixelWidthHeightRatio = currentPixelWidthHeightRatio;
-    }
-  }
-
-  private void maybeNotifyDroppedFrames() {
-    if (droppedFrames > 0) {
-      long now = SystemClock.elapsedRealtime();
-      long elapsedMs = now - droppedFrameAccumulationStartTimeMs;
-      eventDispatcher.droppedFrames(droppedFrames, elapsedMs);
-      droppedFrames = 0;
-      droppedFrameAccumulationStartTimeMs = now;
-    }
+  private static void setVideoScalingMode(MediaCodec codec, int scalingMode) {
+    codec.setVideoScalingMode(scalingMode);
   }
 
   /**
@@ -656,4 +805,22 @@ public CodecMaxValues(int width, int height, int inputSize) {
 
   }
 
+  @TargetApi(23)
+  private final class OnFrameRenderedListenerV23 implements MediaCodec.OnFrameRenderedListener {
+
+    private OnFrameRenderedListenerV23(MediaCodec codec) {
+      codec.setOnFrameRenderedListener(this, new Handler());
+    }
+
+    @Override
+    public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
+      if (this != tunnelingOnFrameRenderedListener) {
+        // Stale event.
+        return;
+      }
+      maybeNotifyRenderedFirstFrame();
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/library/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index 4c7d8a62c1..53d6a76b8d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/library/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -69,7 +69,8 @@ void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
   void onDroppedFrames(int count, long elapsedMs);
 
   /**
-   * Called each time there's a change in the size of the video being rendered.
+   * Called before a frame is rendered for the first time since setting the surface, and each time
+   * there's a change in the size, rotation or pixel aspect ratio of the video being rendered.
    *
    * @param width The video width in pixels.
    * @param height The video height in pixels.
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
new file mode 100644
index 0000000000..4b86e109e9
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M4,18l8.5,-6L4,6v12zM13,6v12l8.5,-6L13,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
new file mode 100644
index 0000000000..6305bcbc90
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,18l8.5,-6L6,6v12zM16,6v12h2V6h-2z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
new file mode 100644
index 0000000000..45cd68bed6
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,19h4L10,5L6,5v14zM14,5v14h4L18,5h-4z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
new file mode 100644
index 0000000000..c8c4cdb127
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M8,5v14l11,-7z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
new file mode 100644
index 0000000000..9564a2a350
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,6h2v12L6,18zM9.5,12l8.5,6L18,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
new file mode 100644
index 0000000000..976b706170
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M11,18L11,6l-8.5,6 8.5,6zM11.5,12l8.5,6L20,6l-8.5,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png
index c65956ab7f..843df84091 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_next.png b/library/src/main/res/drawable-hdpi/exo_controls_next.png
index 6e27b8161e..c37541472e 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_next.png and b/library/src/main/res/drawable-hdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_pause.png b/library/src/main/res/drawable-hdpi/exo_controls_pause.png
index 1d465a41e4..0a23452746 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_pause.png and b/library/src/main/res/drawable-hdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_play.png b/library/src/main/res/drawable-hdpi/exo_controls_play.png
index 2746d17fb1..e98e2b9cbe 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_play.png and b/library/src/main/res/drawable-hdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_previous.png b/library/src/main/res/drawable-hdpi/exo_controls_previous.png
index 85b3766904..3eae5c883b 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_previous.png and b/library/src/main/res/drawable-hdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png
index a4ac181777..36537d3b73 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png
index 1b4d9dbef9..19b9e6015c 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_next.png b/library/src/main/res/drawable-ldpi/exo_controls_next.png
index 99927fd27b..d4872037aa 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_next.png and b/library/src/main/res/drawable-ldpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_pause.png b/library/src/main/res/drawable-ldpi/exo_controls_pause.png
index 3b98d66688..616ec42f39 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_pause.png and b/library/src/main/res/drawable-ldpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_play.png b/library/src/main/res/drawable-ldpi/exo_controls_play.png
index e7c19724bb..5d1c702892 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_play.png and b/library/src/main/res/drawable-ldpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_previous.png b/library/src/main/res/drawable-ldpi/exo_controls_previous.png
index df043228d0..930534d312 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_previous.png and b/library/src/main/res/drawable-ldpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png
index 28843f9fb0..83d71782f6 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png and b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png
index 170dd2daaa..ee3efe1d69 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_next.png b/library/src/main/res/drawable-mdpi/exo_controls_next.png
index fcd73d90e7..9d4d7469ed 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_next.png and b/library/src/main/res/drawable-mdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_pause.png b/library/src/main/res/drawable-mdpi/exo_controls_pause.png
index 3e6b2a17b5..f54c942201 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_pause.png and b/library/src/main/res/drawable-mdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_play.png b/library/src/main/res/drawable-mdpi/exo_controls_play.png
index 7966bbc516..dd0c142859 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_play.png and b/library/src/main/res/drawable-mdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_previous.png b/library/src/main/res/drawable-mdpi/exo_controls_previous.png
index b653d05b9f..950e213d2f 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_previous.png and b/library/src/main/res/drawable-mdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png
index 5489180eb1..e75efae189 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png
index 60f7e92181..ead712cfe9 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_next.png b/library/src/main/res/drawable-xhdpi/exo_controls_next.png
index 4def965cec..bc1ebf83c5 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png
index 6bd3d482e1..1c868f1831 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_play.png b/library/src/main/res/drawable-xhdpi/exo_controls_play.png
index ccfef18056..f2f934413e 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png
index c4472ae2d9..d197eff873 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png
index 167d10e58b..3340ef9bd2 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png
index ab9e022fbf..e1c6cae292 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png
index ce0a14325a..232f09e910 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png
index 9a36b17cb8..50a545db4d 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png
index 41f76bbf99..08508c5015 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png
index d4688741b9..f71acc4875 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png
index 8ebb2ccf30..db0555f9e5 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/layout/exo_playback_control_view.xml b/library/src/main/res/layout/exo_playback_control_view.xml
index a0be4a8149..f8ef5a6fdd 100644
--- a/library/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/src/main/res/layout/exo_playback_control_view.xml
@@ -17,9 +17,9 @@
   android:layout_width="match_parent"
   android:layout_height="wrap_content"
   android:layout_gravity="bottom"
+  android:layoutDirection="ltr"
   android:background="#CC000000"
-  android:orientation="vertical"
-  android:layoutDirection="ltr">
+  android:orientation="vertical">
 
   <LinearLayout
     android:layout_width="match_parent"
@@ -28,23 +28,22 @@
     android:paddingTop="4dp"
     android:orientation="horizontal">
 
-    <ImageButton android:id="@+id/prev"
-      android:contentDescription="@string/exo_controls_previous_description"
+    <ImageButton android:id="@id/exo_prev"
       style="@style/ExoMediaButton.Previous"/>
 
-    <ImageButton android:id="@+id/rew"
-      android:contentDescription="@string/exo_controls_rewind_description"
+    <ImageButton android:id="@id/exo_rew"
       style="@style/ExoMediaButton.Rewind"/>
 
-    <ImageButton android:id="@+id/play"
-      style="@style/ExoMediaButton"/>
+    <ImageButton android:id="@id/exo_play"
+      style="@style/ExoMediaButton.Play"/>
 
-    <ImageButton android:id="@+id/ffwd"
-      android:contentDescription="@string/exo_controls_fastforward_description"
+    <ImageButton android:id="@id/exo_pause"
+      style="@style/ExoMediaButton.Pause"/>
+
+    <ImageButton android:id="@id/exo_ffwd"
       style="@style/ExoMediaButton.FastForward"/>
 
-    <ImageButton android:id="@+id/next"
-      android:contentDescription="@string/exo_controls_previous_description"
+    <ImageButton android:id="@id/exo_next"
       style="@style/ExoMediaButton.Next"/>
 
   </LinearLayout>
@@ -52,34 +51,35 @@
   <LinearLayout
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
+    android:layout_marginTop="4dp"
+    android:gravity="center_vertical"
     android:orientation="horizontal">
 
-    <TextView android:id="@+id/time_current"
+    <TextView android:id="@id/exo_position"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_horizontal"
       android:textSize="14sp"
       android:textStyle="bold"
-      android:paddingTop="4dp"
-      android:paddingStart="4dp"
-      android:paddingEnd="4dp"
+      android:paddingLeft="4dp"
+      android:paddingRight="4dp"
+      android:includeFontPadding="false"
       android:textColor="#FFBEBEBE"/>
 
-    <SeekBar android:id="@+id/mediacontroller_progress"
+    <SeekBar android:id="@id/exo_progress"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="32dp"
+      android:focusable="false"
       style="?android:attr/progressBarStyleHorizontal"/>
 
-    <TextView android:id="@+id/time"
+    <TextView android:id="@id/exo_duration"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_horizontal"
       android:textSize="14sp"
       android:textStyle="bold"
-      android:paddingTop="4dp"
-      android:paddingEnd="4dp"
-      android:paddingStart="4dp"
+      android:paddingLeft="4dp"
+      android:paddingRight="4dp"
+      android:includeFontPadding="false"
       android:textColor="#FFBEBEBE"/>
 
   </LinearLayout>
diff --git a/library/src/main/res/layout/exo_simple_player_view.xml b/library/src/main/res/layout/exo_simple_player_view.xml
index 99945b8d25..1f59b7796d 100644
--- a/library/src/main/res/layout/exo_simple_player_view.xml
+++ b/library/src/main/res/layout/exo_simple_player_view.xml
@@ -13,28 +13,37 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_height="match_parent"
-    android:layout_width="match_parent">
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
 
-  <com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@+id/video_frame"
+  <com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@id/exo_content_frame"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:layout_gravity="center">
 
-    <View android:id="@+id/shutter"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      android:background="@android:color/black"/>
+    <!-- Video surface will be inserted as the first child of the content frame. -->
 
-    <com.google.android.exoplayer2.ui.SubtitleView android:id="@+id/subtitles"
+    <View android:id="@id/exo_shutter"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@android:color/black"/>
+
+    <ImageView android:id="@id/exo_artwork"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scaleType="fitXY"/>
+
+    <com.google.android.exoplayer2.ui.SubtitleView android:id="@id/exo_subtitles"
         android:layout_width="match_parent"
         android:layout_height="match_parent"/>
 
   </com.google.android.exoplayer2.ui.AspectRatioFrameLayout>
 
-  <com.google.android.exoplayer2.ui.PlaybackControlView android:id="@+id/control"
+  <View android:id="@id/exo_controller_placeholder"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+  <FrameLayout android:id="@id/exo_overlay"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
-</FrameLayout>
+</merge>
diff --git a/library/src/main/res/values-v11/styles.xml b/library/src/main/res/values-v11/styles.xml
new file mode 100644
index 0000000000..6f77440287
--- /dev/null
+++ b/library/src/main/res/values-v11/styles.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+  <style name="ExoMediaButton">
+    <item name="android:background">?android:attr/selectableItemBackground</item>
+    <item name="android:layout_width">@dimen/exo_media_button_width</item>
+    <item name="android:layout_height">@dimen/exo_media_button_height</item>
+  </style>
+
+</resources>
diff --git a/library/src/main/res/values/attrs.xml b/library/src/main/res/values/attrs.xml
index d58882c0aa..c73bfb0a3c 100644
--- a/library/src/main/res/values/attrs.xml
+++ b/library/src/main/res/values/attrs.xml
@@ -15,22 +15,37 @@
 -->
 <resources>
 
+  <!-- Must be kept in sync with AspectRatioFrameLayout -->
   <attr name="resize_mode" format="enum">
     <enum name="fit" value="0"/>
     <enum name="fixed_width" value="1"/>
     <enum name="fixed_height" value="2"/>
+    <enum name="fill" value="3"/>
+  </attr>
+
+  <!-- Must be kept in sync with SimpleExoPlayerView -->
+  <attr name="surface_type" format="enum">
+    <enum name="none" value="0"/>
+    <enum name="surface_view" value="1"/>
+    <enum name="texture_view" value="2"/>
   </attr>
   <attr name="show_timeout" format="integer"/>
   <attr name="rewind_increment" format="integer"/>
   <attr name="fastforward_increment" format="integer"/>
+  <attr name="player_layout_id" format="reference"/>
+  <attr name="controller_layout_id" format="reference"/>
 
   <declare-styleable name="SimpleExoPlayerView">
+    <attr name="use_artwork" format="boolean"/>
+    <attr name="default_artwork" format="reference"/>
     <attr name="use_controller" format="boolean"/>
-    <attr name="use_texture_view" format="boolean"/>
+    <attr name="surface_type"/>
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
     <attr name="fastforward_increment"/>
     <attr name="resize_mode"/>
+    <attr name="player_layout_id"/>
+    <attr name="controller_layout_id"/>
   </declare-styleable>
 
   <declare-styleable name="AspectRatioFrameLayout">
@@ -41,6 +56,7 @@
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
     <attr name="fastforward_increment"/>
+    <attr name="controller_layout_id"/>
   </declare-styleable>
 
 </resources>
diff --git a/library/src/main/res/values/constants.xml b/library/src/main/res/values/constants.xml
new file mode 100644
index 0000000000..5c86696ea0
--- /dev/null
+++ b/library/src/main/res/values/constants.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+  <dimen name="exo_media_button_width">71dp</dimen>
+  <dimen name="exo_media_button_height">52dp</dimen>
+
+</resources>
diff --git a/library/src/main/res/values/ids.xml b/library/src/main/res/values/ids.xml
new file mode 100644
index 0000000000..61db83825e
--- /dev/null
+++ b/library/src/main/res/values/ids.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+  <item name="exo_content_frame" type="id"/>
+  <item name="exo_shutter" type="id"/>
+  <item name="exo_subtitles" type="id"/>
+  <item name="exo_artwork" type="id"/>
+  <item name="exo_controller_placeholder" type="id"/>
+  <item name="exo_overlay" type="id"/>
+  <item name="exo_play" type="id"/>
+  <item name="exo_pause" type="id"/>
+  <item name="exo_rew" type="id"/>
+  <item name="exo_ffwd" type="id"/>
+  <item name="exo_prev" type="id"/>
+  <item name="exo_next" type="id"/>
+  <item name="exo_duration" type="id"/>
+  <item name="exo_position" type="id"/>
+  <item name="exo_progress" type="id"/>
+
+</resources>
diff --git a/library/src/main/res/values/styles.xml b/library/src/main/res/values/styles.xml
index fe1e26e967..a67cffe420 100644
--- a/library/src/main/res/values/styles.xml
+++ b/library/src/main/res/values/styles.xml
@@ -17,8 +17,8 @@
 
   <style name="ExoMediaButton">
     <item name="android:background">@null</item>
-    <item name="android:layout_width">71dip</item>
-    <item name="android:layout_height">52dip</item>
+    <item name="android:layout_width">@dimen/exo_media_button_width</item>
+    <item name="android:layout_height">@dimen/exo_media_button_height</item>
   </style>
 
   <style name="ExoMediaButton.Previous">
@@ -41,4 +41,14 @@
     <item name="android:contentDescription">@string/exo_controls_rewind_description</item>
   </style>
 
+  <style name="ExoMediaButton.Play">
+    <item name="android:src">@drawable/exo_controls_play</item>
+    <item name="android:contentDescription">@string/exo_controls_play_description</item>
+  </style>
+
+  <style name="ExoMediaButton.Pause">
+    <item name="android:src">@drawable/exo_controls_pause</item>
+    <item name="android:contentDescription">@string/exo_controls_pause_description</item>
+  </style>
+
 </resources>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index f6d59e758c..c53793b534 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -11,27 +11,16 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-apply plugin: 'com.android.application'
+apply plugin: 'com.android.library'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 16
+        minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
 }
 
 dependencies {
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..2f7bbe6d7c
--- /dev/null
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer2.playbacktests">
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.WAKE_LOCK"/>
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
+
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+    <uses-library android:name="android.test.runner"/>
+
+    <activity android:name="com.google.android.exoplayer2.playbacktests.util.HostActivity"
+        android:configChanges="keyboardHidden|orientation|screenSize"
+        android:label="ExoPlayerTest"/>
+
+  </application>
+
+  <instrumentation
+      android:targetPackage="com.google.android.exoplayer2.playbacktests"
+      android:name="android.test.InstrumentationTestRunner"
+      tools:replace="android:targetPackage"/>
+
+</manifest>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
similarity index 74%
rename from playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
rename to playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
index d9eade1c2f..5752058c4e 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
@@ -17,24 +17,34 @@
 
 import android.annotation.TargetApi;
 import android.media.MediaDrm;
+import android.media.MediaDrm.MediaDrmStateException;
 import android.media.UnsupportedSchemeException;
 import android.net.Uri;
-import android.os.Handler;
-import android.os.Looper;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
+import android.util.Pair;
+import android.view.Surface;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
+import com.google.android.exoplayer2.drm.OfflineLicenseHelper;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.playbacktests.util.ActionSchedule;
+import com.google.android.exoplayer2.playbacktests.util.DebugSimpleExoPlayer;
 import com.google.android.exoplayer2.playbacktests.util.DecoderCountersUtil;
 import com.google.android.exoplayer2.playbacktests.util.ExoHostedTest;
 import com.google.android.exoplayer2.playbacktests.util.HostActivity;
@@ -56,6 +66,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -271,7 +282,7 @@ public void testH264Adaptive() throws DecoderQueryException {
     }
     String streamName = "test_h264_adaptive";
     testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-            MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+        MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
@@ -596,6 +607,121 @@ public void testWidevine29FpsH264Fixed() throws DecoderQueryException {
         WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
   }
 
+  // Offline license tests
+
+  public void testWidevineOfflineLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      testDashPlayback(getActivity(), streamName, null, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+      helper.renewLicense();
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineReleasedLicense() throws Throwable {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      helper.releaseLicense(); // keySetId no longer valid.
+      try {
+        testDashPlayback(getActivity(), streamName, null, true, parameters,
+            WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+        fail("Playback should fail because the license has been released.");
+      } catch (Throwable e) {
+        // Get the root cause
+        while (true) {
+          Throwable cause = e.getCause();
+          if (cause == null || cause == e) {
+            break;
+          }
+          e = cause;
+        }
+        // It should be a MediaDrmStateException instance
+        if (!(e instanceof MediaDrmStateException)) {
+          throw e;
+        }
+      }
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineExpiredLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+
+      // Wait until the license expires
+      long licenseDuration = helper.getLicenseDurationRemainingSec().first;
+      assertTrue("License duration should be less than 30 sec. "
+          + "Server settings might have changed.", licenseDuration < 30);
+      while (licenseDuration > 0) {
+        synchronized (this) {
+          wait(licenseDuration * 1000 + 2000);
+        }
+        long previousDuration = licenseDuration;
+        licenseDuration = helper.getLicenseDurationRemainingSec().first;
+        assertTrue("License duration should be decreasing.", previousDuration > licenseDuration);
+      }
+
+      // DefaultDrmSessionManager should renew the license and stream play fine
+      testDashPlayback(getActivity(), streamName, null, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      // During playback pause until the license expires then continue playback
+      Pair<Long, Long> licenseDurationRemainingSec = helper.getLicenseDurationRemainingSec();
+      long licenseDuration = licenseDurationRemainingSec.first;
+      assertTrue("License duration should be less than 30 sec. "
+          + "Server settings might have changed.", licenseDuration < 30);
+      ActionSchedule schedule = new ActionSchedule.Builder(TAG)
+          .delay(3000).pause().delay(licenseDuration * 1000 + 2000).play().build();
+      // DefaultDrmSessionManager should renew the license and stream play fine
+      testDashPlayback(getActivity(), streamName, schedule, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
   // Internal.
 
   private void testDashPlayback(HostActivity activity, String streamName, String manifestFileName,
@@ -609,25 +735,39 @@ private void testDashPlayback(HostActivity activity, String streamName,
       ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
       String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
       boolean canIncludeAdditionalVideoFormats, String... videoFormats) {
+    testDashPlayback(activity, streamName, actionSchedule, fullPlaybackNoSeeking,
+        newDashHostedTestEncParameters(manifestFileName, isWidevineEncrypted, videoMimeType),
+        audioFormat, canIncludeAdditionalVideoFormats, null, videoFormats);
+  }
+
+  private void testDashPlayback(HostActivity activity, String streamName,
+      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking,
+      DashHostedTestEncParameters parameters, String audioFormat,
+      boolean canIncludeAdditionalVideoFormats, byte[] offlineLicenseKeySetId,
+      String... videoFormats) {
     MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
         REPORT_NAME, REPORT_OBJECT_NAME);
-    String manifestPath = MANIFEST_URL_PREFIX + manifestFileName;
-    DashHostedTest test = new DashHostedTest(streamName, manifestPath, metricsLogger,
-        fullPlaybackNoSeeking, audioFormat, isWidevineEncrypted, videoMimeType,
-        canIncludeAdditionalVideoFormats, false, actionSchedule, videoFormats);
+    DashHostedTest test = new DashHostedTest(streamName, metricsLogger, fullPlaybackNoSeeking,
+        audioFormat, canIncludeAdditionalVideoFormats, false, actionSchedule, parameters,
+        offlineLicenseKeySetId, videoFormats);
     activity.runTest(test, TEST_TIMEOUT_MS);
     // Retry test exactly once if adaptive test fails due to excessive dropped buffers when playing
     // non-CDD required formats (b/28220076).
     if (test.needsCddLimitedRetry) {
       metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG, REPORT_NAME,
           REPORT_OBJECT_NAME);
-      test = new DashHostedTest(streamName, manifestPath, metricsLogger, fullPlaybackNoSeeking,
-          audioFormat, isWidevineEncrypted, videoMimeType, false, true, actionSchedule,
-          videoFormats);
+      test = new DashHostedTest(streamName, metricsLogger, fullPlaybackNoSeeking, audioFormat,
+          false, true, actionSchedule, parameters, offlineLicenseKeySetId, videoFormats);
       activity.runTest(test, TEST_TIMEOUT_MS);
     }
   }
 
+  private static DashHostedTestEncParameters newDashHostedTestEncParameters(String manifestFileName,
+      boolean isWidevineEncrypted, String videoMimeType) {
+    String manifestPath = MANIFEST_URL_PREFIX + manifestFileName;
+    return new DashHostedTestEncParameters(manifestPath, isWidevineEncrypted, videoMimeType);
+  }
+
   private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQueryException {
     MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false);
     assertNotNull(decoderInfo);
@@ -638,48 +778,139 @@ private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQue
     return true;
   }
 
+  private static class DashHostedTestEncParameters {
+
+    public final String manifestUrl;
+    public final boolean useL1Widevine;
+    public final String widevineLicenseUrl;
+    public final boolean isWidevineEncrypted;
+
+    public DashHostedTestEncParameters(String manifestUrl, boolean isWidevineEncrypted,
+        String videoMimeType) {
+      this.isWidevineEncrypted = isWidevineEncrypted;
+      if (!isWidevineEncrypted) {
+        this.manifestUrl = manifestUrl;
+        this.useL1Widevine = true;
+        this.widevineLicenseUrl = null;
+      } else {
+        this.useL1Widevine = isL1WidevineAvailable(videoMimeType);
+        this.widevineLicenseUrl = WIDEVINE_LICENSE_URL + (useL1Widevine
+            ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID);
+        this.manifestUrl =
+            manifestUrl + (useL1Widevine ? WIDEVINE_L1_SUFFIX : WIDEVINE_L3_SUFFIX);
+      }
+    }
+
+    @TargetApi(18)
+    @SuppressWarnings("ResourceType")
+    private static boolean isL1WidevineAvailable(String videoMimeType) {
+      try {
+        // Force L3 if secure decoder is not available.
+        if (MediaCodecUtil.getDecoderInfo(videoMimeType, true) == null) {
+          return false;
+        }
+
+        MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
+        String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+        mediaDrm.release();
+        return WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
+      } catch (DecoderQueryException | UnsupportedSchemeException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+
+  }
+
+  private static class TestOfflineLicenseHelper {
+
+    private final DashHostedTestEncParameters parameters;
+    private final OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper;
+    private final DefaultHttpDataSourceFactory httpDataSourceFactory;
+    private byte[] offlineLicenseKeySetId;
+
+    public TestOfflineLicenseHelper(DashHostedTestEncParameters parameters)
+        throws UnsupportedDrmException {
+      this.parameters = parameters;
+      httpDataSourceFactory = new DefaultHttpDataSourceFactory("ExoPlayerPlaybackTests");
+      offlineLicenseHelper = OfflineLicenseHelper.newWidevineInstance(
+          parameters.widevineLicenseUrl, httpDataSourceFactory);
+    }
+
+    public byte[] downloadLicense() throws InterruptedException, DrmSessionException, IOException {
+      assertNull(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = offlineLicenseHelper
+          .download(httpDataSourceFactory.createDataSource(), parameters.manifestUrl);
+      assertNotNull(offlineLicenseKeySetId);
+      assertTrue(offlineLicenseKeySetId.length > 0);
+      return offlineLicenseKeySetId;
+    }
+
+    public void renewLicense() throws DrmSessionException {
+      assertNotNull(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+      assertNotNull(offlineLicenseKeySetId);
+    }
+
+    public void releaseLicense() throws DrmSessionException {
+      assertNotNull(offlineLicenseKeySetId);
+      offlineLicenseHelper.release(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = null;
+    }
+
+    public Pair<Long, Long> getLicenseDurationRemainingSec() throws DrmSessionException {
+      return offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+    }
+
+    public void releaseResources() throws DrmSessionException {
+      if (offlineLicenseKeySetId != null) {
+        releaseLicense();
+      }
+      if (offlineLicenseHelper != null) {
+        offlineLicenseHelper.releaseResources();
+      }
+    }
+
+  }
+
   @TargetApi(16)
   private static class DashHostedTest extends ExoHostedTest {
 
     private final String streamName;
-    private final String videoMimeType;
-    private final String manifestPath;
     private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
     private final boolean isCddLimitedRetry;
-    private final boolean isWidevineEncrypted;
     private final DashTestTrackSelector trackSelector;
+    private final DashHostedTestEncParameters parameters;
+    private final byte[] offlineLicenseKeySetId;
 
     private boolean needsCddLimitedRetry;
-    private boolean needsSecureVideoDecoder;
 
     /**
      * @param streamName The name of the test stream for metric logging.
-     * @param manifestPath The manifest path.
      * @param metricsLogger Logger to log metrics from the test.
      * @param fullPlaybackNoSeeking Whether the test will play the entire source with no seeking.
      * @param audioFormat The audio format.
-     * @param isWidevineEncrypted Whether the video is Widevine encrypted.
-     * @param videoMimeType The video mime type.
      * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to those
      *     listed in the videoFormats argument, if the device is capable of playing them.
      * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
      * @param actionSchedule The action schedule for the test.
+     * @param parameters Encryption parameters.
+     * @param offlineLicenseKeySetId The key set id of the license to be used.
      * @param videoFormats The video formats.
      */
-    public DashHostedTest(String streamName, String manifestPath, MetricsLogger metricsLogger,
-        boolean fullPlaybackNoSeeking, String audioFormat, boolean isWidevineEncrypted,
-        String videoMimeType, boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
-        ActionSchedule actionSchedule, String... videoFormats) {
+    public DashHostedTest(String streamName, MetricsLogger metricsLogger,
+        boolean fullPlaybackNoSeeking, String audioFormat,
+        boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
+        ActionSchedule actionSchedule, DashHostedTestEncParameters parameters,
+        byte[] offlineLicenseKeySetId, String... videoFormats) {
       super(TAG, fullPlaybackNoSeeking);
       Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
       this.streamName = streamName;
-      this.manifestPath = manifestPath;
       this.metricsLogger = metricsLogger;
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
-      this.isWidevineEncrypted = isWidevineEncrypted;
-      this.videoMimeType = videoMimeType;
       this.isCddLimitedRetry = isCddLimitedRetry;
+      this.parameters = parameters;
+      this.offlineLicenseKeySetId = offlineLicenseKeySetId;
       trackSelector = new DashTestTrackSelector(audioFormat, videoFormats,
           canIncludeAdditionalVideoFormats);
       if (actionSchedule != null) {
@@ -694,32 +925,23 @@ protected MappingTrackSelector buildTrackSelector(HostActivity host,
     }
 
     @Override
-    @TargetApi(18)
-    @SuppressWarnings("ResourceType")
-    protected final StreamingDrmSessionManager buildDrmSessionManager(final String userAgent) {
-      StreamingDrmSessionManager drmSessionManager = null;
-      if (isWidevineEncrypted) {
+    protected final DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
+        final String userAgent) {
+      DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
+      if (parameters.isWidevineEncrypted) {
         try {
-          // Force L3 if secure decoder is not available.
-          boolean forceL3Widevine = MediaCodecUtil.getDecoderInfo(videoMimeType, true) == null;
-          MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
-          String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          String widevineContentId = forceL3Widevine ? WIDEVINE_SW_CRYPTO_CONTENT_ID
-              : WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty)
-              ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID;
-          HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(
-              WIDEVINE_LICENSE_URL + widevineContentId,
+          MediaDrmCallback drmCallback = new HttpMediaDrmCallback(parameters.widevineLicenseUrl,
               new DefaultHttpDataSourceFactory(userAgent));
-          drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(drmCallback, null,
+          drmSessionManager = DefaultDrmSessionManager.newWidevineInstance(drmCallback, null,
               null, null);
-          if (forceL3Widevine && !WIDEVINE_SECURITY_LEVEL_3.equals(securityProperty)) {
+          if (!parameters.useL1Widevine) {
             drmSessionManager.setPropertyString(SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
           }
-          // Check if secure video decoder is required.
-          securityProperty = drmSessionManager.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          needsSecureVideoDecoder = WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
-        } catch (MediaCodecUtil.DecoderQueryException | UnsupportedSchemeException
-            | UnsupportedDrmException e) {
+          if (offlineLicenseKeySetId != null) {
+            drmSessionManager.setMode(DefaultDrmSessionManager.MODE_PLAYBACK,
+                offlineLicenseKeySetId);
+          }
+        } catch (UnsupportedDrmException e) {
           throw new IllegalStateException(e);
         }
       }
@@ -727,15 +949,22 @@ protected final StreamingDrmSessionManager buildDrmSessionManager(final String u
     }
 
     @Override
-    public MediaSource buildSource(HostActivity host, String userAgent,
+    protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
+        MappingTrackSelector trackSelector,
+        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      SimpleExoPlayer player = new DebugSimpleExoPlayer(host, trackSelector,
+          new DefaultLoadControl(), drmSessionManager);
+      player.setVideoSurface(surface);
+      return player;
+    }
+
+    @Override
+    protected MediaSource buildSource(HostActivity host, String userAgent,
         TransferListener<? super DataSource> mediaTransferListener) {
       DataSource.Factory manifestDataSourceFactory = new DefaultDataSourceFactory(host, userAgent);
       DataSource.Factory mediaDataSourceFactory = new DefaultDataSourceFactory(host, userAgent,
           mediaTransferListener);
-      String manifestUrl = manifestPath;
-      manifestUrl += isWidevineEncrypted ? (needsSecureVideoDecoder ? WIDEVINE_L1_SUFFIX
-          : WIDEVINE_L3_SUFFIX) : "";
-      Uri manifestUri = Uri.parse(manifestUrl);
+      Uri manifestUri = Uri.parse(parameters.manifestUrl);
       DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
           mediaDataSourceFactory);
       return new DashMediaSource(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
@@ -803,7 +1032,6 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
 
     private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
         boolean canIncludeAdditionalVideoFormats) {
-      super(new Handler(Looper.getMainLooper()));
       this.audioFormatId = audioFormatId;
       this.videoFormatIds = videoFormatIds;
       this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
@@ -822,7 +1050,7 @@ private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
       TrackSelection[] selections = new TrackSelection[rendererCapabilities.length];
       selections[VIDEO_RENDERER_INDEX] = new RandomTrackSelection(
           rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
-          getTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
+          getVideoTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
               rendererFormatSupports[VIDEO_RENDERER_INDEX][0], videoFormatIds,
               canIncludeAdditionalVideoFormats),
           0 /* seed */);
@@ -834,20 +1062,24 @@ private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
       return selections;
     }
 
-    private static int[] getTrackIndices(TrackGroup trackGroup, int[] formatSupport,
+    private static int[] getVideoTrackIndices(TrackGroup trackGroup, int[] formatSupport,
         String[] formatIds, boolean canIncludeAdditionalFormats) {
       List<Integer> trackIndices = new ArrayList<>();
 
       // Always select explicitly listed representations.
       for (String formatId : formatIds) {
-        trackIndices.add(getTrackIndex(trackGroup, formatId));
+        int trackIndex = getTrackIndex(trackGroup, formatId);
+        Log.d(TAG, "Adding base video format: "
+            + Format.toLogString(trackGroup.getFormat(trackIndex)));
+        trackIndices.add(trackIndex);
       }
 
       // Select additional video representations, if supported by the device.
       if (canIncludeAdditionalFormats) {
         for (int i = 0; i < trackGroup.length; i++) {
           if (!trackIndices.contains(i) && isFormatHandled(formatSupport[i])) {
-            Log.d(TAG, "Adding video format: " + trackGroup.getFormat(i).id);
+            Log.d(TAG, "Adding extra video format: "
+                + Format.toLogString(trackGroup.getFormat(i)));
             trackIndices.add(i);
           }
         }
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 58ede793b2..8df75b0da1 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -14,30 +14,4 @@
      limitations under the License.
 -->
 
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    package="com.google.android.exoplayer2.playbacktests"
-    android:versionCode="2003"
-    android:versionName="2.0.3">
-
-  <uses-permission android:name="android.permission.INTERNET"/>
-  <uses-permission android:name="android.permission.WAKE_LOCK"/>
-
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="24"/>
-
-  <application android:debuggable="true"
-      android:allowBackup="false"
-      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
-    <uses-library android:name="android.test.runner"/>
-
-    <activity android:name="com.google.android.exoplayer2.playbacktests.util.HostActivity"
-        android:configChanges="keyboardHidden|orientation|screenSize"
-        android:label="ExoPlayerTest"/>
-
-  </application>
-
-  <instrumentation
-      android:targetPackage="com.google.android.exoplayer2.playbacktests"
-      android:name="android.test.InstrumentationTestRunner"/>
-
-</manifest>
+<manifest package="com.google.android.exoplayer2.playbacktests"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugMediaCodecVideoRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugMediaCodecVideoRenderer.java
deleted file mode 100644
index cbc5f35e94..0000000000
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugMediaCodecVideoRenderer.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.playbacktests.util;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Handler;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
-import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
-import com.google.android.exoplayer2.video.VideoRendererEventListener;
-
-/**
- * Decodes and renders video using {@link MediaCodecVideoRenderer}. Provides buffer timestamp
- * assertions.
- */
-@TargetApi(16)
-public class DebugMediaCodecVideoRenderer extends MediaCodecVideoRenderer {
-
-  private static final int ARRAY_SIZE = 1000;
-
-  private final long[] timestampsList = new long[ARRAY_SIZE];
-
-  private int startIndex;
-  private int queueSize;
-  private int bufferCount;
-
-  public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-      int videoScalingMode, long allowedJoiningTimeMs, Handler eventHandler,
-      VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
-    super(context, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
-        eventHandler, eventListener, maxDroppedFrameCountToNotify);
-    startIndex = 0;
-    queueSize = 0;
-  }
-
-  @Override
-  protected void releaseCodec() {
-    super.releaseCodec();
-    clearTimestamps();
-  }
-
-  @Override
-  protected void flushCodec() throws ExoPlaybackException {
-    super.flushCodec();
-    clearTimestamps();
-  }
-
-  @Override
-  protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
-    insertTimestamp(buffer.timeUs);
-    maybeShiftTimestampsList();
-  }
-
-  @Override
-  protected void onProcessedOutputBuffer(long presentationTimeUs) {
-    bufferCount++;
-    long expectedTimestampUs = dequeueTimestamp();
-    if (expectedTimestampUs != presentationTimeUs) {
-      throw new IllegalStateException("Expected to dequeue video buffer with presentation "
-          + "timestamp: " + expectedTimestampUs + ". Instead got: " + presentationTimeUs
-          + " (Processed buffers since last flush: " + bufferCount + ").");
-    }
-  }
-
-  private void clearTimestamps() {
-    startIndex = 0;
-    queueSize = 0;
-    bufferCount = 0;
-  }
-
-  private void insertTimestamp(long presentationTimeUs) {
-    for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
-      if (presentationTimeUs >= timestampsList[i]) {
-        timestampsList[i + 1] = presentationTimeUs;
-        queueSize++;
-        return;
-      }
-      timestampsList[i + 1] = timestampsList[i];
-    }
-    timestampsList[startIndex] = presentationTimeUs;
-    queueSize++;
-  }
-
-  private void maybeShiftTimestampsList() {
-    if (startIndex + queueSize == ARRAY_SIZE) {
-      System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
-      startIndex = 0;
-    }
-  }
-
-  private long dequeueTimestamp() {
-    startIndex++;
-    queueSize--;
-    return timestampsList[startIndex - 1];
-  }
-}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
new file mode 100644
index 0000000000..ede172ad29
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.util;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Handler;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.Renderer;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.util.ArrayList;
+
+/**
+ * A debug extension of {@link SimpleExoPlayer}. Provides video buffer timestamp assertions.
+ */
+@TargetApi(16)
+public class DebugSimpleExoPlayer extends SimpleExoPlayer {
+
+  public DebugSimpleExoPlayer(Context context, TrackSelector trackSelector,
+      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+    super(context, trackSelector, loadControl, drmSessionManager,
+        SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF, 0);
+  }
+
+  @Override
+  protected void buildVideoRenderers(Context context, Handler mainHandler,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      @ExtensionRendererMode int extensionRendererMode, VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
+    out.add(new DebugMediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
+        allowedVideoJoiningTimeMs, mainHandler, drmSessionManager, eventListener,
+        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+  }
+
+  /**
+   * Decodes and renders video using {@link MediaCodecVideoRenderer}. Provides buffer timestamp
+   * assertions.
+   */
+  private static class DebugMediaCodecVideoRenderer extends MediaCodecVideoRenderer {
+
+    private static final int ARRAY_SIZE = 1000;
+
+    private final long[] timestampsList = new long[ARRAY_SIZE];
+
+    private int startIndex;
+    private int queueSize;
+    private int bufferCount;
+    private int minimumInsertIndex;
+
+    public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
+        long allowedJoiningTimeMs, Handler eventHandler,
+        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+        VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
+      super(context, mediaCodecSelector, allowedJoiningTimeMs, drmSessionManager, false,
+          eventHandler, eventListener, maxDroppedFrameCountToNotify);
+    }
+
+    @Override
+    protected void releaseCodec() {
+      super.releaseCodec();
+      clearTimestamps();
+    }
+
+    @Override
+    protected void flushCodec() throws ExoPlaybackException {
+      super.flushCodec();
+      clearTimestamps();
+    }
+
+    @Override
+    protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+      super.onInputFormatChanged(newFormat);
+      // Ensure timestamps of buffers queued after this format change are never inserted into the
+      // queue of expected output timestamps before those of buffers that have already been queued.
+      minimumInsertIndex = startIndex + queueSize;
+    }
+
+    @Override
+    protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+      insertTimestamp(buffer.timeUs);
+      maybeShiftTimestampsList();
+    }
+
+    @Override
+    protected void onProcessedOutputBuffer(long presentationTimeUs) {
+      bufferCount++;
+      long expectedTimestampUs = dequeueTimestamp();
+      if (expectedTimestampUs != presentationTimeUs) {
+        throw new IllegalStateException("Expected to dequeue video buffer with presentation "
+            + "timestamp: " + expectedTimestampUs + ". Instead got: " + presentationTimeUs
+            + " (Processed buffers since last flush: " + bufferCount + ").");
+      }
+    }
+
+    private void clearTimestamps() {
+      startIndex = 0;
+      queueSize = 0;
+      bufferCount = 0;
+      minimumInsertIndex = 0;
+    }
+
+    private void insertTimestamp(long presentationTimeUs) {
+      for (int i = startIndex + queueSize - 1; i >= minimumInsertIndex; i--) {
+        if (presentationTimeUs >= timestampsList[i]) {
+          timestampsList[i + 1] = presentationTimeUs;
+          queueSize++;
+          return;
+        }
+        timestampsList[i + 1] = timestampsList[i];
+      }
+      timestampsList[minimumInsertIndex] = presentationTimeUs;
+      queueSize++;
+    }
+
+    private void maybeShiftTimestampsList() {
+      if (startIndex + queueSize == ARRAY_SIZE) {
+        System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
+        minimumInsertIndex -= startIndex;
+        startIndex = 0;
+      }
+    }
+
+    private long dequeueTimestamp() {
+      queueSize--;
+      startIndex++;
+      minimumInsertIndex = Math.max(minimumInsertIndex, startIndex);
+      return timestampsList[startIndex - 1];
+    }
+
+  }
+
+}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
index b8ac1eb76c..7bf8985b64 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
@@ -30,11 +30,14 @@
 import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.playbacktests.util.HostActivity.HostedTest;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
@@ -130,7 +133,7 @@ public final void onStart(HostActivity host, Surface surface) {
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
     trackSelector = buildTrackSelector(host, bandwidthMeter);
     String userAgent = "ExoPlayerPlaybackTests";
-    DrmSessionManager drmSessionManager = buildDrmSessionManager(userAgent);
+    DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
     player = buildExoPlayer(host, surface, trackSelector, drmSessionManager);
     player.prepare(buildSource(host, Util.getUserAgent(host, userAgent), bandwidthMeter));
     player.addListener(this);
@@ -185,6 +188,11 @@ public void onLoadingChanged(boolean isLoading) {
     // Do nothing.
   }
 
+  @Override
+  public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+    // Do nothing.
+  }
+
   @Override
   public final void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     Log.d(tag, "state [" + playWhenReady + ", " + playbackState + "]");
@@ -239,7 +247,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(tag, "audioFormatChanged [" + format.id + "]");
+    Log.d(tag, "audioFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
@@ -269,7 +277,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(tag, "videoFormatChanged [" + format.id + "]");
+    Log.d(tag, "videoFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
@@ -296,7 +304,7 @@ public void onRenderedFirstFrame(Surface surface) {
 
   // Internal logic
 
-  protected DrmSessionManager buildDrmSessionManager(String userAgent) {
+  protected DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(String userAgent) {
     // Do nothing. Interested subclasses may override.
     return null;
   }
@@ -304,14 +312,16 @@ protected DrmSessionManager buildDrmSessionManager(String userAgent) {
   @SuppressWarnings("unused")
   protected MappingTrackSelector buildTrackSelector(HostActivity host,
       BandwidthMeter bandwidthMeter) {
-    return new DefaultTrackSelector(null, new AdaptiveVideoTrackSelection.Factory(bandwidthMeter));
+    return new DefaultTrackSelector(new AdaptiveVideoTrackSelection.Factory(bandwidthMeter));
   }
 
   @SuppressWarnings("unused")
   protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
-      MappingTrackSelector trackSelector, DrmSessionManager drmSessionManager) {
+      MappingTrackSelector trackSelector,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(host, trackSelector,
-        new DefaultLoadControl(), drmSessionManager, false, 0);
+        new DefaultLoadControl(), drmSessionManager, SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF,
+        0);
     player.setVideoSurface(surface);
     return player;
   }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/HostActivity.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/HostActivity.java
index 2a890b7c7f..9c2ced3a8a 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/HostActivity.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/HostActivity.java
@@ -232,7 +232,7 @@ public void run() {
   }
 
   @SuppressLint("InlinedApi")
-  private static final int getWifiLockMode() {
+  private static int getWifiLockMode() {
     return Util.SDK_INT < 12 ? WifiManager.WIFI_MODE_FULL : WifiManager.WIFI_MODE_FULL_HIGH_PERF;
   }
 
diff --git a/testutils/build.gradle b/testutils/build.gradle
index 61bb50f74d..83ff065f9a 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -1,3 +1,16 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 apply plugin: 'com.android.library'
 
 android {
@@ -8,13 +21,6 @@ android {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
 }
 
 dependencies {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 6f4578b694..fd971892b4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.app.Instrumentation;
+import android.content.Context;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -65,28 +66,23 @@ public static boolean sniffTestData(Extractor extractor, FakeExtractorInput inpu
     }
   }
 
-  public static FakeExtractorOutput consumeTestData(Extractor extractor, byte[] data)
-      throws IOException, InterruptedException {
-    return consumeTestData(extractor, newExtractorInput(data));
-  }
-
-  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input)
-      throws IOException, InterruptedException {
-    return consumeTestData(extractor, input, false);
+  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
+      long timeUs) throws IOException, InterruptedException {
+    return consumeTestData(extractor, input, timeUs, false);
   }
 
   public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
-      boolean retryFromStartIfLive) throws IOException, InterruptedException {
+      long timeUs, boolean retryFromStartIfLive) throws IOException, InterruptedException {
     FakeExtractorOutput output = new FakeExtractorOutput();
     extractor.init(output);
-    consumeTestData(extractor, input, output, retryFromStartIfLive);
+    consumeTestData(extractor, input, timeUs, output, retryFromStartIfLive);
     return output;
   }
 
-  private static void consumeTestData(Extractor extractor, FakeExtractorInput input,
+  private static void consumeTestData(Extractor extractor, FakeExtractorInput input, long timeUs,
       FakeExtractorOutput output, boolean retryFromStartIfLive)
       throws IOException, InterruptedException {
-    extractor.seek(input.getPosition());
+    extractor.seek(input.getPosition(), timeUs);
     PositionHolder seekPositionHolder = new PositionHolder();
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
@@ -113,7 +109,7 @@ private static void consumeTestData(Extractor extractor, FakeExtractorInput inpu
         for (int i = 0; i < output.numberOfTracks; i++) {
           output.trackOutputs.valueAt(i).clear();
         }
-        extractor.seek(0);
+        extractor.seek(0, 0);
       }
     }
   }
@@ -276,7 +272,7 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String sampl
 
     Assert.assertTrue(sniffTestData(extractor, input));
     input.resetPeekPosition();
-    FakeExtractorOutput extractorOutput = consumeTestData(extractor, input, true);
+    FakeExtractorOutput extractorOutput = consumeTestData(extractor, input, 0, true);
 
     if (simulateUnknownLength
         && assetExists(instrumentation, sampleFile + UNKNOWN_LENGTH_EXTENSION)) {
@@ -296,7 +292,7 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String sampl
           extractorOutput.trackOutputs.valueAt(i).clear();
         }
 
-        consumeTestData(extractor, input, extractorOutput, false);
+        consumeTestData(extractor, input, timeUs, extractorOutput, false);
         extractorOutput.assertOutput(instrumentation, sampleFile + '.' + j + DUMP_EXTENSION);
       }
     }
@@ -304,6 +300,81 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String sampl
     return extractorOutput;
   }
 
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param sampleFile The path to the input sample.
+   * @param instrumentation To be used to load the sample file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, String sampleFile,
+      Instrumentation instrumentation, Class<? extends Throwable> expectedThrowable)
+      throws IOException, InterruptedException {
+    byte[] fileData = getByteArray(instrumentation, sampleFile);
+    assertThrows(factory, fileData, expectedThrowable);
+  }
+
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable) throws IOException, InterruptedException {
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true,  true);
+  }
+
+  /**
+   * Asserts {@code extractor} throws {@code expectedThrowable} while consuming {@code sampleFile}.
+   *
+   * @param extractor The {@link Extractor} to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @param simulateIOErrors If true simulates IOErrors.
+   * @param simulateUnknownLength If true simulates unknown input length.
+   * @param simulatePartialReads If true simulates partial reads.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  public static void assertThrows(Extractor extractor, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable, boolean simulateIOErrors,
+      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
+      InterruptedException {
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(fileData)
+        .setSimulateIOErrors(simulateIOErrors)
+        .setSimulateUnknownLength(simulateUnknownLength)
+        .setSimulatePartialReads(simulatePartialReads).build();
+    try {
+      consumeTestData(extractor, input, 0, true);
+      throw new AssertionError(expectedThrowable.getSimpleName() + " expected but not thrown");
+    } catch (Throwable throwable) {
+      if (expectedThrowable.equals(throwable.getClass())) {
+        return; // Pass!
+      }
+      throw throwable;
+    }
+  }
+
   public static void recursiveDelete(File fileOrDirectory) {
     if (fileOrDirectory.isDirectory()) {
       for (File child : fileOrDirectory.listFiles()) {
@@ -313,4 +384,12 @@ public static void recursiveDelete(File fileOrDirectory) {
     fileOrDirectory.delete();
   }
 
+  /** Creates an empty folder in the application specific cache directory. */
+  public static File createTempFolder(Context context) throws IOException {
+    File tempFolder = File.createTempFile("ExoPlayerTest", null, context.getCacheDir());
+    Assert.assertTrue(tempFolder.delete());
+    Assert.assertTrue(tempFolder.mkdir());
+    return tempFolder;
+  }
+
 }
