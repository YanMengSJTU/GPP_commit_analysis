diff --git a/build.gradle b/build.gradle
index 96eade1aa3..bd04ec9851 100644
--- a/build.gradle
+++ b/build.gradle
@@ -12,14 +12,16 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 buildscript {
+    ext.kotlin_version = '1.3.21'
     repositories {
         google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.4'
+        classpath 'com.android.tools.build:gradle:3.3.2'
         classpath 'com.novoda:bintray-release:0.8.1'
-        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.0.3'
+        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.1.0'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
     // Workaround for the following test coverage issue. Remove when fixed:
     // https://code.google.com/p/android/issues/detail?id=226070
diff --git a/captures/com.google.android.exoplayer2.demo_2019.03.05_12.29.li b/captures/com.google.android.exoplayer2.demo_2019.03.05_12.29.li
new file mode 100644
index 0000000000..13ccabc680
Binary files /dev/null and b/captures/com.google.android.exoplayer2.demo_2019.03.05_12.29.li differ
diff --git a/captures/com.google.android.exoplayer2.demo_2019.03.05_16.01.li b/captures/com.google.android.exoplayer2.demo_2019.03.05_16.01.li
new file mode 100644
index 0000000000..96d77b67c3
Binary files /dev/null and b/captures/com.google.android.exoplayer2.demo_2019.03.05_16.01.li differ
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 6395ea4c24..f40aa5006e 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -53,7 +53,9 @@
 import java.util.Collections;
 import java.util.List;
 
-/** An activity for selecting from a list of media samples. */
+/**
+ * An activity for selecting from a list of media samples.
+ */
 public class SampleChooserActivity extends Activity
     implements DownloadTracker.Listener, OnChildClickListener {
 
@@ -78,7 +80,7 @@ public void onCreate(Bundle savedInstanceState) {
     String dataUri = intent.getDataString();
     String[] uris;
     if (dataUri != null) {
-      uris = new String[] {dataUri};
+      uris = new String[]{dataUri};
     } else {
       ArrayList<String> uriList = new ArrayList<>();
       AssetManager assetManager = getAssets();
@@ -491,6 +493,7 @@ public SampleGroup(String title) {
   }
 
   private static final class DrmInfo {
+
     public final String drmScheme;
     public final String drmLicenseUrl;
     public final String[] drmKeyRequestProperties;
@@ -517,6 +520,7 @@ public void updateIntent(Intent intent) {
   }
 
   private abstract static class Sample {
+
     public final String name;
     public final DrmInfo drmInfo;
 
diff --git a/demos/main/src/main/res/layout/player_activity.xml b/demos/main/src/main/res/layout/player_activity.xml
index 6b84033273..8546d6ece6 100644
--- a/demos/main/src/main/res/layout/player_activity.xml
+++ b/demos/main/src/main/res/layout/player_activity.xml
@@ -42,6 +42,7 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="horizontal"
+      tools:visibility="visible"
         android:visibility="gone"/>
 
   </LinearLayout>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 5559e8ccfa..ad8cb8cd14 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 367f15f028..22ae334673 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -13,6 +13,8 @@
 // limitations under the License.
 apply from: '../../constants.gradle'
 apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android-extensions'
+apply plugin: 'kotlin-android'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
@@ -41,6 +43,7 @@ dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
     testImplementation project(modulePrefix + 'testutils-robolectric')
 }
@@ -55,3 +58,6 @@ ext {
     releaseDescription = 'The ExoPlayer library UI module.'
 }
 apply from: '../../publish.gradle'
+repositories {
+    mavenCentral()
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 5467538c0f..0b4b94ee1a 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -44,18 +44,20 @@
   public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new DefaultControlDispatcher();
 
   /** The default fast forward increment, in milliseconds. */
-  public static final int DEFAULT_FAST_FORWARD_MS = PlayerControlView.DEFAULT_FAST_FORWARD_MS;
+  public static final int DEFAULT_FAST_FORWARD_MS = PlayerControlView.Companion
+      .getDEFAULT_FAST_FORWARD_MS();
   /** The default rewind increment, in milliseconds. */
-  public static final int DEFAULT_REWIND_MS = PlayerControlView.DEFAULT_REWIND_MS;
+  public static final int DEFAULT_REWIND_MS = PlayerControlView.Companion.getDEFAULT_REWIND_MS();
   /** The default show timeout, in milliseconds. */
-  public static final int DEFAULT_SHOW_TIMEOUT_MS = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
+  public static final int DEFAULT_SHOW_TIMEOUT_MS = PlayerControlView.Companion
+      .getDEFAULT_SHOW_TIMEOUT_MS();
   /** The default repeat toggle modes. */
   public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      PlayerControlView.DEFAULT_REPEAT_TOGGLE_MODES;
+      PlayerControlView.Companion.getDEFAULT_REPEAT_TOGGLE_MODES();
 
   /** The maximum number of windows that can be shown in a multi-window time bar. */
   public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR =
-      PlayerControlView.MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR;
+      PlayerControlView.Companion.getMAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR();
 
   public PlaybackControlView(Context context) {
     super(context);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
deleted file mode 100644
index 8ab4210465..0000000000
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ /dev/null
@@ -1,1124 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ui;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.os.Looper;
-import android.os.SystemClock;
-import android.support.annotation.Nullable;
-import android.util.AttributeSet;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.TextView;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.PlaybackPreparer;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.RepeatModeUtil;
-import com.google.android.exoplayer2.util.Util;
-import java.util.Arrays;
-import java.util.Formatter;
-import java.util.Locale;
-
-/**
- * A view for controlling {@link Player} instances.
- *
- * <p>A PlayerControlView can be customized by setting attributes (or calling corresponding
- * methods), overriding the view's layout file or by specifying a custom view layout file, as
- * outlined below.
- *
- * <h3>Attributes</h3>
- *
- * The following attributes can be set on a PlayerControlView when used in a layout XML file:
- *
- * <ul>
- *   <li><b>{@code show_timeout}</b> - The time between the last user interaction and the controls
- *       being automatically hidden, in milliseconds. Use zero if the controls should not
- *       automatically timeout.
- *       <ul>
- *         <li>Corresponding method: {@link #setShowTimeoutMs(int)}
- *         <li>Default: {@link #DEFAULT_SHOW_TIMEOUT_MS}
- *       </ul>
- *   <li><b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
- *       rewind button, in milliseconds. Use zero to disable the rewind button.
- *       <ul>
- *         <li>Corresponding method: {@link #setRewindIncrementMs(int)}
- *         <li>Default: {@link #DEFAULT_REWIND_MS}
- *       </ul>
- *   <li><b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
- *       <ul>
- *         <li>Corresponding method: {@link #setFastForwardIncrementMs(int)}
- *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS}
- *       </ul>
- *   <li><b>{@code repeat_toggle_modes}</b> - A flagged enumeration value specifying which repeat
- *       mode toggle options are enabled. Valid values are: {@code none}, {@code one}, {@code all},
- *       or {@code one|all}.
- *       <ul>
- *         <li>Corresponding method: {@link #setRepeatToggleModes(int)}
- *         <li>Default: {@link PlayerControlView#DEFAULT_REPEAT_TOGGLE_MODES}
- *       </ul>
- *   <li><b>{@code show_shuffle_button}</b> - Whether the shuffle button is shown.
- *       <ul>
- *         <li>Corresponding method: {@link #setShowShuffleButton(boolean)}
- *         <li>Default: false
- *       </ul>
- *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
- *       below for more details.
- *       <ul>
- *         <li>Corresponding method: None
- *         <li>Default: {@code R.layout.exo_player_control_view}
- *       </ul>
- * </ul>
- *
- * <h3>Overriding the layout file</h3>
- *
- * To customize the layout of PlayerControlView throughout your app, or just for certain
- * configurations, you can define {@code exo_player_control_view.xml} layout files in your
- * application {@code res/layout*} directories. These layouts will override the one provided by the
- * ExoPlayer library, and will be inflated for use by PlayerControlView. The view identifies and
- * binds its children by looking for the following ids:
- *
- * <p>
- *
- * <ul>
- *   <li><b>{@code exo_play}</b> - The play button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_pause}</b> - The pause button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_ffwd}</b> - The fast forward button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_rew}</b> - The rewind button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_prev}</b> - The previous track button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_next}</b> - The next track button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_repeat_toggle}</b> - The repeat toggle button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_shuffle}</b> - The shuffle button.
- *       <ul>
- *         <li>Type: {@link View}
- *       </ul>
- *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
- *       <ul>
- *         <li>Type: {@link TextView}
- *       </ul>
- *   <li><b>{@code exo_duration}</b> - Text view displaying the current media duration.
- *       <ul>
- *         <li>Type: {@link TextView}
- *       </ul>
- *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
- *       <ul>
- *         <li>Type: {@link TimeBar}
- *       </ul>
- * </ul>
- *
- * <p>All child views are optional and so can be omitted if not required, however where defined they
- * must be of the expected type.
- *
- * <h3>Specifying a custom layout file</h3>
- *
- * Defining your own {@code exo_player_control_view.xml} is useful to customize the layout of
- * PlayerControlView throughout your application. It's also possible to customize the layout for a
- * single instance in a layout file. This is achieved by setting the {@code controller_layout_id}
- * attribute on a PlayerControlView. This will cause the specified layout to be inflated instead of
- * {@code exo_player_control_view.xml} for only the instance on which the attribute is set.
- */
-public class PlayerControlView extends FrameLayout {
-
-  static {
-    ExoPlayerLibraryInfo.registerModule("goog.exo.ui");
-  }
-
-  /** Listener to be notified about changes of the visibility of the UI control. */
-  public interface VisibilityListener {
-
-    /**
-     * Called when the visibility changes.
-     *
-     * @param visibility The new visibility. Either {@link View#VISIBLE} or {@link View#GONE}.
-     */
-    void onVisibilityChange(int visibility);
-  }
-
-  /** The default fast forward increment, in milliseconds. */
-  public static final int DEFAULT_FAST_FORWARD_MS = 15000;
-  /** The default rewind increment, in milliseconds. */
-  public static final int DEFAULT_REWIND_MS = 5000;
-  /** The default show timeout, in milliseconds. */
-  public static final int DEFAULT_SHOW_TIMEOUT_MS = 5000;
-  /** The default repeat toggle modes. */
-  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE;
-
-  /** The maximum number of windows that can be shown in a multi-window time bar. */
-  public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR = 100;
-
-  private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
-
-  private final ComponentListener componentListener;
-  private final View previousButton;
-  private final View nextButton;
-  private final View playButton;
-  private final View pauseButton;
-  private final View fastForwardButton;
-  private final View rewindButton;
-  private final ImageView repeatToggleButton;
-  private final View shuffleButton;
-  private final TextView durationView;
-  private final TextView positionView;
-  private final TimeBar timeBar;
-  private final StringBuilder formatBuilder;
-  private final Formatter formatter;
-  private final Timeline.Period period;
-  private final Timeline.Window window;
-  private final Runnable updateProgressAction;
-  private final Runnable hideAction;
-
-  private final Drawable repeatOffButtonDrawable;
-  private final Drawable repeatOneButtonDrawable;
-  private final Drawable repeatAllButtonDrawable;
-  private final String repeatOffButtonContentDescription;
-  private final String repeatOneButtonContentDescription;
-  private final String repeatAllButtonContentDescription;
-
-  private Player player;
-  private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
-  private VisibilityListener visibilityListener;
-  private @Nullable PlaybackPreparer playbackPreparer;
-
-  private boolean isAttachedToWindow;
-  private boolean showMultiWindowTimeBar;
-  private boolean multiWindowTimeBar;
-  private boolean scrubbing;
-  private int rewindMs;
-  private int fastForwardMs;
-  private int showTimeoutMs;
-  private @RepeatModeUtil.RepeatToggleModes int repeatToggleModes;
-  private boolean showShuffleButton;
-  private long hideAtMs;
-  private long[] adGroupTimesMs;
-  private boolean[] playedAdGroups;
-  private long[] extraAdGroupTimesMs;
-  private boolean[] extraPlayedAdGroups;
-
-  public PlayerControlView(Context context) {
-    this(context, null);
-  }
-
-  public PlayerControlView(Context context, AttributeSet attrs) {
-    this(context, attrs, 0);
-  }
-
-  public PlayerControlView(Context context, AttributeSet attrs, int defStyleAttr) {
-    this(context, attrs, defStyleAttr, attrs);
-  }
-
-  public PlayerControlView(
-      Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
-    super(context, attrs, defStyleAttr);
-    int controllerLayoutId = R.layout.exo_player_control_view;
-    rewindMs = DEFAULT_REWIND_MS;
-    fastForwardMs = DEFAULT_FAST_FORWARD_MS;
-    showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
-    repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES;
-    hideAtMs = C.TIME_UNSET;
-    showShuffleButton = false;
-    if (playbackAttrs != null) {
-      TypedArray a =
-          context
-              .getTheme()
-              .obtainStyledAttributes(playbackAttrs, R.styleable.PlayerControlView, 0, 0);
-      try {
-        rewindMs = a.getInt(R.styleable.PlayerControlView_rewind_increment, rewindMs);
-        fastForwardMs =
-            a.getInt(R.styleable.PlayerControlView_fastforward_increment, fastForwardMs);
-        showTimeoutMs = a.getInt(R.styleable.PlayerControlView_show_timeout, showTimeoutMs);
-        controllerLayoutId =
-            a.getResourceId(R.styleable.PlayerControlView_controller_layout_id, controllerLayoutId);
-        repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes);
-        showShuffleButton =
-            a.getBoolean(R.styleable.PlayerControlView_show_shuffle_button, showShuffleButton);
-      } finally {
-        a.recycle();
-      }
-    }
-    period = new Timeline.Period();
-    window = new Timeline.Window();
-    formatBuilder = new StringBuilder();
-    formatter = new Formatter(formatBuilder, Locale.getDefault());
-    adGroupTimesMs = new long[0];
-    playedAdGroups = new boolean[0];
-    extraAdGroupTimesMs = new long[0];
-    extraPlayedAdGroups = new boolean[0];
-    componentListener = new ComponentListener();
-    controlDispatcher = new com.google.android.exoplayer2.DefaultControlDispatcher();
-    updateProgressAction = this::updateProgress;
-    hideAction = this::hide;
-
-    LayoutInflater.from(context).inflate(controllerLayoutId, this);
-    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-
-    durationView = findViewById(R.id.exo_duration);
-    positionView = findViewById(R.id.exo_position);
-    timeBar = findViewById(R.id.exo_progress);
-    if (timeBar != null) {
-      timeBar.addListener(componentListener);
-    }
-    playButton = findViewById(R.id.exo_play);
-    if (playButton != null) {
-      playButton.setOnClickListener(componentListener);
-    }
-    pauseButton = findViewById(R.id.exo_pause);
-    if (pauseButton != null) {
-      pauseButton.setOnClickListener(componentListener);
-    }
-    previousButton = findViewById(R.id.exo_prev);
-    if (previousButton != null) {
-      previousButton.setOnClickListener(componentListener);
-    }
-    nextButton = findViewById(R.id.exo_next);
-    if (nextButton != null) {
-      nextButton.setOnClickListener(componentListener);
-    }
-    rewindButton = findViewById(R.id.exo_rew);
-    if (rewindButton != null) {
-      rewindButton.setOnClickListener(componentListener);
-    }
-    fastForwardButton = findViewById(R.id.exo_ffwd);
-    if (fastForwardButton != null) {
-      fastForwardButton.setOnClickListener(componentListener);
-    }
-    repeatToggleButton = findViewById(R.id.exo_repeat_toggle);
-    if (repeatToggleButton != null) {
-      repeatToggleButton.setOnClickListener(componentListener);
-    }
-    shuffleButton = findViewById(R.id.exo_shuffle);
-    if (shuffleButton != null) {
-      shuffleButton.setOnClickListener(componentListener);
-    }
-    Resources resources = context.getResources();
-    repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
-    repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
-    repeatAllButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_all);
-    repeatOffButtonContentDescription =
-        resources.getString(R.string.exo_controls_repeat_off_description);
-    repeatOneButtonContentDescription =
-        resources.getString(R.string.exo_controls_repeat_one_description);
-    repeatAllButtonContentDescription =
-        resources.getString(R.string.exo_controls_repeat_all_description);
-  }
-
-  @SuppressWarnings("ResourceType")
-  private static @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes(
-      TypedArray a, @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    return a.getInt(R.styleable.PlayerControlView_repeat_toggle_modes, repeatToggleModes);
-  }
-
-  /**
-   * Returns the {@link Player} currently being controlled by this view, or null if no player is
-   * set.
-   */
-  public Player getPlayer() {
-    return player;
-  }
-
-  /**
-   * Sets the {@link Player} to control.
-   *
-   * @param player The {@link Player} to control, or {@code null} to detach the current player. Only
-   *     players which are accessed on the main thread are supported ({@code
-   *     player.getApplicationLooper() == Looper.getMainLooper()}).
-   */
-  public void setPlayer(@Nullable Player player) {
-    Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());
-    Assertions.checkArgument(
-        player == null || player.getApplicationLooper() == Looper.getMainLooper());
-    if (this.player == player) {
-      return;
-    }
-    if (this.player != null) {
-      this.player.removeListener(componentListener);
-    }
-    this.player = player;
-    if (player != null) {
-      player.addListener(componentListener);
-    }
-    updateAll();
-  }
-
-  /**
-   * Sets whether the time bar should show all windows, as opposed to just the current one. If the
-   * timeline has a period with unknown duration or more than {@link
-   * #MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR} windows the time bar will fall back to showing a single
-   * window.
-   *
-   * @param showMultiWindowTimeBar Whether the time bar should show all windows.
-   */
-  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
-    this.showMultiWindowTimeBar = showMultiWindowTimeBar;
-    updateTimeBarMode();
-  }
-
-  /**
-   * Sets the millisecond positions of extra ad markers relative to the start of the window (or
-   * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
-   * markers are shown in addition to any ad markers for ads in the player's timeline.
-   *
-   * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
-   *     {@code null} to show no extra ad markers.
-   * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
-   *     markers.
-   */
-  public void setExtraAdGroupMarkers(
-      @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {
-    if (extraAdGroupTimesMs == null) {
-      this.extraAdGroupTimesMs = new long[0];
-      this.extraPlayedAdGroups = new boolean[0];
-    } else {
-      Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);
-      this.extraAdGroupTimesMs = extraAdGroupTimesMs;
-      this.extraPlayedAdGroups = extraPlayedAdGroups;
-    }
-    updateProgress();
-  }
-
-  /**
-   * Sets the {@link VisibilityListener}.
-   *
-   * @param listener The listener to be notified about visibility changes.
-   */
-  public void setVisibilityListener(VisibilityListener listener) {
-    this.visibilityListener = listener;
-  }
-
-  /**
-   * Sets the {@link PlaybackPreparer}.
-   *
-   * @param playbackPreparer The {@link PlaybackPreparer}.
-   */
-  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
-    this.playbackPreparer = playbackPreparer;
-  }
-
-  /**
-   * Sets the {@link com.google.android.exoplayer2.ControlDispatcher}.
-   *
-   * @param controlDispatcher The {@link com.google.android.exoplayer2.ControlDispatcher}, or null
-   *     to use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
-   */
-  public void setControlDispatcher(
-      @Nullable com.google.android.exoplayer2.ControlDispatcher controlDispatcher) {
-    this.controlDispatcher =
-        controlDispatcher == null
-            ? new com.google.android.exoplayer2.DefaultControlDispatcher()
-            : controlDispatcher;
-  }
-
-  /**
-   * Sets the rewind increment in milliseconds.
-   *
-   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
-   *     rewind button to be disabled.
-   */
-  public void setRewindIncrementMs(int rewindMs) {
-    this.rewindMs = rewindMs;
-    updateNavigation();
-  }
-
-  /**
-   * Sets the fast forward increment in milliseconds.
-   *
-   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
-   *     cause the fast forward button to be disabled.
-   */
-  public void setFastForwardIncrementMs(int fastForwardMs) {
-    this.fastForwardMs = fastForwardMs;
-    updateNavigation();
-  }
-
-  /**
-   * Returns the playback controls timeout. The playback controls are automatically hidden after
-   * this duration of time has elapsed without user input.
-   *
-   * @return The duration in milliseconds. A non-positive value indicates that the controls will
-   *     remain visible indefinitely.
-   */
-  public int getShowTimeoutMs() {
-    return showTimeoutMs;
-  }
-
-  /**
-   * Sets the playback controls timeout. The playback controls are automatically hidden after this
-   * duration of time has elapsed without user input.
-   *
-   * @param showTimeoutMs The duration in milliseconds. A non-positive value will cause the controls
-   *     to remain visible indefinitely.
-   */
-  public void setShowTimeoutMs(int showTimeoutMs) {
-    this.showTimeoutMs = showTimeoutMs;
-    if (isVisible()) {
-      // Reset the timeout.
-      hideAfterTimeout();
-    }
-  }
-
-  /**
-   * Returns which repeat toggle modes are enabled.
-   *
-   * @return The currently enabled {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes() {
-    return repeatToggleModes;
-  }
-
-  /**
-   * Sets which repeat toggle modes are enabled.
-   *
-   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    this.repeatToggleModes = repeatToggleModes;
-    if (player != null) {
-      @Player.RepeatMode int currentMode = player.getRepeatMode();
-      if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE
-          && currentMode != Player.REPEAT_MODE_OFF) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_OFF);
-      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE
-          && currentMode == Player.REPEAT_MODE_ALL) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ONE);
-      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL
-          && currentMode == Player.REPEAT_MODE_ONE) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ALL);
-      }
-    }
-    updateRepeatModeButton();
-  }
-
-  /** Returns whether the shuffle button is shown. */
-  public boolean getShowShuffleButton() {
-    return showShuffleButton;
-  }
-
-  /**
-   * Sets whether the shuffle button is shown.
-   *
-   * @param showShuffleButton Whether the shuffle button is shown.
-   */
-  public void setShowShuffleButton(boolean showShuffleButton) {
-    this.showShuffleButton = showShuffleButton;
-    updateShuffleButton();
-  }
-
-  /**
-   * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
-   * be automatically hidden after this duration of time has elapsed without user input.
-   */
-  public void show() {
-    if (!isVisible()) {
-      setVisibility(VISIBLE);
-      if (visibilityListener != null) {
-        visibilityListener.onVisibilityChange(getVisibility());
-      }
-      updateAll();
-      requestPlayPauseFocus();
-    }
-    // Call hideAfterTimeout even if already visible to reset the timeout.
-    hideAfterTimeout();
-  }
-
-  /** Hides the controller. */
-  public void hide() {
-    if (isVisible()) {
-      setVisibility(GONE);
-      if (visibilityListener != null) {
-        visibilityListener.onVisibilityChange(getVisibility());
-      }
-      removeCallbacks(updateProgressAction);
-      removeCallbacks(hideAction);
-      hideAtMs = C.TIME_UNSET;
-    }
-  }
-
-  /** Returns whether the controller is currently visible. */
-  public boolean isVisible() {
-    return getVisibility() == VISIBLE;
-  }
-
-  private void hideAfterTimeout() {
-    removeCallbacks(hideAction);
-    if (showTimeoutMs > 0) {
-      hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs;
-      if (isAttachedToWindow) {
-        postDelayed(hideAction, showTimeoutMs);
-      }
-    } else {
-      hideAtMs = C.TIME_UNSET;
-    }
-  }
-
-  private void updateAll() {
-    updatePlayPauseButton();
-    updateNavigation();
-    updateRepeatModeButton();
-    updateShuffleButton();
-    updateProgress();
-  }
-
-  private void updatePlayPauseButton() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-    boolean requestPlayPauseFocus = false;
-    boolean playing = isPlaying();
-    if (playButton != null) {
-      requestPlayPauseFocus |= playing && playButton.isFocused();
-      playButton.setVisibility(playing ? View.GONE : View.VISIBLE);
-    }
-    if (pauseButton != null) {
-      requestPlayPauseFocus |= !playing && pauseButton.isFocused();
-      pauseButton.setVisibility(!playing ? View.GONE : View.VISIBLE);
-    }
-    if (requestPlayPauseFocus) {
-      requestPlayPauseFocus();
-    }
-  }
-
-  private void updateNavigation() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-    Timeline timeline = player != null ? player.getCurrentTimeline() : null;
-    boolean haveNonEmptyTimeline = timeline != null && !timeline.isEmpty();
-    boolean isSeekable = false;
-    boolean enablePrevious = false;
-    boolean enableNext = false;
-    if (haveNonEmptyTimeline && !player.isPlayingAd()) {
-      int windowIndex = player.getCurrentWindowIndex();
-      timeline.getWindow(windowIndex, window);
-      isSeekable = window.isSeekable;
-      enablePrevious = isSeekable || !window.isDynamic || player.hasPrevious();
-      enableNext = window.isDynamic || player.hasNext();
-    }
-    setButtonEnabled(enablePrevious, previousButton);
-    setButtonEnabled(enableNext, nextButton);
-    setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
-    setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
-    if (timeBar != null) {
-      timeBar.setEnabled(isSeekable);
-    }
-  }
-
-  private void updateRepeatModeButton() {
-    if (!isVisible() || !isAttachedToWindow || repeatToggleButton == null) {
-      return;
-    }
-    if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE) {
-      repeatToggleButton.setVisibility(View.GONE);
-      return;
-    }
-    if (player == null) {
-      setButtonEnabled(false, repeatToggleButton);
-      return;
-    }
-    setButtonEnabled(true, repeatToggleButton);
-    switch (player.getRepeatMode()) {
-      case Player.REPEAT_MODE_OFF:
-        repeatToggleButton.setImageDrawable(repeatOffButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatOffButtonContentDescription);
-        break;
-      case Player.REPEAT_MODE_ONE:
-        repeatToggleButton.setImageDrawable(repeatOneButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatOneButtonContentDescription);
-        break;
-      case Player.REPEAT_MODE_ALL:
-        repeatToggleButton.setImageDrawable(repeatAllButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatAllButtonContentDescription);
-        break;
-      default:
-        // Never happens.
-    }
-    repeatToggleButton.setVisibility(View.VISIBLE);
-  }
-
-  private void updateShuffleButton() {
-    if (!isVisible() || !isAttachedToWindow || shuffleButton == null) {
-      return;
-    }
-    if (!showShuffleButton) {
-      shuffleButton.setVisibility(View.GONE);
-    } else if (player == null) {
-      setButtonEnabled(false, shuffleButton);
-    } else {
-      shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
-      shuffleButton.setEnabled(true);
-      shuffleButton.setVisibility(View.VISIBLE);
-    }
-  }
-
-  private void updateTimeBarMode() {
-    if (player == null) {
-      return;
-    }
-    multiWindowTimeBar =
-        showMultiWindowTimeBar && canShowMultiWindowTimeBar(player.getCurrentTimeline(), window);
-  }
-
-  private void updateProgress() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-
-    long position = 0;
-    long bufferedPosition = 0;
-    long duration = 0;
-    if (player != null) {
-      long currentWindowTimeBarOffsetMs = 0;
-      long durationUs = 0;
-      int adGroupCount = 0;
-      Timeline timeline = player.getCurrentTimeline();
-      if (!timeline.isEmpty()) {
-        int currentWindowIndex = player.getCurrentWindowIndex();
-        int firstWindowIndex = multiWindowTimeBar ? 0 : currentWindowIndex;
-        int lastWindowIndex =
-            multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
-        for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
-          if (i == currentWindowIndex) {
-            currentWindowTimeBarOffsetMs = C.usToMs(durationUs);
-          }
-          timeline.getWindow(i, window);
-          if (window.durationUs == C.TIME_UNSET) {
-            Assertions.checkState(!multiWindowTimeBar);
-            break;
-          }
-          for (int j = window.firstPeriodIndex; j <= window.lastPeriodIndex; j++) {
-            timeline.getPeriod(j, period);
-            int periodAdGroupCount = period.getAdGroupCount();
-            for (int adGroupIndex = 0; adGroupIndex < periodAdGroupCount; adGroupIndex++) {
-              long adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex);
-              if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
-                if (period.durationUs == C.TIME_UNSET) {
-                  // Don't show ad markers for postrolls in periods with unknown duration.
-                  continue;
-                }
-                adGroupTimeInPeriodUs = period.durationUs;
-              }
-              long adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.getPositionInWindowUs();
-              if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
-                if (adGroupCount == adGroupTimesMs.length) {
-                  int newLength = adGroupTimesMs.length == 0 ? 1 : adGroupTimesMs.length * 2;
-                  adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, newLength);
-                  playedAdGroups = Arrays.copyOf(playedAdGroups, newLength);
-                }
-                adGroupTimesMs[adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs);
-                playedAdGroups[adGroupCount] = period.hasPlayedAdGroup(adGroupIndex);
-                adGroupCount++;
-              }
-            }
-          }
-          durationUs += window.durationUs;
-        }
-      }
-      duration = C.usToMs(durationUs);
-      position = currentWindowTimeBarOffsetMs + player.getContentPosition();
-      bufferedPosition = currentWindowTimeBarOffsetMs + player.getContentBufferedPosition();
-      if (timeBar != null) {
-        int extraAdGroupCount = extraAdGroupTimesMs.length;
-        int totalAdGroupCount = adGroupCount + extraAdGroupCount;
-        if (totalAdGroupCount > adGroupTimesMs.length) {
-          adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, totalAdGroupCount);
-          playedAdGroups = Arrays.copyOf(playedAdGroups, totalAdGroupCount);
-        }
-        System.arraycopy(extraAdGroupTimesMs, 0, adGroupTimesMs, adGroupCount, extraAdGroupCount);
-        System.arraycopy(extraPlayedAdGroups, 0, playedAdGroups, adGroupCount, extraAdGroupCount);
-        timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount);
-      }
-    }
-    if (durationView != null) {
-      durationView.setText(Util.getStringForTime(formatBuilder, formatter, duration));
-    }
-    if (positionView != null && !scrubbing) {
-      positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
-    }
-    if (timeBar != null) {
-      timeBar.setPosition(position);
-      timeBar.setBufferedPosition(bufferedPosition);
-      timeBar.setDuration(duration);
-    }
-
-    // Cancel any pending updates and schedule a new one if necessary.
-    removeCallbacks(updateProgressAction);
-    int playbackState = player == null ? Player.STATE_IDLE : player.getPlaybackState();
-    if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
-      long delayMs;
-      if (player.getPlayWhenReady() && playbackState == Player.STATE_READY) {
-        float playbackSpeed = player.getPlaybackParameters().speed;
-        if (playbackSpeed <= 0.1f) {
-          delayMs = 1000;
-        } else if (playbackSpeed <= 5f) {
-          long mediaTimeUpdatePeriodMs = 1000 / Math.max(1, Math.round(1 / playbackSpeed));
-          long mediaTimeDelayMs = mediaTimeUpdatePeriodMs - (position % mediaTimeUpdatePeriodMs);
-          if (mediaTimeDelayMs < (mediaTimeUpdatePeriodMs / 5)) {
-            mediaTimeDelayMs += mediaTimeUpdatePeriodMs;
-          }
-          delayMs =
-              playbackSpeed == 1 ? mediaTimeDelayMs : (long) (mediaTimeDelayMs / playbackSpeed);
-        } else {
-          delayMs = 200;
-        }
-      } else {
-        delayMs = 1000;
-      }
-      postDelayed(updateProgressAction, delayMs);
-    }
-  }
-
-  private void requestPlayPauseFocus() {
-    boolean playing = isPlaying();
-    if (!playing && playButton != null) {
-      playButton.requestFocus();
-    } else if (playing && pauseButton != null) {
-      pauseButton.requestFocus();
-    }
-  }
-
-  private void setButtonEnabled(boolean enabled, View view) {
-    if (view == null) {
-      return;
-    }
-    view.setEnabled(enabled);
-    view.setAlpha(enabled ? 1f : 0.3f);
-    view.setVisibility(VISIBLE);
-  }
-
-  private void previous() {
-    Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty() || player.isPlayingAd()) {
-      return;
-    }
-    int windowIndex = player.getCurrentWindowIndex();
-    timeline.getWindow(windowIndex, window);
-    int previousWindowIndex = player.getPreviousWindowIndex();
-    if (previousWindowIndex != C.INDEX_UNSET
-        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
-            || (window.isDynamic && !window.isSeekable))) {
-      seekTo(previousWindowIndex, C.TIME_UNSET);
-    } else {
-      seekTo(0);
-    }
-  }
-
-  private void next() {
-    Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty() || player.isPlayingAd()) {
-      return;
-    }
-    int windowIndex = player.getCurrentWindowIndex();
-    int nextWindowIndex = player.getNextWindowIndex();
-    if (nextWindowIndex != C.INDEX_UNSET) {
-      seekTo(nextWindowIndex, C.TIME_UNSET);
-    } else if (timeline.getWindow(windowIndex, window).isDynamic) {
-      seekTo(windowIndex, C.TIME_UNSET);
-    }
-  }
-
-  private void rewind() {
-    if (rewindMs <= 0) {
-      return;
-    }
-    seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
-  }
-
-  private void fastForward() {
-    if (fastForwardMs <= 0) {
-      return;
-    }
-    long durationMs = player.getDuration();
-    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
-    if (durationMs != C.TIME_UNSET) {
-      seekPositionMs = Math.min(seekPositionMs, durationMs);
-    }
-    seekTo(seekPositionMs);
-  }
-
-  private void seekTo(long positionMs) {
-    seekTo(player.getCurrentWindowIndex(), positionMs);
-  }
-
-  private void seekTo(int windowIndex, long positionMs) {
-    boolean dispatched = controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
-    if (!dispatched) {
-      // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
-      // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
-      updateProgress();
-    }
-  }
-
-  private void seekToTimeBarPosition(long positionMs) {
-    int windowIndex;
-    Timeline timeline = player.getCurrentTimeline();
-    if (multiWindowTimeBar && !timeline.isEmpty()) {
-      int windowCount = timeline.getWindowCount();
-      windowIndex = 0;
-      while (true) {
-        long windowDurationMs = timeline.getWindow(windowIndex, window).getDurationMs();
-        if (positionMs < windowDurationMs) {
-          break;
-        } else if (windowIndex == windowCount - 1) {
-          // Seeking past the end of the last window should seek to the end of the timeline.
-          positionMs = windowDurationMs;
-          break;
-        }
-        positionMs -= windowDurationMs;
-        windowIndex++;
-      }
-    } else {
-      windowIndex = player.getCurrentWindowIndex();
-    }
-    seekTo(windowIndex, positionMs);
-  }
-
-  @Override
-  public void onAttachedToWindow() {
-    super.onAttachedToWindow();
-    isAttachedToWindow = true;
-    if (hideAtMs != C.TIME_UNSET) {
-      long delayMs = hideAtMs - SystemClock.uptimeMillis();
-      if (delayMs <= 0) {
-        hide();
-      } else {
-        postDelayed(hideAction, delayMs);
-      }
-    } else if (isVisible()) {
-      hideAfterTimeout();
-    }
-    updateAll();
-  }
-
-  @Override
-  public void onDetachedFromWindow() {
-    super.onDetachedFromWindow();
-    isAttachedToWindow = false;
-    removeCallbacks(updateProgressAction);
-    removeCallbacks(hideAction);
-  }
-
-  @Override
-  public final boolean dispatchTouchEvent(MotionEvent ev) {
-    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
-      removeCallbacks(hideAction);
-    } else if (ev.getAction() == MotionEvent.ACTION_UP) {
-      hideAfterTimeout();
-    }
-    return super.dispatchTouchEvent(ev);
-  }
-
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-  }
-
-  /**
-   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
-   * events will be handled.
-   *
-   * @param event A key event.
-   * @return Whether the key event was handled.
-   */
-  public boolean dispatchMediaKeyEvent(KeyEvent event) {
-    int keyCode = event.getKeyCode();
-    if (player == null || !isHandledMediaKey(keyCode)) {
-      return false;
-    }
-    if (event.getAction() == KeyEvent.ACTION_DOWN) {
-      if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
-        fastForward();
-      } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
-        rewind();
-      } else if (event.getRepeatCount() == 0) {
-        switch (keyCode) {
-          case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            controlDispatcher.dispatchSetPlayWhenReady(player, !player.getPlayWhenReady());
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PLAY:
-            controlDispatcher.dispatchSetPlayWhenReady(player, true);
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            controlDispatcher.dispatchSetPlayWhenReady(player, false);
-            break;
-          case KeyEvent.KEYCODE_MEDIA_NEXT:
-            next();
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            previous();
-            break;
-          default:
-            break;
-        }
-      }
-    }
-    return true;
-  }
-
-  private boolean isPlaying() {
-    return player != null
-        && player.getPlaybackState() != Player.STATE_ENDED
-        && player.getPlaybackState() != Player.STATE_IDLE
-        && player.getPlayWhenReady();
-  }
-
-  @SuppressLint("InlinedApi")
-  private static boolean isHandledMediaKey(int keyCode) {
-    return keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
-        || keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE
-        || keyCode == KeyEvent.KEYCODE_MEDIA_NEXT
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS;
-  }
-
-  /**
-   * Returns whether the specified {@code timeline} can be shown on a multi-window time bar.
-   *
-   * @param timeline The {@link Timeline} to check.
-   * @param window A scratch {@link Timeline.Window} instance.
-   * @return Whether the specified timeline can be shown on a multi-window time bar.
-   */
-  private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Window window) {
-    if (timeline.getWindowCount() > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {
-      return false;
-    }
-    int windowCount = timeline.getWindowCount();
-    for (int i = 0; i < windowCount; i++) {
-      if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private final class ComponentListener
-      implements Player.EventListener, TimeBar.OnScrubListener, OnClickListener {
-
-    @Override
-    public void onScrubStart(TimeBar timeBar, long position) {
-      scrubbing = true;
-    }
-
-    @Override
-    public void onScrubMove(TimeBar timeBar, long position) {
-      if (positionView != null) {
-        positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
-      }
-    }
-
-    @Override
-    public void onScrubStop(TimeBar timeBar, long position, boolean canceled) {
-      scrubbing = false;
-      if (!canceled && player != null) {
-        seekToTimeBarPosition(position);
-      }
-    }
-
-    @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      updatePlayPauseButton();
-      updateProgress();
-    }
-
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      updateRepeatModeButton();
-      updateNavigation();
-    }
-
-    @Override
-    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
-      updateShuffleButton();
-      updateNavigation();
-    }
-
-    @Override
-    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-      updateNavigation();
-      updateProgress();
-    }
-
-    @Override
-    public void onTimelineChanged(
-        Timeline timeline, @Nullable Object manifest, @Player.TimelineChangeReason int reason) {
-      updateNavigation();
-      updateTimeBarMode();
-      updateProgress();
-    }
-
-    @Override
-    public void onClick(View view) {
-      if (player != null) {
-        if (nextButton == view) {
-          next();
-        } else if (previousButton == view) {
-          previous();
-        } else if (fastForwardButton == view) {
-          fastForward();
-        } else if (rewindButton == view) {
-          rewind();
-        } else if (playButton == view) {
-          if (player.getPlaybackState() == Player.STATE_IDLE) {
-            if (playbackPreparer != null) {
-              playbackPreparer.preparePlayback();
-            }
-          } else if (player.getPlaybackState() == Player.STATE_ENDED) {
-            controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
-          }
-          controlDispatcher.dispatchSetPlayWhenReady(player, true);
-        } else if (pauseButton == view) {
-          controlDispatcher.dispatchSetPlayWhenReady(player, false);
-        } else if (repeatToggleButton == view) {
-          controlDispatcher.dispatchSetRepeatMode(
-              player, RepeatModeUtil.getNextRepeatMode(player.getRepeatMode(), repeatToggleModes));
-        } else if (shuffleButton == view) {
-          controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
-        }
-      }
-    }
-  }
-}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt
new file mode 100644
index 0000000000..139f9bcf87
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.kt
@@ -0,0 +1,1041 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.res.TypedArray
+import android.graphics.drawable.Drawable
+import android.os.Looper
+import android.os.SystemClock
+import android.util.AttributeSet
+import android.view.*
+import android.widget.FrameLayout
+import android.widget.ImageView
+import android.widget.TextView
+import com.google.android.exoplayer2.*
+import com.google.android.exoplayer2.util.Assertions
+import com.google.android.exoplayer2.util.RepeatModeUtil
+import com.google.android.exoplayer2.util.Util
+import java.util.*
+
+/**
+ * A view for controlling [Player] instances.
+ *
+ *
+ * A PlayerControlView can be customized by setting attributes (or calling corresponding
+ * methods), overriding the view's layout file or by specifying a custom view layout file, as
+ * outlined below.
+ *
+ * <h3>Attributes</h3>
+ *
+ * The following attributes can be set on a PlayerControlView when used in a layout XML file:
+ *
+ *
+ *  * **`show_timeout`** - The time between the last user interaction and the controls
+ * being automatically hidden, in milliseconds. Use zero if the controls should not
+ * automatically timeout.
+ *
+ *  * Corresponding method: [.setShowTimeoutMs]
+ *  * Default: [.DEFAULT_SHOW_TIMEOUT_MS]
+ *
+ *  * **`rewind_increment`** - The duration of the rewind applied when the user taps the
+ * rewind button, in milliseconds. Use zero to disable the rewind button.
+ *
+ *  * Corresponding method: [.setRewindIncrementMs]
+ *  * Default: [.DEFAULT_REWIND_MS]
+ *
+ *  * **`fastforward_increment`** - Like `rewind_increment`, but for fast forward.
+ *
+ *  * Corresponding method: [.setFastForwardIncrementMs]
+ *  * Default: [.DEFAULT_FAST_FORWARD_MS]
+ *
+ *  * **`repeat_toggle_modes`** - A flagged enumeration value specifying which repeat
+ * mode toggle options are enabled. Valid values are: `none`, `one`, `all`,
+ * or `one|all`.
+ *
+ *  * Corresponding method: [.setRepeatToggleModes]
+ *  * Default: [PlayerControlView.DEFAULT_REPEAT_TOGGLE_MODES]
+ *
+ *  * **`show_shuffle_button`** - Whether the shuffle button is shown.
+ *
+ *  * Corresponding method: [.setShowShuffleButton]
+ *  * Default: false
+ *
+ *  * **`controller_layout_id`** - Specifies the id of the layout to be inflated. See
+ * below for more details.
+ *
+ *  * Corresponding method: None
+ *  * Default: `R.layout.exo_player_control_view`
+ *
+ *
+ *
+ * <h3>Overriding the layout file</h3>
+ *
+ * To customize the layout of PlayerControlView throughout your app, or just for certain
+ * configurations, you can define `exo_player_control_view.xml` layout files in your
+ * application `res/layout*` directories. These layouts will override the one provided by the
+ * ExoPlayer library, and will be inflated for use by PlayerControlView. The view identifies and
+ * binds its children by looking for the following ids:
+ *
+ *
+ *
+ *
+ *
+ *  * **`exo_play`** - The play button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_pause`** - The pause button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_ffwd`** - The fast forward button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_rew`** - The rewind button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_prev`** - The previous track button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_next`** - The next track button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_repeat_toggle`** - The repeat toggle button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_shuffle`** - The shuffle button.
+ *
+ *  * Type: [View]
+ *
+ *  * **`exo_position`** - Text view displaying the current playback position.
+ *
+ *  * Type: [TextView]
+ *
+ *  * **`exo_duration`** - Text view displaying the current media duration.
+ *
+ *  * Type: [TextView]
+ *
+ *  * **`exo_progress`** - Time bar that's updated during playback and allows seeking.
+ *
+ *  * Type: [TimeBar]
+ *
+ *
+ *
+ *
+ * All child views are optional and so can be omitted if not required, however where defined they
+ * must be of the expected type.
+ *
+ * <h3>Specifying a custom layout file</h3>
+ *
+ * Defining your own `exo_player_control_view.xml` is useful to customize the layout of
+ * PlayerControlView throughout your application. It's also possible to customize the layout for a
+ * single instance in a layout file. This is achieved by setting the `controller_layout_id`
+ * attribute on a PlayerControlView. This will cause the specified layout to be inflated instead of
+ * `exo_player_control_view.xml` for only the instance on which the attribute is set.
+ */
+open class PlayerControlView(
+        context: Context, attrs: AttributeSet?, defStyleAttr: Int, playbackAttrs: AttributeSet?) : FrameLayout(context, attrs, defStyleAttr) {
+
+    constructor(context: Context) : this(context, null)
+
+    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)
+
+    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : this(context, attrs, defStyleAttr, attrs)
+
+    private val componentListener: ComponentListener
+    private val previousButton: View?
+    private val nextButton: View?
+    private val playButton: View?
+    private val pauseButton: View?
+    private val fastForwardButton: View?
+    private val rewindButton: View?
+    private val repeatToggleButton: ImageView?
+    private val qualityChangeView: ImageView?
+    private val shuffleButton: View?
+    private val durationView: TextView?
+    private val positionView: TextView?
+    private val timeBar: TimeBar?
+    private val formatBuilder: StringBuilder
+    private val formatter: Formatter
+    private val period: Timeline.Period
+    private val window: Timeline.Window
+    private val updateProgressAction: Runnable
+    private val hideAction: Runnable
+
+
+    private val repeatOffButtonDrawable: Drawable
+    private val repeatOneButtonDrawable: Drawable
+    private val repeatAllButtonDrawable: Drawable
+    private val repeatOffButtonContentDescription: String
+    private val repeatOneButtonContentDescription: String
+    private val repeatAllButtonContentDescription: String
+
+    /**
+     * Returns the [Player] currently being controlled by this view, or null if no player is
+     * set.
+     */
+    /**
+     * Sets the [Player] to control.
+     *
+     * @param player The [Player] to control, or `null` to detach the current player. Only
+     * players which are accessed on the main thread are supported (`player.getApplicationLooper() == Looper.getMainLooper()`).
+     */
+    var player: Player? = null
+        set(player) {
+            Assertions.checkState(Looper.myLooper() == Looper.getMainLooper())
+            Assertions.checkArgument(
+                    player == null || player.applicationLooper == Looper.getMainLooper())
+            if (this.player === player) {
+                return
+            }
+            if (this.player != null) {
+                this.player!!.removeListener(componentListener)
+            }
+            field = player
+            player?.addListener(componentListener)
+            updateAll()
+        }
+    private var controlDispatcher: com.google.android.exoplayer2.ControlDispatcher? = null
+    private var visibilityListener: VisibilityListener? = null
+    private var playbackPreparer: PlaybackPreparer? = null
+
+    private var _isAttachedToWindow: Boolean = false
+    private var showMultiWindowTimeBar: Boolean = false
+    private var multiWindowTimeBar: Boolean = false
+    private var scrubbing: Boolean = false
+    private var rewindMs: Int = 0
+    private var fastForwardMs: Int = 0
+    private var showTimeoutMs: Int = 0
+    @RepeatModeUtil.RepeatToggleModes
+    private var repeatToggleModes: Int = 0
+    private var showShuffleButton: Boolean = false
+    private var hideAtMs: Long = 0
+    private var adGroupTimesMs: LongArray? = null
+    private var playedAdGroups: BooleanArray? = null
+    private var extraAdGroupTimesMs: LongArray? = null
+    private var extraPlayedAdGroups: BooleanArray? = null
+
+    /** Returns whether the controller is currently visible.  */
+    val isVisible: Boolean
+        get() = visibility == View.VISIBLE
+
+    private val isPlaying: Boolean
+        get() = (this.player != null
+                && this.player!!.playbackState != Player.STATE_ENDED
+                && this.player!!.playbackState != Player.STATE_IDLE
+                && this.player!!.playWhenReady)
+
+    /** Listener to be notified about changes of the visibility of the UI control.  */
+    interface VisibilityListener {
+
+        /**
+         * Called when the visibility changes.
+         *
+         * @param visibility The new visibility. Either [View.VISIBLE] or [View.GONE].
+         */
+        fun onVisibilityChange(visibility: Int)
+    }
+
+    init {
+        var controllerLayoutId = R.layout.exo_player_control_view
+        rewindMs = DEFAULT_REWIND_MS
+        fastForwardMs = DEFAULT_FAST_FORWARD_MS
+        showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS
+        repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES
+        hideAtMs = C.TIME_UNSET
+        showShuffleButton = false
+        if (playbackAttrs != null) {
+            val a = context
+                    .theme
+                    .obtainStyledAttributes(playbackAttrs, R.styleable.PlayerControlView, 0, 0)
+            try {
+                rewindMs = a.getInt(R.styleable.PlayerControlView_rewind_increment, rewindMs)
+                fastForwardMs = a.getInt(R.styleable.PlayerControlView_fastforward_increment, fastForwardMs)
+                showTimeoutMs = a.getInt(R.styleable.PlayerControlView_show_timeout, showTimeoutMs)
+                controllerLayoutId = a.getResourceId(R.styleable.PlayerControlView_controller_layout_id, controllerLayoutId)
+                repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes)
+                showShuffleButton = a.getBoolean(R.styleable.PlayerControlView_show_shuffle_button, showShuffleButton)
+            } finally {
+                a.recycle()
+            }
+        }
+        period = Timeline.Period()
+        window = Timeline.Window()
+        formatBuilder = StringBuilder()
+        formatter = Formatter(formatBuilder, Locale.getDefault())
+        adGroupTimesMs = LongArray(0)
+        playedAdGroups = BooleanArray(0)
+        extraAdGroupTimesMs = LongArray(0)
+        extraPlayedAdGroups = BooleanArray(0)
+        componentListener = ComponentListener()
+        controlDispatcher = com.google.android.exoplayer2.DefaultControlDispatcher()
+        updateProgressAction = Runnable { this.updateProgress() }
+        hideAction = Runnable { this.hide() }
+
+        LayoutInflater.from(context).inflate(controllerLayoutId, this)
+        descendantFocusability = ViewGroup.FOCUS_AFTER_DESCENDANTS
+
+        durationView = findViewById(R.id.exo_duration)
+        positionView = findViewById(R.id.exo_position)
+        timeBar = findViewById<View>(R.id.exo_progress) as TimeBar?
+        timeBar?.addListener(componentListener)
+        playButton = findViewById(R.id.exo_play)
+        playButton?.setOnClickListener(componentListener)
+        pauseButton = findViewById(R.id.exo_pause)
+        pauseButton?.setOnClickListener(componentListener)
+        previousButton = findViewById(R.id.exo_prev)
+        previousButton?.setOnClickListener(componentListener)
+        nextButton = findViewById(R.id.exo_next)
+        nextButton?.setOnClickListener(componentListener)
+        rewindButton = findViewById(R.id.exo_rew)
+        rewindButton?.setOnClickListener(componentListener)
+        fastForwardButton = findViewById(R.id.exo_ffwd)
+        fastForwardButton?.setOnClickListener(componentListener)
+        repeatToggleButton = findViewById(R.id.exo_repeat_toggle)
+        repeatToggleButton?.setOnClickListener(componentListener)
+        qualityChangeView = findViewById(R.id.exo_quality_change)
+        qualityChangeView?.setOnClickListener(componentListener)
+        shuffleButton = findViewById(R.id.exo_shuffle)
+        shuffleButton?.setOnClickListener(componentListener)
+        val resources = context.resources
+        repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off)
+        repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one)
+        repeatAllButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_all)
+        repeatOffButtonContentDescription = resources.getString(R.string.exo_controls_repeat_off_description)
+        repeatOneButtonContentDescription = resources.getString(R.string.exo_controls_repeat_one_description)
+        repeatAllButtonContentDescription = resources.getString(R.string.exo_controls_repeat_all_description)
+    }
+
+    /**
+     * Sets whether the time bar should show all windows, as opposed to just the current one. If the
+     * timeline has a period with unknown duration or more than [ ][.MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR] windows the time bar will fall back to showing a single
+     * window.
+     *
+     * @param showMultiWindowTimeBar Whether the time bar should show all windows.
+     */
+    fun setShowMultiWindowTimeBar(showMultiWindowTimeBar: Boolean) {
+        this.showMultiWindowTimeBar = showMultiWindowTimeBar
+        updateTimeBarMode()
+    }
+
+    /**
+     * Sets the millisecond positions of extra ad markers relative to the start of the window (or
+     * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
+     * markers are shown in addition to any ad markers for ads in the player's timeline.
+     *
+     * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
+     * `null` to show no extra ad markers.
+     * @param extraPlayedAdGroups Whether each ad has been played, or `null` to show no extra ad
+     * markers.
+     */
+    fun setExtraAdGroupMarkers(
+            extraAdGroupTimesMs: LongArray?, extraPlayedAdGroups: BooleanArray?) {
+        if (extraAdGroupTimesMs == null) {
+            this.extraAdGroupTimesMs = LongArray(0)
+            this.extraPlayedAdGroups = BooleanArray(0)
+        } else {
+            Assertions.checkArgument(extraAdGroupTimesMs.size == extraPlayedAdGroups!!.size)
+            this.extraAdGroupTimesMs = extraAdGroupTimesMs
+            this.extraPlayedAdGroups = extraPlayedAdGroups
+        }
+        updateProgress()
+    }
+
+    /**
+     * Sets the [VisibilityListener].
+     *
+     * @param listener The listener to be notified about visibility changes.
+     */
+    fun setVisibilityListener(listener: VisibilityListener) {
+        this.visibilityListener = listener
+    }
+
+    /**
+     * Sets the [PlaybackPreparer].
+     *
+     * @param playbackPreparer The [PlaybackPreparer].
+     */
+    fun setPlaybackPreparer(playbackPreparer: PlaybackPreparer?) {
+        this.playbackPreparer = playbackPreparer
+    }
+
+    /**
+     * Sets the [com.google.android.exoplayer2.ControlDispatcher].
+     *
+     * @param controlDispatcher The [com.google.android.exoplayer2.ControlDispatcher], or null
+     * to use [com.google.android.exoplayer2.DefaultControlDispatcher].
+     */
+    fun setControlDispatcher(
+            controlDispatcher: com.google.android.exoplayer2.ControlDispatcher?) {
+        this.controlDispatcher = controlDispatcher
+                ?: com.google.android.exoplayer2.DefaultControlDispatcher()
+    }
+
+    /**
+     * Sets the rewind increment in milliseconds.
+     *
+     * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+     * rewind button to be disabled.
+     */
+    fun setRewindIncrementMs(rewindMs: Int) {
+        this.rewindMs = rewindMs
+        updateNavigation()
+    }
+
+    /**
+     * Sets the fast forward increment in milliseconds.
+     *
+     * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+     * cause the fast forward button to be disabled.
+     */
+    fun setFastForwardIncrementMs(fastForwardMs: Int) {
+        this.fastForwardMs = fastForwardMs
+        updateNavigation()
+    }
+
+    /**
+     * Returns the playback controls timeout. The playback controls are automatically hidden after
+     * this duration of time has elapsed without user input.
+     *
+     * @return The duration in milliseconds. A non-positive value indicates that the controls will
+     * remain visible indefinitely.
+     */
+    fun getShowTimeoutMs(): Int {
+        return showTimeoutMs
+    }
+
+    /**
+     * Sets the playback controls timeout. The playback controls are automatically hidden after this
+     * duration of time has elapsed without user input.
+     *
+     * @param showTimeoutMs The duration in milliseconds. A non-positive value will cause the controls
+     * to remain visible indefinitely.
+     */
+    fun setShowTimeoutMs(showTimeoutMs: Int) {
+        this.showTimeoutMs = showTimeoutMs
+        if (isVisible) {
+            // Reset the timeout.
+            hideAfterTimeout()
+        }
+    }
+
+    /**
+     * Returns which repeat toggle modes are enabled.
+     *
+     * @return The currently enabled [RepeatModeUtil.RepeatToggleModes].
+     */
+    @RepeatModeUtil.RepeatToggleModes
+    fun getRepeatToggleModes(): Int {
+        return repeatToggleModes
+    }
+
+    /**
+     * Sets which repeat toggle modes are enabled.
+     *
+     * @param repeatToggleModes A set of [RepeatModeUtil.RepeatToggleModes].
+     */
+    fun setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes repeatToggleModes: Int) {
+        this.repeatToggleModes = repeatToggleModes
+        if (this.player != null) {
+            @Player.RepeatMode val currentMode = this.player!!.repeatMode
+            if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE && currentMode != Player.REPEAT_MODE_OFF) {
+                controlDispatcher!!.dispatchSetRepeatMode(this.player, Player.REPEAT_MODE_OFF)
+            } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE && currentMode == Player.REPEAT_MODE_ALL) {
+                controlDispatcher!!.dispatchSetRepeatMode(this.player, Player.REPEAT_MODE_ONE)
+            } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL && currentMode == Player.REPEAT_MODE_ONE) {
+                controlDispatcher!!.dispatchSetRepeatMode(this.player, Player.REPEAT_MODE_ALL)
+            }
+        }
+        updateRepeatModeButton()
+    }
+
+    /** Returns whether the shuffle button is shown.  */
+    fun getShowShuffleButton(): Boolean {
+        return showShuffleButton
+    }
+
+    /**
+     * Sets whether the shuffle button is shown.
+     *
+     * @param showShuffleButton Whether the shuffle button is shown.
+     */
+    fun setShowShuffleButton(showShuffleButton: Boolean) {
+        this.showShuffleButton = showShuffleButton
+        updateShuffleButton()
+    }
+
+    /**
+     * Shows the playback controls. If [.getShowTimeoutMs] is positive then the controls will
+     * be automatically hidden after this duration of time has elapsed without user input.
+     */
+    fun show() {
+        if (!isVisible) {
+            visibility = View.VISIBLE
+            if (visibilityListener != null) {
+                visibilityListener!!.onVisibilityChange(visibility)
+            }
+            updateAll()
+            requestPlayPauseFocus()
+        }
+        // Call hideAfterTimeout even if already visible to reset the timeout.
+        hideAfterTimeout()
+    }
+
+    /** Hides the controller.  */
+    fun hide() {
+        if (isVisible) {
+            visibility = View.GONE
+            if (visibilityListener != null) {
+                visibilityListener!!.onVisibilityChange(visibility)
+            }
+            removeCallbacks(updateProgressAction)
+            removeCallbacks(hideAction)
+            hideAtMs = C.TIME_UNSET
+        }
+    }
+
+    private fun hideAfterTimeout() {
+        removeCallbacks(hideAction)
+        if (showTimeoutMs > 0) {
+            hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs
+            if (_isAttachedToWindow) {
+                postDelayed(hideAction, showTimeoutMs.toLong())
+            }
+        } else {
+            hideAtMs = C.TIME_UNSET
+        }
+    }
+
+    private fun updateAll() {
+        updatePlayPauseButton()
+        updateNavigation()
+        updateRepeatModeButton()
+        updateShuffleButton()
+        updateProgress()
+    }
+
+    private fun updatePlayPauseButton() {
+        if (!isVisible || !_isAttachedToWindow) {
+            return
+        }
+        var requestPlayPauseFocus = false
+        val playing = isPlaying
+        if (playButton != null) {
+            requestPlayPauseFocus = requestPlayPauseFocus or (playing && playButton.isFocused)
+            playButton.visibility = if (playing) View.GONE else View.VISIBLE
+        }
+        if (pauseButton != null) {
+            requestPlayPauseFocus = requestPlayPauseFocus or (!playing && pauseButton.isFocused)
+            pauseButton.visibility = if (!playing) View.GONE else View.VISIBLE
+        }
+        if (requestPlayPauseFocus) {
+            requestPlayPauseFocus()
+        }
+    }
+
+    private fun updateNavigation() {
+        if (!isVisible || !_isAttachedToWindow) {
+            return
+        }
+        val timeline = if (this.player != null) this.player!!.currentTimeline else null
+        val haveNonEmptyTimeline = timeline != null && !timeline.isEmpty
+        var isSeekable = false
+        var enablePrevious = false
+        var enableNext = false
+        if (haveNonEmptyTimeline && !this.player!!.isPlayingAd) {
+            val windowIndex = this.player!!.currentWindowIndex
+            timeline!!.getWindow(windowIndex, window)
+            isSeekable = window.isSeekable
+            enablePrevious = isSeekable || !window.isDynamic || this.player!!.hasPrevious()
+            enableNext = window.isDynamic || this.player!!.hasNext()
+        }
+        setButtonEnabled(enablePrevious, previousButton)
+        setButtonEnabled(enableNext, nextButton)
+        setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton)
+        setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton)
+        timeBar?.setEnabled(isSeekable)
+    }
+
+    private fun updateRepeatModeButton() {
+        if (!isVisible || !_isAttachedToWindow || repeatToggleButton == null) {
+            return
+        }
+        if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE) {
+            repeatToggleButton.visibility = View.GONE
+            return
+        }
+        if (this.player == null) {
+            setButtonEnabled(false, repeatToggleButton)
+            return
+        }
+        setButtonEnabled(true, repeatToggleButton)
+        when (this.player!!.repeatMode) {
+            Player.REPEAT_MODE_OFF -> {
+                repeatToggleButton.setImageDrawable(repeatOffButtonDrawable)
+                repeatToggleButton.contentDescription = repeatOffButtonContentDescription
+            }
+            Player.REPEAT_MODE_ONE -> {
+                repeatToggleButton.setImageDrawable(repeatOneButtonDrawable)
+                repeatToggleButton.contentDescription = repeatOneButtonContentDescription
+            }
+            Player.REPEAT_MODE_ALL -> {
+                repeatToggleButton.setImageDrawable(repeatAllButtonDrawable)
+                repeatToggleButton.contentDescription = repeatAllButtonContentDescription
+            }
+        }// Never happens.
+        repeatToggleButton.visibility = View.VISIBLE
+    }
+
+    private fun updateShuffleButton() {
+        if (!isVisible || !_isAttachedToWindow || shuffleButton == null) {
+            return
+        }
+        if (!showShuffleButton) {
+            shuffleButton.visibility = View.GONE
+        } else if (this.player == null) {
+            setButtonEnabled(false, shuffleButton)
+        } else {
+            shuffleButton.alpha = if (this.player!!.shuffleModeEnabled) 1f else 0.3f
+            shuffleButton.isEnabled = true
+            shuffleButton.visibility = View.VISIBLE
+        }
+    }
+
+    private fun updateTimeBarMode() {
+        if (this.player == null) {
+            return
+        }
+        multiWindowTimeBar = showMultiWindowTimeBar && canShowMultiWindowTimeBar(this.player!!.currentTimeline, window)
+    }
+
+    private fun updateProgress() {
+        if (!isVisible || !_isAttachedToWindow) {
+            return
+        }
+
+        var position: Long = 0
+        var bufferedPosition: Long = 0
+        var duration: Long = 0
+        if (this.player != null) {
+            var currentWindowTimeBarOffsetMs: Long = 0
+            var durationUs: Long = 0
+            var adGroupCount = 0
+            val timeline = this.player!!.currentTimeline
+            if (!timeline.isEmpty) {
+                val currentWindowIndex = this.player!!.currentWindowIndex
+                val firstWindowIndex = if (multiWindowTimeBar) 0 else currentWindowIndex
+                val lastWindowIndex = if (multiWindowTimeBar) timeline.windowCount - 1 else currentWindowIndex
+                for (i in firstWindowIndex..lastWindowIndex) {
+                    if (i == currentWindowIndex) {
+                        currentWindowTimeBarOffsetMs = C.usToMs(durationUs)
+                    }
+                    timeline.getWindow(i, window)
+                    if (window.durationUs == C.TIME_UNSET) {
+                        Assertions.checkState(!multiWindowTimeBar)
+                        break
+                    }
+                    for (j in window.firstPeriodIndex..window.lastPeriodIndex) {
+                        timeline.getPeriod(j, period)
+                        val periodAdGroupCount = period.adGroupCount
+                        for (adGroupIndex in 0 until periodAdGroupCount) {
+                            var adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex)
+                            if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
+                                if (period.durationUs == C.TIME_UNSET) {
+                                    // Don't show ad markers for postrolls in periods with unknown duration.
+                                    continue
+                                }
+                                adGroupTimeInPeriodUs = period.durationUs
+                            }
+                            val adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.positionInWindowUs
+                            if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
+                                if (adGroupCount == adGroupTimesMs!!.size) {
+                                    val newLength = if (adGroupTimesMs!!.size == 0) 1 else adGroupTimesMs!!.size * 2
+                                    adGroupTimesMs = Arrays.copyOf(adGroupTimesMs!!, newLength)
+                                    playedAdGroups = Arrays.copyOf(playedAdGroups!!, newLength)
+                                }
+                                adGroupTimesMs!![adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs)
+                                playedAdGroups!![adGroupCount] = period.hasPlayedAdGroup(adGroupIndex)
+                                adGroupCount++
+                            }
+                        }
+                    }
+                    durationUs += window.durationUs
+                }
+            }
+            duration = C.usToMs(durationUs)
+            position = currentWindowTimeBarOffsetMs + this.player!!.contentPosition
+            bufferedPosition = currentWindowTimeBarOffsetMs + this.player!!.contentBufferedPosition
+            if (timeBar != null) {
+                val extraAdGroupCount = extraAdGroupTimesMs!!.size
+                val totalAdGroupCount = adGroupCount + extraAdGroupCount
+                if (totalAdGroupCount > adGroupTimesMs!!.size) {
+                    adGroupTimesMs = Arrays.copyOf(adGroupTimesMs!!, totalAdGroupCount)
+                    playedAdGroups = Arrays.copyOf(playedAdGroups!!, totalAdGroupCount)
+                }
+                System.arraycopy(extraAdGroupTimesMs!!, 0, adGroupTimesMs!!, adGroupCount, extraAdGroupCount)
+                System.arraycopy(extraPlayedAdGroups!!, 0, playedAdGroups!!, adGroupCount, extraAdGroupCount)
+                timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount)
+            }
+        }
+        if (durationView != null) {
+            durationView.text = Util.getStringForTime(formatBuilder, formatter, duration)
+        }
+        if (positionView != null && !scrubbing) {
+            positionView.text = Util.getStringForTime(formatBuilder, formatter, position)
+        }
+        if (timeBar != null) {
+            timeBar.setPosition(position)
+            timeBar.setBufferedPosition(bufferedPosition)
+            timeBar.setDuration(duration)
+        }
+
+        // Cancel any pending updates and schedule a new one if necessary.
+        removeCallbacks(updateProgressAction)
+        val playbackState = if (this.player == null) Player.STATE_IDLE else this.player!!.playbackState
+        if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
+            val delayMs: Long
+            if (this.player!!.playWhenReady && playbackState == Player.STATE_READY) {
+                val playbackSpeed = this.player!!.playbackParameters.speed
+                if (playbackSpeed <= 0.1f) {
+                    delayMs = 1000
+                } else if (playbackSpeed <= 5f) {
+                    val mediaTimeUpdatePeriodMs = (1000 / Math.max(1, Math.round(1 / playbackSpeed))).toLong()
+                    var mediaTimeDelayMs = mediaTimeUpdatePeriodMs - position % mediaTimeUpdatePeriodMs
+                    if (mediaTimeDelayMs < mediaTimeUpdatePeriodMs / 5) {
+                        mediaTimeDelayMs += mediaTimeUpdatePeriodMs
+                    }
+                    delayMs = if (playbackSpeed == 1f) mediaTimeDelayMs else (mediaTimeDelayMs / playbackSpeed).toLong()
+                } else {
+                    delayMs = 200
+                }
+            } else {
+                delayMs = 1000
+            }
+            postDelayed(updateProgressAction, delayMs)
+        }
+    }
+
+    private fun requestPlayPauseFocus() {
+        val playing = isPlaying
+        if (!playing && playButton != null) {
+            playButton.requestFocus()
+        } else if (playing && pauseButton != null) {
+            pauseButton.requestFocus()
+        }
+    }
+
+    private fun setButtonEnabled(enabled: Boolean, view: View?) {
+        if (view == null) {
+            return
+        }
+        view.isEnabled = enabled
+        view.alpha = if (enabled) 1f else 0.3f
+        view.visibility = View.VISIBLE
+    }
+
+    private fun previous() {
+        val timeline = this.player!!.currentTimeline
+        if (timeline.isEmpty || this.player!!.isPlayingAd) {
+            return
+        }
+        val windowIndex = this.player!!.currentWindowIndex
+        timeline.getWindow(windowIndex, window)
+        val previousWindowIndex = this.player!!.previousWindowIndex
+        if (previousWindowIndex != C.INDEX_UNSET && (this.player!!.currentPosition <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS || window.isDynamic && !window.isSeekable)) {
+            seekTo(previousWindowIndex, C.TIME_UNSET)
+        } else {
+            seekTo(0)
+        }
+    }
+
+    private operator fun next() {
+        val timeline = this.player!!.currentTimeline
+        if (timeline.isEmpty || this.player!!.isPlayingAd) {
+            return
+        }
+        val windowIndex = this.player!!.currentWindowIndex
+        val nextWindowIndex = this.player!!.nextWindowIndex
+        if (nextWindowIndex != C.INDEX_UNSET) {
+            seekTo(nextWindowIndex, C.TIME_UNSET)
+        } else if (timeline.getWindow(windowIndex, window).isDynamic) {
+            seekTo(windowIndex, C.TIME_UNSET)
+        }
+    }
+
+    private fun rewind() {
+        if (rewindMs <= 0) {
+            return
+        }
+        seekTo(Math.max(this.player!!.currentPosition - rewindMs, 0))
+    }
+
+    private fun fastForward() {
+        if (fastForwardMs <= 0) {
+            return
+        }
+        val durationMs = this.player!!.duration
+        var seekPositionMs = this.player!!.currentPosition + fastForwardMs
+        if (durationMs != C.TIME_UNSET) {
+            seekPositionMs = Math.min(seekPositionMs, durationMs)
+        }
+        seekTo(seekPositionMs)
+    }
+
+    private fun seekTo(positionMs: Long) {
+        seekTo(this.player!!.currentWindowIndex, positionMs)
+    }
+
+    private fun seekTo(windowIndex: Int, positionMs: Long) {
+        val dispatched = controlDispatcher!!.dispatchSeekTo(this.player, windowIndex, positionMs)
+        if (!dispatched) {
+            // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
+            // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
+            updateProgress()
+        }
+    }
+
+    private fun seekToTimeBarPosition(positionMs: Long) {
+        var positionMs = positionMs
+        var windowIndex: Int
+        val timeline = this.player!!.currentTimeline
+        if (multiWindowTimeBar && !timeline.isEmpty) {
+            val windowCount = timeline.windowCount
+            windowIndex = 0
+            while (true) {
+                val windowDurationMs = timeline.getWindow(windowIndex, window).durationMs
+                if (positionMs < windowDurationMs) {
+                    break
+                } else if (windowIndex == windowCount - 1) {
+                    // Seeking past the end of the last window should seek to the end of the timeline.
+                    positionMs = windowDurationMs
+                    break
+                }
+                positionMs -= windowDurationMs
+                windowIndex++
+            }
+        } else {
+            windowIndex = this.player!!.currentWindowIndex
+        }
+        seekTo(windowIndex, positionMs)
+    }
+
+    public override fun onAttachedToWindow() {
+        super.onAttachedToWindow()
+        _isAttachedToWindow = true
+        if (hideAtMs != C.TIME_UNSET) {
+            val delayMs = hideAtMs - SystemClock.uptimeMillis()
+            if (delayMs <= 0) {
+                hide()
+            } else {
+                postDelayed(hideAction, delayMs)
+            }
+        } else if (isVisible) {
+            hideAfterTimeout()
+        }
+        updateAll()
+    }
+
+    public override fun onDetachedFromWindow() {
+        super.onDetachedFromWindow()
+        _isAttachedToWindow = false
+        removeCallbacks(updateProgressAction)
+        removeCallbacks(hideAction)
+    }
+
+    override fun dispatchTouchEvent(ev: MotionEvent): Boolean {
+        if (ev.action == MotionEvent.ACTION_DOWN) {
+            removeCallbacks(hideAction)
+        } else if (ev.action == MotionEvent.ACTION_UP) {
+            hideAfterTimeout()
+        }
+        return super.dispatchTouchEvent(ev)
+    }
+
+    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
+        return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event)
+    }
+
+    /**
+     * Called to process media key events. Any [KeyEvent] can be passed but only media key
+     * events will be handled.
+     *
+     * @param event A key event.
+     * @return Whether the key event was handled.
+     */
+    fun dispatchMediaKeyEvent(event: KeyEvent): Boolean {
+        val keyCode = event.keyCode
+        if (this.player == null || !isHandledMediaKey(keyCode)) {
+            return false
+        }
+        if (event.action == KeyEvent.ACTION_DOWN) {
+            if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
+                fastForward()
+            } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
+                rewind()
+            } else if (event.repeatCount == 0) {
+                when (keyCode) {
+                    KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE -> controlDispatcher!!.dispatchSetPlayWhenReady(this.player, !this.player!!.playWhenReady)
+                    KeyEvent.KEYCODE_MEDIA_PLAY -> controlDispatcher!!.dispatchSetPlayWhenReady(this.player, true)
+                    KeyEvent.KEYCODE_MEDIA_PAUSE -> controlDispatcher!!.dispatchSetPlayWhenReady(this.player, false)
+                    KeyEvent.KEYCODE_MEDIA_NEXT -> next()
+                    KeyEvent.KEYCODE_MEDIA_PREVIOUS -> previous()
+                    else -> {
+                    }
+                }
+            }
+        }
+        return true
+    }
+
+    private inner class ComponentListener() : Player.EventListener, TimeBar.OnScrubListener, View.OnClickListener {
+
+        override fun onScrubStart(timeBar: TimeBar, position: Long) {
+            scrubbing = true
+        }
+
+        override fun onScrubMove(timeBar: TimeBar, position: Long) {
+            if (positionView != null) {
+                positionView.text = Util.getStringForTime(formatBuilder, formatter, position)
+            }
+        }
+
+        override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
+            scrubbing = false
+            if (!canceled && this@PlayerControlView.player != null) {
+                seekToTimeBarPosition(position)
+            }
+        }
+
+        override fun onPlayerStateChanged(playWhenReady: Boolean, playbackState: Int) {
+            updatePlayPauseButton()
+            updateProgress()
+        }
+
+        override fun onRepeatModeChanged(repeatMode: Int) {
+            updateRepeatModeButton()
+            updateNavigation()
+        }
+
+        override fun onShuffleModeEnabledChanged(shuffleModeEnabled: Boolean) {
+            updateShuffleButton()
+            updateNavigation()
+        }
+
+        override fun onPositionDiscontinuity(@Player.DiscontinuityReason reason: Int) {
+            updateNavigation()
+            updateProgress()
+        }
+
+        override fun onTimelineChanged(
+                timeline: Timeline, manifest: Any?, @Player.TimelineChangeReason reason: Int) {
+            updateNavigation()
+            updateTimeBarMode()
+            updateProgress()
+        }
+
+        override fun onClick(view: View) {
+            if (this@PlayerControlView.player != null) {
+                when {
+                    nextButton === view -> next()
+                    previousButton === view -> previous()
+                    fastForwardButton === view -> fastForward()
+                    rewindButton === view -> rewind()
+                    playButton === view -> {
+                        if (this@PlayerControlView.player!!.getPlaybackState() == Player.STATE_IDLE) {
+                            if (playbackPreparer != null) {
+                                playbackPreparer!!.preparePlayback()
+                            }
+                        } else if (this@PlayerControlView.player!!.getPlaybackState() == Player.STATE_ENDED) {
+                            controlDispatcher!!.dispatchSeekTo(this@PlayerControlView.player, this@PlayerControlView.player!!.getCurrentWindowIndex(), C.TIME_UNSET)
+                        }
+                        controlDispatcher!!.dispatchSetPlayWhenReady(this@PlayerControlView.player, true)
+                    }
+                    pauseButton === view -> controlDispatcher!!.dispatchSetPlayWhenReady(this@PlayerControlView.player, false)
+                    repeatToggleButton === view -> controlDispatcher!!.dispatchSetRepeatMode(
+                            this@PlayerControlView.player, RepeatModeUtil.getNextRepeatMode(this@PlayerControlView.player!!.getRepeatMode(), repeatToggleModes))
+                    shuffleButton === view -> controlDispatcher!!.dispatchSetShuffleModeEnabled(this@PlayerControlView.player, !this@PlayerControlView.player!!.getShuffleModeEnabled())
+                    qualityChangeView === view -> TODO("")
+                }
+            }
+        }
+    }
+
+    companion object {
+
+        init {
+            ExoPlayerLibraryInfo.registerModule("goog.exo.ui")
+        }
+
+        /** The default fast forward increment, in milliseconds.  */
+        val DEFAULT_FAST_FORWARD_MS = 15000
+        /** The default rewind increment, in milliseconds.  */
+        val DEFAULT_REWIND_MS = 5000
+        /** The default show timeout, in milliseconds.  */
+        val DEFAULT_SHOW_TIMEOUT_MS = 5000
+        /** The default repeat toggle modes.  */
+        @RepeatModeUtil.RepeatToggleModes
+        val DEFAULT_REPEAT_TOGGLE_MODES = RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE
+
+        /** The maximum number of windows that can be shown in a multi-window time bar.  */
+        val MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR = 100
+
+        private val MAX_POSITION_FOR_SEEK_TO_PREVIOUS: Long = 3000
+
+        @RepeatModeUtil.RepeatToggleModes
+        private fun getRepeatToggleModes(
+                a: TypedArray, @RepeatModeUtil.RepeatToggleModes repeatToggleModes: Int): Int {
+            return a.getInt(R.styleable.PlayerControlView_repeat_toggle_modes, repeatToggleModes)
+        }
+
+        @SuppressLint("InlinedApi")
+        private fun isHandledMediaKey(keyCode: Int): Boolean {
+            return (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_NEXT
+                    || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS)
+        }
+
+        /**
+         * Returns whether the specified `timeline` can be shown on a multi-window time bar.
+         *
+         * @param timeline The [Timeline] to check.
+         * @param window A scratch [Timeline.Window] instance.
+         * @return Whether the specified timeline can be shown on a multi-window time bar.
+         */
+        private fun canShowMultiWindowTimeBar(timeline: Timeline, window: Timeline.Window): Boolean {
+            if (timeline.windowCount > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {
+                return false
+            }
+            val windowCount = timeline.windowCount
+            for (i in 0 until windowCount) {
+                if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {
+                    return false
+                }
+            }
+            return true
+        }
+    }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 9d66289e94..1c906bd015 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -345,7 +345,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
     boolean useController = true;
     int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
     int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
-    int controllerShowTimeoutMs = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
+    int controllerShowTimeoutMs = PlayerControlView.Companion.getDEFAULT_SHOW_TIMEOUT_MS();
     boolean controllerHideOnTouch = true;
     boolean controllerAutoShow = true;
     boolean controllerHideDuringAds = true;
diff --git a/library/ui/src/main/res/drawable/ic_exo_fullscreen.xml b/library/ui/src/main/res/drawable/ic_exo_fullscreen.xml
new file mode 100644
index 0000000000..512caf4ec3
--- /dev/null
+++ b/library/ui/src/main/res/drawable/ic_exo_fullscreen.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:height="32dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0"
+  android:width="32dp">
+  <path
+    android:fillColor="#FFFFFF"
+    android:pathData="M7,14L5,14v5h5v-2L7,17v-3zM5,10h2L7,7h3L10,5L5,5v5zM17,17h-3v2h5v-5h-2v3zM14,5v2h3v3h2L19,5h-5z"/>
+</vector>
diff --git a/library/ui/src/main/res/drawable/ic_exo_fullscreen_exit.xml b/library/ui/src/main/res/drawable/ic_exo_fullscreen_exit.xml
new file mode 100644
index 0000000000..5377c6d3c0
--- /dev/null
+++ b/library/ui/src/main/res/drawable/ic_exo_fullscreen_exit.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:height="32dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0"
+  android:width="32dp">
+  <path
+    android:fillColor="#FFFFFF"
+    android:pathData="M5,16h3v3h2v-5L5,14v2zM8,8L5,8v2h5L10,5L8,5v3zM14,19h2v-3h3v-2h-5v5zM16,8L16,5h-2v5h5L19,8h-3z"/>
+</vector>
diff --git a/library/ui/src/main/res/drawable/ic_exo_quality_change.xml b/library/ui/src/main/res/drawable/ic_exo_quality_change.xml
new file mode 100644
index 0000000000..39ecac95ff
--- /dev/null
+++ b/library/ui/src/main/res/drawable/ic_exo_quality_change.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+  android:height="24dp"
+  android:viewportHeight="24.0"
+  android:viewportWidth="24.0"
+  android:width="24dp">
+  <path
+    android:fillColor="#FFFFFF"
+    android:pathData="M19.43,12.98c0.04,-0.32 0.07,-0.64 0.07,-0.98s-0.03,-0.66 -0.07,-0.98l2.11,-1.65c0.19,-0.15 0.24,-0.42 0.12,-0.64l-2,-3.46c-0.12,-0.22 -0.39,-0.3 -0.61,-0.22l-2.49,1c-0.52,-0.4 -1.08,-0.73 -1.69,-0.98l-0.38,-2.65C14.46,2.18 14.25,2 14,2h-4c-0.25,0 -0.46,0.18 -0.49,0.42l-0.38,2.65c-0.61,0.25 -1.17,0.59 -1.69,0.98l-2.49,-1c-0.23,-0.09 -0.49,0 -0.61,0.22l-2,3.46c-0.13,0.22 -0.07,0.49 0.12,0.64l2.11,1.65c-0.04,0.32 -0.07,0.65 -0.07,0.98s0.03,0.66 0.07,0.98l-2.11,1.65c-0.19,0.15 -0.24,0.42 -0.12,0.64l2,3.46c0.12,0.22 0.39,0.3 0.61,0.22l2.49,-1c0.52,0.4 1.08,0.73 1.69,0.98l0.38,2.65c0.03,0.24 0.24,0.42 0.49,0.42h4c0.25,0 0.46,-0.18 0.49,-0.42l0.38,-2.65c0.61,-0.25 1.17,-0.59 1.69,-0.98l2.49,1c0.23,0.09 0.49,0 0.61,-0.22l2,-3.46c0.12,-0.22 0.07,-0.49 -0.12,-0.64l-2.11,-1.65zM12,15.5c-1.93,0 -3.5,-1.57 -3.5,-3.5s1.57,-3.5 3.5,-3.5 3.5,1.57 3.5,3.5 -1.57,3.5 -3.5,3.5z"/>
+</vector>
diff --git a/library/ui/src/main/res/layout/exo_playback_control_view.xml b/library/ui/src/main/res/layout/exo_playback_control_view.xml
index 534655f2f4..c5988987bb 100644
--- a/library/ui/src/main/res/layout/exo_playback_control_view.xml
+++ b/library/ui/src/main/res/layout/exo_playback_control_view.xml
@@ -18,40 +18,48 @@
   android:layout_width="match_parent"
   android:layout_height="wrap_content"
   android:layout_gravity="bottom"
-  android:layoutDirection="ltr"
   android:background="#CC000000"
+  android:layoutDirection="ltr"
   android:orientation="vertical"
   tools:targetApi="28">
 
   <LinearLayout
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
-    android:gravity="center"
     android:paddingTop="4dp"
+    android:gravity="center"
     android:orientation="horizontal">
 
-    <ImageButton android:id="@id/exo_prev"
+    <ImageButton
+      android:id="@id/exo_prev"
       style="@style/ExoMediaButton.Previous"/>
 
-    <ImageButton android:id="@id/exo_rew"
+    <ImageButton
+      android:id="@id/exo_rew"
       style="@style/ExoMediaButton.Rewind"/>
 
-    <ImageButton android:id="@id/exo_shuffle"
+    <ImageButton
+      android:id="@id/exo_shuffle"
       style="@style/ExoMediaButton.Shuffle"/>
 
-    <ImageButton android:id="@id/exo_repeat_toggle"
+    <ImageButton
+      android:id="@id/exo_repeat_toggle"
       style="@style/ExoMediaButton"/>
 
-    <ImageButton android:id="@id/exo_play"
+    <ImageButton
+      android:id="@id/exo_play"
       style="@style/ExoMediaButton.Play"/>
 
-    <ImageButton android:id="@id/exo_pause"
+    <ImageButton
+      android:id="@id/exo_pause"
       style="@style/ExoMediaButton.Pause"/>
 
-    <ImageButton android:id="@id/exo_ffwd"
+    <ImageButton
+      android:id="@id/exo_ffwd"
       style="@style/ExoMediaButton.FastForward"/>
 
-    <ImageButton android:id="@id/exo_next"
+    <ImageButton
+      android:id="@id/exo_next"
       style="@style/ExoMediaButton.Next"/>
 
   </LinearLayout>
@@ -63,31 +71,47 @@
     android:gravity="center_vertical"
     android:orientation="horizontal">
 
-    <TextView android:id="@id/exo_position"
+    <TextView
+      android:id="@id/exo_position"
+      android:textStyle="bold"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:textSize="14sp"
-      android:textStyle="bold"
       android:paddingLeft="4dp"
       android:paddingRight="4dp"
       android:includeFontPadding="false"
-      android:textColor="#FFBEBEBE"/>
+      android:textColor="#FFBEBEBE"
+      android:textSize="14sp"
+      tools:text="0:30"/>
 
     <com.google.android.exoplayer2.ui.DefaultTimeBar
       android:id="@id/exo_progress"
       android:layout_width="0dp"
-      android:layout_weight="1"
-      android:layout_height="26dp"/>
+      android:layout_height="26dp"
+      android:layout_weight="1"/>
 
-    <TextView android:id="@id/exo_duration"
+    <TextView
+      android:id="@id/exo_duration"
+      android:textStyle="bold"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:textSize="14sp"
-      android:textStyle="bold"
       android:paddingLeft="4dp"
       android:paddingRight="4dp"
       android:includeFontPadding="false"
-      android:textColor="#FFBEBEBE"/>
+      android:textColor="#FFBEBEBE"
+      android:textSize="14sp"
+      tools:text="1:00"/>
+
+    <ImageView
+      android:id="@+id/exo_quality_change"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:src="@drawable/ic_exo_quality_change"/>
+
+    <ImageView
+      android:id="@+id/exo_fullscreen_btn"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:src="@drawable/ic_exo_fullscreen"/>
 
   </LinearLayout>
 
