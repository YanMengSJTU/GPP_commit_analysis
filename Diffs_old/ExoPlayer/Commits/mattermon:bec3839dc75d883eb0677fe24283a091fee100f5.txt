diff --git a/ISSUE_TEMPLATE b/.github/ISSUE_TEMPLATE/bug.md
similarity index 51%
rename from ISSUE_TEMPLATE
rename to .github/ISSUE_TEMPLATE/bug.md
index 8d2f66093d..f2cc754221 100644
--- a/ISSUE_TEMPLATE
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -1,13 +1,20 @@
-Before filing an issue:
+---
+name: Bug report
+about: Issue template for a bug report.
+title: ''
+labels: bug, needs triage
+assignees: ''
+---
+
+Before filing a bug:
 -----------------------
 - Search existing issues, including issues that are closed.
 - Consult our FAQs, supported devices and supported formats pages. These can be
   found at https://google.github.io/ExoPlayer/.
 - Rule out issues in your own code. A good way to do this is to try and
-  reproduce the issue in the ExoPlayer demo app.
-- This issue tracker is intended for bugs, feature requests and ExoPlayer
-  specific questions. If you're asking a general Android development question,
-  please do so on Stack Overflow.
+  reproduce the issue in the ExoPlayer demo app. Information about the ExoPlayer
+  demo app can be found here:
+  http://google.github.io/ExoPlayer/demo-application.html.
 
 When reporting a bug:
 -----------------------
@@ -15,29 +22,37 @@ Fill out the sections below, leaving the headers but replacing the content. If
 you're unable to provide certain information, please explain why in the relevant
 section. We may close issues if they do not include sufficient information.
 
-### Issue description
+### [REQUIRED] Issue description
 Describe the issue in detail, including observed and expected behavior.
 
-### Reproduction steps
-Describe how the issue can be reproduced, ideally using the ExoPlayer demo app.
+### [REQUIRED] Reproduction steps
+Describe how the issue can be reproduced, ideally using the ExoPlayer demo app
+or a small sample app that you’re able to share as source code on GitHub.
 
-### Link to test content
-Provide a link to media that reproduces the issue. If you don't wish to post it
-publicly, please submit the issue, then email the link to
-dev.exoplayer@gmail.com using a subject in the format "Issue #1234".
+### [REQUIRED] Link to test content
+Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
+media that reproduces the issue. If you don't wish to post it publicly, please
+submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
+in the format "Issue #1234". Provide all the metadata we'd need to play the
+content like drm license urls or similar. If the content is accessible only in
+certain countries or regions, please say so.
 
-### Version of ExoPlayer being used
-Specify the absolute version number. Avoid using terms such as "latest".
-
-### Device(s) and version(s) of Android being used
-Specify the devices and versions of Android on which the issue can be
-reproduced, and how easily it reproduces. If possible, please test on multiple
-devices and Android versions.
-
-### A full bug report captured from the device
+### [REQUIRED] A full bug report captured from the device
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
 "Issue #1234".
 
+### [REQUIRED] Version of ExoPlayer being used
+Specify the absolute version number. Avoid using terms such as "latest".
+
+### [REQUIRED] Device(s) and version(s) of Android being used
+Specify the devices and versions of Android on which the issue can be
+reproduced, and how easily it reproduces. If possible, please test on multiple
+devices and Android versions.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/bug.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
new file mode 100644
index 0000000000..a8265c4bd6
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -0,0 +1,47 @@
+---
+name: Content not playing correctly
+about: Issue template for a content not playing issue.
+title: ''
+labels: content not playing, needs triage
+assignees: ''
+---
+
+Before filing a content issue:
+------------------------------
+- Search existing issues, including issues that are closed.
+- Consult our supported formats page, which can be found at
+  https://google.github.io/ExoPlayer/supported-formats.html.
+- Try playing your content in the ExoPlayer demo app. Information about the
+  ExoPlayer demo app can be found here:
+  http://google.github.io/ExoPlayer/demo-application.html.
+
+When reporting a content issue:
+-----------------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Content description
+Describe the content and any specifics you expected to play but did not. This
+could be the container or sample format itself or any features the stream has
+and you expect to play, like 5.1 audio track, text tracks or drm systems.
+
+### [REQUIRED] Link to test content
+Provide a JSON snippet for the demo app’s media.exolist.json file, or a link to
+media that reproduces the issue. If you don't wish to post it publicly, please
+submit the issue, then email the link to dev.exoplayer@gmail.com using a subject
+in the format "Issue #1234". Provide all the metadata we'd need to play the
+content like drm license urls or similar. If the content is accessible only in
+certain countries or regions, please say so.
+
+### [REQUIRED] Version of ExoPlayer being used
+Specify the absolute version number. Avoid using terms such as "latest".
+
+### [REQUIRED] Device(s) and version(s) of Android being used
+Specify the devices and versions of Android on which you expect the content to
+play. If possible, please test on multiple devices and Android versions.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 0000000000..089de35910
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,34 @@
+---
+name: Feature request
+about: Issue template for a feature request.
+title: ''
+labels: enhancement, needs triage
+assignees: ''
+---
+
+Before filing a feature request:
+-----------------------
+- Search existing open issues, specifically with the label ‘enhancement’.
+- Search existing pull requests.
+
+When filing a feature request:
+-----------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Use case description
+Describe the use case or problem you are trying to solve in detail. If there are
+any standards or specifications involved, please provide the relevant details.
+
+### Proposed solution
+A clear and concise description of your proposed solution, if you have one.
+
+### Alternatives considered
+A clear and concise description of any alternative solutions you considered,
+if applicable.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/feature_request.md
+-->
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
new file mode 100644
index 0000000000..57202f17dd
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -0,0 +1,34 @@
+---
+name: Question
+about: Issue template for a question.
+title: ''
+labels: question, needs triage
+assignees: ''
+---
+
+Before filing a question:
+-----------------------
+- This issue tracker is intended ExoPlayer specific questions. If you're asking
+  a general Android development question, please do so on Stack Overflow.
+- Search existing issues, including issues that are closed. It’s often the
+  quickest way to get an answer!
+- Consult our FAQs, developer guide and the class reference of ExoPlayer. These
+  can be found at https://google.github.io/ExoPlayer/.
+
+When filing a question:
+-----------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### [REQUIRED] Searched documentation and issues
+Tell us where you’ve already looked for an answer to your question. It’s
+important for us to know this so that we can improve our documentation.
+
+### [REQUIRED] Question
+Describe your question in detail.
+
+<!-- DO NOT DELETE
+validate_template=true
+template_path=.github/ISSUE_TEMPLATE/question.md
+-->
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 68794310bd..6c87dd02b4 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,45 @@
 # Release notes #
 
+### 2.9.6 ###
+
+* Remove `player` and `isTopLevelSource` parameters from `MediaSource.prepare`.
+* IMA extension:
+  * Require setting the `Player` on `AdsLoader` instances before
+    playback.
+  * Remove deprecated `ImaAdsMediaSource`. Create `AdsMediaSource` with an
+    `ImaAdsLoader` instead.
+  * Remove deprecated `AdsMediaSource` constructors. Listen for media source
+    events using `AdsMediaSource.addEventListener`, and ad interaction events by
+    adding a listener when building `ImaAdsLoader`.
+  * Allow apps to register playback-related obstructing views that are on top of
+    their ad display containers via `AdsLoader.AdViewProvider`. `PlayerView`
+    implements this interface and will register its control view. This makes it
+    possible for ad loading SDKs to calculate ad viewability accurately.
+* DASH: Fix issue handling large `EventStream` presentation timestamps
+  ([#5490](https://github.com/google/ExoPlayer/issues/5490)).
+* HLS: Fix transition to STATE_ENDED when playing fragmented mp4 in chunkless
+  preparation ([#5524](https://github.com/google/ExoPlayer/issues/5524)).
+* Revert workaround for video quality problems with Amlogic decoders, as this
+  may cause problems for some devices and/or non-interlaced content
+  ([#5003](https://github.com/google/ExoPlayer/issues/5003)).
+
+### 2.9.5 ###
+
+* HLS: Parse `CHANNELS` attribute from `EXT-X-MEDIA` tag.
+* ConcatenatingMediaSource:
+  * Add `Handler` parameter to methods that take a callback `Runnable`.
+  * Fix issue with dropped messages when releasing the source
+    ([#5464](https://github.com/google/ExoPlayer/issues/5464)).
+* ExtractorMediaSource: Fix issue that could cause the player to get stuck
+  buffering at the end of the media.
+* PlayerView: Fix issue preventing `OnClickListener` from receiving events
+  ([#5433](https://github.com/google/ExoPlayer/issues/5433)).
+* IMA extension: Upgrade IMA dependency to 3.10.6.
+* Cronet extension: Upgrade Cronet dependency to 71.3578.98.
+* OkHttp extension: Upgrade OkHttp dependency to 3.12.1.
+* MP3: Wider fix for issue where streams would play twice on some Samsung
+  devices ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
+
 ### 2.9.4 ###
 
 * IMA extension: Clear ads loader listeners on release
@@ -1160,7 +1200,7 @@
   [here](https://medium.com/google-exoplayer/customizing-exoplayers-ui-components-728cf55ee07a#.9ewjg7avi).
 * Robustness improvements when handling MediaSource timeline changes and
   MediaPeriod transitions.
-* EIA608: Support for caption styling and positioning.
+* CEA-608: Support for caption styling and positioning.
 * MPEG-TS: Improved support:
   * Support injection of custom TS payload readers.
   * Support injection of custom section payload readers.
@@ -1404,8 +1444,8 @@ V2 release.
   (#801).
 * MP3: Fix playback of some streams when stream length is unknown.
 * ID3: Support multiple frames of the same type in a single tag.
-* EIA608: Correctly handle repeated control characters, fixing an issue in which
-  captions would immediately disappear.
+* CEA-608: Correctly handle repeated control characters, fixing an issue in
+  which captions would immediately disappear.
 * AVC3: Fix decoder failures on some MediaTek devices in the case where the
   first buffer fed to the decoder does not start with SPS/PPS NAL units.
 * Misc bug fixes.
diff --git a/constants.gradle b/constants.gradle
index 716ddbadba..d7349c3c66 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.9.4'
-    releaseVersionCode = 2009004
+    releaseVersion = '2.9.6'
+    releaseVersionCode = 2009006
     // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
diff --git a/demos/ima/src/main/AndroidManifest.xml b/demos/ima/src/main/AndroidManifest.xml
index 50ad0c1b54..85439018fd 100644
--- a/demos/ima/src/main/AndroidManifest.xml
+++ b/demos/ima/src/main/AndroidManifest.xml
@@ -17,6 +17,7 @@
     package="com.google.android.exoplayer2.imademo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
   <uses-sdk/>
 
   <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index d67c4549d8..fb13073840 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -29,10 +29,6 @@
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
@@ -56,14 +52,9 @@ public PlayerManager(Context context) {
   }
 
   public void init(Context context, PlayerView playerView) {
-    // Create a default track selector.
-    TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
-    TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
-
     // Create a player instance.
-    player = ExoPlayerFactory.newSimpleInstance(context, trackSelector);
-
-    // Bind the player to the view.
+    player = ExoPlayerFactory.newSimpleInstance(context);
+    adsLoader.setPlayer(player);
     playerView.setPlayer(player);
 
     // This is the MediaSource representing the content media (i.e. not the ad).
@@ -73,10 +64,7 @@ public void init(Context context, PlayerView playerView) {
     // Compose the content media source into a new AdsMediaSource with both ads and content.
     MediaSource mediaSourceWithAds =
         new AdsMediaSource(
-            contentMediaSource,
-            /* adMediaSourceFactory= */ this,
-            adsLoader,
-            playerView.getOverlayFrameLayout());
+            contentMediaSource, /* adMediaSourceFactory= */ this, adsLoader, playerView);
 
     // Prepare the player with the source.
     player.seekTo(contentPosition);
@@ -89,6 +77,7 @@ public void reset() {
       contentPosition = player.getContentPosition();
       player.release();
       player = null;
+      adsLoader.setPlayer(null);
     }
   }
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index ffa9bafa4f..483ab37369 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -27,9 +27,7 @@
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
-import android.view.ViewGroup;
 import android.widget.Button;
-import android.widget.FrameLayout;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 import android.widget.Toast;
@@ -151,7 +149,6 @@
 
   private AdsLoader adsLoader;
   private Uri loadedAdTagUri;
-  private ViewGroup adUiViewGroup;
 
   // Activity lifecycle
 
@@ -474,7 +471,6 @@ private MediaSource buildMediaSource(Uri uri) {
     return buildMediaSource(uri, null);
   }
 
-  @SuppressWarnings("unchecked")
   private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
     @ContentType int type = Util.inferContentType(uri, overrideExtension);
     switch (type) {
@@ -534,6 +530,9 @@ private void releasePlayer() {
       mediaSource = null;
       trackSelector = null;
     }
+    if (adsLoader != null) {
+      adsLoader.setPlayer(null);
+    }
     releaseMediaDrm();
   }
 
@@ -593,10 +592,8 @@ private void clearStartPosition() {
                 .getConstructor(android.content.Context.class, android.net.Uri.class);
         // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
         adsLoader = loaderConstructor.newInstance(this, adTagUri);
-        adUiViewGroup = new FrameLayout(this);
-        // The demo app has a non-null overlay frame layout.
-        playerView.getOverlayFrameLayout().addView(adUiViewGroup);
       }
+      adsLoader.setPlayer(player);
       AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
           new AdsMediaSource.MediaSourceFactory() {
             @Override
@@ -609,7 +606,7 @@ public MediaSource createMediaSource(Uri uri) {
               return new int[] {C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
             }
           };
-      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, adUiViewGroup);
+      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, playerView);
     } catch (ClassNotFoundException e) {
       // IMA extension not loaded.
       return null;
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 7d8c217b58..520edfe1d1 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -30,7 +30,7 @@ android {
 }
 
 dependencies {
-    api 'org.chromium.net:cronet-embedded:66.3359.158'
+    api 'org.chromium.net:cronet-embedded:71.3578.98'
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     testImplementation project(modulePrefix + 'library')
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index 22196ff3ab..4d6302c898 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -31,13 +31,13 @@ android {
 }
 
 dependencies {
-    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.10.2'
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.10.6'
     implementation project(modulePrefix + 'library-core')
-    implementation 'com.google.android.gms:play-services-ads:17.1.1'
+    implementation 'com.google.android.gms:play-services-ads:17.1.2'
     // These dependencies are necessary to force the supportLibraryVersion of
     // com.android.support:support-v4 and com.android.support:customtabs to be
     // used. Else older versions are used, for example via:
-    // com.google.android.gms:play-services-ads:17.1.1
+    // com.google.android.gms:play-services-ads:17.1.2
     // |-- com.android.support:customtabs:26.1.0
     implementation 'com.android.support:support-v4:' + supportLibraryVersion
     implementation 'com.android.support:customtabs:' + supportLibraryVersion
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 9b4b66125c..3aeefb5441 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -21,6 +21,7 @@
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import android.view.View;
 import android.view.ViewGroup;
 import com.google.ads.interactivemedia.v3.api.Ad;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
@@ -46,7 +47,6 @@
 import com.google.ads.interactivemedia.v3.api.player.VideoProgressUpdate;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
@@ -73,7 +73,17 @@
 import java.util.Map;
 import java.util.Set;
 
-/** Loads ads using the IMA SDK. All methods are called on the main thread. */
+/**
+ * {@link AdsLoader} using the IMA SDK. All methods must be called on the main thread.
+ *
+ * <p>The player instance that will play the loaded ads must be set before playback using {@link
+ * #setPlayer(Player)}. If the ads loader is no longer required, it must be released by calling
+ * {@link #release()}.
+ *
+ * <p>The IMA SDK can take into account video control overlay views when calculating ad viewability.
+ * For more details see {@link AdDisplayContainer#registerVideoControlsOverlay(View)} and {@link
+ * AdViewProvider#getAdOverlayViews()}.
+ */
 public final class ImaAdsLoader
     implements Player.EventListener,
         AdsLoader,
@@ -92,9 +102,9 @@
 
     private final Context context;
 
-    private @Nullable ImaSdkSettings imaSdkSettings;
-    private @Nullable AdEventListener adEventListener;
-    private @Nullable Set<UiElement> adUiElements;
+    @Nullable private ImaSdkSettings imaSdkSettings;
+    @Nullable private AdEventListener adEventListener;
+    @Nullable private Set<UiElement> adUiElements;
     private int vastLoadTimeoutMs;
     private int mediaLoadTimeoutMs;
     private int mediaBitrate;
@@ -316,10 +326,11 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
+  @Nullable private Player nextPlayer;
   private Object pendingAdRequestContext;
   private List<String> supportedMimeTypes;
-  private EventListener eventListener;
-  private Player player;
+  @Nullable private EventListener eventListener;
+  @Nullable private Player player;
   private VideoProgressUpdate lastContentProgress;
   private VideoProgressUpdate lastAdProgress;
   private int lastVolumePercentage;
@@ -459,11 +470,11 @@ private ImaAdsLoader(
     }
     imaSdkSettings.setPlayerType(IMA_SDK_SETTINGS_PLAYER_TYPE);
     imaSdkSettings.setPlayerVersion(IMA_SDK_SETTINGS_PLAYER_VERSION);
-    adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings);
     period = new Timeline.Period();
     adCallbacks = new ArrayList<>(/* initialCapacity= */ 1);
     adDisplayContainer = imaFactory.createAdDisplayContainer();
     adDisplayContainer.setPlayer(/* videoAdPlayer= */ this);
+    adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings, adDisplayContainer);
     adsLoader.addAdErrorListener(/* adErrorListener= */ this);
     adsLoader.addAdsLoadedListener(/* adsLoadedListener= */ this);
     fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
@@ -481,13 +492,29 @@ private ImaAdsLoader(
     return adsLoader;
   }
 
+  /**
+   * Returns the {@link AdDisplayContainer} used by this loader.
+   *
+   * <p>Note: any video controls overlays registered via {@link
+   * AdDisplayContainer#registerVideoControlsOverlay(View)} will be unregistered automatically when
+   * the media source detaches from this instance. It is therefore necessary to re-register views
+   * each time the ads loader is reused. Alternatively, provide overlay views via the {@link
+   * AdsLoader.AdViewProvider} when creating the media source to benefit from automatic
+   * registration.
+   */
+  public AdDisplayContainer getAdDisplayContainer() {
+    return adDisplayContainer;
+  }
+
   /**
    * Sets the slots for displaying companion ads. Individual slots can be created using {@link
    * ImaSdkFactory#createCompanionAdSlot()}.
    *
    * @param companionSlots Slots for displaying companion ads.
    * @see AdDisplayContainer#setCompanionSlots(Collection)
+   * @deprecated Use {@code getAdDisplayContainer().setCompanionSlots(...)}.
    */
+  @Deprecated
   public void setCompanionSlots(Collection<CompanionAdSlot> companionSlots) {
     adDisplayContainer.setCompanionSlots(companionSlots);
   }
@@ -499,14 +526,14 @@ public void setCompanionSlots(Collection<CompanionAdSlot> companionSlots) {
    * called, so it is only necessary to call this method if you want to request ads before preparing
    * the player.
    *
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
    */
-  public void requestAds(ViewGroup adUiViewGroup) {
+  public void requestAds(ViewGroup adViewGroup) {
     if (adPlaybackState != null || adsManager != null || pendingAdRequestContext != null) {
       // Ads have already been requested.
       return;
     }
-    adDisplayContainer.setAdContainer(adUiViewGroup);
+    adDisplayContainer.setAdContainer(adViewGroup);
     pendingAdRequestContext = new Object();
     AdsRequest request = imaFactory.createAdsRequest();
     if (adTagUri != null) {
@@ -517,7 +544,6 @@ public void requestAds(ViewGroup adUiViewGroup) {
     if (vastLoadTimeoutMs != TIMEOUT_UNSET) {
       request.setVastLoadTimeout(vastLoadTimeoutMs);
     }
-    request.setAdDisplayContainer(adDisplayContainer);
     request.setContentProgressProvider(this);
     request.setUserRequestContext(pendingAdRequestContext);
     adsLoader.requestAds(request);
@@ -525,6 +551,14 @@ public void requestAds(ViewGroup adUiViewGroup) {
 
   // AdsLoader implementation.
 
+  @Override
+  public void setPlayer(@Nullable Player player) {
+    Assertions.checkState(Looper.getMainLooper() == Looper.myLooper());
+    Assertions.checkState(
+        player == null || player.getApplicationLooper() == Looper.getMainLooper());
+    nextPlayer = player;
+  }
+
   @Override
   public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
     List<String> supportedMimeTypes = new ArrayList<>();
@@ -549,14 +583,20 @@ public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
   }
 
   @Override
-  public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup) {
-    Assertions.checkArgument(player.getApplicationLooper() == Looper.getMainLooper());
-    this.player = player;
+  public void start(EventListener eventListener, AdViewProvider adViewProvider) {
+    Assertions.checkNotNull(
+        nextPlayer, "Set player using adsLoader.setPlayer before preparing the player.");
+    player = nextPlayer;
     this.eventListener = eventListener;
     lastVolumePercentage = 0;
     lastAdProgress = null;
     lastContentProgress = null;
-    adDisplayContainer.setAdContainer(adUiViewGroup);
+    ViewGroup adViewGroup = adViewProvider.getAdViewGroup();
+    adDisplayContainer.setAdContainer(adViewGroup);
+    View[] adOverlayViews = adViewProvider.getAdOverlayViews();
+    for (View view : adOverlayViews) {
+      adDisplayContainer.registerVideoControlsOverlay(view);
+    }
     player.addListener(this);
     maybeNotifyPendingAdLoadError();
     if (adPlaybackState != null) {
@@ -570,12 +610,12 @@ public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGrou
       startAdPlayback();
     } else {
       // Ads haven't loaded yet, so request them.
-      requestAds(adUiViewGroup);
+      requestAds(adViewGroup);
     }
   }
 
   @Override
-  public void detachPlayer() {
+  public void stop() {
     if (adsManager != null && imaPausedContent) {
       adPlaybackState =
           adPlaybackState.withAdResumePositionUs(
@@ -585,6 +625,7 @@ public void detachPlayer() {
     lastVolumePercentage = getVolume();
     lastAdProgress = getAdProgress();
     lastContentProgress = getContentProgress();
+    adDisplayContainer.unregisterAllVideoControlsOverlays();
     player.removeListener(this);
     player = null;
     eventListener = null;
@@ -1331,7 +1372,8 @@ private void maybeNotifyInternalError(String name, Exception cause) {
   private static boolean isAdGroupLoadError(AdError adError) {
     // TODO: Find out what other errors need to be handled (if any), and whether each one relates to
     // a single ad, ad group or the whole timeline.
-    return adError.getErrorCode() == AdErrorCode.VAST_LINEAR_ASSET_MISMATCH;
+    return adError.getErrorCode() == AdErrorCode.VAST_LINEAR_ASSET_MISMATCH
+        || adError.getErrorCode() == AdErrorCode.UNKNOWN_ERROR;
   }
 
   private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
@@ -1357,9 +1399,9 @@ private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
     AdDisplayContainer createAdDisplayContainer();
     /** @see com.google.ads.interactivemedia.v3.api.ImaSdkFactory#createAdsRequest() */
     AdsRequest createAdsRequest();
-    /** @see ImaSdkFactory#createAdsLoader(Context, ImaSdkSettings) */
+    /** @see ImaSdkFactory#createAdsLoader(Context, ImaSdkSettings, AdDisplayContainer) */
     com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-        Context context, ImaSdkSettings imaSdkSettings);
+        Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer);
   }
 
   /** Default {@link ImaFactory} for non-test usage, which delegates to {@link ImaSdkFactory}. */
@@ -1386,8 +1428,9 @@ public AdsRequest createAdsRequest() {
 
     @Override
     public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-        Context context, ImaSdkSettings imaSdkSettings) {
-      return ImaSdkFactory.getInstance().createAdsLoader(context, imaSdkSettings);
+        Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
+      return ImaSdkFactory.getInstance()
+          .createAdsLoader(context, imaSdkSettings, adDisplayContainer);
     }
   }
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
deleted file mode 100644
index 0978ee401c..0000000000
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ext.ima;
-
-import android.os.Handler;
-import android.support.annotation.Nullable;
-import android.view.ViewGroup;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.BaseMediaSource;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSource.SourceInfoRefreshListener;
-import com.google.android.exoplayer2.source.ads.AdsMediaSource;
-import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import java.io.IOException;
-
-/**
- * A {@link MediaSource} that inserts ads linearly with a provided content media source.
- *
- * @deprecated Use com.google.android.exoplayer2.source.ads.AdsMediaSource with ImaAdsLoader.
- */
-@Deprecated
-public final class ImaAdsMediaSource extends BaseMediaSource implements SourceInfoRefreshListener {
-
-  private final AdsMediaSource adsMediaSource;
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by
-   * {@code contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param imaAdsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   */
-  public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
-      ImaAdsLoader imaAdsLoader, ViewGroup adUiViewGroup) {
-    this(contentMediaSource, dataSourceFactory, imaAdsLoader, adUiViewGroup, null, null);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param imaAdsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public ImaAdsMediaSource(
-      MediaSource contentMediaSource,
-      DataSource.Factory dataSourceFactory,
-      ImaAdsLoader imaAdsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable AdsMediaSource.EventListener eventListener) {
-    adsMediaSource = new AdsMediaSource(contentMediaSource, dataSourceFactory, imaAdsLoader,
-        adUiViewGroup, eventHandler, eventListener);
-  }
-
-  @Override
-  @Nullable
-  public Object getTag() {
-    return adsMediaSource.getTag();
-  }
-
-  @Override
-  public void prepareSourceInternal(
-      final ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    adsMediaSource.prepareSource(
-        player, isTopLevelSource, /* listener= */ this, mediaTransferListener);
-  }
-
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    adsMediaSource.maybeThrowSourceInfoRefreshError();
-  }
-
-  @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
-    return adsMediaSource.createPeriod(id, allocator, startPositionUs);
-  }
-
-  @Override
-  public void releasePeriod(MediaPeriod mediaPeriod) {
-    adsMediaSource.releasePeriod(mediaPeriod);
-  }
-
-  @Override
-  public void releaseSourceInternal() {
-    adsMediaSource.releaseSource(/* listener= */ this);
-  }
-
-  @Override
-  public void onSourceInfoRefreshed(
-      MediaSource source, Timeline timeline, @Nullable Object manifest) {
-    refreshSourceInfo(timeline, manifest);
-  }
-}
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
index b8024d6534..d20ccbd728 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.testutil.StubExoPlayer;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import java.util.ArrayList;
 
 /** A fake player for testing content/ad playback. */
@@ -109,6 +110,11 @@ public void setState(int state, boolean playWhenReady) {
 
   // ExoPlayer methods. Other methods are unsupported.
 
+  @Override
+  public AudioComponent getAudioComponent() {
+    return null;
+  }
+
   @Override
   public Looper getApplicationLooper() {
     return Looper.getMainLooper();
@@ -134,6 +140,16 @@ public boolean getPlayWhenReady() {
     return playWhenReady;
   }
 
+  @Override
+  public int getRendererCount() {
+    return 0;
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return new TrackSelectionArray();
+  }
+
   @Override
   public Timeline getCurrentTimeline() {
     return timeline;
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
index b0fe731480..dabae2de4b 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
@@ -17,11 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import android.net.Uri;
 import android.support.annotation.Nullable;
+import android.view.View;
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
 import com.google.ads.interactivemedia.v3.api.Ad;
@@ -49,6 +51,7 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
@@ -73,7 +76,9 @@
   private @Mock AdDisplayContainer adDisplayContainer;
   private @Mock AdsManager adsManager;
   private SingletonImaFactory testImaFactory;
-  private ViewGroup adUiViewGroup;
+  private ViewGroup adViewGroup;
+  private View adOverlayView;
+  private AdsLoader.AdViewProvider adViewProvider;
   private TestAdsLoaderListener adsLoaderListener;
   private FakePlayer fakeExoPlayer;
   private ImaAdsLoader imaAdsLoader;
@@ -90,7 +95,20 @@ public void setUp() {
             adDisplayContainer,
             fakeAdsRequest,
             fakeAdsLoader);
-    adUiViewGroup = new FrameLayout(RuntimeEnvironment.application);
+    adViewGroup = new FrameLayout(RuntimeEnvironment.application);
+    adOverlayView = new View(RuntimeEnvironment.application);
+    adViewProvider =
+        new AdsLoader.AdViewProvider() {
+          @Override
+          public ViewGroup getAdViewGroup() {
+            return adViewGroup;
+          }
+
+          @Override
+          public View[] getAdOverlayViews() {
+            return new View[] {adOverlayView};
+          }
+        };
   }
 
   @After
@@ -109,17 +127,18 @@ public void testBuilder_overridesPlayerType() {
   }
 
   @Test
-  public void testAttachPlayer_setsAdUiViewGroup() {
+  public void testStart_setsAdUiViewGroup() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
 
-    verify(adDisplayContainer, atLeastOnce()).setAdContainer(adUiViewGroup);
+    verify(adDisplayContainer, atLeastOnce()).setAdContainer(adViewGroup);
+    verify(adDisplayContainer, atLeastOnce()).registerVideoControlsOverlay(adOverlayView);
   }
 
   @Test
-  public void testAttachPlayer_updatesAdPlaybackState() {
+  public void testStart_updatesAdPlaybackState() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
 
     assertThat(adsLoaderListener.adPlaybackState)
         .isEqualTo(
@@ -128,17 +147,17 @@ public void testAttachPlayer_updatesAdPlaybackState() {
   }
 
   @Test
-  public void testAttachAfterRelease() {
+  public void testStartAfterRelease() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
     imaAdsLoader.release();
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
   }
 
   @Test
-  public void testAttachAndCallbacksAfterRelease() {
+  public void testStartAndCallbacksAfterRelease() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
     imaAdsLoader.release();
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
     fakeExoPlayer.setPlayingContentPosition(/* position= */ 0);
     fakeExoPlayer.setState(Player.STATE_READY, true);
 
@@ -146,7 +165,7 @@ public void testAttachAndCallbacksAfterRelease() {
     // Note: we can't currently call getContentProgress/getAdProgress as a VerifyError is thrown
     // when using Robolectric and accessing VideoProgressUpdate.VIDEO_TIME_NOT_READY, due to the IMA
     // SDK being proguarded.
-    imaAdsLoader.requestAds(adUiViewGroup);
+    imaAdsLoader.requestAds(adViewGroup);
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
     imaAdsLoader.loadAd(TEST_URI.toString());
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
@@ -166,7 +185,7 @@ public void testPlayback_withPrerollAd_marksAdAsPlayed() {
     setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
 
     // Load the preroll ad.
-    imaAdsLoader.attachPlayer(fakeExoPlayer, adsLoaderListener, adUiViewGroup);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.LOADED, UNSKIPPABLE_AD));
     imaAdsLoader.loadAd(TEST_URI.toString());
     imaAdsLoader.onAdEvent(getAdEvent(AdEventType.CONTENT_PAUSE_REQUESTED, UNSKIPPABLE_AD));
@@ -201,6 +220,18 @@ public void testPlayback_withPrerollAd_marksAdAsPlayed() {
                 .withAdResumePositionUs(/* adResumePositionUs= */ 0));
   }
 
+  @Test
+  public void testStop_unregistersAllVideoControlOverlays() {
+    setupPlayback(CONTENT_TIMELINE, PREROLL_ADS_DURATIONS_US, PREROLL_CUE_POINTS_SECONDS);
+    imaAdsLoader.start(adsLoaderListener, adViewProvider);
+    imaAdsLoader.requestAds(adViewGroup);
+    imaAdsLoader.stop();
+
+    InOrder inOrder = inOrder(adDisplayContainer);
+    inOrder.verify(adDisplayContainer).registerVideoControlsOverlay(adOverlayView);
+    inOrder.verify(adDisplayContainer).unregisterAllVideoControlsOverlays();
+  }
+
   private void setupPlayback(Timeline contentTimeline, long[][] adDurationsUs, Float[] cuePoints) {
     fakeExoPlayer = new FakePlayer();
     adsLoaderListener = new TestAdsLoaderListener(fakeExoPlayer, contentTimeline, adDurationsUs);
@@ -210,6 +241,7 @@ private void setupPlayback(Timeline contentTimeline, long[][] adDurationsUs, Flo
             .setImaFactory(testImaFactory)
             .setImaSdkSettings(imaSdkSettings)
             .buildForAdTag(TEST_URI);
+    imaAdsLoader.setPlayer(fakeExoPlayer);
   }
 
   private static AdEvent getAdEvent(AdEventType adEventType, @Nullable Ad ad) {
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
index dd46d8a68b..4efd8cf38c 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/SingletonImaFactory.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdsLoader;
 import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
 import com.google.ads.interactivemedia.v3.api.AdsRequest;
 import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
@@ -64,8 +65,8 @@ public AdsRequest createAdsRequest() {
   }
 
   @Override
-  public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
-      Context context, ImaSdkSettings imaSdkSettings) {
+  public AdsLoader createAdsLoader(
+      Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
     return adsLoader;
   }
 }
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 4e6b11c495..78825a6277 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -34,7 +34,7 @@ dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
     compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
-    api 'com.squareup.okhttp3:okhttp:3.11.0'
+    api 'com.squareup.okhttp3:okhttp:3.12.1'
 }
 
 ext {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index cc16c43b05..50832dd5af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.content.Context;
+import android.media.MediaCodec;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.IntDef;
@@ -85,15 +86,18 @@
   protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
 
   private final Context context;
-  private final @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
-  private final @ExtensionRendererMode int extensionRendererMode;
-  private final long allowedVideoJoiningTimeMs;
+  @Nullable private DrmSessionManager<FrameworkMediaCrypto> drmSessionManager;
+  @ExtensionRendererMode private int extensionRendererMode;
+  private long allowedVideoJoiningTimeMs;
+  private boolean playClearSamplesWithoutKeys;
+  private MediaCodecSelector mediaCodecSelector;
 
-  /**
-   * @param context A {@link Context}.
-   */
+  /** @param context A {@link Context}. */
   public DefaultRenderersFactory(Context context) {
-    this(context, EXTENSION_RENDERER_MODE_OFF);
+    this.context = context;
+    extensionRendererMode = EXTENSION_RENDERER_MODE_OFF;
+    allowedVideoJoiningTimeMs = DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS;
+    mediaCodecSelector = MediaCodecSelector.DEFAULT;
   }
 
   /**
@@ -108,19 +112,20 @@ public DefaultRenderersFactory(
   }
 
   /**
-   * @param context A {@link Context}.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
+   *     #setExtensionRendererMode(int)}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context, @ExtensionRendererMode int extensionRendererMode) {
     this(context, extensionRendererMode, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
   }
 
   /**
-   * @deprecated Use {@link #DefaultRenderersFactory(Context, int)} and pass {@link
-   *     DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
+   *     #setExtensionRendererMode(int)}, and pass {@link DrmSessionManager} directly to {@link
+   *     SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
@@ -132,26 +137,22 @@ public DefaultRenderersFactory(
   }
 
   /**
-   * @param context A {@link Context}.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
-   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
-   *     seamlessly join an ongoing playback.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
+   *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public DefaultRenderersFactory(
       Context context,
       @ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
-    this.context = context;
-    this.extensionRendererMode = extensionRendererMode;
-    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
-    this.drmSessionManager = null;
+    this(context, null, extensionRendererMode, allowedVideoJoiningTimeMs);
   }
 
   /**
-   * @deprecated Use {@link #DefaultRenderersFactory(Context, int, long)} and pass {@link
-   *     DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
+   *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}, and pass
+   *     {@link DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
    */
   @Deprecated
   public DefaultRenderersFactory(
@@ -163,6 +164,70 @@ public DefaultRenderersFactory(
     this.extensionRendererMode = extensionRendererMode;
     this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
     this.drmSessionManager = drmSessionManager;
+    mediaCodecSelector = MediaCodecSelector.DEFAULT;
+  }
+
+  /**
+   * Sets the extension renderer mode, which determines if and how available extension renderers are
+   * used. Note that extensions must be included in the application build for them to be considered
+   * available.
+   *
+   * <p>The default value is {@link #EXTENSION_RENDERER_MODE_OFF}.
+   *
+   * @param extensionRendererMode The extension renderer mode.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setExtensionRendererMode(
+      @ExtensionRendererMode int extensionRendererMode) {
+    this.extensionRendererMode = extensionRendererMode;
+    return this;
+  }
+
+  /**
+   * Sets whether renderers are permitted to play clear regions of encrypted media prior to having
+   * obtained the keys necessary to decrypt encrypted regions of the media. For encrypted media that
+   * starts with a short clear region, this allows playback to begin in parallel with key
+   * acquisition, which can reduce startup latency.
+   *
+   * <p>The default value is {@code false}.
+   *
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setPlayClearSamplesWithoutKeys(
+      boolean playClearSamplesWithoutKeys) {
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    return this;
+  }
+
+  /**
+   * Sets a {@link MediaCodecSelector} for use by {@link MediaCodec} based renderers.
+   *
+   * <p>The default value is {@link MediaCodecSelector#DEFAULT}.
+   *
+   * @param mediaCodecSelector The {@link MediaCodecSelector}.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setMediaCodecSelector(MediaCodecSelector mediaCodecSelector) {
+    this.mediaCodecSelector = mediaCodecSelector;
+    return this;
+  }
+
+  /**
+   * Sets the maximum duration for which video renderers can attempt to seamlessly join an ongoing
+   * playback.
+   *
+   * <p>The default value is {@link #DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS}.
+   *
+   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
+   *     seamlessly join an ongoing playback, in milliseconds.
+   * @return This factory, for convenience.
+   */
+  public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoiningTimeMs) {
+    this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;
+    return this;
   }
 
   @Override
@@ -177,10 +242,26 @@ public DefaultRenderersFactory(
       drmSessionManager = this.drmSessionManager;
     }
     ArrayList<Renderer> renderersList = new ArrayList<>();
-    buildVideoRenderers(context, drmSessionManager, allowedVideoJoiningTimeMs,
-        eventHandler, videoRendererEventListener, extensionRendererMode, renderersList);
-    buildAudioRenderers(context, drmSessionManager, buildAudioProcessors(),
-        eventHandler, audioRendererEventListener, extensionRendererMode, renderersList);
+    buildVideoRenderers(
+        context,
+        extensionRendererMode,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        eventHandler,
+        videoRendererEventListener,
+        allowedVideoJoiningTimeMs,
+        renderersList);
+    buildAudioRenderers(
+        context,
+        extensionRendererMode,
+        mediaCodecSelector,
+        drmSessionManager,
+        playClearSamplesWithoutKeys,
+        buildAudioProcessors(),
+        eventHandler,
+        audioRendererEventListener,
+        renderersList);
     buildTextRenderers(context, textRendererOutput, eventHandler.getLooper(),
         extensionRendererMode, renderersList);
     buildMetadataRenderers(context, metadataRendererOutput, eventHandler.getLooper(),
@@ -194,27 +275,36 @@ public DefaultRenderersFactory(
    * Builds video renderers for use by the player.
    *
    * @param context The {@link Context} associated with the player.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player
-   *     will not be used for DRM protected playbacks.
-   * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video
-   *     renderers can attempt to seamlessly join an ongoing playback.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   *     not be used for DRM protected playbacks.
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
    * @param eventHandler A handler associated with the main thread's looper.
    * @param eventListener An event listener.
-   * @param extensionRendererMode The extension renderer mode.
+   * @param allowedVideoJoiningTimeMs The maximum duration for which video renderers can attempt to
+   *     seamlessly join an ongoing playback, in milliseconds.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildVideoRenderers(Context context,
+  protected void buildVideoRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      long allowedVideoJoiningTimeMs, Handler eventHandler,
-      VideoRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
+      boolean playClearSamplesWithoutKeys,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs,
       ArrayList<Renderer> out) {
     out.add(
         new MediaCodecVideoRenderer(
             context,
-            MediaCodecSelector.DEFAULT,
+            mediaCodecSelector,
             allowedVideoJoiningTimeMs,
             drmSessionManager,
-            /* playClearSamplesWithoutKeys= */ false,
+            playClearSamplesWithoutKeys,
             eventHandler,
             eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
@@ -261,26 +351,35 @@ protected void buildVideoRenderers(Context context,
    * Builds audio renderers for use by the player.
    *
    * @param context The {@link Context} associated with the player.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player
-   *     will not be used for DRM protected playbacks.
-   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio
-   *     buffers before output. May be empty.
+   * @param extensionRendererMode The extension renderer mode.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+   *     not be used for DRM protected playbacks.
+   * @param playClearSamplesWithoutKeys Whether renderers are permitted to play clear regions of
+   *     encrypted media prior to having obtained the keys necessary to decrypt encrypted regions of
+   *     the media.
+   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
+   *     before output. May be empty.
    * @param eventHandler A handler to use when invoking event listeners and outputs.
    * @param eventListener An event listener.
-   * @param extensionRendererMode The extension renderer mode.
    * @param out An array to which the built renderers should be appended.
    */
-  protected void buildAudioRenderers(Context context,
+  protected void buildAudioRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-      AudioProcessor[] audioProcessors, Handler eventHandler,
-      AudioRendererEventListener eventListener, @ExtensionRendererMode int extensionRendererMode,
+      boolean playClearSamplesWithoutKeys,
+      AudioProcessor[] audioProcessors,
+      Handler eventHandler,
+      AudioRendererEventListener eventListener,
       ArrayList<Renderer> out) {
     out.add(
         new MediaCodecAudioRenderer(
             context,
-            MediaCodecSelector.DEFAULT,
+            mediaCodecSelector,
             drmSessionManager,
-            /* playClearSamplesWithoutKeys= */ false,
+            playClearSamplesWithoutKeys,
             eventHandler,
             eventListener,
             AudioCapabilities.getCapabilities(context),
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 81f4285a08..6c2a6f527c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -97,7 +97,8 @@ public static SimpleExoPlayer newSimpleInstance(
       LoadControl loadControl,
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode) {
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context, extensionRendererMode);
+    RenderersFactory renderersFactory =
+        new DefaultRenderersFactory(context).setExtensionRendererMode(extensionRendererMode);
     return newSimpleInstance(
         context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
@@ -127,7 +128,9 @@ public static SimpleExoPlayer newSimpleInstance(
       @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode,
       long allowedVideoJoiningTimeMs) {
     RenderersFactory renderersFactory =
-        new DefaultRenderersFactory(context, extensionRendererMode, allowedVideoJoiningTimeMs);
+        new DefaultRenderersFactory(context)
+            .setExtensionRendererMode(extensionRendererMode)
+            .setAllowedVideoJoiningTimeMs(allowedVideoJoiningTimeMs);
     return newSimpleInstance(
         context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 35fa85e467..de6e867514 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -138,7 +138,6 @@ public void handleMessage(Message msg) {
             repeatMode,
             shuffleModeEnabled,
             eventHandler,
-            this,
             clock);
     internalPlayerHandler = new Handler(internalPlayer.getPlaybackLooper());
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 7f41719d1d..c31c6b75a5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -93,7 +93,6 @@
   private final HandlerWrapper handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
-  private final ExoPlayer player;
   private final Timeline.Window window;
   private final Timeline.Period period;
   private final long backBufferDurationUs;
@@ -131,7 +130,6 @@ public ExoPlayerImplInternal(
       @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled,
       Handler eventHandler,
-      ExoPlayer player,
       Clock clock) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
@@ -142,7 +140,6 @@ public ExoPlayerImplInternal(
     this.repeatMode = repeatMode;
     this.shuffleModeEnabled = shuffleModeEnabled;
     this.eventHandler = eventHandler;
-    this.player = player;
     this.clock = clock;
     this.queue = new MediaPeriodQueue();
 
@@ -398,11 +395,7 @@ private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boo
     loadControl.onPrepared();
     this.mediaSource = mediaSource;
     setState(Player.STATE_BUFFERING);
-    mediaSource.prepareSource(
-        player,
-        /* isTopLevelSource= */ true,
-        /* listener= */ this,
-        bandwidthMeter.getTransferListener());
+    mediaSource.prepareSource(/* listener= */ this, bandwidthMeter.getTransferListener());
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index 36723c5d73..b389ec742f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.9.4";
+  public static final String VERSION = "2.9.6";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.4";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.6";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2009004;
+  public static final int VERSION_INT = 2009006;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 429510bcaf..7ee25d07d1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -419,7 +419,7 @@ public void configure(
     isInputPcm = Util.isEncodingLinearPcm(inputEncoding);
     shouldConvertHighResIntPcmToFloat =
         enableConvertHighResIntPcmToFloat
-            && supportsOutput(channelCount, C.ENCODING_PCM_32BIT)
+            && supportsOutput(channelCount, C.ENCODING_PCM_FLOAT)
             && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
     if (isInputPcm) {
       pcmFrameSize = Util.getPcmFrameSize(inputEncoding, channelCount);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 0f1fd8f649..d7ed1c0c5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -591,6 +591,14 @@ private void onEmsgLeafAtomRead(ParsableByteArray atom) {
     long presentationTimeDeltaUs =
         Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
 
+    // The presentation_time_delta is accounted for by adjusting the sample timestamp, so we zero it
+    // in the sample data before writing it to the track outputs.
+    int position = atom.getPosition();
+    atom.data[position - 4] = 0;
+    atom.data[position - 3] = 0;
+    atom.data[position - 2] = 0;
+    atom.data[position - 1] = 0;
+
     // Output the sample data.
     for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
       atom.setPosition(Atom.FULL_HEADER_SIZE);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index a5506e2cfb..88805d9362 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -50,7 +50,8 @@
         FLAG_IGNORE_H264_STREAM,
         FLAG_DETECT_ACCESS_UNITS,
         FLAG_IGNORE_SPLICE_INFO_STREAM,
-        FLAG_OVERRIDE_CAPTION_DESCRIPTORS
+        FLAG_OVERRIDE_CAPTION_DESCRIPTORS,
+        FLAG_IGNORE_HDMV_DTS_STREAM
       })
   public @interface Flags {}
 
@@ -86,6 +87,12 @@
    * closedCaptionFormats} will be ignored if the PMT contains closed captions service descriptors.
    */
   public static final int FLAG_OVERRIDE_CAPTION_DESCRIPTORS = 1 << 5;
+  /**
+   * Prevents the creation of {@link DtsReader} instances when receiving {@link
+   * TsExtractor#TS_STREAM_TYPE_HDMV_DTS} as stream type. Enabling this flag prevents a stream type
+   * collision between HDMV DTS audio and SCTE-35 subtitles.
+   */
+  public static final int FLAG_IGNORE_HDMV_DTS_STREAM = 1 << 6;
 
   private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
 
@@ -142,8 +149,12 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_AC3:
       case TsExtractor.TS_STREAM_TYPE_E_AC3:
         return new PesReader(new Ac3Reader(esInfo.language));
-      case TsExtractor.TS_STREAM_TYPE_DTS:
       case TsExtractor.TS_STREAM_TYPE_HDMV_DTS:
+        if (isSet(FLAG_IGNORE_HDMV_DTS_STREAM)) {
+          return null;
+        }
+        // Fall through.
+      case TsExtractor.TS_STREAM_TYPE_DTS:
         return new PesReader(new DtsReader(esInfo.language));
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader(buildUserDataReader(esInfo)));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 9ae50179c3..f09cae9949 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -59,8 +59,6 @@ private DecoderQueryException(Throwable cause) {
 
   private static final String TAG = "MediaCodecUtil";
   private static final Pattern PROFILE_PATTERN = Pattern.compile("^\\D?(\\d+)$");
-  private static final RawAudioCodecComparator RAW_AUDIO_CODEC_COMPARATOR =
-      new RawAudioCodecComparator();
 
   private static final HashMap<CodecKey, List<MediaCodecInfo>> decoderInfosCache = new HashMap<>();
 
@@ -312,32 +310,6 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
       return false;
     }
 
-    // Work around https://github.com/google/ExoPlayer/issues/398.
-    if (Util.SDK_INT < 18 && "OMX.SEC.MP3.Decoder".equals(name)) {
-      return false;
-    }
-
-    // Work around https://github.com/google/ExoPlayer/issues/4519.
-    if ("OMX.SEC.mp3.dec".equals(name)
-        && (Util.MODEL.startsWith("GT-I9152")
-            || Util.MODEL.startsWith("GT-I9515")
-            || Util.MODEL.startsWith("GT-P5220")
-            || Util.MODEL.startsWith("GT-S7580")
-            || Util.MODEL.startsWith("SM-G350")
-            || Util.MODEL.startsWith("SM-G386")
-            || Util.MODEL.startsWith("SM-T231")
-            || Util.MODEL.startsWith("SM-T530")
-            || Util.MODEL.startsWith("SCH-I535")
-            || Util.MODEL.startsWith("SPH-L710"))) {
-      return false;
-    }
-    if ("OMX.brcm.audio.mp3.decoder".equals(name)
-        && (Util.MODEL.startsWith("GT-I9152")
-            || Util.MODEL.startsWith("GT-S7580")
-            || Util.MODEL.startsWith("SM-G350"))) {
-      return false;
-    }
-
     // Work around https://github.com/google/ExoPlayer/issues/1528 and
     // https://github.com/google/ExoPlayer/issues/3171.
     if (Util.SDK_INT < 18 && "OMX.MTK.AUDIO.DECODER.AAC".equals(name)
@@ -424,7 +396,18 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
    */
   private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decoderInfos) {
     if (MimeTypes.AUDIO_RAW.equals(mimeType)) {
-      Collections.sort(decoderInfos, RAW_AUDIO_CODEC_COMPARATOR);
+      Collections.sort(decoderInfos, new RawAudioCodecComparator());
+    } else if (Util.SDK_INT < 21 && decoderInfos.size() > 1) {
+      String firstCodecName = decoderInfos.get(0).name;
+      if ("OMX.SEC.mp3.dec".equals(firstCodecName)
+          || "OMX.SEC.MP3.Decoder".equals(firstCodecName)
+          || "OMX.brcm.audio.mp3.decoder".equals(firstCodecName)) {
+        // Prefer OMX.google codecs over OMX.SEC.mp3.dec, OMX.SEC.MP3.Decoder and
+        // OMX.brcm.audio.mp3.decoder on older devices. See:
+        // https://github.com/google/ExoPlayer/issues/398 and
+        // https://github.com/google/ExoPlayer/issues/4519.
+        Collections.sort(decoderInfos, new PreferOmxGoogleCodecComparator());
+      }
     }
   }
 
@@ -730,6 +713,18 @@ private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
     }
   }
 
+  /** Comparator for preferring OMX.google media codecs. */
+  private static final class PreferOmxGoogleCodecComparator implements Comparator<MediaCodecInfo> {
+    @Override
+    public int compare(MediaCodecInfo a, MediaCodecInfo b) {
+      return scoreMediaCodecInfo(a) - scoreMediaCodecInfo(b);
+    }
+
+    private static int scoreMediaCodecInfo(MediaCodecInfo mediaCodecInfo) {
+      return mediaCodecInfo.name.startsWith("OMX.google") ? -1 : 0;
+    }
+  }
+
   static {
     AVC_PROFILE_NUMBER_TO_CONST = new SparseIntArray();
     AVC_PROFILE_NUMBER_TO_CONST.put(66, CodecProfileLevel.AVCProfileBaseline);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index 7d70d9de1c..8a3467e2ed 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -44,13 +44,6 @@
    */
   public final long durationMs;
 
-  /**
-   * The presentation time value of this event message in microseconds.
-   * <p>
-   * Except in special cases, application code should <em>not</em> use this field.
-   */
-  public final long presentationTimeUs;
-
   /**
    * The instance identifier.
    */
@@ -70,22 +63,19 @@
    * @param durationMs The duration of the event in milliseconds.
    * @param id The instance identifier.
    * @param messageData The body of the message.
-   * @param presentationTimeUs The presentation time value of this event message in microseconds.
    */
-  public EventMessage(String schemeIdUri, String value, long durationMs, long id,
-      byte[] messageData, long presentationTimeUs) {
+  public EventMessage(
+      String schemeIdUri, String value, long durationMs, long id, byte[] messageData) {
     this.schemeIdUri = schemeIdUri;
     this.value = value;
     this.durationMs = durationMs;
     this.id = id;
     this.messageData = messageData;
-    this.presentationTimeUs = presentationTimeUs;
   }
 
   /* package */ EventMessage(Parcel in) {
     schemeIdUri = castNonNull(in.readString());
     value = castNonNull(in.readString());
-    presentationTimeUs = in.readLong();
     durationMs = in.readLong();
     id = in.readLong();
     messageData = castNonNull(in.createByteArray());
@@ -97,7 +87,6 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
       result = 31 * result + (value != null ? value.hashCode() : 0);
-      result = 31 * result + (int) (presentationTimeUs ^ (presentationTimeUs >>> 32));
       result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
       result = 31 * result + (int) (id ^ (id >>> 32));
       result = 31 * result + Arrays.hashCode(messageData);
@@ -115,9 +104,11 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     EventMessage other = (EventMessage) obj;
-    return presentationTimeUs == other.presentationTimeUs && durationMs == other.durationMs
-        && id == other.id && Util.areEqual(schemeIdUri, other.schemeIdUri)
-        && Util.areEqual(value, other.value) && Arrays.equals(messageData, other.messageData);
+    return durationMs == other.durationMs
+        && id == other.id
+        && Util.areEqual(schemeIdUri, other.schemeIdUri)
+        && Util.areEqual(value, other.value)
+        && Arrays.equals(messageData, other.messageData);
   }
 
   @Override
@@ -136,7 +127,6 @@ public int describeContents() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(schemeIdUri);
     dest.writeString(value);
-    dest.writeLong(presentationTimeUs);
     dest.writeLong(durationMs);
     dest.writeLong(id);
     dest.writeByteArray(messageData);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index 14f678374c..33d79917eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,11 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
@@ -27,12 +27,15 @@
 
 /**
  * Decodes Event Message (emsg) atoms, as defined in ISO/IEC 23009-1:2014, Section 5.10.3.3.
- * <p>
- * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
- * first byte of the scheme_id_uri field).
+ *
+ * <p>Atom data should be provided to the decoder without the full atom header (i.e. starting from
+ * the first byte of the scheme_id_uri field). It is expected that the presentation_time_delta field
+ * should be 0, having already been accounted for by adjusting the sample timestamp.
  */
 public final class EventMessageDecoder implements MetadataDecoder {
 
+  private static final String TAG = "EventMessageDecoder";
+
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
   public Metadata decode(MetadataInputBuffer inputBuffer) {
@@ -43,13 +46,16 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
     String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
     String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
     long timescale = emsgData.readUnsignedInt();
-    long presentationTimeUs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(),
-        C.MICROS_PER_SECOND, timescale);
+    long presentationTimeDelta = emsgData.readUnsignedInt();
+    if (presentationTimeDelta != 0) {
+      // We expect the source to have accounted for presentation_time_delta by adjusting the sample
+      // timestamp and zeroing the field in the sample data. Log a warning if the field is non-zero.
+      Log.w(TAG, "Ignoring non-zero presentation_time_delta: " + presentationTimeDelta);
+    }
     long durationMs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(), 1000, timescale);
     long id = emsgData.readUnsignedInt();
     byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
-    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData,
-        presentationTimeUs));
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
index eca498a6df..22708a8448 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
@@ -16,9 +16,6 @@
 package com.google.android.exoplayer2.metadata.emsg;
 
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -37,27 +34,22 @@ public EventMessageEncoder() {
   }
 
   /**
-   * Encodes an {@link EventMessage} to a byte array that can be decoded by
-   * {@link EventMessageDecoder}.
+   * Encodes an {@link EventMessage} to a byte array that can be decoded by {@link
+   * EventMessageDecoder}.
    *
    * @param eventMessage The event message to be encoded.
-   * @param timescale Timescale of the event message, in units per second.
    * @return The serialized byte array.
    */
   @Nullable
-  public byte[] encode(EventMessage eventMessage, long timescale) {
-    Assertions.checkArgument(timescale >= 0);
+  public byte[] encode(EventMessage eventMessage) {
     byteArrayOutputStream.reset();
     try {
       writeNullTerminatedString(dataOutputStream, eventMessage.schemeIdUri);
       String nonNullValue = eventMessage.value != null ? eventMessage.value : "";
       writeNullTerminatedString(dataOutputStream, nonNullValue);
-      writeUnsignedInt(dataOutputStream, timescale);
-      long presentationTime = Util.scaleLargeTimestamp(eventMessage.presentationTimeUs,
-          timescale, C.MICROS_PER_SECOND);
-      writeUnsignedInt(dataOutputStream, presentationTime);
-      long duration = Util.scaleLargeTimestamp(eventMessage.durationMs, timescale, 1000);
-      writeUnsignedInt(dataOutputStream, duration);
+      writeUnsignedInt(dataOutputStream, 1000); // timescale
+      writeUnsignedInt(dataOutputStream, 0); // presentation_time_delta
+      writeUnsignedInt(dataOutputStream, eventMessage.durationMs);
       writeUnsignedInt(dataOutputStream, eventMessage.id);
       dataOutputStream.write(eventMessage.messageData);
       dataOutputStream.flush();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
index 2feac2978e..189467b47e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/BaseMediaSource.java
@@ -16,8 +16,8 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -35,9 +35,9 @@
   private final ArrayList<SourceInfoRefreshListener> sourceInfoListeners;
   private final MediaSourceEventListener.EventDispatcher eventDispatcher;
 
-  private @Nullable ExoPlayer player;
-  private @Nullable Timeline timeline;
-  private @Nullable Object manifest;
+  @Nullable private Looper looper;
+  @Nullable private Timeline timeline;
+  @Nullable private Object manifest;
 
   public BaseMediaSource() {
     sourceInfoListeners = new ArrayList<>(/* initialCapacity= */ 1);
@@ -48,21 +48,16 @@ public BaseMediaSource() {
    * Starts source preparation. This method is called at most once until the next call to {@link
    * #releaseSourceInternal()}.
    *
-   * @param player The player for which this source is being prepared.
-   * @param isTopLevelSource Whether this source has been passed directly to {@link
-   *     ExoPlayer#prepare(MediaSource)} or {@link ExoPlayer#prepare(MediaSource, boolean,
-   *     boolean)}.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
    *     transfers. May be null if no listener is available. Note that this listener should usually
    *     be only informed of transfers related to the media loads and not of auxiliary loads for
    *     manifests and other data.
    */
-  protected abstract void prepareSourceInternal(
-      ExoPlayer player, boolean isTopLevelSource, @Nullable TransferListener mediaTransferListener);
+  protected abstract void prepareSourceInternal(@Nullable TransferListener mediaTransferListener);
 
   /**
    * Releases the source. This method is called exactly once after each call to {@link
-   * #prepareSourceInternal(ExoPlayer, boolean, TransferListener)}.
+   * #prepareSourceInternal(TransferListener)}.
    */
   protected abstract void releaseSourceInternal();
 
@@ -135,21 +130,14 @@ public final void removeEventListener(MediaSourceEventListener eventListener) {
 
   @Override
   public final void prepareSource(
-      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener) {
-    prepareSource(player, isTopLevelSource, listener, /* mediaTransferListener= */ null);
-  }
-
-  @Override
-  public final void prepareSource(
-      ExoPlayer player,
-      boolean isTopLevelSource,
       SourceInfoRefreshListener listener,
       @Nullable TransferListener mediaTransferListener) {
-    Assertions.checkArgument(this.player == null || this.player == player);
+    Looper looper = Looper.myLooper();
+    Assertions.checkArgument(this.looper == null || this.looper == looper);
     sourceInfoListeners.add(listener);
-    if (this.player == null) {
-      this.player = player;
-      prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+    if (this.looper == null) {
+      this.looper = looper;
+      prepareSourceInternal(mediaTransferListener);
     } else if (timeline != null) {
       listener.onSourceInfoRefreshed(/* source= */ this, timeline, manifest);
     }
@@ -159,7 +147,7 @@ public final void prepareSource(
   public final void releaseSource(SourceInfoRefreshListener listener) {
     sourceInfoListeners.remove(listener);
     if (sourceInfoListeners.isEmpty()) {
-      player = null;
+      looper = null;
       timeline = null;
       manifest = null;
       releaseSourceInternal();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index fce1c4b877..d5399dc02d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -18,7 +18,6 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -223,11 +222,8 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     prepareChildSource(/* id= */ null, mediaSource);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
index 69fa4b094b..dbf5812f98 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -18,7 +18,6 @@
 import android.os.Handler;
 import android.support.annotation.CallSuper;
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
@@ -35,7 +34,6 @@
 
   private final HashMap<T, MediaSourceAndListener> childSources;
 
-  private @Nullable ExoPlayer player;
   private @Nullable Handler eventHandler;
   private @Nullable TransferListener mediaTransferListener;
 
@@ -46,11 +44,7 @@ protected CompositeMediaSource() {
 
   @Override
   @CallSuper
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    this.player = player;
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     eventHandler = new Handler();
   }
@@ -71,7 +65,6 @@ public void releaseSourceInternal() {
       childSource.mediaSource.removeEventListener(childSource.eventListener);
     }
     childSources.clear();
-    player = null;
   }
 
   /**
@@ -105,11 +98,7 @@ protected final void prepareChildSource(final T id, MediaSource mediaSource) {
     MediaSourceEventListener eventListener = new ForwardingEventListener(id);
     childSources.put(id, new MediaSourceAndListener(mediaSource, sourceListener, eventListener));
     mediaSource.addEventListener(Assertions.checkNotNull(eventHandler), eventListener);
-    mediaSource.prepareSource(
-        Assertions.checkNotNull(player),
-        /* isTopLevelSource= */ false,
-        sourceListener,
-        mediaTransferListener);
+    mediaSource.prepareSource(sourceListener, mediaTransferListener);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index c93afdb249..961aaf105f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -17,11 +17,11 @@
 
 import android.os.Handler;
 import android.os.Message;
+import android.support.annotation.GuardedBy;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
@@ -35,9 +35,11 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * Concatenates multiple {@link MediaSource}s. The list of {@link MediaSource}s can be modified
@@ -50,25 +52,31 @@
   private static final int MSG_REMOVE = 1;
   private static final int MSG_MOVE = 2;
   private static final int MSG_SET_SHUFFLE_ORDER = 3;
-  private static final int MSG_NOTIFY_LISTENER = 4;
+  private static final int MSG_UPDATE_TIMELINE = 4;
   private static final int MSG_ON_COMPLETION = 5;
 
-  // Accessed on the app thread.
+  // Accessed on any thread.
+  @GuardedBy("this")
   private final List<MediaSourceHolder> mediaSourcesPublic;
 
-  // Accessed on the playback thread.
+  @GuardedBy("this")
+  private final Set<HandlerAndRunnable> pendingOnCompletionActions;
+
+  @GuardedBy("this")
+  @Nullable
+  private Handler playbackThreadHandler;
+
+  // Accessed on the playback thread only.
   private final List<MediaSourceHolder> mediaSourceHolders;
   private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
   private final Map<Object, MediaSourceHolder> mediaSourceByUid;
-  private final List<Runnable> pendingOnCompletionActions;
   private final boolean isAtomic;
   private final boolean useLazyPreparation;
   private final Timeline.Window window;
   private final Timeline.Period period;
 
-  @Nullable private Handler playbackThreadHandler;
-  @Nullable private Handler applicationThreadHandler;
-  private boolean listenerNotificationScheduled;
+  private boolean timelineUpdateScheduled;
+  private Set<HandlerAndRunnable> nextTimelineUpdateOnCompletionActions;
   private ShuffleOrder shuffleOrder;
   private int windowCount;
   private int periodCount;
@@ -127,7 +135,8 @@ public ConcatenatingMediaSource(
     this.mediaSourceByUid = new HashMap<>();
     this.mediaSourcesPublic = new ArrayList<>();
     this.mediaSourceHolders = new ArrayList<>();
-    this.pendingOnCompletionActions = new ArrayList<>();
+    this.nextTimelineUpdateOnCompletionActions = new HashSet<>();
+    this.pendingOnCompletionActions = new HashSet<>();
     this.isAtomic = isAtomic;
     this.useLazyPreparation = useLazyPreparation;
     window = new Timeline.Window();
@@ -141,19 +150,20 @@ public ConcatenatingMediaSource(
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public final synchronized void addMediaSource(MediaSource mediaSource) {
-    addMediaSource(mediaSourcesPublic.size(), mediaSource, null);
+    addMediaSource(mediaSourcesPublic.size(), mediaSource);
   }
 
   /**
    * Appends a {@link MediaSource} to the playlist and executes a custom action on completion.
    *
    * @param mediaSource The {@link MediaSource} to be added to the list.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been added to the playlist.
    */
   public final synchronized void addMediaSource(
-      MediaSource mediaSource, @Nullable Runnable actionOnCompletion) {
-    addMediaSource(mediaSourcesPublic.size(), mediaSource, actionOnCompletion);
+      MediaSource mediaSource, Handler handler, Runnable onCompletionAction) {
+    addMediaSource(mediaSourcesPublic.size(), mediaSource, handler, onCompletionAction);
   }
 
   /**
@@ -164,7 +174,11 @@ public final synchronized void addMediaSource(
    * @param mediaSource The {@link MediaSource} to be added to the list.
    */
   public final synchronized void addMediaSource(int index, MediaSource mediaSource) {
-    addMediaSource(index, mediaSource, null);
+    addPublicMediaSources(
+        index,
+        Collections.singletonList(mediaSource),
+        /* handler= */ null,
+        /* onCompletionAction= */ null);
   }
 
   /**
@@ -173,12 +187,14 @@ public final synchronized void addMediaSource(int index, MediaSource mediaSource
    * @param index The index at which the new {@link MediaSource} will be inserted. This index must
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param mediaSource The {@link MediaSource} to be added to the list.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been added to the playlist.
    */
   public final synchronized void addMediaSource(
-      int index, MediaSource mediaSource, @Nullable Runnable actionOnCompletion) {
-    addMediaSources(index, Collections.singletonList(mediaSource), actionOnCompletion);
+      int index, MediaSource mediaSource, Handler handler, Runnable onCompletionAction) {
+    addPublicMediaSources(
+        index, Collections.singletonList(mediaSource), handler, onCompletionAction);
   }
 
   /**
@@ -188,7 +204,11 @@ public final synchronized void addMediaSource(
    *     sources are added in the order in which they appear in this collection.
    */
   public final synchronized void addMediaSources(Collection<MediaSource> mediaSources) {
-    addMediaSources(mediaSourcesPublic.size(), mediaSources, null);
+    addPublicMediaSources(
+        mediaSourcesPublic.size(),
+        mediaSources,
+        /* handler= */ null,
+        /* onCompletionAction= */ null);
   }
 
   /**
@@ -197,12 +217,13 @@ public final synchronized void addMediaSources(Collection<MediaSource> mediaSour
    *
    * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
    *     sources are added in the order in which they appear in this collection.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     sources have been added to the playlist.
    */
   public final synchronized void addMediaSources(
-      Collection<MediaSource> mediaSources, @Nullable Runnable actionOnCompletion) {
-    addMediaSources(mediaSourcesPublic.size(), mediaSources, actionOnCompletion);
+      Collection<MediaSource> mediaSources, Handler handler, Runnable onCompletionAction) {
+    addPublicMediaSources(mediaSourcesPublic.size(), mediaSources, handler, onCompletionAction);
   }
 
   /**
@@ -214,7 +235,7 @@ public final synchronized void addMediaSources(
    *     sources are added in the order in which they appear in this collection.
    */
   public final synchronized void addMediaSources(int index, Collection<MediaSource> mediaSources) {
-    addMediaSources(index, mediaSources, null);
+    addPublicMediaSources(index, mediaSources, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -224,26 +245,16 @@ public final synchronized void addMediaSources(int index, Collection<MediaSource
    *     be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param mediaSources A collection of {@link MediaSource}s to be added to the list. The media
    *     sources are added in the order in which they appear in this collection.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     sources have been added to the playlist.
    */
   public final synchronized void addMediaSources(
-      int index, Collection<MediaSource> mediaSources, @Nullable Runnable actionOnCompletion) {
-    for (MediaSource mediaSource : mediaSources) {
-      Assertions.checkNotNull(mediaSource);
-    }
-    List<MediaSourceHolder> mediaSourceHolders = new ArrayList<>(mediaSources.size());
-    for (MediaSource mediaSource : mediaSources) {
-      mediaSourceHolders.add(new MediaSourceHolder(mediaSource));
-    }
-    mediaSourcesPublic.addAll(index, mediaSourceHolders);
-    if (playbackThreadHandler != null && !mediaSources.isEmpty()) {
-      playbackThreadHandler
-          .obtainMessage(MSG_ADD, new MessageData<>(index, mediaSourceHolders, actionOnCompletion))
-          .sendToTarget();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int index,
+      Collection<MediaSource> mediaSources,
+      Handler handler,
+      Runnable onCompletionAction) {
+    addPublicMediaSources(index, mediaSources, handler, onCompletionAction);
   }
 
   /**
@@ -259,26 +270,27 @@ public final synchronized void addMediaSources(
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public final synchronized void removeMediaSource(int index) {
-    removeMediaSource(index, null);
+    removePublicMediaSources(index, index + 1, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
    * Removes a {@link MediaSource} from the playlist and executes a custom action on completion.
    *
    * <p>Note: If you want to move the instance, it's preferable to use {@link #moveMediaSource(int,
-   * int, Runnable)} instead.
+   * int, Handler, Runnable)} instead.
    *
    * <p>Note: If you want to remove a set of contiguous sources, it's preferable to use {@link
-   * #removeMediaSourceRange(int, int, Runnable)} instead.
+   * #removeMediaSourceRange(int, int, Handler, Runnable)} instead.
    *
    * @param index The index at which the media source will be removed. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been removed from the playlist.
    */
   public final synchronized void removeMediaSource(
-      int index, @Nullable Runnable actionOnCompletion) {
-    removeMediaSourceRange(index, index + 1, actionOnCompletion);
+      int index, Handler handler, Runnable onCompletionAction) {
+    removePublicMediaSources(index, index + 1, handler, onCompletionAction);
   }
 
   /**
@@ -296,7 +308,8 @@ public final synchronized void removeMediaSource(
    *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
    */
   public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex) {
-    removeMediaSourceRange(fromIndex, toIndex, null);
+    removePublicMediaSources(
+        fromIndex, toIndex, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -310,27 +323,15 @@ public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex
    *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
    * @param toIndex The final range index, pointing to the first media source that will be left
    *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source range has been removed from the playlist.
    * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
    *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
    */
   public final synchronized void removeMediaSourceRange(
-      int fromIndex, int toIndex, @Nullable Runnable actionOnCompletion) {
-    Util.removeRange(mediaSourcesPublic, fromIndex, toIndex);
-    if (fromIndex == toIndex) {
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-      return;
-    }
-    if (playbackThreadHandler != null) {
-      playbackThreadHandler
-          .obtainMessage(MSG_REMOVE, new MessageData<>(fromIndex, toIndex, actionOnCompletion))
-          .sendToTarget();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int fromIndex, int toIndex, Handler handler, Runnable onCompletionAction) {
+    removePublicMediaSources(fromIndex, toIndex, handler, onCompletionAction);
   }
 
   /**
@@ -342,7 +343,8 @@ public final synchronized void removeMediaSourceRange(
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
    */
   public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
-    moveMediaSource(currentIndex, newIndex, null);
+    movePublicMediaSource(
+        currentIndex, newIndex, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
@@ -353,40 +355,29 @@ public final synchronized void moveMediaSource(int currentIndex, int newIndex) {
    *     in the range of 0 &lt;= index &lt; {@link #getSize()}.
    * @param newIndex The target index of the media source in the playlist. This index must be in the
    *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the media
    *     source has been moved.
    */
   public final synchronized void moveMediaSource(
-      int currentIndex, int newIndex, @Nullable Runnable actionOnCompletion) {
-    if (currentIndex == newIndex) {
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-      return;
-    }
-    mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
-    if (playbackThreadHandler != null) {
-      playbackThreadHandler
-          .obtainMessage(MSG_MOVE, new MessageData<>(currentIndex, newIndex, actionOnCompletion))
-          .sendToTarget();
-    } else if (actionOnCompletion != null) {
-      actionOnCompletion.run();
-    }
+      int currentIndex, int newIndex, Handler handler, Runnable onCompletionAction) {
+    movePublicMediaSource(currentIndex, newIndex, handler, onCompletionAction);
   }
 
   /** Clears the playlist. */
   public final synchronized void clear() {
-    clear(/* actionOnCompletion= */ null);
+    removeMediaSourceRange(0, getSize());
   }
 
   /**
    * Clears the playlist and executes a custom action on completion.
    *
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the playlist
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the playlist
    *     has been cleared.
    */
-  public final synchronized void clear(@Nullable Runnable actionOnCompletion) {
-    removeMediaSourceRange(0, getSize(), actionOnCompletion);
+  public final synchronized void clear(Handler handler, Runnable onCompletionAction) {
+    removeMediaSourceRange(0, getSize(), handler, onCompletionAction);
   }
 
   /** Returns the number of media sources in the playlist. */
@@ -410,41 +401,24 @@ public final synchronized MediaSource getMediaSource(int index) {
    * @param shuffleOrder A {@link ShuffleOrder}.
    */
   public final synchronized void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    setShuffleOrder(shuffleOrder, /* actionOnCompletion= */ null);
+    setPublicShuffleOrder(shuffleOrder, /* handler= */ null, /* onCompletionAction= */ null);
   }
 
   /**
    * Sets a new shuffle order to use when shuffling the child media sources.
    *
    * @param shuffleOrder A {@link ShuffleOrder}.
-   * @param actionOnCompletion A {@link Runnable} which is executed immediately after the shuffle
+   * @param handler The {@link Handler} to run {@code onCompletionAction}.
+   * @param onCompletionAction A {@link Runnable} which is executed immediately after the shuffle
    *     order has been changed.
    */
   public final synchronized void setShuffleOrder(
-      ShuffleOrder shuffleOrder, @Nullable Runnable actionOnCompletion) {
-    Handler playbackThreadHandler = this.playbackThreadHandler;
-    if (playbackThreadHandler != null) {
-      int size = getSize();
-      if (shuffleOrder.getLength() != size) {
-        shuffleOrder =
-            shuffleOrder
-                .cloneAndClear()
-                .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
-      }
-      playbackThreadHandler
-          .obtainMessage(
-              MSG_SET_SHUFFLE_ORDER,
-              new MessageData<>(/* index= */ 0, shuffleOrder, actionOnCompletion))
-          .sendToTarget();
-    } else {
-      this.shuffleOrder =
-          shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
-      if (actionOnCompletion != null) {
-        actionOnCompletion.run();
-      }
-    }
+      ShuffleOrder shuffleOrder, Handler handler, Runnable onCompletionAction) {
+    setPublicShuffleOrder(shuffleOrder, handler, onCompletionAction);
   }
 
+  // CompositeMediaSource implementation.
+
   @Override
   @Nullable
   public Object getTag() {
@@ -453,18 +427,15 @@ public Object getTag() {
 
   @Override
   public final synchronized void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
       @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+    super.prepareSourceInternal(mediaTransferListener);
     playbackThreadHandler = new Handler(/* callback= */ this::handleMessage);
-    applicationThreadHandler = new Handler(player.getApplicationLooper());
     if (mediaSourcesPublic.isEmpty()) {
-      notifyListener();
+      updateTimelineAndScheduleOnCompletionActions();
     } else {
       shuffleOrder = shuffleOrder.cloneAndInsert(0, mediaSourcesPublic.size());
       addMediaSourcesInternal(0, mediaSourcesPublic);
-      scheduleListenerNotification(/* actionOnCompletion= */ null);
+      scheduleTimelineUpdate();
     }
   }
 
@@ -509,15 +480,20 @@ public final void releasePeriod(MediaPeriod mediaPeriod) {
   }
 
   @Override
-  public final void releaseSourceInternal() {
+  public final synchronized void releaseSourceInternal() {
     super.releaseSourceInternal();
     mediaSourceHolders.clear();
     mediaSourceByUid.clear();
-    playbackThreadHandler = null;
-    applicationThreadHandler = null;
     shuffleOrder = shuffleOrder.cloneAndClear();
     windowCount = 0;
     periodCount = 0;
+    if (playbackThreadHandler != null) {
+      playbackThreadHandler.removeCallbacksAndMessages(null);
+      playbackThreadHandler = null;
+    }
+    timelineUpdateScheduled = false;
+    nextTimelineUpdateOnCompletionActions.clear();
+    dispatchOnCompletionActions(pendingOnCompletionActions);
   }
 
   @Override
@@ -550,19 +526,123 @@ protected int getWindowIndexForChildWindowIndex(
     return windowIndex + mediaSourceHolder.firstWindowIndexInChild;
   }
 
+  // Internal methods. Called from any thread.
+
+  @GuardedBy("this")
+  private void addPublicMediaSources(
+      int index,
+      Collection<MediaSource> mediaSources,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    for (MediaSource mediaSource : mediaSources) {
+      Assertions.checkNotNull(mediaSource);
+    }
+    List<MediaSourceHolder> mediaSourceHolders = new ArrayList<>(mediaSources.size());
+    for (MediaSource mediaSource : mediaSources) {
+      mediaSourceHolders.add(new MediaSourceHolder(mediaSource));
+    }
+    mediaSourcesPublic.addAll(index, mediaSourceHolders);
+    if (playbackThreadHandler != null && !mediaSources.isEmpty()) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_ADD, new MessageData<>(index, mediaSourceHolders, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void removePublicMediaSources(
+      int fromIndex,
+      int toIndex,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    Util.removeRange(mediaSourcesPublic, fromIndex, toIndex);
+    if (playbackThreadHandler != null) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_REMOVE, new MessageData<>(fromIndex, toIndex, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void movePublicMediaSource(
+      int currentIndex,
+      int newIndex,
+      @Nullable Handler handler,
+      @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
+    if (playbackThreadHandler != null) {
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(MSG_MOVE, new MessageData<>(currentIndex, newIndex, callbackAction))
+          .sendToTarget();
+    } else if (onCompletionAction != null && handler != null) {
+      handler.post(onCompletionAction);
+    }
+  }
+
+  @GuardedBy("this")
+  private void setPublicShuffleOrder(
+      ShuffleOrder shuffleOrder, @Nullable Handler handler, @Nullable Runnable onCompletionAction) {
+    Assertions.checkArgument((handler == null) == (onCompletionAction == null));
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    if (playbackThreadHandler != null) {
+      int size = getSize();
+      if (shuffleOrder.getLength() != size) {
+        shuffleOrder =
+            shuffleOrder
+                .cloneAndClear()
+                .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
+      }
+      HandlerAndRunnable callbackAction = createOnCompletionAction(handler, onCompletionAction);
+      playbackThreadHandler
+          .obtainMessage(
+              MSG_SET_SHUFFLE_ORDER,
+              new MessageData<>(/* index= */ 0, shuffleOrder, callbackAction))
+          .sendToTarget();
+    } else {
+      this.shuffleOrder =
+          shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
+      if (onCompletionAction != null && handler != null) {
+        handler.post(onCompletionAction);
+      }
+    }
+  }
+
+  @GuardedBy("this")
+  @Nullable
+  private HandlerAndRunnable createOnCompletionAction(
+      @Nullable Handler handler, @Nullable Runnable runnable) {
+    if (handler == null || runnable == null) {
+      return null;
+    }
+    HandlerAndRunnable handlerAndRunnable = new HandlerAndRunnable(handler, runnable);
+    pendingOnCompletionActions.add(handlerAndRunnable);
+    return handlerAndRunnable;
+  }
+
+  // Internal methods. Called on the playback thread.
+
   @SuppressWarnings("unchecked")
   private boolean handleMessage(Message msg) {
-    if (playbackThreadHandler == null) {
-      // Stale event.
-      return false;
-    }
     switch (msg.what) {
       case MSG_ADD:
         MessageData<Collection<MediaSourceHolder>> addMessage =
             (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndInsert(addMessage.index, addMessage.customData.size());
         addMediaSourcesInternal(addMessage.index, addMessage.customData);
-        scheduleListenerNotification(addMessage.actionOnCompletion);
+        scheduleTimelineUpdate(addMessage.onCompletionAction);
         break;
       case MSG_REMOVE:
         MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
@@ -576,30 +656,27 @@ private boolean handleMessage(Message msg) {
         for (int index = toIndex - 1; index >= fromIndex; index--) {
           removeMediaSourceInternal(index);
         }
-        scheduleListenerNotification(removeMessage.actionOnCompletion);
+        scheduleTimelineUpdate(removeMessage.onCompletionAction);
         break;
       case MSG_MOVE:
         MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index, moveMessage.index + 1);
         shuffleOrder = shuffleOrder.cloneAndInsert(moveMessage.customData, 1);
         moveMediaSourceInternal(moveMessage.index, moveMessage.customData);
-        scheduleListenerNotification(moveMessage.actionOnCompletion);
+        scheduleTimelineUpdate(moveMessage.onCompletionAction);
         break;
       case MSG_SET_SHUFFLE_ORDER:
         MessageData<ShuffleOrder> shuffleOrderMessage =
             (MessageData<ShuffleOrder>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrderMessage.customData;
-        scheduleListenerNotification(shuffleOrderMessage.actionOnCompletion);
+        scheduleTimelineUpdate(shuffleOrderMessage.onCompletionAction);
         break;
-      case MSG_NOTIFY_LISTENER:
-        notifyListener();
+      case MSG_UPDATE_TIMELINE:
+        updateTimelineAndScheduleOnCompletionActions();
         break;
       case MSG_ON_COMPLETION:
-        List<Runnable> actionsOnCompletion = (List<Runnable>) Util.castNonNull(msg.obj);
-        Handler handler = Assertions.checkNotNull(applicationThreadHandler);
-        for (int i = 0; i < actionsOnCompletion.size(); i++) {
-          handler.post(actionsOnCompletion.get(i));
-        }
+        Set<HandlerAndRunnable> actions = (Set<HandlerAndRunnable>) Util.castNonNull(msg.obj);
+        dispatchOnCompletionActions(actions);
         break;
       default:
         throw new IllegalStateException();
@@ -607,34 +684,46 @@ private boolean handleMessage(Message msg) {
     return true;
   }
 
-  private void scheduleListenerNotification(@Nullable Runnable actionOnCompletion) {
-    if (!listenerNotificationScheduled) {
-      Assertions.checkNotNull(playbackThreadHandler)
-          .obtainMessage(MSG_NOTIFY_LISTENER)
-          .sendToTarget();
-      listenerNotificationScheduled = true;
+  private void scheduleTimelineUpdate() {
+    scheduleTimelineUpdate(/* onCompletionAction= */ null);
+  }
+
+  private void scheduleTimelineUpdate(@Nullable HandlerAndRunnable onCompletionAction) {
+    if (!timelineUpdateScheduled) {
+      getPlaybackThreadHandlerOnPlaybackThread().obtainMessage(MSG_UPDATE_TIMELINE).sendToTarget();
+      timelineUpdateScheduled = true;
     }
-    if (actionOnCompletion != null) {
-      pendingOnCompletionActions.add(actionOnCompletion);
+    if (onCompletionAction != null) {
+      nextTimelineUpdateOnCompletionActions.add(onCompletionAction);
     }
   }
 
-  private void notifyListener() {
-    listenerNotificationScheduled = false;
-    List<Runnable> actionsOnCompletion =
-        pendingOnCompletionActions.isEmpty()
-            ? Collections.emptyList()
-            : new ArrayList<>(pendingOnCompletionActions);
-    pendingOnCompletionActions.clear();
+  private void updateTimelineAndScheduleOnCompletionActions() {
+    timelineUpdateScheduled = false;
+    Set<HandlerAndRunnable> onCompletionActions = nextTimelineUpdateOnCompletionActions;
+    nextTimelineUpdateOnCompletionActions = new HashSet<>();
     refreshSourceInfo(
         new ConcatenatedTimeline(
             mediaSourceHolders, windowCount, periodCount, shuffleOrder, isAtomic),
         /* manifest= */ null);
-    if (!actionsOnCompletion.isEmpty()) {
-      Assertions.checkNotNull(playbackThreadHandler)
-          .obtainMessage(MSG_ON_COMPLETION, actionsOnCompletion)
-          .sendToTarget();
+    getPlaybackThreadHandlerOnPlaybackThread()
+        .obtainMessage(MSG_ON_COMPLETION, onCompletionActions)
+        .sendToTarget();
+  }
+
+  @SuppressWarnings("GuardedBy")
+  private Handler getPlaybackThreadHandlerOnPlaybackThread() {
+    // Write access to this value happens on the playback thread only, so playback thread reads
+    // don't need to be synchronized.
+    return Assertions.checkNotNull(playbackThreadHandler);
+  }
+
+  private synchronized void dispatchOnCompletionActions(
+      Set<HandlerAndRunnable> onCompletionActions) {
+    for (HandlerAndRunnable pendingAction : onCompletionActions) {
+      pendingAction.dispatch();
     }
+    pendingOnCompletionActions.removeAll(onCompletionActions);
   }
 
   private void addMediaSourcesInternal(
@@ -733,7 +822,7 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
       }
     }
     mediaSourceHolder.isPrepared = true;
-    scheduleListenerNotification(/* actionOnCompletion= */ null);
+    scheduleTimelineUpdate();
   }
 
   private void removeMediaSourceInternal(int index) {
@@ -846,12 +935,12 @@ public int compareTo(@NonNull MediaSourceHolder other) {
 
     public final int index;
     public final T customData;
-    public final @Nullable Runnable actionOnCompletion;
+    @Nullable public final HandlerAndRunnable onCompletionAction;
 
-    public MessageData(int index, T customData, @Nullable Runnable actionOnCompletion) {
+    public MessageData(int index, T customData, @Nullable HandlerAndRunnable onCompletionAction) {
       this.index = index;
-      this.actionOnCompletion = actionOnCompletion;
       this.customData = customData;
+      this.onCompletionAction = onCompletionAction;
     }
   }
 
@@ -1071,10 +1160,7 @@ public Object getUidOfPeriod(int periodIndex) {
   private static final class DummyMediaSource extends BaseMediaSource {
 
     @Override
-    protected void prepareSourceInternal(
-        ExoPlayer player,
-        boolean isTopLevelSource,
-        @Nullable TransferListener mediaTransferListener) {
+    protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
       // Do nothing.
     }
 
@@ -1104,5 +1190,20 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
       // Do nothing.
     }
   }
+
+  private static final class HandlerAndRunnable {
+
+    private final Handler handler;
+    private final Runnable runnable;
+
+    public HandlerAndRunnable(Handler handler, Runnable runnable) {
+      this.handler = handler;
+      this.runnable = runnable;
+    }
+
+    public void dispatch() {
+      handler.post(runnable);
+    }
+  }
 }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 823901af2a..76a5428a12 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -346,10 +346,9 @@ public long getBufferedPositionUs() {
     } else if (isPendingReset()) {
       return pendingResetPositionUs;
     }
-    long largestQueuedTimestampUs = C.TIME_UNSET;
+    long largestQueuedTimestampUs = Long.MAX_VALUE;
     if (haveAudioVideoTracks) {
       // Ignore non-AV tracks, which may be sparse or poorly interleaved.
-      largestQueuedTimestampUs = Long.MAX_VALUE;
       int trackCount = sampleQueues.length;
       for (int i = 0; i < trackCount; i++) {
         if (trackIsAudioVideoFlags[i] && !sampleQueues[i].isLastSampleQueued()) {
@@ -358,7 +357,7 @@ public long getBufferedPositionUs() {
         }
       }
     }
-    if (largestQueuedTimestampUs == C.TIME_UNSET) {
+    if (largestQueuedTimestampUs == Long.MAX_VALUE) {
       largestQueuedTimestampUs = getLargestQueuedTimestampUs();
     }
     return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 9465a8f1a2..5403f9f33b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Handler;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -365,10 +364,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
     notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 281465eec3..e19a02b7b3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -31,7 +31,7 @@
  * Loops a {@link MediaSource} a specified number of times.
  *
  * <p>Note: To loop a {@link MediaSource} indefinitely, it is usually better to use {@link
- * ExoPlayer#setRepeatMode(int)}.
+ * ExoPlayer#setRepeatMode(int)} instead of this class.
  */
 public final class LoopingMediaSource extends CompositeMediaSource<Void> {
 
@@ -71,11 +71,8 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     prepareChildSource(/* id= */ null, childSource);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 801737faef..14f9a26245 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -25,23 +25,24 @@
 import java.io.IOException;
 
 /**
- * Defines and provides media to be played by an {@link ExoPlayer}. A MediaSource has two main
- * responsibilities:
+ * Defines and provides media to be played by an {@link com.google.android.exoplayer2.ExoPlayer}. A
+ * MediaSource has two main responsibilities:
  *
  * <ul>
  *   <li>To provide the player with a {@link Timeline} defining the structure of its media, and to
  *       provide a new timeline whenever the structure of the media changes. The MediaSource
  *       provides these timelines by calling {@link SourceInfoRefreshListener#onSourceInfoRefreshed}
- *       on the {@link SourceInfoRefreshListener}s passed to {@link #prepareSource(ExoPlayer,
- *       boolean, SourceInfoRefreshListener, TransferListener)}.
+ *       on the {@link SourceInfoRefreshListener}s passed to {@link
+ *       #prepareSource(SourceInfoRefreshListener, TransferListener)}.
  *   <li>To provide {@link MediaPeriod} instances for the periods in its timeline. MediaPeriods are
  *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator, long)}, and provide a
  *       way for the player to load and read the media.
  * </ul>
  *
  * All methods are called on the player's internal playback thread, as described in the {@link
- * ExoPlayer} Javadoc. They should not be called directly from application code. Instances can be
- * re-used, but only for one {@link ExoPlayer} instance simultaneously.
+ * com.google.android.exoplayer2.ExoPlayer} Javadoc. They should not be called directly from
+ * application code. Instances can be re-used, but only for one {@link
+ * com.google.android.exoplayer2.ExoPlayer} instance simultaneously.
  */
 public interface MediaSource {
 
@@ -226,11 +227,6 @@ default Object getTag() {
     return null;
   }
 
-  /** @deprecated Will be removed in the next release. */
-  @Deprecated
-  void prepareSource(
-      ExoPlayer player, boolean isTopLevelSource, SourceInfoRefreshListener listener);
-
   /**
    * Starts source preparation if not yet started, and adds a listener for timeline and/or manifest
    * updates.
@@ -242,11 +238,6 @@ void prepareSource(
    * <p>For each call to this method, a call to {@link #releaseSource(SourceInfoRefreshListener)} is
    * needed to remove the listener and to release the source if no longer required.
    *
-   * @param player The player for which this source is being prepared.
-   * @param isTopLevelSource Whether this source has been passed directly to {@link
-   *     ExoPlayer#prepare(MediaSource)} or {@link ExoPlayer#prepare(MediaSource, boolean,
-   *     boolean)}. If {@code false}, this source is being prepared by another source (e.g. {@link
-   *     ConcatenatingMediaSource}) for composition.
    * @param listener The listener to be added.
    * @param mediaTransferListener The transfer listener which should be informed of any media data
    *     transfers. May be null if no listener is available. Note that this listener should be only
@@ -254,10 +245,7 @@ void prepareSource(
    *     and other data.
    */
   void prepareSource(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      SourceInfoRefreshListener listener,
-      @Nullable TransferListener mediaTransferListener);
+      SourceInfoRefreshListener listener, @Nullable TransferListener mediaTransferListener);
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index cc7202f9b2..1ea3404e81 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -17,7 +17,6 @@
 
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -105,11 +104,8 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
     for (int i = 0; i < mediaSources.length; i++) {
       prepareChildSource(i, mediaSources[i]);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 046672bb77..c028a9e339 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -18,7 +18,6 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -304,10 +303,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
     refreshSourceInfo(timeline, /* manifest= */ null);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
index f041542356..b3054f69a0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer2.source.ads;
 
+import android.support.annotation.Nullable;
+import android.view.View;
 import android.view.ViewGroup;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource.AdLoadException;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.IOException;
@@ -25,27 +27,25 @@
 /**
  * Interface for loaders of ads, which can be used with {@link AdsMediaSource}.
  *
- * <p>Ad loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
+ * <p>Ads loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
  * particular, implementations must call {@link EventListener#onAdPlaybackState(AdPlaybackState)}
  * with a new copy of the current {@link AdPlaybackState} whenever further information about ads
  * becomes known (for example, when an ad media URI is available, or an ad has played to the end).
  *
- * <p>{@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} will be called when the ads media
- * source first initializes, at which point the loader can request ads. If the player enters the
- * background, {@link #detachPlayer()} will be called. Loaders should maintain any ad playback state
- * in preparation for a later call to {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. If
- * an ad is playing when the player is detached, update the ad playback state with the current
- * playback position using {@link AdPlaybackState#withAdResumePositionUs(long)}.
+ * <p>{@link #start(EventListener, AdViewProvider)} will be called when the ads media source first
+ * initializes, at which point the loader can request ads. If the player enters the background,
+ * {@link #stop()} will be called. Loaders should maintain any ad playback state in preparation for
+ * a later call to {@link #start(EventListener, AdViewProvider)}. If an ad is playing when the
+ * player is detached, update the ad playback state with the current playback position using {@link
+ * AdPlaybackState#withAdResumePositionUs(long)}.
  *
  * <p>If {@link EventListener#onAdPlaybackState(AdPlaybackState)} has been called, the
- * implementation of {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} should invoke the
- * same listener to provide the existing playback state to the new player.
+ * implementation of {@link #start(EventListener, AdViewProvider)} should invoke the same listener
+ * to provide the existing playback state to the new player.
  */
 public interface AdsLoader {
 
-  /**
-   * Listener for ad loader events. All methods are called on the main thread.
-   */
+  /** Listener for ads loader events. All methods are called on the main thread. */
   interface EventListener {
 
     /**
@@ -53,7 +53,7 @@
      *
      * @param adPlaybackState The new ad playback state.
      */
-    void onAdPlaybackState(AdPlaybackState adPlaybackState);
+    default void onAdPlaybackState(AdPlaybackState adPlaybackState) {}
 
     /**
      * Called when there was an error loading ads.
@@ -61,23 +61,62 @@
      * @param error The error.
      * @param dataSpec The data spec associated with the load error.
      */
-    void onAdLoadError(AdLoadException error, DataSpec dataSpec);
+    default void onAdLoadError(AdLoadException error, DataSpec dataSpec) {}
 
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
+    /** Called when the user clicks through an ad (for example, following a 'learn more' link). */
+    default void onAdClicked() {}
+
+    /** Called when the user taps a non-clickthrough part of an ad. */
+    default void onAdTapped() {}
+  }
+
+  /** Provides views for the ad UI. */
+  interface AdViewProvider {
+
+    /** Returns the {@link ViewGroup} on top of the player that will show any ad UI. */
+    ViewGroup getAdViewGroup();
 
     /**
-     * Called when the user taps a non-clickthrough part of an ad.
+     * Returns an array of views that are shown on top of the ad view group, but that are essential
+     * for controlling playback and should be excluded from ad viewability measurements by the
+     * {@link AdsLoader} (if it supports this).
+     *
+     * <p>Each view must be either a fully transparent overlay (for capturing touch events), or a
+     * small piece of transient UI that is essential to the user experience of playback (such as a
+     * button to pause/resume playback or a transient full-screen or cast button). For more
+     * information see the documentation for your ads loader.
      */
-    void onAdTapped();
-
+    View[] getAdOverlayViews();
   }
 
+  // Methods called by the application.
+
+  /**
+   * Sets the player that will play the loaded ads.
+   *
+   * <p>This method must be called before the player is prepared with media using this ads loader.
+   *
+   * <p>This method must also be called on the main thread and only players which are accessed on
+   * the main thread are supported ({@code player.getApplicationLooper() ==
+   * Looper.getMainLooper()}).
+   *
+   * @param player The player instance that will play the loaded ads. May be null to delete the
+   *     reference to a previously set player.
+   */
+  void setPlayer(@Nullable Player player);
+
   /**
-   * Sets the supported content types for ad media. Must be called before the first call to
-   * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. Subsequent calls may be ignored.
+   * Releases the loader. Must be called by the application on the main thread when the instance is
+   * no longer needed.
+   */
+  void release();
+
+  // Methods called by AdsMediaSource.
+
+  /**
+   * Sets the supported content types for ad media. Must be called before the first call to {@link
+   * #start(EventListener, AdViewProvider)}. Subsequent calls may be ignored. Called on the main
+   * thread by {@link AdsMediaSource}.
    *
    * @param contentTypes The supported content types for ad media. Each element must be one of
    *     {@link C#TYPE_DASH}, {@link C#TYPE_HLS}, {@link C#TYPE_SS} and {@link C#TYPE_OTHER}.
@@ -85,32 +124,23 @@
   void setSupportedContentTypes(@C.ContentType int... contentTypes);
 
   /**
-   * Attaches a player that will play ads loaded using this instance. Called on the main thread by
-   * {@link AdsMediaSource}.
+   * Starts using the ads loader for playback. Called on the main thread by {@link AdsMediaSource}.
    *
-   * @param player The player instance that will play the loaded ads. Only players which are
-   *     accessed on the main thread are supported ({@code player.getApplicationLooper() ==
-   *     Looper.getMainLooper()}).
    * @param eventListener Listener for ads loader events.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   */
-  void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup);
-
-  /**
-   * Detaches the attached player and event listener. Called on the main thread by
-   * {@link AdsMediaSource}.
+   * @param adViewProvider Provider of views for the ad UI.
    */
-  void detachPlayer();
+  void start(EventListener eventListener, AdViewProvider adViewProvider);
 
   /**
-   * Releases the loader. Called by the application on the main thread when the instance is no
-   * longer needed.
+   * Stops using the ads loader for playback and deregisters the event listener. Called on the main
+   * thread by {@link AdsMediaSource}.
    */
-  void release();
+  void stop();
 
   /**
    * Notifies the ads loader that the player was not able to prepare media for a given ad.
    * Implementations should update the ad playback state as the specified ad has failed to load.
+   * Called on the main thread by {@link AdsMediaSource}.
    *
    * @param adGroupIndex The index of the ad group.
    * @param adIndexInAdGroup The index of the ad in the ad group.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 4bf661ddc0..c57ad6a223 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -20,9 +20,7 @@
 import android.os.Looper;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
-import android.view.ViewGroup;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.CompositeMediaSource;
 import com.google.android.exoplayer2.source.DeferredMediaPeriod;
@@ -140,46 +138,6 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
     }
   }
 
-  /**
-   * Listener for ads media source events.
-   *
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public interface EventListener {
-
-    /**
-     * Called if there was an error loading one or more ads. The loader will skip the problematic
-     * ad(s).
-     *
-     * @param error The error.
-     */
-    void onAdLoadError(IOException error);
-
-    /**
-     * Called when an unexpected internal error is encountered while loading ads. The loader will
-     * skip all remaining ads, as the error is not recoverable.
-     *
-     * @param error The error.
-     */
-    void onInternalAdLoadError(RuntimeException error);
-
-    /**
-     * Called when the user clicks through an ad (for example, following a 'learn more' link).
-     */
-    void onAdClicked();
-
-    /**
-     * Called when the user taps a non-clickthrough part of an ad.
-     */
-    void onAdTapped();
-
-  }
-
   // Used to identify the content "child" source for CompositeMediaSource.
   private static final MediaPeriodId DUMMY_CONTENT_MEDIA_PERIOD_ID =
       new MediaPeriodId(/* periodUid= */ new Object());
@@ -187,9 +145,7 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
   private final MediaSource contentMediaSource;
   private final MediaSourceFactory adMediaSourceFactory;
   private final AdsLoader adsLoader;
-  private final ViewGroup adUiViewGroup;
-  @Nullable private final Handler eventHandler;
-  @Nullable private final EventListener eventListener;
+  private final AdsLoader.AdViewProvider adViewProvider;
   private final Handler mainHandler;
   private final Map<MediaSource, List<DeferredMediaPeriod>> deferredMediaPeriodByAdMediaSource;
   private final Timeline.Period period;
@@ -209,20 +165,18 @@ public RuntimeException getRuntimeExceptionForUnexpected() {
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param dataSourceFactory Factory for data sources used to load ad media.
    * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewProvider Provider of views for the ad UI.
    */
   public AdsMediaSource(
       MediaSource contentMediaSource,
       DataSource.Factory dataSourceFactory,
       AdsLoader adsLoader,
-      ViewGroup adUiViewGroup) {
+      AdsLoader.AdViewProvider adViewProvider) {
     this(
         contentMediaSource,
         new ExtractorMediaSource.Factory(dataSourceFactory),
         adsLoader,
-        adUiViewGroup,
-        /* eventHandler= */ null,
-        /* eventListener= */ null);
+        adViewProvider);
   }
 
   /**
@@ -232,85 +186,17 @@ public AdsMediaSource(
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param adMediaSourceFactory Factory for media sources used to load ad media.
    * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param adViewProvider Provider of views for the ad UI.
    */
   public AdsMediaSource(
       MediaSource contentMediaSource,
       MediaSourceFactory adMediaSourceFactory,
       AdsLoader adsLoader,
-      ViewGroup adUiViewGroup) {
-    this(
-        contentMediaSource,
-        adMediaSourceFactory,
-        adsLoader,
-        adUiViewGroup,
-        /* eventHandler= */ null,
-        /* eventListener= */ null);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}. Ad media is loaded using {@link ExtractorMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param dataSourceFactory Factory for data sources used to load ad media.
-   * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public AdsMediaSource(
-      MediaSource contentMediaSource,
-      DataSource.Factory dataSourceFactory,
-      AdsLoader adsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable EventListener eventListener) {
-    this(
-        contentMediaSource,
-        new ExtractorMediaSource.Factory(dataSourceFactory),
-        adsLoader,
-        adUiViewGroup,
-        eventHandler,
-        eventListener);
-  }
-
-  /**
-   * Constructs a new source that inserts ads linearly with the content specified by {@code
-   * contentMediaSource}.
-   *
-   * @param contentMediaSource The {@link MediaSource} providing the content to play.
-   * @param adMediaSourceFactory Factory for media sources used to load ad media.
-   * @param adsLoader The loader for ads.
-   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @deprecated To listen for ad load error events, add a listener via {@link
-   *     #addEventListener(Handler, MediaSourceEventListener)} and check for {@link
-   *     AdLoadException}s in {@link MediaSourceEventListener#onLoadError(int, MediaPeriodId,
-   *     LoadEventInfo, MediaLoadData, IOException, boolean)}. Individual ads loader implementations
-   *     should expose ad interaction events, if applicable.
-   */
-  @Deprecated
-  public AdsMediaSource(
-      MediaSource contentMediaSource,
-      MediaSourceFactory adMediaSourceFactory,
-      AdsLoader adsLoader,
-      ViewGroup adUiViewGroup,
-      @Nullable Handler eventHandler,
-      @Nullable EventListener eventListener) {
+      AdsLoader.AdViewProvider adViewProvider) {
     this.contentMediaSource = contentMediaSource;
     this.adMediaSourceFactory = adMediaSourceFactory;
     this.adsLoader = adsLoader;
-    this.adUiViewGroup = adUiViewGroup;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
+    this.adViewProvider = adViewProvider;
     mainHandler = new Handler(Looper.getMainLooper());
     deferredMediaPeriodByAdMediaSource = new HashMap<>();
     period = new Timeline.Period();
@@ -326,18 +212,12 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      final ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
-    super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
-    Assertions.checkArgument(
-        isTopLevelSource,
-        "AdsMediaSource must be the top-level source used to prepare the player.");
-    final ComponentListener componentListener = new ComponentListener();
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
+    super.prepareSourceInternal(mediaTransferListener);
+    ComponentListener componentListener = new ComponentListener();
     this.componentListener = componentListener;
     prepareChildSource(DUMMY_CONTENT_MEDIA_PERIOD_ID, contentMediaSource);
-    mainHandler.post(() -> adsLoader.attachPlayer(player, componentListener, adUiViewGroup));
+    mainHandler.post(() -> adsLoader.start(componentListener, adViewProvider));
   }
 
   @Override
@@ -406,7 +286,7 @@ public void releaseSourceInternal() {
     adPlaybackState = null;
     adGroupMediaSources = new MediaSource[0][];
     adGroupTimelines = new Timeline[0][];
-    mainHandler.post(adsLoader::detachPlayer);
+    mainHandler.post(adsLoader::stop);
   }
 
   @Override
@@ -446,6 +326,7 @@ private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
   }
 
   private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    Assertions.checkArgument(timeline.getPeriodCount() == 1);
     contentTimeline = timeline;
     contentManifest = manifest;
     maybeUpdateSourceInfo();
@@ -528,36 +409,6 @@ public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
           });
     }
 
-    @Override
-    public void onAdClicked() {
-      if (released) {
-        return;
-      }
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                eventListener.onAdClicked();
-              }
-            });
-      }
-    }
-
-    @Override
-    public void onAdTapped() {
-      if (released) {
-        return;
-      }
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                eventListener.onAdTapped();
-              }
-            });
-      }
-    }
-
     @Override
     public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
       if (released) {
@@ -574,18 +425,6 @@ public void onAdLoadError(final AdLoadException error, DataSpec dataSpec) {
               /* bytesLoaded= */ 0,
               error,
               /* wasCanceled= */ true);
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(
-            () -> {
-              if (!released) {
-                if (error.type == AdLoadException.TYPE_UNEXPECTED) {
-                  eventListener.onInternalAdLoadError(error.getRuntimeExceptionForUnexpected());
-                } else {
-                  eventListener.onAdLoadError(error);
-                }
-              }
-            });
-      }
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 388aa29ce9..3e262a567d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -1087,10 +1087,6 @@ protected CodecMaxValues getCodecMaxValues(
       throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
-    if (codecNeedsMaxVideoSizeResetWorkaround(codecInfo.name)) {
-      maxWidth = Math.max(maxWidth, 1920);
-      maxHeight = Math.max(maxHeight, 1089);
-    }
     int maxInputSize = getMaxInputSize(codecInfo, format);
     if (streamFormats.length == 1) {
       // The single entry in streamFormats must correspond to the format for which the codec is
@@ -1278,18 +1274,6 @@ private static boolean deviceNeedsNoPostProcessWorkaround() {
     return "NVIDIA".equals(Util.MANUFACTURER);
   }
 
-  /**
-   * Returns whether the codec is known to have problems with the configuration for interlaced
-   * content and needs minimum values for the maximum video size to force reset the configuration.
-   *
-   * <p>See https://github.com/google/ExoPlayer/issues/5003.
-   *
-   * @param name The name of the codec.
-   */
-  private static boolean codecNeedsMaxVideoSizeResetWorkaround(String name) {
-    return "OMX.amlogic.avc.decoder.awesome".equals(name) && Util.SDK_INT <= 25;
-  }
-
   /*
    * TODO:
    *
@@ -1319,8 +1303,9 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
     }
     synchronized (MediaCodecVideoRenderer.class) {
       if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {
-        if (Util.SDK_INT <= 27 && "dangal".equals(Util.DEVICE)) {
-          // Dangal is affected on API level 27: https://github.com/google/ExoPlayer/issues/5169.
+        if (Util.SDK_INT <= 27 && ("dangal".equals(Util.DEVICE) || "HWEML".equals(Util.DEVICE))) {
+          // A small number of devices are affected on API level 27:
+          // https://github.com/google/ExoPlayer/issues/5169.
           deviceNeedsSetOutputSurfaceWorkaround = true;
         } else if (Util.SDK_INT >= 27) {
           // In general, devices running API level 27 or later should be unaffected. Do nothing.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index d131ed0f51..fd9100338c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -267,10 +267,8 @@ public void testRepreparationGivesFreshSourceInfo() throws Exception {
         new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
           @Override
           public synchronized void prepareSourceInternal(
-              ExoPlayer player,
-              boolean isTopLevelSource,
               @Nullable TransferListener mediaTransferListener) {
-            super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
+            super.prepareSourceInternal(mediaTransferListener);
             // We've queued a source info refresh on the playback thread's event queue. Allow the
             // test thread to prepare the player with the third source, and block this thread (the
             // playback thread) until the test thread's call to prepare() has returned.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
index c6558e3fc9..85d336b439 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -51,7 +51,6 @@ public void testDecodeEventMessage() {
     assertThat(eventMessage.durationMs).isEqualTo(3000);
     assertThat(eventMessage.id).isEqualTo(1000403);
     assertThat(eventMessage.messageData).isEqualTo(new byte[]{0, 1, 2, 3, 4});
-    assertThat(eventMessage.presentationTimeUs).isEqualTo(1000000);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
index 7195548fbf..2869692272 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
@@ -33,25 +33,27 @@
 
   @Test
   public void testEncodeEventStream() throws IOException {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] expectedEmsgBody = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -45, // id = 1000403
-        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
-    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage, 48000);
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] expectedEmsgBody =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -45, // id = 1000403
+          0, 1, 2, 3, 4
+        }; // message_data = {0, 1, 2, 3, 4}
+    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage);
     assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
   }
 
   @Test
   public void testEncodeDecodeEventStream() throws IOException {
-    EventMessage expectedEmsg = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg, 48000);
+    EventMessage expectedEmsg =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg);
     MetadataInputBuffer buffer = new MetadataInputBuffer();
     buffer.data = ByteBuffer.allocate(encodedByteArray.length).put(encodedByteArray);
 
@@ -63,30 +65,34 @@ public void testEncodeDecodeEventStream() throws IOException {
 
   @Test
   public void testEncodeEventStreamMultipleTimesWorkingCorrectly() throws IOException {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000000);
-    byte[] expectedEmsgBody = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -45, // id = 1000403
-        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
-    EventMessage eventMessage1 = new EventMessage("urn:test", "123", 3000, 1000402,
-        new byte[] {4, 3, 2, 1, 0}, 1000000);
-    byte[] expectedEmsgBody1 = new byte[] {
-        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
-        49, 50, 51, 0, // value = "123"
-        0, 0, -69, -128, // timescale = 48000
-        0, 0, -69, -128, // presentation_time_delta = 48000
-        0, 2, 50, -128, // event_duration = 144000
-        0, 15, 67, -46, // id = 1000402
-        4, 3, 2, 1, 0}; // message_data = {4, 3, 2, 1, 0}
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
+    byte[] expectedEmsgBody =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -45, // id = 1000403
+          0, 1, 2, 3, 4
+        }; // message_data = {0, 1, 2, 3, 4}
+    EventMessage eventMessage1 =
+        new EventMessage("urn:test", "123", 3000, 1000402, new byte[] {4, 3, 2, 1, 0});
+    byte[] expectedEmsgBody1 =
+        new byte[] {
+          117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+          49, 50, 51, 0, // value = "123"
+          0, 0, 3, -24, // timescale = 1000
+          0, 0, 0, 0, // presentation_time_delta = 0
+          0, 0, 11, -72, // event_duration = 3000
+          0, 15, 67, -46, // id = 1000402
+          4, 3, 2, 1, 0
+        }; // message_data = {4, 3, 2, 1, 0}
     EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
-    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage, 48000);
+    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage);
     assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
-    byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1, 48000);
+    byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1);
     assertThat(encodedByteArray1).isEqualTo(expectedEmsgBody1);
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
index 30e1cd6c1f..f7970d1a16 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -30,8 +30,8 @@
 
   @Test
   public void testEventMessageParcelable() {
-    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4}, 1000);
+    EventMessage eventMessage =
+        new EventMessage("urn:test", "123", 3000, 1000403, new byte[] {0, 1, 2, 3, 4});
     // Write to parcel.
     Parcel parcel = Parcel.obtain();
     eventMessage.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
index dd1221f160..9ec5078faf 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -17,13 +17,16 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import android.os.ConditionVariable;
+import android.os.Handler;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSource.SourceInfoRefreshListener;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.testutil.DummyMainThread;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
@@ -41,7 +44,6 @@
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
@@ -415,57 +417,59 @@ public void testIllegalArguments() {
 
   @Test
   public void testCustomCallbackBeforePreparationAddSingle() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
-    mediaSource.addMediaSource(createFakeMediaSource(), runnable);
+    mediaSource.addMediaSource(createFakeMediaSource(), new Handler(), runnable);
     verify(runnable).run();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddMultiple() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
     mediaSource.addMediaSources(
         Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+        new Handler(),
         runnable);
     verify(runnable).run();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddSingleWithIndex() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
-    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), runnable);
+    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), new Handler(), runnable);
     verify(runnable).run();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationAddMultipleWithIndex() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
     mediaSource.addMediaSources(
         /* index */ 0,
         Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+        new Handler(),
         runnable);
     verify(runnable).run();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationRemove() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
     mediaSource.addMediaSource(createFakeMediaSource());
-    mediaSource.removeMediaSource(/* index */ 0, runnable);
+    mediaSource.removeMediaSource(/* index */ 0, new Handler(), runnable);
     verify(runnable).run();
   }
 
   @Test
   public void testCustomCallbackBeforePreparationMove() {
-    Runnable runnable = Mockito.mock(Runnable.class);
+    Runnable runnable = mock(Runnable.class);
 
     mediaSource.addMediaSources(
         Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
-    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, runnable);
+    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, new Handler(), runnable);
     verify(runnable).run();
   }
 
@@ -476,7 +480,8 @@ public void testCustomCallbackAfterPreparationAddSingle() throws IOException {
       testRunner.prepareSource();
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.addMediaSource(createFakeMediaSource(), timelineGrabber));
+          () ->
+              mediaSource.addMediaSource(createFakeMediaSource(), new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -495,6 +500,7 @@ public void testCustomCallbackAfterPreparationAddMultiple() throws IOException {
               mediaSource.addMediaSources(
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  new Handler(),
                   timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
@@ -511,7 +517,8 @@ public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws IOExce
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
           () ->
-              mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), timelineGrabber));
+              mediaSource.addMediaSource(
+                  /* index */ 0, createFakeMediaSource(), new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(1);
     } finally {
@@ -531,6 +538,7 @@ public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws IOEx
                   /* index */ 0,
                   Arrays.asList(
                       new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  new Handler(),
                   timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
@@ -549,7 +557,7 @@ public void testCustomCallbackAfterPreparationRemove() throws IOException {
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.removeMediaSource(/* index */ 0, timelineGrabber));
+          () -> mediaSource.removeMediaSource(/* index */ 0, new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(0);
     } finally {
@@ -571,7 +579,9 @@ public void testCustomCallbackAfterPreparationMove() throws IOException {
 
       final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
       dummyMainThread.runOnMainThread(
-          () -> mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, timelineGrabber));
+          () ->
+              mediaSource.moveMediaSource(
+                  /* fromIndex */ 1, /* toIndex */ 0, new Handler(), timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getWindowCount()).isEqualTo(2);
     } finally {
@@ -819,7 +829,7 @@ public void testClear() throws IOException {
     testRunner.prepareSource();
     final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
 
-    dummyMainThread.runOnMainThread(() -> mediaSource.clear(timelineGrabber));
+    dummyMainThread.runOnMainThread(() -> mediaSource.clear(new Handler(), timelineGrabber));
 
     Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
     assertThat(timeline.isEmpty()).isTrue();
@@ -964,8 +974,9 @@ public void testSetShuffleOrderAfterPreparation() throws Exception {
 
   @Test
   public void testCustomCallbackBeforePreparationSetShuffleOrder() throws Exception {
-    Runnable runnable = Mockito.mock(Runnable.class);
-    mediaSource.setShuffleOrder(new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0), runnable);
+    Runnable runnable = mock(Runnable.class);
+    mediaSource.setShuffleOrder(
+        new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 0), new Handler(), runnable);
 
     verify(runnable).run();
   }
@@ -981,7 +992,9 @@ public void testCustomCallbackAfterPreparationSetShuffleOrder() throws Exception
       dummyMainThread.runOnMainThread(
           () ->
               mediaSource.setShuffleOrder(
-                  new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3), timelineGrabber));
+                  new ShuffleOrder.UnshuffledShuffleOrder(/* length= */ 3),
+                  new Handler(),
+                  timelineGrabber));
       Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
       assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
     } finally {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index c65bfceb39..8b503989b7 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -22,7 +22,6 @@
 import android.text.TextUtils;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
@@ -614,10 +613,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       processManifest(false);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
index 9f812b8e84..f06a709960 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
@@ -112,8 +112,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       }
     }
     int sampleIndex = currentIndex++;
-    byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex],
-        eventStream.timescale);
+    byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex]);
     if (serializedEvent != null) {
       buffer.ensureSpaceForWrite(serializedEvent.length);
       buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index f017ae64ad..f34127273d 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -834,13 +834,13 @@ protected EventStream parseEventStream(XmlPullParser xpp)
     String schemeIdUri = parseString(xpp, "schemeIdUri", "");
     String value = parseString(xpp, "value", "");
     long timescale = parseLong(xpp, "timescale", 1);
-    List<EventMessage> eventMessages = new ArrayList<>();
+    List<Pair<Long, EventMessage>> eventMessages = new ArrayList<>();
     ByteArrayOutputStream scratchOutputStream = new ByteArrayOutputStream(512);
     do {
       xpp.next();
       if (XmlPullParserUtil.isStartTag(xpp, "Event")) {
-        EventMessage event = parseEvent(xpp, schemeIdUri, value, timescale,
-            scratchOutputStream);
+        Pair<Long, EventMessage> event =
+            parseEvent(xpp, schemeIdUri, value, timescale, scratchOutputStream);
         eventMessages.add(event);
       } else {
         maybeSkipTag(xpp);
@@ -850,9 +850,9 @@ protected EventStream parseEventStream(XmlPullParser xpp)
     long[] presentationTimesUs = new long[eventMessages.size()];
     EventMessage[] events = new EventMessage[eventMessages.size()];
     for (int i = 0; i < eventMessages.size(); i++) {
-      EventMessage event = eventMessages.get(i);
-      presentationTimesUs[i] = event.presentationTimeUs;
-      events[i] = event;
+      Pair<Long, EventMessage> event = eventMessages.get(i);
+      presentationTimesUs[i] = event.first;
+      events[i] = event.second;
     }
     return buildEventStream(schemeIdUri, value, timescale, presentationTimesUs, events);
   }
@@ -871,11 +871,12 @@ protected EventStream buildEventStream(String schemeIdUri, String value, long ti
    * @param timescale The timescale of the parent EventStream.
    * @param scratchOutputStream A {@link ByteArrayOutputStream} that is used when parsing event
    *     objects.
-   * @return The {@link EventMessage} parsed from this EventStream node.
+   * @return A pair containing the node's presentation timestamp in microseconds and the parsed
+   *     {@link EventMessage}.
    * @throws XmlPullParserException If there is any error parsing this node.
    * @throws IOException If there is any error reading from the underlying input stream.
    */
-  protected EventMessage parseEvent(
+  protected Pair<Long, EventMessage> parseEvent(
       XmlPullParser xpp,
       String schemeIdUri,
       String value,
@@ -890,13 +891,14 @@ protected EventMessage parseEvent(
         timescale);
     String messageData = parseString(xpp, "messageData", null);
     byte[] eventObject = parseEventObject(xpp, scratchOutputStream);
-    return buildEvent(
-        schemeIdUri,
-        value,
-        id,
-        durationMs,
-        messageData == null ? eventObject : Util.getUtf8Bytes(messageData),
-        presentationTimesUs);
+    return Pair.create(
+        presentationTimesUs,
+        buildEvent(
+            schemeIdUri,
+            value,
+            id,
+            durationMs,
+            messageData == null ? eventObject : Util.getUtf8Bytes(messageData)));
   }
 
   /**
@@ -963,9 +965,9 @@ protected EventMessage parseEvent(
     return scratchOutputStream.toByteArray();
   }
 
-  protected EventMessage buildEvent(String schemeIdUri, String value, long id,
-      long durationMs, byte[] messageData, long presentationTimeUs) {
-    return new EventMessage(schemeIdUri, value, durationMs, id, messageData, presentationTimeUs);
+  protected EventMessage buildEvent(
+      String schemeIdUri, String value, long id, long durationMs, byte[] messageData) {
+    return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
   }
 
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
index 9c3752551a..9621381eed 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
@@ -111,7 +111,7 @@ public void testReadDataOutOfBoundReturnEndOfStreamAfterFormatForDynamicEventSam
   @Test
   public void testReadDataReturnDataAfterFormat() {
     long presentationTimeUs = 1000000;
-    EventMessage eventMessage = newEventMessageWithIdAndTime(1, presentationTimeUs);
+    EventMessage eventMessage = newEventMessageWithId(1);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs}, new EventMessage[] {eventMessage});
     EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
@@ -133,8 +133,8 @@ public void testReadDataReturnDataAfterFormat() {
   public void testSkipDataThenReadDataReturnDataFromSkippedPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -159,8 +159,8 @@ public void testSkipDataThenReadDataReturnDataFromSkippedPosition() {
   public void testSeekToUsThenReadDataReturnDataFromSeekPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
     EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -186,9 +186,9 @@ public void testUpdateEventStreamContinueToReadAfterLastReadSamplePresentationTi
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -220,9 +220,9 @@ public void testSkipDataThenUpdateStreamContinueToReadFromSkippedPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -253,9 +253,9 @@ public void testSkipDataThenUpdateStreamContinueToReadDoNotSkippedMoreThanAvaila
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1},
         new EventMessage[] {eventMessage1});
@@ -287,9 +287,9 @@ public void testSeekToUsThenUpdateStreamContinueToReadFromSeekPosition() {
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1, presentationTimeUs2},
         new EventMessage[] {eventMessage1, eventMessage2});
@@ -319,9 +319,9 @@ public void testSeekToThenUpdateStreamContinueToReadFromSeekPositionEvenSeekMore
     long presentationTimeUs1 = 1000000;
     long presentationTimeUs2 = 2000000;
     long presentationTimeUs3 = 3000000;
-    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
-    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
-    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventMessage eventMessage1 = newEventMessageWithId(1);
+    EventMessage eventMessage2 = newEventMessageWithId(2);
+    EventMessage eventMessage3 = newEventMessageWithId(3);
     EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
         new long[] {presentationTimeUs1},
         new EventMessage[] {eventMessage1});
@@ -345,12 +345,12 @@ private int readData(EventSampleStream sampleStream) {
     return sampleStream.readData(formatHolder, inputBuffer, false);
   }
 
-  private EventMessage newEventMessageWithIdAndTime(int id, long presentationTimeUs) {
-    return new EventMessage(SCHEME_ID, VALUE, DURATION_MS, id, MESSAGE_DATA, presentationTimeUs);
+  private EventMessage newEventMessageWithId(int id) {
+    return new EventMessage(SCHEME_ID, VALUE, DURATION_MS, id, MESSAGE_DATA);
   }
 
   private byte[] getEncodedMessage(EventMessage eventMessage) {
-    return eventMessageEncoder.encode(eventMessage, TIME_SCALE);
+    return eventMessageEncoder.encode(eventMessage);
   }
 
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index a1693f6985..67d8dbecac 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -104,52 +104,53 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
             "call",
             10000,
             0,
-            "+ 1 800 10101010".getBytes(Charset.forName(C.UTF8_NAME)),
-            0);
+            "+ 1 800 10101010".getBytes(Charset.forName(C.UTF8_NAME)));
     assertThat(eventStream1.events[0]).isEqualTo(expectedEvent1);
+    assertThat(eventStream1.presentationTimesUs[0]).isEqualTo(0);
 
     // assert CData-structured event stream
     EventStream eventStream2 = period.eventStreams.get(1);
     assertThat(eventStream2.events.length).isEqualTo(1);
-    assertThat(eventStream2.events[0])
-        .isEqualTo(
-            new EventMessage(
-                "urn:dvb:iptv:cpm:2014",
-                "",
-                1500000,
-                1,
-                Util.getUtf8Bytes(
-                    "<![CDATA[<BroadcastEvent>\n"
-                        + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
-                        + "      <InstanceDescription>\n"
-                        + "      <Title xml:lang=\"en\">The title</Title>\n"
-                        + "      <Synopsis xml:lang=\"en\" length=\"medium\">"
-                        + "The description</Synopsis>\n"
-                        + "      <ParentalGuidance>\n"
-                        + "      <mpeg7:ParentalRating href=\"urn:dvb:iptv:rating:2014:15\"/>\n"
-                        + "      <mpeg7:Region>GB</mpeg7:Region>\n"
-                        + "      </ParentalGuidance>\n"
-                        + "      </InstanceDescription>\n"
-                        + "      </BroadcastEvent>]]>"),
-                300000000));
+    EventMessage expectedEvent2 =
+        new EventMessage(
+            "urn:dvb:iptv:cpm:2014",
+            "",
+            1500000,
+            1,
+            Util.getUtf8Bytes(
+                "<![CDATA[<BroadcastEvent>\n"
+                    + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
+                    + "      <InstanceDescription>\n"
+                    + "      <Title xml:lang=\"en\">The title</Title>\n"
+                    + "      <Synopsis xml:lang=\"en\" length=\"medium\">"
+                    + "The description</Synopsis>\n"
+                    + "      <ParentalGuidance>\n"
+                    + "      <mpeg7:ParentalRating href=\"urn:dvb:iptv:rating:2014:15\"/>\n"
+                    + "      <mpeg7:Region>GB</mpeg7:Region>\n"
+                    + "      </ParentalGuidance>\n"
+                    + "      </InstanceDescription>\n"
+                    + "      </BroadcastEvent>]]>"));
+
+    assertThat(eventStream2.events[0]).isEqualTo(expectedEvent2);
+    assertThat(eventStream2.presentationTimesUs[0]).isEqualTo(300000000);
 
     // assert xml-structured event stream
     EventStream eventStream3 = period.eventStreams.get(2);
     assertThat(eventStream3.events.length).isEqualTo(1);
-    assertThat(eventStream3.events[0])
-        .isEqualTo(
-            new EventMessage(
-                "urn:scte:scte35:2014:xml+bin",
-                "",
-                1000000,
-                2,
-                Util.getUtf8Bytes(
-                    "<scte35:Signal>\n"
-                        + "         <scte35:Binary>\n"
-                        + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
-                        + "         </scte35:Binary>\n"
-                        + "       </scte35:Signal>"),
-                1000000000));
+    EventMessage expectedEvent3 =
+        new EventMessage(
+            "urn:scte:scte35:2014:xml+bin",
+            "",
+            1000000,
+            2,
+            Util.getUtf8Bytes(
+                "<scte35:Signal>\n"
+                    + "         <scte35:Binary>\n"
+                    + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
+                    + "         </scte35:Binary>\n"
+                    + "       </scte35:Signal>"));
+    assertThat(eventStream3.events[0]).isEqualTo(expectedEvent3);
+    assertThat(eventStream3.presentationTimesUs[0]).isEqualTo(1000000000);
   }
 
   @Test
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 2afd041631..cd2cbbcab9 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Handler;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.source.BaseMediaSource;
@@ -397,10 +396,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     EventDispatcher eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
     playlistTracker.start(manifestUri, eventDispatcher, /* listener= */ this);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index f43d119018..cf879e91c6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -68,6 +68,10 @@ public void maybeThrowError() throws IOException {
 
   @Override
   public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean requireFormat) {
+    if (sampleQueueIndex == HlsSampleStreamWrapper.SAMPLE_QUEUE_INDEX_NO_MAPPING_NON_FATAL) {
+      buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+      return C.RESULT_BUFFER_READ;
+    }
     return hasValidSampleQueueIndex()
         ? sampleStreamWrapper.readData(sampleQueueIndex, formatHolder, buffer, requireFormat)
         : C.RESULT_NOTHING_READ;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 242711431c..9e13d6fa0f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -101,6 +101,7 @@
       Pattern.compile("AVERAGE-BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_AUDIO = Pattern.compile("AUDIO=\"(.+?)\"");
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("[^-]BANDWIDTH=(\\d+)\\b");
+  private static final Pattern REGEX_CHANNELS = Pattern.compile("CHANNELS=\"(.+?)\"");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
   private static final Pattern REGEX_FRAME_RATE = Pattern.compile("FRAME-RATE=([\\d\\.]+)\\b");
@@ -346,6 +347,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       switch (parseStringAttr(line, REGEX_TYPE, variableDefinitions)) {
         case TYPE_AUDIO:
           String codecs = audioGroupIdToCodecs.get(groupId);
+          int channelCount = parseChannelsAttribute(line, variableDefinitions);
           String sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
           format =
               Format.createAudioContainerFormat(
@@ -355,7 +357,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                   sampleMimeType,
                   codecs,
                   /* bitrate= */ Format.NO_VALUE,
-                  /* channelCount= */ Format.NO_VALUE,
+                  channelCount,
                   /* sampleRate= */ Format.NO_VALUE,
                   /* initializationData= */ null,
                   selectionFlags,
@@ -426,21 +428,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         variableDefinitions);
   }
 
-  @C.SelectionFlags
-  private static int parseSelectionFlags(String line) {
-    int flags = 0;
-    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {
-      flags |= C.SELECTION_FLAG_DEFAULT;
-    }
-    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {
-      flags |= C.SELECTION_FLAG_FORCED;
-    }
-    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {
-      flags |= C.SELECTION_FLAG_AUTOSELECT;
-    }
-    return flags;
-  }
-
   private static HlsMediaPlaylist parseMediaPlaylist(
       HlsMasterPlaylist masterPlaylist, LineIterator iterator, String baseUri) throws IOException {
     @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
@@ -661,6 +648,28 @@ private static HlsMediaPlaylist parseMediaPlaylist(
         segments);
   }
 
+  @C.SelectionFlags
+  private static int parseSelectionFlags(String line) {
+    int flags = 0;
+    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {
+      flags |= C.SELECTION_FLAG_DEFAULT;
+    }
+    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {
+      flags |= C.SELECTION_FLAG_FORCED;
+    }
+    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {
+      flags |= C.SELECTION_FLAG_AUTOSELECT;
+    }
+    return flags;
+  }
+
+  private static int parseChannelsAttribute(String line, Map<String, String> variableDefinitions) {
+    String channelsString = parseOptionalStringAttr(line, REGEX_CHANNELS, variableDefinitions);
+    return channelsString != null
+        ? Integer.parseInt(Util.splitAtFirst(channelsString, "/")[0])
+        : Format.NO_VALUE;
+  }
+
   private static @Nullable SchemeData parsePlayReadySchemeData(
       String line, Map<String, String> variableDefinitions) throws ParserException {
     String keyFormatVersions =
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 9701171ce9..8b69ba0db2 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -81,6 +81,18 @@
           + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
           + "http://example.com/low.m3u8\n";
 
+  private static final String PLAYLIST_WITH_CHANNELS_ATTRIBUTE =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",CHANNELS=\"6\",NAME=\"Eng6\","
+          + "URI=\"something.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",CHANNELS=\"2/6\",NAME=\"Eng26\","
+          + "URI=\"something2.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",NAME=\"Eng\","
+          + "URI=\"something3.m3u8\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",AUDIO=\"audio\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
   private static final String PLAYLIST_WITHOUT_CC =
       " #EXTM3U \n"
           + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
@@ -216,6 +228,17 @@ public void testPlaylistWithClosedCaption() throws IOException {
     assertThat(closedCaptionFormat.language).isEqualTo("es");
   }
 
+  @Test
+  public void testPlaylistWithChannelsAttribute() throws IOException {
+    HlsMasterPlaylist playlist =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_CHANNELS_ATTRIBUTE);
+    List<HlsMasterPlaylist.HlsUrl> audios = playlist.audios;
+    assertThat(audios).hasSize(3);
+    assertThat(audios.get(0).format.channelCount).isEqualTo(6);
+    assertThat(audios.get(1).format.channelCount).isEqualTo(2);
+    assertThat(audios.get(2).format.channelCount).isEqualTo(Format.NO_VALUE);
+  }
+
   @Test
   public void testPlaylistWithoutClosedCaptions() throws IOException {
     HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITHOUT_CC);
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index d025f8fa3a..fb64f43772 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -20,7 +20,6 @@
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
@@ -510,10 +509,7 @@ public Object getTag() {
   }
 
   @Override
-  public void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
     if (sideloadedManifest) {
       manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 83f5b70cbb..9d66289e94 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -54,6 +54,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -69,6 +70,7 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -221,6 +223,11 @@
  *       <ul>
  *         <li>Type: {@link PlayerControlView}
  *       </ul>
+ *   <li><b>{@code exo_ad_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ *       is used to show ad UI (if applicable).
+ *       <ul>
+ *         <li>Type: {@link FrameLayout}
+ *       </ul>
  *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
  *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
  *       <ul>
@@ -239,7 +246,7 @@
  * PlayerView. This will cause the specified layout to be inflated instead of {@code
  * exo_player_view.xml} for only the instance on which the attribute is set.
  */
-public class PlayerView extends FrameLayout {
+public class PlayerView extends FrameLayout implements AdsLoader.AdViewProvider {
 
   // LINT.IfChange
   /**
@@ -278,9 +285,10 @@
   private final SubtitleView subtitleView;
   @Nullable private final View bufferingView;
   @Nullable private final TextView errorMessageView;
-  private final PlayerControlView controller;
+  @Nullable private final PlayerControlView controller;
   private final ComponentListener componentListener;
-  private final FrameLayout overlayFrameLayout;
+  @Nullable private final FrameLayout adOverlayFrameLayout;
+  @Nullable private final FrameLayout overlayFrameLayout;
 
   private Player player;
   private boolean useController;
@@ -317,6 +325,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       errorMessageView = null;
       controller = null;
       componentListener = null;
+      adOverlayFrameLayout = null;
       overlayFrameLayout = null;
       ImageView logo = new ImageView(context);
       if (Util.SDK_INT >= 23) {
@@ -411,6 +420,9 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
       surfaceView = null;
     }
 
+    // Ad overlay frame layout.
+    adOverlayFrameLayout = findViewById(R.id.exo_ad_overlay);
+
     // Overlay frame layout.
     overlayFrameLayout = findViewById(R.id.exo_overlay);
 
@@ -758,10 +770,6 @@ public void setCustomErrorMessage(@Nullable CharSequence message) {
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     if (player != null && player.isPlayingAd()) {
-      // Focus any overlay UI now, in case it's provided by a WebView whose contents may update
-      // dynamically. This is needed to make the "Skip ad" button focused on Android TV when using
-      // IMA [Internal: b/62371030].
-      overlayFrameLayout.requestFocus();
       return super.dispatchKeyEvent(event);
     }
     boolean isDpadWhenControlHidden =
@@ -1016,6 +1024,7 @@ public View getVideoSurfaceView() {
    * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
    *     the overlay is not present.
    */
+  @Nullable
   public FrameLayout getOverlayFrameLayout() {
     return overlayFrameLayout;
   }
@@ -1035,6 +1044,12 @@ public boolean onTouchEvent(MotionEvent ev) {
     if (ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
       return false;
     }
+    return performClick();
+  }
+
+  @Override
+  public boolean performClick() {
+    super.performClick();
     return toggleControllerVisibility();
   }
 
@@ -1093,6 +1108,28 @@ protected void onContentAspectRatioChanged(
     }
   }
 
+  // AdsLoader.AdViewProvider implementation.
+
+  @Override
+  public ViewGroup getAdViewGroup() {
+    return Assertions.checkNotNull(
+        adOverlayFrameLayout, "exo_ad_overlay must be present for ad playback");
+  }
+
+  @Override
+  public View[] getAdOverlayViews() {
+    ArrayList<View> overlayViews = new ArrayList<>();
+    if (overlayFrameLayout != null) {
+      overlayViews.add(overlayFrameLayout);
+    }
+    if (controller != null) {
+      overlayViews.add(controller);
+    }
+    return overlayViews.toArray(new View[0]);
+  }
+
+  // Internal methods.
+
   private boolean toggleControllerVisibility() {
     if (!useController || player == null) {
       return false;
diff --git a/library/ui/src/main/res/layout/exo_simple_player_view.xml b/library/ui/src/main/res/layout/exo_simple_player_view.xml
index 167ac96222..65dea9271e 100644
--- a/library/ui/src/main/res/layout/exo_simple_player_view.xml
+++ b/library/ui/src/main/res/layout/exo_simple_player_view.xml
@@ -52,6 +52,10 @@
 
   </com.google.android.exoplayer2.ui.AspectRatioFrameLayout>
 
+  <FrameLayout android:id="@id/exo_ad_overlay"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"/>
+
   <FrameLayout android:id="@id/exo_overlay"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
diff --git a/library/ui/src/main/res/values/ids.xml b/library/ui/src/main/res/values/ids.xml
index 184e51ac58..6f798adcb4 100644
--- a/library/ui/src/main/res/values/ids.xml
+++ b/library/ui/src/main/res/values/ids.xml
@@ -21,6 +21,7 @@
   <item name="exo_artwork" type="id"/>
   <item name="exo_controller_placeholder" type="id"/>
   <item name="exo_controller" type="id"/>
+  <item name="exo_ad_overlay" type="id"/>
   <item name="exo_overlay" type="id"/>
   <item name="exo_play" type="id"/>
   <item name="exo_pause" type="id"/>
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
index 627b5b72f3..4ea2d7d754 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DebugRenderersFactory.java
@@ -20,6 +20,7 @@
 import android.media.MediaCodec;
 import android.media.MediaCrypto;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -37,23 +38,38 @@
 
 /**
  * A debug extension of {@link DefaultRenderersFactory}. Provides a video renderer that performs
- * video buffer timestamp assertions.
+ * video buffer timestamp assertions, and modifies the default value for {@link
+ * #setAllowedVideoJoiningTimeMs(long)} to be {@code 0}.
  */
 @TargetApi(16)
 public class DebugRenderersFactory extends DefaultRenderersFactory {
 
   public DebugRenderersFactory(Context context) {
-    super(context, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF, 0);
+    super(context);
+    setAllowedVideoJoiningTimeMs(0);
   }
 
   @Override
-  protected void buildVideoRenderers(Context context,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, long allowedVideoJoiningTimeMs,
-      Handler eventHandler, VideoRendererEventListener eventListener,
-      @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
-    out.add(new DebugMediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
-        allowedVideoJoiningTimeMs, drmSessionManager, eventHandler, eventListener,
-        MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+  protected void buildVideoRenderers(
+      Context context,
+      @ExtensionRendererMode int extensionRendererMode,
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys,
+      Handler eventHandler,
+      VideoRendererEventListener eventListener,
+      long allowedVideoJoiningTimeMs,
+      ArrayList<Renderer> out) {
+    out.add(
+        new DebugMediaCodecVideoRenderer(
+            context,
+            mediaCodecSelector,
+            allowedVideoJoiningTimeMs,
+            drmSessionManager,
+            playClearSamplesWithoutKeys,
+            eventHandler,
+            eventListener,
+            MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
   }
 
   /**
@@ -72,12 +88,24 @@ protected void buildVideoRenderers(Context context,
     private int minimumInsertIndex;
     private boolean skipToPositionBeforeRenderingFirstFrame;
 
-    public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
-        long allowedJoiningTimeMs, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-        Handler eventHandler, VideoRendererEventListener eventListener,
+    public DebugMediaCodecVideoRenderer(
+        Context context,
+        MediaCodecSelector mediaCodecSelector,
+        long allowedJoiningTimeMs,
+        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+        boolean playClearSamplesWithoutKeys,
+        Handler eventHandler,
+        VideoRendererEventListener eventListener,
         int maxDroppedFrameCountToNotify) {
-      super(context, mediaCodecSelector, allowedJoiningTimeMs, drmSessionManager, false,
-          eventHandler, eventListener, maxDroppedFrameCountToNotify);
+      super(
+          context,
+          mediaCodecSelector,
+          allowedJoiningTimeMs,
+          drmSessionManager,
+          playClearSamplesWithoutKeys,
+          eventHandler,
+          eventListener,
+          maxDroppedFrameCountToNotify);
     }
 
     @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index 999372b90a..de4be82b38 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -22,7 +22,6 @@
 import android.os.SystemClock;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
@@ -96,10 +95,7 @@ public Object getTag() {
   }
 
   @Override
-  public synchronized void prepareSourceInternal(
-      ExoPlayer player,
-      boolean isTopLevelSource,
-      @Nullable TransferListener mediaTransferListener) {
+  public synchronized void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     assertThat(preparedSource).isFalse();
     transferListener = mediaTransferListener;
     preparedSource = true;
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
index e6fb5bc5f3..9514768416 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
@@ -17,17 +17,13 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
-import static org.junit.Assert.fail;
 
 import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
-import android.os.Message;
 import android.support.annotation.Nullable;
 import android.util.Pair;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.PlayerMessage;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -54,7 +50,6 @@
 
   public static final int TIMEOUT_MS = 10000;
 
-  private final StubExoPlayer player;
   private final MediaSource mediaSource;
   private final MediaSourceListener mediaSourceListener;
   private final HandlerThread playbackThread;
@@ -79,7 +74,6 @@ public MediaSourceTestRunner(MediaSource mediaSource, Allocator allocator) {
     playbackThread.start();
     Looper playbackLooper = playbackThread.getLooper();
     playbackHandler = new Handler(playbackLooper);
-    player = new EventHandlingExoPlayer(playbackLooper);
     mediaSourceListener = new MediaSourceListener();
     timelines = new LinkedBlockingDeque<>();
     completedLoads = new CopyOnWriteArrayList<>();
@@ -121,11 +115,7 @@ public Timeline prepareSource() throws IOException {
     final IOException[] prepareError = new IOException[1];
     runOnPlaybackThread(
         () -> {
-          mediaSource.prepareSource(
-              player,
-              /* isTopLevelSource= */ true,
-              mediaSourceListener,
-              /* mediaTransferListener= */ null);
+          mediaSource.prepareSource(mediaSourceListener, /* mediaTransferListener= */ null);
           try {
             // TODO: This only catches errors that are set synchronously in prepareSource. To
             // capture async errors we'll need to poll maybeThrowSourceInfoRefreshError until the
@@ -430,43 +420,4 @@ public void onDownstreamFormatChanged(
       Assertions.checkState(Looper.myLooper() == playbackThread.getLooper());
     }
   }
-
-  private static class EventHandlingExoPlayer extends StubExoPlayer
-      implements Handler.Callback, PlayerMessage.Sender {
-
-    private final Handler handler;
-
-    public EventHandlingExoPlayer(Looper looper) {
-      this.handler = new Handler(looper, this);
-    }
-
-    @Override
-    public Looper getApplicationLooper() {
-      return handler.getLooper();
-    }
-
-    @Override
-    public PlayerMessage createMessage(PlayerMessage.Target target) {
-      return new PlayerMessage(
-          /* sender= */ this, target, Timeline.EMPTY, /* defaultWindowIndex= */ 0, handler);
-    }
-
-    @Override
-    public void sendMessage(PlayerMessage message) {
-      handler.obtainMessage(0, message).sendToTarget();
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public boolean handleMessage(Message msg) {
-      PlayerMessage message = (PlayerMessage) msg.obj;
-      try {
-        message.getTarget().handleMessage(message.getType(), message.getPayload());
-        message.markAsProcessed(/* isDelivered= */ true);
-      } catch (ExoPlaybackException e) {
-        fail("Unexpected ExoPlaybackException.");
-      }
-      return true;
-    }
-  }
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
index dc7781fd90..1e7f09bacf 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
@@ -37,6 +37,7 @@
 public final class RobolectricUtil {
 
   private static final AtomicLong sequenceNumberGenerator = new AtomicLong(0);
+  private static final int ANY_MESSAGE = Integer.MIN_VALUE;
 
   private RobolectricUtil() {}
 
@@ -110,7 +111,8 @@ private void doLoop() {
             boolean isRemoved = false;
             for (RemovedMessage removedMessage : removedMessages) {
               if (removedMessage.handler == target
-                  && removedMessage.what == pendingMessage.message.what
+                  && (removedMessage.what == ANY_MESSAGE
+                      || removedMessage.what == pendingMessage.message.what)
                   && (removedMessage.object == null
                       || removedMessage.object == pendingMessage.message.obj)
                   && pendingMessage.sequenceNumber < removedMessage.sequenceNumber) {
@@ -179,6 +181,15 @@ public void removeMessages(Handler handler, int what, Object object) {
         ((CustomLooper) shadowOf(looper)).removeMessages(handler, what, object);
       }
     }
+
+    @Implementation
+    public void removeCallbacksAndMessages(Handler handler, Object object) {
+      Looper looper = ShadowLooper.getLooperForThread(looperThread);
+      if (shadowOf(looper) instanceof CustomLooper
+          && shadowOf(looper) != ShadowLooper.getShadowMainLooper()) {
+        ((CustomLooper) shadowOf(looper)).removeMessages(handler, ANY_MESSAGE, object);
+      }
+    }
   }
 
   private static final class PendingMessage implements Comparable<PendingMessage> {
