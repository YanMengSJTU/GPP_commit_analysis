diff --git a/.gitignore b/.gitignore
index 8ad7cdb8d0..ea082245c5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,10 +41,13 @@ proguard-project.txt
 dist
 tmp
 
-# VP9 Extension
+# VP9 extension
 extensions/vp9/src/main/jni/libvpx
 extensions/vp9/src/main/jni/libvpx_android_configs
 extensions/vp9/src/main/jni/libyuv
 
-# Opus Extension
+# Opus extension
 extensions/opus/src/main/jni/libopus
+
+# FLAC extension
+extensions/flac/src/main/jni/flac
diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
deleted file mode 100644
index e173978184..0000000000
--- a/ISSUE_TEMPLATE
+++ /dev/null
@@ -1,8 +0,0 @@
-Please search the existing issues before filing a new one, including issues that are closed. When filing a new issue please include all of the following, unless you're certain that they're not useful for the particular issue being reported.
-
-- A description of the issue.
-- Steps describing how the issue can be reproduced, ideally in the ExoPlayer demo app.
-- A link to content that reproduces the issue. If you don't wish to post it publicly, please submit the issue, then email the link to dev.exoplayer@gmail.com including the issue number in the subject line.
-- The version of ExoPlayer being used.
-- The device(s) and version(s) of Android on which the issue can be reproduced, and how easily it reproduces. If possible, please test on multiple devices and Android versions.
-- A bug report taken from the device just after the issue occurs, attached as a file. A bug report can be captured using "adb bugreport". Output from "adb logcat" or a log snippet is not sufficient.
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 8af8a83f8c..7325abae89 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,14 @@
 # Release notes #
 
+### r1.5.8 ###
+
+* HLS: Fix handling of HTTP redirects.
+* Audio: Minor adjustment to improve A/V sync.
+* OGG: Support FLAC in OGG.
+* TTML: Support regions.
+* WAV/PCM: Support 8, 24 and 32-bit WAV and PCM audio.
+* Misc bug fixes and performance optimizations.
+
 ### r1.5.7 ###
 
 * OGG: Support added for OGG.
@@ -96,6 +105,7 @@
 * TTML: Improved handling of whitespace.
 * DASH: Support Mpd.Location element.
 * Add option to TsExtractor to allow non-IDR keyframes.
+* Added MulticastDataSource for connecting to multicast streams.
 * (WorkInProgress) - First steps to supporting seeking in DASH DVR window.
 * (WorkInProgress) - First steps to supporting styled + positioned subtitles.
 * Misc bug fixes.
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 2d17093118..42a97407e1 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1507"
-    android:versionName="1.5.7"
+    android:versionCode="1508"
+    android:versionName="1.5.8"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index 6c6c62d9c5..a104cc04e4 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -732,13 +732,15 @@ public void setMediaPlayer(MediaController.MediaPlayerControl playerControl) {
     @Override
     public boolean dispatchKeyEvent(KeyEvent event) {
       int keyCode = event.getKeyCode();
-      if (playerControl.canSeekForward() && keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
+      if (playerControl.canSeekForward() && (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
+          || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT)) {
         if (event.getAction() == KeyEvent.ACTION_DOWN) {
           playerControl.seekTo(playerControl.getCurrentPosition() + 15000); // milliseconds
           show();
         }
         return true;
-      } else if (playerControl.canSeekBackward() && keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
+      } else if (playerControl.canSeekBackward() && (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
+          || keyCode == KeyEvent.KEYCODE_DPAD_LEFT)) {
         if (event.getAction() == KeyEvent.ACTION_DOWN) {
           playerControl.seekTo(playerControl.getCurrentPosition() - 5000); // milliseconds
           show();
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index b9c34fe595..198b37b9a3 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -91,7 +91,6 @@ public void cancel() {
 
     private final Context context;
     private final String userAgent;
-    private final String url;
     private final DemoPlayer player;
     private final ManifestFetcher<HlsPlaylist> playlistFetcher;
 
@@ -100,7 +99,6 @@ public void cancel() {
     public AsyncRendererBuilder(Context context, String userAgent, String url, DemoPlayer player) {
       this.context = context;
       this.userAgent = userAgent;
-      this.url = url;
       this.player = player;
       HlsPlaylistParser parser = new HlsPlaylistParser();
       playlistFetcher = new ManifestFetcher<>(url, new DefaultUriDataSource(context, userAgent),
@@ -145,8 +143,8 @@ public void onSingleManifest(HlsPlaylist manifest) {
 
       // Build the video/id3 renderers.
       DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, url,
-          manifest, DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter,
+      HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, manifest,
+          DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter,
           timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
       HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
           MAIN_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_VIDEO);
@@ -161,7 +159,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
       if (haveAudios) {
         DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
         HlsChunkSource audioChunkSource = new HlsChunkSource(false /* isMaster */, audioDataSource,
-            url, manifest, DefaultHlsTrackSelector.newAudioInstance(), bandwidthMeter,
+            manifest, DefaultHlsTrackSelector.newAudioInstance(), bandwidthMeter,
             timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
         HlsSampleSource audioSampleSource = new HlsSampleSource(audioChunkSource, loadControl,
             AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
@@ -181,7 +179,7 @@ public void onSingleManifest(HlsPlaylist manifest) {
       if (haveSubtitles) {
         DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
         HlsChunkSource textChunkSource = new HlsChunkSource(false /* isMaster */, textDataSource,
-            url, manifest, DefaultHlsTrackSelector.newSubtitleInstance(), bandwidthMeter,
+            manifest, DefaultHlsTrackSelector.newSubtitleInstance(), bandwidthMeter,
             timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
         HlsSampleSource textSampleSource = new HlsSampleSource(textChunkSource, loadControl,
             TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_TEXT);
diff --git a/demo_ext/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
index daced900c8..98acb700ea 100644
--- a/demo_ext/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.ext"
-    android:versionCode="1507"
-    android:versionName="1.5.7"
+    android:versionCode="1508"
+    android:versionName="1.5.8"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
index 2f361c3cd4..4982eb4fa6 100644
--- a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer.ext.vp9.VpxDecoderException;
 import com.google.android.exoplayer.ext.vp9.VpxVideoSurfaceView;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.ogg.OggExtractor;
 import com.google.android.exoplayer.extractor.webm.WebmExtractor;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
@@ -141,7 +142,7 @@ private void startBasicPlayback() {
         contentUri,
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
         new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
-        new WebmExtractor(), new FlacExtractor());
+        new WebmExtractor(), new FlacExtractor(), new OggExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index 7d6abc9c8b..8a5b295621 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -35,6 +35,7 @@ NDK_PATH="<path to Android NDK>"
 * Download and extract flac-1.3.1 as "${FLAC_EXT_PATH}/jni/flac" folder:
 
 ```
+cd "${FLAC_EXT_PATH}/jni" && \
 curl http://downloads.xiph.org/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
 mv flac-1.3.1 flac
 ```
diff --git a/extensions/flac/src/androidTest/.classpath b/extensions/flac/src/androidTest/.classpath
new file mode 100644
index 0000000000..370096f6ec
--- /dev/null
+++ b/extensions/flac/src/androidTest/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/ExoPlayerExt-Flac"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/flac/src/androidTest/.project b/extensions/flac/src/androidTest/.project
new file mode 100644
index 0000000000..7322c904ef
--- /dev/null
+++ b/extensions/flac/src/androidTest/.project
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-FlacTests</name>
+	<comment></comment>
+	<projects>
+		<project>ExoPlayerLib</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>0</id>
+			<name></name>
+			<type>14</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-true-false-BUILD</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..764b7e98d1
--- /dev/null
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer.ext.flac.test">
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+    <uses-library android:name="android.test.runner"/>
+  </application>
+
+  <instrumentation
+      android:targetPackage="com.google.android.exoplayer.ext.flac.test"
+      android:name="android.test.InstrumentationTestRunner"
+      tools:replace="android:targetPackage"/>
+
+</manifest>
diff --git a/extensions/flac/src/androidTest/assets/bear-flac.mka b/extensions/flac/src/androidTest/assets/bear-flac.mka
new file mode 100644
index 0000000000..457353d722
Binary files /dev/null and b/extensions/flac/src/androidTest/assets/bear-flac.mka differ
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer/ext/flac/FlacPlaybackTest.java
new file mode 100644
index 0000000000..079fdca00b
--- /dev/null
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer/ext/flac/FlacPlaybackTest.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.Util;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.Looper;
+import android.test.InstrumentationTestCase;
+
+/**
+ * Playback tests using {@link LibflacAudioTrackRenderer}.
+ */
+public class FlacPlaybackTest extends InstrumentationTestCase {
+
+  private static final String BEAR_FLAC_URI = "asset:///bear-flac.mka";
+
+  public void testBasicPlayback() throws ExoPlaybackException {
+    playUri(BEAR_FLAC_URI);
+  }
+
+  private void playUri(String uri) throws ExoPlaybackException {
+    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+        getInstrumentation().getContext());
+    thread.start();
+    try {
+      thread.join();
+    } catch (InterruptedException e) {
+      fail(); // Should never happen.
+    }
+    if (thread.playbackException != null) {
+      throw thread.playbackException;
+    }
+  }
+
+  private static class TestPlaybackThread extends Thread implements ExoPlayer.Listener {
+
+    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+    private static final int BUFFER_SEGMENT_COUNT = 16;
+
+    private final Context context;
+    private final Uri uri;
+
+    private ExoPlayer player;
+    private ExoPlaybackException playbackException;
+
+    public TestPlaybackThread(Uri uri, Context context) {
+      this.uri = uri;
+      this.context = context;
+    }
+
+    @Override
+    public void run() {
+      Looper.prepare();
+      player = ExoPlayer.Factory.newInstance(1);
+      player.addListener(this);
+      ExtractorSampleSource  sampleSource = new ExtractorSampleSource(
+          uri,
+          new DefaultUriDataSource(context, Util.getUserAgent(context, "ExoPlayerExtFlacTest")),
+          new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
+          new WebmExtractor());
+      LibflacAudioTrackRenderer audioRenderer = new LibflacAudioTrackRenderer(sampleSource);
+      player.prepare(audioRenderer);
+      player.setPlayWhenReady(true);
+      Looper.loop();
+    }
+
+    @Override
+    public void onPlayWhenReadyCommitted () {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException error) {
+      playbackException = error;
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == ExoPlayer.STATE_ENDED
+          || (playbackState == ExoPlayer.STATE_IDLE && playbackException != null)) {
+        releasePlayerAndQuitLooper();
+      }
+    }
+
+    private void releasePlayerAndQuitLooper() {
+      player.release();
+      Looper.myLooper().quit();
+    }
+
+  }
+
+}
diff --git a/extensions/flac/src/androidTest/project.properties b/extensions/flac/src/androidTest/project.properties
new file mode 100644
index 0000000000..916037e334
--- /dev/null
+++ b/extensions/flac/src/androidTest/project.properties
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
diff --git a/extensions/flac/src/androidTest/res/.README.txt b/extensions/flac/src/androidTest/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/extensions/flac/src/androidTest/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
index 7881b45ecd..b857a2c325 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.ext.flac;
 
 import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.FlacStreamInfo;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
 import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
@@ -74,7 +75,11 @@ protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
   }
 
   @Override
-  public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
+  public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer,
+      boolean reset) {
+    if (reset) {
+      decoder.flush();
+    }
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.limit(sampleHolder.data.position());
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
index 7090a36a1a..f4d763c29a 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.FlacStreamInfo;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
@@ -40,7 +41,8 @@
    */
   private static final byte[] FLAC_SIGNATURE = {'f', 'L', 'a', 'C', 0, 0, 0, 0x22};
 
-  private TrackOutput output;
+  private ExtractorOutput output;
+  private TrackOutput trackOutput;
 
   private FlacJni decoder;
 
@@ -49,25 +51,12 @@
   private ParsableByteArray outputBuffer;
   private ByteBuffer outputByteBuffer;
 
-  private boolean isSeekable;
-
   @Override
   public void init(ExtractorOutput output) {
-    this.output = output.track(0);
+    this.output = output;
+    this.trackOutput = output.track(0);
     output.endTracks();
 
-    output.seekMap(new SeekMap() {
-      @Override
-      public boolean isSeekable() {
-        return isSeekable;
-      }
-
-      @Override
-      public long getPosition(long timeUs) {
-        return isSeekable ? decoder.getSeekPosition(timeUs) : 0;
-      }
-    });
-
     try {
       decoder = new FlacJni();
     } catch (FlacDecoderException e) {
@@ -93,12 +82,25 @@ public int read(final ExtractorInput input, PositionHolder seekPosition)
         throw new IOException("Metadata decoding failed");
       }
       metadataParsed = true;
-      isSeekable = decoder.getSeekPosition(0) != -1;
+
+      output.seekMap(new SeekMap() {
+        final boolean isSeekable = decoder.getSeekPosition(0) != -1;
+
+        @Override
+        public boolean isSeekable() {
+          return isSeekable;
+        }
+
+        @Override
+        public long getPosition(long timeUs) {
+          return isSeekable ? decoder.getSeekPosition(timeUs) : 0;
+        }
+      });
 
       MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_RAW,
-              MediaFormat.NO_VALUE, streamInfo.bitRate(), streamInfo.durationUs(),
-              streamInfo.channels, streamInfo.sampleRate, null, null);
-      output.format(mediaFormat);
+              streamInfo.bitRate(), MediaFormat.NO_VALUE, streamInfo.durationUs(),
+              streamInfo.channels, streamInfo.sampleRate, null, null, C.ENCODING_PCM_16BIT);
+      trackOutput.format(mediaFormat);
 
       outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
       outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
@@ -109,9 +111,9 @@ public int read(final ExtractorInput input, PositionHolder seekPosition)
     if (size <= 0) {
       return RESULT_END_OF_INPUT;
     }
-    output.sampleData(outputBuffer, size);
+    trackOutput.sampleData(outputBuffer, size);
 
-    output.sampleMetadata(decoder.getLastSampleTimestamp(), C.SAMPLE_FLAG_SYNC, size, 0, null);
+    trackOutput.sampleMetadata(decoder.getLastSampleTimestamp(), C.SAMPLE_FLAG_SYNC, size, 0, null);
 
     return decoder.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
   }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
index 1c26909c26..c7b066869c 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.FlacStreamInfo;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index e1b07e2162..4e4692fd56 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.ext.flac;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
@@ -343,7 +344,8 @@ private boolean readFormat(long positionUs) {
     int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
-      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      audioTrack.configure(MimeTypes.AUDIO_RAW, format.channelCount, format.sampleRate,
+          C.ENCODING_PCM_16BIT);
       return true;
     }
     return false;
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index 7fe1887971..7b8cdf5bc9 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -89,7 +89,7 @@ FUNC(jobject, flacDecodeMetadata, jlong jContext) {
       context->parser->getStreamInfo();
 
   jclass cls = env->FindClass(
-      "com/google/android/exoplayer/ext/flac/"
+      "com/google/android/exoplayer/util/"
       "FlacStreamInfo");
   jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
 
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index b6658444cb..329288169a 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -267,6 +267,8 @@ FLACParser::FLACParser(DataSource *source)
     : mDataSource(source),
       mCopy(copyTrespass),
       mDecoder(NULL),
+      mSeekTable(NULL),
+      firstFrameOffset(0LL),
       mCurrentPos(0LL),
       mEOF(false),
       mStreamInfoValid(false),
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
index 9e69804c7a..743e428b7e 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
@@ -159,7 +159,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       responseByteStream = response.body().byteStream();
     } catch (IOException e) {
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec);
+          dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     int responseCode = response.code();
@@ -204,7 +204,7 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
       skipInternal();
       return readInternal(buffer, offset, readLength);
     } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec);
+      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
     }
   }
 
diff --git a/extensions/opus/src/androidTest/.classpath b/extensions/opus/src/androidTest/.classpath
new file mode 100644
index 0000000000..f0e3ea5223
--- /dev/null
+++ b/extensions/opus/src/androidTest/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<classpath>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/ExoPlayerExt-Opus"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/opus/src/androidTest/.project b/extensions/opus/src/androidTest/.project
new file mode 100644
index 0000000000..e3429833b6
--- /dev/null
+++ b/extensions/opus/src/androidTest/.project
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-OpusTests</name>
+	<comment></comment>
+	<projects>
+		<project>ExoPlayerLib</project>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>0</id>
+			<name></name>
+			<type>14</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-true-false-BUILD</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..7b1516a08a
--- /dev/null
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer.ext.opus.test">
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+    <uses-library android:name="android.test.runner"/>
+  </application>
+
+  <instrumentation
+      android:targetPackage="com.google.android.exoplayer.ext.opus.test"
+      android:name="android.test.InstrumentationTestRunner"
+      tools:replace="android:targetPackage"/>
+
+</manifest>
diff --git a/extensions/opus/src/androidTest/assets/bear-opus.webm b/extensions/opus/src/androidTest/assets/bear-opus.webm
new file mode 100644
index 0000000000..c198148814
Binary files /dev/null and b/extensions/opus/src/androidTest/assets/bear-opus.webm differ
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer/ext/opus/OpusPlaybackTest.java
new file mode 100644
index 0000000000..4ac85615ed
--- /dev/null
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer/ext/opus/OpusPlaybackTest.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.Util;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.Looper;
+import android.test.InstrumentationTestCase;
+
+/**
+ * Playback tests using {@link LibopusAudioTrackRenderer}.
+ */
+public class OpusPlaybackTest extends InstrumentationTestCase {
+
+  private static final String BEAR_OPUS_URI = "asset:///bear-opus.webm";
+
+  public void testBasicPlayback() throws ExoPlaybackException {
+    playUri(BEAR_OPUS_URI);
+  }
+
+  private void playUri(String uri) throws ExoPlaybackException {
+    TestPlaybackThread thread = new TestPlaybackThread(Uri.parse(uri),
+        getInstrumentation().getContext());
+    thread.start();
+    try {
+      thread.join();
+    } catch (InterruptedException e) {
+      fail(); // Should never happen.
+    }
+    if (thread.playbackException != null) {
+      throw thread.playbackException;
+    }
+  }
+
+  private static class TestPlaybackThread extends Thread implements ExoPlayer.Listener {
+
+    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+    private static final int BUFFER_SEGMENT_COUNT = 16;
+
+    private final Context context;
+    private final Uri uri;
+
+    private ExoPlayer player;
+    private ExoPlaybackException playbackException;
+
+    public TestPlaybackThread(Uri uri, Context context) {
+      this.uri = uri;
+      this.context = context;
+    }
+
+    @Override
+    public void run() {
+      Looper.prepare();
+      player = ExoPlayer.Factory.newInstance(1);
+      player.addListener(this);
+      ExtractorSampleSource  sampleSource = new ExtractorSampleSource(
+          uri,
+          new DefaultUriDataSource(context, Util.getUserAgent(context, "ExoPlayerExtOpusTest")),
+          new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
+          new WebmExtractor());
+      LibopusAudioTrackRenderer audioRenderer = new LibopusAudioTrackRenderer(sampleSource);
+      player.prepare(audioRenderer);
+      player.setPlayWhenReady(true);
+      Looper.loop();
+    }
+
+    @Override
+    public void onPlayWhenReadyCommitted () {
+      // Do nothing.
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException error) {
+      playbackException = error;
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == ExoPlayer.STATE_ENDED
+          || (playbackState == ExoPlayer.STATE_IDLE && playbackException != null)) {
+        releasePlayerAndQuitLooper();
+      }
+    }
+
+    private void releasePlayerAndQuitLooper() {
+      player.release();
+      Looper.myLooper().quit();
+    }
+
+  }
+
+}
diff --git a/extensions/opus/src/androidTest/project.properties b/extensions/opus/src/androidTest/project.properties
new file mode 100644
index 0000000000..916037e334
--- /dev/null
+++ b/extensions/opus/src/androidTest/project.properties
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
diff --git a/extensions/opus/src/androidTest/res/.README.txt b/extensions/opus/src/androidTest/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/extensions/opus/src/androidTest/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index ae337d1960..c67eed99ae 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
@@ -94,7 +95,6 @@
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean sourceIsReady;
-  private boolean notifyDiscontinuityToDecoder;
 
   private int audioSessionId;
 
@@ -274,10 +274,6 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       inputStreamEnded = true;
       return false;
     }
-    if (notifyDiscontinuityToDecoder) {
-      notifyDiscontinuityToDecoder = false;
-      inputBuffer.setFlag(Buffer.FLAG_RESET);
-    }
 
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
@@ -291,7 +287,6 @@ private void flushDecoder() {
       outputBuffer = null;
     }
     decoder.flush();
-    notifyDiscontinuityToDecoder = true;
   }
 
   @Override
@@ -361,7 +356,8 @@ private boolean readFormat(long positionUs) {
     int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
-      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      audioTrack.configure(MimeTypes.AUDIO_RAW, format.channelCount, format.sampleRate,
+          C.ENCODING_PCM_16BIT);
       return true;
     }
     return false;
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index 9ad75f9e62..d494d32b35 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -117,9 +117,9 @@ public OpusDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBu
         throw new OpusDecoderException("Invalid Codec Delay or Seek Preroll");
       }
       long codecDelayNs =
-          ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+          ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.nativeOrder()).getLong();
       long seekPreRollNs =
-          ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+          ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.nativeOrder()).getLong();
       headerSkipSamples = nsToSamples(codecDelayNs);
       headerSeekPreRollSamples = nsToSamples(seekPreRollNs);
     } else {
@@ -150,8 +150,9 @@ protected void releaseOutputBuffer(OpusOutputBuffer buffer) {
   }
 
   @Override
-  public OpusDecoderException decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
-    if (inputBuffer.getFlag(Buffer.FLAG_RESET)) {
+  public OpusDecoderException decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer,
+      boolean reset) {
+    if (reset) {
       opusReset(nativeDecoderContext);
       // When seeking to 0, skip number of samples as specified in opus header. When seeking to
       // any other time, skip number of samples as specified by seek preroll.
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 4f8c845db8..d645fde877 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -100,7 +100,8 @@ protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
   }
 
   @Override
-  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
+  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer,
+      boolean reset) {
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
diff --git a/library/build.gradle b/library/build.gradle
index a8580f2597..65f3ad2d60 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.7'
+    version = 'r1.5.8'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/assets/ttml/chain_multiple_styles.xml b/library/src/androidTest/assets/ttml/chain_multiple_styles.xml
index 7bcce6527d..307a44a507 100644
--- a/library/src/androidTest/assets/ttml/chain_multiple_styles.xml
+++ b/library/src/androidTest/assets/ttml/chain_multiple_styles.xml
@@ -1,7 +1,8 @@
-<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
-  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
-  xmlns="http://www.w3.org/ns/ttml"
-  xmlns="http://www.w3.org/2006/10/ttaf1">
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata"
+    xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+    xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+    xmlns="http://www.w3.org/ns/ttml"
+    xmlns="http://www.w3.org/2006/10/ttaf1">
   <head>
     <styling>
       <style id="s0"
diff --git a/library/src/androidTest/assets/ttml/font_size.xml b/library/src/androidTest/assets/ttml/font_size.xml
index adbb8d6926..a25fff1cf9 100644
--- a/library/src/androidTest/assets/ttml/font_size.xml
+++ b/library/src/androidTest/assets/ttml/font_size.xml
@@ -1,7 +1,8 @@
-<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
-  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
-  xmlns="http://www.w3.org/ns/ttml"
-  xmlns="http://www.w3.org/2006/10/ttaf1">
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata"
+    xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+    xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+    xmlns="http://www.w3.org/ns/ttml"
+    xmlns="http://www.w3.org/2006/10/ttaf1">
   <head>
     <styling>
       <style id="s0"
diff --git a/library/src/androidTest/assets/ttml/inherit_multiple_styles.xml b/library/src/androidTest/assets/ttml/inherit_multiple_styles.xml
index 3ee089c3ff..19ce4defc2 100644
--- a/library/src/androidTest/assets/ttml/inherit_multiple_styles.xml
+++ b/library/src/androidTest/assets/ttml/inherit_multiple_styles.xml
@@ -1,7 +1,8 @@
-<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
-  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
-  xmlns="http://www.w3.org/ns/ttml"
-  xmlns="http://www.w3.org/2006/10/ttaf1">
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata"
+    xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+    xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+    xmlns="http://www.w3.org/ns/ttml"
+    xmlns="http://www.w3.org/2006/10/ttaf1">
   <head>
     <styling>
       <style id="s0"
diff --git a/library/src/androidTest/assets/ttml/multiple_regions.xml b/library/src/androidTest/assets/ttml/multiple_regions.xml
new file mode 100644
index 0000000000..3bde2c99b5
--- /dev/null
+++ b/library/src/androidTest/assets/ttml/multiple_regions.xml
@@ -0,0 +1,29 @@
+<tt xmlns="http://www.w3.org/ns/ttml"
+    xmlns="http://www.w3.org/2006/10/ttaf1"
+    xmlns:id="http://www.w3.org/XML/1998/namespace"
+    xmlns:ttp="http://www.w3.org/ns/ttml#parameter"
+    xmlns:tts="http://www.w3.org/ns/ttml#styling"
+    xmlns:ttm="http://www.w3.org/ns/ttml#metadata">
+    <head>
+        <layout>
+            <region xml:id="region1" ttm:origin="10% 10%" extent="20% 20%"/>
+            <region xml:id="region2" ttm:origin="40% 40%" extent="20% 20%"/>
+            <region xml:id="region3" ttm:origin="10% 80%"/>
+            <region xml:id="region4" ttm:origin="60% 10%" extent="20% 20%"/>
+            <region xml:id="ultimate" ttm:origin="45% 45%" extent="35% 35%"/>
+        </layout>
+    </head>
+    <body>
+        <div>
+            <p begin="1s" end="4s" region="region1">lorem</p>
+            <p begin="5s" end="8s" region="region2">ipsum</p>
+            <p begin="9s" end="18s" region="region3">dolor</p>
+            <p begin="1s" end="4s" region="region4">amet</p>
+        </div>
+        <div region="ultimate">
+            <p begin="21s" end="34s">She first said this</p>
+            <p begin="25s" end="34s">Then this</p>
+            <p begin="29s" end="34s">Finally this</p>
+        </div>
+    </body>
+</tt>
diff --git a/library/src/androidTest/assets/ttml/namespace_confusion.xml b/library/src/androidTest/assets/ttml/namespace_confusion.xml
deleted file mode 100644
index 5b9025cd94..0000000000
--- a/library/src/androidTest/assets/ttml/namespace_confusion.xml
+++ /dev/null
@@ -1,17 +0,0 @@
-<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" 
-    xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
-    xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
-    xmlns="http://www.w3.org/ns/ttml"
-    xmlns="http://www.w3.org/2006/10/ttaf1">
-  <body>
-    <div>
-      <p begin="10s" end="18s"
-          tts:backgroundColor="black"
-          abc:fontFamily="sansSerif"
-          def:fontStyle="italic"
-          ghi:textDecoration="lineThrough"
-          jkl:color="yellow">text 1</p>
-    </div>
-  </body>
-</tt>
-
diff --git a/library/src/androidTest/assets/ttml/namespace_not_declared.xml b/library/src/androidTest/assets/ttml/namespace_not_declared.xml
deleted file mode 100644
index 25e8369a34..0000000000
--- a/library/src/androidTest/assets/ttml/namespace_not_declared.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<tt>
-  <body>
-    <div>
-      <p begin="10s" end="18s"
-          tts:backgroundColor="black"
-          abc:fontFamily="sansSerif"
-          def:fontStyle="italic"
-          ghi:textDecoration="lineThrough"
-          jkl:color="yellow">text 1</p>
-    </div>
-  </body>
-</tt>
-
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
index c3270298a7..04025d2ae4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -15,16 +15,19 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.os.Parcel;
 
 import junit.framework.TestCase;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -32,31 +35,49 @@
  */
 public final class MediaFormatTest extends TestCase {
 
-  public void testConversionToFrameworkFormat() {
-    if (Util.SDK_INT < 16) {
-      // Test doesn't apply.
-      return;
-    }
-
+  private static final List<byte[]> INIT_DATA;
+  static {
     byte[] initData1 = new byte[] {1, 2, 3};
     byte[] initData2 = new byte[] {4, 5, 6};
     List<byte[]> initData = new ArrayList<>();
     initData.add(initData1);
     initData.add(initData2);
+    INIT_DATA = Collections.unmodifiableList(initData);
+  }
+
+  public void testParcelable() {
+    MediaFormat formatToParcel = new MediaFormat("id", MimeTypes.VIDEO_H264, 1024, 2048,
+        C.UNKNOWN_TIME_US, 1920, 1080, 90, 2, 6, 44100, "und", MediaFormat.OFFSET_SAMPLE_RELATIVE,
+        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004);
+
+    Parcel parcel = Parcel.obtain();
+    formatToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    MediaFormat formatFromParcel = MediaFormat.CREATOR.createFromParcel(parcel);
+    assertEquals(formatToParcel, formatFromParcel);
+
+    parcel.recycle();
+  }
+
+  public void testConversionToFrameworkFormat() {
+    if (Util.SDK_INT < 16) {
+      // Test doesn't apply.
+      return;
+    }
 
-    testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(
-        null, "video/xyz", 5000, 102400, 1000L, 1280, 720, initData));
-    testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(
-        null, "video/xyz", 5000, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 1280, 720, null));
-    testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(
-        null, "audio/xyz", 500, 128, 1000L, 5, 44100, initData, null));
-    testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(
-        null, "audio/xyz", 500, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 5, 44100, null, null));
-    testConversionToFrameworkFormatV16(
-        MediaFormat.createTextFormat(null, "text/xyz", MediaFormat.NO_VALUE, 1000L, "eng"));
-    testConversionToFrameworkFormatV16(
-        MediaFormat.createTextFormat(null, "text/xyz", MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US,
-        null));
+    testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(null, "video/xyz", 5000,
+        102400, 1000L, 1280, 720, INIT_DATA));
+    testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(null, "video/xyz", 5000,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 1280, 720, null));
+    testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(null, "audio/xyz", 500, 128,
+        1000L, 5, 44100, INIT_DATA, null));
+    testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(null, "audio/xyz", 500,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 5, 44100, null, null));
+    testConversionToFrameworkFormatV16(MediaFormat.createTextFormat(null, "text/xyz",
+        MediaFormat.NO_VALUE, 1000L, "eng"));
+    testConversionToFrameworkFormatV16(MediaFormat.createTextFormat(null, "text/xyz",
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, null));
   }
 
   @SuppressLint("InlinedApi")
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggExtractorTest.java
new file mode 100644
index 0000000000..f75ffc08cf
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggExtractorTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer.testutil.TestUtil;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+
+/**
+ * Unit test for {@link OggExtractor}.
+ */
+public final class OggExtractorTest extends TestCase {
+
+  private OggExtractor extractor;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    extractor = new OggExtractor();
+  }
+
+  public void testSniffVorbis() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertTrue(sniff(createInput(data)));
+  }
+
+  public void testSniffFlac() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x7F, 'F', 'L', 'A', 'C', ' ', ' '});
+    assertTrue(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsOpusFile() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x00),
+        new byte[]{'O', 'p', 'u', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsInvalidOggHeader() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x00, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffInvalidHeader() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x7F, 'X', 'o', 'r', 'b', 'i', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsEOF() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x02, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  private static FakeExtractorInput createInput(byte[] data) {
+    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
+  }
+
+  private boolean sniff(FakeExtractorInput input) throws InterruptedException, IOException {
+    while (true) {
+      try {
+        return extractor.sniff(input);
+      } catch (SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggParserTest.java
similarity index 83%
rename from library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggParserTest.java
index f1270aeb2f..ebacfee144 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggParserTest.java
@@ -31,19 +31,19 @@
 import java.util.Random;
 
 /**
- * Unit test for {@link OggReader}.
+ * Unit test for {@link OggParser}.
  */
-public final class OggReaderTest extends TestCase {
+public final class OggParserTest extends TestCase {
 
   private Random random;
-  private OggReader oggReader;
+  private OggParser oggParser;
   private ParsableByteArray scratch;
 
   @Override
   public void setUp() throws Exception {
     super.setUp();
     random = new Random(0);
-    oggReader = new OggReader();
+    oggParser = new OggParser();
     scratch = new ParsableByteArray(new byte[255 * 255], 0);
   }
 
@@ -72,37 +72,37 @@ public void testReadPacketsWithEmptyPage() throws Exception {
             fourthPacket), true);
 
     assertReadPacket(input, firstPacket);
-    assertTrue((oggReader.getPageHeader().type & 0x02) == 0x02);
-    assertFalse((oggReader.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(0x02, oggReader.getPageHeader().type);
-    assertEquals(27 + 1, oggReader.getPageHeader().headerSize);
-    assertEquals(8, oggReader.getPageHeader().bodySize);
-    assertEquals(0x00, oggReader.getPageHeader().revision);
-    assertEquals(1, oggReader.getPageHeader().pageSegmentCount);
-    assertEquals(1000, oggReader.getPageHeader().pageSequenceNumber);
-    assertEquals(4096, oggReader.getPageHeader().streamSerialNumber);
-    assertEquals(0, oggReader.getPageHeader().granulePosition);
+    assertTrue((oggParser.getPageHeader().type & 0x02) == 0x02);
+    assertFalse((oggParser.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(0x02, oggParser.getPageHeader().type);
+    assertEquals(27 + 1, oggParser.getPageHeader().headerSize);
+    assertEquals(8, oggParser.getPageHeader().bodySize);
+    assertEquals(0x00, oggParser.getPageHeader().revision);
+    assertEquals(1, oggParser.getPageHeader().pageSegmentCount);
+    assertEquals(1000, oggParser.getPageHeader().pageSequenceNumber);
+    assertEquals(4096, oggParser.getPageHeader().streamSerialNumber);
+    assertEquals(0, oggParser.getPageHeader().granulePosition);
 
     assertReadPacket(input, secondPacket);
-    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
-    assertFalse((oggReader.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(0, oggReader.getPageHeader().type);
-    assertEquals(27 + 2, oggReader.getPageHeader().headerSize);
-    assertEquals(255 + 17, oggReader.getPageHeader().bodySize);
-    assertEquals(2, oggReader.getPageHeader().pageSegmentCount);
-    assertEquals(1001, oggReader.getPageHeader().pageSequenceNumber);
-    assertEquals(16, oggReader.getPageHeader().granulePosition);
+    assertFalse((oggParser.getPageHeader().type & 0x02) == 0x02);
+    assertFalse((oggParser.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(0, oggParser.getPageHeader().type);
+    assertEquals(27 + 2, oggParser.getPageHeader().headerSize);
+    assertEquals(255 + 17, oggParser.getPageHeader().bodySize);
+    assertEquals(2, oggParser.getPageHeader().pageSegmentCount);
+    assertEquals(1001, oggParser.getPageHeader().pageSequenceNumber);
+    assertEquals(16, oggParser.getPageHeader().granulePosition);
 
     assertReadPacket(input, thirdPacket);
-    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
-    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(4, oggReader.getPageHeader().type);
-    assertEquals(27 + 4, oggReader.getPageHeader().headerSize);
-    assertEquals(255 + 1 + 255 + 16, oggReader.getPageHeader().bodySize);
-    assertEquals(4, oggReader.getPageHeader().pageSegmentCount);
+    assertFalse((oggParser.getPageHeader().type & 0x02) == 0x02);
+    assertTrue((oggParser.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(4, oggParser.getPageHeader().type);
+    assertEquals(27 + 4, oggParser.getPageHeader().headerSize);
+    assertEquals(255 + 1 + 255 + 16, oggParser.getPageHeader().bodySize);
+    assertEquals(4, oggParser.getPageHeader().pageSegmentCount);
     // Page 1002 is empty, so current page is 1003.
-    assertEquals(1003, oggReader.getPageHeader().pageSequenceNumber);
-    assertEquals(128, oggReader.getPageHeader().granulePosition);
+    assertEquals(1003, oggParser.getPageHeader().pageSequenceNumber);
+    assertEquals(128, oggParser.getPageHeader().granulePosition);
 
     assertReadPacket(input, fourthPacket);
 
@@ -140,9 +140,9 @@ public void testReadContinuedPacketOverTwoPages() throws Exception {
             Arrays.copyOfRange(firstPacket, 510, 510 + 8)), true);
 
     assertReadPacket(input, firstPacket);
-    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
-    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
-    assertEquals(1001, oggReader.getPageHeader().pageSequenceNumber);
+    assertTrue((oggParser.getPageHeader().type & 0x04) == 0x04);
+    assertFalse((oggParser.getPageHeader().type & 0x02) == 0x02);
+    assertEquals(1001, oggParser.getPageHeader().pageSequenceNumber);
 
     assertReadEof(input);
   }
@@ -170,9 +170,9 @@ public void testReadContinuedPacketOverFourPages() throws Exception {
             Arrays.copyOfRange(firstPacket, 510 + 255 + 255, 510 + 255 + 255 + 8)), true);
 
     assertReadPacket(input, firstPacket);
-    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
-    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
-    assertEquals(1003, oggReader.getPageHeader().pageSequenceNumber);
+    assertTrue((oggParser.getPageHeader().type & 0x04) == 0x04);
+    assertFalse((oggParser.getPageHeader().type & 0x02) == 0x02);
+    assertEquals(1003, oggParser.getPageHeader().pageSequenceNumber);
 
     assertReadEof(input);
   }
@@ -281,7 +281,7 @@ private void skipToPageOfGranule(ExtractorInput input, long granule,
       long elapsedSamplesExpected) throws IOException, InterruptedException {
     while (true) {
       try {
-        assertEquals(elapsedSamplesExpected, oggReader.skipToPageOfGranule(input, granule));
+        assertEquals(elapsedSamplesExpected, oggParser.skipToPageOfGranule(input, granule));
         return;
       } catch (FakeExtractorInput.SimulatedIOException e) {
         input.resetPeekPosition();
@@ -330,7 +330,7 @@ private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
       throws IOException, InterruptedException {
     while (true) {
       try {
-        assertEquals(expected, oggReader.readGranuleOfLastPage(input));
+        assertEquals(expected, oggParser.readGranuleOfLastPage(input));
         break;
       } catch (FakeExtractorInput.SimulatedIOException e) {
         // ignored
@@ -355,7 +355,7 @@ private boolean readPacket(FakeExtractorInput input, ParsableByteArray scratch)
       throws InterruptedException, IOException {
     while (true) {
       try {
-        return oggReader.readPacket(input, scratch);
+        return oggParser.readPacket(input, scratch);
       } catch (FakeExtractorInput.SimulatedIOException e) {
         // Ignore.
       }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisReaderTest.java
similarity index 63%
rename from library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisReaderTest.java
index 46f59200c3..a085372d2b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisReaderTest.java
@@ -15,10 +15,9 @@
  */
 package com.google.android.exoplayer.extractor.ogg;
 
-import com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor.VorbisSetup;
+import com.google.android.exoplayer.extractor.ogg.VorbisReader.VorbisSetup;
 import com.google.android.exoplayer.testutil.FakeExtractorInput;
 import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
-import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import junit.framework.TestCase;
@@ -26,57 +25,24 @@
 import java.io.IOException;
 
 /**
- * Unit test for {@link OggVorbisExtractor}.
+ * Unit test for {@link VorbisReader}.
  */
-public final class OggVorbisExtractorTest extends TestCase {
+public final class VorbisReaderTest extends TestCase {
 
-  private OggVorbisExtractor extractor;
+  private VorbisReader extractor;
   private ParsableByteArray scratch;
 
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    extractor = new OggVorbisExtractor();
+    extractor = new VorbisReader();
     scratch = new ParsableByteArray(new byte[255 * 255], 0);
   }
 
-  public void testSniff() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
-        TestUtil.createByteArray(120, 120),  // Laces
-        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
-    assertTrue(sniff(createInput(data)));
-  }
-
-  public void testSniffFailsOpusFile() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 0x00),
-        new byte[]{'O', 'p', 'u', 's'});
-    assertFalse(sniff(createInput(data)));
-  }
-
-  public void testSniffFailsInvalidOggHeader() throws Exception {
-    byte[] data = TestData.buildOggHeader(0x00, 0, 1000, 0x00);
-    assertFalse(sniff(createInput(data)));
-  }
-
-  public void testSniffInvalidVorbisHeader() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
-        TestUtil.createByteArray(120, 120),  // Laces
-        new byte[]{0x01, 'X', 'o', 'r', 'b', 'i', 's'});
-    assertFalse(sniff(createInput(data)));
-  }
-
-  public void testSniffFailsEOF() throws Exception {
-    byte[] data = TestData.buildOggHeader(0x02, 0, 1000, 0x00);
-    assertFalse(sniff(createInput(data)));
-  }
-
   public void testAppendNumberOfSamples() throws Exception {
     ParsableByteArray buffer = new ParsableByteArray(4);
     buffer.setLimit(0);
-    OggVorbisExtractor.appendNumberOfSamples(buffer, 0x01234567);
+    VorbisReader.appendNumberOfSamples(buffer, 0x01234567);
     assertEquals(4, buffer.limit());
     assertEquals(0x67, buffer.data[0]);
     assertEquals(0x45, buffer.data[1]);
@@ -86,7 +52,7 @@ public void testAppendNumberOfSamples() throws Exception {
 
   public void testReadSetupHeadersWithIOExceptions() throws IOException, InterruptedException {
     byte[] data = TestData.getVorbisHeaderPages();
-    OggVorbisExtractor.VorbisSetup vorbisSetup = readSetupHeaders(createInput(data));
+    VorbisReader.VorbisSetup vorbisSetup = readSetupHeaders(createInput(data));
 
     assertNotNull(vorbisSetup.idHeader);
     assertNotNull(vorbisSetup.commentHeader);
@@ -122,16 +88,6 @@ private static FakeExtractorInput createInput(byte[] data) {
         .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
   }
 
-  private boolean sniff(FakeExtractorInput input) throws InterruptedException, IOException {
-    while (true) {
-      try {
-        return extractor.sniff(input);
-      } catch (SimulatedIOException e) {
-        // Ignore.
-      }
-    }
-  }
-
   private VorbisSetup readSetupHeaders(FakeExtractorInput input)
       throws IOException, InterruptedException {
     while (true) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
index 206feabed4..bcb326e3c7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -742,9 +742,9 @@ private void assertAudioFormat(int trackNumber, int timecodeScale, String expect
       android.test.MoreAsserts.assertEquals(TEST_OPUS_CODEC_PRIVATE,
           format.initializationData.get(0));
       assertEquals(TEST_CODEC_DELAY, ByteBuffer.wrap(format.initializationData.get(1))
-          .order(ByteOrder.LITTLE_ENDIAN).getLong());
+          .order(ByteOrder.nativeOrder()).getLong());
       assertEquals(TEST_SEEK_PRE_ROLL, ByteBuffer.wrap(format.initializationData.get(2))
-          .order(ByteOrder.LITTLE_ENDIAN).getLong());
+          .order(ByteOrder.nativeOrder()).getLong());
     } else if (MimeTypes.AUDIO_VORBIS.equals(expectedMimeType)) {
       assertEquals(2, format.initializationData.size());
       assertEquals(TEST_VORBIS_INFO_SIZE, format.initializationData.get(0).length);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
index 64423c33f8..63b5852a2b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
@@ -41,32 +41,22 @@
  */
 public final class TtmlParserTest extends InstrumentationTestCase {
 
-  private static final String INLINE_ATTRIBUTES_TTML_FILE =
-      "ttml/inline_style_attributes.xml";
-  private static final String INHERIT_STYLE_TTML_FILE =
-      "ttml/inherit_style.xml";
+  private static final String INLINE_ATTRIBUTES_TTML_FILE = "ttml/inline_style_attributes.xml";
+  private static final String INHERIT_STYLE_TTML_FILE = "ttml/inherit_style.xml";
   private static final String INHERIT_STYLE_OVERRIDE_TTML_FILE =
       "ttml/inherit_and_override_style.xml";
   private static final String INHERIT_GLOBAL_AND_PARENT_TTML_FILE =
       "ttml/inherit_global_and_parent.xml";
   private static final String INHERIT_MULTIPLE_STYLES_TTML_FILE =
       "ttml/inherit_multiple_styles.xml";
-  private static final String CHAIN_MULTIPLE_STYLES_TTML_FILE =
-      "ttml/chain_multiple_styles.xml";
+  private static final String CHAIN_MULTIPLE_STYLES_TTML_FILE = "ttml/chain_multiple_styles.xml";
+  private static final String MULTIPLE_REGIONS_TTML_FILE = "ttml/multiple_regions.xml";
   private static final String NO_UNDERLINE_LINETHROUGH_TTML_FILE =
       "ttml/no_underline_linethrough.xml";
-  private static final String NAMESPACE_CONFUSION_TTML_FILE =
-      "ttml/namespace_confusion.xml";
-  private static final String NAMESPACE_NOT_DECLARED_TTML_FILE =
-      "ttml/namespace_not_declared.xml";
-  private static final String FONT_SIZE_TTML_FILE =
-      "ttml/font_size.xml";
-  private static final String FONT_SIZE_MISSING_UNIT_TTML_FILE =
-      "ttml/font_size_no_unit.xml";
-  private static final String FONT_SIZE_INVALID_TTML_FILE =
-      "ttml/font_size_invalid.xml";
-  private static final String FONT_SIZE_EMPTY_TTML_FILE =
-      "ttml/font_size_empty.xml";
+  private static final String FONT_SIZE_TTML_FILE = "ttml/font_size.xml";
+  private static final String FONT_SIZE_MISSING_UNIT_TTML_FILE = "ttml/font_size_no_unit.xml";
+  private static final String FONT_SIZE_INVALID_TTML_FILE = "ttml/font_size_invalid.xml";
+  private static final String FONT_SIZE_EMPTY_TTML_FILE = "ttml/font_size_empty.xml";
 
   public void testInlineAttributes() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
@@ -77,7 +67,7 @@ public void testInlineAttributes() throws IOException {
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode firstDiv = queryChildrenForTag(body, TtmlNode.TAG_DIV, 0);
     TtmlStyle firstPStyle = queryChildrenForTag(firstDiv, TtmlNode.TAG_P, 0).style;
-    assertEquals(TtmlColorParser.parseColor("yellow"), firstPStyle.getColor());
+    assertEquals(TtmlColorParser.parseColor("yellow"), firstPStyle.getFontColor());
     assertEquals(TtmlColorParser.parseColor("blue"), firstPStyle.getBackgroundColor());
     assertEquals("serif", firstPStyle.getFontFamily());
     assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, firstPStyle.getStyle());
@@ -92,29 +82,28 @@ public void testInheritInlineAttributes() throws IOException {
   }
 
   /**
-   * regression test for devices on JellyBean where some named colors are not correctly defined
+   * Regression test for devices on JellyBean where some named colors are not correctly defined
    * on framework level. Tests that <i>lime</i> resolves to <code>#FF00FF00</code> not
    * <code>#00FF00</code>.
    *
-   * See: https://github.com/android/platform_frameworks_base/blob/jb-mr2-release/
-   *          graphics/java/android/graphics/Color.java#L414
-   *      https://github.com/android/platform_frameworks_base/blob/kitkat-mr2.2-release/
-   *          graphics/java/android/graphics/Color.java#L414
-   *
+   * @see <a href="https://github.com/android/platform_frameworks_base/blob/jb-mr2-release/graphics/java/android/graphics/Color.java#L414">
+   *     JellyBean Color</a>
+   *     <a href="https://github.com/android/platform_frameworks_base/blob/kitkat-mr2.2-release/graphics/java/android/graphics/Color.java#L414">
+   *     Kitkat Color</a>
    * @throws IOException thrown if reading subtitle file fails.
    */
   public void testLime() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
     assertEquals(4, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_ITALIC,
-        TtmlColorParser.CYAN, TtmlColorParser.LIME, false, true, null);
+    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_ITALIC, TtmlColorParser.CYAN,
+        TtmlColorParser.LIME, false, true, null);
   }
 
   public void testInheritGlobalStyle() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_STYLE_TTML_FILE);
     assertEquals(2, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 10, "text 1", "serif", TtmlStyle.STYLE_BOLD_ITALIC,
-        TtmlColorParser.BLUE, TtmlColorParser.YELLOW, true, false, null);
+    assertSpans(subtitle, 10, "text 1", "serif", TtmlStyle.STYLE_BOLD_ITALIC, TtmlColorParser.BLUE,
+        TtmlColorParser.YELLOW, true, false, null);
   }
 
   public void testInheritGlobalStyleOverriddenByInlineAttributes() throws IOException {
@@ -131,11 +120,10 @@ public void testInheritGlobalAndParent() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_GLOBAL_AND_PARENT_TTML_FILE);
     assertEquals(4, subtitle.getEventTimeCount());
 
-    assertSpans(subtitle, 10, "text 1", "sansSerif", TtmlStyle.STYLE_NORMAL,
-        TtmlColorParser.RED, TtmlColorParser.parseColor("lime"), false, true,
-        Layout.Alignment.ALIGN_CENTER);
-    assertSpans(subtitle, 20, "text 2", "serif", TtmlStyle.STYLE_BOLD_ITALIC,
-        TtmlColorParser.BLUE, TtmlColorParser.YELLOW, true, true, Layout.Alignment.ALIGN_CENTER);
+    assertSpans(subtitle, 10, "text 1", "sansSerif", TtmlStyle.STYLE_NORMAL, TtmlColorParser.RED,
+        TtmlColorParser.parseColor("lime"), false, true, Layout.Alignment.ALIGN_CENTER);
+    assertSpans(subtitle, 20, "text 2", "serif", TtmlStyle.STYLE_BOLD_ITALIC, TtmlColorParser.BLUE,
+        TtmlColorParser.YELLOW, true, true, Layout.Alignment.ALIGN_CENTER);
   }
 
   public void testInheritMultipleStyles() throws IOException {
@@ -149,7 +137,6 @@ public void testInheritMultipleStyles() throws IOException {
   public void testInheritMultipleStylesWithoutLocalAttributes() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
     assertEquals(12, subtitle.getEventTimeCount());
-
     assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_BOLD_ITALIC,
         TtmlColorParser.BLUE, TtmlColorParser.BLACK, false, true, null);
 
@@ -158,11 +145,60 @@ public void testInheritMultipleStylesWithoutLocalAttributes() throws IOException
   public void testMergeMultipleStylesWithParentStyle() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
     assertEquals(12, subtitle.getEventTimeCount());
-
     assertSpans(subtitle, 30, "text 2.5", "sansSerifInline", TtmlStyle.STYLE_ITALIC,
         TtmlColorParser.RED, TtmlColorParser.YELLOW, true, true, null);
   }
 
+  public void testMultipleRegions() throws IOException {
+    TtmlSubtitle subtitle = getSubtitle(MULTIPLE_REGIONS_TTML_FILE);
+    List<Cue> output = subtitle.getCues(1000000);
+    assertEquals(2, output.size());
+    Cue ttmlCue = output.get(0);
+    assertEquals("lorem", ttmlCue.text.toString());
+    assertEquals(10.f / 100.f, ttmlCue.position);
+    assertEquals(10.f / 100.f, ttmlCue.line);
+    assertEquals(20.f / 100.f, ttmlCue.size);
+
+    ttmlCue = output.get(1);
+    assertEquals("amet", ttmlCue.text.toString());
+    assertEquals(60.f / 100.f, ttmlCue.position);
+    assertEquals(10.f / 100.f, ttmlCue.line);
+    assertEquals(20.f / 100.f, ttmlCue.size);
+
+    output = subtitle.getCues(5000000);
+    assertEquals(1, output.size());
+    ttmlCue = output.get(0);
+    assertEquals("ipsum", ttmlCue.text.toString());
+    assertEquals(40.f / 100.f, ttmlCue.position);
+    assertEquals(40.f / 100.f, ttmlCue.line);
+    assertEquals(20.f / 100.f, ttmlCue.size);
+
+    output = subtitle.getCues(9000000);
+    assertEquals(1, output.size());
+    ttmlCue = output.get(0);
+    assertEquals("dolor", ttmlCue.text.toString());
+    assertEquals(10.f / 100.f, ttmlCue.position);
+    assertEquals(80.f / 100.f, ttmlCue.line);
+    assertEquals(Cue.DIMEN_UNSET, ttmlCue.size);
+
+    output = subtitle.getCues(21000000);
+    assertEquals(1, output.size());
+    ttmlCue = output.get(0);
+    assertEquals("She first said this", ttmlCue.text.toString());
+    assertEquals(45.f / 100.f, ttmlCue.position);
+    assertEquals(45.f / 100.f, ttmlCue.line);
+    assertEquals(35.f / 100.f, ttmlCue.size);
+    output = subtitle.getCues(25000000);
+    ttmlCue = output.get(0);
+    assertEquals("She first said this\nThen this", ttmlCue.text.toString());
+    output = subtitle.getCues(29000000);
+    assertEquals(1, output.size());
+    ttmlCue = output.get(0);
+    assertEquals("She first said this\nThen this\nFinally this", ttmlCue.text.toString());
+    assertEquals(45.f / 100.f, ttmlCue.position);
+    assertEquals(45.f / 100.f, ttmlCue.line);
+  }
+
   public void testEmptyStyleAttribute() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
     assertEquals(12, subtitle.getEventTimeCount());
@@ -206,13 +242,13 @@ public void testMultipleChaining() throws IOException {
     TtmlStyle style = globalStyles.get("s2");
     assertEquals("serif", style.getFontFamily());
     assertEquals(TtmlColorParser.RED, style.getBackgroundColor());
-    assertEquals(TtmlColorParser.BLACK, style.getColor());
+    assertEquals(TtmlColorParser.BLACK, style.getFontColor());
     assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
     assertTrue(style.isLinethrough());
 
     style = globalStyles.get("s3");
     // only difference: color must be RED
-    assertEquals(TtmlColorParser.RED, style.getColor());
+    assertEquals(TtmlColorParser.RED, style.getFontColor());
     assertEquals("serif", style.getFontFamily());
     assertEquals(TtmlColorParser.RED, style.getBackgroundColor());
     assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
@@ -244,43 +280,6 @@ public void testNoLinethrough() throws IOException {
         style.isLinethrough());
   }
 
-  public void testNamspaceConfusionDoesNotHurt() throws IOException {
-    TtmlSubtitle subtitle = getSubtitle(NAMESPACE_CONFUSION_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
-
-    TtmlNode root = subtitle.getRoot();
-    TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
-    TtmlNode div = queryChildrenForTag(body, TtmlNode.TAG_DIV, 0);
-    TtmlStyle style = queryChildrenForTag(div, TtmlNode.TAG_P, 0).style;
-
-    assertNotNull(style);
-    assertEquals(TtmlColorParser.BLACK, style.getBackgroundColor());
-    assertEquals(TtmlColorParser.YELLOW, style.getColor());
-    assertEquals(TtmlStyle.STYLE_ITALIC, style.getStyle());
-    assertEquals("sansSerif", style.getFontFamily());
-    assertFalse(style.isUnderline());
-    assertTrue(style.isLinethrough());
-
-  }
-
-  public void testNamespaceNotDeclared() throws IOException {
-    TtmlSubtitle subtitle = getSubtitle(NAMESPACE_NOT_DECLARED_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
-
-    TtmlNode root = subtitle.getRoot();
-    TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
-    TtmlNode div = queryChildrenForTag(body, TtmlNode.TAG_DIV, 0);
-    TtmlStyle style = queryChildrenForTag(div, TtmlNode.TAG_P, 0).style;
-
-    assertNotNull(style);
-    assertEquals(TtmlColorParser.BLACK, style.getBackgroundColor());
-    assertEquals(TtmlColorParser.YELLOW, style.getColor());
-    assertEquals(TtmlStyle.STYLE_ITALIC, style.getStyle());
-    assertEquals("sansSerif", style.getFontFamily());
-    assertFalse(style.isUnderline());
-    assertTrue(style.isLinethrough());
-  }
-
   public void testFontSizeSpans() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_TTML_FILE);
     assertEquals(10, subtitle.getEventTimeCount());
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtilTest.java
index bdfeda663b..b55b658c8a 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtilTest.java
@@ -48,7 +48,7 @@ public void testResolveStyleMultipleReferentialStyles() {
     // inherited from s0
     assertEquals(Color.BLACK, resolved.getBackgroundColor());
     // inherited from s1
-    assertEquals(Color.RED, resolved.getColor());
+    assertEquals(Color.RED, resolved.getFontColor());
     // merged from s0 and s1
     assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, resolved.getStyle());
   }
@@ -101,7 +101,7 @@ public void testResolveStyleOnlyInlineStyle() {
     TtmlStyle s1 = new TtmlStyle();
     s1.setId("s1");
     s1.setBackgroundColor(Color.RED);
-    s1.setColor(Color.RED);
+    s1.setFontColor(Color.RED);
     s1.setItalic(true);
     globalStyles.put(s1.getId(), s1);
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
index 12f6a9fe9a..60aa0b2307 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
@@ -42,8 +42,8 @@ public void testInheritStyle() {
         assertTrue(style.isLinethrough());
         assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
         assertEquals(FONT_FAMILY, style.getFontFamily());
-        assertEquals(Color.WHITE, style.getColor());
-        assertFalse("do not inherit backgroundColor", style.hasBackgroundColorSpecified());
+        assertEquals(Color.WHITE, style.getFontColor());
+        assertFalse("do not inherit backgroundColor", style.hasBackgroundColor());
     }
 
     public void testChainStyle() {
@@ -53,7 +53,7 @@ public void testChainStyle() {
         assertTrue(style.isLinethrough());
         assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
         assertEquals(FONT_FAMILY, style.getFontFamily());
-        assertEquals(FOREGROUND_COLOR, style.getColor());
+        assertEquals(FOREGROUND_COLOR, style.getFontColor());
         // do inherit backgroundColor when chaining
         assertEquals("do not inherit backgroundColor when chaining",
             BACKGROUND_COLOR, style.getBackgroundColor());
@@ -65,7 +65,7 @@ private TtmlStyle createAncestorStyle() {
         ancestor.setItalic(true);
         ancestor.setBold(true);
         ancestor.setBackgroundColor(BACKGROUND_COLOR);
-        ancestor.setColor(FOREGROUND_COLOR);
+        ancestor.setFontColor(FOREGROUND_COLOR);
         ancestor.setLinethrough(true);
         ancestor.setUnderline(true);
         ancestor.setFontFamily(FONT_FAMILY);
@@ -109,17 +109,17 @@ public void testFontFamily() {
     }
 
     public void testColor() {
-        assertFalse(style.hasColorSpecified());
-        style.setColor(Color.BLACK);
-        assertEquals(Color.BLACK, style.getColor());
-        assertTrue(style.hasColorSpecified());
+        assertFalse(style.hasFontColor());
+        style.setFontColor(Color.BLACK);
+        assertEquals(Color.BLACK, style.getFontColor());
+        assertTrue(style.hasFontColor());
     }
 
     public void testBackgroundColor() {
-        assertFalse(style.hasBackgroundColorSpecified());
+        assertFalse(style.hasBackgroundColor());
         style.setBackgroundColor(Color.BLACK);
         assertEquals(Color.BLACK, style.getBackgroundColor());
-        assertTrue(style.hasBackgroundColorSpecified());
+        assertTrue(style.hasBackgroundColor());
     }
 
     public void testId() {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java
index 2444dcca6f..b6cbada748 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/Mp4WebvttParserTest.java
@@ -20,14 +20,12 @@
 import com.google.android.exoplayer.text.Subtitle;
 import com.google.android.exoplayer.util.Util;
 
-import android.util.ArraySet;
-
 import junit.framework.TestCase;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Set;
 
 /**
  * Unit test for {@link Mp4WebvttParser}.
@@ -139,7 +137,7 @@ private static void assertMp4WebvttSubtitleEquals(Subtitle sub, Cue... expectedC
     List<Cue> subtitleCues = sub.getCues(0);
     assertEquals(expectedCues.length, subtitleCues.size());
     for (int i = 0; i < subtitleCues.size(); i++) {
-      Set<String> differences = getCueDifferences(subtitleCues.get(i), expectedCues[i]);
+      List<String> differences = getCueDifferences(subtitleCues.get(i), expectedCues[i]);
       assertTrue("Cues at position " + i + " are not equal. Different fields are "
           + Arrays.toString(differences.toArray()), differences.isEmpty());
     }
@@ -150,10 +148,10 @@ private static void assertMp4WebvttSubtitleEquals(Subtitle sub, Cue... expectedC
    *
    * @return a set that contains the names of the different fields.
    */
-  private static Set<String> getCueDifferences(Cue aCue, Cue anotherCue) {
+  private static List<String> getCueDifferences(Cue aCue, Cue anotherCue) {
     assertNotNull(aCue);
     assertNotNull(anotherCue);
-    Set<String> differences = new ArraySet<>();
+    List<String> differences = new ArrayList<>();
     if (aCue.line != anotherCue.line) {
       differences.add("line: " + aCue.line + " | " + anotherCue.line);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 622da04caf..8a8a9c3dd1 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -58,6 +58,31 @@
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
 
+  /**
+   * @see AudioFormat#ENCODING_INVALID
+   */
+  public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
+
+  /**
+   * @see AudioFormat#ENCODING_PCM_8BIT
+   */
+  public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
+
+  /**
+   * @see AudioFormat#ENCODING_PCM_16BIT
+   */
+  public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
+
+  /**
+   * PCM encoding with 24 bits per sample.
+   */
+  public static final int ENCODING_PCM_24BIT = 0x80000000;
+
+  /**
+   * PCM encoding with 32 bits per sample.
+   */
+  public static final int ENCODING_PCM_32BIT = 0x40000000;
+
   /**
    * @see AudioFormat#ENCODING_AC3
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/DecoderInfo.java b/library/src/main/java/com/google/android/exoplayer/DecoderInfo.java
index 440148a556..7d061575ef 100644
--- a/library/src/main/java/com/google/android/exoplayer/DecoderInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/DecoderInfo.java
@@ -15,9 +15,15 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.media.MediaCodecInfo.CodecCapabilities;
+
 /**
  * Contains information about a media decoder.
  */
+@TargetApi(16)
 public final class DecoderInfo {
 
   /**
@@ -28,6 +34,11 @@
    */
   public final String name;
 
+  /**
+   * {@link CodecCapabilities} for this decoder.
+   */
+  public final CodecCapabilities capabilities;
+
   /**
    * Whether the decoder supports seamless resolution switches.
    *
@@ -38,11 +49,21 @@
 
   /**
    * @param name The name of the decoder.
-   * @param adaptive Whether the decoder is adaptive.
+   * @param capabilities {@link CodecCapabilities} of the decoder.
    */
-  /* package */ DecoderInfo(String name, boolean adaptive) {
+  /* package */ DecoderInfo(String name, CodecCapabilities capabilities) {
     this.name = name;
-    this.adaptive = adaptive;
+    this.capabilities = capabilities;
+    this.adaptive = isAdaptive(capabilities);
+  }
+
+  private static boolean isAdaptive(CodecCapabilities capabilities) {
+    return capabilities != null && Util.SDK_INT >= 19 && isAdaptiveV19(capabilities);
+  }
+
+  @TargetApi(19)
+  private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
+    return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 2c36a09b9a..cf3717df6e 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,15 +23,16 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.7";
+  public static final String VERSION = "1.5.8";
 
   /**
    * The version of the library, expressed as an integer.
    * <p>
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
-   * corresponding integer version 001002003.
+   * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
+   * integer version 123045006 (123-045-006).
    */
-  public static final int VERSION_INT = 001005007;
+  public static final int VERSION_INT = 1005008;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index b7a16768f9..fce7aa611c 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -326,10 +326,12 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     }
     long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
         ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
+    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+        : MediaFormat.NO_VALUE;
     MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, encoderDelay, encoderPadding);
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index d61d5410bb..55cecdc367 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -91,6 +91,7 @@
 
   private boolean passthroughEnabled;
   private android.media.MediaFormat passthroughMediaFormat;
+  private int pcmEncoding;
   private int audioSessionId;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
@@ -224,7 +225,7 @@ protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector, Stri
       String passthroughDecoderName = mediaCodecSelector.getPassthroughDecoderName();
       if (passthroughDecoderName != null) {
         passthroughEnabled = true;
-        return new DecoderInfo(passthroughDecoderName, false);
+        return new DecoderInfo(passthroughDecoderName, null);
       }
     }
     passthroughEnabled = false;
@@ -265,9 +266,24 @@ protected MediaClock getMediaClock() {
   }
 
   @Override
-  protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
+  protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlaybackException {
+    super.onInputFormatChanged(holder);
+    // If the input format is anything other than PCM then we assume that the audio decoder will
+    // output 16-bit PCM.
+    pcmEncoding = MimeTypes.AUDIO_RAW.equals(holder.format.mimeType) ? holder.format.pcmEncoding
+        : C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean passthrough = passthroughMediaFormat != null;
-    audioTrack.configure(passthrough ? passthroughMediaFormat : outputFormat, passthrough);
+    String mimeType = passthrough
+        ? passthroughMediaFormat.getString(android.media.MediaFormat.KEY_MIME)
+        : MimeTypes.AUDIO_RAW;
+    android.media.MediaFormat format = passthrough ? passthroughMediaFormat : outputFormat;
+    int channelCount = format.getInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT);
+    int sampleRate = format.getInteger(android.media.MediaFormat.KEY_SAMPLE_RATE);
+    audioTrack.configure(mimeType, channelCount, sampleRate, pcmEncoding);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index a8e9c84aa1..d11255bfd1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -775,10 +775,11 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
    * <p>
    * The default implementation is a no-op.
    *
+   * @param codec The {@link MediaCodec} instance.
    * @param outputFormat The new output format.
    * @throws ExoPlaybackException If an error occurs on output format change.
    */
-  protected void onOutputFormatChanged(android.media.MediaFormat outputFormat)
+  protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat)
       throws ExoPlaybackException {
     // Do nothing.
   }
@@ -934,7 +935,7 @@ private void processOutputFormat() throws ExoPlaybackException {
     if (codecNeedsMonoChannelCountWorkaround) {
       format.setInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT, 1);
     }
-    onOutputFormatChanged(format);
+    onOutputFormatChanged(codec, format);
     codecCounters.outputFormatChangedCount++;
   }
 
@@ -1055,7 +1056,8 @@ private static boolean codecNeedsDiscardToSpsWorkaround(String name, MediaFormat
    *     propagation incorrectly on the host device. False otherwise.
    */
   private static boolean codecNeedsEosPropagationWorkaround(String name) {
-    return Util.SDK_INT <= 17 && "OMX.rk.video_decoder.avc".equals(name);
+    return Util.SDK_INT <= 17 && ("OMX.rk.video_decoder.avc".equals(name)
+        || "OMX.allwinner.video.decoder.avc".equals(name));
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index e3cd5b7e6c..abd97b22cf 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -26,10 +26,13 @@
 import android.media.MediaCodecList;
 import android.text.TextUtils;
 import android.util.Log;
-import android.util.Pair;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 /**
  * A utility class for querying the available codecs.
@@ -53,7 +56,10 @@ private DecoderQueryException(Throwable cause) {
 
   private static final String TAG = "MediaCodecUtil";
 
-  private static final HashMap<CodecKey, Pair<String, CodecCapabilities>> codecs = new HashMap<>();
+  private static final Map<CodecKey, List<DecoderInfo>> decoderInfosCache = new HashMap<>();
+
+  // Lazily initialized.
+  private static int maxH264DecodableFrameSize = -1;
 
   private MediaCodecUtil() {}
 
@@ -67,11 +73,8 @@ private MediaCodecUtil() {}
    */
   public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
       throws DecoderQueryException {
-    Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
-    if (info == null) {
-      return null;
-    }
-    return new DecoderInfo(info.first, isAdaptive(info.second));
+    List<DecoderInfo> decoderInfos = getDecoderInfos(mimeType, secure);
+    return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
   }
 
   /**
@@ -83,9 +86,9 @@ public static DecoderInfo getDecoderInfo(String mimeType, boolean secure)
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
    */
-  public static synchronized void warmCodec(String mimeType, boolean secure) {
+  public static void warmCodec(String mimeType, boolean secure) {
     try {
-      getMediaCodecInfo(mimeType, secure);
+      getDecoderInfos(mimeType, secure);
     } catch (DecoderQueryException e) {
       // Codec warming is best effort, so we can swallow the exception.
       Log.e(TAG, "Codec warming failed", e);
@@ -93,87 +96,74 @@ public static synchronized void warmCodec(String mimeType, boolean secure) {
   }
 
   /**
-   * Returns the name of the best decoder and its capabilities for the given mimeType.
+   * Returns all @{link DecoderInfo}s for the given mime type, in the order given by MediaCodecList.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @return The name of the best decoder and its capabilities for the given mimeType, or null if
-   *     no decoder exists.
+   * @return A list of all @{link DecoderInfo}s for the given mime type,
    */
-  public static synchronized Pair<String, CodecCapabilities> getMediaCodecInfo(
-      String mimeType, boolean secure) throws DecoderQueryException {
+  public static synchronized List<DecoderInfo> getDecoderInfos(String mimeType, boolean secure)
+      throws DecoderQueryException {
     CodecKey key = new CodecKey(mimeType, secure);
-    if (codecs.containsKey(key)) {
-      return codecs.get(key);
+    List<DecoderInfo> decoderInfos = decoderInfosCache.get(key);
+    if (decoderInfos != null) {
+      return decoderInfos;
     }
     MediaCodecListCompat mediaCodecList = Util.SDK_INT >= 21
         ? new MediaCodecListCompatV21(secure) : new MediaCodecListCompatV16();
-    Pair<String, CodecCapabilities> codecInfo = getMediaCodecInfo(key, mediaCodecList);
-    if (secure && codecInfo == null && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
+    decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
+    if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
       // TODO: Verify that the issue cannot occur on API levels 22 and 23, and tighten this block
       // to execute on API level 21 only if confirmed.
       mediaCodecList = new MediaCodecListCompatV16();
-      codecInfo = getMediaCodecInfo(key, mediaCodecList);
-      if (codecInfo != null) {
+      decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
+      if (!decoderInfos.isEmpty()) {
         Log.w(TAG, "MediaCodecList API didn't list secure decoder for: " + mimeType
-            + ". Assuming: " + codecInfo.first);
+            + ". Assuming: " + decoderInfos.get(0).name);
       }
     }
-    return codecInfo;
+    decoderInfos = Collections.unmodifiableList(decoderInfos);
+    decoderInfosCache.put(key, decoderInfos);
+    return decoderInfos;
   }
 
-  private static Pair<String, CodecCapabilities> getMediaCodecInfo(CodecKey key,
-      MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
+  private static List<DecoderInfo> getDecoderInfosInternal(
+      CodecKey key, MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
     try {
-      return getMediaCodecInfoInternal(key, mediaCodecList);
-    } catch (Exception e) {
-      // If the underlying mediaserver is in a bad state, we may catch an IllegalStateException
-      // or an IllegalArgumentException here.
-      throw new DecoderQueryException(e);
-    }
-  }
-
-  private static Pair<String, CodecCapabilities> getMediaCodecInfoInternal(CodecKey key,
-      MediaCodecListCompat mediaCodecList) {
-    String mimeType = key.mimeType;
-    int numberOfCodecs = mediaCodecList.getCodecCount();
-    boolean secureDecodersExplicit = mediaCodecList.secureDecodersExplicit();
-    // Note: MediaCodecList is sorted by the framework such that the best decoders come first.
-    for (int i = 0; i < numberOfCodecs; i++) {
-      MediaCodecInfo info = mediaCodecList.getCodecInfoAt(i);
-      String codecName = info.getName();
-      if (isCodecUsableDecoder(info, codecName, secureDecodersExplicit)) {
-        String[] supportedTypes = info.getSupportedTypes();
-        for (int j = 0; j < supportedTypes.length; j++) {
-          String supportedType = supportedTypes[j];
-          if (supportedType.equalsIgnoreCase(mimeType)) {
-            CodecCapabilities capabilities = info.getCapabilitiesForType(supportedType);
-            boolean secure = mediaCodecList.isSecurePlaybackSupported(key.mimeType, capabilities);
-            if (!secureDecodersExplicit) {
-              // Cache variants for both insecure and (if we think it's supported) secure playback.
-              codecs.put(key.secure ? new CodecKey(mimeType, false) : key,
-                  Pair.create(codecName, capabilities));
-              if (secure) {
-                codecs.put(key.secure ? key : new CodecKey(mimeType, true),
-                    Pair.create(codecName + ".secure", capabilities));
+      List<DecoderInfo> decoderInfos = new ArrayList<>();
+      String mimeType = key.mimeType;
+      int numberOfCodecs = mediaCodecList.getCodecCount();
+      boolean secureDecodersExplicit = mediaCodecList.secureDecodersExplicit();
+      // Note: MediaCodecList is sorted by the framework such that the best decoders come first.
+      for (int i = 0; i < numberOfCodecs; i++) {
+        MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
+        String codecName = codecInfo.getName();
+        if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit)) {
+          for (String supportedType : codecInfo.getSupportedTypes()) {
+            if (supportedType.equalsIgnoreCase(mimeType)) {
+              CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(supportedType);
+              boolean secure = mediaCodecList.isSecurePlaybackSupported(mimeType, capabilities);
+              if ((secureDecodersExplicit && key.secure == secure)
+                  || (!secureDecodersExplicit && !key.secure)) {
+                decoderInfos.add(new DecoderInfo(codecName, capabilities));
+              } else if (!secureDecodersExplicit && secure) {
+                decoderInfos.add(new DecoderInfo(codecName + ".secure", capabilities));
+                // It only makes sense to have one synthesized secure decoder, return immediately.
+                return decoderInfos;
               }
-            } else {
-              // Only cache this variant. If both insecure and secure decoders are available, they
-              // should both be listed separately.
-              codecs.put(key.secure == secure ? key : new CodecKey(mimeType, secure),
-                  Pair.create(codecName, capabilities));
-            }
-            if (codecs.containsKey(key)) {
-              return codecs.get(key);
             }
           }
         }
       }
+      return decoderInfos;
+    } catch (Exception e) {
+      // If the underlying mediaserver is in a bad state, we may catch an IllegalStateException
+      // or an IllegalArgumentException here.
+      throw new DecoderQueryException(e);
     }
-    return null;
   }
 
   /**
@@ -194,7 +184,7 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
             || "MP3Decoder".equals(name)) {
       return false;
     }
-    if (Util.SDK_INT == 16 && "OMX.SEC.MP3.Decoder".equals(name)) {
+    if (Util.SDK_INT < 18 && "OMX.SEC.MP3.Decoder".equals(name)) {
       return false;
     }
 
@@ -234,19 +224,6 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
     return true;
   }
 
-  private static boolean isAdaptive(CodecCapabilities capabilities) {
-    if (Util.SDK_INT >= 19) {
-      return isAdaptiveV19(capabilities);
-    } else {
-      return false;
-    }
-  }
-
-  @TargetApi(19)
-  private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
-    return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
-  }
-
   /**
    * Tests whether the device advertises it can decode video of a given type at a specified width
    * and height.
@@ -295,22 +272,20 @@ public static boolean isSizeAndRateSupportedV21(String mimeType, boolean secure,
    * @param profile An AVC profile constant from {@link CodecProfileLevel}.
    * @param level An AVC profile level from {@link CodecProfileLevel}.
    * @return Whether the specified profile is supported at the specified level.
+   * @deprecated Prefer {@link #getDecoderInfos(String, boolean)} for new code.
    */
+  @Deprecated
   public static boolean isH264ProfileSupported(int profile, int level)
       throws DecoderQueryException {
-    Pair<String, CodecCapabilities> info = getMediaCodecInfo(MimeTypes.VIDEO_H264, false);
-    if (info == null) {
+    DecoderInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
+    if (decoderInfo == null) {
       return false;
     }
-
-    CodecCapabilities capabilities = info.second;
-    for (int i = 0; i < capabilities.profileLevels.length; i++) {
-      CodecProfileLevel profileLevel = capabilities.profileLevels[i];
+    for (CodecProfileLevel profileLevel : decoderInfo.capabilities.profileLevels) {
       if (profileLevel.profile == profile && profileLevel.level >= level) {
         return true;
       }
     }
-
     return false;
   }
 
@@ -318,30 +293,24 @@ public static boolean isH264ProfileSupported(int profile, int level)
    * @return the maximum frame size for an H264 stream that can be decoded on the device.
    */
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
-    Pair<String, CodecCapabilities> info = getMediaCodecInfo(MimeTypes.VIDEO_H264, false);
-    if (info == null) {
-      return 0;
-    }
-
-    int maxH264DecodableFrameSize = 0;
-    CodecCapabilities capabilities = info.second;
-    for (int i = 0; i < capabilities.profileLevels.length; i++) {
-      CodecProfileLevel profileLevel = capabilities.profileLevels[i];
-      maxH264DecodableFrameSize = Math.max(
-          avcLevelToMaxFrameSize(profileLevel.level), maxH264DecodableFrameSize);
+    if (maxH264DecodableFrameSize == -1) {
+      int result = 0;
+      DecoderInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
+      if (decoderInfo != null) {
+        for (CodecProfileLevel profileLevel : decoderInfo.capabilities.profileLevels) {
+          result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
+        }
+      }
+      maxH264DecodableFrameSize = result;
     }
-
     return maxH264DecodableFrameSize;
   }
 
   @TargetApi(21)
   private static MediaCodecInfo.VideoCapabilities getVideoCapabilitiesV21(String mimeType,
       boolean secure) throws DecoderQueryException {
-    Pair<String, CodecCapabilities> info = getMediaCodecInfo(mimeType, secure);
-    if (info == null) {
-      return null;
-    }
-    return info.second.getVideoCapabilities();
+    DecoderInfo decoderInfo = getDecoderInfo(mimeType, secure);
+    return decoderInfo == null ? null : decoderInfo.capabilities.getVideoCapabilities();
   }
 
   /**
@@ -377,25 +346,25 @@ private static int avcLevelToMaxFrameSize(int avcLevel) {
     /**
      * The number of codecs in the list.
      */
-    public int getCodecCount();
+    int getCodecCount();
 
     /**
      * The info at the specified index in the list.
      *
      * @param index The index.
      */
-    public MediaCodecInfo getCodecInfoAt(int index);
+    MediaCodecInfo getCodecInfoAt(int index);
 
     /**
      * @return Returns whether secure decoders are explicitly listed, if present.
      */
-    public boolean secureDecodersExplicit();
+    boolean secureDecodersExplicit();
 
     /**
      * Whether secure playback is supported for the given {@link CodecCapabilities}, which should
      * have been obtained from a {@link MediaCodecInfo} obtained from this list.
      */
-    public boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capabilities);
+    boolean isSecurePlaybackSupported(String mimeType, CodecCapabilities capabilities);
 
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index 4152391310..fa2e684e88 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -326,7 +326,6 @@ protected void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
       android.media.MediaFormat format, MediaCrypto crypto) {
     maybeSetMaxInputSize(format, codecIsAdaptive);
     codec.configure(format, surface, crypto, 0);
-    codec.setVideoScalingMode(videoScalingMode);
   }
 
   @Override
@@ -346,7 +345,7 @@ protected final boolean haveRenderedFirstFrame() {
   }
 
   @Override
-  protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
+  protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
         && outputFormat.containsKey(KEY_CROP_LEFT) && outputFormat.containsKey(KEY_CROP_BOTTOM)
         && outputFormat.containsKey(KEY_CROP_TOP);
@@ -371,6 +370,8 @@ protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
       // On API level 20 and below the decoder does not apply the rotation.
       currentUnappliedRotationDegrees = pendingRotationDegrees;
     }
+    // Must be applied each time the output format changes.
+    codec.setVideoScalingMode(videoScalingMode);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index b39ff7da95..846a778718 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -21,8 +21,11 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.os.Parcel;
+import android.os.Parcelable;
 
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -30,7 +33,7 @@
 /**
  * Defines the format of an elementary media stream.
  */
-public final class MediaFormat {
+public final class MediaFormat implements Parcelable {
 
   public static final int NO_VALUE = -1;
 
@@ -119,6 +122,12 @@
    * The audio sampling rate in Hz, or {@link #NO_VALUE} if unknown or not applicable.
    */
   public final int sampleRate;
+  /**
+   * The encoding for PCM audio streams. If {@link #mimeType} is {@link MimeTypes#AUDIO_RAW} then
+   * one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT}
+   * and {@link C#ENCODING_PCM_32BIT}. Set to {@link #NO_VALUE} for other media types.
+   */
+  public final int pcmEncoding;
   /**
    * The number of samples to trim from the start of the decoded audio stream.
    */
@@ -158,15 +167,22 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int channelCount, int sampleRate,
       List<byte[]> initializationData, String language) {
+    return createAudioFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, channelCount,
+        sampleRate, initializationData, language, NO_VALUE);
+  }
+
+  public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
+      int maxInputSize, long durationUs, int channelCount, int sampleRate,
+      List<byte[]> initializationData, String language, int pcmEncoding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -179,21 +195,21 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
       long durationUs, List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createId3Format() {
@@ -201,11 +217,35 @@ public static MediaFormat createId3Format() {
         C.UNKNOWN_TIME_US);
   }
 
+  /* package */ MediaFormat(Parcel in) {
+    trackId = in.readString();
+    mimeType = in.readString();
+    bitrate = in.readInt();
+    maxInputSize = in.readInt();
+    durationUs = in.readLong();
+    width = in.readInt();
+    height = in.readInt();
+    rotationDegrees = in.readInt();
+    pixelWidthHeightRatio = in.readFloat();
+    channelCount = in.readInt();
+    sampleRate = in.readInt();
+    language = in.readString();
+    subsampleOffsetUs = in.readLong();
+    initializationData = new ArrayList<>();
+    in.readList(initializationData, null);
+    adaptive = in.readInt() == 1;
+    maxWidth = in.readInt();
+    maxHeight = in.readInt();
+    pcmEncoding = in.readInt();
+    encoderDelay = in.readInt();
+    encoderPadding = in.readInt();
+  }
+
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
-      int encoderDelay, int encoderPadding) {
+      int pcmEncoding, int encoderDelay, int encoderPadding) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -224,6 +264,7 @@ public static MediaFormat createId3Format() {
     this.adaptive = adaptive;
     this.maxWidth = maxWidth;
     this.maxHeight = maxHeight;
+    this.pcmEncoding = pcmEncoding;
     this.encoderDelay = encoderDelay;
     this.encoderPadding = encoderPadding;
   }
@@ -231,57 +272,57 @@ public static MediaFormat createId3Format() {
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithLanguage(String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
       String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight, NO_VALUE, NO_VALUE);
+        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   /**
@@ -332,8 +373,8 @@ public String toString() {
     return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitrate + ", " + maxInputSize
         + ", " + width + ", " + height + ", " + rotationDegrees + ", " + pixelWidthHeightRatio
         + ", " + channelCount + ", " + sampleRate + ", " + language + ", " + durationUs + ", "
-        + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + encoderDelay + ", "
-        + encoderPadding + ")";
+        + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + pcmEncoding + ", " + encoderDelay
+        + ", " + encoderPadding + ")";
   }
 
   @Override
@@ -352,11 +393,13 @@ public int hashCode() {
       result = 31 * result + (adaptive ? 1231 : 1237);
       result = 31 * result + maxWidth;
       result = 31 * result + maxHeight;
-      result = 31 * result + encoderDelay;
-      result = 31 * result + encoderPadding;
       result = 31 * result + channelCount;
       result = 31 * result + sampleRate;
+      result = 31 * result + pcmEncoding;
+      result = 31 * result + encoderDelay;
+      result = 31 * result + encoderPadding;
       result = 31 * result + (language == null ? 0 : language.hashCode());
+      result = 31 * result + (int) subsampleOffsetUs;
       for (int i = 0; i < initializationData.size(); i++) {
         result = 31 * result + Arrays.hashCode(initializationData.get(i));
       }
@@ -375,12 +418,13 @@ public boolean equals(Object obj) {
     }
     MediaFormat other = (MediaFormat) obj;
     if (adaptive != other.adaptive || bitrate != other.bitrate || maxInputSize != other.maxInputSize
-        || width != other.width || height != other.height
+        || durationUs != other.durationUs || width != other.width || height != other.height
         || rotationDegrees != other.rotationDegrees
         || pixelWidthHeightRatio != other.pixelWidthHeightRatio
         || maxWidth != other.maxWidth || maxHeight != other.maxHeight
-        || encoderDelay != other.encoderDelay || encoderPadding != other.encoderPadding
         || channelCount != other.channelCount || sampleRate != other.sampleRate
+        || pcmEncoding != other.pcmEncoding || encoderDelay != other.encoderDelay
+        || encoderPadding != other.encoderPadding || subsampleOffsetUs != other.subsampleOffsetUs
         || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
         || initializationData.size() != other.initializationData.size()) {
@@ -410,4 +454,49 @@ private static final void maybeSetIntegerV16(android.media.MediaFormat format, S
     }
   }
 
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(trackId);
+    dest.writeString(mimeType);
+    dest.writeInt(bitrate);
+    dest.writeInt(maxInputSize);
+    dest.writeLong(durationUs);
+    dest.writeInt(width);
+    dest.writeInt(height);
+    dest.writeInt(rotationDegrees);
+    dest.writeFloat(pixelWidthHeightRatio);
+    dest.writeInt(channelCount);
+    dest.writeInt(sampleRate);
+    dest.writeString(language);
+    dest.writeLong(subsampleOffsetUs);
+    dest.writeList(initializationData);
+    dest.writeInt(adaptive ? 1 : 0);
+    dest.writeInt(maxWidth);
+    dest.writeInt(maxHeight);
+    dest.writeInt(pcmEncoding);
+    dest.writeInt(encoderDelay);
+    dest.writeInt(encoderPadding);
+  }
+
+  public static final Creator<MediaFormat> CREATOR = new Creator<MediaFormat>() {
+
+    @Override
+    public MediaFormat createFromParcel(Parcel in) {
+      return new MediaFormat(in);
+    }
+
+    @Override
+    public MediaFormat[] newArray(int size) {
+      return new MediaFormat[size];
+    }
+
+  };
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 34b5db935a..a38846fdaa 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -26,7 +26,6 @@
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.AudioTimestamp;
-import android.media.MediaFormat;
 import android.media.PlaybackParams;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
@@ -57,7 +56,6 @@
  * <p>
  * Call {@link #release()} when the instance will no longer be used.
  */
-@TargetApi(16)
 public final class AudioTrack {
 
   /**
@@ -201,7 +199,8 @@ public InvalidAudioTrackTimestampException(String message) {
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
-  private int encoding;
+  private int sourceEncoding;
+  private int targetEncoding;
   private boolean passthrough;
   private int pcmFrameSize;
   private int bufferSize;
@@ -228,6 +227,9 @@ public InvalidAudioTrackTimestampException(String message) {
   private int temporaryBufferOffset;
   private int bufferBytesRemaining;
 
+  private ByteBuffer resampledBuffer;
+  private boolean useResampledBuffer;
+
   /**
    * Creates an audio track with default audio capabilities (no encoded audio passthrough support).
    */
@@ -333,26 +335,33 @@ public long getCurrentPositionUs(boolean sourceEnded) {
   }
 
   /**
-   * Configures (or reconfigures) the audio track to play back media in {@code format}, inferring a
-   * buffer size from the format.
+   * Configures (or reconfigures) the audio track, inferring a suitable buffer size automatically.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to play back using a passthrough encoding.
+   * @param mimeType The mime type.
+   * @param channelCount The number of channels.
+   * @param sampleRate The sample rate in Hz.
+   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}.
    */
-  public void configure(MediaFormat format, boolean passthrough) {
-    configure(format, passthrough, 0);
+  public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding) {
+    configure(mimeType, channelCount, sampleRate, pcmEncoding, 0);
   }
 
   /**
-   * Configures (or reconfigures) the audio track to play back media in {@code format}.
+   * Configures (or reconfigures) the audio track.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to play back using a passthrough encoding.
-   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
-   *     size inferred from the format.
+   * @param mimeType The mime type.
+   * @param channelCount The number of channels.
+   * @param sampleRate The sample rate in Hz.
+   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
+   *     suitable buffer size automatically.
    */
-  public void configure(MediaFormat format, boolean passthrough, int specifiedBufferSize) {
-    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
+  public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding,
+      int specifiedBufferSize) {
     int channelConfig;
     switch (channelCount) {
       case 1:
@@ -382,38 +391,48 @@ public void configure(MediaFormat format, boolean passthrough, int specifiedBuff
       default:
         throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
     }
-    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
-    String mimeType = format.getString(MediaFormat.KEY_MIME);
-    int encoding = passthrough ? getEncodingForMimeType(mimeType) : AudioFormat.ENCODING_PCM_16BIT;
-    if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
-        && this.encoding == encoding) {
-      // We already have an audio track with the correct sample rate, encoding and channel config.
+
+    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
+    int sourceEncoding;
+    if (passthrough) {
+      sourceEncoding = getEncodingForMimeType(mimeType);
+    } else if (pcmEncoding == C.ENCODING_PCM_8BIT || pcmEncoding == C.ENCODING_PCM_16BIT
+        || pcmEncoding == C.ENCODING_PCM_24BIT || pcmEncoding == C.ENCODING_PCM_32BIT) {
+      sourceEncoding = pcmEncoding;
+    } else {
+      throw new IllegalArgumentException("Unsupported PCM encoding: " + pcmEncoding);
+    }
+
+    if (isInitialized() && this.sourceEncoding == sourceEncoding && this.sampleRate == sampleRate
+        && this.channelConfig == channelConfig) {
+      // We already have an audio track with the correct sample rate, channel config and encoding.
       return;
     }
 
     reset();
 
-    this.encoding = encoding;
+    this.sourceEncoding = sourceEncoding;
     this.passthrough = passthrough;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
-    pcmFrameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
+    targetEncoding = passthrough ? sourceEncoding : C.ENCODING_PCM_16BIT;
+    pcmFrameSize = 2 * channelCount; // 2 bytes per 16-bit sample * number of channels.
 
     if (specifiedBufferSize != 0) {
       bufferSize = specifiedBufferSize;
     } else if (passthrough) {
       // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
       // account. [Internal: b/25181305]
-      if (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3) {
+      if (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3) {
         // AC-3 allows bitrates up to 640 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
-      } else { // encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD
+      } else /* (targetEncoding == C.ENCODING_DTS || targetEncoding == C.ENCODING_DTS_HD) */ {
         // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
       }
     } else {
       int minBufferSize =
-          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, targetEncoding);
       Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
@@ -452,12 +471,12 @@ public int initialize(int sessionId) throws InitializationException {
     releasingConditionVariable.block();
 
     if (sessionId == SESSION_ID_NOT_SET) {
-      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-          bufferSize, android.media.AudioTrack.MODE_STREAM);
+      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
+          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM);
     } else {
       // Re-attach to the same audio session.
-      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-          bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
+      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
+          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
     }
     checkAudioTrackInitialized();
 
@@ -473,7 +492,7 @@ public int initialize(int sessionId) throws InitializationException {
         if (keepSessionIdAudioTrack == null) {
           int sampleRate = 4000; // Equal to private android.media.AudioTrack.MIN_SAMPLE_RATE.
           int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
-          int encoding = AudioFormat.ENCODING_PCM_16BIT;
+          int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
               channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STATIC, sessionId);
@@ -574,32 +593,40 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     if (bufferBytesRemaining == 0) {
       // The previous buffer (if there was one) was fully written to the audio track. We're now
       // seeing a new buffer for the first time.
+
+      useResampledBuffer = targetEncoding != sourceEncoding;
+      if (useResampledBuffer) {
+        Assertions.checkState(targetEncoding == C.ENCODING_PCM_16BIT);
+        // Resample the buffer to get the data in the target encoding.
+        resampledBuffer = resampleTo16BitPcm(buffer, offset, size, sourceEncoding, resampledBuffer);
+        // Use the resampled buffer, offset and size.
+        buffer = resampledBuffer;
+        offset = resampledBuffer.position();
+        size = resampledBuffer.limit();
+      }
+
       bufferBytesRemaining = size;
       buffer.position(offset);
       if (passthrough && framesPerEncodedSample == 0) {
         // If this is the first encoded sample, calculate the sample size in frames.
-        framesPerEncodedSample = getFramesPerEncodedSample(encoding, buffer);
+        framesPerEncodedSample = getFramesPerEncodedSample(targetEncoding, buffer);
       }
-      long frames = passthrough ? framesPerEncodedSample : pcmBytesToFrames(size);
-      long bufferDurationUs = framesToDurationUs(frames);
-      // Note: presentationTimeUs corresponds to the end of the sample, not the start.
-      long bufferStartTime = presentationTimeUs - bufferDurationUs;
       if (startMediaTimeState == START_NOT_SET) {
-        startMediaTimeUs = Math.max(0, bufferStartTime);
+        startMediaTimeUs = Math.max(0, presentationTimeUs);
         startMediaTimeState = START_IN_SYNC;
       } else {
         // Sanity check that bufferStartTime is consistent with the expected value.
         long expectedBufferStartTime = startMediaTimeUs + framesToDurationUs(getSubmittedFrames());
         if (startMediaTimeState == START_IN_SYNC
-            && Math.abs(expectedBufferStartTime - bufferStartTime) > 200000) {
+            && Math.abs(expectedBufferStartTime - presentationTimeUs) > 200000) {
           Log.e(TAG, "Discontinuity detected [expected " + expectedBufferStartTime + ", got "
-              + bufferStartTime + "]");
+              + presentationTimeUs + "]");
           startMediaTimeState = START_NEED_SYNC;
         }
         if (startMediaTimeState == START_NEED_SYNC) {
           // Adjust startMediaTimeUs to be consistent with the current buffer's start time and the
           // number of bytes submitted.
-          startMediaTimeUs += (bufferStartTime - expectedBufferStartTime);
+          startMediaTimeUs += (presentationTimeUs - expectedBufferStartTime);
           startMediaTimeState = START_IN_SYNC;
           result |= RESULT_POSITION_DISCONTINUITY;
         }
@@ -628,7 +655,8 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
         }
       }
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bufferBytesRemaining);
+      ByteBuffer data = useResampledBuffer ? resampledBuffer : buffer;
+      bytesWritten = writeNonBlockingV21(audioTrack, data, bufferBytesRemaining);
     }
 
     if (bytesWritten < 0) {
@@ -658,12 +686,6 @@ public void handleEndOfStream() {
     }
   }
 
-  @TargetApi(21)
-  private static int writeNonBlockingV21(
-      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
-    return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
-  }
-
   /**
    * Returns whether the audio track has more data pending that will be played back.
    */
@@ -683,7 +705,6 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
     audioTrackUtil.setPlaybackParameters(playbackParams);
   }
 
-
   /**
    * Sets the playback volume.
    */
@@ -704,16 +725,6 @@ private void setAudioTrackVolume() {
     }
   }
 
-  @TargetApi(21)
-  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
-    audioTrack.setVolume(volume);
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
-    audioTrack.setStereoVolume(volume, volume);
-  }
-
   /**
    * Pauses playback.
    */
@@ -934,7 +945,8 @@ private void resetSyncParams() {
    * See [Internal: b/18899620, b/19187573, b/21145353].
    */
   private boolean needsPassthroughWorkarounds() {
-    return Util.SDK_INT < 23 && (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3);
+    return Util.SDK_INT < 23
+        && (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3);
   }
 
   /**
@@ -949,6 +961,75 @@ private boolean overrideHasPendingData() {
         && audioTrack.getPlaybackHeadPosition() == 0;
   }
 
+  /**
+   * Converts the provided buffer into 16-bit PCM.
+   *
+   * @param buffer The buffer containing the data to convert.
+   * @param offset The offset of the data in the buffer.
+   * @param size The size in bytes of the data in the buffer.
+   * @param sourceEncoding The data encoding.
+   * @param out A buffer into which the output should be written, if its capacity is sufficient.
+   * @return The 16-bit PCM output. Different to the out parameter if null was passed, or if the
+   *     capacity was insufficient for the output.
+   */
+  private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int offset, int size,
+      int sourceEncoding, ByteBuffer out) {
+    int resampledSize;
+    switch (sourceEncoding) {
+      case C.ENCODING_PCM_8BIT:
+        resampledSize = size * 2;
+        break;
+      case C.ENCODING_PCM_24BIT:
+        resampledSize = (size / 3) * 2;
+        break;
+      case C.ENCODING_PCM_32BIT:
+        resampledSize = size / 2;
+        break;
+      default:
+        // Never happens.
+        throw new IllegalStateException();
+    }
+
+    ByteBuffer resampledBuffer = out;
+    if (resampledBuffer == null || resampledBuffer.capacity() < resampledSize) {
+      resampledBuffer = ByteBuffer.allocateDirect(resampledSize);
+    }
+    resampledBuffer.position(0);
+    resampledBuffer.limit(resampledSize);
+
+    // Samples are little endian.
+    int limit = offset + size;
+    switch (sourceEncoding) {
+      case C.ENCODING_PCM_8BIT:
+        // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
+        for (int i = offset; i < limit; i++) {
+          resampledBuffer.put((byte) 0);
+          resampledBuffer.put((byte) ((buffer.get(i) & 0xFF) - 128));
+        }
+        break;
+      case C.ENCODING_PCM_24BIT:
+        // 24->16 bit resampling. Drop the least significant byte.
+        for (int i = offset; i < limit; i += 3) {
+          resampledBuffer.put(buffer.get(i + 1));
+          resampledBuffer.put(buffer.get(i + 2));
+        }
+        break;
+      case C.ENCODING_PCM_32BIT:
+        // 32->16 bit resampling. Drop the two least significant bytes.
+        for (int i = offset; i < limit; i += 4) {
+          resampledBuffer.put(buffer.get(i + 2));
+          resampledBuffer.put(buffer.get(i + 3));
+        }
+        break;
+      default:
+        // Never happens.
+        throw new IllegalStateException();
+    }
+
+    resampledBuffer.position(0);
+    return resampledBuffer;
+  }
+
   private static int getEncodingForMimeType(String mimeType) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AC3:
@@ -960,7 +1041,7 @@ private static int getEncodingForMimeType(String mimeType) {
       case MimeTypes.AUDIO_DTS_HD:
         return C.ENCODING_DTS_HD;
       default:
-        return AudioFormat.ENCODING_INVALID;
+        return C.ENCODING_INVALID;
     }
   }
 
@@ -976,6 +1057,22 @@ private static int getFramesPerEncodedSample(int encoding, ByteBuffer buffer) {
     }
   }
 
+  @TargetApi(21)
+  private static int writeNonBlockingV21(
+      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
+    return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
+  }
+
+  @TargetApi(21)
+  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
+    audioTrack.setVolume(volume);
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
+    audioTrack.setStereoVolume(volume, volume);
+  }
+
   /**
    * Wraps an {@link android.media.AudioTrack} to expose useful utility methods.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index c1db4257a9..67265e7695 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -249,11 +249,11 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       currentChunk = mediaChunks.getFirst();
     }
 
-    if (downstreamFormat == null || !downstreamFormat.equals(currentChunk.format)) {
-      notifyDownstreamFormatChanged(currentChunk.format, currentChunk.trigger,
-          currentChunk.startTimeUs);
-      downstreamFormat = currentChunk.format;
+    Format format = currentChunk.format;
+    if (!format.equals(downstreamFormat)) {
+      notifyDownstreamFormatChanged(format, currentChunk.trigger, currentChunk.startTimeUs);
     }
+    downstreamFormat = format;
 
     if (haveSamples || currentChunk.isMediaFormatFinal) {
       MediaFormat mediaFormat = currentChunk.getMediaFormat();
@@ -263,6 +263,11 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
         downstreamMediaFormat = mediaFormat;
         return FORMAT_READ;
       }
+      // If mediaFormat and downstreamMediaFormat are equal but different objects then the equality
+      // check above will have been expensive, comparing the fields in each format. We update
+      // downstreamMediaFormat here so that referential equality can be cheaply established during
+      // subsequent calls.
+      downstreamMediaFormat = mediaFormat;
     }
 
     if (!haveSamples) {
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
index 162bcba1cb..b26af291cb 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
@@ -158,7 +158,7 @@ public final void load() throws IOException, InterruptedException {
         // Set the target to ourselves.
         extractorWrapper.init(this);
       }
-      // Load and parse the initialization data.
+      // Load and parse the sample data.
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index b2f1c39f37..c313a289f9 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -94,14 +94,12 @@
       int viewportWidth, int viewportHeight) throws DecoderQueryException {
     int maxVideoPixelsToRetain = Integer.MAX_VALUE;
     ArrayList<Integer> selectedIndexList = new ArrayList<>();
-    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
 
     // First pass to filter out formats that individually fail to meet the selection criteria.
     int formatWrapperCount = formatWrappers.size();
     for (int i = 0; i < formatWrapperCount; i++) {
       Format format = formatWrappers.get(i).getFormat();
-      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats,
-          maxDecodableFrameSize)) {
+      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats)) {
         // Select the format for now. It may still be filtered in the second pass below.
         selectedIndexList.add(i);
         // Keep track of the number of pixels of the selected format whose resolution is the
@@ -141,7 +139,7 @@
    * whether HD formats should be filtered and a maximum decodable frame size in pixels.
    */
   private static boolean isFormatPlayable(Format format, String[] allowedContainerMimeTypes,
-      boolean filterHdFormats, int maxDecodableFrameSize) throws DecoderQueryException {
+      boolean filterHdFormats) throws DecoderQueryException {
     if (allowedContainerMimeTypes != null
         && !Util.contains(allowedContainerMimeTypes, format.mimeType)) {
       // Filtering format based on its container mime type.
@@ -167,7 +165,7 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
         }
       }
       // Assume the video is H.264.
-      if (format.width * format.height > maxDecodableFrameSize) {
+      if (format.width * format.height > MediaCodecUtil.maxH264DecodableFrameSize()) {
         // Filtering format because it exceeds the maximum decodable frame size.
         return false;
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index db640a5464..78ca511436 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -52,7 +52,7 @@
  * <li>MP4, including M4A ({@link com.google.android.exoplayer.extractor.mp4.Mp4Extractor})</li>
  * <li>fMP4 ({@link com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor})</li>
  * <li>Matroska and WebM ({@link com.google.android.exoplayer.extractor.webm.WebmExtractor})</li>
- * <li>Ogg Vorbis ({@link com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor}</li>
+ * <li>Ogg Vorbis/FLAC ({@link com.google.android.exoplayer.extractor.ogg.OggExtractor}</li>
  * <li>MP3 ({@link com.google.android.exoplayer.extractor.mp3.Mp3Extractor})</li>
  * <li>AAC ({@link com.google.android.exoplayer.extractor.ts.AdtsExtractor})</li>
  * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor})</li>
@@ -172,7 +172,7 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     }
     try {
       DEFAULT_EXTRACTOR_CLASSES.add(
-          Class.forName("com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor")
+          Class.forName("com.google.android.exoplayer.extractor.ogg.OggExtractor")
               .asSubclass(Extractor.class));
     } catch (ClassNotFoundException e) {
       // Extractor not found.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index a962982d4e..7165840cd2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -67,7 +67,7 @@
   private GaplessInfo gaplessInfo;
   private Seeker seeker;
   private long basisTimeUs;
-  private int samplesRead;
+  private long samplesRead;
   private int sampleBytesRemaining;
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 48a30236e3..f6da60fab6 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -54,6 +54,8 @@
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
   public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
+  public static final int TYPE_lpcm = Util.getIntegerCodeForString("lpcm");
+  public static final int TYPE_sowt = Util.getIntegerCodeForString("sowt");
   public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
   public static final int TYPE_dac3 = Util.getIntegerCodeForString("dac3");
   public static final int TYPE_ec_3 = Util.getIntegerCodeForString("ec-3");
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index b7ab5d6c0e..14e14e9952 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -91,12 +91,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
 
     // Entries are byte offsets of chunks.
-    ParsableByteArray chunkOffsets;
+    boolean chunkOffsetsAreLongs = false;
     Atom.LeafAtom chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
     if (chunkOffsetsAtom == null) {
+      chunkOffsetsAreLongs = true;
       chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
     }
-    chunkOffsets = chunkOffsetsAtom.data;
+    ParsableByteArray chunkOffsets = chunkOffsetsAtom.data;
     // Entries are (chunk number, number of samples per chunk, sample description index).
     ParsableByteArray stsc = stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
     // Entries are (number of samples, timestamp delta between those samples).
@@ -112,33 +113,12 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     stsz.setPosition(Atom.FULL_HEADER_SIZE);
     int fixedSampleSize = stsz.readUnsignedIntToInt();
     int sampleCount = stsz.readUnsignedIntToInt();
-
-    long[] offsets = new long[sampleCount];
-    int[] sizes = new int[sampleCount];
-    int maximumSize = 0;
-    long[] timestamps = new long[sampleCount];
-    int[] flags = new int[sampleCount];
     if (sampleCount == 0) {
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+      return new TrackSampleTable(new long[0], new int[0], 0, new long[0], new int[0]);
     }
 
-    // Prepare to read chunk offsets.
-    chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
-    int chunkCount = chunkOffsets.readUnsignedIntToInt();
-
-    stsc.setPosition(Atom.FULL_HEADER_SIZE);
-    int remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt() - 1;
-    Assertions.checkState(stsc.readInt() == 1, "stsc first chunk must be 1");
-    int samplesPerChunk = stsc.readUnsignedIntToInt();
-    stsc.skipBytes(4); // Skip the sample description index.
-    int nextSamplesPerChunkChangeChunkIndex = -1;
-    if (remainingSamplesPerChunkChanges > 0) {
-      // Store the chunk index when the samples-per-chunk will next change.
-      nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
-    }
-
-    int chunkIndex = 0;
-    int remainingSamplesInChunk = samplesPerChunk;
+    // Prepare to read chunk information.
+    ChunkIterator chunkIterator = new ChunkIterator(stsc, chunkOffsets, chunkOffsetsAreLongs);
 
     // Prepare to read sample timestamps.
     stts.setPosition(Atom.FULL_HEADER_SIZE);
@@ -163,95 +143,103 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
     }
 
-    // Calculate the chunk offsets
-    long offsetBytes;
-    if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
-      offsetBytes = chunkOffsets.readUnsignedInt();
-    } else {
-      offsetBytes = chunkOffsets.readUnsignedLongToLong();
-    }
+    // True if we can rechunk fixed-sample-size data. Note that we only rechunk raw audio.
+    boolean isRechunkable =
+        fixedSampleSize != 0
+        && MimeTypes.AUDIO_RAW.equals(track.mediaFormat.mimeType)
+        && remainingTimestampDeltaChanges == 0
+        && remainingTimestampOffsetChanges == 0
+        && remainingSynchronizationSamples == 0;
 
-    long timestampTimeUnits = 0;
-    for (int i = 0; i < sampleCount; i++) {
-      // Add on the timestamp offset if ctts is present.
-      if (ctts != null) {
-        while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
-          remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
-          // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers in
-          // version 0 ctts boxes, however some streams violate the spec and use signed integers
-          // instead. It's safe to always parse sample offsets as signed integers here, because
-          // unsigned integers will still be parsed correctly (unless their top bit is set, which is
-          // never true in practice because sample offsets are always small).
-          timestampOffset = ctts.readInt();
-          remainingTimestampOffsetChanges--;
-        }
-        remainingSamplesAtTimestampOffset--;
-      }
-
-      offsets[i] = offsetBytes;
-      sizes[i] = fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
-      if (sizes[i] > maximumSize) {
-        maximumSize = sizes[i];
-      }
-      timestamps[i] = timestampTimeUnits + timestampOffset;
-
-      // All samples are synchronization samples if the stss is not present.
-      flags[i] = stss == null ? C.SAMPLE_FLAG_SYNC : 0;
-      if (i == nextSynchronizationSampleIndex) {
-        flags[i] = C.SAMPLE_FLAG_SYNC;
-        remainingSynchronizationSamples--;
-        if (remainingSynchronizationSamples > 0) {
-          nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
+    long[] offsets;
+    int[] sizes;
+    int maximumSize = 0;
+    long[] timestamps;
+    int[] flags;
+
+    if (!isRechunkable) {
+      offsets = new long[sampleCount];
+      sizes = new int[sampleCount];
+      timestamps = new long[sampleCount];
+      flags = new int[sampleCount];
+      long timestampTimeUnits = 0;
+      long offset = 0;
+      int remainingSamplesInChunk = 0;
+
+      for (int i = 0; i < sampleCount; i++) {
+        // Advance to the next chunk if necessary.
+        while (remainingSamplesInChunk == 0) {
+          Assertions.checkState(chunkIterator.moveNext());
+          offset = chunkIterator.offset;
+          remainingSamplesInChunk = chunkIterator.numSamples;
         }
-      }
-
-      // Add on the duration of this sample.
-      timestampTimeUnits += timestampDeltaInTimeUnits;
-      remainingSamplesAtTimestampDelta--;
-      if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
-        remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
-        timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
-        remainingTimestampDeltaChanges--;
-      }
 
-      // If we're at the last sample in this chunk, move to the next chunk.
-      remainingSamplesInChunk--;
-      if (remainingSamplesInChunk == 0) {
-        chunkIndex++;
-        if (chunkIndex < chunkCount) {
-          if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
-            offsetBytes = chunkOffsets.readUnsignedInt();
-          } else {
-            offsetBytes = chunkOffsets.readUnsignedLongToLong();
+        // Add on the timestamp offset if ctts is present.
+        if (ctts != null) {
+          while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
+            remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
+            // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers
+            // in version 0 ctts boxes, however some streams violate the spec and use signed
+            // integers instead. It's safe to always parse sample offsets as signed integers here,
+            // because unsigned integers will still be parsed correctly (unless their top bit is
+            // set, which is never true in practice because sample offsets are always small).
+            timestampOffset = ctts.readInt();
+            remainingTimestampOffsetChanges--;
           }
+          remainingSamplesAtTimestampOffset--;
         }
 
-        // Change the samples-per-chunk if required.
-        if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
-          samplesPerChunk = stsc.readUnsignedIntToInt();
-          stsc.skipBytes(4); // Skip the sample description index.
-          remainingSamplesPerChunkChanges--;
-          if (remainingSamplesPerChunkChanges > 0) {
-            nextSamplesPerChunkChangeChunkIndex = stsc.readUnsignedIntToInt() - 1;
+        offsets[i] = offset;
+        sizes[i] = fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
+        if (sizes[i] > maximumSize) {
+          maximumSize = sizes[i];
+        }
+        timestamps[i] = timestampTimeUnits + timestampOffset;
+
+        // All samples are synchronization samples if the stss is not present.
+        flags[i] = stss == null ? C.SAMPLE_FLAG_SYNC : 0;
+        if (i == nextSynchronizationSampleIndex) {
+          flags[i] = C.SAMPLE_FLAG_SYNC;
+          remainingSynchronizationSamples--;
+          if (remainingSynchronizationSamples > 0) {
+            nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
           }
         }
 
-        // Expect samplesPerChunk samples in the following chunk, if it's before the end.
-        if (chunkIndex < chunkCount) {
-          remainingSamplesInChunk = samplesPerChunk;
+        // Add on the duration of this sample.
+        timestampTimeUnits += timestampDeltaInTimeUnits;
+        remainingSamplesAtTimestampDelta--;
+        if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
+          remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
+          timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
+          remainingTimestampDeltaChanges--;
         }
-      } else {
-        // The next sample follows the current one.
-        offsetBytes += sizes[i];
+
+        offset += sizes[i];
+        remainingSamplesInChunk--;
       }
-    }
 
-    // Check all the expected samples have been seen.
-    Assertions.checkArgument(remainingSynchronizationSamples == 0);
-    Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
-    Assertions.checkArgument(remainingSamplesInChunk == 0);
-    Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
-    Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
+      // Check all the expected samples have been seen.
+      Assertions.checkArgument(remainingSynchronizationSamples == 0);
+      Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
+      Assertions.checkArgument(remainingSamplesInChunk == 0);
+      Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
+      Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
+    } else {
+      long[] chunkOffsetsBytes = new long[chunkIterator.length];
+      int[] chunkSampleCounts = new int[chunkIterator.length];
+      while (chunkIterator.moveNext()) {
+        chunkOffsetsBytes[chunkIterator.index] = chunkIterator.offset;
+        chunkSampleCounts[chunkIterator.index] = chunkIterator.numSamples;
+      }
+      FixedSampleSizeRechunker.Results rechunkedResults = FixedSampleSizeRechunker.rechunk(
+          fixedSampleSize, chunkOffsetsBytes, chunkSampleCounts, timestampDeltaInTimeUnits);
+      offsets = rechunkedResults.offsets;
+      sizes = rechunkedResults.sizes;
+      maximumSize = rechunkedResults.maximumSize;
+      timestamps = rechunkedResults.timestamps;
+      flags = rechunkedResults.flags;
+    }
 
     if (track.editListDurations == null) {
       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
@@ -557,7 +545,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
           || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
           || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
-          || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb) {
+          || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
+          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             durationUs, language, isQuickTime, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
@@ -817,16 +806,29 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       parent.skipBytes(16);
     }
 
-    int channelCount = parent.readUnsignedShort();
-    int sampleSize = parent.readUnsignedShort();
-    parent.skipBytes(4);
-    int sampleRate = parent.readUnsignedFixedPoint1616();
+    int channelCount;
+    int sampleRate;
 
-    if (quickTimeSoundDescriptionVersion > 0) {
-      parent.skipBytes(16);
-      if (quickTimeSoundDescriptionVersion == 2) {
-        parent.skipBytes(20);
+    if (quickTimeSoundDescriptionVersion == 0 || quickTimeSoundDescriptionVersion == 1) {
+      channelCount = parent.readUnsignedShort();
+      parent.skipBytes(6);  // sampleSize, compressionId, packetSize.
+      sampleRate = parent.readUnsignedFixedPoint1616();
+
+      if (quickTimeSoundDescriptionVersion == 1) {
+        parent.skipBytes(16);
       }
+    } else if (quickTimeSoundDescriptionVersion == 2) {
+      parent.skipBytes(16);  // always[3,16,Minus2,0,65536], sizeOfStructOnly
+
+      sampleRate = (int) Math.round(parent.readDouble());
+      channelCount = parent.readUnsignedIntToInt();
+
+      // Skip always7F000000, sampleSize, formatSpecificFlags, constBytesPerAudioPacket,
+      // constLPCMFramesPerAudioPacket.
+      parent.skipBytes(20);
+    } else {
+      // Unsupported version.
+      return;
     }
 
     // If the atom type determines a MIME type, set it immediately.
@@ -845,6 +847,8 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_AMR_NB;
     } else if (atomType == Atom.TYPE_sawb) {
       mimeType = MimeTypes.AUDIO_AMR_WB;
+    } else if (atomType == Atom.TYPE_lpcm || atomType == Atom.TYPE_sowt) {
+      mimeType = MimeTypes.AUDIO_RAW;
     }
 
     byte[] initializationData = null;
@@ -906,10 +910,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
+    // TODO: Determine the correct PCM encoding.
+    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+        : MediaFormat.NO_VALUE;
+
     out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
-        MediaFormat.NO_VALUE, sampleSize, durationUs, channelCount, sampleRate,
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
         initializationData == null ? null : Collections.singletonList(initializationData),
-        language);
+        language, pcmEncoding);
   }
 
   /** Returns the position of the esds box within a parent, or -1 if no esds box is found */
@@ -1017,6 +1025,51 @@ private AtomParsers() {
     // Prevent instantiation.
   }
 
+  private static final class ChunkIterator {
+
+    public final int length;
+
+    public int index;
+    public int numSamples;
+    public long offset;
+
+    private final boolean chunkOffsetsAreLongs;
+    private final ParsableByteArray chunkOffsets;
+    private final ParsableByteArray stsc;
+
+    private int nextSamplesPerChunkChangeIndex;
+    private int remainingSamplesPerChunkChanges;
+
+    public ChunkIterator(ParsableByteArray stsc, ParsableByteArray chunkOffsets,
+        boolean chunkOffsetsAreLongs) {
+      this.stsc = stsc;
+      this.chunkOffsets = chunkOffsets;
+      this.chunkOffsetsAreLongs = chunkOffsetsAreLongs;
+      chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
+      length = chunkOffsets.readUnsignedIntToInt();
+      stsc.setPosition(Atom.FULL_HEADER_SIZE);
+      remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt();
+      Assertions.checkState(stsc.readInt() == 1, "first_chunk must be 1");
+      index = -1;
+    }
+
+    public boolean moveNext() {
+      if (++index == length) {
+        return false;
+      }
+      offset = chunkOffsetsAreLongs ? chunkOffsets.readUnsignedLongToLong()
+          : chunkOffsets.readUnsignedInt();
+      if (index == nextSamplesPerChunkChangeIndex) {
+        numSamples = stsc.readUnsignedIntToInt();
+        stsc.skipBytes(4); // Skip sample_description_index
+        nextSamplesPerChunkChangeIndex = --remainingSamplesPerChunkChanges > 0
+            ? (stsc.readUnsignedIntToInt() - 1) : -1;
+      }
+      return true;
+    }
+
+  }
+
   /**
    * Holds data parsed from a tkhd atom.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FixedSampleSizeRechunker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FixedSampleSizeRechunker.java
new file mode 100644
index 0000000000..a4a01aea3a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FixedSampleSizeRechunker.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Util;
+
+/** Utilities for rechunking fixed sample size data (e.g., uncompressed audio). */
+/* package */ final class FixedSampleSizeRechunker {
+
+  /** Maximum number of bytes for each buffer in rechunked output. */
+  private static final int MAX_SAMPLE_SIZE = 8 * 1024;
+
+  /** Stores the results (new chunk information) of a rechunking operation. */
+  public static final class Results {
+    public final long[] offsets;
+    public final int[] sizes;
+    public final int maximumSize;
+    public final long[] timestamps;
+    public final int[] flags;
+
+    public Results(long[] offsets, int[] sizes, int maximumSize, long[] timestamps, int[] flags) {
+      this.offsets = offsets;
+      this.sizes = sizes;
+      this.maximumSize = maximumSize;
+      this.timestamps = timestamps;
+      this.flags = flags;
+    }
+  }
+
+  /**
+   * Rechunk the given fixed sample size input to produce a new sequence of samples.
+   *
+   * @param fixedSampleSize Size in bytes of each sample.
+   * @param chunkOffsets Chunk offsets in the MP4 stream to rechunk.
+   * @param chunkSampleCounts Sample counts for each of the MP4 stream's chunks.
+   * @param timestampDeltaInTimeUnits Timestamp delta between each sample in time units.
+   */
+  public static Results rechunk(
+      int fixedSampleSize,
+      long[] chunkOffsets,
+      int[] chunkSampleCounts,
+      long timestampDeltaInTimeUnits) {
+    int maxSampleCount = MAX_SAMPLE_SIZE / fixedSampleSize;
+
+    // Count the number of new, rechunked buffers.
+    int rechunkedSampleCount = 0;
+    for (int chunkSampleCount : chunkSampleCounts) {
+      rechunkedSampleCount += Util.ceilDivide(chunkSampleCount, maxSampleCount);
+    }
+
+    long[] offsets = new long[rechunkedSampleCount];
+    int[] sizes = new int[rechunkedSampleCount];
+    int maximumSize = 0;
+    long[] timestamps = new long[rechunkedSampleCount];
+    int[] flags = new int[rechunkedSampleCount];
+
+    int originalSampleIndex = 0;
+    int newSampleIndex = 0;
+    for (int chunkIndex = 0; chunkIndex < chunkSampleCounts.length; chunkIndex++) {
+      int chunkSamplesRemaining = chunkSampleCounts[chunkIndex];
+      long sampleOffset = chunkOffsets[chunkIndex];
+
+      while (chunkSamplesRemaining > 0) {
+        int bufferSampleCount = Math.min(maxSampleCount, chunkSamplesRemaining);
+
+        offsets[newSampleIndex] = sampleOffset;
+        sizes[newSampleIndex] = fixedSampleSize * bufferSampleCount;
+        maximumSize = Math.max(maximumSize, sizes[newSampleIndex]);
+        timestamps[newSampleIndex] = (timestampDeltaInTimeUnits * originalSampleIndex);
+        flags[newSampleIndex] = C.SAMPLE_FLAG_SYNC;
+
+        sampleOffset += sizes[newSampleIndex];
+        originalSampleIndex += bufferSampleCount;
+
+        chunkSamplesRemaining -= bufferSampleCount;
+        newSampleIndex++;
+      }
+    }
+
+    return new Results(offsets, sizes, maximumSize, timestamps, flags);
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/FlacReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/FlacReader.java
new file mode 100644
index 0000000000..c3bdb33a56
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/FlacReader.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.FlacSeekTable;
+import com.google.android.exoplayer.util.FlacStreamInfo;
+import com.google.android.exoplayer.util.FlacUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * {@link StreamReader} to extract Flac data out of Ogg byte stream.
+ */
+/* package */ final class FlacReader extends StreamReader {
+
+  private static final byte AUDIO_PACKET_TYPE = (byte) 0xFF;
+  private static final byte SEEKTABLE_PACKET_TYPE = 0x03;
+
+  private FlacStreamInfo streamInfo;
+
+  private FlacSeekTable seekTable;
+
+  private boolean firstAudioPacketProcessed;
+
+  /* package */ static boolean verifyBitstreamType(ParsableByteArray data) {
+    return data.readUnsignedByte() == 0x7F && // packet type
+        data.readUnsignedInt() == 0x464C4143; // ASCII signature "FLAC"
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    long position = input.getPosition();
+
+    if (!oggParser.readPacket(input, scratch)) {
+      return Extractor.RESULT_END_OF_INPUT;
+    }
+
+    byte[] data = scratch.data;
+    if (streamInfo == null) {
+      streamInfo = new FlacStreamInfo(data, 17);
+
+      byte[] metadata = Arrays.copyOfRange(data, 9, scratch.limit());
+      metadata[4] = (byte) 0x80; // Set the last metadata block flag, ignore the other blocks
+      List<byte[]> initializationData = Collections.singletonList(metadata);
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_FLAC,
+          streamInfo.bitRate(), MediaFormat.NO_VALUE, streamInfo.durationUs(),
+          streamInfo.channels, streamInfo.sampleRate, initializationData, null);
+      trackOutput.format(mediaFormat);
+
+    } else if (data[0] == AUDIO_PACKET_TYPE) {
+      if (!firstAudioPacketProcessed) {
+        if (seekTable != null) {
+          extractorOutput.seekMap(seekTable.createSeekMap(position, streamInfo.sampleRate));
+          seekTable = null;
+        } else {
+          extractorOutput.seekMap(SeekMap.UNSEEKABLE);
+        }
+        firstAudioPacketProcessed = true;
+      }
+
+      trackOutput.sampleData(scratch, scratch.limit());
+      scratch.setPosition(0);
+      long timeUs = FlacUtil.extractSampleTimestamp(streamInfo, scratch);
+      trackOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, scratch.limit(), 0, null);
+
+    } else if ((data[0] & 0x7F) == SEEKTABLE_PACKET_TYPE && seekTable == null) {
+      seekTable = FlacSeekTable.parseSeekTable(scratch);
+    }
+
+    scratch.reset();
+    return Extractor.RESULT_CONTINUE;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java
new file mode 100644
index 0000000000..f41aa0bbc8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggExtractor.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Ogg {@link Extractor}.
+ */
+public class OggExtractor implements Extractor {
+
+  private StreamReader streamReader;
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    try {
+      ParsableByteArray scratch = new ParsableByteArray(new byte[OggUtil.PAGE_HEADER_SIZE], 0);
+      OggUtil.PageHeader header = new OggUtil.PageHeader();
+      if (!OggUtil.populatePageHeader(input, header, scratch, true)
+          || (header.type & 0x02) != 0x02 || header.bodySize < 7) {
+        return false;
+      }
+      scratch.reset();
+      input.peekFully(scratch.data, 0, 7);
+      if (FlacReader.verifyBitstreamType(scratch)) {
+        streamReader = new FlacReader();
+      } else {
+        scratch.reset();
+        if (VorbisReader.verifyBitstreamType(scratch)) {
+          streamReader = new VorbisReader();
+        } else {
+          return false;
+        }
+      }
+      return true;
+    } catch (ParserException e) {
+      // does not happen
+    } finally {
+    }
+    return false;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    TrackOutput trackOutput = output.track(0);
+    output.endTracks();
+    streamReader.init(output, trackOutput);
+  }
+
+  @Override
+  public void seek() {
+    streamReader.seek();
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    return streamReader.read(input, seekPosition);
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggParser.java
similarity index 96%
rename from library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggParser.java
index 3fb2ed473a..c66adcabe6 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggParser.java
@@ -27,7 +27,7 @@
 /**
  * Reads OGG packets from an {@link ExtractorInput}.
  */
-/* package */ final class OggReader {
+/* package */ final class OggParser {
 
   public static final int OGG_MAX_SEGMENT_SIZE = 255;
 
@@ -112,12 +112,9 @@ public long readGranuleOfLastPage(ExtractorInput input)
     Assertions.checkArgument(input.getLength() != C.LENGTH_UNBOUNDED); // never read forever!
     OggUtil.skipToNextPage(input);
     pageHeader.reset();
-    while ((pageHeader.type & 0x04) != 0x04) {
-      if (pageHeader.bodySize > 0) {
-        input.skipFully(pageHeader.bodySize);
-      }
+    while ((pageHeader.type & 0x04) != 0x04 && input.getPosition() < input.getLength()) {
       OggUtil.populatePageHeader(input, pageHeader, headerArray, false);
-      input.skipFully(pageHeader.headerSize);
+      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
     }
     return pageHeader.granulePosition;
   }
@@ -163,7 +160,7 @@ public long skipToPageOfGranule(ExtractorInput input, long targetGranule)
    * Returns the {@link OggUtil.PageHeader} of the current page. The header might not have been
    * populated if the first packet has yet to be read.
    * <p>
-   * Note that there is only a single instance of {@code OggReader.PageHeader} which is mutable.
+   * Note that there is only a single instance of {@code OggParser.PageHeader} which is mutable.
    * The value of the fields might be changed by the reader when reading the stream advances and
    * the next page is read (which implies reading and populating the next header).
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java
index 7466c8d2e8..40f88b2d27 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java
@@ -46,14 +46,6 @@ public void setup(long audioDataLength, long totalSamples) {
     this.totalSamples = totalSamples;
   }
 
-  /**
-   * Resets this {@code OggSeeker}.
-   */
-  public void reset() {
-    pageHeader.reset();
-    headerArray.reset();
-  }
-
   /**
    * Returns a position converging to the {@code targetGranule} to which the {@link ExtractorInput}
    * has to seek and then be passed for another call until -1 is return. If -1 is returned the
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java
index d62ba6ef42..c17d4b61f3 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java
@@ -29,6 +29,8 @@
  */
 /* package */ final class OggUtil {
 
+  public static final int PAGE_HEADER_SIZE = 27;
+
   private static final int TYPE_OGGS = Util.getIntegerCodeForString("OggS");
 
   /**
@@ -86,7 +88,7 @@ public static void skipToNextPage(ExtractorInput input)
    *
    * @param input the {@link ExtractorInput} to read from.
    * @param header the {@link PageHeader} to read from.
-   * @param scratch a scratch array temporary use.
+   * @param scratch a scratch array temporary use. Its size should be at least PAGE_HEADER_SIZE
    * @param quite if {@code true} no Exceptions are thrown but {@code false} is return if something
    *     goes wrong.
    * @return {@code true} if the read was successful. {@code false} if the end of the
@@ -100,8 +102,8 @@ public static boolean populatePageHeader(ExtractorInput input, PageHeader header
     scratch.reset();
     header.reset();
     boolean hasEnoughBytes = input.getLength() == C.LENGTH_UNBOUNDED
-        || input.getLength() - input.getPeekPosition() >= 27;
-    if (!hasEnoughBytes || !input.peekFully(scratch.data, 0, 27, true)) {
+        || input.getLength() - input.getPeekPosition() >= PAGE_HEADER_SIZE;
+    if (!hasEnoughBytes || !input.peekFully(scratch.data, 0, PAGE_HEADER_SIZE, true)) {
       if (quite) {
         return false;
       } else {
@@ -134,7 +136,7 @@ public static boolean populatePageHeader(ExtractorInput input, PageHeader header
 
     scratch.reset();
     // calculate total size of header including laces
-    header.headerSize = 27 + header.pageSegmentCount;
+    header.headerSize = PAGE_HEADER_SIZE + header.pageSegmentCount;
     input.peekFully(scratch.data, 0, header.pageSegmentCount);
     for (int i = 0; i < header.pageSegmentCount; i++) {
       header.laces[i] = scratch.readUnsignedByte();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/StreamReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/StreamReader.java
new file mode 100644
index 0000000000..af251cfd52
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/StreamReader.java
@@ -0,0 +1,44 @@
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * StreamReader abstract class.
+ */
+/* package */ abstract class StreamReader {
+
+  protected final ParsableByteArray scratch = new ParsableByteArray(
+      new byte[OggParser.OGG_MAX_SEGMENT_SIZE * 255], 0);
+
+  protected final OggParser oggParser = new OggParser();
+
+  protected TrackOutput trackOutput;
+
+  protected ExtractorOutput extractorOutput;
+
+  void init(ExtractorOutput output, TrackOutput trackOutput) {
+    this.extractorOutput = output;
+    this.trackOutput = trackOutput;
+  }
+
+  /**
+   * @see Extractor#seek()
+   */
+  void seek() {
+    oggParser.reset();
+    scratch.reset();
+  }
+
+  /**
+   * @see Extractor#read(ExtractorInput, PositionHolder)
+   */
+  abstract int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException;
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisReader.java
similarity index 81%
rename from library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
rename to library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisReader.java
index 94124048ab..c71ec0b540 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisReader.java
@@ -20,10 +20,8 @@
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
-import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.ogg.VorbisUtil.Mode;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
@@ -32,16 +30,12 @@
 import java.util.ArrayList;
 
 /**
- * {@link Extractor} to extract Vorbis data out of Ogg byte stream.
+ * {@link StreamReader} to extract Vorbis data out of Ogg byte stream.
  */
-public final class OggVorbisExtractor implements Extractor, SeekMap {
+/* package */ final class VorbisReader extends StreamReader implements SeekMap {
 
-  private final ParsableByteArray scratch = new ParsableByteArray(
-      new byte[OggReader.OGG_MAX_SEGMENT_SIZE * 255], 0);
+  private static final long LARGEST_EXPECTED_PAGE_SIZE = 8000;
 
-  private final OggReader oggReader = new OggReader();
-
-  private TrackOutput trackOutput;
   private VorbisSetup vorbisSetup;
   private int previousPacketBlockSize;
   private long elapsedSamples;
@@ -50,7 +44,6 @@
   private final OggSeeker oggSeeker = new OggSeeker();
   private long targetGranule = -1;
 
-  private ExtractorOutput extractorOutput;
   private VorbisUtil.VorbisIdHeader vorbisIdHeader;
   private VorbisUtil.CommentHeader commentHeader;
   private long inputLength;
@@ -58,44 +51,20 @@
   private long totalSamples;
   private long duration;
 
-  @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+  /* package */ static boolean verifyBitstreamType(ParsableByteArray data) {
     try {
-      OggUtil.PageHeader header = new OggUtil.PageHeader();
-      if (!OggUtil.populatePageHeader(input, header, scratch, true)
-          || (header.type & 0x02) != 0x02 || header.bodySize < 7) {
-        return false;
-      }
-      scratch.reset();
-      input.peekFully(scratch.data, 0, 7);
-      return VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, scratch, true);
+      return VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, data, true);
     } catch (ParserException e) {
-      // does not happen
-    } finally {
-      scratch.reset();
+      return false;
     }
-    return false;
-  }
-
-  @Override
-  public void init(ExtractorOutput output) {
-    trackOutput = output.track(0);
-    output.endTracks();
-    extractorOutput = output;
   }
 
   @Override
   public void seek() {
-    oggReader.reset();
+    super.seek();
     previousPacketBlockSize = 0;
     elapsedSamples = 0;
     seenFirstAudioPacket = false;
-    scratch.reset();
-  }
-
-  @Override
-  public void release() {
-    // Do nothing
   }
 
   @Override
@@ -111,12 +80,12 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
         extractorOutput.seekMap(this);
         if (inputLength != C.LENGTH_UNBOUNDED) {
           // seek to the end just before the last page of stream to get the duration
-          seekPosition.position = input.getLength() - 8000;
-          return RESULT_SEEK;
+          seekPosition.position = Math.max(0, input.getLength() - LARGEST_EXPECTED_PAGE_SIZE);
+          return Extractor.RESULT_SEEK;
         }
       }
       totalSamples = inputLength == C.LENGTH_UNBOUNDED ? -1
-          : oggReader.readGranuleOfLastPage(input);
+          : oggParser.readGranuleOfLastPage(input);
 
       ArrayList<byte[]> codecInitialisationData = new ArrayList<>();
       codecInitialisationData.add(vorbisSetup.idHeader.data);
@@ -125,7 +94,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       duration = inputLength == C.LENGTH_UNBOUNDED ? C.UNKNOWN_TIME_US
           : totalSamples * C.MICROS_PER_SECOND / vorbisSetup.idHeader.sampleRate;
       trackOutput.format(MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_VORBIS,
-          this.vorbisSetup.idHeader.bitrateNominal, OggReader.OGG_MAX_SEGMENT_SIZE * 255, duration,
+          this.vorbisSetup.idHeader.bitrateNominal, OggParser.OGG_MAX_SEGMENT_SIZE * 255, duration,
           this.vorbisSetup.idHeader.channels, (int) this.vorbisSetup.idHeader.sampleRate,
           codecInitialisationData, null));
 
@@ -133,7 +102,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
         oggSeeker.setup(inputLength - audioStartPosition, totalSamples);
         // seek back to resume from where we finished reading vorbis headers
         seekPosition.position = audioStartPosition;
-        return RESULT_SEEK;
+        return Extractor.RESULT_SEEK;
       }
     }
 
@@ -143,18 +112,17 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       long position = oggSeeker.getNextSeekPosition(targetGranule, input);
       if (position != -1) {
         seekPosition.position = position;
-        return RESULT_SEEK;
+        return Extractor.RESULT_SEEK;
       } else {
-        elapsedSamples = oggReader.skipToPageOfGranule(input, targetGranule);
+        elapsedSamples = oggParser.skipToPageOfGranule(input, targetGranule);
         previousPacketBlockSize = vorbisIdHeader.blockSize0;
         // we're never at the first packet after seeking
         seenFirstAudioPacket = true;
-        oggSeeker.reset();
       }
     }
 
     // playback
-    if (oggReader.readPacket(input, scratch)) {
+    if (oggParser.readPacket(input, scratch)) {
       // if this is an audio packet...
       if ((scratch.data[0] & 0x01) != 1) {
         // ... we need to decode the block size
@@ -178,9 +146,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
         previousPacketBlockSize = packetBlockSize;
       }
       scratch.reset();
-      return RESULT_CONTINUE;
+      return Extractor.RESULT_CONTINUE;
     }
-    return RESULT_END_OF_INPUT;
+    return Extractor.RESULT_END_OF_INPUT;
   }
 
   //@VisibleForTesting
@@ -188,18 +156,18 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
 
     if (vorbisIdHeader == null) {
-      oggReader.readPacket(input, scratch);
+      oggParser.readPacket(input, scratch);
       vorbisIdHeader = VorbisUtil.readVorbisIdentificationHeader(scratch);
       scratch.reset();
     }
 
     if (commentHeader == null) {
-      oggReader.readPacket(input, scratch);
+      oggParser.readPacket(input, scratch);
       commentHeader = VorbisUtil.readVorbisCommentHeader(scratch);
       scratch.reset();
     }
 
-    oggReader.readPacket(input, scratch);
+    oggParser.readPacket(input, scratch);
     // the third packet contains the setup header
     byte[] setupHeaderData = new byte[scratch.limit()];
     // raw data of vorbis setup header has to be passed to decoder as CSD buffer #2
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
index 2ae8e24560..0e8ffb10db 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -101,6 +101,10 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
         input.peekFully(scratch.data, 0, 4);
         scratchBits.setPosition(14);
         int frameSize = scratchBits.readBits(13);
+        // Either the stream is malformed OR we're not parsing an ADTS stream.
+        if (frameSize <= 6) {
+          return false;
+        }
         input.advancePeekPosition(frameSize - 6);
         validFramesSize += frameSize;
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
index c83da2f6d8..345c1aaf8d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
@@ -90,7 +90,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
               wavHeader.getNumChannels(),
               wavHeader.getSampleRateHz(),
               null,
-              null));
+              null,
+              wavHeader.getEncoding()));
       extractorOutput.seekMap(this);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
index 24fb83ecd8..4ebdfcbc45 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
@@ -30,6 +30,9 @@
   private final int blockAlignment;
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
+  /** The pcm encoding */
+  private final int encoding;
+
   /** Offset to the start of sample data. */
   private long dataStartPosition;
   /** Total size in bytes of the sample data. */
@@ -40,12 +43,14 @@ public WavHeader(
       int sampleRateHz,
       int averageBytesPerSecond,
       int blockAlignment,
-      int bitsPerSample) {
+      int bitsPerSample,
+      int encoding) {
     this.numChannels = numChannels;
     this.sampleRateHz = sampleRateHz;
     this.averageBytesPerSecond = averageBytesPerSecond;
     this.blockAlignment = blockAlignment;
     this.bitsPerSample = bitsPerSample;
+    this.encoding = encoding;
   }
 
   /** Returns the duration in microseconds of this WAV. */
@@ -110,4 +115,10 @@ public void setDataBounds(long dataStartPosition, long dataSize) {
     this.dataStartPosition = dataStartPosition;
     this.dataSize = dataSize;
   }
+
+  /** Returns the PCM encoding. **/
+  public int getEncoding() {
+    return encoding;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
index 3a0ab83265..2407a68129 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.wav;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.util.Assertions;
@@ -53,8 +54,8 @@ public static WavHeader peek(ExtractorInput input)
     ParsableByteArray scratch = new ParsableByteArray(16);
 
     // Attempt to read the RIFF chunk.
-    ChunkHeader riffChunkHeader = ChunkHeader.peek(input, scratch);
-    if (riffChunkHeader.id != Util.getIntegerCodeForString("RIFF")) {
+    ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
+    if (chunkHeader.id != Util.getIntegerCodeForString("RIFF")) {
       return null;
     }
 
@@ -66,14 +67,14 @@ public static WavHeader peek(ExtractorInput input)
       return null;
     }
 
-    // Attempt to read the format chunk.
-    ChunkHeader formatChunkHeader = ChunkHeader.peek(input, scratch);
-    if (formatChunkHeader.id != Util.getIntegerCodeForString("fmt ")) {
-      throw new ParserException(
-          "Second chunk in RIFF WAV should be format; got: " + formatChunkHeader.id);
+    // Skip chunks until we find the format chunk.
+    chunkHeader = ChunkHeader.peek(input, scratch);
+    while (chunkHeader.id != Util.getIntegerCodeForString("fmt ")) {
+      input.advancePeekPosition((int) chunkHeader.size);
+      chunkHeader = ChunkHeader.peek(input, scratch);
     }
-    Assertions.checkState(formatChunkHeader.size >= 16);
 
+    Assertions.checkState(chunkHeader.size >= 16);
     input.peekFully(scratch.data, 0, 16);
     scratch.setPosition(0);
     int type = scratch.readLittleEndianUnsignedShort();
@@ -85,14 +86,13 @@ public static WavHeader peek(ExtractorInput input)
 
     int expectedBlockAlignment = numChannels * bitsPerSample / 8;
     if (blockAlignment != expectedBlockAlignment) {
-      throw new ParserException(
-          "Expected WAV block alignment of: "
-              + expectedBlockAlignment
-              + "; got: "
-              + blockAlignment);
+      throw new ParserException("Expected block alignment: " + expectedBlockAlignment + "; got: "
+          + blockAlignment);
     }
-    if (bitsPerSample != 16) {
-      Log.e(TAG, "Only 16-bit WAVs are supported; got: " + bitsPerSample);
+
+    int encoding = Util.getPcmEncoding(bitsPerSample);
+    if (encoding == C.ENCODING_INVALID) {
+      Log.e(TAG, "Unsupported WAV bit depth: " + bitsPerSample);
       return null;
     }
 
@@ -102,10 +102,10 @@ public static WavHeader peek(ExtractorInput input)
     }
 
     // If present, skip extensionSize, validBitsPerSample, channelMask, subFormatGuid, ...
-    input.advancePeekPosition((int) formatChunkHeader.size - 16);
+    input.advancePeekPosition((int) chunkHeader.size - 16);
 
-    return new WavHeader(
-        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample);
+    return new WavHeader(numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment,
+        bitsPerSample, encoding);
   }
 
   /**
@@ -126,6 +126,9 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     Assertions.checkNotNull(input);
     Assertions.checkNotNull(wavHeader);
 
+    // Make sure the peek position is set to the read position before we peek the first header.
+    input.resetPeekPosition();
+
     ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
     // Skip all chunks until we hit the data header.
     ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index eacb3199a5..6155620f09 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -1217,6 +1217,7 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         throws ParserException {
       String mimeType;
       int maxInputSize = MediaFormat.NO_VALUE;
+      int pcmEncoding = MediaFormat.NO_VALUE;
       List<byte[]> initializationData = null;
       switch (codecId) {
         case CODEC_ID_VP8:
@@ -1264,9 +1265,9 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
           initializationData = new ArrayList<>(3);
           initializationData.add(codecPrivate);
           initializationData.add(
-              ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(codecDelayNs).array());
+              ByteBuffer.allocate(8).order(ByteOrder.nativeOrder()).putLong(codecDelayNs).array());
           initializationData.add(
-              ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(seekPreRollNs).array());
+              ByteBuffer.allocate(8).order(ByteOrder.nativeOrder()).putLong(seekPreRollNs).array());
           break;
         case CODEC_ID_AAC:
           mimeType = MimeTypes.AUDIO_AAC;
@@ -1301,13 +1302,15 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
           if (!parseMsAcmCodecPrivate(new ParsableByteArray(codecPrivate))) {
             throw new ParserException("Non-PCM MS/ACM is unsupported");
           }
-          if (audioBitDepth != 16) {
+          pcmEncoding = Util.getPcmEncoding(audioBitDepth);
+          if (pcmEncoding == C.ENCODING_INVALID) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
         case CODEC_ID_PCM_INT_LIT:
           mimeType = MimeTypes.AUDIO_RAW;
-          if (audioBitDepth != 16) {
+          pcmEncoding = Util.getPcmEncoding(audioBitDepth);
+          if (pcmEncoding == C.ENCODING_INVALID) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
@@ -1331,7 +1334,7 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       if (MimeTypes.isAudio(mimeType)) {
         format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, maxInputSize, durationUs, channelCount, sampleRate,
-            initializationData, language);
+            initializationData, language, pcmEncoding);
       } else if (MimeTypes.isVideo(mimeType)) {
         if (displayUnit == Track.DISPLAY_UNIT_PIXELS) {
           displayWidth = displayWidth == MediaFormat.NO_VALUE ? width : displayWidth;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 853f6b3c67..9d1f2587bc 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -164,8 +164,7 @@
    *     playback must have exactly one master source, which should be the source providing video
    *     chunks (or audio chunks for audio only playbacks).
    * @param dataSource A {@link DataSource} suitable for loading the media data.
-   * @param playlistUrl The playlist URL.
-   * @param playlist The hls playlist.
+   * @param playlist The HLS playlist.
    * @param trackSelector Selects tracks to be exposed by this source.
    * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
    * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
@@ -175,10 +174,10 @@
    *     {@link #ADAPTIVE_MODE_NONE}, {@link #ADAPTIVE_MODE_ABRUPT} and
    *     {@link #ADAPTIVE_MODE_SPLICE}.
    */
-  public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUrl,
-      HlsPlaylist playlist, HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
+  public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
+      HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
       PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode) {
-    this(isMaster, dataSource, playlistUrl, playlist, trackSelector, bandwidthMeter,
+    this(isMaster, dataSource, playlist, trackSelector, bandwidthMeter,
         timestampAdjusterProvider, adaptiveMode, DEFAULT_MIN_BUFFER_TO_SWITCH_UP_MS,
         DEFAULT_MAX_BUFFER_TO_SWITCH_DOWN_MS);
   }
@@ -188,8 +187,7 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUr
    *     playback must have exactly one master source, which should be the source providing video
    *     chunks (or audio chunks for audio only playbacks).
    * @param dataSource A {@link DataSource} suitable for loading the media data.
-   * @param playlistUrl The playlist URL.
-   * @param playlist The hls playlist.
+   * @param playlist The HLS playlist.
    * @param trackSelector Selects tracks to be exposed by this source.
    * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
    * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. If
@@ -203,8 +201,8 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUr
    * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be buffered
    *     for a switch to a lower quality variant to be considered.
    */
-  public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUrl,
-      HlsPlaylist playlist, HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
+  public HlsChunkSource(boolean isMaster, DataSource dataSource, HlsPlaylist playlist,
+      HlsTrackSelector trackSelector, BandwidthMeter bandwidthMeter,
       PtsTimestampAdjusterProvider timestampAdjusterProvider, int adaptiveMode,
       long minBufferDurationToSwitchUpMs, long maxBufferDurationToSwitchDownMs) {
     this.isMaster = isMaster;
@@ -225,8 +223,8 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUr
       Format format = new Format("0", MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1, -1, null,
           null);
       List<Variant> variants = new ArrayList<>();
-      variants.add(new Variant(playlistUrl, format));
-      masterPlaylist = new HlsMasterPlaylist(playlistUrl, variants,
+      variants.add(new Variant(baseUri, format));
+      masterPlaylist = new HlsMasterPlaylist(baseUri, variants,
           Collections.<Variant>emptyList(), Collections.<Variant>emptyList(), null, null);
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index 1ed68da072..d7731bb48d 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -305,11 +305,11 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       return NOTHING_READ;
     }
 
-    if (downstreamFormat == null || !downstreamFormat.equals(extractor.format)) {
-      // Notify a change in the downstream format.
-      notifyDownstreamFormatChanged(extractor.format, extractor.trigger, extractor.startTimeUs);
-      downstreamFormat = extractor.format;
+    Format format = extractor.format;
+    if (!format.equals(downstreamFormat)) {
+      notifyDownstreamFormatChanged(format, extractor.trigger, extractor.startTimeUs);
     }
+    downstreamFormat = format;
 
     if (extractors.size() > 1) {
       // If there's more than one extractor, attempt to configure a seamless splice from the
@@ -329,10 +329,17 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     MediaFormat mediaFormat = extractor.getMediaFormat(extractorTrack);
-    if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormats[track])) {
-      formatHolder.format = mediaFormat;
+    if (mediaFormat != null) {
+      if (!mediaFormat.equals(downstreamMediaFormats[track])) {
+        formatHolder.format = mediaFormat;
+        downstreamMediaFormats[track] = mediaFormat;
+        return FORMAT_READ;
+      }
+      // If mediaFormat and downstreamMediaFormat[track] are equal but different objects then the
+      // equality check above will have been expensive, comparing the fields in each format. We
+      // update downstreamMediaFormat here so that referential equality can be cheaply established
+      // during subsequent calls.
       downstreamMediaFormats[track] = mediaFormat;
-      return FORMAT_READ;
     }
 
     if (extractor.getSample(extractorTrack, sampleHolder)) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
index d393875c57..abf9a4643c 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
@@ -15,12 +15,17 @@
  */
 package com.google.android.exoplayer.text.ttml;
 
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.util.Assertions;
+
 import android.text.SpannableStringBuilder;
 
 import java.util.ArrayList;
-import java.util.Iterator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import java.util.TreeMap;
 import java.util.TreeSet;
 
 /**
@@ -45,13 +50,16 @@
   public static final String TAG_SMPTE_DATA = "smpte:data";
   public static final String TAG_SMPTE_INFORMATION = "smpte:information";
 
+  public static final String ANONYMOUS_REGION_ID = "";
   public static final String ATTR_ID = "id";
   public static final String ATTR_TTS_BACKGROUND_COLOR = "backgroundColor";
+  public static final String ATTR_TTS_EXTENT = "extent";
   public static final String ATTR_TTS_FONT_STYLE = "fontStyle";
   public static final String ATTR_TTS_FONT_SIZE = "fontSize";
   public static final String ATTR_TTS_FONT_FAMILY = "fontFamily";
   public static final String ATTR_TTS_FONT_WEIGHT = "fontWeight";
   public static final String ATTR_TTS_COLOR = "color";
+  public static final String ATTR_TTS_ORIGIN = "origin";
   public static final String ATTR_TTS_TEXT_DECORATION = "textDecoration";
   public static final String ATTR_TTS_TEXT_ALIGN = "textAlign";
 
@@ -74,24 +82,26 @@
   public final long startTimeUs;
   public final long endTimeUs;
   public final TtmlStyle style;
-  private String[] styleIds;
+  public final String regionId;
+
+  private final String[] styleIds;
+  private final HashMap<String, Integer> nodeStartsByRegion;
+  private final HashMap<String, Integer> nodeEndsByRegion;
 
   private List<TtmlNode> children;
-  private int start;
-  private int end;
 
   public static TtmlNode buildTextNode(String text) {
     return new TtmlNode(null, TtmlRenderUtil.applyTextElementSpacePolicy(text), UNDEFINED_TIME,
-        UNDEFINED_TIME, null, null);
+        UNDEFINED_TIME, null, null, ANONYMOUS_REGION_ID);
   }
 
   public static TtmlNode buildNode(String tag, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds) {
-    return new TtmlNode(tag, null, startTimeUs, endTimeUs, style, styleIds);
+      TtmlStyle style, String[] styleIds, String regionId) {
+    return new TtmlNode(tag, null, startTimeUs, endTimeUs, style, styleIds, regionId);
   }
 
   private TtmlNode(String tag, String text, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds) {
+      TtmlStyle style, String[] styleIds, String regionId) {
     this.tag = tag;
     this.text = text;
     this.style = style;
@@ -99,6 +109,9 @@ private TtmlNode(String tag, String text, long startTimeUs, long endTimeUs,
     this.isTextNode = text != null;
     this.startTimeUs = startTimeUs;
     this.endTimeUs = endTimeUs;
+    this.regionId = Assertions.checkNotNull(regionId);
+    nodeStartsByRegion = new HashMap<>();
+    nodeEndsByRegion = new HashMap<>();
   }
 
   public boolean isActive(long timeUs) {
@@ -130,10 +143,8 @@ public int getChildCount() {
     TreeSet<Long> eventTimeSet = new TreeSet<>();
     getEventTimes(eventTimeSet, false);
     long[] eventTimes = new long[eventTimeSet.size()];
-    Iterator<Long> eventTimeIterator = eventTimeSet.iterator();
     int i = 0;
-    while (eventTimeIterator.hasNext()) {
-      long eventTimeUs = eventTimeIterator.next();
+    for (long eventTimeUs : eventTimeSet) {
       eventTimes[i++] = eventTimeUs;
     }
     return eventTimes;
@@ -161,10 +172,83 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     return styleIds;
   }
 
-  public CharSequence getText(long timeUs, Map<String, TtmlStyle> globalStyles) {
-    SpannableStringBuilder builder = new SpannableStringBuilder();
-    traverseForText(timeUs, builder, false);
-    traverseForStyle(builder, globalStyles);
+  public List<Cue> getCues(long timeUs, Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap) {
+    TreeMap<String, SpannableStringBuilder> regionOutputs = new TreeMap<>();
+    traverseForText(timeUs, false, regionId, regionOutputs);
+    traverseForStyle(globalStyles, regionOutputs);
+    List<Cue> cues = new ArrayList<>();
+    for (Entry<String, SpannableStringBuilder> entry : regionOutputs.entrySet()) {
+      TtmlRegion region = regionMap.get(entry.getKey());
+      cues.add(new Cue(cleanUpText(entry.getValue()), null, region.line, Cue.TYPE_UNSET,
+          Cue.TYPE_UNSET, region.position, Cue.TYPE_UNSET, region.width));
+    }
+    return cues;
+  }
+
+  private void traverseForText(long timeUs,  boolean descendsPNode,
+      String inheritedRegion, Map<String, SpannableStringBuilder> regionOutputs) {
+    nodeStartsByRegion.clear();
+    nodeEndsByRegion.clear();
+    String resolvedRegionId = regionId;
+    if (ANONYMOUS_REGION_ID.equals(resolvedRegionId)) {
+      resolvedRegionId = inheritedRegion;
+    }
+    if (isTextNode && descendsPNode) {
+      getRegionOutput(resolvedRegionId, regionOutputs).append(text);
+    } else if (TAG_BR.equals(tag) && descendsPNode) {
+      getRegionOutput(resolvedRegionId, regionOutputs).append('\n');
+    } else if (TAG_METADATA.equals(tag)) {
+      // Do nothing.
+    } else if (isActive(timeUs)) {
+      boolean isPNode = TAG_P.equals(tag);
+      for (Entry<String, SpannableStringBuilder> entry : regionOutputs.entrySet()) {
+        nodeStartsByRegion.put(entry.getKey(), entry.getValue().length());
+      }
+      for (int i = 0; i < getChildCount(); i++) {
+        getChild(i).traverseForText(timeUs, descendsPNode || isPNode, resolvedRegionId,
+            regionOutputs);
+      }
+      if (isPNode) {
+        TtmlRenderUtil.endParagraph(getRegionOutput(resolvedRegionId, regionOutputs));
+      }
+      for (Entry<String, SpannableStringBuilder> entry : regionOutputs.entrySet()) {
+        nodeEndsByRegion.put(entry.getKey(), entry.getValue().length());
+      }
+    }
+  }
+
+  private static SpannableStringBuilder getRegionOutput(String resolvedRegionId,
+      Map<String, SpannableStringBuilder> regionOutputs) {
+    if (!regionOutputs.containsKey(resolvedRegionId)) {
+      regionOutputs.put(resolvedRegionId, new SpannableStringBuilder());
+    }
+    return regionOutputs.get(resolvedRegionId);
+  }
+
+  private void traverseForStyle(Map<String, TtmlStyle> globalStyles,
+      Map<String, SpannableStringBuilder> regionOutputs) {
+    for (Entry<String, Integer> entry : nodeEndsByRegion.entrySet()) {
+      String regionId = entry.getKey();
+      int start = nodeStartsByRegion.containsKey(regionId) ? nodeStartsByRegion.get(regionId) : 0;
+      applyStyleToOutput(globalStyles, regionOutputs.get(regionId), start, entry.getValue());
+      for (int i = 0; i < getChildCount(); ++i) {
+        getChild(i).traverseForStyle(globalStyles, regionOutputs);
+      }
+    }
+  }
+
+  private void applyStyleToOutput(Map<String, TtmlStyle> globalStyles,
+      SpannableStringBuilder regionOutput, int start, int end) {
+    if (start != end) {
+      TtmlStyle resolvedStyle = TtmlRenderUtil.resolveStyle(style, styleIds, globalStyles);
+      if (resolvedStyle != null) {
+        TtmlRenderUtil.applyStylesToSpan(regionOutput, start, end, resolvedStyle);
+      }
+    }
+  }
+
+  private SpannableStringBuilder cleanUpText(SpannableStringBuilder builder) {
     // Having joined the text elements, we need to do some final cleanup on the result.
     // 1. Collapse multiple consecutive spaces into a single space.
     int builderLength = builder.length();
@@ -208,44 +292,7 @@ public CharSequence getText(long timeUs, Map<String, TtmlStyle> globalStyles) {
       builder.delete(builderLength - 1, builderLength);
       /*builderLength--;*/
     }
-
     return builder;
   }
 
-  private SpannableStringBuilder traverseForText(long timeUs, SpannableStringBuilder builder,
-      boolean descendsPNode) {
-    start = builder.length();
-    end = start;
-    if (isTextNode && descendsPNode) {
-      builder.append(text);
-    } else if (TAG_BR.equals(tag) && descendsPNode) {
-      builder.append('\n');
-    } else if (TAG_METADATA.equals(tag)) {
-      // Do nothing.
-    } else if (isActive(timeUs)) {
-      boolean isPNode = TAG_P.equals(tag);
-      for (int i = 0; i < getChildCount(); ++i) {
-        getChild(i).traverseForText(timeUs, builder, descendsPNode || isPNode);
-      }
-      if (isPNode) {
-        TtmlRenderUtil.endParagraph(builder);
-      }
-      end = builder.length();
-    }
-    return builder;
-  }
-
-  private void traverseForStyle(SpannableStringBuilder builder,
-      Map<String, TtmlStyle> globalStyles) {
-    if (start != end) {
-      TtmlStyle resolvedStyle = TtmlRenderUtil.resolveStyle(style, styleIds, globalStyles);
-      if (resolvedStyle != null) {
-        TtmlRenderUtil.applyStylesToSpan(builder, start, end, resolvedStyle);
-      }
-      for (int i = 0; i < getChildCount(); ++i) {
-        getChild(i).traverseForStyle(builder, globalStyles);
-      }
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index 2b089f258a..9c72753706 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -1,4 +1,4 @@
-/*
+/*arse
  * Copyright (C) 2014 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParserUtil;
@@ -24,6 +25,7 @@
 
 import android.text.Layout;
 import android.util.Log;
+import android.util.Pair;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
@@ -66,14 +68,16 @@
   private static final String ATTR_DURATION = "dur";
   private static final String ATTR_END = "end";
   private static final String ATTR_STYLE = "style";
+  private static final String ATTR_REGION = "region";
 
   private static final Pattern CLOCK_TIME =
       Pattern.compile("^([0-9][0-9]+):([0-9][0-9]):([0-9][0-9])"
           + "(?:(\\.[0-9]+)|:([0-9][0-9])(?:\\.([0-9]+))?)?$");
   private static final Pattern OFFSET_TIME =
       Pattern.compile("^([0-9]+(?:\\.[0-9]+)?)(h|m|s|ms|f|t)$");
-  private static final Pattern FONT_SIZE =
-      Pattern.compile("^(([0-9]*.)?[0-9]+)(px|em|%)$");
+  private static final Pattern FONT_SIZE = Pattern.compile("^(([0-9]*.)?[0-9]+)(px|em|%)$");
+  private static final Pattern PERCENTAGE_COORDINATES =
+      Pattern.compile("^(\\d+\\.?\\d*?)% (\\d+\\.?\\d*?)%$");
 
   // TODO: read and apply the following attributes if specified.
   private static final int DEFAULT_FRAMERATE = 30;
@@ -85,6 +89,7 @@
   public TtmlParser() {
     try {
       xmlParserFactory = XmlPullParserFactory.newInstance();
+      xmlParserFactory.setNamespaceAware(true);
     } catch (XmlPullParserException e) {
       throw new RuntimeException("Couldn't create XmlPullParserFactory instance", e);
     }
@@ -100,6 +105,8 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
     try {
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
       Map<String, TtmlStyle> globalStyles = new HashMap<>();
+      Map<String, TtmlRegion> regionMap = new HashMap<>();
+      regionMap.put(TtmlNode.ANONYMOUS_REGION_ID, new TtmlRegion());
       ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes, offset, length);
       xmlParser.setInput(inputStream, null);
       TtmlSubtitle ttmlSubtitle = null;
@@ -115,10 +122,10 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
               Log.i(TAG, "Ignoring unsupported tag: " + xmlParser.getName());
               unsupportedNodeDepth++;
             } else if (TtmlNode.TAG_HEAD.equals(name)) {
-              parseHeader(xmlParser, globalStyles);
+              parseHeader(xmlParser, globalStyles, regionMap);
             } else {
               try {
-                TtmlNode node = parseNode(xmlParser, parent);
+                TtmlNode node = parseNode(xmlParser, parent, regionMap);
                 nodeStack.addLast(node);
                 if (parent != null) {
                   parent.addChild(node);
@@ -133,7 +140,7 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
             parent.addChild(TtmlNode.buildTextNode(xmlParser.getText()));
           } else if (eventType == XmlPullParser.END_TAG) {
             if (xmlParser.getName().equals(TtmlNode.TAG_TT)) {
-              ttmlSubtitle = new TtmlSubtitle(nodeStack.getLast(), globalStyles);
+              ttmlSubtitle = new TtmlSubtitle(nodeStack.getLast(), globalStyles, regionMap);
             }
             nodeStack.removeLast();
           }
@@ -156,13 +163,12 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
   }
 
   private Map<String, TtmlStyle> parseHeader(XmlPullParser xmlParser,
-      Map<String, TtmlStyle> globalStyles)
+      Map<String, TtmlStyle> globalStyles, Map<String, TtmlRegion> globalRegions)
       throws IOException, XmlPullParserException {
-
     do {
       xmlParser.next();
       if (ParserUtil.isStartTag(xmlParser, TtmlNode.TAG_STYLE)) {
-        String parentStyleId = xmlParser.getAttributeValue(null, ATTR_STYLE);
+        String parentStyleId = ParserUtil.getAttributeValue(xmlParser, ATTR_STYLE);
         TtmlStyle style = parseStyleAttributes(xmlParser, new TtmlStyle());
         if (parentStyleId != null) {
           String[] ids = parseStyleIds(parentStyleId);
@@ -173,11 +179,54 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
         if (style.getId() != null) {
           globalStyles.put(style.getId(), style);
         }
+      } else if (ParserUtil.isStartTag(xmlParser, TtmlNode.TAG_REGION)) {
+        Pair<String, TtmlRegion> ttmlRegionInfo = parseRegionAttributes(xmlParser);
+        if (ttmlRegionInfo != null) {
+          globalRegions.put(ttmlRegionInfo.first, ttmlRegionInfo.second);
+        }
       }
     } while (!ParserUtil.isEndTag(xmlParser, TtmlNode.TAG_HEAD));
     return globalStyles;
   }
 
+  /**
+   * Parses a region declaration. Supports origin and extent definition but only when defined in
+   * terms of percentage of the viewport. Regions that do not correctly declare origin are ignored.
+   */
+  private Pair<String, TtmlRegion> parseRegionAttributes(XmlPullParser xmlParser) {
+    String regionId = ParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);
+    String regionOrigin = ParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);
+    String regionExtent = ParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
+    if (regionOrigin == null || regionId == null) {
+      return null;
+    }
+    float position = Cue.DIMEN_UNSET;
+    float line = Cue.DIMEN_UNSET;
+    Matcher originMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
+    if (originMatcher.matches()) {
+      try {
+        position = Float.parseFloat(originMatcher.group(1)) / 100.f;
+        line = Float.parseFloat(originMatcher.group(2)) / 100.f;
+      } catch (NumberFormatException e) {
+        Log.w(TAG, "Ignoring region with malformed origin: '" + regionOrigin + "'", e);
+        position = Cue.DIMEN_UNSET;
+      }
+    }
+    float width = Cue.DIMEN_UNSET;
+    if (regionExtent != null) {
+      Matcher extentMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
+      if (extentMatcher.matches()) {
+        try {
+          width = Float.parseFloat(extentMatcher.group(1)) / 100.f;
+        } catch (NumberFormatException e) {
+          Log.w(TAG, "Ignoring malformed region extent: '" + regionExtent + "'", e);
+        }
+      }
+    }
+    return position != Cue.DIMEN_UNSET ? new Pair<>(regionId, new TtmlRegion(position, line, width))
+        : null;
+  }
+
   private String[] parseStyleIds(String parentStyleIds) {
     return parentStyleIds.split("\\s+");
   }
@@ -185,9 +234,8 @@ public TtmlSubtitle parse(byte[] bytes, int offset, int length) throws ParserExc
   private TtmlStyle parseStyleAttributes(XmlPullParser parser, TtmlStyle style) {
     int attributeCount = parser.getAttributeCount();
     for (int i = 0; i < attributeCount; i++) {
-      String attributeName = parser.getAttributeName(i);
       String attributeValue = parser.getAttributeValue(i);
-      switch (ParserUtil.removeNamespacePrefix(attributeName)) {
+      switch (parser.getAttributeName(i)) {
         case TtmlNode.ATTR_ID:
           if (TtmlNode.TAG_STYLE.equals(parser.getName())) {
             style = createIfNull(style).setId(attributeValue);
@@ -204,7 +252,7 @@ private TtmlStyle parseStyleAttributes(XmlPullParser parser, TtmlStyle style) {
         case TtmlNode.ATTR_TTS_COLOR:
           style = createIfNull(style);
           try {
-            style.setColor(TtmlColorParser.parseColor(attributeValue));
+            style.setFontColor(TtmlColorParser.parseColor(attributeValue));
           } catch (IllegalArgumentException e) {
             Log.w(TAG, "failed parsing color value: '" + attributeValue + "'");
           }
@@ -275,31 +323,37 @@ private TtmlStyle createIfNull(TtmlStyle style) {
     return style == null ? new TtmlStyle() : style;
   }
 
-  private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent) throws ParserException {
+  private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
+      Map<String, TtmlRegion> regionMap) throws ParserException {
     long duration = 0;
     long startTime = TtmlNode.UNDEFINED_TIME;
     long endTime = TtmlNode.UNDEFINED_TIME;
+    String regionId = TtmlNode.ANONYMOUS_REGION_ID;
     String[] styleIds = null;
     int attributeCount = parser.getAttributeCount();
     TtmlStyle style = parseStyleAttributes(parser, null);
     for (int i = 0; i < attributeCount; i++) {
-      String attr = ParserUtil.removeNamespacePrefix(parser.getAttributeName(i));
+      String attr = parser.getAttributeName(i);
       String value = parser.getAttributeValue(i);
-      if (attr.equals(ATTR_BEGIN)) {
+      if (ATTR_BEGIN.equals(attr)) {
         startTime = parseTimeExpression(value,
             DEFAULT_FRAMERATE, DEFAULT_SUBFRAMERATE, DEFAULT_TICKRATE);
-      } else if (attr.equals(ATTR_END)) {
+      } else if (ATTR_END.equals(attr)) {
         endTime = parseTimeExpression(value,
             DEFAULT_FRAMERATE, DEFAULT_SUBFRAMERATE, DEFAULT_TICKRATE);
-      } else if (attr.equals(ATTR_DURATION)) {
+      } else if (ATTR_DURATION.equals(attr)) {
         duration = parseTimeExpression(value,
             DEFAULT_FRAMERATE, DEFAULT_SUBFRAMERATE, DEFAULT_TICKRATE);
-      } else if (attr.equals(ATTR_STYLE)) {
+      } else if (ATTR_STYLE.equals(attr)) {
         // IDREFS: potentially multiple space delimited ids
         String[] ids = parseStyleIds(value);
         if (ids.length > 0) {
           styleIds = ids;
         }
+      } else if (ATTR_REGION.equals(attr) && regionMap.containsKey(value)) {
+        // If the region has not been correctly declared or does not define a position, we use the
+        // anonymous region.
+        regionId = value;
       } else {
         // Do nothing.
       }
@@ -321,7 +375,7 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent) throws ParserE
         endTime = parent.endTimeUs;
       }
     }
-    return TtmlNode.buildNode(parser.getName(), startTime, endTime, style, styleIds);
+    return TtmlNode.buildNode(parser.getName(), startTime, endTime, style, styleIds, regionId);
   }
 
   private static boolean isSupportedTag(String tag) {
@@ -352,10 +406,11 @@ private static void parseFontSize(String expression, TtmlStyle out) throws Parse
       matcher = FONT_SIZE.matcher(expression);
     } else if (expressions.length == 2){
       matcher = FONT_SIZE.matcher(expressions[1]);
-      Log.w(TAG, "multiple values in fontSize attribute. Picking the second "
-          + "value for vertical font size and ignoring the first.");
+      Log.w(TAG, "Multiple values in fontSize attribute. Picking the second value for vertical font"
+          + " size and ignoring the first.");
     } else {
-      throw new ParserException();
+      throw new ParserException("Invalid number of entries for fontSize: " + expressions.length
+          + ".");
     }
 
     if (matcher.matches()) {
@@ -371,11 +426,11 @@ private static void parseFontSize(String expression, TtmlStyle out) throws Parse
           out.setFontSizeUnit(TtmlStyle.FONT_SIZE_UNIT_PERCENT);
           break;
         default:
-          throw new ParserException();
+          throw new ParserException("Invalid unit for fontSize: '" + unit + "'.");
       }
       out.setFontSize(Float.valueOf(matcher.group(1)));
     } else {
-      throw new ParserException();
+      throw new ParserException("Invalid expression for fontSize: '" + expression + "'.");
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRegion.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRegion.java
new file mode 100644
index 0000000000..135018a861
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRegion.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.ttml;
+
+import com.google.android.exoplayer.text.Cue;
+
+/**
+ * Represents a TTML Region.
+ */
+/* package */ final class TtmlRegion {
+
+  public final float position;
+  public final float line;
+  public final float width;
+
+  public TtmlRegion() {
+    this(Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.DIMEN_UNSET);
+  }
+
+  public TtmlRegion(float position, float line, float width) {
+    this.position = position;
+    this.line = line;
+    this.width = width;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
index a2bff2ec1d..a8c69d8ac2 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
@@ -38,29 +38,29 @@
   public static TtmlStyle resolveStyle(TtmlStyle style, String[] styleIds,
       Map<String, TtmlStyle> globalStyles) {
     if (style == null && styleIds == null) {
-      // no styles at all
+      // No styles at all.
       return null;
     } else if (style == null && styleIds.length == 1) {
-      // only one single referential style present
+      // Only one single referential style present.
       return globalStyles.get(styleIds[0]);
     } else if (style == null && styleIds.length > 1) {
-      // only multiple referential styles present
+      // Only multiple referential styles present.
       TtmlStyle chainedStyle = new TtmlStyle();
-      for (int i = 0; i < styleIds.length; i++) {
-        chainedStyle.chain(globalStyles.get(styleIds[i]));
+      for (String id : styleIds) {
+        chainedStyle.chain(globalStyles.get(id));
       }
       return chainedStyle;
     } else if (style != null && styleIds != null && styleIds.length == 1) {
-      // merge a single referential style into inline style
+      // Merge a single referential style into inline style.
       return style.chain(globalStyles.get(styleIds[0]));
     } else if (style != null && styleIds != null && styleIds.length > 1) {
-      // merge multiple referential styles into inline style
-      for (int i = 0; i < styleIds.length; i++) {
-        style.chain(globalStyles.get(styleIds[i]));
+      // Merge multiple referential styles into inline style.
+      for (String id : styleIds) {
+        style.chain(globalStyles.get(id));
       }
       return style;
     }
-    // only inline styles available
+    // Only inline styles available.
     return style;
   }
 
@@ -77,11 +77,11 @@ public static void applyStylesToSpan(SpannableStringBuilder builder,
     if (style.isUnderline()) {
       builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
-    if (style.hasColorSpecified()) {
-      builder.setSpan(new ForegroundColorSpan(style.getColor()), start, end,
+    if (style.hasFontColor()) {
+      builder.setSpan(new ForegroundColorSpan(style.getFontColor()), start, end,
           Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
-    if (style.hasBackgroundColorSpecified()) {
+    if (style.hasBackgroundColor()) {
       builder.setSpan(new BackgroundColorSpan(style.getBackgroundColor()), start, end,
           Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
index 4cb5f95a86..c8a40f4405 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
@@ -25,53 +25,55 @@
  */
 /* package */ final class TtmlStyle {
 
-  public static final short UNSPECIFIED = -1;
+  public static final int UNSPECIFIED = -1;
 
-  public static final short STYLE_NORMAL = Typeface.NORMAL;
-  public static final short STYLE_BOLD = Typeface.BOLD;
-  public static final short STYLE_ITALIC = Typeface.ITALIC;
-  public static final short STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
+  public static final int STYLE_NORMAL = Typeface.NORMAL;
+  public static final int STYLE_BOLD = Typeface.BOLD;
+  public static final int STYLE_ITALIC = Typeface.ITALIC;
+  public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
-  public static final short FONT_SIZE_UNIT_PIXEL = 1;
-  public static final short FONT_SIZE_UNIT_EM = 2;
-  public static final short FONT_SIZE_UNIT_PERCENT = 3;
+  public static final int FONT_SIZE_UNIT_PIXEL = 1;
+  public static final int FONT_SIZE_UNIT_EM = 2;
+  public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
-  private static final short OFF = 0;
-  private static final short ON = 1;
+  private static final int OFF = 0;
+  private static final int ON = 1;
 
   private String fontFamily;
-  private int color;
-  private boolean colorSpecified;
+  private int fontColor;
+  private boolean hasFontColor;
   private int backgroundColor;
-  private boolean backgroundColorSpecified;
-  private short linethrough = UNSPECIFIED;
-  private short underline = UNSPECIFIED;
-  private short bold = UNSPECIFIED;
-  private short italic = UNSPECIFIED;
-  private short fontSizeUnit = UNSPECIFIED;
+  private boolean hasBackgroundColor;
+  private int linethrough;
+  private int underline;
+  private int bold;
+  private int italic;
+  private int fontSizeUnit;
   private float fontSize;
   private String id;
   private TtmlStyle inheritableStyle;
   private Layout.Alignment textAlign;
 
+  public TtmlStyle() {
+    linethrough = UNSPECIFIED;
+    underline = UNSPECIFIED;
+    bold = UNSPECIFIED;
+    italic = UNSPECIFIED;
+    fontSizeUnit = UNSPECIFIED;
+  }
+
   /**
-   * Returns the style or <code>UNSPECIFIED</code> when no style information is given.
+   * Returns the style or {@link #UNSPECIFIED} when no style information is given.
    *
-   * @return UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_BOLD or STYLE_BOLD_ITALIC
+   * @return {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link #STYLE_BOLD}, {@link #STYLE_BOLD}
+   *     or {@link #STYLE_BOLD_ITALIC}.
    */
-  public short getStyle() {
+  public int getStyle() {
     if (bold == UNSPECIFIED && italic == UNSPECIFIED) {
       return UNSPECIFIED;
     }
-
-    short style = STYLE_NORMAL;
-    if (bold != UNSPECIFIED) {
-      style += bold;
-    }
-    if (italic != UNSPECIFIED){
-      style += italic;
-    }
-    return style;
+    return (bold != UNSPECIFIED ? bold : STYLE_NORMAL)
+        | (italic != UNSPECIFIED ? italic : STYLE_NORMAL);
   }
 
   public boolean isLinethrough() {
@@ -104,33 +106,39 @@ public TtmlStyle setFontFamily(String fontFamily) {
     return this;
   }
 
-  public int getColor() {
-    return color;
+  public int getFontColor() {
+    if (!hasFontColor) {
+      throw new IllegalStateException("Font color has not been defined.");
+    }
+    return fontColor;
   }
 
-  public TtmlStyle setColor(int color) {
+  public TtmlStyle setFontColor(int fontColor) {
     Assertions.checkState(inheritableStyle == null);
-    this.color = color;
-    colorSpecified = true;
+    this.fontColor = fontColor;
+    hasFontColor = true;
     return this;
   }
 
-  public boolean hasColorSpecified() {
-    return colorSpecified;
+  public boolean hasFontColor() {
+    return hasFontColor;
   }
 
   public int getBackgroundColor() {
+    if (!hasBackgroundColor) {
+      throw new IllegalStateException("Background color has not been defined.");
+    }
     return backgroundColor;
   }
 
   public TtmlStyle setBackgroundColor(int backgroundColor) {
     this.backgroundColor = backgroundColor;
-    backgroundColorSpecified = true;
+    hasBackgroundColor = true;
     return this;
   }
 
-  public boolean hasBackgroundColorSpecified() {
-    return backgroundColorSpecified;
+  public boolean hasBackgroundColor() {
+    return hasBackgroundColor;
   }
 
   public TtmlStyle setBold(boolean isBold) {
@@ -168,8 +176,8 @@ public TtmlStyle chain(TtmlStyle ancestor) {
 
   private TtmlStyle inherit(TtmlStyle ancestor, boolean chaining) {
     if (ancestor != null) {
-      if (!colorSpecified && ancestor.colorSpecified) {
-        setColor(ancestor.color);
+      if (!hasFontColor && ancestor.hasFontColor) {
+        setFontColor(ancestor.fontColor);
       }
       if (bold == UNSPECIFIED) {
         bold = ancestor.bold;
@@ -194,7 +202,7 @@ private TtmlStyle inherit(TtmlStyle ancestor, boolean chaining) {
         fontSize = ancestor.fontSize;
       }
       // attributes not inherited as of http://www.w3.org/TR/ttml1/
-      if (chaining && !backgroundColorSpecified && ancestor.backgroundColorSpecified) {
+      if (chaining && !hasBackgroundColor && ancestor.hasBackgroundColor) {
         setBackgroundColor(ancestor.backgroundColor);
       }
     }
@@ -224,12 +232,12 @@ public TtmlStyle setFontSize(float fontSize) {
     return this;
   }
 
-  public TtmlStyle setFontSizeUnit(short unit) {
-    this.fontSizeUnit = unit;
+  public TtmlStyle setFontSizeUnit(int fontSizeUnit) {
+    this.fontSizeUnit = fontSizeUnit;
     return this;
   }
 
-  public short getFontSizeUnit() {
+  public int getFontSizeUnit() {
     return fontSizeUnit;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
index a989bf86f8..e54bd8b52e 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
@@ -31,9 +31,12 @@
   private final TtmlNode root;
   private final long[] eventTimesUs;
   private final Map<String, TtmlStyle> globalStyles;
+  private final Map<String, TtmlRegion> regionMap;
 
-  public TtmlSubtitle(TtmlNode root, Map<String, TtmlStyle> globalStyles) {
+  public TtmlSubtitle(TtmlNode root, Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap) {
     this.root = root;
+    this.regionMap = regionMap;
     this.globalStyles = globalStyles != null
         ? Collections.unmodifiableMap(globalStyles) : Collections.<String, TtmlStyle>emptyMap();
     this.eventTimesUs = root.getEventTimesUs();
@@ -67,13 +70,7 @@ public long getLastEventTime() {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    CharSequence cueText = root.getText(timeUs, globalStyles);
-    if (cueText == null) {
-      return Collections.<Cue>emptyList();
-    } else {
-      Cue cue = new Cue(cueText);
-      return Collections.singletonList(cue);
-    }
+    return root.getCues(timeUs, globalStyles, regionMap);
   }
 
   /* @VisibleForTesting */
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
index 59d6c2bff2..6c3fe9a6e2 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
@@ -191,7 +191,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       connection = makeConnection(dataSpec);
     } catch (IOException e) {
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec);
+          dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     int responseCode;
@@ -200,7 +200,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     } catch (IOException e) {
       closeConnectionQuietly();
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec);
+          dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     // Check for a valid response code.
@@ -240,7 +240,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       inputStream = connection.getInputStream();
     } catch (IOException e) {
       closeConnectionQuietly();
-      throw new HttpDataSourceException(e, dataSpec);
+      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     opened = true;
@@ -257,7 +257,7 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
       skipInternal();
       return readInternal(buffer, offset, readLength);
     } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec);
+      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
     }
   }
 
@@ -269,7 +269,7 @@ public void close() throws HttpDataSourceException {
         try {
           inputStream.close();
         } catch (IOException e) {
-          throw new HttpDataSourceException(e, dataSpec);
+          throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_CLOSE);
         }
       }
     } finally {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
index c9d977cd87..c1e2337ce6 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
@@ -32,7 +32,7 @@
   /**
    * A {@link Predicate} that rejects content types often used for pay-walls.
    */
-  public static final Predicate<String> REJECT_PAYWALL_TYPES = new Predicate<String>() {
+  Predicate<String> REJECT_PAYWALL_TYPES = new Predicate<String>() {
 
     @Override
     public boolean evaluate(String contentType) {
@@ -47,31 +47,41 @@ public boolean evaluate(String contentType) {
   /**
    * Thrown when an error is encountered when trying to read from a {@link HttpDataSource}.
    */
-  public static class HttpDataSourceException extends IOException {
+  class HttpDataSourceException extends IOException {
 
-    /*
+    public static final int TYPE_OPEN = 1;
+    public static final int TYPE_READ = 2;
+    public static final int TYPE_CLOSE = 3;
+
+    public final int type;
+
+    /**
      * The {@link DataSpec} associated with the current connection.
      */
     public final DataSpec dataSpec;
 
-    public HttpDataSourceException(DataSpec dataSpec) {
+    public HttpDataSourceException(DataSpec dataSpec, int type) {
       super();
       this.dataSpec = dataSpec;
+      this.type = type;
     }
 
-    public HttpDataSourceException(String message, DataSpec dataSpec) {
+    public HttpDataSourceException(String message, DataSpec dataSpec, int type) {
       super(message);
       this.dataSpec = dataSpec;
+      this.type = type;
     }
 
-    public HttpDataSourceException(IOException cause, DataSpec dataSpec) {
+    public HttpDataSourceException(IOException cause, DataSpec dataSpec, int type) {
       super(cause);
       this.dataSpec = dataSpec;
+      this.type = type;
     }
 
-    public HttpDataSourceException(String message, IOException cause, DataSpec dataSpec) {
+    public HttpDataSourceException(String message, IOException cause, DataSpec dataSpec, int type) {
       super(message, cause);
       this.dataSpec = dataSpec;
+      this.type = type;
     }
 
   }
@@ -79,12 +89,12 @@ public HttpDataSourceException(String message, IOException cause, DataSpec dataS
   /**
    * Thrown when the content type is invalid.
    */
-  public static final class InvalidContentTypeException extends HttpDataSourceException {
+  final class InvalidContentTypeException extends HttpDataSourceException {
 
     public final String contentType;
 
     public InvalidContentTypeException(String contentType, DataSpec dataSpec) {
-      super("Invalid content type: " + contentType, dataSpec);
+      super("Invalid content type: " + contentType, dataSpec, TYPE_OPEN);
       this.contentType = contentType;
     }
 
@@ -93,7 +103,7 @@ public InvalidContentTypeException(String contentType, DataSpec dataSpec) {
   /**
    * Thrown when an attempt to open a connection results in a response code not in the 2xx range.
    */
-  public static final class InvalidResponseCodeException extends HttpDataSourceException {
+  final class InvalidResponseCodeException extends HttpDataSourceException {
 
     /**
      * The response code that was outside of the 2xx range.
@@ -107,7 +117,7 @@ public InvalidContentTypeException(String contentType, DataSpec dataSpec) {
 
     public InvalidResponseCodeException(int responseCode, Map<String, List<String>> headerFields,
         DataSpec dataSpec) {
-      super("Response code: " + responseCode, dataSpec);
+      super("Response code: " + responseCode, dataSpec, TYPE_OPEN);
       this.responseCode = responseCode;
       this.headerFields = headerFields;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index 86fc1b6129..4e60d78698 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -55,7 +55,7 @@ public SimpleCache(File cacheDir, CacheEvictor evictor) {
     this.listeners = new HashMap<>();
     // Start cache initialization.
     final ConditionVariable conditionVariable = new ConditionVariable();
-    new Thread() {
+    new Thread("SimpleCache.initialize()") {
       @Override
       public void run() {
         synchronized (SimpleCache.this) {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java b/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java
new file mode 100644
index 0000000000..5dbf0e2749
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacSeekTable.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import com.google.android.exoplayer.extractor.SeekMap;
+
+/**
+ * FLAC seek table class
+ */
+public final class FlacSeekTable {
+
+  private static final int METADATA_LENGTH_OFFSET = 1;
+  private static final int SEEK_POINT_SIZE = 18;
+
+  private final long[] sampleNumbers;
+  private final long[] offsets;
+
+  /**
+   * Parses a FLAC file seek table metadata structure and creates a FlacSeekTable instance.
+   *
+   * @param data A ParsableByteArray including whole seek table metadata block. Its position should
+   *     be set to the beginning of the block.
+   * @return A FlacSeekTable instance keeping seek table data
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_seektable">FLAC format
+   *     METADATA_BLOCK_SEEKTABLE</a>
+   */
+  public static FlacSeekTable parseSeekTable(ParsableByteArray data) {
+    data.skipBytes(METADATA_LENGTH_OFFSET);
+    int length = data.readUnsignedInt24();
+    int numberOfSeekPoints = length / SEEK_POINT_SIZE;
+
+    long[] sampleNumbers = new long[numberOfSeekPoints];
+    long[] offsets = new long[numberOfSeekPoints];
+
+    for (int i = 0; i < numberOfSeekPoints; i++) {
+      sampleNumbers[i] = data.readLong();
+      offsets[i] = data.readLong();
+      data.skipBytes(2); // Skip "Number of samples in the target frame."
+    }
+
+    return new FlacSeekTable(sampleNumbers, offsets);
+  }
+
+  private FlacSeekTable(long[] sampleNumbers, long[] offsets) {
+    this.sampleNumbers = sampleNumbers;
+    this.offsets = offsets;
+  }
+
+  /**
+   * Creates a {@link SeekMap} wrapper for this FlacSeekTable.
+   *
+   * @param firstFrameOffset Offset of the first FLAC frame
+   * @param sampleRate Sample rate of the FLAC file.
+   * @return A SeekMap wrapper for this FlacSeekTable.
+   */
+  public SeekMap createSeekMap(final long firstFrameOffset, final long sampleRate) {
+    return new SeekMap() {
+      @Override
+      public boolean isSeekable() {
+        return true;
+      }
+
+      @Override
+      public long getPosition(long timeUs) {
+        long sample = (timeUs * sampleRate) / 1000000L;
+
+        int index = Util.binarySearchFloor(sampleNumbers, sample, true, true);
+        return firstFrameOffset + offsets[index];
+      }
+    };
+  }
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java b/library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
similarity index 60%
rename from extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
rename to library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
index 8de58f7993..0f75c8032e 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacStreamInfo.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.ext.flac;
+package com.google.android.exoplayer.util;
 
 /**
- * Holder for flac stream info.
+ * Holder for FLAC stream info.
  */
-/* package */ final class FlacStreamInfo {
+public final class FlacStreamInfo {
+
   public final int minBlockSize;
   public final int maxBlockSize;
   public final int minFrameSize;
@@ -28,6 +29,28 @@
   public final int bitsPerSample;
   public final long totalSamples;
 
+  /**
+   * Constructs a FlacStreamInfo parsing the given binary FLAC stream info metadata structure.
+   *
+   * @param data An array holding FLAC stream info metadata structure
+   * @param offset Offset of the structure in the array
+   * @see <a href="https://xiph.org/flac/format.html#metadata_block_streaminfo">FLAC format
+   *     METADATA_BLOCK_STREAMINFO</a>
+   */
+  public FlacStreamInfo(byte[] data, int offset) {
+    ParsableBitArray scratch = new ParsableBitArray(data);
+    scratch.setPosition(offset * 8);
+    this.minBlockSize = scratch.readBits(16);
+    this.maxBlockSize = scratch.readBits(16);
+    this.minFrameSize = scratch.readBits(24);
+    this.maxFrameSize = scratch.readBits(24);
+    this.sampleRate = scratch.readBits(20);
+    this.channels = scratch.readBits(3) + 1;
+    this.bitsPerSample = scratch.readBits(5) + 1;
+    this.totalSamples = scratch.readBits(36);
+    // Remaining 16 bytes is md5 value
+  }
+
   public FlacStreamInfo(int minBlockSize, int maxBlockSize, int minFrameSize, int maxFrameSize,
       int sampleRate, int channels, int bitsPerSample, long totalSamples) {
     this.minBlockSize = minBlockSize;
@@ -51,4 +74,5 @@ public int bitRate() {
   public long durationUs() {
     return (totalSamples * 1000000L) / sampleRate;
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java b/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java
new file mode 100644
index 0000000000..1999be7b5f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/FlacUtil.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+/**
+ * Utility functions for FLAC
+ */
+public final class FlacUtil {
+
+  private static final int FRAME_HEADER_SAMPLE_NUMBER_OFFSET = 4;
+
+  /**
+   * Prevents initialization.
+   */
+  private FlacUtil() {
+  }
+
+  /**
+   * Extracts sample timestamp from the given binary FLAC frame header data structure.
+   *
+   * @param streamInfo A {@link FlacStreamInfo} instance
+   * @param frameData A {@link ParsableByteArray} including binary FLAC frame header data structure.
+   *     Its position should be set to the beginning of the structure.
+   * @return Sample timestamp
+   * @see <a href="https://xiph.org/flac/format.html#frame_header">FLAC format FRAME_HEADER</a>
+   */
+  public static long extractSampleTimestamp(FlacStreamInfo streamInfo,
+      ParsableByteArray frameData) {
+    frameData.skipBytes(FRAME_HEADER_SAMPLE_NUMBER_OFFSET);
+    long sampleNumber = frameData.readUTF8EncodedLong();
+    if (streamInfo.minBlockSize == streamInfo.maxBlockSize) {
+      // if fixed block size then sampleNumber is frame number
+      sampleNumber *= streamInfo.minBlockSize;
+    }
+    return (sampleNumber * 1000000L) / streamInfo.sampleRate;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index f54de76066..ce6636471e 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -328,6 +328,11 @@ public long readUnsignedLongToLong() {
     return result;
   }
 
+  /** Reads the next eight bytes as a 64-bit floating point value. */
+  public double readDouble() {
+    return Double.longBitsToDouble(readLong());
+  }
+
   /**
    * Reads the next {@code length} bytes as UTF-8 characters.
    *
@@ -391,4 +396,38 @@ public String readLine() {
     return line;
   }
 
+  /**
+   * Reads a long value encoded by UTF-8 encoding
+   * @throws NumberFormatException if there is a problem with decoding
+   * @return Decoded long value
+   */
+  public long readUTF8EncodedLong() {
+    int length = 0;
+    long value = data[position];
+    // find the high most 0 bit
+    for (int j = 7; j >= 0; j--) {
+      if ((value & (1 << j)) == 0) {
+        if (j < 6) {
+          value &= (1 << j) - 1;
+          length = 7 - j;
+        } else if (j == 7) {
+          length = 1;
+        }
+        break;
+      }
+    }
+    if (length == 0) {
+      throw new NumberFormatException("Invalid UTF-8 sequence first byte: " + value);
+    }
+    for (int i = 1; i < length; i++) {
+      int x = data[position + i];
+      if ((x & 0xC0) != 0x80) { // if the high most 0 bit not 7th
+        throw new NumberFormatException("Invalid UTF-8 sequence continuation byte: " + value);
+      }
+      value = (value << 6) | (x & 0x3F);
+    }
+    position += length;
+    return value;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java b/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
index 105c5a5838..5c054cc623 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParserUtil.java
@@ -26,26 +26,30 @@
   private ParserUtil() {}
 
   public static boolean isEndTag(XmlPullParser xpp, String name) throws XmlPullParserException {
-    return xpp.getEventType() == XmlPullParser.END_TAG && name.equals(xpp.getName());
+    return isEndTag(xpp) && xpp.getName().equals(name);
+  }
+
+  public static boolean isEndTag(XmlPullParser xpp) throws XmlPullParserException {
+    return xpp.getEventType() == XmlPullParser.END_TAG;
   }
 
   public static boolean isStartTag(XmlPullParser xpp, String name)
       throws XmlPullParserException {
-    return xpp.getEventType() == XmlPullParser.START_TAG && name.equals(xpp.getName());
+    return isStartTag(xpp) && xpp.getName().equals(name);
   }
 
   public static boolean isStartTag(XmlPullParser xpp) throws XmlPullParserException {
     return xpp.getEventType() == XmlPullParser.START_TAG;
   }
 
-  /**
-   * Removes the namespace part ('^.*:') of the attributeName.
-   *
-   * @param attributeName the string to remove the namespace prefix from
-   * @return the name of the attribute without the prefix
-   */
-  public static String removeNamespacePrefix(String attributeName) {
-    return attributeName.replaceFirst("^.*:", "");
+  public static String getAttributeValue(XmlPullParser xpp, String attributeName) {
+    int attributeCount = xpp.getAttributeCount();
+    for (int i = 0; i < attributeCount; i++) {
+      if (attributeName.equals(xpp.getAttributeName(i))) {
+        return xpp.getAttributeValue(i);
+      }
+    }
+    return null;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 73accd5ad8..08c1118aa3 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -769,6 +769,30 @@ public static String getUserAgent(Context context, String applicationName) {
     }
   }
 
+  /**
+   * Converts a sample bit depth to a corresponding PCM encoding constant.
+   *
+   * @param bitDepth The bit depth. Supported values are 8, 16, 24 and 32.
+   * @return The corresponding encoding. One of {@link C#ENCODING_PCM_8BIT},
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}. If the bit depth is unsupported then
+   *     {@link C#ENCODING_INVALID} is returned.
+   */
+  public static int getPcmEncoding(int bitDepth) {
+    switch (bitDepth) {
+      case 8:
+        return C.ENCODING_PCM_8BIT;
+      case 16:
+        return C.ENCODING_PCM_16BIT;
+      case 24:
+        return C.ENCODING_PCM_24BIT;
+      case 32:
+        return C.ENCODING_PCM_32BIT;
+      default:
+        return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Makes a best guess to infer the type from a file name.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
index 241a02327b..fb9ab856c0 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
@@ -24,14 +24,10 @@
    * Flag for empty input/output buffers that signal that the end of the stream was reached.
    */
   public static final int FLAG_END_OF_STREAM = 1;
-  /**
-   * Flag for non-empty input buffers which signals that the decoder must be reset before decoding.
-   */
-  public static final int FLAG_RESET = 2;
   /**
    * Flag for non-empty input/output buffers that should only be decoded (not rendered).
    */
-  public static final int FLAG_DECODE_ONLY = 4;
+  public static final int FLAG_DECODE_ONLY = 2;
 
   private int flags;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
index b8455611aa..03b3e0690b 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
@@ -51,7 +51,7 @@
   private I dequeuedInputBuffer;
 
   private E exception;
-  private boolean flushDecodedOutputBuffer;
+  private boolean flushed;
   private boolean released;
 
   /**
@@ -141,7 +141,7 @@ protected void releaseOutputBuffer(O outputBuffer) {
   @Override
   public final void flush() {
     synchronized (lock) {
-      flushDecodedOutputBuffer = true;
+      flushed = true;
       if (dequeuedInputBuffer != null) {
         availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffer;
         dequeuedInputBuffer = null;
@@ -206,6 +206,7 @@ public final void run() {
   private boolean decode() throws InterruptedException {
     I inputBuffer;
     O outputBuffer;
+    boolean resetDecoder;
 
     // Wait until we have an input buffer to decode, and an output buffer to decode into.
     synchronized (lock) {
@@ -217,7 +218,8 @@ private boolean decode() throws InterruptedException {
       }
       inputBuffer = queuedInputBuffers.removeFirst();
       outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
-      flushDecodedOutputBuffer = false;
+      resetDecoder = flushed;
+      flushed = false;
     }
 
     outputBuffer.reset();
@@ -227,7 +229,7 @@ private boolean decode() throws InterruptedException {
       if (inputBuffer.getFlag(C.SAMPLE_FLAG_DECODE_ONLY)) {
         outputBuffer.setFlag(C.SAMPLE_FLAG_DECODE_ONLY);
       }
-      exception = decode(inputBuffer, outputBuffer);
+      exception = decode(inputBuffer, outputBuffer, resetDecoder);
       if (exception != null) {
         // Memory barrier to ensure that the decoder exception is visible from the playback thread.
         synchronized (lock) {}
@@ -236,7 +238,7 @@ private boolean decode() throws InterruptedException {
     }
 
     synchronized (lock) {
-      if (flushDecodedOutputBuffer || outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
+      if (flushed || outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
         // If a flush occurred while decoding or the buffer was only for decoding (not presentation)
         // then make the output buffer available again rather than queueing it to be consumed.
         availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
@@ -273,8 +275,9 @@ private boolean canDecodeBuffer() {
    *     {@link Buffer#FLAG_DECODE_ONLY} will be set if the same flag is set on {@code inputBuffer},
    *     but the decoder may set/unset the flag if required. If the flag is set after this method
    *     returns, any output should not be presented.
+   * @param reset True if the decoder must be reset before decoding.
    * @return A decoder exception if an error occurred, or null if decoding was successful.
    */
-  protected abstract E decode(I inputBuffer, O outputBuffer);
+  protected abstract E decode(I inputBuffer, O outputBuffer, boolean reset);
 
 }
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 2963ca5be6..7ce85ab729 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1507"
-    android:versionName="1.5.7">
+    android:versionCode="1508"
+    android:versionName="1.5.8">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index 8f9ce937ec..090151e1b8 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -51,12 +51,13 @@
 
 import android.annotation.TargetApi;
 import android.media.MediaCodec;
-import android.os.Bundle;
 import android.os.Handler;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
 import android.view.Surface;
 
+import junit.framework.AssertionFailedError;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -67,6 +68,7 @@
 public final class DashTest extends ActivityInstrumentationTestCase2<HostActivity> {
 
   private static final String TAG = "DashTest";
+  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
 
   private static final long MAX_PLAYING_TIME_DISCREPANCY_MS = 2000;
   private static final float MAX_DROPPED_VIDEO_FRAME_FRACTION = 0.01f;
@@ -92,8 +94,10 @@
   // The highest quality H264 format mandated by the Android CDD.
   private static final String H264_CDD_FIXED = Util.SDK_INT < 23
       ? H264_BASELINE_480P_VIDEO_REPRESENTATION_ID : H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
-  // Multiple H264 formats mandated by the Android CDD.
-  private static final String[] H264_CDD_ADAPTIVE = Util.SDK_INT < 23
+  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
+  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
+  // when switching between baseline and main profiles on certain devices.
+  private static final String[] H264_CDD_ADAPTIVE = Util.SDK_INT < 24
       ? new String[] {
           H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
           H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
@@ -133,7 +137,7 @@
 
   // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
   // if the device advertises support for them.
-  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 23;
+  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 24;
 
   private static final ActionSchedule SEEKING_SCHEDULE = new ActionSchedule.Builder(TAG)
       .delay(10000).seek(15000)
@@ -184,8 +188,8 @@ public void testH264Fixed() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testH264Fixed";
-    testDashPlayback(getActivity(), testName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+    String streamName = "test_h264_fixed";
+    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
         H264_CDD_FIXED);
   }
 
@@ -194,8 +198,8 @@ public void testH264Adaptive() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testH264Adaptive";
-    testDashPlayback(getActivity(), testName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+    String streamName = "test_h264_adaptive";
+    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
         ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
@@ -204,8 +208,8 @@ public void testH264AdaptiveWithSeeking() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testH264AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, H264_MANIFEST,
+    String streamName = "test_h264_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H264_MANIFEST,
         AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
@@ -214,8 +218,8 @@ public void testH264AdaptiveWithRendererDisabling() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testH264AdaptiveWithRendererDisabling";
-    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false, H264_MANIFEST,
+    String streamName = "test_h264_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false, H264_MANIFEST,
         AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
@@ -226,38 +230,38 @@ public void testH265Fixed() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testH265Fixed";
-    testDashPlayback(getActivity(), testName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+    String streamName = "test_h265_fixed";
+    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
         H265_CDD_FIXED);
   }
 
   public void testH265Adaptive() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
-    String testName = "testH265Adaptive";
-    testDashPlayback(getActivity(), testName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+    String streamName = "test_h265_adaptive";
+    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
         ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
-    String testName = "testH265AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, H265_MANIFEST,
+    String streamName = "test_h265_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H265_MANIFEST,
         AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
-    String testName = "testH265AdaptiveWithRendererDisabling";
-    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
+    String streamName = "test_h265_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
         H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
         H265_CDD_ADAPTIVE);
     }
@@ -269,38 +273,38 @@ public void testVp9Fixed360p() throws IOException {
       // Pass.
       return;
     }
-    String testName = "testVp9Fixed360p";
-    testDashPlayback(getActivity(), testName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
+    String streamName = "test_vp9_fixed_360p";
+    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
         VP9_CDD_FIXED);
   }
 
   public void testVp9Adaptive() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    String testName = "testVp9Adaptive";
-    testDashPlayback(getActivity(), testName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+    String streamName = "test_vp9_adaptive";
+    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
         ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    String testName = "testVp9AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, VP9_MANIFEST,
+    String streamName = "test_vp9_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, VP9_MANIFEST,
         VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
-    String testName = "testVp9AdaptiveWithRendererDisabling";
-    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
+    String streamName = "test_vp9_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
         VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
         VP9_CDD_ADAPTIVE);
   }
@@ -313,9 +317,9 @@ public void test23FpsH264Fixed() throws IOException {
       // Pass.
       return;
     }
-    String testName = "test23FpsH264Fixed";
-    testDashPlayback(getActivity(), testName, H264_23_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+    String streamName = "test_23fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, H264_23_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        false, H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // 24 fps.
@@ -324,9 +328,9 @@ public void test24FpsH264Fixed() throws IOException {
       // Pass.
       return;
     }
-    String testName = "test24FpsH264Fixed";
-    testDashPlayback(getActivity(), testName, H264_24_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+    String streamName = "test_24fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, H264_24_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        false, H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // 29.97 fps.
@@ -335,33 +339,40 @@ public void test29FpsH264Fixed() throws IOException {
       // Pass.
       return;
     }
-    String testName = "test29FpsH264Fixed";
-    testDashPlayback(getActivity(), testName, H264_29_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
+    String streamName = "test_29fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, H264_29_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        false, H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // Internal.
 
-  private void testDashPlayback(HostActivity activity, String testName, String manifestFileName,
-      String audioFormat, boolean includeAdditionalVideoFormats, String... videoFormats)
+  private void testDashPlayback(HostActivity activity, String streamName, String manifestFileName,
+      String audioFormat, boolean canIncludeAdditionalVideoFormats, String... videoFormats)
       throws IOException {
-    testDashPlayback(activity, testName, null, true, manifestFileName, audioFormat,
-        includeAdditionalVideoFormats, videoFormats);
+    testDashPlayback(activity, streamName, null, true, manifestFileName, audioFormat,
+        canIncludeAdditionalVideoFormats, videoFormats);
   }
 
-  private void testDashPlayback(HostActivity activity, String testName,
+  private void testDashPlayback(HostActivity activity, String streamName,
       ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
-      String audioFormat, boolean includeAdditionalVideoFormats, String... videoFormats)
+      String audioFormat, boolean canIncludeAdditionalVideoFormats, String... videoFormats)
       throws IOException {
     MediaPresentationDescription mpd = TestUtil.loadManifest(activity,
         MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
-    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG);
-    DashHostedTest test = new DashHostedTest(testName, mpd, metricsLogger, fullPlaybackNoSeeking,
-        audioFormat, includeAdditionalVideoFormats, videoFormats);
-    if (actionSchedule != null) {
-      test.setSchedule(actionSchedule);
-    }
+    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
+        REPORT_NAME, streamName);
+    DashHostedTest test = new DashHostedTest(streamName, mpd, metricsLogger, fullPlaybackNoSeeking,
+        audioFormat, canIncludeAdditionalVideoFormats, false, actionSchedule, videoFormats);
     activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
+    // Retry test exactly once if adaptive test fails due to excessive dropped buffers when playing
+    // non-CDD required formats (b/28220076).
+    if (test.needsCddLimitedRetry) {
+      metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG, REPORT_NAME,
+          streamName + "_cdd_limited_retry");
+      test = new DashHostedTest(streamName, mpd, metricsLogger, fullPlaybackNoSeeking, audioFormat,
+          false, true, actionSchedule, videoFormats);
+      activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
+    }
   }
 
   private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
@@ -388,39 +399,47 @@ private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
     private static final int VIDEO_EVENT_ID = 0;
     private static final int AUDIO_EVENT_ID = 1;
 
-    private final String testName;
+    private final String streamName;
     private final MediaPresentationDescription mpd;
     private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
-    private final boolean includeAdditionalVideoFormats;
+    private final boolean canIncludeAdditionalVideoFormats;
     private final String[] audioFormats;
     private final String[] videoFormats;
 
     private CodecCounters videoCounters;
     private CodecCounters audioCounters;
+    private boolean needsCddLimitedRetry;
+    private TrackSelector videoTrackSelector;
 
     /**
-     * @param testName The name of the test.
+     * @param streamName The name of the test stream for metric logging.
      * @param mpd The manifest.
      * @param metricsLogger Logger to log metrics from the test.
      * @param fullPlaybackNoSeeking True if the test will play the entire source with no seeking.
      *     False otherwise.
      * @param audioFormat The audio format.
-     * @param includeAdditionalVideoFormats Whether to use video formats in addition to
+     * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to
      *     those listed in the videoFormats argument, if the device is capable of playing them.
+     * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
      * @param videoFormats The video formats.
      */
-    public DashHostedTest(String testName, MediaPresentationDescription mpd,
+    public DashHostedTest(String streamName, MediaPresentationDescription mpd,
         MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, String audioFormat,
-        boolean includeAdditionalVideoFormats, String... videoFormats) {
+        boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
+        ActionSchedule actionSchedule, String... videoFormats) {
       super(RENDERER_COUNT);
-      this.testName = testName;
+      Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
+      this.streamName = streamName;
       this.mpd = Assertions.checkNotNull(mpd);
       this.metricsLogger = metricsLogger;
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
       this.audioFormats = new String[] {audioFormat};
-      this.includeAdditionalVideoFormats = includeAdditionalVideoFormats;
+      this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
       this.videoFormats = videoFormats;
+      if (actionSchedule != null) {
+        setSchedule(actionSchedule);
+      }
     }
 
     @Override
@@ -432,8 +451,8 @@ public DashHostedTest(String testName, MediaPresentationDescription mpd,
 
       // Build the video renderer.
       DataSource videoDataSource = new DefaultUriDataSource(host, null, userAgent);
-      TrackSelector videoTrackSelector = new TrackSelector(AdaptationSet.TYPE_VIDEO,
-          includeAdditionalVideoFormats, videoFormats);
+      videoTrackSelector = new TrackSelector(AdaptationSet.TYPE_VIDEO,
+          canIncludeAdditionalVideoFormats, videoFormats);
       ChunkSource videoChunkSource = new DashChunkSource(mpd, videoTrackSelector, videoDataSource,
           new FormatEvaluator.RandomEvaluator(0));
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
@@ -473,7 +492,7 @@ protected void assertPassed() {
         CodecCountersUtil.assertOutputFormatChangedCount(AUDIO_TAG, audioCounters, 1);
         CodecCountersUtil.assertOutputBuffersChangedLimit(AUDIO_TAG, audioCounters, 1);
 
-        if (videoFormats != null && videoFormats.length == 1) {
+        if (videoFormats.length == 1) {
           // Video is not adaptive, so the decoder output format should have changed exactly once.
           // The output buffers should have changed 0 or 1 times.
           CodecCountersUtil.assertOutputFormatChangedCount(VIDEO_TAG, videoCounters, 1);
@@ -500,47 +519,56 @@ protected void assertPassed() {
             + sourceDuration, minAllowedActualPlayingTime <= actualPlayingTime
             && actualPlayingTime <= maxAllowedActualPlayingTime);
       }
-
-      // Assert that the level of performance was acceptable.
-      // Assert that total dropped frames were within limit.
-      int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
-          * CodecCountersUtil.getTotalOutputBuffers(videoCounters));
-      CodecCountersUtil.assertDroppedOutputBufferLimit(VIDEO_TAG, videoCounters, droppedFrameLimit);
-      // Assert that consecutive dropped frames were within limit.
-      CodecCountersUtil.assertConsecutiveDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
-          MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
+      try {
+        int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
+            * CodecCountersUtil.getTotalOutputBuffers(videoCounters));
+        // Assert that performance is acceptable.
+        // Assert that total dropped frames were within limit.
+        CodecCountersUtil.assertDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
+            droppedFrameLimit);
+        // Assert that consecutive dropped frames were within limit.
+        CodecCountersUtil.assertConsecutiveDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
+            MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
+      } catch (AssertionFailedError e) {
+        if (videoTrackSelector.includedAdditionalVideoRepresentations) {
+          // Retry limiting to CDD mandated formats (b/28220076).
+          Log.e(TAG, "Too many dropped or consecutive dropped frames.", e);
+          needsCddLimitedRetry = true;
+        } else {
+          throw e;
+        }
+      }
     }
 
     @Override
     protected void logMetrics() {
-      // Create Bundle of metrics from the test.
-      Bundle metrics = new Bundle();
-      metrics.putString(MetricsLogger.KEY_TEST_NAME, testName);
-      metrics.putInt(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
+      // Log metrics from the test.
+      metricsLogger.logMetric(MetricsLogger.KEY_TEST_NAME, streamName);
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
           videoCounters.droppedOutputBufferCount);
-      metrics.putInt(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
+      metricsLogger.logMetric(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
           videoCounters.maxConsecutiveDroppedOutputBufferCount);
-      metrics.putInt(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
           videoCounters.skippedOutputBufferCount);
-      metrics.putInt(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
           videoCounters.renderedOutputBufferCount);
-
-      // Send metrics for logging.
-      metricsLogger.logMetrics(metrics);
+      metricsLogger.close();
     }
 
     private static final class TrackSelector implements DashTrackSelector {
 
       private final int adaptationSetType;
       private final String[] representationIds;
-      private final boolean includeAdditionalVideoRepresentations;
+      private final boolean canIncludeAdditionalVideoRepresentations;
 
-      private TrackSelector(int adaptationSetType, boolean includeAdditionalVideoRepresentations,
+      public boolean includedAdditionalVideoRepresentations;
+
+      private TrackSelector(int adaptationSetType, boolean canIncludeAdditionalVideoRepresentations,
           String[] representationIds) {
-        Assertions.checkState(!includeAdditionalVideoRepresentations
+        Assertions.checkState(!canIncludeAdditionalVideoRepresentations
             || adaptationSetType == AdaptationSet.TYPE_VIDEO);
         this.adaptationSetType = adaptationSetType;
-        this.includeAdditionalVideoRepresentations = includeAdditionalVideoRepresentations;
+        this.canIncludeAdditionalVideoRepresentations = canIncludeAdditionalVideoRepresentations;
         this.representationIds = representationIds;
       }
 
@@ -551,7 +579,10 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
         int adaptationSetIndex = period.getAdaptationSetIndex(adaptationSetType);
         AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
         int[] representationIndices = getRepresentationIndices(adaptationSet, representationIds,
-            includeAdditionalVideoRepresentations);
+            canIncludeAdditionalVideoRepresentations);
+        if (representationIndices.length > representationIds.length) {
+          includedAdditionalVideoRepresentations = true;
+        }
         if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {
           output.adaptiveTrack(manifest, periodIndex, adaptationSetIndex, representationIndices);
         }
@@ -561,7 +592,7 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
       }
 
       private static int[] getRepresentationIndices(AdaptationSet adaptationSet,
-          String[] representationIds, boolean includeAdditionalVideoRepresentations)
+          String[] representationIds, boolean canIncludeAdditionalVideoRepresentations)
           throws IOException {
         List<Representation> availableRepresentations = adaptationSet.representations;
         List<Integer> selectedRepresentationIndices = new ArrayList<>();
@@ -582,7 +613,7 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
         }
 
         // Select additional video representations, if supported by the device.
-        if (includeAdditionalVideoRepresentations) {
+        if (canIncludeAdditionalVideoRepresentations) {
            int[] supportedVideoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormats(
                availableRepresentations, null, false, true, -1, -1);
            for (int i = 0; i < supportedVideoRepresentationIndices.length; i++) {
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
index bee732187b..9f7bb3dab8 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.util.Assertions;
 
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -39,6 +38,7 @@
 
   private int startIndex;
   private int queueSize;
+  private int bufferCount;
   private boolean enableBufferTimestampAssertions;
 
   public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
@@ -63,8 +63,14 @@ protected void onQueuedInputBuffer(
 
   @Override
   protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    bufferCount++;
     if (enableBufferTimestampAssertions) {
-      Assertions.checkArgument(dequeueTimestamp() == presentationTimeUs);
+      long expectedTimestampUs = dequeueTimestamp();
+      if (expectedTimestampUs != presentationTimeUs) {
+        throw new IllegalStateException("Expected buffer with presentation timestamp: "
+            + expectedTimestampUs + ". Instead got: " + presentationTimeUs + " (Processed buffers: "
+            + bufferCount + ")");
+      }
     }
   }
 
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
index 075a71d587..2273db7746 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/ExoHostedTest.java
@@ -85,7 +85,7 @@ public final void setSchedule(ActionSchedule schedule) {
   // HostedTest implementation
 
   @Override
-  public final void initialize(HostActivity host, Surface surface) {
+  public final void onStart(HostActivity host, Surface surface) {
     // Build the player.
     player = ExoPlayer.Factory.newInstance(rendererCount);
     player.addListener(this);
@@ -100,7 +100,7 @@ public final void initialize(HostActivity host, Surface surface) {
   }
 
   @Override
-  public final void release() {
+  public final void onStop() {
     actionHandler.removeCallbacksAndMessages(null);
     player.release();
     player = null;
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
index 73d30d99b3..a9d41c4056 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/HostActivity.java
@@ -48,36 +48,35 @@
   public interface HostedTest {
 
     /**
-     * Called once the activity has been resumed and its surface has been created.
+     * Called on the main thread when the test is started.
      * <p>
-     * Called on the main thread.
+     * The test will not be started until the {@link HostActivity} has been resumed and its
+     * {@link Surface} has been created.
      *
-     * @param host The host in which the test is being run.
-     * @param surface The created surface.
+     * @param host The {@link HostActivity} in which the test is being run.
+     * @param surface The {@link Surface}.
      */
-    void initialize(HostActivity host, Surface surface);
+    void onStart(HostActivity host, Surface surface);
 
     /**
-     * Called when the test has finished, or if the activity is paused or its surface is destroyed.
+     * Called on the main thread when the test is stopped.
      * <p>
-     * Called on the main thread.
+     * The test will be stopped if it has finished, if the {@link HostActivity} has been paused, or
+     * if the {@link HostActivity}'s {@link Surface} has been destroyed.
      */
-    void release();
+    void onStop();
 
     /**
-     * Called periodically to check whether the test has finished.
-     * <p>
-     * Called on the main thread.
+     * Called on the main thread to check whether the test has finished.
      *
      * @return True if the test has finished. False otherwise.
      */
     boolean isFinished();
 
     /**
-     * Called after the test is finished and has been released. Implementations may use this method
-     * to assert that test criteria were met.
+     * Called on the main thread after the test has finished and been stopped.
      * <p>
-     * Called on the test thread.
+     * Implementations may use this method to assert that test criteria were met.
      */
     void onFinished();
 
@@ -87,20 +86,17 @@
 
   private WakeLock wakeLock;
   private WifiLock wifiLock;
-
   private SurfaceView surfaceView;
   private Handler mainHandler;
   private CheckFinishedRunnable checkFinishedRunnable;
 
   private HostedTest hostedTest;
-  private ConditionVariable hostedTestReleasedCondition;
-  private boolean hostedTestInitialized;
+  private ConditionVariable hostedTestStoppedCondition;
+  private boolean hostedTestStarted;
   private boolean hostedTestFinished;
 
   /**
    * Executes a {@link HostedTest} inside the host.
-   * <p>
-   * Must only be called once on each instance. Must be called from the test thread.
    *
    * @param hostedTest The test to execute.
    * @param timeoutMs The number of milliseconds to wait for the test to finish. If the timeout
@@ -109,15 +105,21 @@
   public void runTest(final HostedTest hostedTest, long timeoutMs) {
     Assertions.checkArgument(timeoutMs > 0);
     Assertions.checkState(Thread.currentThread() != getMainLooper().getThread());
+
+    Assertions.checkState(this.hostedTest == null);
+    this.hostedTest = Assertions.checkNotNull(hostedTest);
+    hostedTestStoppedCondition = new ConditionVariable();
+    hostedTestStarted = false;
+    hostedTestFinished = false;
+
     runOnUiThread(new Runnable() {
       @Override
       public void run() {
-        Assertions.checkState(HostActivity.this.hostedTest == null);
-        HostActivity.this.hostedTest = Assertions.checkNotNull(hostedTest);
-        maybeInitializeHostedTest();
+        maybeStartHostedTest();
       }
     });
-    if (hostedTestReleasedCondition.block(timeoutMs)) {
+
+    if (hostedTestStoppedCondition.block(timeoutMs)) {
       if (hostedTestFinished) {
         Log.d(TAG, "Test finished. Checking pass conditions.");
         hostedTest.onFinished();
@@ -143,7 +145,6 @@ public void onCreate(Bundle savedInstanceState) {
     surfaceView = (SurfaceView) findViewById(R.id.surface_view);
     surfaceView.getHolder().addCallback(this);
     mainHandler = new Handler();
-    hostedTestReleasedCondition = new ConditionVariable();
     checkFinishedRunnable = new CheckFinishedRunnable();
   }
 
@@ -162,13 +163,13 @@ public void onStart() {
   @Override
   public void onResume() {
     super.onResume();
-    maybeInitializeHostedTest();
+    maybeStartHostedTest();
   }
 
   @Override
   public void onPause() {
     super.onPause();
-    maybeReleaseHostedTest();
+    maybeStopHostedTest();
   }
 
   @Override
@@ -184,12 +185,12 @@ public void onStop() {
 
   @Override
   public void surfaceCreated(SurfaceHolder holder) {
-    maybeInitializeHostedTest();
+    maybeStartHostedTest();
   }
 
   @Override
   public void surfaceDestroyed(SurfaceHolder holder) {
-    maybeReleaseHostedTest();
+    maybeStopHostedTest();
   }
 
   @Override
@@ -199,25 +200,25 @@ public void surfaceChanged(SurfaceHolder holder, int format, int width, int heig
 
   // Internal logic
 
-  private void maybeInitializeHostedTest() {
-    if (hostedTest == null || hostedTestInitialized) {
+  private void maybeStartHostedTest() {
+    if (hostedTest == null || hostedTestStarted) {
       return;
     }
     Surface surface = surfaceView.getHolder().getSurface();
     if (surface != null && surface.isValid()) {
-      hostedTestInitialized = true;
-      Log.d(TAG, "Initializing test.");
-      hostedTest.initialize(this, surface);
+      hostedTestStarted = true;
+      Log.d(TAG, "Starting test.");
+      hostedTest.onStart(this, surface);
       checkFinishedRunnable.startChecking();
     }
   }
 
-  private void maybeReleaseHostedTest() {
-    if (hostedTest != null && hostedTestInitialized) {
-      hostedTest.release();
+  private void maybeStopHostedTest() {
+    if (hostedTest != null && hostedTestStarted) {
+      hostedTest.onStop();
       hostedTest = null;
       mainHandler.removeCallbacks(checkFinishedRunnable);
-      hostedTestReleasedCondition.open();
+      hostedTestStoppedCondition.open();
     }
   }
 
@@ -238,7 +239,7 @@ private void startChecking() {
     public void run() {
       if (hostedTest.isFinished()) {
         hostedTestFinished = true;
-        finish();
+        maybeStopHostedTest();
       } else {
         mainHandler.postDelayed(this, CHECK_INTERVAL_MS);
       }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java
index 07a9524d6c..8de3a197f2 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatMetricsLogger.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.playbacktests.util;
 
-import android.os.Bundle;
 import android.util.Log;
 
 /**
@@ -30,12 +29,23 @@ public LogcatMetricsLogger(String tag) {
   }
 
   @Override
-  public void logMetrics(Bundle metrics) {
-    if (metrics != null) {
-      for (String key : metrics.keySet()) {
-        Log.v(tag, key + ": " + metrics.get(key).toString());
-      }
-    }
+  public void logMetric(String key, int value) {
+    Log.d(tag, key + ": " + value);
+  }
+
+  @Override
+  public void logMetric(String key, double value) {
+    Log.d(tag, key + ": " + value);
+  }
+
+  @Override
+  public void logMetric(String key, String value) {
+    Log.d(tag, key + ": " + value);
+  }
+
+  @Override
+  public void close() {
+    // Do nothing.
   }
 
 }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java
index 9bbaf48388..09f557442b 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/MetricsLogger.java
@@ -16,40 +16,64 @@
 package com.google.android.exoplayer.playbacktests.util;
 
 import android.app.Instrumentation;
-import android.os.Bundle;
 
 /**
  * Metric Logging interface for ExoPlayer playback tests.
  */
 public interface MetricsLogger {
 
-  String KEY_FRAMES_DROPPED_COUNT = "Frames Dropped (Count)";
-  String KEY_FRAMES_RENDERED_COUNT = "Frames Rendered (Count)";
-  String KEY_FRAMES_SKIPPED_COUNT = "Frames Skipped (Count)";
-  String KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT = "Maximum Consecutive Frames Dropped";
-  String KEY_TEST_NAME = "Test Name";
+  String KEY_FRAMES_DROPPED_COUNT = "frames_dropped_count";
+  String KEY_FRAMES_RENDERED_COUNT = "frames_rendered_count";
+  String KEY_FRAMES_SKIPPED_COUNT = "frames_skipped_count";
+  String KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT = "maximum_consecutive_frames_dropped_count";
+  String KEY_TEST_NAME = "test_name";
 
   /**
-   * Logs the metrics provided from a test.
+   * Logs an int metric provided from a test.
    *
-   * @param metrics The {@link Bundle} of metrics to be logged.
+   * @param key The key of the metric to be logged.
+   * @param value The value of the metric to be logged.
    */
-  void logMetrics(Bundle metrics);
+  void logMetric(String key, int value);
 
   /**
-   * A factory for instantiating MetricsLogger instances.
+   * Logs a double metric provided from a test.
+   *
+   * @param key The key of the metric to be logged.
+   * @param value The value of the metric to be logged.
+   */
+  void logMetric(String key, double value);
+
+  /**
+   * Logs a string metric provided from a test.
+   *
+   * @param key The key of the metric to be logged.
+   * @param value The value of the metric to be logged.
+   */
+  void logMetric(String key, String value);
+
+  /**
+   * Closes the logger.
+   */
+  void close();
+
+  /**
+   * A factory for instantiating {@link MetricsLogger} instances.
    */
   final class Factory {
 
     private Factory() {}
 
     /**
-     * Obtains a new instance of MetricsLogger.
+     * Obtains a new instance of {@link MetricsLogger}.
      *
      * @param instrumentation The test instrumentation.
      * @param tag The tag to be used for logcat logs.
+     * @param reportName The name of the report log.
+     * @param streamName The name of the stream of metrics.
      */
-    public static MetricsLogger createDefault(Instrumentation instrumentation, String tag) {
+    public static MetricsLogger createDefault(Instrumentation instrumentation, String tag,
+        String reportName, String streamName) {
       return new LogcatMetricsLogger(tag);
     }
   }
diff --git a/third_party/okhttp3/LICENSE b/third_party/okhttp3/LICENSE
new file mode 100644
index 0000000000..261eeb9e9f
--- /dev/null
+++ b/third_party/okhttp3/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/third_party/okhttp3/okhttp-3.2.0.jar b/third_party/okhttp3/okhttp-3.2.0.jar
new file mode 100644
index 0000000000..bd9daaf962
Binary files /dev/null and b/third_party/okhttp3/okhttp-3.2.0.jar differ
diff --git a/third_party/okio/LICENSE b/third_party/okio/LICENSE
new file mode 100644
index 0000000000..261eeb9e9f
--- /dev/null
+++ b/third_party/okio/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/third_party/okio/okio-1.6.0.jar b/third_party/okio/okio-1.6.0.jar
new file mode 100644
index 0000000000..c87be599f6
Binary files /dev/null and b/third_party/okio/okio-1.6.0.jar differ
