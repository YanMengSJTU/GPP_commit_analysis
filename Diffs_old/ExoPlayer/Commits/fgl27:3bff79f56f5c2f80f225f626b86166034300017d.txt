diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 5128abba46..bc9f64a001 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -17,6 +17,8 @@
 * Add a workaround for broken raw audio decoding on Oppo R9
   ([#5782](https://github.com/google/ExoPlayer/issues/5782)).
 * Add VR player demo.
+* Wrap decoder exceptions in a new `DecoderException` class and report as
+  renderer error.
 
 ### 2.10.2 ###
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 82fb8bb9f5..929b579b4c 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -680,7 +680,7 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
           // Special case for decoder initialization failures.
           DecoderInitializationException decoderInitializationException =
               (DecoderInitializationException) cause;
-          if (decoderInitializationException.decoderName == null) {
+          if (decoderInitializationException.codecInfo == null) {
             if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
               errorString = getString(R.string.error_querying_decoders);
             } else if (decoderInitializationException.secureDecoderRequired) {
@@ -695,7 +695,7 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
             errorString =
                 getString(
                     R.string.error_instantiating_decoder,
-                    decoderInitializationException.decoderName);
+                    decoderInitializationException.codecInfo.name);
           }
         }
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index d00b218c38..4b7bab2cfa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -80,14 +80,13 @@
     public final boolean secureDecoderRequired;
 
     /**
-     * The name of the decoder that failed to initialize. Null if no suitable decoder was found.
+     * The {@link MediaCodecInfo} of the decoder that failed to initialize. Null if no suitable
+     * decoder was found.
      */
-    public final String decoderName;
+    @Nullable public final MediaCodecInfo codecInfo;
 
-    /**
-     * An optional developer-readable diagnostic information string. May be null.
-     */
-    public final String diagnosticInfo;
+    /** An optional developer-readable diagnostic information string. May be null. */
+    @Nullable public final String diagnosticInfo;
 
     /**
      * If the decoder failed to initialize and another decoder being used as a fallback also failed
@@ -103,19 +102,22 @@ public DecoderInitializationException(Format format, Throwable cause,
           cause,
           format.sampleMimeType,
           secureDecoderRequired,
-          /* decoderName= */ null,
+          /* mediaCodecInfo= */ null,
           buildCustomDiagnosticInfo(errorCode),
           /* fallbackDecoderInitializationException= */ null);
     }
 
-    public DecoderInitializationException(Format format, Throwable cause,
-        boolean secureDecoderRequired, String decoderName) {
+    public DecoderInitializationException(
+        Format format,
+        Throwable cause,
+        boolean secureDecoderRequired,
+        MediaCodecInfo mediaCodecInfo) {
       this(
-          "Decoder init failed: " + decoderName + ", " + format,
+          "Decoder init failed: " + mediaCodecInfo.name + ", " + format,
           cause,
           format.sampleMimeType,
           secureDecoderRequired,
-          decoderName,
+          mediaCodecInfo,
           Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null,
           /* fallbackDecoderInitializationException= */ null);
     }
@@ -125,13 +127,13 @@ private DecoderInitializationException(
         Throwable cause,
         String mimeType,
         boolean secureDecoderRequired,
-        @Nullable String decoderName,
+        @Nullable MediaCodecInfo mediaCodecInfo,
         @Nullable String diagnosticInfo,
         @Nullable DecoderInitializationException fallbackDecoderInitializationException) {
       super(message, cause);
       this.mimeType = mimeType;
       this.secureDecoderRequired = secureDecoderRequired;
-      this.decoderName = decoderName;
+      this.codecInfo = mediaCodecInfo;
       this.diagnosticInfo = diagnosticInfo;
       this.fallbackDecoderInitializationException = fallbackDecoderInitializationException;
     }
@@ -144,7 +146,7 @@ private DecoderInitializationException copyWithFallbackException(
           getCause(),
           mimeType,
           secureDecoderRequired,
-          decoderName,
+          codecInfo,
           diagnosticInfo,
           fallbackException);
     }
@@ -159,9 +161,34 @@ private static String getDiagnosticInfoV21(Throwable cause) {
 
     private static String buildCustomDiagnosticInfo(int errorCode) {
       String sign = errorCode < 0 ? "neg_" : "";
-      return "com.google.android.exoplayer.MediaCodecTrackRenderer_" + sign + Math.abs(errorCode);
+      return "com.google.android.exoplayer2.mediacodec.MediaCodecRenderer_"
+          + sign
+          + Math.abs(errorCode);
+    }
+  }
+
+  /** Thrown when a failure occurs in the decoder. */
+  public static class DecoderException extends Exception {
+
+    /** The {@link MediaCodecInfo} of the decoder that failed. Null if unknown. */
+    @Nullable public final MediaCodecInfo codecInfo;
+
+    /** An optional developer-readable diagnostic information string. May be null. */
+    @Nullable public final String diagnosticInfo;
+
+    public DecoderException(Throwable cause, @Nullable MediaCodecInfo codecInfo) {
+      super("Decoder failed: " + (codecInfo == null ? null : codecInfo.name), cause);
+      this.codecInfo = codecInfo;
+      diagnosticInfo = Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null;
     }
 
+    @TargetApi(21)
+    private static String getDiagnosticInfoV21(Throwable cause) {
+      if (cause instanceof CodecException) {
+        return ((CodecException) cause).getDiagnosticInfo();
+      }
+      return null;
+    }
   }
 
   /** Indicates no codec operating rate should be set. */
@@ -637,31 +664,40 @@ protected void onStopped() {
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    if (outputStreamEnded) {
-      renderToEndOfStream();
-      return;
-    }
-    if (inputFormat == null && !readToFlagsOnlyBuffer(/* requireFormat= */ true)) {
+    try {
+      if (outputStreamEnded) {
+        renderToEndOfStream();
+        return;
+      }
+      if (inputFormat == null && !readToFlagsOnlyBuffer(/* requireFormat= */ true)) {
         // We still don't have a format and can't make progress without one.
         return;
+      }
+      // We have a format.
+      maybeInitCodec();
+      if (codec != null) {
+        long drainStartTimeMs = SystemClock.elapsedRealtime();
+        TraceUtil.beginSection("drainAndFeed");
+        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
+        while (feedInputBuffer() && shouldContinueFeeding(drainStartTimeMs)) {}
+        TraceUtil.endSection();
+      } else {
+        decoderCounters.skippedInputBufferCount += skipSource(positionUs);
+        // We need to read any format changes despite not having a codec so that drmSession can be
+        // updated, and so that we have the most recent format should the codec be initialized. We
+        // may
+        // also reach the end of the stream. Note that readSource will not read a sample into a
+        // flags-only buffer.
+        readToFlagsOnlyBuffer(/* requireFormat= */ false);
+      }
+      decoderCounters.ensureUpdated();
+    } catch (IllegalStateException e) {
+      if (isMediaCodecException(e)) {
+        throw ExoPlaybackException.createForRenderer(
+            createDecoderException(e, getCodecInfo()), getIndex());
+      }
+      throw e;
     }
-    // We have a format.
-    maybeInitCodec();
-    if (codec != null) {
-      long drainStartTimeMs = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("drainAndFeed");
-      while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-      while (feedInputBuffer() && shouldContinueFeeding(drainStartTimeMs)) {}
-      TraceUtil.endSection();
-    } else {
-      decoderCounters.skippedInputBufferCount += skipSource(positionUs);
-      // We need to read any format changes despite not having a codec so that drmSession can be
-      // updated, and so that we have the most recent format should the codec be initialized. We may
-      // also reach the end of the stream. Note that readSource will not read a sample into a
-      // flags-only buffer.
-      readToFlagsOnlyBuffer(/* requireFormat= */ false);
-    }
-    decoderCounters.ensureUpdated();
   }
 
   /**
@@ -725,6 +761,11 @@ protected boolean flushOrReleaseCodec() {
     return false;
   }
 
+  protected DecoderException createDecoderException(
+      Throwable cause, @Nullable MediaCodecInfo codecInfo) {
+    return new DecoderException(cause, codecInfo);
+  }
+
   /** Reads into {@link #flagsOnlyBuffer} and returns whether a format was read. */
   private boolean readToFlagsOnlyBuffer(boolean requireFormat) throws ExoPlaybackException {
     flagsOnlyBuffer.clear();
@@ -785,7 +826,7 @@ private void maybeInitCodecWithFallback(
         availableCodecInfos.removeFirst();
         DecoderInitializationException exception =
             new DecoderInitializationException(
-                inputFormat, e, mediaCryptoRequiresSecureDecoder, codecInfo.name);
+                inputFormat, e, mediaCryptoRequiresSecureDecoder, codecInfo);
         if (preferredDecoderInitializationException == null) {
           preferredDecoderInitializationException = exception;
         } else {
@@ -1701,6 +1742,19 @@ private boolean isDecodeOnlyBuffer(long presentationTimeUs) {
     return cryptoInfo;
   }
 
+  private static boolean isMediaCodecException(IllegalStateException error) {
+    if (Util.SDK_INT >= 21) {
+      return isMediaCodecExceptionV21(error);
+    }
+    StackTraceElement[] stackTrace = error.getStackTrace();
+    return stackTrace.length > 0 && stackTrace[0].getClassName().equals("android.media.MediaCodec");
+  }
+
+  @TargetApi(21)
+  private static boolean isMediaCodecExceptionV21(IllegalStateException error) {
+    return error instanceof MediaCodec.CodecException;
+  }
+
   /**
    * Returns whether the device needs keys to have been loaded into the {@link DrmSession} before
    * codec configuration.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index f60dbf3cb7..c864adfa68 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -92,6 +92,23 @@
    */
   private static final float INITIAL_FORMAT_MAX_INPUT_SIZE_SCALE_FACTOR = 1.5f;
 
+  /** A {@link DecoderException} with additional surface information. */
+  public static final class VideoDecoderException extends DecoderException {
+
+    /** The {@link System#identityHashCode(Object)} of the surface when the exception occurred. */
+    public final int surfaceIdentityHashCode;
+
+    /** Whether the surface was valid when the exception occurred. */
+    public final boolean isSurfaceValid;
+
+    public VideoDecoderException(
+        Throwable cause, @Nullable MediaCodecInfo codecInfo, @Nullable Surface surface) {
+      super(cause, codecInfo);
+      surfaceIdentityHashCode = System.identityHashCode(surface);
+      isSurfaceValid = surface == null || surface.isValid();
+    }
+  }
+
   private static boolean evaluatedDeviceNeedsSetOutputSurfaceWorkaround;
   private static boolean deviceNeedsSetOutputSurfaceWorkaround;
 
@@ -1260,6 +1277,12 @@ protected CodecMaxValues getCodecMaxValues(
     return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
   }
 
+  @Override
+  protected DecoderException createDecoderException(
+      Throwable cause, @Nullable MediaCodecInfo codecInfo) {
+    return new VideoDecoderException(cause, codecInfo, surface);
+  }
+
   /**
    * Returns a maximum video size to use when configuring a codec for {@code format} in a way that
    * will allow possible adaptation to other compatible formats that are expected to have the same
