diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 6062a6652a..bc72f24c3a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -517,7 +517,7 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
 
     List<SchemeData> schemeDatas = null;
     if (offlineLicenseKeySetId == null) {
-      schemeDatas = getSchemeDatas(drmInitData, uuid, false);
+      schemeDatas = getSchemeDatas(drmInitData, uuid, true);
       if (schemeDatas.isEmpty()) {
         final MissingSchemeDataException error = new MissingSchemeDataException(uuid);
         eventDispatcher.dispatch(listener -> listener.onDrmSessionManagerError(error));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index d2a5b6a0d6..a8d5ab341e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -252,15 +252,17 @@ private static SchemeData getSchemeData(UUID uuid, List<SchemeData> schemeDatas)
 
     // For API levels 23 - 27, prefer the first V1 PSSH box. For API levels 22 and earlier, prefer
     // the first V0 box.
-    for (int i = 0; i < schemeDatas.size(); i++) {
-      SchemeData schemeData = schemeDatas.get(i);
-      int version = PsshAtomUtil.parseVersion(schemeData.data);
-      if (Util.SDK_INT < 23 && version == 0) {
-        return schemeData;
-      } else if (Util.SDK_INT >= 23 && version == 1) {
-        return schemeData;
-      }
-    }
+    /**
+     schemeData.dataの中身がうまくパースできないため、コメントアウト（SDKのバージョンに拘らずversionが０で取れてしまう）
+     for (int i = 0; i < schemeDatas.size(); i++) {
+     SchemeData schemeData = schemeDatas.get(i);
+     int version = PsshAtomUtil.parseVersion(schemeData.data);
+     if (Util.SDK_INT < 23 && version == 0) {
+     return schemeData;
+     } else if (Util.SDK_INT >= 23 && version == 1) {
+     return schemeData;
+     }
+     }**/
 
     // If all else fails, use the first scheme data.
     return schemeDatas.get(0);
@@ -276,10 +278,10 @@ private static UUID adjustUuid(UUID uuid) {
     // devices also required data to be extracted from the PSSH atom for PlayReady.
     if ((Util.SDK_INT < 21 && C.WIDEVINE_UUID.equals(uuid))
         || (C.PLAYREADY_UUID.equals(uuid)
-            && "Amazon".equals(Util.MANUFACTURER)
-            && ("AFTB".equals(Util.MODEL) // Fire TV Gen 1
-                || "AFTS".equals(Util.MODEL) // Fire TV Gen 2
-                || "AFTM".equals(Util.MODEL)))) { // Fire TV Stick Gen 1
+        && "Amazon".equals(Util.MANUFACTURER)
+        && ("AFTB".equals(Util.MODEL) // Fire TV Gen 1
+        || "AFTS".equals(Util.MODEL) // Fire TV Gen 2
+        || "AFTM".equals(Util.MODEL)))) { // Fire TV Stick Gen 1
       byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(initData, uuid);
       if (psshData != null) {
         // Extraction succeeded, so return the extracted data.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
index 9298c16cb0..a607b8e237 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -43,11 +43,11 @@
    * is no longer required.
    *
    * @param defaultLicenseUrl The default license URL. Used for key requests that do not specify
-   *     their own license URL.
+   * their own license URL.
    * @param httpDataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
    * @return A new instance which uses Widevine CDM.
    * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
-   *     instantiated.
+   * instantiated.
    */
   public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
       String defaultLicenseUrl, Factory httpDataSourceFactory)
@@ -60,13 +60,13 @@
    * is no longer required.
    *
    * @param defaultLicenseUrl The default license URL. Used for key requests that do not specify
-   *     their own license URL.
+   * their own license URL.
    * @param forceDefaultLicenseUrl Whether to use {@code defaultLicenseUrl} for key requests that
-   *     include their own license URL.
+   * include their own license URL.
    * @param httpDataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
    * @return A new instance which uses Widevine CDM.
    * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
-   *     instantiated.
+   * instantiated.
    */
   public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
       String defaultLicenseUrl, boolean forceDefaultLicenseUrl, Factory httpDataSourceFactory)
@@ -80,16 +80,16 @@
    * is no longer required.
    *
    * @param defaultLicenseUrl The default license URL. Used for key requests that do not specify
-   *     their own license URL.
+   * their own license URL.
    * @param forceDefaultLicenseUrl Whether to use {@code defaultLicenseUrl} for key requests that
-   *     include their own license URL.
+   * include their own license URL.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @return A new instance which uses Widevine CDM.
    * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
-   *     instantiated.
+   * instantiated.
    * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
+   * MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
    */
   public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
       String defaultLicenseUrl,
@@ -97,12 +97,22 @@
       Factory httpDataSourceFactory,
       HashMap<String, String> optionalKeyRequestParameters)
       throws UnsupportedDrmException {
+    return newWidevineInstance(optionalKeyRequestParameters,
+        new HttpMediaDrmCallback(defaultLicenseUrl, forceDefaultLicenseUrl,
+            httpDataSourceFactory));
+  }
+
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      HashMap<String, String> optionalKeyRequestParameters,
+      HttpMediaDrmCallback callback)
+      throws UnsupportedDrmException {
     return new OfflineLicenseHelper<>(C.WIDEVINE_UUID,
         FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID),
-        new HttpMediaDrmCallback(defaultLicenseUrl, forceDefaultLicenseUrl, httpDataSourceFactory),
+        callback,
         optionalKeyRequestParameters);
   }
 
+
   /**
    * Constructs an instance. Call {@link #release()} when the instance is no longer required.
    *
@@ -110,9 +120,9 @@
    * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
    * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
-   *     MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
+   * MediaDrmCallback, HashMap, Handler, DefaultDrmSessionEventListener)
    */
   public OfflineLicenseHelper(
       UUID uuid,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
index fcbe06993e..d16c317e08 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadHelper.java
@@ -19,6 +19,7 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.offline.DownloadHelper;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.offline.TrackKey;
@@ -78,6 +79,7 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
     }
     // TODO: Generate track groups as in playback. Reverse the mapping in getDownloadAction.
     HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+
     TrackGroup[] trackGroups = new TrackGroup[3];
     renditionGroups = new int[3];
     int trackGroupIndex = 0;
@@ -96,6 +98,11 @@ public TrackGroupArray getTrackGroups(int periodIndex) {
     return new TrackGroupArray(Arrays.copyOf(trackGroups, trackGroupIndex));
   }
 
+  public DrmInitData getDrmInitData(){
+    HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+    return masterPlaylist.playlistProtectionSchemes;
+  }
+
   @Override
   public HlsDownloadAction getDownloadAction(@Nullable byte[] data, List<TrackKey> trackKeys) {
     Assertions.checkNotNull(renditionGroups);
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index bb01ade28d..747461033e 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
@@ -37,7 +38,8 @@
           /* muxedAudioFormat= */ null,
           /* muxedCaptionFormats= */ Collections.emptyList(),
           /* hasIndependentSegments= */ false,
-          /* variableDefinitions= */ Collections.emptyMap());
+          /* variableDefinitions= */ Collections.emptyMap(),
+          /* playlistProtectionSchemes= */null);
 
   public static final int GROUP_INDEX_VARIANT = 0;
   public static final int GROUP_INDEX_AUDIO = 1;
@@ -115,6 +117,8 @@ public HlsUrl(String url, Format format) {
   /** Contains variable definitions, as defined by the #EXT-X-DEFINE tag. */
   public final Map<String, String> variableDefinitions;
 
+  public final DrmInitData playlistProtectionSchemes;
+
   /**
    * @param baseUri See {@link #baseUri}.
    * @param tags See {@link #tags}.
@@ -135,7 +139,8 @@ public HlsMasterPlaylist(
       Format muxedAudioFormat,
       List<Format> muxedCaptionFormats,
       boolean hasIndependentSegments,
-      Map<String, String> variableDefinitions) {
+      Map<String, String> variableDefinitions,
+      DrmInitData playlistProtectionSchemes) {
     super(baseUri, tags, hasIndependentSegments);
     this.variants = Collections.unmodifiableList(variants);
     this.audios = Collections.unmodifiableList(audios);
@@ -144,6 +149,7 @@ public HlsMasterPlaylist(
     this.muxedCaptionFormats = muxedCaptionFormats != null
         ? Collections.unmodifiableList(muxedCaptionFormats) : null;
     this.variableDefinitions = Collections.unmodifiableMap(variableDefinitions);
+    this.playlistProtectionSchemes = playlistProtectionSchemes;
   }
 
   @Override
@@ -157,7 +163,8 @@ public HlsMasterPlaylist copy(List<StreamKey> streamKeys) {
         muxedAudioFormat,
         muxedCaptionFormats,
         hasIndependentSegments,
-        variableDefinitions);
+        variableDefinitions,
+        playlistProtectionSchemes);
   }
 
   /**
@@ -178,7 +185,8 @@ public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variant
         /* muxedAudioFormat= */ null,
         /* muxedCaptionFormats= */ null,
         /* hasIndependentSegments= */ false,
-        /* variableDefinitions= */ Collections.emptyMap());
+        /* variableDefinitions= */ Collections.emptyMap(),
+        null);
   }
 
   private static List<HlsUrl> copyRenditionsList(
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 65f4796187..8f4a585425 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import android.support.annotation.Nullable;
 import android.util.Base64;
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -74,6 +75,8 @@
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
   private static final String TAG_GAP = "#EXT-X-GAP";
+  private static final String TAG_SESSION_KEY = "#EXT-X-SESSION-KEY";
+
 
   private static final String TYPE_AUDIO = "AUDIO";
   private static final String TYPE_VIDEO = "VIDEO";
@@ -256,10 +259,14 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     boolean noClosedCaptions = false;
     boolean hasIndependentSegmentsTag = false;
 
+    TreeMap<String, SchemeData> currentSchemeDatas = new TreeMap<>();
+    DrmInitData cachedDrmInitData = null;
+    String encryptionScheme = null;
+    DrmInitData playlistProtectionSchemes = null;
+
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-
       if (line.startsWith(TAG_PREFIX)) {
         // We expose all tags through the playlist.
         tags.add(line);
@@ -331,6 +338,38 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                   /* selectionFlags= */ 0);
           variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
         }
+      } else if (line.startsWith(TAG_SESSION_KEY)) {
+        String method = parseStringAttr(line, REGEX_METHOD, variableDefinitions);
+        String keyFormat =
+            parseOptionalStringAttr(line, REGEX_KEYFORMAT, KEYFORMAT_IDENTITY, variableDefinitions);
+        if (METHOD_NONE.equals(method)) {
+          currentSchemeDatas.clear();
+          cachedDrmInitData = null;
+        } else /* !METHOD_NONE.equals(method) */ {
+          if (encryptionScheme == null) {
+            encryptionScheme =
+                METHOD_SAMPLE_AES_CENC.equals(method) || METHOD_SAMPLE_AES_CTR.equals(method)
+                    ? C.CENC_TYPE_cenc
+                    : C.CENC_TYPE_cbcs;
+          }
+          SchemeData schemeData;
+          if (KEYFORMAT_PLAYREADY.equals(keyFormat)) {
+            schemeData = parsePlayReadySchemeData(line, variableDefinitions);
+          } else {
+            schemeData = parseWidevineSchemeData(line, keyFormat, variableDefinitions);
+          }
+          if (schemeData != null) {
+            cachedDrmInitData = null;
+            currentSchemeDatas.put(keyFormat, schemeData);
+          }
+          if (cachedDrmInitData == null && !currentSchemeDatas.isEmpty()) {
+            SchemeData[] schemeDatas = currentSchemeDatas.values().toArray(new SchemeData[0]);
+            cachedDrmInitData = new DrmInitData(encryptionScheme, schemeDatas);
+            if (playlistProtectionSchemes == null) {
+              playlistProtectionSchemes = new DrmInitData(encryptionScheme, schemeDatas);
+            }
+          }
+        }
       }
     }
 
@@ -423,7 +462,8 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         muxedAudioFormat,
         muxedCaptionFormats,
         hasIndependentSegmentsTag,
-        variableDefinitions);
+        variableDefinitions,
+        playlistProtectionSchemes);
   }
 
   @C.SelectionFlags
@@ -477,7 +517,6 @@ private static HlsMediaPlaylist parseMediaPlaylist(
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-
       if (line.startsWith(TAG_PREFIX)) {
         // We expose all tags through the playlist.
         tags.add(line);
@@ -661,7 +700,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(
         segments);
   }
 
-  private static @Nullable SchemeData parsePlayReadySchemeData(
+  private static @Nullable
+  SchemeData parsePlayReadySchemeData(
       String line, Map<String, String> variableDefinitions) throws ParserException {
     String keyFormatVersions =
         parseOptionalStringAttr(line, REGEX_KEYFORMATVERSIONS, "1", variableDefinitions);
@@ -675,10 +715,12 @@ private static HlsMediaPlaylist parseMediaPlaylist(
     return new SchemeData(C.PLAYREADY_UUID, MimeTypes.VIDEO_MP4, psshData);
   }
 
-  private static @Nullable SchemeData parseWidevineSchemeData(
+  private static @Nullable
+  SchemeData parseWidevineSchemeData(
       String line, String keyFormat, Map<String, String> variableDefinitions)
       throws ParserException {
     if (KEYFORMAT_WIDEVINE_PSSH_BINARY.equals(keyFormat)) {
+      //if (keyFormat.equals(keyFormat)) {
       String uriString = parseStringAttr(line, REGEX_URI, variableDefinitions);
       return new SchemeData(
           C.WIDEVINE_UUID,
@@ -718,7 +760,8 @@ private static String parseStringAttr(
     }
   }
 
-  private static @Nullable String parseOptionalStringAttr(
+  private static @Nullable
+  String parseOptionalStringAttr(
       String line, Pattern pattern, Map<String, String> variableDefinitions) {
     return parseOptionalStringAttr(line, pattern, null, variableDefinitions);
   }
