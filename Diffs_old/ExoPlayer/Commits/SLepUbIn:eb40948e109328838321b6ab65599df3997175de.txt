diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index c89e415f55..86eab7c1b0 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -194,6 +194,16 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
    */
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
+  /**
+   * H.264/AVC buffer to queue when using the adaptation workaround (see
+   * {@link #codecNeedsAdaptationWorkaround(String)}. Consists of three NAL units with start codes:
+   * Baseline sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be
+   * queued to force a resolution change when adapting to a new format.
+   */
+  private static final byte[] ADAPTATION_WORKAROUND_BUFFER = Util.getBytesFromHexString(
+      "0000016742C00BDA259000000168CE0F13200000016588840DCE7118A0002FBF1C31C3275D78");
+  private static final int ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT = 32;
+
   public final CodecCounters codecCounters;
 
   private final MediaCodecSelector mediaCodecSelector;
@@ -213,9 +223,12 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean codecIsAdaptive;
   private boolean codecNeedsDiscardToSpsWorkaround;
   private boolean codecNeedsFlushWorkaround;
+  private boolean codecNeedsAdaptationWorkaround;
   private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
   private boolean codecNeedsMonoChannelCountWorkaround;
+  private boolean codecNeedsAdaptationWorkaroundBuffer;
+  private boolean shouldSkipAdaptationWorkaroundOutputBuffer;
   private ByteBuffer[] inputBuffers;
   private ByteBuffer[] outputBuffers;
   private long codecHotswapTimeMs;
@@ -378,6 +391,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     codecIsAdaptive = decoderInfo.adaptive;
     codecNeedsDiscardToSpsWorkaround = codecNeedsDiscardToSpsWorkaround(codecName, format);
     codecNeedsFlushWorkaround = codecNeedsFlushWorkaround(codecName);
+    codecNeedsAdaptationWorkaround = codecNeedsAdaptationWorkaround(codecName);
     codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
     codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
@@ -459,9 +473,12 @@ protected void releaseCodec() {
       codecIsAdaptive = false;
       codecNeedsDiscardToSpsWorkaround = false;
       codecNeedsFlushWorkaround = false;
+      codecNeedsAdaptationWorkaround = false;
       codecNeedsEosPropagationWorkaround = false;
       codecNeedsEosFlushWorkaround = false;
       codecNeedsMonoChannelCountWorkaround = false;
+      codecNeedsAdaptationWorkaroundBuffer = false;
+      shouldSkipAdaptationWorkaroundOutputBuffer = false;
       codecReceivedEos = false;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       codecReinitializationState = REINITIALIZATION_STATE_NONE;
@@ -533,6 +550,8 @@ protected void flushCodec() throws ExoPlaybackException {
     waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     decodeOnlyPresentationTimestamps.clear();
+    codecNeedsAdaptationWorkaroundBuffer = false;
+    shouldSkipAdaptationWorkaroundOutputBuffer = false;
     if (codecNeedsFlushWorkaround || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
       // Workaround framework bugs. See [Internal: b/8347958, b/8578467, b/8543366, b/23361053].
       releaseCodec();
@@ -593,6 +612,15 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
       return false;
     }
 
+    if (codecNeedsAdaptationWorkaroundBuffer) {
+      codecNeedsAdaptationWorkaroundBuffer = false;
+      sampleHolder.data.put(ADAPTATION_WORKAROUND_BUFFER);
+      codec.queueInputBuffer(inputIndex, 0, ADAPTATION_WORKAROUND_BUFFER.length, 0, 0);
+      inputIndex = -1;
+      codecReceivedBuffers = true;
+      return true;
+    }
+
     int result;
     if (waitingForKeys) {
       // We've already read an encrypted sample into sampleHolder, and are waiting for keys.
@@ -759,6 +787,7 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
     if (codec != null && canReconfigureCodec(codec, codecIsAdaptive, oldFormat, format)) {
       codecReconfigured = true;
       codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+      codecNeedsAdaptationWorkaroundBuffer = codecNeedsAdaptationWorkaround;
     } else {
       if (codecReceivedBuffers) {
         // Signal end of stream and wait for any final output buffers before re-initialization.
@@ -907,6 +936,13 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       return false;
     }
 
+    if (shouldSkipAdaptationWorkaroundOutputBuffer) {
+      shouldSkipAdaptationWorkaroundOutputBuffer = false;
+      codec.releaseOutputBuffer(outputIndex, false);
+      outputIndex = -1;
+      return true;
+    }
+
     if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
       processEndOfStream();
       return false;
@@ -933,6 +969,15 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
    */
   private void processOutputFormat() throws ExoPlaybackException {
     android.media.MediaFormat format = codec.getOutputFormat();
+    if (codecNeedsAdaptationWorkaround
+        && format.getInteger(android.media.MediaFormat.KEY_WIDTH)
+            == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
+        && format.getInteger(android.media.MediaFormat.KEY_HEIGHT)
+            == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT) {
+      // We assume this format changed event was caused by the adaptation workaround.
+      shouldSkipAdaptationWorkaroundOutputBuffer = true;
+      return;
+    }
     if (codecNeedsMonoChannelCountWorkaround) {
       format.setInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT, 1);
     }
@@ -1029,6 +1074,22 @@ private static boolean codecNeedsFlushWorkaround(String name) {
             && ("OMX.Exynos.avc.dec".equals(name) || "OMX.Exynos.avc.dec.secure".equals(name)));
   }
 
+  /**
+   * Returns whether the decoder is known to get stuck during some adaptations.
+   * <p>
+   * If true is returned, the renderer will work around the issue by queueing and discarding a blank
+   * frame at a different resolution, which resets the codec's internal state.
+   * <p>
+   * See [Internal: b/27807182].
+   *
+   * @param name The name of the decoder.
+   * @return True if the decoder is known to get stuck during some adaptations.
+   */
+  private static boolean codecNeedsAdaptationWorkaround(String name) {
+    return Util.SDK_INT < 24 && Util.DEVICE.startsWith("flounder")
+        && ("OMX.Nvidia.h264.decode".equals(name) || "OMX.Nvidia.h264.decode.secure".equals(name));
+  }
+
   /**
    * Returns whether the decoder is an H.264/AVC decoder known to fail if NAL units are queued
    * before the codec specific data.
