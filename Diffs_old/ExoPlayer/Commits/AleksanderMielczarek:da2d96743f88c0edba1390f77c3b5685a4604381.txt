diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
index 3e91c74a90..dabf828b10 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadManager.java
@@ -233,31 +233,29 @@ public void stopDownloads() {
   public void pauseDownload(DownloadAction action) {
     Assertions.checkState(!released);
     if (!downloadsStopped) {
-      Iterator<Task> taskIterator = activeDownloadTasks.iterator();
-      while (taskIterator.hasNext()) {
-        Task task = taskIterator.next();
+      for (Task task : activeDownloadTasks) {
         if (task.action.equals(action)) {
           task.pause();
+          break;
         }
       }
       logd("Download is pausing");
     }
   }
 
-  public void resumeDownload(DownloadAction action) {
-    Assertions.checkState(!released);
-    Iterator<Task> taskIterator = tasks.iterator();
-    while (taskIterator.hasNext()) {
-      Task task = taskIterator.next();
+  private void resumeDownload(DownloadAction action) {
+    for (Task task : tasks) {
       if (task.action.equals(action)) {
         Task resumedTask = task.getResumedTask();
         replaceTask(task, resumedTask);
         resumedTask.resume();
         saveActions();
+        notifyListenersTaskStateChange(resumedTask);
+        maybeStartTasks();
+        notifyListenersTaskStateChange(resumedTask);
+        break;
       }
     }
-    startDownloads();
-    logd("Download is resuming");
   }
 
   /**
@@ -270,11 +268,21 @@ public void resumeDownload(DownloadAction action) {
    */
   public int handleAction(byte[] actionData) throws IOException {
     Assertions.checkState(!released);
-    ByteArrayInputStream input = new ByteArrayInputStream(actionData);
-    DownloadAction action = DownloadAction.deserializeFromStream(deserializers, input);
+    DownloadAction action = createDownloadAction(actionData);
     return handleAction(action);
   }
 
+  public void handleResumeAction(byte[] actionData) throws IOException {
+    Assertions.checkState(!released);
+    DownloadAction action = createDownloadAction(actionData);
+    resumeDownload(action);
+  }
+
+  private DownloadAction createDownloadAction(byte[] actionData) throws IOException {
+    ByteArrayInputStream input = new ByteArrayInputStream(actionData);
+    return DownloadAction.deserializeFromStream(deserializers, input);
+  }
+
   /**
    * Handles the given action. A task is created and added to the task queue. If it's a remove
    * action then any download tasks for the same media are immediately canceled.
@@ -864,7 +872,7 @@ private void pause() {
     }
 
     private void resume() {
-      changeStateAndNotify(STATE_PAUSED, STATE_QUEUED);
+      currentState = STATE_QUEUED;
     }
 
     private boolean changeStateAndNotify(@InternalState int oldState, @InternalState int newState) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
index 5c6cf88b48..b0269d21e0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloadService.java
@@ -44,6 +44,8 @@
   /** Starts a download service, adding a new {@link DownloadAction} to be executed. */
   public static final String ACTION_ADD = "com.google.android.exoplayer.downloadService.action.ADD";
 
+  public static final String ACTION_RESUME = "com.google.android.exoplayer.downloadService.action.RESUME";
+
   /** Reloads the download requirements. */
   public static final String ACTION_RELOAD_REQUIREMENTS =
       "com.google.android.exoplayer.downloadService.action.RELOAD_REQUIREMENTS";
@@ -174,6 +176,16 @@ public static Intent buildAddActionIntent(
         .putExtra(KEY_FOREGROUND, foreground);
   }
 
+  public static Intent buildResumeActionIntent(
+          Context context,
+          Class<? extends DownloadService> clazz,
+          DownloadAction downloadAction,
+          boolean foreground) {
+    return getIntent(context, clazz, ACTION_RESUME)
+            .putExtra(KEY_DOWNLOAD_ACTION, downloadAction.toByteArray())
+            .putExtra(KEY_FOREGROUND, foreground);
+  }
+
   /**
    * Starts the service, adding an action to be executed.
    *
@@ -195,6 +207,19 @@ public static void startWithAction(
     }
   }
 
+  public static void startWithResumeAction(
+          Context context,
+          Class<? extends DownloadService> clazz,
+          DownloadAction downloadAction,
+          boolean foreground) {
+    Intent intent = buildResumeActionIntent(context, clazz, downloadAction, foreground);
+    if (foreground) {
+      Util.startForegroundService(context, intent);
+    } else {
+      context.startService(intent);
+    }
+  }
+
   /**
    * Starts the service without adding a new action. If there are any not finished actions and the
    * requirements are met, the service resumes executing actions. Otherwise it stops immediately.
@@ -248,13 +273,13 @@ public int onStartCommand(Intent intent, int flags, int startId) {
       intentAction = ACTION_INIT;
     }
     logd("onStartCommand action: " + intentAction + " startId: " + startId);
+    byte[] actionData = intent.getByteArrayExtra(KEY_DOWNLOAD_ACTION);
     switch (intentAction) {
       case ACTION_INIT:
       case ACTION_RESTART:
         // Do nothing.
         break;
       case ACTION_ADD:
-        byte[] actionData = intent.getByteArrayExtra(KEY_DOWNLOAD_ACTION);
         if (actionData == null) {
           Log.e(TAG, "Ignoring ADD action with no action data");
         } else {
@@ -265,6 +290,17 @@ public int onStartCommand(Intent intent, int flags, int startId) {
           }
         }
         break;
+      case ACTION_RESUME:
+        if (actionData == null) {
+          Log.e(TAG, "Ignoring RESUME action with no action data");
+        } else {
+          try {
+            downloadManager.handleResumeAction(actionData);
+          } catch (IOException e) {
+            Log.e(TAG, "Failed to handle RESUME action", e);
+          }
+        }
+        break;
       case ACTION_RELOAD_REQUIREMENTS:
         stopWatchingRequirements();
         break;
