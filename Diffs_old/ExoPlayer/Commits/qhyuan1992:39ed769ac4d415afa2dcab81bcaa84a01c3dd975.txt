diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 2559901b0b..43c4809480 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -9,10 +9,9 @@ Before filing a new issue, please search the tracker to check if it's already
 covered by an existing report. Avoiding duplicates helps us maximize the time we
 can spend fixing bugs and adding new features.
 
-If you're filing a bug, be sure to provide enough information for us to
-efficiently diagnose and reproduce the problem.
-[Reporting an issue](https://google.github.io/ExoPlayer/2015/10/01/reporting-issues.html)
-gives some examples of what to include.
+When filing an issue, be sure to provide enough information for us to
+efficiently diagnose and reproduce the problem. In particular, please include
+all of the information requested in the issue template.
 
 ## Pull requests ##
 
diff --git a/README.md b/README.md
index 3731ddda0b..970d482e16 100644
--- a/README.md
+++ b/README.md
@@ -16,7 +16,7 @@ and extend, and can be updated through Play Store application updates.
 
 [developer guide]: https://google.github.io/ExoPlayer/guide.html
 [class reference]: https://google.github.io/ExoPlayer/doc/reference
-[release notes]: https://github.com/google/ExoPlayer/blob/dev/RELEASENOTES.md
+[release notes]: https://github.com/google/ExoPlayer/blob/dev-v2/RELEASENOTES.md
 
 ## Using ExoPlayer ##
 
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 9b0c1d07e3..60e421a860 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,18 @@
 # Release notes #
 
+### r1.5.11 ###
+
+* Cronet network stack extension.
+* HLS: Fix propagation of language for alternative audio renditions
+  ([#1784](https://github.com/google/ExoPlayer/issues/1784)).
+* WebM: Support for subsample encryption.
+* ID3: Fix EOS detection for 2-byte encodings
+  ([#1774](https://github.com/google/ExoPlayer/issues/1774)).
+* MPEG-TS: Support multiple tracks of the same type.
+* MPEG-TS: Work toward robust handling of stream corruption.
+* Fix ContentDataSource failures triggered by garbage collector
+  ([#1759](https://github.com/google/ExoPlayer/issues/1759)).
+
 ### r1.5.10 ###
 
 * HLS: Stability fixes.
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 1b0a025a57..eaa2e296d1 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1510"
-    android:versionName="1.5.10"
+    android:versionCode="1511"
+    android:versionName="1.5.11"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
index e74dd8275e..f21df7f79c 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer.util.Util;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
@@ -35,6 +36,8 @@
 
   private static final String PLAYREADY_TEST_DEFAULT_URI =
       "http://playready.directtaps.net/pr/svc/rightsmanager.asmx";
+  private static final Map<String, String> PROVISIONING_REQUEST_PROPERTIES =
+      Collections.singletonMap("Content-Type", "application/octet-stream");
   private static final Map<String, String> KEY_REQUEST_PROPERTIES;
   static {
     HashMap<String, String> keyRequestProperties = new HashMap<>();
@@ -47,7 +50,7 @@
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return Util.executePost(url, null, null);
+    return Util.executePost(url, null, PROVISIONING_REQUEST_PROPERTIES);
   }
 
   @Override
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index 91a2c85cdd..9039d16cb2 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -22,6 +22,8 @@
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.util.Util;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -32,6 +34,8 @@
 
   private static final String WIDEVINE_GTS_DEFAULT_BASE_URI =
       "https://proxy.uat.widevine.com/proxy";
+  private static final Map<String, String> REQUEST_PROPERTIES =
+      Collections.singletonMap("Content-Type", "application/octet-stream");
 
   private final String defaultUri;
 
@@ -43,7 +47,7 @@ public WidevineTestMediaDrmCallback(String contentId, String provider) {
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return Util.executePost(url, null, null);
+    return Util.executePost(url, null, REQUEST_PROPERTIES);
   }
 
   @Override
@@ -52,7 +56,7 @@ public WidevineTestMediaDrmCallback(String contentId, String provider) {
     if (TextUtils.isEmpty(url)) {
       url = defaultUri;
     }
-    return Util.executePost(url, request.getData(), null);
+    return Util.executePost(url, request.getData(), REQUEST_PROPERTIES);
   }
 
 }
diff --git a/demo_ext/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
index b5413ee399..a86a742737 100644
--- a/demo_ext/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.ext"
-    android:versionCode="1510"
-    android:versionName="1.5.10"
+    android:versionCode="1511"
+    android:versionName="1.5.11"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
new file mode 100644
index 0000000000..be79ac7d3e
--- /dev/null
+++ b/extensions/cronet/README.md
@@ -0,0 +1,31 @@
+# ExoPlayer Cronet Extension #
+
+## Description ##
+
+[Cronet][] is Chromium's Networking stack packaged as a library.
+
+The Cronet Extension is an [HttpDataSource][] implementation using [Cronet][].
+
+[HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/upstream/HttpDataSource.html
+[Cronet]: https://chromium.googlesource.com/chromium/src/+/master/components/cronet?autodive=0%2F%2F
+
+## Build Instructions ##
+
+* Checkout ExoPlayer along with Extensions:
+
+```
+git clone https://github.com/google/ExoPlayer.git
+```
+
+* Get the Cronet libraries:
+
+1. Find the latest Cronet release [here][] and navigate to its `Release/cronet`
+   directory
+1. Download `cronet.jar`, `cronet_api.jar` and the `libs` directory
+1. Copy the two jar files into the `libs` directory of this extension
+1. Copy the content of the downloaded `libs` directory into the `jniLibs`
+   directory of this extension
+
+* In ExoPlayer's `settings.gradle` file, uncomment the Cronet extension
+
+[here]: https://console.cloud.google.com/storage/browser/chromium-cronet/android
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
new file mode 100644
index 0000000000..0b75639d73
--- /dev/null
+++ b/extensions/cronet/build.gradle
@@ -0,0 +1,51 @@
+// Copyright (C) 2014 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    sourceSets.main {
+        jniLibs.srcDirs = ['jniLibs']
+    }
+}
+
+dependencies {
+    compile project(':library')
+    compile files('libs/cronet_api.jar')
+    compile files('libs/cronet.jar')
+    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
+    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestCompile 'org.mockito:mockito-core:1.9.5'
+    androidTestCompile project(':library')
+    androidTestCompile 'com.android.support.test:runner:0.4'
+}
diff --git a/extensions/cronet/jniLibs/README.md b/extensions/cronet/jniLibs/README.md
new file mode 100644
index 0000000000..e9f0717ae6
--- /dev/null
+++ b/extensions/cronet/jniLibs/README.md
@@ -0,0 +1 @@
+Copy folders containing architecture specific .so files here.
diff --git a/extensions/cronet/libs/README.md b/extensions/cronet/libs/README.md
new file mode 100644
index 0000000000..641a80db18
--- /dev/null
+++ b/extensions/cronet/libs/README.md
@@ -0,0 +1 @@
+Copy cronet.jar and cronet_api.jar here.
diff --git a/extensions/cronet/src/androidTest/AndroidManifest.xml b/extensions/cronet/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..48edf5aca6
--- /dev/null
+++ b/extensions/cronet/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer.ext.cronet">
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
+    <uses-library android:name="android.test.runner" />
+  </application>
+
+  <instrumentation
+      android:name="android.test.InstrumentationTestRunner"
+      android:targetPackage="com.google.android.exoplayer.ext.cronet"
+      tools:replace="android:targetPackage"/>
+
+</manifest>
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProviderTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProviderTest.java
new file mode 100644
index 0000000000..2222711bf7
--- /dev/null
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProviderTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer.ext.cronet;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.annotation.TargetApi;
+import android.os.Build.VERSION_CODES;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.chromium.net.UploadDataSink;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+/**
+ * Tests for {@link ByteArrayUploadDataProvider}.
+ */
+@RunWith(AndroidJUnit4.class)
+public final class ByteArrayUploadDataProviderTest {
+
+  private static final byte[] TEST_DATA = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  @Mock private UploadDataSink mockUploadDataSink;
+  private ByteBuffer byteBuffer;
+  private ByteArrayUploadDataProvider byteArrayUploadDataProvider;
+
+  @Before
+  public void setUp() {
+    System.setProperty("dexmaker.dexcache",
+        InstrumentationRegistry.getTargetContext().getCacheDir().getPath());
+    initMocks(this);
+    byteBuffer = ByteBuffer.allocate(TEST_DATA.length);
+    byteArrayUploadDataProvider = new ByteArrayUploadDataProvider(TEST_DATA);
+  }
+
+  @Test
+  public void testGetLength() {
+    assertEquals(TEST_DATA.length, byteArrayUploadDataProvider.getLength());
+  }
+
+  @Test
+  public void testReadFullBuffer() throws IOException {
+    byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
+    assertArrayEquals(TEST_DATA, byteBuffer.array());
+  }
+
+  @TargetApi(VERSION_CODES.GINGERBREAD)
+  @Test
+  public void testReadPartialBuffer() throws IOException {
+    byte[] firstHalf = Arrays.copyOfRange(TEST_DATA, 0, TEST_DATA.length / 2);
+    byte[] secondHalf = Arrays.copyOfRange(TEST_DATA, TEST_DATA.length / 2, TEST_DATA.length);
+    byteBuffer = ByteBuffer.allocate(TEST_DATA.length / 2);
+    // Read half of the data.
+    byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
+    assertArrayEquals(firstHalf, byteBuffer.array());
+
+    // Read the second half of the data.
+    byteBuffer.rewind();
+    byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
+    assertArrayEquals(secondHalf, byteBuffer.array());
+    verify(mockUploadDataSink, times(2)).onReadSucceeded(false);
+  }
+
+  @Test
+  public void testRewind() throws IOException {
+    // Read all the data.
+    byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
+    assertArrayEquals(TEST_DATA, byteBuffer.array());
+
+    // Rewind and make sure it can be read again.
+    byteBuffer.clear();
+    byteArrayUploadDataProvider.rewind(mockUploadDataSink);
+    byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
+    assertArrayEquals(TEST_DATA, byteBuffer.array());
+    verify(mockUploadDataSink).onRewindSucceeded();
+  }
+
+}
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
new file mode 100644
index 0000000000..246028649a
--- /dev/null
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
@@ -0,0 +1,838 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer.ext.cronet;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.net.Uri;
+import android.os.ConditionVariable;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.HttpDataSource;
+import com.google.android.exoplayer.upstream.HttpDataSource.HttpDataSourceException;
+import com.google.android.exoplayer.upstream.TransferListener;
+import com.google.android.exoplayer.util.Clock;
+import com.google.android.exoplayer.util.Predicate;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.chromium.net.CronetEngine;
+import org.chromium.net.UrlRequest;
+import org.chromium.net.UrlRequestException;
+import org.chromium.net.UrlResponseInfo;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Tests for {@link CronetDataSource}.
+ */
+@RunWith(AndroidJUnit4.class)
+public final class CronetDataSourceTest {
+
+  private static final int TEST_CONNECT_TIMEOUT_MS = 100;
+  private static final int TEST_READ_TIMEOUT_MS = 50;
+  private static final String TEST_URL = "http://google.com";
+  private static final String TEST_CONTENT_TYPE = "test/test";
+  private static final byte[] TEST_POST_BODY = "test post body".getBytes();
+  private static final long TEST_CONTENT_LENGTH = 16000L;
+  private static final int TEST_BUFFER_SIZE = 16;
+  private static final int TEST_CONNECTION_STATUS = 5;
+
+  private DataSpec testDataSpec;
+  private DataSpec testPostDataSpec;
+  private Map<String, String> testResponseHeader;
+  private UrlResponseInfo testUrlResponseInfo;
+
+  /**
+   * MockableCronetEngine is an abstract class for helping creating new Requests.
+   */
+  public abstract static class MockableCronetEngine extends CronetEngine {
+
+    @Override
+    public abstract UrlRequest createRequest(String url, UrlRequest.Callback callback,
+        Executor executor, int priority,
+        Collection<Object> connectionAnnotations,
+        boolean disableCache,
+        boolean disableConnectionMigration);
+
+  }
+
+  @Mock
+  private UrlRequest mockUrlRequest;
+  @Mock
+  private Predicate<String> mockContentTypePredicate;
+  @Mock
+  private TransferListener mockTransferListener;
+  @Mock
+  private Clock mockClock;
+  @Mock
+  private Executor mockExecutor;
+  @Mock
+  private UrlRequestException mockUrlRequestException;
+  @Mock
+  private MockableCronetEngine mockCronetEngine;
+
+  private CronetDataSource dataSourceUnderTest;
+
+  @Before
+  public void setUp() throws Exception {
+    System.setProperty("dexmaker.dexcache",
+        InstrumentationRegistry.getTargetContext().getCacheDir().getPath());
+    initMocks(this);
+    dataSourceUnderTest = spy(
+        new CronetDataSource(
+            mockCronetEngine,
+            mockExecutor,
+            mockClock,
+            mockContentTypePredicate,
+            mockTransferListener,
+            TEST_CONNECT_TIMEOUT_MS,
+            TEST_READ_TIMEOUT_MS,
+            true)); // resetTimeoutOnRedirects
+    when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
+    when(mockCronetEngine.createRequest(
+        anyString(),
+        any(UrlRequest.Callback.class),
+        any(Executor.class),
+        anyInt(),
+        eq(Collections.emptyList()),
+        any(Boolean.class),
+        any(Boolean.class))).thenReturn(mockUrlRequest);
+    mockStatusResponse();
+
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNBOUNDED, null);
+    testPostDataSpec = new DataSpec(
+        Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNBOUNDED, null, 0);
+    testResponseHeader = new HashMap<>();
+    testResponseHeader.put("Content-Type", TEST_CONTENT_TYPE);
+    // This value can be anything since the DataSpec is unbounded.
+    testResponseHeader.put("Content-Length", Long.toString(TEST_CONTENT_LENGTH));
+    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+  }
+
+  private UrlResponseInfo createUrlResponseInfo(int statusCode) {
+    ArrayList<Map.Entry<String, String>> responseHeaderList = new ArrayList<>();
+    responseHeaderList.addAll(testResponseHeader.entrySet());
+    return new UrlResponseInfo(
+        Collections.singletonList(TEST_URL),
+        statusCode,
+        null, // httpStatusText
+        responseHeaderList,
+        false, // wasCached
+        null, // negotiatedProtocol
+        null); // proxyServer
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void testOpeningTwiceThrows() throws HttpDataSourceException, IllegalStateException {
+    mockResponesStartSuccess();
+
+    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
+    dataSourceUnderTest.open(testDataSpec);
+    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    dataSourceUnderTest.open(testDataSpec);
+  }
+
+  @Test
+  public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+    dataSourceUnderTest.close();
+    // Prepare a mock UrlRequest to be used in the second open() call.
+    final UrlRequest mockUrlRequest2 = mock(UrlRequest.class);
+    when(mockCronetEngine.createRequest(
+        anyString(),
+        any(UrlRequest.Callback.class),
+        any(Executor.class),
+        anyInt(),
+        eq(Collections.emptyList()),
+        any(Boolean.class),
+        any(Boolean.class))).thenReturn(mockUrlRequest2);
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        // Invoke the callback for the previous request.
+        dataSourceUnderTest.onFailed(
+            mockUrlRequest,
+            testUrlResponseInfo,
+            null);
+        dataSourceUnderTest.onResponseStarted(
+            mockUrlRequest2,
+            testUrlResponseInfo);
+        return null;
+      }
+    }).when(mockUrlRequest2).start();
+    dataSourceUnderTest.open(testDataSpec);
+  }
+
+  @Test
+  public void testRequestStartCalled() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+    verify(mockCronetEngine).createRequest(
+        eq(TEST_URL),
+        any(UrlRequest.Callback.class),
+        any(Executor.class),
+        anyInt(),
+        eq(Collections.emptyList()),
+        any(Boolean.class),
+        any(Boolean.class));
+    verify(mockUrlRequest).start();
+  }
+
+  @Test
+  public void testRequestHeadersSet() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+    testResponseHeader.put("Content-Length", Long.toString(5000L));
+
+    dataSourceUnderTest.setRequestProperty("firstHeader", "firstValue");
+    dataSourceUnderTest.setRequestProperty("secondHeader", "secondValue");
+
+    dataSourceUnderTest.open(testDataSpec);
+    // The header value to add is current position to current position + length - 1.
+    verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
+    verify(mockUrlRequest).addHeader("firstHeader", "firstValue");
+    verify(mockUrlRequest).addHeader("secondHeader", "secondValue");
+    verify(mockUrlRequest).start();
+  }
+
+  @Test
+  public void testRequestOpen() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testDataSpec));
+    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    verify(mockTransferListener).onTransferStart();
+  }
+
+  @Test
+  public void testRequestOpenFail() {
+    mockResponseStartFailure();
+
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      // Check for connection not automatically closed.
+      assertFalse(e.getCause() instanceof UnknownHostException);
+      verify(mockUrlRequest, never()).cancel();
+      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
+      verify(mockTransferListener, never()).onTransferStart();
+    }
+  }
+
+  @Test
+  public void testRequestOpenFailDueToDnsFailure() {
+    mockResponseStartFailure();
+    when(mockUrlRequestException.getErrorCode()).thenReturn(
+        UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED);
+
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      // Check for connection not automatically closed.
+      assertTrue(e.getCause() instanceof UnknownHostException);
+      verify(mockUrlRequest, never()).cancel();
+      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
+      verify(mockTransferListener, never()).onTransferStart();
+    }
+  }
+
+  @Test
+  public void testRequestOpenValidatesStatusCode() {
+    mockResponesStartSuccess();
+    testUrlResponseInfo = createUrlResponseInfo(500); // statusCode
+
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      assertTrue(e instanceof HttpDataSource.InvalidResponseCodeException);
+      // Check for connection not automatically closed.
+      verify(mockUrlRequest, never()).cancel();
+      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
+      verify(mockTransferListener, never()).onTransferStart();
+    }
+  }
+
+  @Test
+  public void testRequestOpenValidatesContentTypePredicate() {
+    mockResponesStartSuccess();
+    when(mockContentTypePredicate.evaluate(anyString())).thenReturn(false);
+
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      assertTrue(e instanceof HttpDataSource.InvalidContentTypeException);
+      // Check for connection not automatically closed.
+      verify(mockUrlRequest, never()).cancel();
+      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
+      verify(mockContentTypePredicate).evaluate(TEST_CONTENT_TYPE);
+    }
+  }
+
+  @Test
+  public void testRequestOpenValidatesContentLength() {
+    mockResponesStartSuccess();
+
+    // Data spec's requested length, 5000. Test response's length, 16,000.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    try {
+      dataSourceUnderTest.open(testDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
+      // Check for connection not automatically closed.
+      verify(mockUrlRequest, never()).cancel();
+      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
+      verify(mockTransferListener, never()).onTransferStart();
+    }
+  }
+
+  @Test
+  public void testPostRequestOpen() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
+    assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testPostDataSpec));
+    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    verify(mockTransferListener).onTransferStart();
+  }
+
+  @Test
+  public void testPostRequestOpenValidatesContentType() {
+    mockResponesStartSuccess();
+
+    try {
+      dataSourceUnderTest.open(testPostDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      verify(mockUrlRequest, never()).start();
+    }
+  }
+
+  @Test
+  public void testPostRequestOpenRejects307Redirects() {
+    mockResponesStartSuccess();
+    mockResponseStartRedirect();
+
+    try {
+      dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
+      dataSourceUnderTest.open(testPostDataSpec);
+      fail("HttpDataSource.HttpDataSourceException expected");
+    } catch (HttpDataSourceException e) {
+      verify(mockUrlRequest, never()).followRedirect();
+    }
+  }
+
+  @Test
+  public void testRequestReadTwice() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[8];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
+    assertEquals(8, bytesRead);
+
+    returnedBuffer = new byte[8];
+    bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
+    assertArrayEquals(buildTestDataArray(8, 8), returnedBuffer);
+    assertEquals(8, bytesRead);
+
+    // Should have only called read on cronet once.
+    verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
+    verify(mockTransferListener, times(2)).onBytesTransferred(8);
+  }
+
+  @Test
+  public void testSecondRequestNoContentLength() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    byte[] returnedBuffer = new byte[8];
+
+    // First request.
+    testResponseHeader.put("Content-Length", Long.toString(1L));
+    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    dataSourceUnderTest.open(testDataSpec);
+    dataSourceUnderTest.read(returnedBuffer, 0, 1);
+    dataSourceUnderTest.close();
+
+    // Second request. There's no Content-Length response header.
+    testResponseHeader.remove("Content-Length");
+    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    dataSourceUnderTest.open(testDataSpec);
+    returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
+    assertEquals(10, bytesRead);
+
+    mockResponseFinished();
+
+    // Should read whats left in the buffer first.
+    bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
+    assertEquals(6, bytesRead);
+    bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
+    assertEquals(C.RESULT_END_OF_INPUT, bytesRead);
+  }
+
+  @Test
+  public void testReadWithOffset() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
+    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
+    assertEquals(8, bytesRead);
+    verify(mockTransferListener).onBytesTransferred(8);
+  }
+
+  @Test
+  public void testReadReturnsWhatItCan() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[24];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 24);
+    assertArrayEquals(suffixZeros(buildTestDataArray(0, 16), 24), returnedBuffer);
+    assertEquals(16, bytesRead);
+    verify(mockTransferListener).onBytesTransferred(16);
+  }
+
+  @Test
+  public void testClosedMeansClosed() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    int bytesRead = 0;
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[8];
+    bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
+    assertEquals(8, bytesRead);
+
+    dataSourceUnderTest.close();
+    verify(mockTransferListener).onTransferEnd();
+    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
+
+    try {
+      bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
+      fail();
+    } catch (IllegalStateException e) {
+      // Expected.
+    }
+
+    // 16 bytes were attempted but only 8 should have been successfully read.
+    assertEquals(8, bytesRead);
+  }
+
+  @Test
+  public void testOverread() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadSuccess();
+
+    // Ask for 16 bytes
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 10000, 16, null);
+    // Let the response promise to give 16 bytes back.
+    testResponseHeader.put("Content-Length", Long.toString(16L));
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[8];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
+    assertEquals(8, bytesRead);
+
+    // The current buffer is kept if not completely consumed by DataSource reader.
+    returnedBuffer = new byte[8];
+    bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 6);
+    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
+    assertEquals(14, bytesRead);
+
+    // 2 bytes left at this point.
+    returnedBuffer = new byte[8];
+    bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
+    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
+    assertEquals(16, bytesRead);
+
+    // Should have only called read on cronet once.
+    verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
+    verify(mockTransferListener, times(1)).onBytesTransferred(8);
+    verify(mockTransferListener, times(1)).onBytesTransferred(6);
+    verify(mockTransferListener, times(1)).onBytesTransferred(2);
+
+    // Now we already returned the 16 bytes initially asked.
+    // Try to read again even though all requested 16 bytes are already returned.
+    // Return C.RESULT_END_OF_INPUT
+    returnedBuffer = new byte[16];
+    int bytesOverRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(C.RESULT_END_OF_INPUT, bytesOverRead);
+    assertArrayEquals(new byte[16], returnedBuffer);
+    // C.RESULT_END_OF_INPUT should not be reported though the TransferListener.
+    verify(mockTransferListener, never()).onBytesTransferred(C.RESULT_END_OF_INPUT);
+    // There should still be only one call to read on cronet.
+    verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
+    // Check for connection not automatically closed.
+    verify(mockUrlRequest, never()).cancel();
+    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    assertEquals(16, bytesRead);
+  }
+
+  @Test
+  public void testConnectTimeout() {
+    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    final ConditionVariable startCondition = buildUrlRequestStartedCondition();
+    final ConditionVariable timedOutCondition = new ConditionVariable();
+
+    new Thread() {
+      @Override
+      public void run() {
+        try {
+          dataSourceUnderTest.open(testDataSpec);
+          fail();
+        } catch (HttpDataSourceException e) {
+          // Expected.
+          assertTrue(e instanceof CronetDataSource.OpenException);
+          assertTrue(e.getCause() instanceof SocketTimeoutException);
+          assertEquals(
+              TEST_CONNECTION_STATUS,
+              ((CronetDataSource.OpenException) e).cronetConnectionStatus);
+          timedOutCondition.open();
+        }
+      }
+    }.start();
+    startCondition.block();
+
+    // We should still be trying to open.
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // We should still be trying to open as we approach the timeout.
+    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // Now we timeout.
+    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS);
+    timedOutCondition.block();
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+
+    verify(mockTransferListener, never()).onTransferStart();
+  }
+
+  @Test
+  public void testConnectResponseBeforeTimeout() {
+    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    final ConditionVariable startCondition = buildUrlRequestStartedCondition();
+    final ConditionVariable openCondition = new ConditionVariable();
+
+    new Thread() {
+      @Override
+      public void run() {
+        try {
+          dataSourceUnderTest.open(testDataSpec);
+          openCondition.open();
+        } catch (HttpDataSourceException e) {
+          fail();
+        }
+      }
+    }.start();
+    startCondition.block();
+
+    // We should still be trying to open.
+    assertFalse(openCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // We should still be trying to open as we approach the timeout.
+    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
+    assertFalse(openCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // The response arrives just in time.
+    dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
+    openCondition.block();
+    assertEquals(CronetDataSource.OPEN_CONNECTION, dataSourceUnderTest.connectionState);
+  }
+
+  @Test
+  public void testRedirectIncreasesConnectionTimeout() throws InterruptedException {
+    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    final ConditionVariable startCondition = buildUrlRequestStartedCondition();
+    final ConditionVariable timedOutCondition = new ConditionVariable();
+    final AtomicInteger openExceptions = new AtomicInteger(0);
+
+    new Thread() {
+      @Override
+      public void run() {
+        try {
+          dataSourceUnderTest.open(testDataSpec);
+          fail();
+        } catch (HttpDataSourceException e) {
+          // Expected.
+          assertTrue(e instanceof CronetDataSource.OpenException);
+          assertTrue(e.getCause() instanceof SocketTimeoutException);
+          openExceptions.getAndIncrement();
+          timedOutCondition.open();
+        }
+      }
+    }.start();
+    startCondition.block();
+
+    // We should still be trying to open.
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // We should still be trying to open as we approach the timeout.
+    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // A redirect arrives just in time.
+    dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
+        "RandomRedirectedUrl1");
+
+    long newTimeoutMs = 2 * TEST_CONNECT_TIMEOUT_MS - 1;
+    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs - 1);
+    // Give the thread some time to run.
+    assertFalse(timedOutCondition.block(newTimeoutMs));
+    // We should still be trying to open as we approach the new timeout.
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // A redirect arrives just in time.
+    dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
+        "RandomRedirectedUrl2");
+
+    newTimeoutMs = 3 * TEST_CONNECT_TIMEOUT_MS - 2;
+    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs - 1);
+    // Give the thread some time to run.
+    assertFalse(timedOutCondition.block(newTimeoutMs));
+    // We should still be trying to open as we approach the new timeout.
+    assertFalse(timedOutCondition.block(50));
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+    // Now we timeout.
+    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs);
+    timedOutCondition.block();
+    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
+
+    verify(mockTransferListener, never()).onTransferStart();
+    assertEquals(1, openExceptions.get());
+  }
+
+  @Test
+  public void testExceptionFromTransferListener() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+
+    // Make mockTransferListener throw an exception in CronetDataSource.close(). Ensure that
+    // the subsequent open() call succeeds.
+    doThrow(new NullPointerException()).when(mockTransferListener).onTransferEnd();
+    dataSourceUnderTest.open(testDataSpec);
+    try {
+      dataSourceUnderTest.close();
+      fail("NullPointerException expected");
+    } catch (NullPointerException e) {
+      // Expected.
+    }
+    // Open should return successfully.
+    dataSourceUnderTest.open(testDataSpec);
+  }
+
+  @Test
+  public void testReadFailure() throws HttpDataSourceException {
+    mockResponesStartSuccess();
+    mockReadFailure();
+
+    dataSourceUnderTest.open(testDataSpec);
+    byte[] returnedBuffer = new byte[8];
+    try {
+      dataSourceUnderTest.read(returnedBuffer, 0, 8);
+      fail("dataSourceUnderTest.read() returned, but IOException expected");
+    } catch (IOException e) {
+      // Expected.
+    }
+  }
+
+  // Helper methods.
+
+  private void mockStatusResponse() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        UrlRequest.StatusListener statusListener =
+            (UrlRequest.StatusListener) invocation.getArguments()[0];
+        statusListener.onStatus(TEST_CONNECTION_STATUS);
+        return null;
+      }
+    }).when(mockUrlRequest).getStatus(any(UrlRequest.StatusListener.class));
+  }
+
+  private void mockResponesStartSuccess() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onResponseStarted(
+            mockUrlRequest,
+            testUrlResponseInfo);
+        return null;
+      }
+    }).when(mockUrlRequest).start();
+  }
+
+  private void mockResponseStartRedirect() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onRedirectReceived(
+            mockUrlRequest,
+            createUrlResponseInfo(307), // statusCode
+            "http://redirect.location.com");
+        return null;
+      }
+    }).when(mockUrlRequest).start();
+  }
+
+  private void mockResponseStartFailure() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onFailed(
+            mockUrlRequest,
+            createUrlResponseInfo(500), // statusCode
+            mockUrlRequestException);
+        return null;
+      }
+    }).when(mockUrlRequest).start();
+  }
+
+  private void mockReadSuccess() {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+        inputBuffer.put(buildTestDataBuffer());
+        dataSourceUnderTest.onReadCompleted(
+            mockUrlRequest,
+            testUrlResponseInfo,
+            inputBuffer);
+        return null;
+      }
+    }).when(mockUrlRequest).read(any(ByteBuffer.class));
+  }
+
+  private void mockReadFailure() {
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onFailed(
+            mockUrlRequest,
+            createUrlResponseInfo(500), // statusCode
+            null);
+        return null;
+      }
+    }).when(mockUrlRequest).read(any(ByteBuffer.class));
+  }
+
+  private void mockResponseFinished() {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+        return null;
+      }
+    }).when(mockUrlRequest).read(any(ByteBuffer.class));
+  }
+
+  private ConditionVariable buildUrlRequestStartedCondition() {
+    final ConditionVariable startedCondition = new ConditionVariable();
+    doAnswer(new Answer<Object>() {
+      @Override
+      public Object answer(InvocationOnMock invocation) throws Throwable {
+        startedCondition.open();
+        return null;
+      }
+    }).when(mockUrlRequest).start();
+    return startedCondition;
+  }
+
+  private static byte[] buildTestDataArray(int start, int length) {
+    return Arrays.copyOfRange(buildTestDataBuffer().array(), start, start + length);
+  }
+
+  public static byte[] prefixZeros(byte[] data, int requiredLength) {
+    byte[] prefixedData = new byte[requiredLength];
+    System.arraycopy(data, 0, prefixedData, requiredLength - data.length, data.length);
+    return prefixedData;
+  }
+
+  public static byte[] suffixZeros(byte[] data, int requiredLength) {
+    return Arrays.copyOf(data, requiredLength);
+  }
+
+  private static ByteBuffer buildTestDataBuffer() {
+    ByteBuffer testBuffer = ByteBuffer.allocate(TEST_BUFFER_SIZE);
+    for (byte i = 1; i <= TEST_BUFFER_SIZE; i++) {
+      testBuffer.put(i);
+    }
+    testBuffer.flip();
+    return testBuffer;
+  }
+
+  private void assertConnectionState(int state) {
+    assertEquals(state, dataSourceUnderTest.connectionState);
+  }
+
+}
diff --git a/extensions/cronet/src/main/.classpath b/extensions/cronet/src/main/.classpath
new file mode 100644
index 0000000000..503bb38b67
--- /dev/null
+++ b/extensions/cronet/src/main/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="src" path="/ExoPlayerLib"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/cronet/src/main/.project b/extensions/cronet/src/main/.project
new file mode 100644
index 0000000000..6aa97e6107
--- /dev/null
+++ b/extensions/cronet/src/main/.project
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-Cronet</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?children?</key>
+					<value>?name?=outputEntries\|?children?=?name?=entry\\\\\\\|\\\|?name?=entry\\\\\\\|\\\|\||</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>ndk-build</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/cronet/src/main/AndroidManifest.xml b/extensions/cronet/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..4de726be98
--- /dev/null
+++ b/extensions/cronet/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.ext.cronet">
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+</manifest>
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProvider.java b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProvider.java
new file mode 100644
index 0000000000..c860ff8b6e
--- /dev/null
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/ByteArrayUploadDataProvider.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.cronet;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import org.chromium.net.UploadDataProvider;
+import org.chromium.net.UploadDataSink;
+
+/**
+ * A {@link UploadDataProvider} implementation that provides data from a {@code byte[]}.
+ */
+/* package */ final class ByteArrayUploadDataProvider extends UploadDataProvider {
+
+  private final byte[] data;
+
+  private int position;
+
+  public ByteArrayUploadDataProvider(byte[] data) {
+    this.data = data;
+  }
+
+  @Override
+  public long getLength() {
+    return data.length;
+  }
+
+  @Override
+  public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
+    int readLength = Math.min(byteBuffer.remaining(), data.length - position);
+    byteBuffer.put(data, position, readLength);
+    position += readLength;
+    uploadDataSink.onReadSucceeded(false);
+  }
+
+  @Override
+  public void rewind(UploadDataSink uploadDataSink) throws IOException {
+    position = 0;
+    uploadDataSink.onRewindSucceeded();
+  }
+
+}
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
new file mode 100644
index 0000000000..7c26e93b1e
--- /dev/null
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.cronet;
+
+import android.os.ConditionVariable;
+import android.text.TextUtils;
+import android.util.Log;
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.HttpDataSource;
+import com.google.android.exoplayer.upstream.TransferListener;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Clock;
+import com.google.android.exoplayer.util.Predicate;
+import com.google.android.exoplayer.util.TraceUtil;
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.chromium.net.CronetEngine;
+import org.chromium.net.UrlRequest;
+import org.chromium.net.UrlRequestException;
+import org.chromium.net.UrlResponseInfo;
+
+/**
+ * DataSource without intermediate buffer based on Cronet API set using UrlRequest.
+ * <p>This class's methods are organized in the sequence of expected calls.
+ */
+public class CronetDataSource extends UrlRequest.Callback implements HttpDataSource {
+
+  /**
+   * Thrown when an error is encountered when trying to open a {@link CronetDataSource}.
+   */
+  public static final class OpenException extends HttpDataSourceException {
+
+    /**
+     * Returns the status of the connection establishment at the moment when the error occurred, as
+     * defined by {@link UrlRequest.Status}.
+     */
+    public final int cronetConnectionStatus;
+
+    public OpenException(IOException cause, DataSpec dataSpec, int cronetConnectionStatus) {
+      super(cause, dataSpec, TYPE_OPEN);
+      this.cronetConnectionStatus = cronetConnectionStatus;
+    }
+
+    public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectionStatus) {
+      super(errorMessage, dataSpec, TYPE_OPEN);
+      this.cronetConnectionStatus = cronetConnectionStatus;
+    }
+
+  }
+
+  private static final String TAG = "CronetDataSource";
+  private static final Pattern CONTENT_RANGE_HEADER_PATTERN =
+      Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
+  // The size of read buffer passed to cronet UrlRequest.read().
+  private static final int READ_BUFFER_SIZE_BYTES = 32 * 1024;
+
+  /* package */ static final int IDLE_CONNECTION = 5;
+  /* package */ static final int OPENING_CONNECTION = 2;
+  /* package */ static final int CONNECTED_CONNECTION = 3;
+  /* package */ static final int OPEN_CONNECTION = 4;
+
+  private final CronetEngine cronetEngine;
+  private final Executor executor;
+  private final Predicate<String> contentTypePredicate;
+  private final TransferListener transferListener;
+  private final int connectTimeoutMs;
+  private final int readTimeoutMs;
+  private final boolean resetTimeoutOnRedirects;
+  private final Map<String, String> requestProperties;
+  private final ConditionVariable operation;
+  private final ByteBuffer readBuffer;
+  private final Clock clock;
+
+  private UrlRequest currentUrlRequest;
+  private DataSpec currentDataSpec;
+  private UrlResponseInfo responseInfo;
+
+  /* package */ volatile int connectionState;
+  private volatile String currentUrl;
+  private volatile long currentConnectTimeoutMs;
+  private volatile HttpDataSourceException exception;
+  private volatile long contentLength;
+  private volatile AtomicLong expectedBytesRemainingToRead;
+  private volatile boolean hasData;
+  private volatile boolean responseFinished;
+
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the request.
+   * @param clock A {@link com.google.android.exoplayer.util.Clock} for keeping track of timeout.
+   * @param contentTypePredicate A {@link Predicate}. If a content type is rejected by the
+   *     predicate then a
+   *     {@link com.google.android.exoplayer.upstream.HttpDataSource.InvalidContentTypeException}
+   *     is thrown from {@link #validateResponse(UrlResponseInfo)}.
+   * @param transferListener A listener.
+   * @param connectTimeoutMs The timeout to execute a connection.
+   * @param readTimeoutMs The timeout to execute a connection.
+   * @param resetTimeoutOnRedirects Allow to reset the timeout when redirects occur.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor, Clock clock,
+      Predicate<String> contentTypePredicate, TransferListener transferListener,
+      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+    this.cronetEngine = Assertions.checkNotNull(cronetEngine);
+    this.executor = Assertions.checkNotNull(executor);
+    this.clock = Assertions.checkNotNull(clock);
+    this.contentTypePredicate = contentTypePredicate;
+    this.transferListener = transferListener;
+    this.connectTimeoutMs = connectTimeoutMs;
+    this.readTimeoutMs = readTimeoutMs;
+    this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
+    readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+    requestProperties = new HashMap<>();
+    operation = new ConditionVariable();
+    connectionState = IDLE_CONNECTION;
+  }
+
+  @Override
+  public void setRequestProperty(String name, String value) {
+    synchronized (requestProperties) {
+      requestProperties.put(name, value);
+    }
+  }
+
+  @Override
+  public void clearRequestProperty(String name) {
+    synchronized (requestProperties) {
+      requestProperties.remove(name);
+    }
+  }
+
+  @Override
+  public void clearAllRequestProperties() {
+    synchronized (requestProperties) {
+      requestProperties.clear();
+    }
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return responseInfo == null ? null : responseInfo.getAllHeaders();
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    TraceUtil.beginSection("CronetDataSource.open");
+    try {
+      Assertions.checkNotNull(dataSpec);
+      synchronized (this) {
+        Assertions.checkState(connectionState == IDLE_CONNECTION, "Connection already open");
+        connectionState = OPENING_CONNECTION;
+      }
+
+      operation.close();
+      resetConnectTimeout();
+      startRequest(dataSpec);
+      boolean requestStarted = blockUntilConnectTimeout();
+
+      if (exception != null) {
+        // An error occurred opening the connection.
+        throw exception;
+      } else if (!requestStarted) {
+        // The timeout was reached before the connection was opened.
+        throw new OpenException(new SocketTimeoutException(), dataSpec, getCurrentRequestStatus());
+      }
+
+      // Connection was opened.
+      if (transferListener != null) {
+        transferListener.onTransferStart();
+      }
+      connectionState = OPEN_CONNECTION;
+      return contentLength;
+    } finally {
+      TraceUtil.endSection();
+    }
+  }
+
+  private void startRequest(DataSpec dataSpec) throws HttpDataSourceException {
+    currentUrl = dataSpec.uri.toString();
+    currentDataSpec = dataSpec;
+    UrlRequest.Builder urlRequestBuilder = new UrlRequest.Builder(currentUrl, this, executor,
+        cronetEngine);
+    fillCurrentRequestHeader(urlRequestBuilder);
+    fillCurrentRequestPostBody(urlRequestBuilder, dataSpec);
+    currentUrlRequest = urlRequestBuilder.build();
+    currentUrlRequest.start();
+  }
+
+  private void fillCurrentRequestHeader(UrlRequest.Builder urlRequestBuilder) {
+    synchronized (requestProperties) {
+      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
+        urlRequestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+      }
+    }
+    if (currentDataSpec.position == 0 && currentDataSpec.length == C.LENGTH_UNBOUNDED) {
+      // Not required.
+      return;
+    }
+    StringBuilder rangeValue = new StringBuilder();
+    rangeValue.append("bytes=");
+    rangeValue.append(currentDataSpec.position);
+    rangeValue.append("-");
+    if (currentDataSpec.length != C.LENGTH_UNBOUNDED) {
+      rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
+    }
+    urlRequestBuilder.addHeader("Range", rangeValue.toString());
+  }
+
+  private void fillCurrentRequestPostBody(UrlRequest.Builder urlRequestBuilder, DataSpec dataSpec)
+      throws HttpDataSourceException {
+    if (dataSpec.postBody != null) {
+      if (!requestProperties.containsKey("Content-Type")) {
+        throw new OpenException("POST requests must set a Content-Type header", dataSpec,
+            getCurrentRequestStatus());
+      }
+      urlRequestBuilder.setUploadDataProvider(
+          new ByteArrayUploadDataProvider(dataSpec.postBody), executor);
+    }
+  }
+
+  @Override
+  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
+      UrlRequestException error) {
+    if (request != currentUrlRequest) {
+      return;
+    }
+    if (connectionState == OPENING_CONNECTION) {
+      IOException cause = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
+          ? new UnknownHostException() : error;
+      exception = new OpenException(cause, currentDataSpec, getCurrentRequestStatus());
+    } else if (connectionState == OPEN_CONNECTION) {
+      readBuffer.limit(0);
+      exception = new HttpDataSourceException(error, currentDataSpec,
+          HttpDataSourceException.TYPE_READ);
+    }
+    operation.open();
+  }
+
+  @Override
+  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
+    if (request != currentUrlRequest) {
+      return;
+    }
+    TraceUtil.beginSection("CronetDataSource.onResponseStarted");
+    try {
+      validateResponse(info);
+      responseInfo = info;
+      // Check content length.
+      contentLength = getContentLength(info.getAllHeaders());
+      // If a specific length is requested and a specific length is returned but the 2 don't match
+      // it's an error.
+      if (currentDataSpec.length != C.LENGTH_UNBOUNDED
+          && contentLength != C.LENGTH_UNBOUNDED
+          && currentDataSpec.length != contentLength) {
+        throw new OpenException("Content length did not match requested length", currentDataSpec,
+            getCurrentRequestStatus());
+      }
+
+      if (contentLength > 0) {
+        expectedBytesRemainingToRead = new AtomicLong(contentLength);
+      }
+
+      // Keep track of redirects.
+      currentUrl = responseInfo.getUrl();
+      connectionState = CONNECTED_CONNECTION;
+    } catch (HttpDataSourceException e) {
+      exception = e;
+    } finally {
+      operation.open();
+      TraceUtil.endSection();
+    }
+  }
+
+  private void validateResponse(UrlResponseInfo info) throws HttpDataSourceException {
+    // Check for a valid response code.
+    int responseCode = info.getHttpStatusCode();
+    if (responseCode < 200 || responseCode > 299) {
+      throw new HttpDataSource.InvalidResponseCodeException(
+          responseCode,
+          info.getAllHeaders(),
+          currentDataSpec);
+    }
+    // Check for a valid content type.
+    try {
+      String contentType = info.getAllHeaders().get("Content-Type").get(0);
+      if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+        throw new HttpDataSource.InvalidContentTypeException(contentType, currentDataSpec);
+      }
+    } catch (IndexOutOfBoundsException e) {
+      throw new HttpDataSource.InvalidContentTypeException(null, currentDataSpec);
+    }
+  }
+
+  private long getContentLength(Map<String, List<String>> headers) {
+    // Logic copied from {@code DefaultHttpDataSource}
+    long contentLength = C.LENGTH_UNBOUNDED;
+    List<String> contentLengthHeader = headers.get("Content-Length");
+    if (contentLengthHeader != null
+        && !contentLengthHeader.isEmpty()
+        && !TextUtils.isEmpty(contentLengthHeader.get(0))) {
+      try {
+        contentLength = Long.parseLong(contentLengthHeader.get(0));
+      } catch (NumberFormatException e) {
+        log(Log.ERROR, "Unexpected Content-Length [" + contentLengthHeader + "]");
+      }
+    }
+    List<String> contentRangeHeader = headers.get("Content-Range");
+    if (contentRangeHeader != null
+        && !contentRangeHeader.isEmpty()
+        && !TextUtils.isEmpty(contentRangeHeader.get(0))) {
+      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader.get(0));
+      if (matcher.find()) {
+        try {
+          long contentLengthFromRange =
+              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+          if (contentLength < 0) {
+            // Some proxy servers strip the Content-Length header. Fall back to the length
+            // calculated here in this case.
+            contentLength = contentLengthFromRange;
+          } else if (contentLength != contentLengthFromRange) {
+            // If there is a discrepancy between the Content-Length and Content-Range headers,
+            // assume the one with the larger value is correct. We have seen cases where carrier
+            // change one of them to reduce the size of a request, but it is unlikely anybody
+            // would increase it.
+            log(Log.WARN, "Inconsistent headers [" + contentLengthHeader + "] ["
+                + contentRangeHeader + "]");
+            contentLength = Math.max(contentLength, contentLengthFromRange);
+          }
+        } catch (NumberFormatException e) {
+          log(Log.ERROR, "Unexpected Content-Range [" + contentRangeHeader + "]");
+        }
+      }
+    }
+    return contentLength;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
+    TraceUtil.beginSection("CronetDataSource.read");
+    try {
+      synchronized (this) {
+        if (connectionState != OPEN_CONNECTION) {
+          throw new IllegalStateException("Connection not ready");
+        }
+      }
+
+      // If being asked to read beyond the amount of bytes initially requested, return
+      // RESULT_END_OF_INPUT.
+      if (expectedBytesRemainingToRead != null && expectedBytesRemainingToRead.get() <= 0) {
+        return C.RESULT_END_OF_INPUT;
+      }
+
+      if (!hasData) {
+        // Read more data from cronet.
+        operation.close();
+        currentUrlRequest.read(readBuffer);
+        if (!operation.block(readTimeoutMs)) {
+          throw new HttpDataSourceException(
+              new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
+        }
+        if (exception != null) {
+          throw exception;
+        }
+        // The expected response length is unknown, but cronet has indicated that the request
+        // already finished successfully.
+        if (responseFinished) {
+          return C.RESULT_END_OF_INPUT;
+        }
+      }
+
+      int bytesRead = Math.min(readBuffer.remaining(), readLength);
+
+      readBuffer.get(buffer, offset, bytesRead);
+
+      if (!readBuffer.hasRemaining()) {
+        readBuffer.clear();
+        hasData = false;
+      }
+
+      if (expectedBytesRemainingToRead != null) {
+        expectedBytesRemainingToRead.addAndGet(-bytesRead);
+      }
+
+      if (transferListener != null && bytesRead >= 0) {
+        transferListener.onBytesTransferred(bytesRead);
+      }
+      return bytesRead;
+    } finally {
+      TraceUtil.endSection();
+    }
+  }
+
+  @Override
+  public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
+    if (request != currentUrlRequest) {
+      return;
+    }
+    if (currentDataSpec.postBody != null) {
+      int responseCode = info.getHttpStatusCode();
+      // The industry standard is to disregard POST redirects when the status code is 307 or 308.
+      // For other redirect response codes the POST request is converted to a GET request and the
+      // redirect is followed.
+      if (responseCode == 307 || responseCode == 308) {
+        exception = new OpenException("POST request redirected with 307 or 308 response code",
+            currentDataSpec, getCurrentRequestStatus());
+        operation.open();
+        return;
+      }
+    }
+    if (resetTimeoutOnRedirects) {
+      resetConnectTimeout();
+    }
+    request.followRedirect();
+  }
+
+  @Override
+  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
+      ByteBuffer buffer) {
+    if (request != currentUrlRequest) {
+      return;
+    }
+    readBuffer.flip();
+    if (readBuffer.limit() > 0) {
+      hasData = true;
+    }
+    operation.open();
+  }
+
+  @Override
+  public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+    if (request != currentUrlRequest) {
+      return;
+    }
+    responseFinished = true;
+    operation.open();
+  }
+
+  @Override
+  public synchronized void close() {
+    TraceUtil.beginSection("CronetDataSource.close");
+    try {
+      if (currentUrlRequest != null) {
+        currentUrlRequest.cancel();
+        currentUrlRequest = null;
+      }
+      readBuffer.clear();
+      currentDataSpec = null;
+      currentUrl = null;
+      exception = null;
+      contentLength = 0;
+      hasData = false;
+      responseInfo = null;
+      expectedBytesRemainingToRead = null;
+      responseFinished = false;
+      if (transferListener != null && connectionState == OPEN_CONNECTION) {
+        transferListener.onTransferEnd();
+      }
+    } finally {
+      connectionState = IDLE_CONNECTION;
+      TraceUtil.endSection();
+    }
+  }
+
+  @Override
+  public String getUri() {
+    return currentUrl;
+  }
+
+  private void log(int priority, String message) {
+    if (Log.isLoggable(TAG, priority)) {
+      Log.println(priority, TAG, message);
+    }
+  }
+
+  private int getCurrentRequestStatus() {
+    if (currentUrlRequest == null) {
+      return UrlRequest.Status.IDLE;
+    }
+    final ConditionVariable conditionVariable = new ConditionVariable();
+    final AtomicInteger result = new AtomicInteger();
+    currentUrlRequest.getStatus(new UrlRequest.StatusListener() {
+      @Override
+      public void onStatus(int status) {
+        result.set(status);
+        conditionVariable.open();
+      }
+    });
+    return result.get();
+  }
+
+  private boolean blockUntilConnectTimeout() {
+    long now = clock.elapsedRealtime();
+    boolean opened = false;
+    while (!opened && now < currentConnectTimeoutMs) {
+      opened = operation.block(currentConnectTimeoutMs - now + 5 /* fudge factor */);
+      now = clock.elapsedRealtime();
+    }
+    return opened;
+  }
+
+  private void resetConnectTimeout() {
+    currentConnectTimeoutMs = clock.elapsedRealtime() + connectTimeoutMs;
+  }
+
+}
diff --git a/extensions/cronet/src/main/project.properties b/extensions/cronet/src/main/project.properties
new file mode 100644
index 0000000000..b92a03b7ab
--- /dev/null
+++ b/extensions/cronet/src/main/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
+android.library=true
+android.library.reference.1=../../../../library/src/main
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 247a7d6743..d15574c12c 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -60,7 +60,7 @@ jint JNI_OnLoad(JavaVM* vm, void* reserved) {
 
 FUNC(jlong, vpxInit) {
   vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
-  vpx_codec_dec_cfg_t cfg = {0};
+  vpx_codec_dec_cfg_t cfg = {0, 0, 0};
   cfg.threads = android_getCpuCount();
   if (vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo, &cfg, 0)) {
     LOGE("ERROR: Fail to initialize libvpx decoder.");
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 9a01254a87..b60f1be2b9 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Tue Feb 23 12:44:36 GMT 2016
+#Thu Sep 01 11:41:12 BST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/library/build.gradle b/library/build.gradle
index e1b3203c91..560b699d10 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -83,7 +83,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.10'
+    version = 'r1.5.11'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
index 9339f7c6f2..a1f80bc79b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -45,7 +45,7 @@
   public void testParcelable() {
     MediaFormat formatToParcel = new MediaFormat("id", MimeTypes.VIDEO_H264, 1024, 2048,
         C.UNKNOWN_TIME_US, 1920, 1080, 90, 2, 6, 44100, "und", MediaFormat.OFFSET_SAMPLE_RELATIVE,
-        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004);
+        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004, null, C.STEREO_MODE_TOP_BOTTOM);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 4f22c3f06f..2870680548 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -140,6 +140,21 @@
    */
   public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
 
+  /**
+   * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_MONO = 0;
+
+  /**
+   * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_TOP_BOTTOM = 1;
+
+  /**
+   * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_LEFT_RIGHT = 2;
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index 59bbe0487d..bdec60ce89 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -54,7 +54,7 @@
  * <p>The figure below shows the {@link ExoPlayer} threading model.</p>
  * <p align="center"><img src="doc-files/exoplayer-threading-model.png"
  *     alt="MediaPlayer state diagram"
- *     border="0"/></p>
+ *     border="0"></p>
  *
  * <ul>
  * <li>It is recommended that instances are created and accessed from a single application thread.
@@ -81,14 +81,14 @@
  * completing on the playback thread, as illustrated below.</p>
  * <p align="center"><img src="doc-files/exoplayer-state.png"
  *     alt="ExoPlayer state"
- *     border="0"/></p>
+ *     border="0"></p>
  *
  * <p>The possible playback state transitions are shown below. Transitions can be triggered either
  * by changes in the state of the {@link TrackRenderer}s being used, or as a result of
  * {@link #prepare(TrackRenderer[])}, {@link #stop()} or {@link #release()} being invoked.</p>
  * <p align="center"><img src="doc-files/exoplayer-playbackstate.png"
  *     alt="ExoPlayer playback state transitions"
- *     border="0"/></p>
+ *     border="0"></p>
  */
 public interface ExoPlayer {
 
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 3f002eccff..48fd78d8eb 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.10";
+  public static final String VERSION = "1.5.11";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  public static final int VERSION_INT = 1005010;
+  public static final int VERSION_INT = 1005011;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index f6e1d0cd21..b114e374e0 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -329,7 +329,8 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding);
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding,
+        null, MediaFormat.NO_VALUE);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 878aaaaf61..85fa35ccb7 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -782,6 +782,9 @@ protected void onInputFormatChanged(MediaFormatHolder formatHolder) throws ExoPl
     MediaFormat oldFormat = format;
     format = formatHolder.format;
     drmInitData = formatHolder.drmInitData;
+    if (Util.areEqual(format, oldFormat)) {
+      return;
+    }
     if (codec != null && canReconfigureCodec(codec, codecIsAdaptive, oldFormat, format)) {
       codecReconfigured = true;
       codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 2051acf48f..15c9b58f41 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -110,6 +110,18 @@
    */
   public final float pixelWidthHeightRatio;
 
+  /**
+   * The stereo layout for 360/3D/VR video, or {@link #NO_VALUE} if not applicable. Valid stereo
+   * modes are {@link C#STEREO_MODE_MONO}, {@link C#STEREO_MODE_TOP_BOTTOM}, {@link
+   * C#STEREO_MODE_LEFT_RIGHT}.
+   */
+  public final int stereoMode;
+
+  /**
+   * The projection data for 360/VR video, or null if not applicable.
+   */
+  public final byte[] projectionData;
+
   // Audio specific.
 
   /**
@@ -157,7 +169,7 @@
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
-        initializationData, NO_VALUE, NO_VALUE);
+        initializationData, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
@@ -165,7 +177,18 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
+  }
+
+  public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
+      int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData,
+      int rotationDegrees, float pixelWidthHeightRatio, byte[] projectionData,
+      int stereoMode) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        projectionData, stereoMode);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
@@ -180,7 +203,8 @@ public static MediaFormat createAudioFormat(String trackId, String mimeType, int
       List<byte[]> initializationData, String language, int pcmEncoding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -193,21 +217,22 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
       long durationUs, List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createId3Format() {
@@ -237,13 +262,17 @@ public static MediaFormat createId3Format() {
     pcmEncoding = in.readInt();
     encoderDelay = in.readInt();
     encoderPadding = in.readInt();
+    boolean hasProjectionData = in.readInt() != 0;
+    projectionData = hasProjectionData ? in.createByteArray() : null;
+    stereoMode = in.readInt();
   }
 
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
-      int pcmEncoding, int encoderDelay, int encoderPadding) {
+      int pcmEncoding, int encoderDelay, int encoderPadding, byte[] projectionData,
+      int stereoMode) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -265,41 +294,43 @@ public static MediaFormat createId3Format() {
     this.pcmEncoding = pcmEncoding;
     this.encoderDelay = encoderDelay;
     this.encoderPadding = encoderPadding;
+    this.projectionData = projectionData;
+    this.stereoMode = stereoMode;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithLanguage(String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
@@ -307,20 +338,20 @@ public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE);
+        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE, null, stereoMode);
   }
 
   public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   /**
@@ -401,6 +432,8 @@ public int hashCode() {
       for (int i = 0; i < initializationData.size(); i++) {
         result = 31 * result + Arrays.hashCode(initializationData.get(i));
       }
+      result = 31 * result + Arrays.hashCode(projectionData);
+      result = 31 * result + stereoMode;
       hashCode = result;
     }
     return hashCode;
@@ -425,7 +458,9 @@ public boolean equals(Object obj) {
         || encoderPadding != other.encoderPadding || subsampleOffsetUs != other.subsampleOffsetUs
         || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
-        || initializationData.size() != other.initializationData.size()) {
+        || initializationData.size() != other.initializationData.size()
+        || !Arrays.equals(projectionData, other.projectionData)
+        || stereoMode != other.stereoMode) {
       return false;
     }
     for (int i = 0; i < initializationData.size(); i++) {
@@ -481,6 +516,11 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeInt(pcmEncoding);
     dest.writeInt(encoderDelay);
     dest.writeInt(encoderPadding);
+    dest.writeInt(projectionData != null ? 1 : 0);
+    if (projectionData != null) {
+      dest.writeByteArray(projectionData);
+    }
+    dest.writeInt(stereoMode);
   }
 
   public static final Creator<MediaFormat> CREATOR = new Creator<MediaFormat>() {
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index fd6fc0e2d7..cf4504dc1d 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -27,7 +27,7 @@
  * transition.
  * <p align="center"><img src="doc-files/trackrenderer-states.png"
  *     alt="TrackRenderer state transitions"
- *     border="0"/></p>
+ *     border="0"></p>
  */
 public abstract class TrackRenderer implements ExoPlayerComponent {
 
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 2c4b2d6488..39c4afe9a0 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -168,7 +168,7 @@ public InvalidAudioTrackTimestampException(String message) {
 
   /**
    * Whether to enable a workaround for an issue where an audio effect does not keep its session
-   * active across releasing/initializing a new audio track, on platform API version before 21.
+   * active across releasing/initializing a new audio track, on platform API version &lt; 21.
    * <p>
    * The flag must be set before creating a player.
    */
@@ -693,10 +693,10 @@ public boolean hasPendingData() {
   }
 
   /**
-   * Sets the playback parameters. Only available for SDK_INT >= 23
+   * Sets the playback parameters. Only available for SDK_INT &gt;= 23
    *
    * @throws UnsupportedOperationException if the Playback Parameters are not supported. That is,
-   *     SDK_INT < 23.
+   *     SDK_INT &lt; 23.
    */
   public void setPlaybackParams(PlaybackParams playbackParams) {
     audioTrackUtil.setPlaybackParameters(playbackParams);
@@ -1225,7 +1225,7 @@ public long getTimestampFramePosition() {
      *
      * @param playbackParams to be used by the {@link android.media.AudioTrack}.
      * @throws UnsupportedOperationException If Playback Parameters are not supported
-     *     (i.e. SDK_INT < 23).
+     *     (i.e. SDK_INT &lt; 23).
      */
     public void setPlaybackParameters(PlaybackParams playbackParams) {
       throw new UnsupportedOperationException();
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index 69b06c611c..c6f316e84d 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -25,10 +25,12 @@
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.extractor.DefaultTrackOutput;
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.LinkedList;
@@ -85,6 +87,7 @@
   private long currentLoadableExceptionTimestamp;
   private long currentLoadStartTimeMs;
 
+  private DrmInitData downstreamDrmInitData;
   private MediaFormat downstreamMediaFormat;
   private Format downstreamFormat;
 
@@ -186,6 +189,7 @@ public void enable(int track, long positionUs) {
     loadControl.register(this, bufferSizeContribution);
     downstreamFormat = null;
     downstreamMediaFormat = null;
+    downstreamDrmInitData = null;
     downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
     pendingDiscontinuity = false;
@@ -256,17 +260,21 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
 
     if (haveSamples || currentChunk.isMediaFormatFinal) {
       MediaFormat mediaFormat = currentChunk.getMediaFormat();
-      if (!mediaFormat.equals(downstreamMediaFormat)) {
+      DrmInitData drmInitData = currentChunk.getDrmInitData();
+      if (!mediaFormat.equals(downstreamMediaFormat)
+          || (!Util.areEqual(downstreamDrmInitData, drmInitData))) {
         formatHolder.format = mediaFormat;
-        formatHolder.drmInitData = currentChunk.getDrmInitData();
+        formatHolder.drmInitData = drmInitData;
         downstreamMediaFormat = mediaFormat;
+        downstreamDrmInitData = drmInitData;
         return FORMAT_READ;
       }
       // If mediaFormat and downstreamMediaFormat are equal but different objects then the equality
       // check above will have been expensive, comparing the fields in each format. We update
       // downstreamMediaFormat here so that referential equality can be cheaply established during
-      // subsequent calls.
+      // subsequent calls. Same goes for downstreamDrmInitData.
       downstreamMediaFormat = mediaFormat;
+      downstreamDrmInitData = drmInitData;
     }
 
     if (!haveSamples) {
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
index 7529344af5..f281a5d6cb 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
@@ -31,7 +31,7 @@
 /**
  * A {@link Chunk} that uses an {@link Extractor} to parse initialization data for single track.
  */
-public final class InitializationChunk extends Chunk implements SingleTrackOutput {
+public class InitializationChunk extends Chunk implements SingleTrackOutput {
 
   private final ChunkExtractorWrapper extractorWrapper;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index 49820b1a7e..9cacbc5721 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -15,18 +15,12 @@
  */
 package com.google.android.exoplayer.chunk;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.Point;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.Display;
-import android.view.WindowManager;
 import com.google.android.exoplayer.MediaCodecUtil;
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -35,8 +29,6 @@
  */
 public final class VideoFormatSelectorUtil {
 
-  private static final String TAG = "VideoFormatSelectorUtil";
-
   /**
    * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
    * corresponding viewport dimension, then the video is considered as filling the viewport (in that
@@ -59,7 +51,7 @@
   public static int[] selectVideoFormatsForDefaultDisplay(Context context,
       List<? extends FormatWrapper> formatWrappers, String[] allowedContainerMimeTypes,
       boolean filterHdFormats) throws DecoderQueryException {
-    Point viewportSize = getDisplaySize(context); // Assume the viewport is fullscreen.
+    Point viewportSize = Util.getPhysicalDisplaySize(context); // Assume the viewport is fullscreen.
     return selectVideoFormats(formatWrappers, allowedContainerMimeTypes, filterHdFormats, true,
         false, viewportSize.x, viewportSize.y);
   }
@@ -199,81 +191,6 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int
     }
   }
 
-  private static Point getDisplaySize(Context context) {
-    // Before API 25 the platform Display object does not provide a working way to identify Android
-    // TVs that can show 4k resolution in a SurfaceView, so check for supported devices here.
-    if (Util.SDK_INT < 25) {
-      if ("Sony".equals(Util.MANUFACTURER) && Util.MODEL != null && Util.MODEL.startsWith("BRAVIA")
-          && context.getPackageManager().hasSystemFeature("com.sony.dtv.hardware.panel.qfhd")) {
-        return new Point(3840, 2160);
-      } else if ("NVIDIA".equals(Util.MANUFACTURER) && Util.MODEL != null
-          && Util.MODEL.contains("SHIELD")) {
-        // Attempt to read sys.display-size.
-        String sysDisplaySize = null;
-        try {
-          Class<?> systemProperties = Class.forName("android.os.SystemProperties");
-          Method getMethod = systemProperties.getMethod("get", String.class);
-          sysDisplaySize = (String) getMethod.invoke(systemProperties, "sys.display-size");
-        } catch (Exception e) {
-          Log.e(TAG, "Failed to read sys.display-size", e);
-        }
-        // If we managed to read sys.display-size, attempt to parse it.
-        if (!TextUtils.isEmpty(sysDisplaySize)) {
-          try {
-            String[] sysDisplaySizeParts = sysDisplaySize.trim().split("x");
-            if (sysDisplaySizeParts.length == 2) {
-              int width = Integer.parseInt(sysDisplaySizeParts[0]);
-              int height = Integer.parseInt(sysDisplaySizeParts[1]);
-              if (width > 0 && height > 0) {
-                return new Point(width, height);
-              }
-            }
-          } catch (NumberFormatException e) {
-            // Do nothing.
-          }
-          Log.e(TAG, "Invalid sys.display-size: " + sysDisplaySize);
-        }
-      }
-    }
-
-    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    Display display = windowManager.getDefaultDisplay();
-    Point displaySize = new Point();
-    if (Util.SDK_INT >= 23) {
-      getDisplaySizeV23(display, displaySize);
-    } else if (Util.SDK_INT >= 17) {
-      getDisplaySizeV17(display, displaySize);
-    } else if (Util.SDK_INT >= 16) {
-      getDisplaySizeV16(display, displaySize);
-    } else {
-      getDisplaySizeV9(display, displaySize);
-    }
-    return displaySize;
-  }
-
-  @TargetApi(23)
-  private static void getDisplaySizeV23(Display display, Point outSize) {
-    Display.Mode mode = display.getMode();
-    outSize.x = mode.getPhysicalWidth();
-    outSize.y = mode.getPhysicalHeight();
-  }
-
-  @TargetApi(17)
-  private static void getDisplaySizeV17(Display display, Point outSize) {
-    display.getRealSize(outSize);
-  }
-
-  @TargetApi(16)
-  private static void getDisplaySizeV16(Display display, Point outSize) {
-    display.getSize(outSize);
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void getDisplaySizeV9(Display display, Point outSize) {
-    outSize.x = display.getWidth();
-    outSize.y = display.getHeight();
-  }
-
   private VideoFormatSelectorUtil() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 63bf568596..53f5d99b1b 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -496,7 +496,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
           : startingNewPeriod ? representationHolder.getFirstAvailableSegmentNum()
           : queue.get(out.queueSize - 1).getNextChunkIndex();
     Chunk nextMediaChunk = newMediaChunk(periodHolder, representationHolder, dataSource,
-        mediaFormat, enabledTrack, segmentNum, evaluation.trigger);
+        mediaFormat, enabledTrack, segmentNum, evaluation.trigger, mediaFormat != null);
     lastChunkWasInitialization = false;
     out.chunk = nextMediaChunk;
   }
@@ -696,7 +696,8 @@ private Chunk newInitializationChunk(RangedUri initializationUri, RangedUri inde
 
   protected Chunk newMediaChunk(
       PeriodHolder periodHolder, RepresentationHolder representationHolder, DataSource dataSource,
-      MediaFormat mediaFormat, ExposedTrack enabledTrack, int segmentNum, int trigger) {
+      MediaFormat mediaFormat, ExposedTrack enabledTrack, int segmentNum, int trigger,
+      boolean isMediaFormatFinal) {
     Representation representation = representationHolder.representation;
     Format format = representation.format;
     long startTimeUs = representationHolder.getSegmentStartTimeUs(segmentNum);
@@ -711,7 +712,6 @@ protected Chunk newMediaChunk(
           startTimeUs, endTimeUs, segmentNum, enabledTrack.trackFormat, null,
           periodHolder.localIndex);
     } else {
-      boolean isMediaFormatFinal = (mediaFormat != null);
       return new ContainerMediaChunk(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs,
           segmentNum, sampleOffsetUs, representationHolder.extractorWrapper, mediaFormat,
           enabledTrack.adaptiveMaxWidth, enabledTrack.adaptiveMaxHeight, periodHolder.drmInitData,
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
index 961906ba86..94e4b2a57a 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
@@ -17,6 +17,7 @@
 
 import android.media.MediaDrm;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
@@ -33,7 +34,7 @@
    * @param schemeUuid The DRM scheme's UUID.
    * @return The initialization data for the scheme, or null if the scheme is not supported.
    */
-  public abstract SchemeInitData get(UUID schemeUuid);
+  public SchemeInitData get(UUID schemeUuid);
 
   /**
    * A {@link DrmInitData} implementation that maps UUID onto scheme specific data.
@@ -61,6 +62,28 @@ public void put(UUID schemeUuid, SchemeInitData schemeInitData) {
       schemeData.put(schemeUuid, schemeInitData);
     }
 
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      }
+      Mapped rhs = (Mapped) obj;
+      if (schemeData.size() != rhs.schemeData.size()) {
+        return false;
+      }
+      for (UUID uuid : schemeData.keySet()) {
+        if (!Util.areEqual(schemeData.get(uuid), rhs.schemeData.get(uuid))) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return schemeData.hashCode();
+    }
+
   }
 
   /**
@@ -79,6 +102,19 @@ public SchemeInitData get(UUID schemeUuid) {
       return data;
     }
 
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      } else {
+        return Util.areEqual(data, ((Universal) obj).data);
+      }
+    }
+
+    @Override
+    public int hashCode() {
+      return data.hashCode();
+    }
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/ExoMediaDrm.java b/library/src/main/java/com/google/android/exoplayer/drm/ExoMediaDrm.java
index e5596907b9..30855dfb86 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/ExoMediaDrm.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/ExoMediaDrm.java
@@ -99,17 +99,17 @@ KeyRequest getKeyRequest(byte[] scope, byte[] init, String mimeType, int keyType
   void provideProvisionResponse(byte[] response) throws DeniedByServerException;
 
   /**
-   * @see android.media.MediaDrm#queryKeyStatus(byte[]).
+   * @see android.media.MediaDrm#queryKeyStatus(byte[])
    */
   Map<String, String> queryKeyStatus(byte[] sessionId);
 
   /**
-   * @see android.media.MediaDrm#release().
+   * @see android.media.MediaDrm#release()
    */
   void release();
 
   /**
-   * @see android.media.MediaDrm#restoreKeys(byte[], byte[]).
+   * @see android.media.MediaDrm#restoreKeys(byte[], byte[])
    */
   void restoreKeys(byte[] sessionId, byte[] keySetId);
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 938b1e3b86..67f6bbf516 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -126,6 +126,9 @@
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
   public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
+  public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
+  public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
+  public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
   public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 4fa1132937..63564ba245 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -614,6 +615,8 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     List<byte[]> initializationData = null;
     String mimeType = null;
+    byte[] projectionData = null;
+    int stereoMode = MediaFormat.NO_VALUE;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
       int childStartPosition = parent.getPosition();
@@ -654,6 +657,27 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
       } else if (childAtomType == Atom.TYPE_vpcC) {
         Assertions.checkState(mimeType == null);
         mimeType = (atomType == Atom.TYPE_vp08) ? MimeTypes.VIDEO_VP8 : MimeTypes.VIDEO_VP9;
+      } else if (childAtomType == Atom.TYPE_sv3d) {
+        projectionData = parseProjFromParent(parent, childStartPosition, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_st3d) {
+        int version = parent.readUnsignedByte();
+        parent.skipBytes(3); // Flags.
+        if (version == 0) {
+          int layout = parent.readUnsignedByte();
+          switch (layout) {
+            case 0:
+              stereoMode = C.STEREO_MODE_MONO;
+              break;
+            case 1:
+              stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+              break;
+            case 2:
+              stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+              break;
+            default:
+              break;
+          }
+        }
       }
       childPosition += childAtomSize;
     }
@@ -665,7 +689,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     out.mediaFormat = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
         MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, width, height, initializationData,
-        rotationDegrees, pixelWidthHeightRatio);
+        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode);
   }
 
   private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int position) {
@@ -1059,6 +1083,23 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
     return null;
   }
 
+
+  /** Parses the proj box from sv3d box, as specified by https://github.com/google/spatial-media */
+  private static byte[] parseProjFromParent(ParsableByteArray parent, int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_proj) {
+        return Arrays.copyOfRange(parent.data, childPosition, childPosition + childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+
   /**
    * Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 4b9277ee85..569fc1d1cf 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -318,26 +318,8 @@ private void onContainerAtomRead(ContainerAtom container) throws ParserException
 
   private void onMoovContainerAtomRead(ContainerAtom moov) {
     Assertions.checkState(sideloadedTrack == null, "Unexpected moov box.");
-    List<Atom.LeafAtom> moovLeafChildren = moov.leafChildren;
-    int moovLeafChildrenSize = moovLeafChildren.size();
 
-    DrmInitData.Mapped drmInitData = null;
-    for (int i = 0; i < moovLeafChildrenSize; i++) {
-      LeafAtom child = moovLeafChildren.get(i);
-      if (child.type == Atom.TYPE_pssh) {
-        if (drmInitData == null) {
-          drmInitData = new DrmInitData.Mapped();
-        }
-        byte[] psshData = child.data.data;
-        UUID uuid = PsshAtomUtil.parseUuid(psshData);
-        if (uuid == null) {
-          Log.w(TAG, "Skipped pssh atom (failed to extract uuid)");
-        } else {
-          drmInitData.put(PsshAtomUtil.parseUuid(psshData),
-              new SchemeInitData(MimeTypes.VIDEO_MP4, psshData));
-        }
-      }
-    }
+    DrmInitData.Mapped drmInitData = getDrmInitDataFromAtoms(moov.leafChildren);
     if (drmInitData != null) {
       extractorOutput.drmInitData(drmInitData);
     }
@@ -391,6 +373,10 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
 
   private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
     parseMoof(moof, trackBundles, flags, extendedTypeScratch);
+    DrmInitData.Mapped drmInitData = getDrmInitDataFromAtoms(moof.leafChildren);
+    if (drmInitData != null) {
+      extractorOutput.drmInitData(drmInitData);
+    }
   }
 
   /**
@@ -1029,6 +1015,29 @@ private int appendSampleEncryptionData(TrackBundle trackBundle) {
     return 1 + vectorSize + subsampleDataLength;
   }
 
+  /** Returns DrmInitData from leaf atoms. */
+  private static DrmInitData.Mapped getDrmInitDataFromAtoms(List<Atom.LeafAtom> leafChildren) {
+    DrmInitData.Mapped drmInitData = null;
+    int leafChildrenSize = leafChildren.size();
+    for (int i = 0; i < leafChildrenSize; i++) {
+      LeafAtom child = leafChildren.get(i);
+      if (child.type == Atom.TYPE_pssh) {
+        if (drmInitData == null) {
+          drmInitData = new DrmInitData.Mapped();
+        }
+        byte[] psshData = child.data.data;
+        UUID uuid = PsshAtomUtil.parseUuid(psshData);
+        if (uuid == null) {
+          Log.w(TAG, "Skipped pssh atom (failed to extract uuid)");
+        } else {
+          drmInitData.put(PsshAtomUtil.parseUuid(psshData),
+              new SchemeInitData(MimeTypes.VIDEO_MP4, psshData));
+        }
+      }
+    }
+    return drmInitData;
+  }
+
   /** Returns whether the extractor should parse a leaf atom with type {@code atom}. */
   private static boolean shouldParseLeafAtom(int atom) {
     return atom == Atom.TYPE_hdlr || atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 8fab023188..6487829d3b 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -18,6 +18,7 @@
 import android.util.Log;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+import android.util.SparseIntArray;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.extractor.DummyTrackOutput;
 import com.google.android.exoplayer.extractor.Extractor;
@@ -25,6 +26,7 @@
 import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
@@ -39,6 +41,7 @@
   public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
   public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
   public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
+  public static final int WORKAROUND_MAP_BY_TYPE = 16;
 
   private static final String TAG = "TsExtractor";
 
@@ -57,21 +60,26 @@
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
   private static final int TS_STREAM_TYPE_H265 = 0x24;
   private static final int TS_STREAM_TYPE_ID3 = 0x15;
-  private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1
+  private static final int BASE_EMBEDDED_TRACK_ID = 0x2000; // Max PID + 1.
 
   private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
   private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
   private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
 
+  private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
+  private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
+
   private final PtsTimestampAdjuster ptsTimestampAdjuster;
   private final int workaroundFlags;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
+  private final SparseIntArray continuityCounters;
   /* package */ final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-  /* package */ final SparseBooleanArray streamTypes;
+  /* package */ final SparseBooleanArray trackIds;
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
+  private int nextEmbeddedTrackId;
   /* package */ Id3Reader id3Reader;
 
   public TsExtractor() {
@@ -85,26 +93,33 @@ public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster) {
   public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, int workaroundFlags) {
     this.ptsTimestampAdjuster = ptsTimestampAdjuster;
     this.workaroundFlags = workaroundFlags;
-    tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
+    tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
     tsPayloadReaders = new SparseArray<>();
     tsPayloadReaders.put(TS_PAT_PID, new PatReader());
-    streamTypes = new SparseBooleanArray();
+    trackIds = new SparseBooleanArray();
+    nextEmbeddedTrackId = BASE_EMBEDDED_TRACK_ID;
+    continuityCounters = new SparseIntArray();
   }
 
   // Extractor implementation.
 
   @Override
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    byte[] scratch = new byte[1];
-    for (int i = 0; i < 5; i++) {
-      input.peekFully(scratch, 0, 1);
-      if ((scratch[0] & 0xFF) != 0x47) {
-        return false;
+    byte[] buffer = tsPacketBuffer.data;
+    input.peekFully(buffer, 0, BUFFER_SIZE);
+    for (int j = 0; j < TS_PACKET_SIZE; j++) {
+      for (int i = 0; true; i++) {
+        if (i == BUFFER_PACKET_COUNT) {
+          input.skipFully(j);
+          return true;
+        }
+        if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+          break;
+        }
       }
-      input.advancePeekPosition(TS_PACKET_SIZE - 1);
     }
-    return true;
+    return false;
   }
 
   @Override
@@ -119,6 +134,8 @@ public void seek() {
     for (int i = 0; i < tsPayloadReaders.size(); i++) {
       tsPayloadReaders.valueAt(i).seek();
     }
+    tsPacketBuffer.reset();
+    continuityCounters.clear();
   }
 
   @Override
@@ -129,28 +146,63 @@ public void release() {
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    if (!input.readFully(tsPacketBuffer.data, 0, TS_PACKET_SIZE, true)) {
-      return RESULT_END_OF_INPUT;
+    byte[] data = tsPacketBuffer.data;
+    // Shift bytes to the start of the buffer if there isn't enough space left at the end
+    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
+      int bytesLeft = tsPacketBuffer.bytesLeft();
+      if (bytesLeft > 0) {
+        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+      }
+      tsPacketBuffer.reset(data, bytesLeft);
+    }
+    // Read more bytes until there is at least one packet size
+    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
+      int limit = tsPacketBuffer.limit();
+      int read = input.read(data, limit, BUFFER_SIZE - limit);
+      if (read == C.RESULT_END_OF_INPUT) {
+        return RESULT_END_OF_INPUT;
+      }
+      tsPacketBuffer.setLimit(limit + read);
     }
 
     // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
     // the header.
-    tsPacketBuffer.setPosition(0);
-    tsPacketBuffer.setLimit(TS_PACKET_SIZE);
-    int syncByte = tsPacketBuffer.readUnsignedByte();
-    if (syncByte != TS_SYNC_BYTE) {
+    final int limit = tsPacketBuffer.limit();
+    int position = tsPacketBuffer.getPosition();
+    while (position < limit && data[position] != TS_SYNC_BYTE) {
+      position++;
+    }
+    tsPacketBuffer.setPosition(position);
+
+    int endOfPacket = position + TS_PACKET_SIZE;
+    if (endOfPacket > limit) {
       return RESULT_CONTINUE;
     }
 
+    tsPacketBuffer.skipBytes(1);
     tsPacketBuffer.readBytes(tsScratch, 3);
-    tsScratch.skipBits(1); // transport_error_indicator
+    if (tsScratch.readBit()) { // transport_error_indicator
+      // There are uncorrectable errors in this packet.
+      tsPacketBuffer.setPosition(endOfPacket);
+      return RESULT_CONTINUE;
+    }
     boolean payloadUnitStartIndicator = tsScratch.readBit();
     tsScratch.skipBits(1); // transport_priority
     int pid = tsScratch.readBits(13);
     tsScratch.skipBits(2); // transport_scrambling_control
     boolean adaptationFieldExists = tsScratch.readBit();
     boolean payloadExists = tsScratch.readBit();
-    // Last 4 bits of scratch are skipped: continuity_counter
+    boolean discontinuityFound = false;
+    int continuityCounter = tsScratch.readBits(4);
+    int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+    continuityCounters.put(pid, continuityCounter);
+    if (previousCounter == continuityCounter) {
+      // Duplicate packet found.
+      tsPacketBuffer.setPosition(endOfPacket);
+      return RESULT_CONTINUE;
+    } else if (continuityCounter != (previousCounter + 1) % 16) {
+      discontinuityFound = true;
+    }
 
     // Skip the adaptation field.
     if (adaptationFieldExists) {
@@ -162,10 +214,17 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (payloadExists) {
       TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
       if (payloadReader != null) {
+        if (discontinuityFound) {
+          payloadReader.seek();
+        }
+        tsPacketBuffer.setLimit(endOfPacket);
         payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator, output);
+        Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
+        tsPacketBuffer.setLimit(limit);
       }
     }
 
+    tsPacketBuffer.setPosition(endOfPacket);
     return RESULT_CONTINUE;
   }
 
@@ -202,9 +261,15 @@ public abstract void consume(ParsableByteArray data, boolean payloadUnitStartInd
    */
   private class PatReader extends TsPayloadReader {
 
+    private final ParsableByteArray sectionData;
     private final ParsableBitArray patScratch;
 
+    private int sectionLength;
+    private int sectionBytesRead;
+    private int crc;
+
     public PatReader() {
+      sectionData = new ParsableByteArray();
       patScratch = new ParsableBitArray(new byte[4]);
     }
 
@@ -220,18 +285,38 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       if (payloadUnitStartIndicator) {
         int pointerField = data.readUnsignedByte();
         data.skipBytes(pointerField);
+
+        // Note: see ISO/IEC 13818-1, section 2.4.4.3 for detailed information on the format of
+        // the header.
+        data.readBytes(patScratch, 3);
+        patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), 0 (1), reserved (2)
+        sectionLength = patScratch.readBits(12);
+        sectionBytesRead = 0;
+        crc = Util.crc(patScratch.data, 0, 3, 0xFFFFFFFF);
+
+        sectionData.reset(sectionLength);
+      }
+
+      int bytesToRead = Math.min(data.bytesLeft(), sectionLength - sectionBytesRead);
+      data.readBytes(sectionData.data, sectionBytesRead, bytesToRead);
+      sectionBytesRead += bytesToRead;
+      if (sectionBytesRead < sectionLength) {
+        // Not yet fully read.
+        return;
+      }
+
+      if (Util.crc(sectionData.data, 0, sectionLength, crc) != 0) {
+        // CRC Invalid. The section gets discarded.
+        return;
       }
 
-      data.readBytes(patScratch, 3);
-      patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
-      int sectionLength = patScratch.readBits(12);
       // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8)
-      data.skipBytes(5);
+      sectionData.skipBytes(5);
 
       int programCount = (sectionLength - 9) / 4;
       for (int i = 0; i < programCount; i++) {
-        data.readBytes(patScratch, 4);
+        sectionData.readBytes(patScratch, 4);
         int programNumber = patScratch.readBits(16);
         patScratch.skipBits(3); // reserved (3)
         if (programNumber == 0) {
@@ -257,6 +342,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
 
     private int sectionLength;
     private int sectionBytesRead;
+    private int crc;
 
     public PmtReader() {
       pmtScratch = new ParsableBitArray(new byte[5]);
@@ -281,13 +367,10 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         data.readBytes(pmtScratch, 3);
         pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), 0 (1), reserved (2)
         sectionLength = pmtScratch.readBits(12);
+        sectionBytesRead = 0;
+        crc = Util.crc(pmtScratch.data, 0, 3, 0xFFFFFFFF);
 
-        if (sectionData.capacity() < sectionLength) {
-          sectionData.reset(new byte[sectionLength], sectionLength);
-        } else {
-          sectionData.reset();
-          sectionData.setLimit(sectionLength);
-        }
+        sectionData.reset(sectionLength);
       }
 
       int bytesToRead = Math.min(data.bytesLeft(), sectionLength - sectionBytesRead);
@@ -298,6 +381,11 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         return;
       }
 
+      if (Util.crc(sectionData.data, 0, sectionLength, crc) != 0) {
+        // CRC Invalid. The section gets discarded.
+        return;
+      }
+
       // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
       // Skip the rest of the PMT header.
@@ -311,7 +399,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if (id3Reader == null) {
+      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See b/20261500.
         id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
@@ -333,48 +421,52 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           sectionData.skipBytes(esInfoLength);
         }
         remainingEntriesLength -= esInfoLength + 5;
-        if (streamTypes.get(streamType)) {
+        int trackId = (workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 ? streamType : elementaryPid;
+        if (trackIds.get(trackId)) {
           continue;
         }
-
         ElementaryStreamReader pesPayloadReader;
         switch (streamType) {
           case TS_STREAM_TYPE_MPA:
-            pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA));
+            pesPayloadReader = new MpegAudioReader(output.track(trackId));
             break;
           case TS_STREAM_TYPE_MPA_LSF:
-            pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA_LSF));
+            pesPayloadReader = new MpegAudioReader(output.track(trackId));
             break;
           case TS_STREAM_TYPE_AAC:
             pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_AAC_STREAM) != 0 ? null
-                : new AdtsReader(output.track(TS_STREAM_TYPE_AAC), new DummyTrackOutput());
+                : new AdtsReader(output.track(trackId), new DummyTrackOutput());
             break;
           case TS_STREAM_TYPE_AC3:
-            pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_AC3), false);
+            pesPayloadReader = new Ac3Reader(output.track(trackId), false);
             break;
           case TS_STREAM_TYPE_E_AC3:
-            pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_E_AC3), true);
+            pesPayloadReader = new Ac3Reader(output.track(trackId), true);
             break;
           case TS_STREAM_TYPE_DTS:
           case TS_STREAM_TYPE_HDMV_DTS:
-            pesPayloadReader = new DtsReader(output.track(TS_STREAM_TYPE_DTS));
+            pesPayloadReader = new DtsReader(output.track(trackId));
             break;
           case TS_STREAM_TYPE_H262:
-            pesPayloadReader = new H262Reader(output.track(TS_STREAM_TYPE_H262));
+            pesPayloadReader = new H262Reader(output.track(trackId));
             break;
           case TS_STREAM_TYPE_H264:
             pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_H264_STREAM) != 0 ? null
-                : new H264Reader(output.track(TS_STREAM_TYPE_H264),
-                    new SeiReader(output.track(TS_STREAM_TYPE_EIA608)),
+                : new H264Reader(output.track(trackId),
+                    new SeiReader(output.track(nextEmbeddedTrackId++)),
                     (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0,
                     (workaroundFlags & WORKAROUND_DETECT_ACCESS_UNITS) != 0);
             break;
           case TS_STREAM_TYPE_H265:
-            pesPayloadReader = new H265Reader(output.track(TS_STREAM_TYPE_H265),
-                new SeiReader(output.track(TS_STREAM_TYPE_EIA608)));
+            pesPayloadReader = new H265Reader(output.track(trackId),
+                new SeiReader(output.track(nextEmbeddedTrackId++)));
             break;
           case TS_STREAM_TYPE_ID3:
-            pesPayloadReader = id3Reader;
+            if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+              pesPayloadReader = id3Reader;
+            } else {
+              pesPayloadReader = new Id3Reader(output.track(nextEmbeddedTrackId++));
+            }
             break;
           default:
             pesPayloadReader = null;
@@ -382,7 +474,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         }
 
         if (pesPayloadReader != null) {
-          streamTypes.put(streamType, true);
+          trackIds.put(trackId, true);
           tsPayloadReaders.put(elementaryPid,
               new PesReader(pesPayloadReader, ptsTimestampAdjuster));
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 08dccdf215..c95deab41a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -214,6 +214,9 @@
   private final ParsableByteArray seekEntryIdBytes;
   private final ParsableByteArray sampleStrippedBytes;
   private final ParsableByteArray subripSample;
+  private final ParsableByteArray encryptionInitializationVector;
+  private final ParsableByteArray encryptionSubsampleData;
+  private ByteBuffer encryptionSubsampleDataBuffer;
 
   private long segmentContentPosition = UNKNOWN;
   private long segmentContentSize = UNKNOWN;
@@ -255,6 +258,11 @@
   // Sample reading state.
   private int sampleBytesRead;
   private boolean sampleEncodingHandled;
+  private boolean sampleSignalByteRead;
+  private boolean sampleInitializationVectorRead;
+  private boolean samplePartitionCountRead;
+  private byte sampleSignalByte;
+  private int samplePartitionCount;
   private int sampleCurrentNalBytesRemaining;
   private int sampleBytesWritten;
   private boolean sampleRead;
@@ -279,6 +287,8 @@ public WebmExtractor() {
     nalLength = new ParsableByteArray(4);
     sampleStrippedBytes = new ParsableByteArray();
     subripSample = new ParsableByteArray();
+    encryptionInitializationVector = new ParsableByteArray(ENCRYPTION_IV_SIZE);
+    encryptionSubsampleData = new ParsableByteArray();
   }
 
   @Override
@@ -839,6 +849,11 @@ private void resetSample() {
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
     sampleEncodingHandled = false;
+    sampleSignalByteRead = false;
+    samplePartitionCountRead = false;
+    samplePartitionCount = 0;
+    sampleSignalByte = (byte) 0;
+    sampleInitializationVectorRead = false;
     sampleStrippedBytes.reset();
   }
 
@@ -882,17 +897,85 @@ private void writeSampleData(ExtractorInput input, Track track, int size)
         // If the sample is encrypted, read its encryption signal byte and set the IV size.
         // Clear the encrypted flag.
         blockFlags &= ~C.SAMPLE_FLAG_ENCRYPTED;
-        input.readFully(scratch.data, 0, 1);
-        sampleBytesRead++;
-        if ((scratch.data[0] & 0x80) == 0x80) {
-          throw new ParserException("Extension bit is set in signal byte");
+        if (!sampleSignalByteRead) {
+          input.readFully(scratch.data, 0, 1);
+          sampleBytesRead++;
+          if ((scratch.data[0] & 0x80) == 0x80) {
+            throw new ParserException("Extension bit is set in signal byte");
+          }
+          sampleSignalByte = scratch.data[0];
+          sampleSignalByteRead = true;
         }
-        if ((scratch.data[0] & 0x01) == 0x01) {
-          scratch.data[0] = (byte) ENCRYPTION_IV_SIZE;
-          scratch.setPosition(0);
-          output.sampleData(scratch, 1);
-          sampleBytesWritten++;
+        boolean isEncrypted = (sampleSignalByte & 0x01) == 0x01;
+        if (isEncrypted) {
+          boolean hasSubsampleEncryption = (sampleSignalByte & 0x02) == 0x02;
           blockFlags |= C.SAMPLE_FLAG_ENCRYPTED;
+          if (!sampleInitializationVectorRead) {
+            input.readFully(encryptionInitializationVector.data, 0, ENCRYPTION_IV_SIZE);
+            sampleBytesRead += ENCRYPTION_IV_SIZE;
+            sampleInitializationVectorRead = true;
+            // Write the signal byte, containing the IV size and the subsample encryption flag.
+            scratch.data[0] = (byte) (ENCRYPTION_IV_SIZE | (hasSubsampleEncryption ? 0x80 : 0x00));
+            scratch.setPosition(0);
+            output.sampleData(scratch, 1);
+            sampleBytesWritten++;
+            // Write the IV.
+            encryptionInitializationVector.setPosition(0);
+            output.sampleData(encryptionInitializationVector, ENCRYPTION_IV_SIZE);
+            sampleBytesWritten += ENCRYPTION_IV_SIZE;
+          }
+          if (hasSubsampleEncryption) {
+            if (!samplePartitionCountRead) {
+              input.readFully(scratch.data, 0, 1);
+              sampleBytesRead++;
+              scratch.setPosition(0);
+              samplePartitionCount = scratch.readUnsignedByte();
+              samplePartitionCountRead = true;
+            }
+            int samplePartitionDataSize = samplePartitionCount * 4;
+            if (scratch.limit() < samplePartitionDataSize) {
+              scratch.reset(new byte[samplePartitionDataSize], samplePartitionDataSize);
+            }
+            input.readFully(scratch.data, 0, samplePartitionDataSize);
+            sampleBytesRead += samplePartitionDataSize;
+            scratch.setPosition(0);
+            scratch.setLimit(samplePartitionDataSize);
+            short subsampleCount = (short) (1 + (samplePartitionCount / 2));
+            int subsampleDataSize = 2 + 6 * subsampleCount;
+            if (encryptionSubsampleDataBuffer == null
+                || encryptionSubsampleDataBuffer.capacity() < subsampleDataSize) {
+              encryptionSubsampleDataBuffer = ByteBuffer.allocate(subsampleDataSize);
+            }
+            encryptionSubsampleDataBuffer.position(0);
+            encryptionSubsampleDataBuffer.putShort(subsampleCount);
+            // Loop through the partition offsets and write out the data in the way ExoPlayer
+            // wants it (ISO 23001-7 Part 7):
+            //   2 bytes - sub sample count.
+            //   for each sub sample:
+            //     2 bytes - clear data size.
+            //     4 bytes - encrypted data size.
+            int partitionOffset = 0;
+            for (int i = 0; i < samplePartitionCount; i++) {
+              int previousPartitionOffset = partitionOffset;
+              partitionOffset = scratch.readUnsignedIntToInt();
+              if ((i % 2) == 0) {
+                encryptionSubsampleDataBuffer.putShort(
+                    (short) (partitionOffset - previousPartitionOffset));
+              } else {
+                encryptionSubsampleDataBuffer.putInt(partitionOffset - previousPartitionOffset);
+              }
+            }
+            int finalPartitionSize = size - sampleBytesRead - partitionOffset;
+            if ((samplePartitionCount % 2) == 1) {
+              encryptionSubsampleDataBuffer.putInt(finalPartitionSize);
+            } else {
+              encryptionSubsampleDataBuffer.putShort((short) finalPartitionSize);
+              encryptionSubsampleDataBuffer.putInt(0);
+            }
+            encryptionSubsampleData.reset(encryptionSubsampleDataBuffer.array(), subsampleDataSize);
+            output.sampleData(encryptionSubsampleData, subsampleDataSize);
+            sampleBytesWritten += subsampleDataSize;
+          }
         }
       } else if (track.sampleStrippedBytes != null) {
         // If the sample has header stripping, prepare to read/output the stripped bytes first.
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index d3ebf79e91..df981d6683 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -513,7 +513,8 @@ public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
         // The master source has yet to instantiate an adjuster for the discontinuity sequence.
         return;
       }
-      int workaroundFlags = 0;
+      // This flag ensures the change of pid between streams does not affect the sample queues.
+      int workaroundFlags = TsExtractor.WORKAROUND_MAP_BY_TYPE;
       String codecs = format.codecs;
       if (!TextUtils.isEmpty(codecs)) {
         // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index 0225d4f0e7..888e7d4a0a 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -547,11 +547,11 @@ private void buildTracks(HlsExtractorWrapper extractor) {
     int trackIndex = 0;
     for (int i = 0; i < extractorTrackCount; i++) {
       MediaFormat format = extractor.getMediaFormat(i).copyWithDurationUs(durationUs);
-      String language = null;
+      String muxedLanguage = null;
       if (MimeTypes.isAudio(format.mimeType)) {
-        language = chunkSource.getMuxedAudioLanguage();
+        muxedLanguage = chunkSource.getMuxedAudioLanguage();
       } else if (MimeTypes.APPLICATION_EIA608.equals(format.mimeType)) {
-        language = chunkSource.getMuxedCaptionLanguage();
+        muxedLanguage = chunkSource.getMuxedCaptionLanguage();
       }
       if (i == primaryExtractorTrackIndex) {
         for (int j = 0; j < chunkSourceTrackCount; j++) {
@@ -559,12 +559,12 @@ private void buildTracks(HlsExtractorWrapper extractor) {
           chunkSourceTrackIndices[trackIndex] = j;
           Variant fixedTrackVariant = chunkSource.getFixedTrackVariant(j);
           trackFormats[trackIndex++] = fixedTrackVariant == null ? format.copyAsAdaptive(null)
-              : copyWithFixedTrackInfo(format, fixedTrackVariant.format, language);
+              : copyWithFixedTrackInfo(format, fixedTrackVariant.format, muxedLanguage);
         }
       } else {
         extractorTrackIndices[trackIndex] = i;
         chunkSourceTrackIndices[trackIndex] = -1;
-        trackFormats[trackIndex++] = format.copyWithLanguage(language);
+        trackFormats[trackIndex++] = format.copyWithLanguage(muxedLanguage);
       }
     }
   }
@@ -590,14 +590,14 @@ private void setTrackEnabledState(int track, boolean enabledState) {
    *
    * @param format The {@link MediaFormat} to copy.
    * @param fixedTrackFormat The {@link Format} to incorporate into the copy.
-   * @param languageOverride The language to incorporate into the copy.
+   * @param muxedLanguage The muxed language as declared by the playlist.
    * @return The copied {@link MediaFormat}.
    */
   private static MediaFormat copyWithFixedTrackInfo(MediaFormat format, Format fixedTrackFormat,
-      String languageOverride) {
+      String muxedLanguage) {
     int width = fixedTrackFormat.width == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.width;
     int height = fixedTrackFormat.height == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.height;
-    String language = languageOverride == null ? fixedTrackFormat.language : languageOverride;
+    String language = fixedTrackFormat.language == null ? muxedLanguage : fixedTrackFormat.language;
     return format.copyWithFixedTrackInfo(fixedTrackFormat.id, fixedTrackFormat.bitrate, width,
         height, language);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
index 1596abe777..e9ffdb4a88 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataParser.java
@@ -33,11 +33,11 @@
   public boolean canParse(String mimeType);
 
   /**
-   * Parses metadata objects of type <T> from the provided binary data.
+   * Parses a metadata object from the provided binary data.
    *
    * @param data The raw binary data from which to parse the metadata.
    * @param size The size of the input data.
-   * @return @return A parsed metadata object of type <T>.
+   * @return @return A parsed metadata object.
    * @throws ParserException If a problem occurred parsing the data.
    */
   public T parse(byte[] data, int size) throws ParserException;
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
index d9b335fbe3..7919a814d4 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/id3/Id3Parser.java
@@ -97,7 +97,7 @@ private static int indexOfEos(byte[] data, int fromIndex, int encoding) {
 
     // Otherwise look for a second zero byte.
     while (terminationPos < data.length - 1) {
-      if (data[terminationPos + 1] == (byte) 0) {
+      if (terminationPos % 2 == 0 && data[terminationPos + 1] == (byte) 0) {
         return terminationPos;
       }
       terminationPos = indexOfZeroByte(data, terminationPos + 1);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
index 64de7b4aef..e037689b81 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
@@ -43,6 +43,7 @@ public ContentDataSourceException(IOException cause) {
   private final ContentResolver resolver;
   private final TransferListener listener;
 
+  private AssetFileDescriptor assetFileDescriptor;
   private InputStream inputStream;
   private String uriString;
   private long bytesRemaining;
@@ -69,8 +70,8 @@ public ContentDataSource(Context context, TransferListener listener) {
   public long open(DataSpec dataSpec) throws ContentDataSourceException {
     try {
       uriString = dataSpec.uri.toString();
-      AssetFileDescriptor assetFd = resolver.openAssetFileDescriptor(dataSpec.uri, "r");
-      inputStream = new FileInputStream(assetFd.getFileDescriptor());
+      assetFileDescriptor = resolver.openAssetFileDescriptor(dataSpec.uri, "r");
+      inputStream = new FileInputStream(assetFileDescriptor.getFileDescriptor());
       long skipped = inputStream.skip(dataSpec.position);
       if (skipped < dataSpec.position) {
         // We expect the skip to be satisfied in full. If it isn't then we're probably trying to
@@ -135,13 +136,22 @@ public String getUri() {
   @Override
   public void close() throws ContentDataSourceException {
     uriString = null;
-    if (inputStream != null) {
-      try {
+    try {
+      if (inputStream != null) {
         inputStream.close();
+      }
+    } catch (IOException e) {
+      throw new ContentDataSourceException(e);
+    } finally {
+      inputStream = null;
+      try {
+        if (assetFileDescriptor != null) {
+          assetFileDescriptor.close();
+        }
       } catch (IOException e) {
         throw new ContentDataSourceException(e);
       } finally {
-        inputStream = null;
+        assetFileDescriptor = null;
         if (opened) {
           opened = false;
           if (listener != null) {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
index c8af75a1e8..ef63e3e45e 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
@@ -133,7 +133,7 @@ public synchronized void trim(int targetSize) {
         if (lowAllocation.data == initialAllocationBlock) {
           lowIndex++;
         } else {
-          Allocation highAllocation = availableAllocations[lowIndex];
+          Allocation highAllocation = availableAllocations[highIndex];
           if (highAllocation.data != initialAllocationBlock) {
             highIndex--;
           } else {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
index d2973f0db7..414dd18a7a 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
@@ -27,9 +27,9 @@
 
   private static final String SUFFIX = ".v2.exo";
   private static final Pattern CACHE_FILE_PATTERN_V1 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$");
+      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
   private static final Pattern CACHE_FILE_PATTERN_V2 =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$");
+      Pattern.compile("^(.+)\\.(\\d+)(E?)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -87,7 +87,7 @@ public static CacheSpan createCacheEntry(File file) {
     }
     String key = Util.unescapeFileName(matcher.group(1));
     return key == null ? null : createCacheEntry(
-        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
+        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(4)), file);
   }
 
   static File upgradeIfNeeded(File file) {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 63f9af1ea4..59597a155f 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -55,6 +55,16 @@ public ParsableByteArray(byte[] data, int limit) {
     this.limit = limit;
   }
 
+  /**
+   * Resets the position to zero and the limit to the specified value. If the limit exceeds the
+   * capacity, {@code data} is replaced with a new array of sufficient size.
+   *
+   * @param limit The limit to set.
+   */
+  public void reset(int limit) {
+    reset(capacity() < limit ? new byte[limit] : data, limit);
+  }
+
   /**
    * Updates the instance to wrap {@code data}, and resets the position to zero.
    *
@@ -328,6 +338,11 @@ public long readUnsignedLongToLong() {
     return result;
   }
 
+  /** Reads the next four bytes as a 32-bit floating point value. */
+  public float readFloat() {
+    return Float.intBitsToFloat(readInt());
+  }
+
   /** Reads the next eight bytes as a 64-bit floating point value. */
   public double readDouble() {
     return Double.longBitsToDouble(readLong());
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index f2ec738701..24991ddc67 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -16,13 +16,18 @@
 package com.google.android.exoplayer.util;
 
 import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.Point;
 import android.net.Uri;
 import android.os.Build;
 import android.text.TextUtils;
+import android.util.Log;
+import android.view.Display;
+import android.view.WindowManager;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer.upstream.DataSource;
@@ -103,17 +108,15 @@
    */
   public static final int TYPE_OTHER = 3;
 
+  private static final String TAG = "Util";
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
       + "(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d+))?"
       + "([Zz]|((\\+|\\-)(\\d\\d):(\\d\\d)))?");
-
   private static final Pattern XS_DURATION_PATTERN =
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
-
   private static final Pattern ESCAPED_CHARACTER_PATTERN = Pattern.compile("%([A-Fa-f0-9]{2})");
-
   private static final long MAX_BYTES_TO_DRAIN = 2048;
 
   private Util() {}
@@ -909,4 +912,148 @@ public static String unescapeFileName(String fileName) {
     }
     return builder.toString();
   }
+
+  /**
+   * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
+   * order.
+   *
+   * @param bytes Array containing the bytes to update the crc value with.
+   * @param start The index to the first byte in the byte range to update the crc with.
+   * @param end The index after the last byte in the byte range to update the crc with.
+   * @param initialValue The initial value for the crc calculation.
+   * @return The result of updating the initial value with the specified bytes.
+   */
+  public static int crc(byte[] bytes, int start, int end, int initialValue) {
+    for (int i = start; i < end; i++) {
+      initialValue = (initialValue << 8)
+          ^ CRC32_BYTES_MSBF[((initialValue >>> 24) ^ (bytes[i] & 0xFF)) & 0xFF];
+    }
+    return initialValue;
+  }
+
+  /**
+   * Gets the physical size of the default display, in pixels.
+   *
+   * @param context Any context.
+   * @return The physical display size, in pixels.
+   */
+  public static Point getPhysicalDisplaySize(Context context) {
+    // Before API 25 the platform Display object does not provide a working way to identify Android
+    // TVs that can show 4k resolution in a SurfaceView, so check for supported devices here.
+    if (Util.SDK_INT < 25) {
+      if ("Sony".equals(Util.MANUFACTURER) && Util.MODEL != null && Util.MODEL.startsWith("BRAVIA")
+          && context.getPackageManager().hasSystemFeature("com.sony.dtv.hardware.panel.qfhd")) {
+        return new Point(3840, 2160);
+      } else if ("NVIDIA".equals(Util.MANUFACTURER) && Util.MODEL != null
+          && Util.MODEL.contains("SHIELD")) {
+        // Attempt to read sys.display-size.
+        String sysDisplaySize = null;
+        try {
+          Class<?> systemProperties = Class.forName("android.os.SystemProperties");
+          Method getMethod = systemProperties.getMethod("get", String.class);
+          sysDisplaySize = (String) getMethod.invoke(systemProperties, "sys.display-size");
+        } catch (Exception e) {
+          Log.e(TAG, "Failed to read sys.display-size", e);
+        }
+        // If we managed to read sys.display-size, attempt to parse it.
+        if (!TextUtils.isEmpty(sysDisplaySize)) {
+          try {
+            String[] sysDisplaySizeParts = sysDisplaySize.trim().split("x");
+            if (sysDisplaySizeParts.length == 2) {
+              int width = Integer.parseInt(sysDisplaySizeParts[0]);
+              int height = Integer.parseInt(sysDisplaySizeParts[1]);
+              if (width > 0 && height > 0) {
+                return new Point(width, height);
+              }
+            }
+          } catch (NumberFormatException e) {
+            // Do nothing.
+          }
+          Log.e(TAG, "Invalid sys.display-size: " + sysDisplaySize);
+        }
+      }
+    }
+
+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+    Display display = windowManager.getDefaultDisplay();
+    Point displaySize = new Point();
+    if (Util.SDK_INT >= 23) {
+      getDisplaySizeV23(display, displaySize);
+    } else if (Util.SDK_INT >= 17) {
+      getDisplaySizeV17(display, displaySize);
+    } else if (Util.SDK_INT >= 16) {
+      getDisplaySizeV16(display, displaySize);
+    } else {
+      getDisplaySizeV9(display, displaySize);
+    }
+    return displaySize;
+  }
+
+  @TargetApi(23)
+  private static void getDisplaySizeV23(Display display, Point outSize) {
+    Display.Mode mode = display.getMode();
+    outSize.x = mode.getPhysicalWidth();
+    outSize.y = mode.getPhysicalHeight();
+  }
+
+  @TargetApi(17)
+  private static void getDisplaySizeV17(Display display, Point outSize) {
+    display.getRealSize(outSize);
+  }
+
+  @TargetApi(16)
+  private static void getDisplaySizeV16(Display display, Point outSize) {
+    display.getSize(outSize);
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void getDisplaySizeV9(Display display, Point outSize) {
+    outSize.x = display.getWidth();
+    outSize.y = display.getHeight();
+  }
+
+  /**
+   * Allows the CRC calculation to be done byte by byte instead of bit per bit being the order
+   * "most significant bit first".
+   */
+  private static final int[] CRC32_BYTES_MSBF = {
+      0X00000000, 0X04C11DB7, 0X09823B6E, 0X0D4326D9, 0X130476DC, 0X17C56B6B, 0X1A864DB2,
+      0X1E475005, 0X2608EDB8, 0X22C9F00F, 0X2F8AD6D6, 0X2B4BCB61, 0X350C9B64, 0X31CD86D3,
+      0X3C8EA00A, 0X384FBDBD, 0X4C11DB70, 0X48D0C6C7, 0X4593E01E, 0X4152FDA9, 0X5F15ADAC,
+      0X5BD4B01B, 0X569796C2, 0X52568B75, 0X6A1936C8, 0X6ED82B7F, 0X639B0DA6, 0X675A1011,
+      0X791D4014, 0X7DDC5DA3, 0X709F7B7A, 0X745E66CD, 0X9823B6E0, 0X9CE2AB57, 0X91A18D8E,
+      0X95609039, 0X8B27C03C, 0X8FE6DD8B, 0X82A5FB52, 0X8664E6E5, 0XBE2B5B58, 0XBAEA46EF,
+      0XB7A96036, 0XB3687D81, 0XAD2F2D84, 0XA9EE3033, 0XA4AD16EA, 0XA06C0B5D, 0XD4326D90,
+      0XD0F37027, 0XDDB056FE, 0XD9714B49, 0XC7361B4C, 0XC3F706FB, 0XCEB42022, 0XCA753D95,
+      0XF23A8028, 0XF6FB9D9F, 0XFBB8BB46, 0XFF79A6F1, 0XE13EF6F4, 0XE5FFEB43, 0XE8BCCD9A,
+      0XEC7DD02D, 0X34867077, 0X30476DC0, 0X3D044B19, 0X39C556AE, 0X278206AB, 0X23431B1C,
+      0X2E003DC5, 0X2AC12072, 0X128E9DCF, 0X164F8078, 0X1B0CA6A1, 0X1FCDBB16, 0X018AEB13,
+      0X054BF6A4, 0X0808D07D, 0X0CC9CDCA, 0X7897AB07, 0X7C56B6B0, 0X71159069, 0X75D48DDE,
+      0X6B93DDDB, 0X6F52C06C, 0X6211E6B5, 0X66D0FB02, 0X5E9F46BF, 0X5A5E5B08, 0X571D7DD1,
+      0X53DC6066, 0X4D9B3063, 0X495A2DD4, 0X44190B0D, 0X40D816BA, 0XACA5C697, 0XA864DB20,
+      0XA527FDF9, 0XA1E6E04E, 0XBFA1B04B, 0XBB60ADFC, 0XB6238B25, 0XB2E29692, 0X8AAD2B2F,
+      0X8E6C3698, 0X832F1041, 0X87EE0DF6, 0X99A95DF3, 0X9D684044, 0X902B669D, 0X94EA7B2A,
+      0XE0B41DE7, 0XE4750050, 0XE9362689, 0XEDF73B3E, 0XF3B06B3B, 0XF771768C, 0XFA325055,
+      0XFEF34DE2, 0XC6BCF05F, 0XC27DEDE8, 0XCF3ECB31, 0XCBFFD686, 0XD5B88683, 0XD1799B34,
+      0XDC3ABDED, 0XD8FBA05A, 0X690CE0EE, 0X6DCDFD59, 0X608EDB80, 0X644FC637, 0X7A089632,
+      0X7EC98B85, 0X738AAD5C, 0X774BB0EB, 0X4F040D56, 0X4BC510E1, 0X46863638, 0X42472B8F,
+      0X5C007B8A, 0X58C1663D, 0X558240E4, 0X51435D53, 0X251D3B9E, 0X21DC2629, 0X2C9F00F0,
+      0X285E1D47, 0X36194D42, 0X32D850F5, 0X3F9B762C, 0X3B5A6B9B, 0X0315D626, 0X07D4CB91,
+      0X0A97ED48, 0X0E56F0FF, 0X1011A0FA, 0X14D0BD4D, 0X19939B94, 0X1D528623, 0XF12F560E,
+      0XF5EE4BB9, 0XF8AD6D60, 0XFC6C70D7, 0XE22B20D2, 0XE6EA3D65, 0XEBA91BBC, 0XEF68060B,
+      0XD727BBB6, 0XD3E6A601, 0XDEA580D8, 0XDA649D6F, 0XC423CD6A, 0XC0E2D0DD, 0XCDA1F604,
+      0XC960EBB3, 0XBD3E8D7E, 0XB9FF90C9, 0XB4BCB610, 0XB07DABA7, 0XAE3AFBA2, 0XAAFBE615,
+      0XA7B8C0CC, 0XA379DD7B, 0X9B3660C6, 0X9FF77D71, 0X92B45BA8, 0X9675461F, 0X8832161A,
+      0X8CF30BAD, 0X81B02D74, 0X857130C3, 0X5D8A9099, 0X594B8D2E, 0X5408ABF7, 0X50C9B640,
+      0X4E8EE645, 0X4A4FFBF2, 0X470CDD2B, 0X43CDC09C, 0X7B827D21, 0X7F436096, 0X7200464F,
+      0X76C15BF8, 0X68860BFD, 0X6C47164A, 0X61043093, 0X65C52D24, 0X119B4BE9, 0X155A565E,
+      0X18197087, 0X1CD86D30, 0X029F3D35, 0X065E2082, 0X0B1D065B, 0X0FDC1BEC, 0X3793A651,
+      0X3352BBE6, 0X3E119D3F, 0X3AD08088, 0X2497D08D, 0X2056CD3A, 0X2D15EBE3, 0X29D4F654,
+      0XC5A92679, 0XC1683BCE, 0XCC2B1D17, 0XC8EA00A0, 0XD6AD50A5, 0XD26C4D12, 0XDF2F6BCB,
+      0XDBEE767C, 0XE3A1CBC1, 0XE760D676, 0XEA23F0AF, 0XEEE2ED18, 0XF0A5BD1D, 0XF464A0AA,
+      0XF9278673, 0XFDE69BC4, 0X89B8FD09, 0X8D79E0BE, 0X803AC667, 0X84FBDBD0, 0X9ABC8BD5,
+      0X9E7D9662, 0X933EB0BB, 0X97FFAD0C, 0XAFB010B1, 0XAB710D06, 0XA6322BDF, 0XA2F33668,
+      0XBCB4666D, 0XB8757BDA, 0XB5365D03, 0XB1F740B4
+  };
+
 }
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index abd26bacf4..996a4e698b 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1510"
-    android:versionName="1.5.10">
+    android:versionCode="1511"
+    android:versionName="1.5.11">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/settings.gradle b/settings.gradle
index 89fc5741cc..eff02b9ce8 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -20,8 +20,15 @@ include ':extension-vp9'
 include ':extension-okhttp'
 include ':extension-flac'
 
+// Uncomment the following line to use the Cronet Extension.
+// include ':extension-cronet'
+
 project(':demo-ext').projectDir = new File(settingsDir, 'demo_ext')
 project(':extension-opus').projectDir = new File(settingsDir, 'extensions/opus')
 project(':extension-vp9').projectDir = new File(settingsDir, 'extensions/vp9')
 project(':extension-okhttp').projectDir = new File(settingsDir, 'extensions/okhttp')
 project(':extension-flac').projectDir = new File(settingsDir, 'extensions/flac')
+
+// Uncomment the following line to use the Cronet Extension.
+// See extensions/cronet/README.md for details.
+// project(':extension-cronet').projectDir = new File(settingsDir, 'extensions/cronet')
\ No newline at end of file
