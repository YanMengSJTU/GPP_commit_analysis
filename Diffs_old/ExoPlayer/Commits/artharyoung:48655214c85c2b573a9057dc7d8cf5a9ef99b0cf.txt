diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
index 3667c8cc96..6e55f3dcd6 100644
--- a/ISSUE_TEMPLATE
+++ b/ISSUE_TEMPLATE
@@ -1,5 +1,7 @@
+*** PLEASE DO NOT IGNORE THIS ISSUE TEMPLATE ***
+
 Please search the existing issues before filing a new one, including issues that
-are closed. When filing a new issue please include all of the following, unless
+are closed. When filing a new issue please include ALL of the following, unless
 you're certain that they're not useful for the particular issue being reported.
 
 - A description of the issue.
diff --git a/README.md b/README.md
index 970d482e16..f74cda84ee 100644
--- a/README.md
+++ b/README.md
@@ -20,10 +20,17 @@ and extend, and can be updated through Play Store application updates.
 
 ## Using ExoPlayer ##
 
-#### Via jCenter ####
+The easiest way to get started using ExoPlayer is to add it as a gradle
+dependency. You need to make sure you have the jcenter repository included in
+the `build.gradle` file in the root of your project:
 
-The easiest way to get started using ExoPlayer is by including the following in
-your project's `build.gradle` file:
+```gradle
+repositories {
+    jcenter()
+}
+```
+
+Next, include the following in your module's `build.gradle` file:
 
 ```gradle
 compile 'com.google.android.exoplayer:exoplayer:rX.X.X'
@@ -35,31 +42,6 @@ project's [Releases][]. For more details, see the project on [Bintray][].
 [Releases]: https://github.com/google/ExoPlayer/releases
 [Bintray]: https://bintray.com/google/exoplayer/exoplayer/view
 
-#### As source ####
-
-ExoPlayer can also be built from source using Gradle. You can include it as a
-dependent project like so:
-
-```gradle
-// settings.gradle
-include ':app', ':..:ExoPlayer:library'
-
-// app/build.gradle
-dependencies {
-    compile project(':..:ExoPlayer:library')
-}
-```
-
-#### As a jar ####
-
-If you want to use ExoPlayer as a jar, run:
-
-```sh
-./gradlew jarRelease
-```
-
-and copy `library.jar` to the libs folder of your new project.
-
 ## Developing ExoPlayer ##
 
 #### Project branches ####
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index fb3b33d696..ce002238ef 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,50 @@
 # Release notes #
 
+### r2.0.4 ###
+
+This release contains important bug fixes. Users of earlier r2.0.x versions
+should proactively update to this version.
+
+* Fix crash on Jellybean devices when using playback controls
+  ([#1965](https://github.com/google/ExoPlayer/issues/1965)).
+
+### r2.0.3 ###
+
+* Fixed NullPointerException in ExtractorMediaSource
+  ([#1914](https://github.com/google/ExoPlayer/issues/1914)).
+* Fixed NullPointerException in HlsMediaPeriod
+  ([#1907](https://github.com/google/ExoPlayer/issues/1907)).
+* Fixed memory leak in PlaybackControlView
+  ([#1908](https://github.com/google/ExoPlayer/issues/1908)).
+* Fixed strict mode violation when using
+  SimpleExoPlayer.setVideoPlayerTextureView().
+* Fixed L3 Widevine provisioning
+  ([#1925](https://github.com/google/ExoPlayer/issues/1925)).
+* Fixed hiding of controls with use_controller="false"
+  ([#1919](https://github.com/google/ExoPlayer/issues/1919)).
+* Improvements to Cronet network stack extension.
+* Misc bug fixes.
+
+### r2.0.2 ###
+
+* Fixes for MergingMediaSource and sideloaded subtitles.
+  ([#1882](https://github.com/google/ExoPlayer/issues/1882),
+  [#1854](https://github.com/google/ExoPlayer/issues/1854),
+  [#1900](https://github.com/google/ExoPlayer/issues/1900)).
+* Reduced effect of application code leaking player references
+  ([#1855](https://github.com/google/ExoPlayer/issues/1855)).
+* Initial support for fragmented MP4 in HLS.
+* Misc bug fixes and minor features.
+
+### r2.0.1 ###
+
+* Fix playback of short duration content
+  ([#1837](https://github.com/google/ExoPlayer/issues/1837)).
+* Fix MergingMediaSource preparation issue
+  ([#1853](https://github.com/google/ExoPlayer/issues/1853)).
+* Fix live stream buffering (out of memory) issue
+  ([#1825](https://github.com/google/ExoPlayer/issues/1825)).
+
 ### r2.0.0 ###
 
 ExoPlayer 2.x is a major iteration of the library. It includes significant API
@@ -68,6 +113,13 @@ some of the motivations behind ExoPlayer 2.x
  * Suppressed "Sending message to a Handler on a dead thread" warnings
    ([#426](https://github.com/google/ExoPlayer/issues/426)).
 
+### r1.5.12 ###
+
+* Improvements to Cronet network stack extension.
+* Fix bug in demo app introduced in r1.5.11 that caused L3 Widevine
+  provisioning requests to fail.
+* Misc bugfixes.
+
 ### r1.5.11 ###
 
 * Cronet network stack extension.
diff --git a/build.gradle b/build.gradle
index b02d3db19b..8e9032be70 100644
--- a/build.gradle
+++ b/build.gradle
@@ -16,7 +16,6 @@
 
 buildscript {
     repositories {
-        mavenCentral()
         jcenter()
     }
     dependencies {
@@ -27,11 +26,16 @@ buildscript {
 
 allprojects {
     repositories {
-        mavenCentral()
+        jcenter()
     }
     project.ext {
         compileSdkVersion=24
         targetSdkVersion=24
         buildToolsVersion='23.0.3'
+        releaseRepoName = 'exoplayer'
+        releaseUserOrg = 'google'
+        releaseGroupId = 'com.google.android.exoplayer'
+        releaseVersion = 'r2.0.4'
+        releaseWebsite = 'https://github.com/google/ExoPlayer'
     }
 }
diff --git a/demo/build.gradle b/demo/build.gradle
index 6aaedf05c5..bfbcd1aa4c 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -38,15 +38,15 @@ android {
     }
 
     productFlavors {
-        demo
-        demo_ext
+        noExtensions
+        withExtensions
     }
 }
 
 dependencies {
     compile project(':library')
-    demo_extCompile project(path: ':extension-ffmpeg')
-    demo_extCompile project(path: ':extension-flac')
-    demo_extCompile project(path: ':extension-opus')
-    demo_extCompile project(path: ':extension-vp9')
+    withExtensionsCompile project(path: ':extension-ffmpeg')
+    withExtensionsCompile project(path: ':extension-flac')
+    withExtensionsCompile project(path: ':extension-opus')
+    withExtensionsCompile project(path: ':extension-vp9')
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 6cf98d2aca..1f015827c9 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo"
-    android:versionCode="2000"
-    android:versionName="2.0.0">
+    android:versionCode="2004"
+    android:versionName="2.0.4">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
diff --git a/demo/src/main/assets/media.exolist.json b/demo/src/main/assets/media.exolist.json
index b067098baa..6fa46d7451 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demo/src/main/assets/media.exolist.json
@@ -303,9 +303,13 @@
         "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_16x9/bipbop_16x9_variant.m3u8"
       },
       {
-        "name": "Apple master playlist advanced",
+        "name": "Apple master playlist advanced (TS)",
         "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_example_v2/master.m3u8"
       },
+      {
+        "name": "Apple master playlist advanced (fMP4)",
+        "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_fmp4_example/master.m3u8"
+      },
       {
         "name": "Apple TS media playlist",
         "uri": "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8"
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index 9e927488a7..92dc08597f 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -16,9 +16,33 @@
 package com.google.android.exoplayer2.demo;
 
 import android.app.Application;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.Util;
 
 /**
  * Placeholder application to facilitate overriding Application methods for debugging and testing.
  */
 public class DemoApplication extends Application {
+
+  protected String userAgent;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
+  }
+
+  DataSource.Factory buildDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
+    return new DefaultDataSourceFactory(this, bandwidthMeter,
+        buildHttpDataSourceFactory(bandwidthMeter));
+  }
+
+  HttpDataSource.Factory buildHttpDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
+    return new DefaultHttpDataSourceFactory(userAgent, bandwidthMeter);
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index 7fd32ddbe1..d79de04657 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -38,9 +38,10 @@
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector.TrackInfo;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import java.io.IOException;
@@ -54,7 +55,7 @@
 /* package */ final class EventLogger implements ExoPlayer.EventListener,
     AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
     ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
-    MappingTrackSelector.EventListener, MetadataRenderer.Output<List<Id3Frame>> {
+    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output<List<Id3Frame>> {
 
   private static final String TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
@@ -96,6 +97,9 @@ public void onPositionDiscontinuity() {
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
+    if (timeline == null) {
+      return;
+    }
     int periodCount = timeline.getPeriodCount();
     int windowCount = timeline.getWindowCount();
     Log.d(TAG, "sourceInfo [periodCount=" + periodCount + ", windowCount=" + windowCount);
@@ -125,23 +129,24 @@ public void onPlayerError(ExoPlaybackException e) {
   // MappingTrackSelector.EventListener
 
   @Override
-  public void onTracksChanged(TrackInfo trackInfo) {
+  public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo> trackSelections) {
     Log.d(TAG, "Tracks [");
     // Log tracks associated to renderers.
-    for (int rendererIndex = 0; rendererIndex < trackInfo.rendererCount; rendererIndex++) {
-      TrackGroupArray trackGroups = trackInfo.getTrackGroups(rendererIndex);
-      TrackSelection trackSelection = trackInfo.getTrackSelection(rendererIndex);
+    MappedTrackInfo info = trackSelections.info;
+    for (int rendererIndex = 0; rendererIndex < trackSelections.length; rendererIndex++) {
+      TrackGroupArray trackGroups = info.getTrackGroups(rendererIndex);
+      TrackSelection trackSelection = trackSelections.get(rendererIndex);
       if (trackGroups.length > 0) {
         Log.d(TAG, "  Renderer:" + rendererIndex + " [");
         for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
           TrackGroup trackGroup = trackGroups.get(groupIndex);
           String adaptiveSupport = getAdaptiveSupportString(
-              trackGroup.length, trackInfo.getAdaptiveSupport(rendererIndex, groupIndex, false));
+              trackGroup.length, info.getAdaptiveSupport(rendererIndex, groupIndex, false));
           Log.d(TAG, "    Group:" + groupIndex + ", adaptive_supported=" + adaptiveSupport + " [");
           for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
             String status = getTrackStatusString(trackSelection, trackGroup, trackIndex);
             String formatSupport = getFormatSupportString(
-                trackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
+                info.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
             Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
                 + getFormatString(trackGroup.getFormat(trackIndex))
                 + ", supported=" + formatSupport);
@@ -152,7 +157,7 @@ public void onTracksChanged(TrackInfo trackInfo) {
       }
     }
     // Log tracks not associated with a renderer.
-    TrackGroupArray trackGroups = trackInfo.getUnassociatedTrackGroups();
+    TrackGroupArray trackGroups = info.getUnassociatedTrackGroups();
     if (trackGroups.length > 0) {
       Log.d(TAG, "  Renderer:None [");
       for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index eaa4d9971f..e9aa46f85f 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -36,6 +36,7 @@
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
 import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
@@ -55,15 +56,15 @@
 import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector.TrackInfo;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.ui.DebugTextViewHelper;
 import com.google.android.exoplayer2.ui.PlaybackControlView;
 import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
-import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.util.Util;
 import java.net.CookieHandler;
@@ -77,7 +78,7 @@
  * An activity that plays media using {@link SimpleExoPlayer}.
  */
 public class PlayerActivity extends Activity implements OnClickListener, ExoPlayer.EventListener,
-    MappingTrackSelector.EventListener, PlaybackControlView.VisibilityListener {
+    TrackSelector.EventListener<MappedTrackInfo>, PlaybackControlView.VisibilityListener {
 
   public static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
   public static final String DRM_LICENSE_URL = "drm_license_url";
@@ -100,13 +101,13 @@
   }
 
   private Handler mainHandler;
+  private Timeline.Window window;
   private EventLogger eventLogger;
   private SimpleExoPlayerView simpleExoPlayerView;
   private LinearLayout debugRootView;
   private TextView debugTextView;
   private Button retryButton;
 
-  private String userAgent;
   private DataSource.Factory mediaDataSourceFactory;
   private SimpleExoPlayer player;
   private MappingTrackSelector trackSelector;
@@ -115,7 +116,7 @@
   private boolean playerNeedsSource;
 
   private boolean shouldAutoPlay;
-  private boolean shouldRestorePosition;
+  private boolean isTimelineStatic;
   private int playerWindow;
   private long playerPosition;
 
@@ -125,9 +126,9 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     shouldAutoPlay = true;
-    userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
     mediaDataSourceFactory = buildDataSourceFactory(true);
     mainHandler = new Handler();
+    window = new Timeline.Window();
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -148,7 +149,7 @@ public void onCreate(Bundle savedInstanceState) {
   @Override
   public void onNewIntent(Intent intent) {
     releasePlayer();
-    shouldRestorePosition = false;
+    isTimelineStatic = false;
     setIntent(intent);
   }
 
@@ -203,7 +204,7 @@ public void onClick(View view) {
       initializePlayer();
     } else if (view.getParent() == debugRootView) {
       trackSelectionHelper.showSelectionDialog(this, ((Button) view).getText(),
-          trackSelector.getTrackInfo(), (int) view.getTag());
+          trackSelector.getCurrentSelections().info, (int) view.getTag());
     }
   }
 
@@ -222,7 +223,7 @@ private void initializePlayer() {
       boolean preferExtensionDecoders = intent.getBooleanExtra(PREFER_EXTENSION_DECODERS, false);
       UUID drmSchemeUuid = intent.hasExtra(DRM_SCHEME_UUID_EXTRA)
           ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
-      DrmSessionManager drmSessionManager = null;
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
       if (drmSchemeUuid != null) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
         String[] keyRequestPropertiesArray = intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES);
@@ -263,7 +264,7 @@ private void initializePlayer() {
       player.setVideoDebugListener(eventLogger);
       player.setId3Output(eventLogger);
       simpleExoPlayerView.setPlayer(player);
-      if (shouldRestorePosition) {
+      if (isTimelineStatic) {
         if (playerPosition == C.TIME_UNSET) {
           player.seekToDefaultPosition(playerWindow);
         } else {
@@ -306,7 +307,7 @@ private void initializePlayer() {
       }
       MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
           : new ConcatenatingMediaSource(mediaSources);
-      player.prepare(mediaSource, !shouldRestorePosition);
+      player.prepare(mediaSource, !isTimelineStatic, !isTimelineStatic);
       playerNeedsSource = false;
       updateButtonVisibilities();
     }
@@ -316,15 +317,15 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
     int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension
         : uri.getLastPathSegment());
     switch (type) {
-      case Util.TYPE_SS:
+      case C.TYPE_SS:
         return new SsMediaSource(uri, buildDataSourceFactory(false),
             new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
-      case Util.TYPE_DASH:
+      case C.TYPE_DASH:
         return new DashMediaSource(uri, buildDataSourceFactory(false),
             new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
-      case Util.TYPE_HLS:
+      case C.TYPE_HLS:
         return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, eventLogger);
-      case Util.TYPE_OTHER:
+      case C.TYPE_OTHER:
         return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),
             mainHandler, eventLogger);
       default: {
@@ -333,9 +334,8 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
     }
   }
 
-  private DrmSessionManager buildDrmSessionManager(UUID uuid, String licenseUrl,
-      Map<String, String> keyRequestProperties)
-      throws UnsupportedDrmException {
+  private DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(UUID uuid,
+      String licenseUrl, Map<String, String> keyRequestProperties) throws UnsupportedDrmException {
     if (Util.SDK_INT < 18) {
       return null;
     }
@@ -350,15 +350,11 @@ private void releasePlayer() {
       debugViewHelper.stop();
       debugViewHelper = null;
       shouldAutoPlay = player.getPlayWhenReady();
-      shouldRestorePosition = false;
+      playerWindow = player.getCurrentWindowIndex();
+      playerPosition = C.TIME_UNSET;
       Timeline timeline = player.getCurrentTimeline();
-      if (timeline != null) {
-        playerWindow = player.getCurrentWindowIndex();
-        Timeline.Window window = timeline.getWindow(playerWindow, new Timeline.Window());
-        if (!window.isDynamic) {
-          shouldRestorePosition = true;
-          playerPosition = window.isSeekable ? player.getCurrentPosition() : C.TIME_UNSET;
-        }
+      if (timeline != null && timeline.getWindow(playerWindow, window).isSeekable) {
+        playerPosition = player.getCurrentPosition();
       }
       player.release();
       player = null;
@@ -376,8 +372,8 @@ private void releasePlayer() {
    * @return A new DataSource factory.
    */
   private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
-    return new DefaultDataSourceFactory(this, useBandwidthMeter ? BANDWIDTH_METER : null,
-        buildHttpDataSourceFactory(useBandwidthMeter));
+    return ((DemoApplication) getApplication())
+        .buildDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
   }
 
   /**
@@ -388,7 +384,8 @@ private void releasePlayer() {
    * @return A new HttpDataSource factory.
    */
   private HttpDataSource.Factory buildHttpDataSourceFactory(boolean useBandwidthMeter) {
-    return new DefaultHttpDataSourceFactory(userAgent, useBandwidthMeter ? BANDWIDTH_METER : null);
+    return ((DemoApplication) getApplication())
+        .buildHttpDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
   }
 
   // ExoPlayer.EventListener implementation
@@ -413,7 +410,8 @@ public void onPositionDiscontinuity() {
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
-    // Do nothing.
+    isTimelineStatic = timeline != null && timeline.getWindowCount() > 0
+        && !timeline.getWindow(timeline.getWindowCount() - 1, window).isDynamic;
   }
 
   @Override
@@ -452,8 +450,9 @@ public void onPlayerError(ExoPlaybackException e) {
   // MappingTrackSelector.EventListener implementation
 
   @Override
-  public void onTracksChanged(TrackInfo trackInfo) {
+  public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo> trackSelections) {
     updateButtonVisibilities();
+    MappedTrackInfo trackInfo = trackSelections.info;
     if (trackInfo.hasOnlyUnplayableTracks(C.TRACK_TYPE_VIDEO)) {
       showToast(R.string.error_unsupported_video);
     }
@@ -474,14 +473,14 @@ private void updateButtonVisibilities() {
       return;
     }
 
-    TrackInfo trackInfo = trackSelector.getTrackInfo();
-    if (trackInfo == null) {
+    TrackSelections<MappedTrackInfo> trackSelections = trackSelector.getCurrentSelections();
+    if (trackSelections == null) {
       return;
     }
 
-    int rendererCount = trackInfo.rendererCount;
+    int rendererCount = trackSelections.length;
     for (int i = 0; i < rendererCount; i++) {
-      TrackGroupArray trackGroups = trackInfo.getTrackGroups(i);
+      TrackGroupArray trackGroups = trackSelections.info.getTrackGroups(i);
       if (trackGroups.length != 0) {
         Button button = new Button(this);
         int label;
@@ -501,7 +500,7 @@ private void updateButtonVisibilities() {
         button.setText(label);
         button.setTag(i);
         button.setOnClickListener(this);
-        debugRootView.addView(button);
+        debugRootView.addView(button, debugRootView.getChildCount() - 1);
       }
     }
   }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index 1bbd620660..8892c138d0 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -31,8 +31,8 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.SelectionOverride;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector.TrackInfo;
 import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -51,7 +51,7 @@
   private final MappingTrackSelector selector;
   private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
 
-  private TrackInfo trackInfo;
+  private MappedTrackInfo trackInfo;
   private int rendererIndex;
   private TrackGroupArray trackGroups;
   private boolean[] trackGroupsAdaptive;
@@ -82,7 +82,7 @@ public TrackSelectionHelper(MappingTrackSelector selector,
    * @param trackInfo The current track information.
    * @param rendererIndex The index of the renderer.
    */
-  public void showSelectionDialog(Activity activity, CharSequence title, TrackInfo trackInfo,
+  public void showSelectionDialog(Activity activity, CharSequence title, MappedTrackInfo trackInfo,
       int rendererIndex) {
     this.trackInfo = trackInfo;
     this.rendererIndex = rendererIndex;
@@ -203,11 +203,7 @@ private void updateViews() {
 
   @Override
   public void onClick(DialogInterface dialog, int which) {
-    if (isDisabled) {
-      selector.setRendererDisabled(rendererIndex, true);
-      return;
-    }
-    selector.setRendererDisabled(rendererIndex, false);
+    selector.setRendererDisabled(rendererIndex, isDisabled);
     if (override != null) {
       selector.setSelectionOverride(rendererIndex, trackGroups, override);
     } else {
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index fca73af98b..b0de0784de 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -46,7 +46,6 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Predicate;
-
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -82,7 +81,6 @@
   private static final String TEST_CONTENT_TYPE = "test/test";
   private static final byte[] TEST_POST_BODY = "test post body".getBytes();
   private static final long TEST_CONTENT_LENGTH = 16000L;
-  private static final int TEST_BUFFER_SIZE = 16;
   private static final int TEST_CONNECTION_STATUS = 5;
 
   private DataSpec testDataSpec;
@@ -100,7 +98,8 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
         Executor executor, int priority,
         Collection<Object> connectionAnnotations,
         boolean disableCache,
-        boolean disableConnectionMigration);
+        boolean disableConnectionMigration,
+        boolean allowDirectExecutor);
   }
 
   @Mock
@@ -108,7 +107,7 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
   @Mock
   private Predicate<String> mockContentTypePredicate;
   @Mock
-  private TransferListener mockTransferListener;
+  private TransferListener<CronetDataSource> mockTransferListener;
   @Mock
   private Clock mockClock;
   @Mock
@@ -143,6 +142,7 @@ public void setUp() throws Exception {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class))).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
@@ -170,18 +170,15 @@ private UrlResponseInfo createUrlResponseInfo(int statusCode) {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void testOpeningTwiceThrows() throws HttpDataSourceException, IllegalStateException {
-    mockResponesStartSuccess();
-
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
+  public void testOpeningTwiceThrows() throws HttpDataSourceException {
+    mockResponseStartSuccess();
     dataSourceUnderTest.open(testDataSpec);
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     dataSourceUnderTest.open(testDataSpec);
   }
 
   @Test
   public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
     dataSourceUnderTest.close();
@@ -194,6 +191,7 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class))).thenReturn(mockUrlRequest2);
     doAnswer(new Answer<Object>() {
       @Override
@@ -202,7 +200,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            null);
+            mockUrlRequestException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -214,7 +212,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   @Test
   public void testRequestStartCalled() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
     verify(mockCronetEngine).createRequest(
@@ -224,16 +222,15 @@ public void testRequestStartCalled() throws HttpDataSourceException {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class));
     verify(mockUrlRequest).start();
   }
 
   @Test
   public void testRequestHeadersSet() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-    testResponseHeader.put("Content-Length", Long.toString(5000L));
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("firstHeader", "firstValue");
     dataSourceUnderTest.setRequestProperty("secondHeader", "secondValue");
@@ -248,10 +245,20 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
 
   @Test
   public void testRequestOpen() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-
+    mockResponseStartSuccess();
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
+  }
+
+  @Test
+  public void testRequestOpenGzippedCompressedReturnsDataSpecLength()
+      throws HttpDataSourceException {
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 5000, null);
+    testResponseHeader.put("Content-Encoding", "gzip");
+    testResponseHeader.put("Content-Length", Long.toString(50L));
+    mockResponseStartSuccess();
+
+    assertEquals(5000 /* contentLength */, dataSourceUnderTest.open(testDataSpec));
     verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
@@ -266,7 +273,6 @@ public void testRequestOpenFail() {
       // Check for connection not automatically closed.
       assertFalse(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     }
   }
@@ -284,14 +290,13 @@ public void testRequestOpenFailDueToDnsFailure() {
       // Check for connection not automatically closed.
       assertTrue(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     }
   }
 
   @Test
   public void testRequestOpenValidatesStatusCode() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     testUrlResponseInfo = createUrlResponseInfo(500); // statusCode
 
     try {
@@ -301,14 +306,13 @@ public void testRequestOpenValidatesStatusCode() {
       assertTrue(e instanceof HttpDataSource.InvalidResponseCodeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     }
   }
 
   @Test
   public void testRequestOpenValidatesContentTypePredicate() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(false);
 
     try {
@@ -318,43 +322,22 @@ public void testRequestOpenValidatesContentTypePredicate() {
       assertTrue(e instanceof HttpDataSource.InvalidContentTypeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockContentTypePredicate).evaluate(TEST_CONTENT_TYPE);
     }
   }
 
-  @Test
-  public void testRequestOpenValidatesContentLength() {
-    mockResponesStartSuccess();
-
-    // Data spec's requested length, 5000. Test response's length, 16,000.
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-
-    try {
-      dataSourceUnderTest.open(testDataSpec);
-      fail("HttpDataSource.HttpDataSourceException expected");
-    } catch (HttpDataSourceException e) {
-      verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
-      // Check for connection not automatically closed.
-      verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
-      verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testPostDataSpec);
-    }
-  }
-
   @Test
   public void testPostRequestOpen() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testPostDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testPostDataSpec);
   }
 
   @Test
   public void testPostRequestOpenValidatesContentType() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     try {
       dataSourceUnderTest.open(testPostDataSpec);
@@ -366,7 +349,7 @@ public void testPostRequestOpenValidatesContentType() {
 
   @Test
   public void testPostRequestOpenRejects307Redirects() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     mockResponseStartRedirect();
 
     try {
@@ -380,8 +363,8 @@ public void testPostRequestOpenRejects307Redirects() {
 
   @Test
   public void testRequestReadTwice() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -402,29 +385,24 @@ public void testRequestReadTwice() throws HttpDataSourceException {
 
   @Test
   public void testSecondRequestNoContentLength() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
-
-    byte[] returnedBuffer = new byte[8];
+    mockResponseStartSuccess();
+    testResponseHeader.put("Content-Length", Long.toString(1L));
+    mockReadSuccess(0, 16);
 
     // First request.
-    testResponseHeader.put("Content-Length", Long.toString(1L));
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
     dataSourceUnderTest.open(testDataSpec);
+    byte[] returnedBuffer = new byte[8];
     dataSourceUnderTest.read(returnedBuffer, 0, 1);
     dataSourceUnderTest.close();
 
-    // Second request. There's no Content-Length response header.
     testResponseHeader.remove("Content-Length");
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    mockReadSuccess(0, 16);
+
+    // Second request.
     dataSourceUnderTest.open(testDataSpec);
     returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(10, bytesRead);
-
-    mockResponseFinished();
-
-    // Should read whats left in the buffer first.
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(6, bytesRead);
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
@@ -433,8 +411,55 @@ public void testSecondRequestNoContentLength() throws HttpDataSourceException {
 
   @Test
   public void testReadWithOffset() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
+    assertEquals(8, bytesRead);
+    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 8);
+  }
+
+  @Test
+  public void testRangeRequestWith206Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(1000, 5000);
+    testUrlResponseInfo = createUrlResponseInfo(206); // Server supports range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
+  }
+
+  @Test
+  public void testRangeRequestWith200Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 7000);
+    testUrlResponseInfo = createUrlResponseInfo(200); // Server does not support range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
+  }
+
+  @Test
+  public void testReadWithUnsetLength() throws HttpDataSourceException {
+    testResponseHeader.remove("Content-Length");
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -447,8 +472,8 @@ public void testReadWithOffset() throws HttpDataSourceException {
 
   @Test
   public void testReadReturnsWhatItCan() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -461,8 +486,8 @@ public void testReadReturnsWhatItCan() throws HttpDataSourceException {
 
   @Test
   public void testClosedMeansClosed() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     int bytesRead = 0;
     dataSourceUnderTest.open(testDataSpec);
@@ -474,7 +499,6 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
     dataSourceUnderTest.close();
     verify(mockTransferListener).onTransferEnd(dataSourceUnderTest);
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
 
     try {
       bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
@@ -489,32 +513,29 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
   @Test
   public void testOverread() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
-
-    // Ask for 16 bytes
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 10000, 16, null);
-    // Let the response promise to give 16 bytes back.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 16, null);
     testResponseHeader.put("Content-Length", Long.toString(16L));
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
     byte[] returnedBuffer = new byte[8];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
     assertEquals(8, bytesRead);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
 
     // The current buffer is kept if not completely consumed by DataSource reader.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 6);
-    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
     assertEquals(14, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
 
     // 2 bytes left at this point.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
     assertEquals(16, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
@@ -536,7 +557,6 @@ public void testOverread() throws HttpDataSourceException {
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
     // Check for connection not automatically closed.
     verify(mockUrlRequest, never()).cancel();
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     assertEquals(16, bytesRead);
   }
 
@@ -567,15 +587,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
@@ -601,15 +618,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // The response arrives just in time.
     dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
     openCondition.block();
-    assertEquals(CronetDataSource.OPEN_CONNECTION, dataSourceUnderTest.connectionState);
   }
 
   @Test
@@ -638,11 +652,9 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl1");
@@ -653,7 +665,6 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl2");
@@ -664,11 +675,9 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     assertEquals(1, openExceptions.get());
@@ -676,7 +685,7 @@ public void run() {
 
   @Test
   public void testExceptionFromTransferListener() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     // Make mockTransferListener throw an exception in CronetDataSource.close(). Ensure that
     // the subsequent open() call succeeds.
@@ -695,7 +704,7 @@ public void testExceptionFromTransferListener() throws HttpDataSourceException {
 
   @Test
   public void testReadFailure() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     mockReadFailure();
 
     dataSourceUnderTest.open(testDataSpec);
@@ -722,7 +731,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).getStatus(any(UrlRequest.StatusListener.class));
   }
 
-  private void mockResponesStartSuccess() {
+  private void mockResponseStartSuccess() {
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -760,16 +769,24 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).start();
   }
 
-  private void mockReadSuccess() {
+  private void mockReadSuccess(int position, int length) {
+    final int[] positionAndRemaining = new int[] {position, length};
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocation) throws Throwable {
-        ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
-        inputBuffer.put(buildTestDataBuffer());
-        dataSourceUnderTest.onReadCompleted(
-            mockUrlRequest,
-            testUrlResponseInfo,
-            inputBuffer);
+        if (positionAndRemaining[1] == 0) {
+          dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+        } else {
+          ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+          int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
+          inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
+          positionAndRemaining[0] += readLength;
+          positionAndRemaining[1] -= readLength;
+          dataSourceUnderTest.onReadCompleted(
+              mockUrlRequest,
+              testUrlResponseInfo,
+              inputBuffer);
+        }
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -782,17 +799,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            null);
-        return null;
-      }
-    }).when(mockUrlRequest).read(any(ByteBuffer.class));
-  }
-
-  private void mockResponseFinished() {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+            mockUrlRequestException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -810,8 +817,8 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return startedCondition;
   }
 
-  private static byte[] buildTestDataArray(int start, int length) {
-    return Arrays.copyOfRange(buildTestDataBuffer().array(), start, start + length);
+  private static byte[] buildTestDataArray(int position, int length) {
+    return buildTestDataBuffer(position, length).array();
   }
 
   public static byte[] prefixZeros(byte[] data, int requiredLength) {
@@ -824,17 +831,13 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return Arrays.copyOf(data, requiredLength);
   }
 
-  private static ByteBuffer buildTestDataBuffer() {
-    ByteBuffer testBuffer = ByteBuffer.allocate(TEST_BUFFER_SIZE);
-    for (byte i = 1; i <= TEST_BUFFER_SIZE; i++) {
-      testBuffer.put(i);
+  private static ByteBuffer buildTestDataBuffer(int position, int length) {
+    ByteBuffer testBuffer = ByteBuffer.allocate(length);
+    for (int i = 0; i < length; i++) {
+      testBuffer.put((byte) (position + i));
     }
     testBuffer.flip();
     return testBuffer;
   }
 
-  private void assertConnectionState(int state) {
-    assertEquals(state, dataSourceUnderTest.connectionState);
-  }
-
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 401941addc..0190668a70 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -28,7 +28,6 @@
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.SystemClock;
-import com.google.android.exoplayer2.util.TraceUtil;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -38,12 +37,11 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
 import org.chromium.net.UrlRequest;
+import org.chromium.net.UrlRequest.Status;
 import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
@@ -86,40 +84,45 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
   public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
 
   private static final String TAG = "CronetDataSource";
+  private static final String CONTENT_TYPE = "Content-Type";
   private static final Pattern CONTENT_RANGE_HEADER_PATTERN =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
   // The size of read buffer passed to cronet UrlRequest.read().
   private static final int READ_BUFFER_SIZE_BYTES = 32 * 1024;
 
-  /* package */ static final int IDLE_CONNECTION = 5;
-  /* package */ static final int OPENING_CONNECTION = 2;
-  /* package */ static final int CONNECTED_CONNECTION = 3;
-  /* package */ static final int OPEN_CONNECTION = 4;
-
   private final CronetEngine cronetEngine;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener transferListener;
+  private final TransferListener<? super CronetDataSource> listener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
   private final Map<String, String> requestProperties;
   private final ConditionVariable operation;
-  private final ByteBuffer readBuffer;
   private final Clock clock;
 
+  // Accessed by the calling thread only.
+  private boolean opened;
+  private long bytesToSkip;
+  private long bytesRemaining;
+
+  // Written from the calling thread only. currentUrlRequest.start() calls ensure writes are visible
+  // to reads made by the Cronet thread.
   private UrlRequest currentUrlRequest;
   private DataSpec currentDataSpec;
+
+  // Reference written and read by calling thread only. Passed to Cronet thread as a local variable.
+  // operation.open() calls ensure writes into the buffer are visible to reads made by the calling
+  // thread.
+  private ByteBuffer readBuffer;
+
+  // Written from the Cronet thread only. operation.open() calls ensure writes are visible to reads
+  // made by the calling thread.
   private UrlResponseInfo responseInfo;
+  private IOException exception;
+  private boolean finished;
 
-  /* package */ volatile int connectionState;
-  private volatile String currentUrl;
   private volatile long currentConnectTimeoutMs;
-  private volatile HttpDataSourceException exception;
-  private volatile long contentLength;
-  private volatile AtomicLong expectedBytesRemainingToRead;
-  private volatile boolean hasData;
-  private volatile boolean responseFinished;
 
   /**
    * @param cronetEngine A CronetEngine.
@@ -127,12 +130,12 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then an {@link InvalidContentTypeException} is thrown from
    *     {@link #open(DataSpec)}.
-   * @param transferListener A listener.
+   * @param listener An optional listener.
    */
   public CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener transferListener) {
-    this(cronetEngine, executor, contentTypePredicate, transferListener,
-        DEFAULT_CONNECT_TIMEOUT_MILLIS, DEFAULT_READ_TIMEOUT_MILLIS, false);
+      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener) {
+    this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS, false);
   }
 
   /**
@@ -141,35 +144,35 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then an {@link InvalidContentTypeException} is thrown from
    *     {@link #open(DataSpec)}.
-   * @param transferListener A listener.
+   * @param listener An optional listener.
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
    */
   public CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener transferListener,
+      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
       int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects) {
-    this(cronetEngine, executor, contentTypePredicate, transferListener, connectTimeoutMs,
+    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
         readTimeoutMs, resetTimeoutOnRedirects, new SystemClock());
   }
 
   /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
-      Predicate<String> contentTypePredicate, TransferListener transferListener,
+      Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
       int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock) {
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
     this.contentTypePredicate = contentTypePredicate;
-    this.transferListener = transferListener;
+    this.listener = listener;
     this.connectTimeoutMs = connectTimeoutMs;
     this.readTimeoutMs = readTimeoutMs;
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
     this.clock = Assertions.checkNotNull(clock);
-    readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
     requestProperties = new HashMap<>();
     operation = new ConditionVariable();
-    connectionState = IDLE_CONNECTION;
   }
 
+  // HttpDataSource implementation.
+
   @Override
   public void setRequestProperty(String name, String value) {
     synchronized (requestProperties) {
@@ -197,258 +200,156 @@ public void clearAllRequestProperties() {
   }
 
   @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.open");
-    try {
-      Assertions.checkNotNull(dataSpec);
-      synchronized (this) {
-        Assertions.checkState(connectionState == IDLE_CONNECTION, "Connection already open");
-        connectionState = OPENING_CONNECTION;
-      }
-
-      operation.close();
-      resetConnectTimeout();
-      startRequest(dataSpec);
-      boolean requestStarted = blockUntilConnectTimeout();
-
-      if (exception != null) {
-        // An error occurred opening the connection.
-        throw exception;
-      } else if (!requestStarted) {
-        // The timeout was reached before the connection was opened.
-        throw new OpenException(new SocketTimeoutException(), dataSpec, getCurrentRequestStatus());
-      }
-
-      // Connection was opened.
-      if (transferListener != null) {
-        transferListener.onTransferStart(this, dataSpec);
-      }
-      connectionState = OPEN_CONNECTION;
-      return contentLength;
-    } finally {
-      TraceUtil.endSection();
-    }
-  }
-
-  private void startRequest(DataSpec dataSpec) throws HttpDataSourceException {
-    currentUrl = dataSpec.uri.toString();
-    currentDataSpec = dataSpec;
-    UrlRequest.Builder urlRequestBuilder = new UrlRequest.Builder(currentUrl, this, executor,
-        cronetEngine);
-    fillCurrentRequestHeader(urlRequestBuilder);
-    fillCurrentRequestPostBody(urlRequestBuilder, dataSpec);
-    currentUrlRequest = urlRequestBuilder.build();
-    currentUrlRequest.start();
-  }
-
-  private void fillCurrentRequestHeader(UrlRequest.Builder urlRequestBuilder) {
-    synchronized (requestProperties) {
-      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
-        urlRequestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
-      }
-    }
-    if (currentDataSpec.position == 0 && currentDataSpec.length == C.LENGTH_UNSET) {
-      // Not required.
-      return;
-    }
-    StringBuilder rangeValue = new StringBuilder();
-    rangeValue.append("bytes=");
-    rangeValue.append(currentDataSpec.position);
-    rangeValue.append("-");
-    if (currentDataSpec.length != C.LENGTH_UNSET) {
-      rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
-    }
-    urlRequestBuilder.addHeader("Range", rangeValue.toString());
-  }
-
-  private void fillCurrentRequestPostBody(UrlRequest.Builder urlRequestBuilder, DataSpec dataSpec)
-      throws HttpDataSourceException {
-    if (dataSpec.postBody != null) {
-      if (!requestProperties.containsKey("Content-Type")) {
-        throw new OpenException("POST requests must set a Content-Type header", dataSpec,
-            getCurrentRequestStatus());
-      }
-      urlRequestBuilder.setUploadDataProvider(
-          new ByteArrayUploadDataProvider(dataSpec.postBody), executor);
-    }
-  }
-
-  @Override
-  public synchronized void onFailed(
-       UrlRequest request, UrlResponseInfo info, UrlRequestException error) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    if (connectionState == OPENING_CONNECTION) {
-      IOException cause = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-          ? new UnknownHostException() : error;
-      exception = new OpenException(cause, currentDataSpec, getCurrentRequestStatus());
-    } else if (connectionState == OPEN_CONNECTION) {
-      readBuffer.limit(0);
-      exception = new HttpDataSourceException(error, currentDataSpec,
-          HttpDataSourceException.TYPE_READ);
-    }
-    operation.open();
+  public Uri getUri() {
+    return responseInfo == null ? null : Uri.parse(responseInfo.getUrl());
   }
 
   @Override
-  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    TraceUtil.beginSection("CronetDataSource.onResponseStarted");
-    try {
-      validateResponse(info);
-      responseInfo = info;
-      // Check content length.
-      contentLength = getContentLength(info.getAllHeaders());
-      // If a specific length is requested and a specific length is returned but the 2 don't match
-      // it's an error.
-      if (currentDataSpec.length != C.LENGTH_UNSET
-          && contentLength != C.LENGTH_UNSET
-          && currentDataSpec.length != contentLength) {
-        throw new OpenException("Content length did not match requested length", currentDataSpec,
-            getCurrentRequestStatus());
-      }
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    Assertions.checkNotNull(dataSpec);
+    Assertions.checkState(!opened);
 
-      if (contentLength > 0) {
-        expectedBytesRemainingToRead = new AtomicLong(contentLength);
-      }
+    operation.close();
+    resetConnectTimeout();
+    currentDataSpec = dataSpec;
+    currentUrlRequest = buildRequest(dataSpec);
+    currentUrlRequest.start();
+    boolean requestStarted = blockUntilConnectTimeout();
 
-      // Keep track of redirects.
-      currentUrl = responseInfo.getUrl();
-      connectionState = CONNECTED_CONNECTION;
-    } catch (HttpDataSourceException e) {
-      exception = e;
-    } finally {
-      operation.open();
-      TraceUtil.endSection();
+    if (exception != null) {
+      throw new OpenException(exception, currentDataSpec, getStatus(currentUrlRequest));
+    } else if (!requestStarted) {
+      // The timeout was reached before the connection was opened.
+      throw new OpenException(new SocketTimeoutException(), dataSpec, getStatus(currentUrlRequest));
     }
-  }
 
-  private void validateResponse(UrlResponseInfo info) throws HttpDataSourceException {
     // Check for a valid response code.
-    int responseCode = info.getHttpStatusCode();
+    int responseCode = responseInfo.getHttpStatusCode();
     if (responseCode < 200 || responseCode > 299) {
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(
-          responseCode, info.getAllHeaders(), currentDataSpec);
+      InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode,
+          responseInfo.getAllHeaders(), currentDataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
       throw exception;
     }
+
     // Check for a valid content type.
-    try {
-      String contentType = info.getAllHeaders().get("Content-Type").get(0);
-      if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+    if (contentTypePredicate != null) {
+      List<String> contentTypeHeaders = responseInfo.getAllHeaders().get(CONTENT_TYPE);
+      String contentType = isEmpty(contentTypeHeaders) ? null : contentTypeHeaders.get(0);
+      if (!contentTypePredicate.evaluate(contentType)) {
         throw new InvalidContentTypeException(contentType, currentDataSpec);
       }
-    } catch (IndexOutOfBoundsException e) {
-      throw new InvalidContentTypeException(null, currentDataSpec);
     }
-  }
 
-  private long getContentLength(Map<String, List<String>> headers) {
-    // Logic copied from {@code DefaultHttpDataSource}
-    long contentLength = C.LENGTH_UNSET;
-    List<String> contentLengthHeader = headers.get("Content-Length");
-    if (contentLengthHeader != null
-        && !contentLengthHeader.isEmpty()
-        && !TextUtils.isEmpty(contentLengthHeader.get(0))) {
-      try {
-        contentLength = Long.parseLong(contentLengthHeader.get(0));
-      } catch (NumberFormatException e) {
-        log(Log.ERROR, "Unexpected Content-Length [" + contentLengthHeader + "]");
+    // If we requested a range starting from a non-zero position and received a 200 rather than a
+    // 206, then the server does not support partial requests. We'll need to manually skip to the
+    // requested position.
+    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+    // Calculate the content length.
+    if (!getIsCompressed(responseInfo)) {
+      if (dataSpec.length != C.LENGTH_UNSET) {
+        bytesRemaining = dataSpec.length;
+      } else {
+        bytesRemaining = getContentLength(responseInfo);
       }
+    } else {
+      // If the response is compressed then the content length will be that of the compressed data
+      // which isn't what we want. Always use the dataSpec length in this case.
+      bytesRemaining = currentDataSpec.length;
     }
-    List<String> contentRangeHeader = headers.get("Content-Range");
-    if (contentRangeHeader != null
-        && !contentRangeHeader.isEmpty()
-        && !TextUtils.isEmpty(contentRangeHeader.get(0))) {
-      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader.get(0));
-      if (matcher.find()) {
-        try {
-          long contentLengthFromRange =
-              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
-          if (contentLength < 0) {
-            // Some proxy servers strip the Content-Length header. Fall back to the length
-            // calculated here in this case.
-            contentLength = contentLengthFromRange;
-          } else if (contentLength != contentLengthFromRange) {
-            // If there is a discrepancy between the Content-Length and Content-Range headers,
-            // assume the one with the larger value is correct. We have seen cases where carrier
-            // change one of them to reduce the size of a request, but it is unlikely anybody
-            // would increase it.
-            log(Log.WARN, "Inconsistent headers [" + contentLengthHeader + "] ["
-                + contentRangeHeader + "]");
-            contentLength = Math.max(contentLength, contentLengthFromRange);
-          }
-        } catch (NumberFormatException e) {
-          log(Log.ERROR, "Unexpected Content-Range [" + contentRangeHeader + "]");
-        }
-      }
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart(this, dataSpec);
     }
-    return contentLength;
+
+    return bytesRemaining;
   }
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.read");
-    try {
-      synchronized (this) {
-        if (connectionState != OPEN_CONNECTION) {
-          throw new IllegalStateException("Connection not ready");
-        }
-      }
+    Assertions.checkState(opened);
 
-      // If being asked to read beyond the amount of bytes initially requested, return
-      // RESULT_END_OF_INPUT.
-      if (expectedBytesRemainingToRead != null && expectedBytesRemainingToRead.get() <= 0) {
-        return C.RESULT_END_OF_INPUT;
-      }
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
+      return C.RESULT_END_OF_INPUT;
+    }
 
-      if (!hasData) {
-        // Read more data from cronet.
-        operation.close();
-        currentUrlRequest.read(readBuffer);
-        if (!operation.block(readTimeoutMs)) {
-          throw new HttpDataSourceException(
-              new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
-        }
-        if (exception != null) {
-          throw exception;
-        }
-        // The expected response length is unknown, but cronet has indicated that the request
-        // already finished successfully.
-        if (responseFinished) {
-          return C.RESULT_END_OF_INPUT;
+    if (readBuffer == null) {
+      readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+      readBuffer.limit(0);
+    }
+    while (!readBuffer.hasRemaining()) {
+      // Fill readBuffer with more data from Cronet.
+      operation.close();
+      readBuffer.clear();
+      currentUrlRequest.read(readBuffer);
+      if (!operation.block(readTimeoutMs)) {
+        // We're timing out, but since the operation is still ongoing we'll need to replace
+        // readBuffer to avoid the possibility of it being written to by this operation during a
+        // subsequent request.
+        readBuffer = null;
+        throw new HttpDataSourceException(
+            new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
+      } else if (exception != null) {
+        throw new HttpDataSourceException(exception, currentDataSpec,
+            HttpDataSourceException.TYPE_READ);
+      } else if (finished) {
+        return C.RESULT_END_OF_INPUT;
+      } else {
+        // The operation didn't time out, fail or finish, and therefore data must have been read.
+        readBuffer.flip();
+        Assertions.checkState(readBuffer.hasRemaining());
+        if (bytesToSkip > 0) {
+          int bytesSkipped = (int) Math.min(readBuffer.remaining(), bytesToSkip);
+          readBuffer.position(readBuffer.position() + bytesSkipped);
+          bytesToSkip -= bytesSkipped;
         }
       }
+    }
 
-      int bytesRead = Math.min(readBuffer.remaining(), readLength);
-
-      readBuffer.get(buffer, offset, bytesRead);
-
-      if (!readBuffer.hasRemaining()) {
-        readBuffer.clear();
-        hasData = false;
-      }
+    int bytesRead = Math.min(readBuffer.remaining(), readLength);
+    readBuffer.get(buffer, offset, bytesRead);
 
-      if (expectedBytesRemainingToRead != null) {
-        expectedBytesRemainingToRead.addAndGet(-bytesRead);
-      }
+    if (bytesRemaining != C.LENGTH_UNSET) {
+      bytesRemaining -= bytesRead;
+    }
+    if (listener != null) {
+      listener.onBytesTransferred(this, bytesRead);
+    }
+    return bytesRead;
+  }
 
-      if (transferListener != null && bytesRead >= 0) {
-        transferListener.onBytesTransferred(this, bytesRead);
+  @Override
+  public synchronized void close() {
+    if (currentUrlRequest != null) {
+      currentUrlRequest.cancel();
+      currentUrlRequest = null;
+    }
+    if (readBuffer != null) {
+      readBuffer.limit(0);
+    }
+    currentDataSpec = null;
+    responseInfo = null;
+    exception = null;
+    finished = false;
+    if (opened) {
+      opened = false;
+      if (listener != null) {
+        listener.onTransferEnd(this);
       }
-      return bytesRead;
-    } finally {
-      TraceUtil.endSection();
     }
   }
 
+  // UrlRequest.Callback implementation
+
   @Override
-  public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
+  public synchronized void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
+      String newLocationUrl) {
     if (request != currentUrlRequest) {
       return;
     }
@@ -458,8 +359,8 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
       // For other redirect response codes the POST request is converted to a GET request and the
       // redirect is followed.
       if (responseCode == 307 || responseCode == 308) {
-        exception = new OpenException("POST request redirected with 307 or 308 response code",
-            currentDataSpec, getCurrentRequestStatus());
+        exception = new InvalidResponseCodeException(responseCode, info.getAllHeaders(),
+            currentDataSpec);
         operation.open();
         return;
       }
@@ -471,78 +372,79 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
   }
 
   @Override
-  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
-      ByteBuffer buffer) {
+  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
     if (request != currentUrlRequest) {
       return;
     }
-    readBuffer.flip();
-    if (readBuffer.limit() > 0) {
-      hasData = true;
-    }
+    responseInfo = info;
     operation.open();
   }
 
   @Override
-  public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
+      ByteBuffer buffer) {
     if (request != currentUrlRequest) {
       return;
     }
-    responseFinished = true;
     operation.open();
   }
 
   @Override
-  public synchronized void close() {
-    TraceUtil.beginSection("CronetDataSource.close");
-    try {
-      if (currentUrlRequest != null) {
-        currentUrlRequest.cancel();
-        currentUrlRequest = null;
-      }
-      readBuffer.clear();
-      currentDataSpec = null;
-      currentUrl = null;
-      exception = null;
-      contentLength = 0;
-      hasData = false;
-      responseInfo = null;
-      expectedBytesRemainingToRead = null;
-      responseFinished = false;
-      if (transferListener != null && connectionState == OPEN_CONNECTION) {
-        transferListener.onTransferEnd(this);
-      }
-    } finally {
-      connectionState = IDLE_CONNECTION;
-      TraceUtil.endSection();
+  public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    finished = true;
+    operation.open();
   }
 
   @Override
-  public Uri getUri() {
-    return Uri.parse(currentUrl);
-  }
-
-  private void log(int priority, String message) {
-    if (Log.isLoggable(TAG, priority)) {
-      Log.println(priority, TAG, message);
+  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
+      UrlRequestException error) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
+        ? new UnknownHostException() : error;
+    operation.open();
   }
 
-  private int getCurrentRequestStatus() {
-    if (currentUrlRequest == null) {
-      return UrlRequest.Status.IDLE;
+  // Internal methods.
+
+  private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
+    UrlRequest.Builder requestBuilder = new UrlRequest.Builder(dataSpec.uri.toString(), this,
+        executor, cronetEngine);
+    // Set the headers.
+    synchronized (requestProperties) {
+      if (dataSpec.postBody != null && dataSpec.postBody.length != 0
+          && !requestProperties.containsKey(CONTENT_TYPE)) {
+        throw new OpenException("POST request with non-empty body must set Content-Type", dataSpec,
+            Status.IDLE);
+      }
+      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
+        requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+      }
     }
-    final ConditionVariable conditionVariable = new ConditionVariable();
-    final AtomicInteger result = new AtomicInteger();
-    currentUrlRequest.getStatus(new UrlRequest.StatusListener() {
-      @Override
-      public void onStatus(int status) {
-        result.set(status);
-        conditionVariable.open();
+    // Set the Range header.
+    if (currentDataSpec.position != 0 || currentDataSpec.length != C.LENGTH_UNSET) {
+      StringBuilder rangeValue = new StringBuilder();
+      rangeValue.append("bytes=");
+      rangeValue.append(currentDataSpec.position);
+      rangeValue.append("-");
+      if (currentDataSpec.length != C.LENGTH_UNSET) {
+        rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
       }
-    });
-    return result.get();
+      requestBuilder.addHeader("Range", rangeValue.toString());
+    }
+    // Set the method and (if non-empty) the body.
+    if (dataSpec.postBody != null) {
+      requestBuilder.setHttpMethod("POST");
+      if (dataSpec.postBody.length != 0) {
+        requestBuilder.setUploadDataProvider(new ByteArrayUploadDataProvider(dataSpec.postBody),
+            executor);
+      }
+    }
+    return requestBuilder.build();
   }
 
   private boolean blockUntilConnectTimeout() {
@@ -559,4 +461,75 @@ private void resetConnectTimeout() {
     currentConnectTimeoutMs = clock.elapsedRealtime() + connectTimeoutMs;
   }
 
+  private static boolean getIsCompressed(UrlResponseInfo info) {
+    for (Map.Entry<String, String> entry : info.getAllHeadersAsList()) {
+      if (entry.getKey().equalsIgnoreCase("Content-Encoding")) {
+        return !entry.getValue().equalsIgnoreCase("identity");
+      }
+    }
+    return false;
+  }
+
+  private static long getContentLength(UrlResponseInfo info) {
+    long contentLength = C.LENGTH_UNSET;
+    Map<String, List<String>> headers = info.getAllHeaders();
+    List<String> contentLengthHeaders = headers.get("Content-Length");
+    String contentLengthHeader = null;
+    if (!isEmpty(contentLengthHeaders)) {
+      contentLengthHeader = contentLengthHeaders.get(0);
+      if (!TextUtils.isEmpty(contentLengthHeader)) {
+        try {
+          contentLength = Long.parseLong(contentLengthHeader);
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
+        }
+      }
+    }
+    List<String> contentRangeHeaders = headers.get("Content-Range");
+    if (!isEmpty(contentRangeHeaders)) {
+      String contentRangeHeader = contentRangeHeaders.get(0);
+      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader);
+      if (matcher.find()) {
+        try {
+          long contentLengthFromRange =
+              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+          if (contentLength < 0) {
+            // Some proxy servers strip the Content-Length header. Fall back to the length
+            // calculated here in this case.
+            contentLength = contentLengthFromRange;
+          } else if (contentLength != contentLengthFromRange) {
+            // If there is a discrepancy between the Content-Length and Content-Range headers,
+            // assume the one with the larger value is correct. We have seen cases where carrier
+            // change one of them to reduce the size of a request, but it is unlikely anybody
+            // would increase it.
+            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
+                + "]");
+            contentLength = Math.max(contentLength, contentLengthFromRange);
+          }
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
+        }
+      }
+    }
+    return contentLength;
+  }
+
+  private static int getStatus(UrlRequest request) {
+    final ConditionVariable conditionVariable = new ConditionVariable();
+    final int[] statusHolder = new int[1];
+    request.getStatus(new UrlRequest.StatusListener() {
+      @Override
+      public void onStatus(int status) {
+        statusHolder[0] = status;
+        conditionVariable.open();
+      }
+    });
+    conditionVariable.block();
+    return statusHolder[0];
+  }
+
+  private static boolean isEmpty(List<?> list) {
+    return list == null || list.isEmpty();
+  }
+
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index 1cffee8188..0f94dad158 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -41,7 +41,7 @@
   private final CronetEngine cronetEngine;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener transferListener;
+  private final TransferListener<? super DataSource> transferListener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index 5df912ace2..29a22f380a 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -71,7 +72,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibflacAudioRenderer audioRenderer = new LibflacAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(null);
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
diff --git a/extensions/okhttp/README.md b/extensions/okhttp/README.md
index 06cd324be2..d84dcb44ec 100644
--- a/extensions/okhttp/README.md
+++ b/extensions/okhttp/README.md
@@ -2,8 +2,29 @@
 
 ## Description ##
 
-The OkHttp Extension is an [HttpDataSource][] implementation using Square's [OkHttp][].
+The OkHttp Extension is an [HttpDataSource][] implementation using Square's
+[OkHttp][].
+
+## Using the extension ##
+
+The easiest way to use the extension is to add it as a gradle dependency. You
+need to make sure you have the jcenter repository included in the `build.gradle`
+file in the root of your project:
+
+```gradle
+repositories {
+    jcenter()
+}
+```
+
+Next, include the following in your module's `build.gradle` file:
+
+```gradle
+compile 'com.google.android.exoplayer:extension-okhttp:rX.X.X'
+```
+
+where `rX.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
 
 [HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html
 [OkHttp]: https://square.github.io/okhttp/
-
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index baadb6a50b..c7555e9ced 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 apply plugin: 'com.android.library'
+apply plugin: 'bintray-release'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
@@ -40,3 +41,13 @@ dependencies {
         exclude group: 'org.json'
     }
 }
+
+publish {
+    artifactId = 'extension-okhttp'
+    description = 'An OkHttp extension for ExoPlayer.'
+    repoName = releaseRepoName
+    userOrg = releaseUserOrg
+    groupId = releaseGroupId
+    version = releaseVersion
+    website = releaseWebsite
+}
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index e6ecd77d02..2b6eaa736d 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -32,21 +32,21 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.CacheControl;
+import okhttp3.Call;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 
 /**
- * An {@link HttpDataSource} that delegates to Square's {@link OkHttpClient}.
+ * An {@link HttpDataSource} that delegates to Square's {@link Call.Factory}.
  */
 public class OkHttpDataSource implements HttpDataSource {
 
   private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
 
-  private final OkHttpClient okHttpClient;
+  private final Call.Factory callFactory;
   private final String userAgent;
   private final Predicate<String> contentTypePredicate;
   private final TransferListener<? super OkHttpDataSource> listener;
@@ -65,31 +65,31 @@
   private long bytesRead;
 
   /**
-   * @param client An {@link OkHttpClient} for use by the source.
+   * @param callFactory An {@link Call.Factory} for use by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
    */
-  public OkHttpDataSource(OkHttpClient client, String userAgent,
+  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate) {
-    this(client, userAgent, contentTypePredicate, null);
+    this(callFactory, userAgent, contentTypePredicate, null);
   }
 
   /**
-   * @param client An {@link OkHttpClient} for use by the source.
+   * @param callFactory An {@link Call.Factory} for use by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a {@link InvalidContentTypeException} is thrown from
    *     {@link #open(DataSpec)}.
    * @param listener An optional listener.
    */
-  public OkHttpDataSource(OkHttpClient client, String userAgent,
+  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener) {
-    this(client, userAgent, contentTypePredicate, listener, null);
+    this(callFactory, userAgent, contentTypePredicate, listener, null);
   }
 
   /**
-   * @param client An {@link OkHttpClient} for use by the source.
+   * @param callFactory An {@link Call.Factory} for use by the source.
    * @param userAgent The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
    *     predicate then a {@link InvalidContentTypeException} is thrown from
@@ -98,10 +98,10 @@ public OkHttpDataSource(OkHttpClient client, String userAgent,
    * @param cacheControl An optional {@link CacheControl} which sets all requests' Cache-Control
    *     header. For example, you could force the network response for all requests.
    */
-  public OkHttpDataSource(OkHttpClient client, String userAgent,
+  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
       CacheControl cacheControl) {
-    this.okHttpClient = Assertions.checkNotNull(client);
+    this.callFactory = Assertions.checkNotNull(callFactory);
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
     this.listener = listener;
@@ -150,7 +150,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.bytesSkipped = 0;
     Request request = makeRequest(dataSpec);
     try {
-      response = okHttpClient.newCall(request).execute();
+      response = callFactory.newCall(request).execute();
       responseByteStream = response.body().byteStream();
     } catch (IOException e) {
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
@@ -185,9 +185,12 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
-    long contentLength = response.body().contentLength();
-    bytesToRead = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length
-        : (contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET);
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      bytesToRead = dataSpec.length;
+    } else {
+      long contentLength = response.body().contentLength();
+      bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
+    }
 
     opened = true;
     if (listener != null) {
@@ -338,17 +341,21 @@ private void skipInternal() throws IOException {
    * @throws IOException If an error occurs reading from the source.
    */
   private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
-    readLength = bytesToRead == C.LENGTH_UNSET ? readLength
-        : (int) Math.min(readLength, bytesToRead - bytesRead);
     if (readLength == 0) {
-      // We've read all of the requested data.
-      return C.RESULT_END_OF_INPUT;
+      return 0;
+    }
+    if (bytesToRead != C.LENGTH_UNSET) {
+      long bytesRemaining = bytesToRead - bytesRead;
+      if (bytesRemaining == 0) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      readLength = (int) Math.min(readLength, bytesRemaining);
     }
 
     int read = responseByteStream.read(buffer, offset, readLength);
     if (read == -1) {
-      if (bytesToRead != C.LENGTH_UNSET && bytesToRead != bytesRead) {
-        // The server closed the connection having not sent sufficient data.
+      if (bytesToRead != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
         throw new EOFException();
       }
       return C.RESULT_END_OF_INPUT;
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 1cfb7219d6..a4dd10a8d3 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -19,26 +19,26 @@
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import okhttp3.CacheControl;
-import okhttp3.OkHttpClient;
+import okhttp3.Call;
 
 /**
  * A {@link Factory} that produces {@link OkHttpDataSource}.
  */
 public final class OkHttpDataSourceFactory implements Factory {
 
-  private final OkHttpClient client;
+  private final Call.Factory callFactory;
   private final String userAgent;
   private final TransferListener<? super DataSource> transferListener;
   private final CacheControl cacheControl;
 
-  public OkHttpDataSourceFactory(OkHttpClient client, String userAgent,
+  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
       TransferListener<? super DataSource> transferListener) {
-    this(client, userAgent, transferListener, null);
+    this(callFactory, userAgent, transferListener, null);
   }
 
-  public OkHttpDataSourceFactory(OkHttpClient client, String userAgent,
+  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
       TransferListener<? super DataSource> transferListener, CacheControl cacheControl) {
-    this.client = client;
+    this.callFactory = callFactory;
     this.userAgent = userAgent;
     this.transferListener = transferListener;
     this.cacheControl = cacheControl;
@@ -46,7 +46,7 @@ public OkHttpDataSourceFactory(OkHttpClient client, String userAgent,
 
   @Override
   public OkHttpDataSource createDataSource() {
-    return new OkHttpDataSource(client, userAgent, null, transferListener, cacheControl);
+    return new OkHttpDataSource(callFactory, userAgent, null, transferListener, cacheControl);
   }
 
 }
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index 1f554cbebc..4f723698a4 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -71,7 +72,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibopusAudioRenderer audioRenderer = new LibopusAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(null);
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 553157605e..c5f61cf231 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Handler;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -87,7 +88,7 @@ public TestPlaybackThread(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibvpxVideoRenderer videoRenderer = new LibvpxVideoRenderer(true, 0);
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(null);
+      DefaultTrackSelector trackSelector = new DefaultTrackSelector(new Handler());
       player = ExoPlayerFactory.newInstance(new Renderer[] {videoRenderer}, trackSelector);
       player.addListener(this);
       ExtractorMediaSource mediaSource = new ExtractorMediaSource(
diff --git a/library/build.gradle b/library/build.gradle
index d301e0903e..42e7cb3bb1 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -55,6 +55,7 @@ dependencies {
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'org.mockito:mockito-core:1.9.5'
+    compile 'com.android.support:support-annotations:24.2.0'
 }
 
 android.libraryVariants.all { variant ->
@@ -91,11 +92,11 @@ android.libraryVariants.all { variant ->
 }
 
 publish {
-    repoName = 'exoplayer'
-    userOrg = 'google'
-    groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r2.0.0'
     description = 'The ExoPlayer library.'
-    website = 'https://github.com/google/ExoPlayer'
+    repoName = releaseRepoName
+    userOrg = releaseUserOrg
+    groupId = releaseGroupId
+    version = releaseVersion
+    website = releaseWebsite
 }
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3 b/library/src/androidTest/assets/mp3/play-trimmed.mp3
new file mode 100644
index 0000000000..d103ac5781
Binary files /dev/null and b/library/src/androidTest/assets/mp3/play-trimmed.mp3 differ
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump b/library/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump
new file mode 100644
index 0000000000..37a04215ee
--- /dev/null
+++ b/library/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump
@@ -0,0 +1,33 @@
+seekMap:
+  isSeekable = true
+  duration = 26125
+  getPosition(0) = 0
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/mpeg
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 2
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 1
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 418, hash B819987
+tracksEnded = true
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump b/library/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump
new file mode 100644
index 0000000000..0b6516ccdb
--- /dev/null
+++ b/library/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump
@@ -0,0 +1,29 @@
+seekMap:
+  isSeekable = true
+  duration = 26125
+  getPosition(0) = 0
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/mpeg
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 2
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 0
+tracksEnded = true
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump b/library/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump
new file mode 100644
index 0000000000..0b6516ccdb
--- /dev/null
+++ b/library/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump
@@ -0,0 +1,29 @@
+seekMap:
+  isSeekable = true
+  duration = 26125
+  getPosition(0) = 0
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/mpeg
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 2
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 0
+tracksEnded = true
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump b/library/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump
new file mode 100644
index 0000000000..0b6516ccdb
--- /dev/null
+++ b/library/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump
@@ -0,0 +1,29 @@
+seekMap:
+  isSeekable = true
+  duration = 26125
+  getPosition(0) = 0
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/mpeg
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 2
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 0
+tracksEnded = true
diff --git a/library/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump b/library/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump
new file mode 100644
index 0000000000..b75aefd91b
--- /dev/null
+++ b/library/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump
@@ -0,0 +1,33 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = 0
+numberOfTracks = 1
+track 0:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = audio/mpeg
+    maxInputSize = 4096
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 2
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 1
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 418, hash B819987
+tracksEnded = true
diff --git a/library/src/androidTest/assets/rawcc/sample.rawcc.0.dump b/library/src/androidTest/assets/rawcc/sample.rawcc.0.dump
index 13e7a93f19..3e84813162 100644
--- a/library/src/androidTest/assets/rawcc/sample.rawcc.0.dump
+++ b/library/src/androidTest/assets/rawcc/sample.rawcc.0.dump
@@ -8,7 +8,7 @@ track 0:
     bitrate = -1
     id = null
     containerMimeType = null
-    sampleMimeType = application/eia-608
+    sampleMimeType = application/cea-608
     maxInputSize = -1
     width = -1
     height = -1
@@ -25,305 +25,605 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
-  sample count = 75
+  sample count = 150
   sample 0:
     time = 37657512133
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7363
   sample 1:
-    time = 37657545511
+    time = 37657528822
     flags = 1
-    data = length 2, hash FFFFF6CD
+    data = length 3, hash 7724
   sample 2:
-    time = 37657578866
+    time = 37657545511
     flags = 1
-    data = length 2, hash FFFFF6DC
+    data = length 3, hash 766F
   sample 3:
-    time = 37657612244
+    time = 37657562177
     flags = 1
-    data = length 2, hash FFFFF65B
+    data = length 3, hash 7724
   sample 4:
-    time = 37657645600
+    time = 37657578866
     flags = 1
-    data = length 2, hash FFFFF6CD
+    data = length 3, hash 767E
   sample 5:
-    time = 37657678977
+    time = 37657595555
     flags = 1
-    data = length 2, hash FFFFF67B
+    data = length 3, hash 7724
   sample 6:
-    time = 37657712333
+    time = 37657612244
     flags = 1
-    data = length 2, hash 2B5
+    data = length 15, hash E4359178
   sample 7:
-    time = 37657745711
+    time = 37657628911
     flags = 1
-    data = length 2, hash F5
+    data = length 3, hash 7724
   sample 8:
-    time = 37657779066
+    time = 37657645600
     flags = 1
-    data = length 2, hash FFFFF87A
+    data = length 12, hash 15EBEB66
   sample 9:
-    time = 37657812444
+    time = 37657662288
     flags = 1
-    data = length 2, hash FFFFF698
+    data = length 3, hash 7724
   sample 10:
-    time = 37657845800
+    time = 37657678977
     flags = 1
-    data = length 2, hash 1F4
+    data = length 3, hash 761D
   sample 11:
-    time = 37657879177
+    time = 37657695644
     flags = 1
-    data = length 2, hash 803
+    data = length 3, hash 7724
   sample 12:
-    time = 37657912533
+    time = 37657712333
     flags = 1
-    data = length 2, hash 1F8
+    data = length 30, hash E181418F
   sample 13:
-    time = 37657945911
+    time = 37657729022
     flags = 1
-    data = length 2, hash 117A
+    data = length 6, hash 36289CE2
   sample 14:
-    time = 37657979266
+    time = 37657745711
     flags = 1
-    data = length 2, hash 166
+    data = length 12, hash 3C304F5B
   sample 15:
-    time = 37658012644
+    time = 37657762377
     flags = 1
-    data = length 2, hash 105A
+    data = length 3, hash 7724
   sample 16:
-    time = 37658046000
+    time = 37657779066
     flags = 1
-    data = length 2, hash FCF
+    data = length 12, hash 88DD8EF6
   sample 17:
-    time = 37658079377
+    time = 37657795755
     flags = 1
-    data = length 2, hash 1253
+    data = length 3, hash 7724
   sample 18:
-    time = 37658112733
+    time = 37657812444
     flags = 1
-    data = length 2, hash 11DA
+    data = length 12, hash 8B411833
   sample 19:
-    time = 37658146111
+    time = 37657829111
     flags = 1
-    data = length 2, hash 795
+    data = length 3, hash 7724
   sample 20:
-    time = 37658179466
+    time = 37657845800
     flags = 1
-    data = length 2, hash 103E
+    data = length 12, hash 742A2DF1
   sample 21:
-    time = 37658212844
+    time = 37657862488
     flags = 1
-    data = length 2, hash 120F
+    data = length 3, hash 7724
   sample 22:
-    time = 37658246200
+    time = 37657879177
     flags = 1
-    data = length 2, hash FFFFF698
+    data = length 12, hash 9A2ECBEE
   sample 23:
-    time = 37658279577
+    time = 37657895844
     flags = 1
-    data = length 2, hash 1F4
+    data = length 3, hash 7724
   sample 24:
-    time = 37658312933
+    time = 37657912533
     flags = 1
-    data = length 2, hash FFFFF71B
+    data = length 12, hash 562688EA
   sample 25:
-    time = 37658346311
+    time = 37657929222
     flags = 1
-    data = length 2, hash F91
+    data = length 3, hash 7724
   sample 26:
-    time = 37658379666
+    time = 37657945911
     flags = 1
-    data = length 2, hash 166
+    data = length 12, hash ADE4B953
   sample 27:
-    time = 37658413044
+    time = 37657962577
     flags = 1
-    data = length 2, hash 1023
+    data = length 3, hash 7724
   sample 28:
-    time = 37658446400
+    time = 37657979266
     flags = 1
-    data = length 2, hash 117A
+    data = length 12, hash F927E3E5
   sample 29:
-    time = 37658479777
+    time = 37657995955
     flags = 1
-    data = length 2, hash 784
+    data = length 3, hash 7724
   sample 30:
-    time = 37658513133
+    time = 37658012644
     flags = 1
-    data = length 2, hash 1F8
+    data = length 12, hash EA327945
   sample 31:
-    time = 37658546511
+    time = 37658029311
     flags = 1
-    data = length 2, hash 10D9
+    data = length 3, hash 7724
   sample 32:
-    time = 37658579866
+    time = 37658046000
     flags = 1
-    data = length 2, hash 935
+    data = length 12, hash 3E5DA13C
   sample 33:
-    time = 37658613244
+    time = 37658062688
     flags = 1
-    data = length 2, hash 2B5
+    data = length 3, hash 7724
   sample 34:
-    time = 37658646600
+    time = 37658079377
     flags = 1
-    data = length 2, hash F5
+    data = length 12, hash BF646AE3
   sample 35:
-    time = 37658679977
+    time = 37658096044
     flags = 1
-    data = length 2, hash FFFFF87A
+    data = length 3, hash 7724
   sample 36:
-    time = 37658713333
+    time = 37658112733
     flags = 1
-    data = length 2, hash FFFFF698
+    data = length 12, hash 41E3BA78
   sample 37:
-    time = 37658746711
+    time = 37658129422
     flags = 1
-    data = length 2, hash 1F4
+    data = length 3, hash 7724
   sample 38:
-    time = 37658780066
+    time = 37658146111
     flags = 1
-    data = length 2, hash 793
+    data = length 12, hash A2945EF6
   sample 39:
-    time = 37658813444
+    time = 37658162777
     flags = 1
-    data = length 2, hash FF0
+    data = length 3, hash 7724
   sample 40:
-    time = 37658846800
+    time = 37658179466
     flags = 1
-    data = length 2, hash 16B
+    data = length 12, hash 26735812
   sample 41:
-    time = 37658880177
+    time = 37658196155
     flags = 1
-    data = length 2, hash 2C0
+    data = length 3, hash 7724
   sample 42:
-    time = 37658913533
+    time = 37658212844
     flags = 1
-    data = length 2, hash FFFFF953
+    data = length 12, hash DC14D3D8
   sample 43:
-    time = 37658946911
+    time = 37658229511
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 44:
-    time = 37658980266
+    time = 37658246200
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 882191BE
   sample 45:
-    time = 37659013644
+    time = 37658262888
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 46:
-    time = 37659047000
+    time = 37658279577
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 8B4886B1
   sample 47:
-    time = 37659080377
+    time = 37658296244
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 48:
-    time = 37659113733
+    time = 37658312933
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 98D98F96
   sample 49:
-    time = 37659147111
+    time = 37658329622
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 50:
-    time = 37659180466
+    time = 37658346311
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 30, hash CF8E53E3
   sample 51:
-    time = 37659213844
+    time = 37658362977
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 6, hash 36289CE2
   sample 52:
-    time = 37659247200
+    time = 37658379666
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash F883C9EE
   sample 53:
-    time = 37659280577
+    time = 37658396355
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 54:
-    time = 37659313933
+    time = 37658413044
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 6E6B2B9C
   sample 55:
-    time = 37659347311
+    time = 37658429711
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 56:
-    time = 37659380666
+    time = 37658446400
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash B4FE7F08
   sample 57:
-    time = 37659414044
+    time = 37658463088
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 58:
-    time = 37659447400
+    time = 37658479777
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 5A1EA7C7
   sample 59:
-    time = 37659480777
+    time = 37658496444
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 60:
-    time = 37659514133
+    time = 37658513133
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 46BD6CC9
   sample 61:
-    time = 37659547511
+    time = 37658529822
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 3, hash 7724
   sample 62:
-    time = 37659580866
+    time = 37658546511
     flags = 1
-    data = length 2, hash FFFFF3C1
+    data = length 12, hash 1B1E2554
   sample 63:
-    time = 37659614244
+    time = 37658563177
     flags = 1
-    data = length 2, hash FFFFF6CD
+    data = length 3, hash 7724
   sample 64:
-    time = 37659647600
+    time = 37658579866
     flags = 1
-    data = length 2, hash FFFFF6DC
+    data = length 12, hash 91FCC537
   sample 65:
-    time = 37659680977
+    time = 37658596555
     flags = 1
-    data = length 2, hash FFFFF65B
+    data = length 3, hash 7724
   sample 66:
-    time = 37659714333
+    time = 37658613244
     flags = 1
-    data = length 2, hash FFFFF6CD
+    data = length 12, hash A9355E1B
   sample 67:
-    time = 37659747711
+    time = 37658629911
     flags = 1
-    data = length 2, hash FFFFF6FF
+    data = length 3, hash 7724
   sample 68:
-    time = 37659781066
+    time = 37658646600
     flags = 1
-    data = length 2, hash FFFFF6AC
+    data = length 12, hash 2511F69B
   sample 69:
-    time = 37659814444
+    time = 37658663288
     flags = 1
-    data = length 2, hash FFFFF5FE
+    data = length 3, hash 7724
   sample 70:
-    time = 37659847800
+    time = 37658679977
     flags = 1
-    data = length 2, hash FFFFFEF7
+    data = length 12, hash 90925736
   sample 71:
-    time = 37659881177
+    time = 37658696644
     flags = 1
-    data = length 2, hash 120C
+    data = length 3, hash 7724
   sample 72:
-    time = 37659914533
+    time = 37658713333
     flags = 1
-    data = length 2, hash 1124
+    data = length 21, hash 431EEE30
   sample 73:
-    time = 37659947911
+    time = 37658730022
     flags = 1
-    data = length 2, hash 1A9
+    data = length 3, hash 7724
   sample 74:
+    time = 37658746711
+    flags = 1
+    data = length 12, hash 7BDEF631
+  sample 75:
+    time = 37658763377
+    flags = 1
+    data = length 3, hash 7724
+  sample 76:
+    time = 37658780066
+    flags = 1
+    data = length 12, hash A2EEF59E
+  sample 77:
+    time = 37658796755
+    flags = 1
+    data = length 3, hash 7724
+  sample 78:
+    time = 37658813444
+    flags = 1
+    data = length 12, hash BFC6C022
+  sample 79:
+    time = 37658830111
+    flags = 1
+    data = length 3, hash 7724
+  sample 80:
+    time = 37658846800
+    flags = 1
+    data = length 12, hash CD4D8FCA
+  sample 81:
+    time = 37658863488
+    flags = 1
+    data = length 3, hash 7724
+  sample 82:
+    time = 37658880177
+    flags = 1
+    data = length 12, hash 2BDE8EFA
+  sample 83:
+    time = 37658896844
+    flags = 1
+    data = length 3, hash 7724
+  sample 84:
+    time = 37658913533
+    flags = 1
+    data = length 12, hash 8C858812
+  sample 85:
+    time = 37658930222
+    flags = 1
+    data = length 3, hash 7724
+  sample 86:
+    time = 37658946911
+    flags = 1
+    data = length 12, hash DE7D0E31
+  sample 87:
+    time = 37658963577
+    flags = 1
+    data = length 3, hash 7724
+  sample 88:
+    time = 37658980266
+    flags = 1
+    data = length 3, hash 7363
+  sample 89:
+    time = 37658996955
+    flags = 1
+    data = length 3, hash 7724
+  sample 90:
+    time = 37659013644
+    flags = 1
+    data = length 3, hash 7363
+  sample 91:
+    time = 37659030311
+    flags = 1
+    data = length 3, hash 7724
+  sample 92:
+    time = 37659047000
+    flags = 1
+    data = length 3, hash 7363
+  sample 93:
+    time = 37659063688
+    flags = 1
+    data = length 3, hash 7724
+  sample 94:
+    time = 37659080377
+    flags = 1
+    data = length 3, hash 7363
+  sample 95:
+    time = 37659097044
+    flags = 1
+    data = length 3, hash 7724
+  sample 96:
+    time = 37659113733
+    flags = 1
+    data = length 3, hash 7363
+  sample 97:
+    time = 37659130422
+    flags = 1
+    data = length 3, hash 7724
+  sample 98:
+    time = 37659147111
+    flags = 1
+    data = length 3, hash 7363
+  sample 99:
+    time = 37659163777
+    flags = 1
+    data = length 3, hash 7724
+  sample 100:
+    time = 37659180466
+    flags = 1
+    data = length 3, hash 7363
+  sample 101:
+    time = 37659197155
+    flags = 1
+    data = length 3, hash 7724
+  sample 102:
+    time = 37659213844
+    flags = 1
+    data = length 3, hash 7363
+  sample 103:
+    time = 37659230511
+    flags = 1
+    data = length 3, hash 7724
+  sample 104:
+    time = 37659247200
+    flags = 1
+    data = length 3, hash 7363
+  sample 105:
+    time = 37659263888
+    flags = 1
+    data = length 3, hash 7724
+  sample 106:
+    time = 37659280577
+    flags = 1
+    data = length 3, hash 7363
+  sample 107:
+    time = 37659297244
+    flags = 1
+    data = length 3, hash 7724
+  sample 108:
+    time = 37659313933
+    flags = 1
+    data = length 3, hash 7363
+  sample 109:
+    time = 37659330622
+    flags = 1
+    data = length 3, hash 7724
+  sample 110:
+    time = 37659347311
+    flags = 1
+    data = length 3, hash 7363
+  sample 111:
+    time = 37659363977
+    flags = 1
+    data = length 3, hash 7724
+  sample 112:
+    time = 37659380666
+    flags = 1
+    data = length 3, hash 7363
+  sample 113:
+    time = 37659397355
+    flags = 1
+    data = length 3, hash 7724
+  sample 114:
+    time = 37659414044
+    flags = 1
+    data = length 3, hash 7363
+  sample 115:
+    time = 37659430711
+    flags = 1
+    data = length 3, hash 7724
+  sample 116:
+    time = 37659447400
+    flags = 1
+    data = length 3, hash 7363
+  sample 117:
+    time = 37659464088
+    flags = 1
+    data = length 3, hash 7724
+  sample 118:
+    time = 37659480777
+    flags = 1
+    data = length 3, hash 7363
+  sample 119:
+    time = 37659497444
+    flags = 1
+    data = length 3, hash 7724
+  sample 120:
+    time = 37659514133
+    flags = 1
+    data = length 3, hash 7363
+  sample 121:
+    time = 37659530822
+    flags = 1
+    data = length 3, hash 7724
+  sample 122:
+    time = 37659547511
+    flags = 1
+    data = length 3, hash 7363
+  sample 123:
+    time = 37659564177
+    flags = 1
+    data = length 3, hash 7724
+  sample 124:
+    time = 37659580866
+    flags = 1
+    data = length 3, hash 7363
+  sample 125:
+    time = 37659597555
+    flags = 1
+    data = length 3, hash 7724
+  sample 126:
+    time = 37659614244
+    flags = 1
+    data = length 3, hash 766F
+  sample 127:
+    time = 37659630911
+    flags = 1
+    data = length 3, hash 7724
+  sample 128:
+    time = 37659647600
+    flags = 1
+    data = length 3, hash 767E
+  sample 129:
+    time = 37659664288
+    flags = 1
+    data = length 3, hash 7724
+  sample 130:
+    time = 37659680977
+    flags = 1
+    data = length 15, hash 191B585A
+  sample 131:
+    time = 37659697644
+    flags = 1
+    data = length 3, hash 7724
+  sample 132:
+    time = 37659714333
+    flags = 1
+    data = length 12, hash 15EC5FC5
+  sample 133:
+    time = 37659731022
+    flags = 1
+    data = length 3, hash 7724
+  sample 134:
+    time = 37659747711
+    flags = 1
+    data = length 3, hash 76A1
+  sample 135:
+    time = 37659764377
+    flags = 1
+    data = length 3, hash 7724
+  sample 136:
+    time = 37659781066
+    flags = 1
+    data = length 30, hash E8012479
+  sample 137:
+    time = 37659797755
+    flags = 1
+    data = length 6, hash 36289D5E
+  sample 138:
+    time = 37659814444
+    flags = 1
+    data = length 12, hash D32F29F3
+  sample 139:
+    time = 37659831111
+    flags = 1
+    data = length 3, hash 7724
+  sample 140:
+    time = 37659847800
+    flags = 1
+    data = length 21, hash 6258623
+  sample 141:
+    time = 37659864488
+    flags = 1
+    data = length 3, hash 7724
+  sample 142:
+    time = 37659881177
+    flags = 1
+    data = length 12, hash FE69ABA2
+  sample 143:
+    time = 37659897844
+    flags = 1
+    data = length 3, hash 7724
+  sample 144:
+    time = 37659914533
+    flags = 1
+    data = length 12, hash 958D0815
+  sample 145:
+    time = 37659931222
+    flags = 1
+    data = length 3, hash 7724
+  sample 146:
+    time = 37659947911
+    flags = 1
+    data = length 12, hash FF57BFD8
+  sample 147:
+    time = 37659964577
+    flags = 1
+    data = length 3, hash 7724
+  sample 148:
     time = 37659981266
     flags = 1
-    data = length 2, hash 935
+    data = length 12, hash 922122E7
+  sample 149:
+    time = 37659997955
+    flags = 1
+    data = length 3, hash 7724
 tracksEnded = true
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index d0ba4d800c..dcab0c6275 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -33,14 +33,14 @@
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8};
   private static final int LARGE_TEST_DATA_LENGTH = 8192;
 
-  public void testInitialPosition() throws IOException {
+  public void testInitialPosition() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input =
         new DefaultExtractorInput(testDataSource, 123, C.LENGTH_UNSET);
     assertEquals(123, input.getPosition());
   }
 
-  public void testRead() throws IOException, InterruptedException {
+  public void testRead() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     // We expect to perform three reads of three bytes, as setup in buildTestDataSource.
@@ -58,7 +58,7 @@ public void testRead() throws IOException, InterruptedException {
     assertEquals(C.RESULT_END_OF_INPUT, expectedEndOfInput);
   }
 
-  public void testReadPeeked() throws IOException, InterruptedException {
+  public void testReadPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -71,7 +71,7 @@ public void testReadPeeked() throws IOException, InterruptedException {
     assertTrue(Arrays.equals(TEST_DATA, target));
   }
 
-  public void testReadMoreDataPeeked() throws IOException, InterruptedException {
+  public void testReadMoreDataPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -84,7 +84,7 @@ public void testReadMoreDataPeeked() throws IOException, InterruptedException {
     assertTrue(Arrays.equals(TEST_DATA, target));
   }
 
-  public void testReadFullyOnce() throws IOException, InterruptedException {
+  public void testReadFullyOnce() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.readFully(target, 0, TEST_DATA.length);
@@ -103,7 +103,7 @@ public void testReadFullyOnce() throws IOException, InterruptedException {
     }
   }
 
-  public void testReadFullyTwice() throws IOException, InterruptedException {
+  public void testReadFullyTwice() throws Exception {
     // Read TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[5];
@@ -116,7 +116,7 @@ public void testReadFullyTwice() throws IOException, InterruptedException {
     assertEquals(5 + 4, input.getPosition());
   }
 
-  public void testReadFullyTooMuch() throws IOException, InterruptedException {
+  public void testReadFullyTooMuch() throws Exception {
     // Read more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
     try {
@@ -141,7 +141,7 @@ public void testReadFullyTooMuch() throws IOException, InterruptedException {
     assertEquals(0, input.getPosition());
   }
 
-  public void testReadFullyWithFailingDataSource() throws IOException, InterruptedException {
+  public void testReadFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     try {
@@ -155,7 +155,7 @@ public void testReadFullyWithFailingDataSource() throws IOException, Interrupted
     assertEquals(0, input.getPosition());
   }
 
-  public void testReadFullyHalfPeeked() throws IOException, InterruptedException {
+  public void testReadFullyHalfPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -168,7 +168,7 @@ public void testReadFullyHalfPeeked() throws IOException, InterruptedException {
     assertEquals(TEST_DATA.length, input.getPosition());
   }
 
-  public void testSkip() throws IOException, InterruptedException {
+  public void testSkip() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     // We expect to perform three skips of three bytes, as setup in buildTestDataSource.
@@ -180,7 +180,7 @@ public void testSkip() throws IOException, InterruptedException {
     assertEquals(C.RESULT_END_OF_INPUT, expectedEndOfInput);
   }
 
-  public void testLargeSkip() throws IOException, InterruptedException {
+  public void testLargeSkip() throws Exception {
     FakeDataSource testDataSource = buildLargeDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     // Check that skipping the entire data source succeeds.
@@ -190,7 +190,7 @@ public void testLargeSkip() throws IOException, InterruptedException {
     }
   }
 
-  public void testSkipFullyOnce() throws IOException, InterruptedException {
+  public void testSkipFullyOnce() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(TEST_DATA.length);
@@ -207,7 +207,7 @@ public void testSkipFullyOnce() throws IOException, InterruptedException {
     }
   }
 
-  public void testSkipFullyTwice() throws IOException, InterruptedException {
+  public void testSkipFullyTwice() throws Exception {
     // Skip TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(5);
@@ -216,7 +216,7 @@ public void testSkipFullyTwice() throws IOException, InterruptedException {
     assertEquals(5 + 4, input.getPosition());
   }
 
-  public void testSkipFullyTwicePeeked() throws IOException, InterruptedException {
+  public void testSkipFullyTwicePeeked() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
 
@@ -230,7 +230,7 @@ public void testSkipFullyTwicePeeked() throws IOException, InterruptedException
     assertEquals(TEST_DATA.length, input.getPosition());
   }
 
-  public void testSkipFullyTooMuch() throws IOException, InterruptedException {
+  public void testSkipFullyTooMuch() throws Exception {
     // Skip more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
     try {
@@ -253,7 +253,7 @@ public void testSkipFullyTooMuch() throws IOException, InterruptedException {
     assertEquals(0, input.getPosition());
   }
 
-  public void testSkipFullyWithFailingDataSource() throws IOException, InterruptedException {
+  public void testSkipFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
     try {
@@ -266,7 +266,7 @@ public void testSkipFullyWithFailingDataSource() throws IOException, Interrupted
     assertEquals(0, input.getPosition());
   }
 
-  public void testSkipFullyLarge() throws IOException, InterruptedException {
+  public void testSkipFullyLarge() throws Exception {
     // Tests skipping an amount of data that's larger than any internal scratch space.
     int largeSkipSize = 1024 * 1024;
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
@@ -286,7 +286,7 @@ public void testSkipFullyLarge() throws IOException, InterruptedException {
     }
   }
 
-  public void testPeekFully() throws IOException, InterruptedException {
+  public void testPeekFully() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
@@ -312,7 +312,7 @@ public void testPeekFully() throws IOException, InterruptedException {
     }
   }
 
-  public void testResetPeekPosition() throws IOException, InterruptedException {
+  public void testResetPeekPosition() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
@@ -336,8 +336,7 @@ public void testResetPeekPosition() throws IOException, InterruptedException {
     }
   }
 
-  public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds()
-      throws IOException, InterruptedException {
+  public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -348,8 +347,24 @@ public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds()
     assertFalse(input.peekFully(target, 0, 1, true));
   }
 
-  public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails()
-      throws IOException, InterruptedException {
+  public void testPeekFullyAtEndThenReadEndOfInput() throws Exception {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    // Peek up to the end of the input.
+    assertTrue(input.peekFully(target, 0, TEST_DATA.length, false));
+
+    // Peek the end of the input.
+    assertFalse(input.peekFully(target, 0, 1, true));
+
+    // Read up to the end of the input.
+    assertTrue(input.readFully(target, 0, TEST_DATA.length, false));
+
+    // Read the end of the input.
+    assertFalse(input.readFully(target, 0, 1, true));
+  }
+
+  public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -365,8 +380,7 @@ public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails()
     }
   }
 
-  public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails()
-      throws IOException, InterruptedException {
+  public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -382,7 +396,7 @@ public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails()
     }
   }
 
-  private static FakeDataSource buildDataSource() throws IOException {
+  private static FakeDataSource buildDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 3));
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 3, 6));
@@ -392,7 +406,7 @@ private static FakeDataSource buildDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static FakeDataSource buildFailingDataSource() throws IOException {
+  private static FakeDataSource buildFailingDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 6));
     builder.appendReadError(new IOException());
@@ -402,7 +416,7 @@ private static FakeDataSource buildFailingDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static FakeDataSource buildLargeDataSource() throws IOException {
+  private static FakeDataSource buildLargeDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(new byte[LARGE_TEST_DATA_LENGTH]);
     FakeDataSource testDataSource = builder.build();
@@ -410,8 +424,9 @@ private static FakeDataSource buildLargeDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static DefaultExtractorInput createDefaultExtractorInput() throws IOException {
+  private static DefaultExtractorInput createDefaultExtractorInput() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     return new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNSET);
   }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
index e268d9f12d..c70710f1ee 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
@@ -33,4 +33,13 @@ public Extractor create() {
     }, "mp3/bear.mp3", getInstrumentation());
   }
 
+  public void testTrimmedMp3Sample() throws Exception {
+    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
+      @Override
+      public Extractor create() {
+        return new Mp3Extractor();
+      }
+    }, "mp3/play-trimmed.mp3", getInstrumentation());
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index 7faea926e0..e19de76466 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -66,9 +68,12 @@
 
   @Override
   protected void setUp() throws Exception {
-    adtsOutput = new FakeTrackOutput();
-    id3Output = new FakeTrackOutput();
-    adtsReader = new AdtsReader(adtsOutput, id3Output);
+    FakeExtractorOutput fakeExtractorOutput = new FakeExtractorOutput();
+    adtsOutput = fakeExtractorOutput.track(0);
+    id3Output = fakeExtractorOutput.track(1);
+    adtsReader = new AdtsReader(true);
+    TrackIdGenerator idGenerator = new TrackIdGenerator(0, 1);
+    adtsReader.init(fakeExtractorOutput, idGenerator);
     data = new ParsableByteArray(TEST_DATA);
     firstFeed = true;
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index 083ade6ac5..1f08507599 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -16,8 +16,18 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.Random;
@@ -61,6 +71,31 @@ public Extractor create() {
     }, "ts/sample.ts", fileData, getInstrumentation());
   }
 
+  public void testCustomPesReader() throws Exception {
+    CustomEsReaderFactory factory = new CustomEsReaderFactory();
+    TsExtractor tsExtractor = new TsExtractor(new TimestampAdjuster(0), factory, false);
+    FakeExtractorInput input = new FakeExtractorInput.Builder()
+        .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample.ts"))
+        .setSimulateIOErrors(false)
+        .setSimulateUnknownLength(false)
+        .setSimulatePartialReads(false).build();
+    FakeExtractorOutput output = new FakeExtractorOutput();
+    tsExtractor.init(output);
+    tsExtractor.seek(input.getPosition());
+    PositionHolder seekPositionHolder = new PositionHolder();
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      readResult = tsExtractor.read(input, seekPositionHolder);
+    }
+    CustomEsReader reader = factory.reader;
+    assertEquals(2, reader.packetsRead);
+    TrackOutput trackOutput = reader.getTrackOutput();
+    assertTrue(trackOutput == output.trackOutputs.get(257 /* PID of audio track. */));
+    assertEquals(
+        Format.createTextSampleFormat("Overriding format", "mime", null, 0, 0, "und", null, 0),
+        ((FakeTrackOutput) trackOutput).format);
+  }
+
   private static void writeJunkData(ByteArrayOutputStream out, int length) throws IOException {
     for (int i = 0; i < length; i++) {
       if (((byte) i) == TS_SYNC_BYTE) {
@@ -71,4 +106,65 @@ private static void writeJunkData(ByteArrayOutputStream out, int length) throws
     }
   }
 
+  private static final class CustomEsReader extends ElementaryStreamReader {
+
+    private final String language;
+    private TrackOutput output;
+    public int packetsRead = 0;
+
+    public CustomEsReader(String language) {
+      this.language = language;
+    }
+
+    @Override
+    public void seek() {
+    }
+
+    @Override
+    public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+      output = extractorOutput.track(idGenerator.getNextId());
+      output.format(Format.createTextSampleFormat("Overriding format", "mime", null, 0, 0,
+          language, null, 0));
+    }
+
+    @Override
+    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    }
+
+    @Override
+    public void consume(ParsableByteArray data) {
+    }
+
+    @Override
+    public void packetFinished() {
+      packetsRead++;
+    }
+
+    public TrackOutput getTrackOutput() {
+      return output;
+    }
+
+  }
+
+  private static final class CustomEsReaderFactory implements ElementaryStreamReader.Factory {
+
+    private final ElementaryStreamReader.Factory defaultFactory;
+    private CustomEsReader reader;
+
+    public CustomEsReaderFactory() {
+      defaultFactory = new DefaultStreamReaderFactory();
+    }
+
+    @Override
+    public ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo) {
+      if (streamType == 3) {
+        reader = new CustomEsReader(esInfo.language);
+        return reader;
+      } else {
+        return defaultFactory.createStreamReader(streamType, esInfo);
+      }
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 85813b391a..8c69524e95 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -17,8 +17,11 @@
 
 import android.media.AudioFormat;
 import android.media.MediaCodec;
+import android.support.annotation.IntDef;
 import android.view.Surface;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.UUID;
 
 /**
@@ -70,55 +73,79 @@ private C() {}
    */
   public static final String UTF8_NAME = "UTF-8";
 
+  /**
+   * Crypto modes for a codec.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({CRYPTO_MODE_UNENCRYPTED, CRYPTO_MODE_AES_CTR, CRYPTO_MODE_AES_CBC})
+  public @interface CryptoMode {}
+  /**
+   * @see MediaCodec#CRYPTO_MODE_UNENCRYPTED
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
   /**
    * @see MediaCodec#CRYPTO_MODE_AES_CTR
    */
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
+  /**
+   * @see MediaCodec#CRYPTO_MODE_AES_CBC
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
+
+  /**
+   * Represents an audio encoding, or an invalid or unset value.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
+      ENCODING_DTS_HD})
+  public @interface Encoding {}
 
+  /**
+   * Represents a PCM audio encoding, or an invalid or unset value.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
+      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
+  public @interface PcmEncoding {}
   /**
    * @see AudioFormat#ENCODING_INVALID
    */
   public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
-
   /**
    * @see AudioFormat#ENCODING_PCM_8BIT
    */
   public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
-
   /**
    * @see AudioFormat#ENCODING_PCM_16BIT
    */
   public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
-
   /**
    * PCM encoding with 24 bits per sample.
    */
   public static final int ENCODING_PCM_24BIT = 0x80000000;
-
   /**
    * PCM encoding with 32 bits per sample.
    */
   public static final int ENCODING_PCM_32BIT = 0x40000000;
-
   /**
    * @see AudioFormat#ENCODING_AC3
    */
   @SuppressWarnings("InlinedApi")
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
-
   /**
    * @see AudioFormat#ENCODING_E_AC3
    */
   @SuppressWarnings("InlinedApi")
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
-
   /**
    * @see AudioFormat#ENCODING_DTS
    */
   @SuppressWarnings("InlinedApi")
   public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
-
   /**
    * @see AudioFormat#ENCODING_DTS_HD
    */
@@ -132,48 +159,93 @@ private C() {}
   public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
       ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
 
+  /**
+   * Flags which can apply to a buffer containing a media sample.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {BUFFER_FLAG_KEY_FRAME, BUFFER_FLAG_END_OF_STREAM,
+      BUFFER_FLAG_ENCRYPTED, BUFFER_FLAG_DECODE_ONLY})
+  public @interface BufferFlags {}
   /**
    * Indicates that a buffer holds a synchronization sample.
    */
   @SuppressWarnings("InlinedApi")
   public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
-
   /**
    * Flag for empty buffers that signal that the end of the stream was reached.
    */
   @SuppressWarnings("InlinedApi")
   public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
-
   /**
    * Indicates that a buffer is (at least partially) encrypted.
    */
   public static final int BUFFER_FLAG_ENCRYPTED = 0x40000000;
-
   /**
    * Indicates that a buffer should be decoded but not rendered.
    */
   public static final int BUFFER_FLAG_DECODE_ONLY = 0x80000000;
 
+  /**
+   * Track selection flags.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {SELECTION_FLAG_DEFAULT, SELECTION_FLAG_FORCED,
+      SELECTION_FLAG_AUTOSELECT})
+  public @interface SelectionFlags {}
+  /**
+   * Indicates that the track should be selected if user preferences do not state otherwise.
+   */
+  public static final int SELECTION_FLAG_DEFAULT = 1;
+  /**
+   * Indicates that the track must be displayed. Only applies to text tracks.
+   */
+  public static final int SELECTION_FLAG_FORCED = 2;
+  /**
+   * Indicates that the player may choose to play the track in absence of an explicit user
+   * preference.
+   */
+  public static final int SELECTION_FLAG_AUTOSELECT = 4;
+
+  /**
+   * Represents a streaming or other media type.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_DASH, TYPE_SS, TYPE_HLS, TYPE_OTHER})
+  public @interface ContentType {}
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for DASH manifests.
+   */
+  public static final int TYPE_DASH = 0;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for Smooth Streaming manifests.
+   */
+  public static final int TYPE_SS = 1;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for HLS manifests.
+   */
+  public static final int TYPE_HLS = 2;
+  /**
+   * Value returned by {@link Util#inferContentType(String)} for files other than DASH, HLS or
+   * Smooth Streaming manifests.
+   */
+  public static final int TYPE_OTHER = 3;
+
   /**
    * A return value for methods where the end of an input was encountered.
    */
   public static final int RESULT_END_OF_INPUT = -1;
-
   /**
    * A return value for methods where the length of parsed data exceeds the maximum length allowed.
    */
   public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
-
   /**
    * A return value for methods where nothing was read.
    */
   public static final int RESULT_NOTHING_READ = -3;
-
   /**
    * A return value for methods where a buffer was read.
    */
   public static final int RESULT_BUFFER_READ = -4;
-
   /**
    * A return value for methods where a format was read.
    */
@@ -183,32 +255,26 @@ private C() {}
    * A data type constant for data of unknown or unspecified type.
    */
   public static final int DATA_TYPE_UNKNOWN = 0;
-
   /**
    * A data type constant for media, typically containing media samples.
    */
   public static final int DATA_TYPE_MEDIA = 1;
-
   /**
    * A data type constant for media, typically containing only initialization data.
    */
   public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
-
   /**
    * A data type constant for drm or encryption data.
    */
   public static final int DATA_TYPE_DRM = 3;
-
   /**
    * A data type constant for a manifest file.
    */
   public static final int DATA_TYPE_MANIFEST = 4;
-
   /**
    * A data type constant for time synchronization data.
    */
   public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
-
   /**
    * Applications or extensions may define custom {@code DATA_TYPE_*} constants greater than or
    * equal to this value.
@@ -219,32 +285,26 @@ private C() {}
    * A type constant for tracks of unknown type.
    */
   public static final int TRACK_TYPE_UNKNOWN = -1;
-
   /**
    * A type constant for tracks of some default type, where the type itself is unknown.
    */
   public static final int TRACK_TYPE_DEFAULT = 0;
-
   /**
    * A type constant for audio tracks.
    */
   public static final int TRACK_TYPE_AUDIO = 1;
-
   /**
    * A type constant for video tracks.
    */
   public static final int TRACK_TYPE_VIDEO = 2;
-
   /**
    * A type constant for text tracks.
    */
   public static final int TRACK_TYPE_TEXT = 3;
-
   /**
    * A type constant for metadata tracks.
    */
   public static final int TRACK_TYPE_METADATA = 4;
-
   /**
    * Applications or extensions may define custom {@code TRACK_TYPE_*} constants greater than or
    * equal to this value.
@@ -255,27 +315,22 @@ private C() {}
    * A selection reason constant for selections whose reasons are unknown or unspecified.
    */
   public static final int SELECTION_REASON_UNKNOWN = 0;
-
   /**
    * A selection reason constant for an initial track selection.
    */
   public static final int SELECTION_REASON_INITIAL = 1;
-
   /**
    * A selection reason constant for an manual (i.e. user initiated) track selection.
    */
   public static final int SELECTION_REASON_MANUAL = 2;
-
   /**
    * A selection reason constant for an adaptive track selection.
    */
   public static final int SELECTION_REASON_ADAPTIVE = 3;
-
   /**
    * A selection reason constant for a trick play track selection.
    */
   public static final int SELECTION_REASON_TRICK_PLAY = 4;
-
   /**
    * Applications or extensions may define custom {@code SELECTION_REASON_*} constants greater than
    * or equal to this value.
@@ -363,16 +418,20 @@ private C() {}
    */
   public static final int MSG_CUSTOM_BASE = 10000;
 
+  /**
+   * The stereo mode for 360/3D/VR videos.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({Format.NO_VALUE, STEREO_MODE_MONO, STEREO_MODE_TOP_BOTTOM, STEREO_MODE_LEFT_RIGHT})
+  public @interface StereoMode {}
   /**
    * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
    */
   public static final int STEREO_MODE_MONO = 0;
-
   /**
    * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
    */
   public static final int STEREO_MODE_TOP_BOTTOM = 1;
-
   /**
    * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index a24a2363a2..e7a0f8b1b8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2;
 
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
 import com.google.android.exoplayer2.util.Util;
@@ -68,7 +68,7 @@
    * Constructs a new instance, using the {@code DEFAULT_*} constants defined in this class.
    */
   public DefaultLoadControl() {
-    this(new DefaultAllocator(C.DEFAULT_BUFFER_SEGMENT_SIZE));
+    this(new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE));
   }
 
   /**
@@ -104,9 +104,14 @@ public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBu
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
   }
 
+  @Override
+  public void onPrepared() {
+    reset(false);
+  }
+
   @Override
   public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
-      TrackSelectionArray trackSelections) {
+      TrackSelections<?> trackSelections) {
     targetBufferSize = 0;
     for (int i = 0; i < renderers.length; i++) {
       if (trackSelections.get(i) != null) {
@@ -117,9 +122,13 @@ public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
   }
 
   @Override
-  public void onTracksDisabled() {
-    targetBufferSize = 0;
-    isBuffering = false;
+  public void onStopped() {
+    reset(true);
+  }
+
+  @Override
+  public void onReleased() {
+    reset(true);
   }
 
   @Override
@@ -147,4 +156,12 @@ private int getBufferTimeState(long bufferedDurationUs) {
         : (bufferedDurationUs < minBufferUs ? BELOW_LOW_WATERMARK : BETWEEN_WATERMARKS);
   }
 
+  private void reset(boolean resetAllocator) {
+    targetBufferSize = 0;
+    isBuffering = false;
+    if (resetAllocator) {
+      allocator.reset();
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index 8f55451712..72ac72e981 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -15,15 +15,24 @@
  */
 package com.google.android.exoplayer2;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Thrown when a non-recoverable playback failure occurs.
  */
 public final class ExoPlaybackException extends Exception {
 
+  /**
+   * The type of source that produced the error.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_SOURCE, TYPE_RENDERER, TYPE_UNEXPECTED})
+  public @interface Type {}
   /**
    * The error occurred loading data from a {@link MediaSource}.
    * <p>
@@ -47,6 +56,7 @@
    * The type of the playback failure. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER} and
    * {@link #TYPE_UNEXPECTED}.
    */
+  @Type
   public final int type;
 
   /**
@@ -85,7 +95,8 @@ public static ExoPlaybackException createForSource(IOException cause) {
     return new ExoPlaybackException(TYPE_UNEXPECTED, null, cause, C.INDEX_UNSET);
   }
 
-  private ExoPlaybackException(int type, String message, Throwable cause, int rendererIndex) {
+  private ExoPlaybackException(@Type int type, String message, Throwable cause,
+      int rendererIndex) {
     super(message, cause);
     this.type = type;
     this.rendererIndex = rendererIndex;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 4d53455151..e3c9b6e114 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -130,8 +130,8 @@
     /**
      * Called when timeline and/or manifest has been refreshed.
      *
-     * @param timeline The latest timeline.
-     * @param manifest The latest manifest.
+     * @param timeline The latest timeline, or null if the timeline is being cleared.
+     * @param manifest The latest manifest, or null if the manifest is being cleared.
      */
     void onTimelineChanged(Timeline timeline, Object manifest);
 
@@ -247,7 +247,7 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
 
   /**
    * Prepares the player to play the provided {@link MediaSource}. Equivalent to
-   * {@code prepare(mediaSource, true)}.
+   * {@code prepare(mediaSource, true, true)}.
    */
   void prepare(MediaSource mediaSource);
 
@@ -259,8 +259,11 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    * @param resetPosition Whether the playback position should be reset to the default position in
    *     the first {@link Timeline.Window}. If false, playback will start from the position defined
    *     by {@link #getCurrentWindowIndex()} and {@link #getCurrentPosition()}.
+   * @param resetTimeline Whether the timeline and manifest should be reset. Should be true unless
+   *     the player is being prepared to play the same media as it was playing previously (e.g. if
+   *     playback failed and is being retried).
    */
-  void prepare(MediaSource mediaSource, boolean resetPosition);
+  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline);
 
   /**
    * Sets whether playback should proceed when {@link #getPlaybackState()} == {@link #STATE_READY}.
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index d8bbd81dd8..91ab56805a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -18,6 +18,7 @@
 import android.content.Context;
 import android.os.Looper;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 
 /**
@@ -41,7 +42,7 @@ private ExoPlayerFactory() {}
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
       LoadControl loadControl) {
     return newSimpleInstance(context, trackSelector, loadControl, null);
   }
@@ -56,8 +57,8 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
    *     will not be used for DRM protected playbacks.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager drmSessionManager) {
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
     return newSimpleInstance(context, trackSelector, loadControl, drmSessionManager, false);
   }
 
@@ -74,8 +75,8 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    *     available extensions over those defined in the core library. Note that extensions must be
    *     included in the application build for setting this flag to have any effect.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager drmSessionManager,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean preferExtensionDecoders) {
     return newSimpleInstance(context, trackSelector, loadControl, drmSessionManager,
         preferExtensionDecoders, DEFAULT_ALLOWED_VIDEO_JOINING_TIME_MS);
@@ -96,8 +97,8 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param allowedVideoJoiningTimeMs The maximum duration for which a video renderer can attempt to
    *     seamlessly join an ongoing playback.
    */
-  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager drmSessionManager,
+  public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector<?> trackSelector,
+      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean preferExtensionDecoders, long allowedVideoJoiningTimeMs) {
     return new SimpleExoPlayer(context, trackSelector, loadControl, drmSessionManager,
         preferExtensionDecoders, allowedVideoJoiningTimeMs);
@@ -110,7 +111,7 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector) {
+  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector<?> trackSelector) {
     return newInstance(renderers, trackSelector, new DefaultLoadControl());
   }
 
@@ -122,7 +123,7 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
-  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
+  public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector<?> trackSelector,
       LoadControl loadControl) {
     return new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index f4b21aac04..3eb2ceb38b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -35,7 +35,7 @@
   private static final String TAG = "ExoPlayerImpl";
 
   private final Handler eventHandler;
-  private final ExoPlayerImplInternal internalPlayer;
+  private final ExoPlayerImplInternal<?> internalPlayer;
   private final CopyOnWriteArraySet<EventListener> listeners;
   private final Timeline.Window window;
   private final Timeline.Period period;
@@ -63,7 +63,8 @@
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    */
   @SuppressLint("HandlerLeak")
-  public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
+  public ExoPlayerImpl(Renderer[] renderers, TrackSelector<?> trackSelector,
+      LoadControl loadControl) {
     Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION);
     Assertions.checkNotNull(renderers);
     Assertions.checkState(renderers.length > 0);
@@ -79,8 +80,8 @@ public void handleMessage(Message msg) {
       }
     };
     playbackInfo = new ExoPlayerImplInternal.PlaybackInfo(0, 0);
-    internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
-        eventHandler, playbackInfo);
+    internalPlayer = new ExoPlayerImplInternal<>(renderers, trackSelector, loadControl,
+        playWhenReady, eventHandler, playbackInfo);
   }
 
   @Override
@@ -100,13 +101,19 @@ public int getPlaybackState() {
 
   @Override
   public void prepare(MediaSource mediaSource) {
-    prepare(mediaSource, true);
+    prepare(mediaSource, true, true);
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition) {
-    timeline = null;
-    internalPlayer.setMediaSource(mediaSource, resetPosition);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
+    if (resetTimeline && (timeline != null || manifest != null)) {
+      timeline = null;
+      manifest = null;
+      for (EventListener listener : listeners) {
+        listener.onTimelineChanged(null, null);
+      }
+    }
+    internalPlayer.prepare(mediaSource, resetPosition);
   }
 
   @Override
@@ -243,16 +250,8 @@ public long getBufferedPosition() {
     if (timeline == null || pendingSeekAcks > 0) {
       return maskingWindowPositionMs;
     } else {
-      int periodIndex = playbackInfo.periodIndex;
-      timeline.getPeriod(periodIndex, period);
-      int windowIndex = period.windowIndex;
-      timeline.getWindow(windowIndex, window);
-      if (window.firstPeriodIndex == periodIndex && window.lastPeriodIndex == periodIndex
-          && window.getPositionInFirstPeriodUs() == 0
-          && window.getDurationUs() == period.getDurationUs()) {
-        return C.usToMs(playbackInfo.bufferedPositionUs);
-      }
-      return getCurrentPosition();
+      timeline.getPeriod(playbackInfo.periodIndex, period);
+      return period.getPositionInWindowMs() + C.usToMs(playbackInfo.bufferedPositionUs);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 8cb15a0271..56b862073a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -27,7 +27,7 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
@@ -40,8 +40,8 @@
 /**
  * Implements the internal behavior of {@link ExoPlayerImpl}.
  */
-/* package */ final class ExoPlayerImplInternal implements Handler.Callback, MediaPeriod.Callback,
-    TrackSelector.InvalidationListener, MediaSource.Listener {
+/* package */ final class ExoPlayerImplInternal<T> implements Handler.Callback,
+    MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
 
   /**
    * Playback position information which is read on the application's thread by
@@ -75,7 +75,7 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
   public static final int MSG_ERROR = 6;
 
   // Internal messages
-  private static final int MSG_SET_MEDIA_SOURCE = 0;
+  private static final int MSG_PREPARE = 0;
   private static final int MSG_SET_PLAY_WHEN_READY = 1;
   private static final int MSG_DO_SOME_WORK = 2;
   private static final int MSG_SEEK_TO = 3;
@@ -100,7 +100,7 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
 
   private final Renderer[] renderers;
   private final RendererCapabilities[] rendererCapabilities;
-  private final TrackSelector trackSelector;
+  private final TrackSelector<T> trackSelector;
   private final LoadControl loadControl;
   private final StandaloneMediaClock standaloneMediaClock;
   private final Handler handler;
@@ -128,13 +128,13 @@ public PlaybackInfo(int periodIndex, long startPositionUs) {
   private boolean isTimelineReady;
   private boolean isTimelineEnded;
   private int bufferAheadPeriodCount;
-  private MediaPeriodHolder playingPeriodHolder;
-  private MediaPeriodHolder readingPeriodHolder;
-  private MediaPeriodHolder loadingPeriodHolder;
+  private MediaPeriodHolder<T> playingPeriodHolder;
+  private MediaPeriodHolder<T> readingPeriodHolder;
+  private MediaPeriodHolder<T> loadingPeriodHolder;
 
   private Timeline timeline;
 
-  public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
+  public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector<T> trackSelector,
       LoadControl loadControl, boolean playWhenReady, Handler eventHandler,
       PlaybackInfo playbackInfo) {
     this.renderers = renderers;
@@ -164,8 +164,8 @@ public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
     handler = new Handler(internalPlaybackThread.getLooper(), this);
   }
 
-  public void setMediaSource(MediaSource mediaSource, boolean resetPosition) {
-    handler.obtainMessage(MSG_SET_MEDIA_SOURCE, resetPosition ? 1 : 0, 0, mediaSource)
+  public void prepare(MediaSource mediaSource, boolean resetPosition) {
+    handler.obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, 0, mediaSource)
         .sendToTarget();
   }
 
@@ -253,8 +253,8 @@ public void onTrackSelectionsInvalidated() {
   public boolean handleMessage(Message msg) {
     try {
       switch (msg.what) {
-        case MSG_SET_MEDIA_SOURCE: {
-          setMediaSourceInternal((MediaSource) msg.obj, msg.arg1 != 0);
+        case MSG_PREPARE: {
+          prepareInternal((MediaSource) msg.obj, msg.arg1 != 0);
           return true;
         }
         case MSG_SET_PLAY_WHEN_READY: {
@@ -335,9 +335,10 @@ private void setIsLoading(boolean isLoading) {
     }
   }
 
-  private void setMediaSourceInternal(MediaSource mediaSource, boolean resetPosition)
+  private void prepareInternal(MediaSource mediaSource, boolean resetPosition)
       throws ExoPlaybackException {
     resetInternal();
+    loadControl.onPrepared();
     if (resetPosition) {
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
     }
@@ -458,12 +459,11 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
           startRenderers();
         }
       }
-    } else if (state == ExoPlayer.STATE_READY) {
-      if (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !isTimelineReady) {
-        rebuffering = playWhenReady;
-        setState(ExoPlayer.STATE_BUFFERING);
-        stopRenderers();
-      }
+    } else if (state == ExoPlayer.STATE_READY
+        && (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !isTimelineReady)) {
+      rebuffering = playWhenReady;
+      setState(ExoPlayer.STATE_BUFFERING);
+      stopRenderers();
     }
 
     if (state == ExoPlayer.STATE_BUFFERING) {
@@ -530,24 +530,31 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
     rebuffering = false;
     setState(ExoPlayer.STATE_BUFFERING);
 
-    if (periodPositionUs == C.TIME_UNSET
-        || (readingPeriodHolder != playingPeriodHolder && (periodIndex == playingPeriodHolder.index
-        || (readingPeriodHolder != null && periodIndex == readingPeriodHolder.index)))) {
+    if (periodPositionUs == C.TIME_UNSET || (readingPeriodHolder != playingPeriodHolder
+        && (periodIndex == playingPeriodHolder.index
+        || periodIndex == readingPeriodHolder.index))) {
       // Clear the timeline because either the seek position is not known, or a renderer is reading
       // ahead to the next period and the seek is to either the playing or reading period.
       periodIndex = C.INDEX_UNSET;
     }
 
-    // Clear the timeline, but keep the requested period if it is already prepared.
-    MediaPeriodHolder periodHolder = playingPeriodHolder;
-    MediaPeriodHolder newPlayingPeriodHolder = null;
-    while (periodHolder != null) {
-      if (periodHolder.index == periodIndex && periodHolder.prepared) {
-        newPlayingPeriodHolder = periodHolder;
-      } else {
-        periodHolder.release();
+    MediaPeriodHolder<T> newPlayingPeriodHolder = null;
+    if (playingPeriodHolder == null) {
+      // We're still waiting for the first period to be prepared.
+      if (loadingPeriodHolder != null) {
+        loadingPeriodHolder.release();
+      }
+    } else {
+      // Clear the timeline, but keep the requested period if it is already prepared.
+      MediaPeriodHolder<T> periodHolder = playingPeriodHolder;
+      while (periodHolder != null) {
+        if (periodHolder.index == periodIndex && periodHolder.prepared) {
+          newPlayingPeriodHolder = periodHolder;
+        } else {
+          periodHolder.release();
+        }
+        periodHolder = periodHolder.next;
       }
-      periodHolder = periodHolder.next;
     }
 
     // Disable all the renderers if the period is changing.
@@ -598,11 +605,13 @@ private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackExce
 
   private void stopInternal() {
     resetInternal();
+    loadControl.onStopped();
     setState(ExoPlayer.STATE_IDLE);
   }
 
   private void releaseInternal() {
     resetInternal();
+    loadControl.onReleased();
     setState(ExoPlayer.STATE_IDLE);
     synchronized (this) {
       released = true;
@@ -639,7 +648,6 @@ private void resetInternal() {
     loadingPeriodHolder = null;
     timeline = null;
     bufferAheadPeriodCount = 0;
-    loadControl.onTracksDisabled();
     setIsLoading(false);
   }
 
@@ -672,7 +680,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
       return;
     }
     // Reselect tracks on each period in turn, until the selection changes.
-    MediaPeriodHolder periodHolder = playingPeriodHolder;
+    MediaPeriodHolder<T> periodHolder = playingPeriodHolder;
     boolean selectionsChangedForReadPeriod = true;
     while (true) {
       if (periodHolder == null || !periodHolder.prepared) {
@@ -691,16 +699,14 @@ private void reselectTracksInternal() throws ExoPlaybackException {
     }
 
     if (selectionsChangedForReadPeriod) {
-      // Release everything after the playing period because a renderer may have read data from a
-      // track whose selection has now changed.
+      // Update streams and rebuffer for the new selection, recreating all streams if reading ahead.
+      boolean recreateStreams = readingPeriodHolder != playingPeriodHolder;
       releasePeriodHoldersFrom(playingPeriodHolder.next);
       playingPeriodHolder.next = null;
       readingPeriodHolder = playingPeriodHolder;
       loadingPeriodHolder = playingPeriodHolder;
       bufferAheadPeriodCount = 0;
 
-      // Update streams for the new selection, recreating all streams if reading ahead.
-      boolean recreateStreams = readingPeriodHolder != playingPeriodHolder;
       boolean[] streamResetFlags = new boolean[renderers.length];
       long periodPositionUs = playingPeriodHolder.updatePeriodTrackSelection(
           playbackInfo.positionUs, loadControl, recreateStreams, streamResetFlags);
@@ -739,7 +745,7 @@ private void reselectTracksInternal() throws ExoPlaybackException {
           }
         }
       }
-      trackSelector.onSelectionActivated(playingPeriodHolder.trackSelectionData);
+      trackSelector.onSelectionActivated(playingPeriodHolder.trackSelections);
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
@@ -811,11 +817,11 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       playingPeriodHolder.setIndex(timeline, timeline.getWindow(period.windowIndex, window),
           index);
 
-      MediaPeriodHolder previousPeriod = playingPeriodHolder;
+      MediaPeriodHolder<T> previousPeriodHolder = playingPeriodHolder;
       boolean seenReadingPeriod = false;
       bufferAheadPeriodCount = 0;
-      while (previousPeriod.next != null) {
-        MediaPeriodHolder periodHolder = previousPeriod.next;
+      while (previousPeriodHolder.next != null) {
+        MediaPeriodHolder<T> periodHolder = previousPeriodHolder.next;
         index++;
         timeline.getPeriod(index, period, true);
         if (!periodHolder.uid.equals(period.uid)) {
@@ -836,7 +842,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
           }
 
           // Update the loading period to be the latest period that is still valid.
-          loadingPeriodHolder = previousPeriod;
+          loadingPeriodHolder = previousPeriodHolder;
           loadingPeriodHolder.next = null;
 
           // Release the rest of the timeline.
@@ -850,7 +856,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
         if (periodHolder == readingPeriodHolder) {
           seenReadingPeriod = true;
         }
-        previousPeriod = periodHolder;
+        previousPeriodHolder = periodHolder;
       }
     } else if (loadingPeriodHolder != null) {
       Object uid = loadingPeriodHolder.uid;
@@ -893,7 +899,8 @@ private void attemptRestart(Timeline newTimeline, Timeline oldTimeline,
     }
 
     // Release all loaded periods.
-    releasePeriodHoldersFrom(playingPeriodHolder);
+    releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder
+        : loadingPeriodHolder);
     bufferAheadPeriodCount = 0;
     playingPeriodHolder = null;
     readingPeriodHolder = null;
@@ -953,10 +960,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
           periodStartPositionUs = defaultPosition.second;
         }
         Object newPeriodUid = timeline.getPeriod(newLoadingPeriodIndex, period, true).uid;
-        MediaPeriod newMediaPeriod = mediaSource.createPeriod(newLoadingPeriodIndex, this,
+        MediaPeriod newMediaPeriod = mediaSource.createPeriod(newLoadingPeriodIndex,
             loadControl.getAllocator(), periodStartPositionUs);
-        MediaPeriodHolder newPeriodHolder = new MediaPeriodHolder(renderers, rendererCapabilities,
-            trackSelector, mediaSource, newMediaPeriod, newPeriodUid, periodStartPositionUs);
+        newMediaPeriod.prepare(this);
+        MediaPeriodHolder<T> newPeriodHolder = new MediaPeriodHolder<>(renderers,
+            rendererCapabilities, trackSelector, mediaSource, newMediaPeriod, newPeriodUid,
+            periodStartPositionUs);
         timeline.getWindow(windowIndex, window);
         newPeriodHolder.setIndex(timeline, window, newLoadingPeriodIndex);
         if (loadingPeriodHolder != null) {
@@ -995,19 +1004,24 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
       eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, playbackInfo).sendToTarget();
     }
     updateTimelineState();
-    if (readingPeriodHolder == null) {
+
+    if (readingPeriodHolder.isLast) {
       // The renderers have their final SampleStreams.
+      for (Renderer renderer : enabledRenderers) {
+        renderer.setCurrentStreamIsFinal();
+      }
       return;
     }
+
     for (Renderer renderer : enabledRenderers) {
       if (!renderer.hasReadStreamToEnd()) {
         return;
       }
     }
     if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
-      TrackSelectionArray oldTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelections<T> oldTrackSelections = readingPeriodHolder.trackSelections;
       readingPeriodHolder = readingPeriodHolder.next;
-      TrackSelectionArray newTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelections<T> newTrackSelections = readingPeriodHolder.trackSelections;
       for (int i = 0; i < renderers.length; i++) {
         Renderer renderer = renderers[i];
         TrackSelection oldSelection = oldTrackSelections.get(i);
@@ -1029,11 +1043,6 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
           }
         }
       }
-    } else if (readingPeriodHolder.isLast) {
-      readingPeriodHolder = null;
-      for (Renderer renderer : enabledRenderers) {
-        renderer.setCurrentStreamIsFinal();
-      }
     }
   }
 
@@ -1071,7 +1080,7 @@ private void maybeContinueLoading() {
     long nextLoadPositionUs = loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
     if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
       long loadingPeriodPositionUs = rendererPositionUs
-          - loadingPeriodHolder.rendererPositionOffsetUs + loadingPeriodHolder.startPositionUs;
+          - loadingPeriodHolder.rendererPositionOffsetUs;
       long bufferedDurationUs = nextLoadPositionUs - loadingPeriodPositionUs;
       boolean continueLoading = loadControl.shouldContinueLoading(bufferedDurationUs);
       setIsLoading(continueLoading);
@@ -1086,14 +1095,15 @@ private void maybeContinueLoading() {
     }
   }
 
-  private void releasePeriodHoldersFrom(MediaPeriodHolder periodHolder) {
+  private void releasePeriodHoldersFrom(MediaPeriodHolder<T> periodHolder) {
     while (periodHolder != null) {
       periodHolder.release();
       periodHolder = periodHolder.next;
     }
   }
 
-  private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPlaybackException {
+  private void setPlayingPeriodHolder(MediaPeriodHolder<T> periodHolder)
+      throws ExoPlaybackException {
     int enabledRendererCount = 0;
     boolean[] rendererWasEnabledFlags = new boolean[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
@@ -1116,7 +1126,7 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
       }
     }
 
-    trackSelector.onSelectionActivated(periodHolder.trackSelectionData);
+    trackSelector.onSelectionActivated(periodHolder.trackSelections);
     playingPeriodHolder = periodHolder;
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
@@ -1173,7 +1183,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
   /**
    * Holds a {@link MediaPeriod} with information required to play it as part of a timeline.
    */
-  private static final class MediaPeriodHolder {
+  private static final class MediaPeriodHolder<T> {
 
     public final MediaPeriod mediaPeriod;
     public final Object uid;
@@ -1187,21 +1197,20 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     public boolean prepared;
     public boolean hasEnabledTracks;
     public long rendererPositionOffsetUs;
-    public MediaPeriodHolder next;
+    public MediaPeriodHolder<T> next;
     public boolean needsContinueLoading;
 
     private final Renderer[] renderers;
     private final RendererCapabilities[] rendererCapabilities;
-    private final TrackSelector trackSelector;
+    private final TrackSelector<T> trackSelector;
     private final MediaSource mediaSource;
 
-    private Object trackSelectionData;
-    private TrackSelectionArray trackSelections;
-    private TrackSelectionArray periodTrackSelections;
+    private TrackSelections<T> trackSelections;
+    private TrackSelections<T> periodTrackSelections;
 
     public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
-        TrackSelector trackSelector, MediaSource mediaSource, MediaPeriod mediaPeriod, Object uid,
-        long positionUs) {
+        TrackSelector<T> trackSelector, MediaSource mediaSource, MediaPeriod mediaPeriod,
+        Object uid, long positionUs) {
       this.renderers = renderers;
       this.rendererCapabilities = rendererCapabilities;
       this.trackSelector = trackSelector;
@@ -1213,7 +1222,7 @@ public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCa
       startPositionUs = positionUs;
     }
 
-    public void setNext(MediaPeriodHolder next) {
+    public void setNext(MediaPeriodHolder<T> next) {
       this.next = next;
     }
 
@@ -1235,14 +1244,12 @@ public void handlePrepared(long positionUs, LoadControl loadControl)
     }
 
     public boolean selectTracks() throws ExoPlaybackException {
-      Pair<TrackSelectionArray, Object> result =
-          trackSelector.selectTracks(rendererCapabilities, mediaPeriod.getTrackGroups());
-      TrackSelectionArray newTrackSelections = result.first;
+      TrackSelections<T> newTrackSelections = trackSelector.selectTracks(rendererCapabilities,
+          mediaPeriod.getTrackGroups());
       if (newTrackSelections.equals(periodTrackSelections)) {
         return false;
       }
       trackSelections = newTrackSelections;
-      trackSelectionData = result.second;
       return true;
     }
 
@@ -1265,11 +1272,14 @@ public long updatePeriodTrackSelection(long positionUs, LoadControl loadControl,
           sampleStreams, streamResetFlags, positionUs);
       periodTrackSelections = trackSelections;
 
+      // Update whether we have enabled tracks and sanity check the expected streams are non-null.
       hasEnabledTracks = false;
       for (int i = 0; i < sampleStreams.length; i++) {
         if (sampleStreams[i] != null) {
+          Assertions.checkState(trackSelections.get(i) != null);
           hasEnabledTracks = true;
-          break;
+        } else {
+          Assertions.checkState(trackSelections.get(i) == null);
         }
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index e2e17c425c..02c70bb0be 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  String VERSION = "2.0.0";
+  String VERSION = "2.0.4";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  int VERSION_INT = 2000000;
+  int VERSION_INT = 2000004;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer2/Format.java b/library/src/main/java/com/google/android/exoplayer2/Format.java
index 9cfe019ef4..550e6ab1d8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Format.java
@@ -39,20 +39,6 @@
    */
   public static final int NO_VALUE = -1;
 
-  /**
-   * Indicates that the track should be selected if user preferences do not state otherwise.
-   */
-  public static final int SELECTION_FLAG_DEFAULT = 1;
-  /**
-   * Indicates that the track must be displayed. Only applies to text tracks.
-   */
-  public static final int SELECTION_FLAG_FORCED = 2;
-  /**
-   * Indicates that the player may choose to play the track in absence of an explicit user
-   * preference.
-   */
-  public static final int SELECTION_FLAG_AUTOSELECT = 4;
-
   /**
    * A value for {@link #subsampleOffsetUs} to indicate that subsample timestamps are relative to
    * the timestamps of their parent samples.
@@ -131,6 +117,7 @@
    * modes are {@link C#STEREO_MODE_MONO}, {@link C#STEREO_MODE_TOP_BOTTOM}, {@link
    * C#STEREO_MODE_LEFT_RIGHT}.
    */
+  @C.StereoMode
   public final int stereoMode;
   /**
    * The projection data for 360/VR video, or null if not applicable.
@@ -153,6 +140,7 @@
    * {@link C#ENCODING_PCM_24BIT} and {@link C#ENCODING_PCM_32BIT}. Set to {@link #NO_VALUE} for
    * other media types.
    */
+  @C.PcmEncoding
   public final int pcmEncoding;
   /**
    * The number of samples to trim from the start of the decoded audio stream.
@@ -177,6 +165,7 @@
   /**
    * Track selection flags.
    */
+  @C.SelectionFlags
   public final int selectionFlags;
 
   /**
@@ -218,7 +207,7 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate,
       List<byte[]> initializationData, int rotationDegrees, float pixelWidthHeightRatio,
-      byte[] projectionData, int stereoMode, DrmInitData drmInitData) {
+      byte[] projectionData, @C.StereoMode int stereoMode, DrmInitData drmInitData) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, width, height,
         frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, initializationData,
@@ -229,7 +218,7 @@ public static Format createVideoSampleFormat(String id, String sampleMimeType, S
 
   public static Format createAudioContainerFormat(String id, String containerMimeType,
       String sampleMimeType, String codecs, int bitrate, int channelCount, int sampleRate,
-      List<byte[]> initializationData, int selectionFlags, String language) {
+      List<byte[]> initializationData, @C.SelectionFlags int selectionFlags, String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, channelCount, sampleRate, NO_VALUE,
         NO_VALUE, NO_VALUE, selectionFlags, language, OFFSET_SAMPLE_RELATIVE, initializationData,
@@ -238,25 +227,26 @@ public static Format createAudioContainerFormat(String id, String containerMimeT
 
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int channelCount, int sampleRate,
-      List<byte[]> initializationData, DrmInitData drmInitData, int selectionFlags,
-      String language) {
+      List<byte[]> initializationData, DrmInitData drmInitData,
+      @C.SelectionFlags int selectionFlags, String language) {
     return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
         sampleRate, NO_VALUE, initializationData, drmInitData, selectionFlags, language);
   }
 
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, int maxInputSize, int channelCount, int sampleRate, int pcmEncoding,
-      List<byte[]> initializationData, DrmInitData drmInitData, int selectionFlags,
-      String language) {
+      int bitrate, int maxInputSize, int channelCount, int sampleRate,
+      @C.PcmEncoding int pcmEncoding, List<byte[]> initializationData, DrmInitData drmInitData,
+      @C.SelectionFlags int selectionFlags, String language) {
     return createAudioSampleFormat(id, sampleMimeType, codecs, bitrate, maxInputSize, channelCount,
         sampleRate, pcmEncoding, NO_VALUE, NO_VALUE, initializationData, drmInitData,
         selectionFlags, language);
   }
 
   public static Format createAudioSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, int maxInputSize, int channelCount, int sampleRate, int pcmEncoding,
-      int encoderDelay, int encoderPadding, List<byte[]> initializationData,
-      DrmInitData drmInitData, int selectionFlags, String language) {
+      int bitrate, int maxInputSize, int channelCount, int sampleRate,
+      @C.PcmEncoding int pcmEncoding, int encoderDelay, int encoderPadding,
+      List<byte[]> initializationData, DrmInitData drmInitData,
+      @C.SelectionFlags int selectionFlags, String language) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, maxInputSize, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, channelCount, sampleRate, pcmEncoding,
         encoderDelay, encoderPadding, selectionFlags, language, OFFSET_SAMPLE_RELATIVE,
@@ -266,20 +256,21 @@ public static Format createAudioSampleFormat(String id, String sampleMimeType, S
   // Text.
 
   public static Format createTextContainerFormat(String id, String containerMimeType,
-      String sampleMimeType, String codecs, int bitrate, int selectionFlags, String language) {
+      String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
+      String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, selectionFlags, language, OFFSET_SAMPLE_RELATIVE, null, null);
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, int selectionFlags, String language, DrmInitData drmInitData) {
+      int bitrate, @C.SelectionFlags int selectionFlags, String language, DrmInitData drmInitData) {
     return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
         drmInitData, OFFSET_SAMPLE_RELATIVE);
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, int selectionFlags, String language, DrmInitData drmInitData,
+      int bitrate, @C.SelectionFlags int selectionFlags, String language, DrmInitData drmInitData,
       long subsampleOffsetUs) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
@@ -313,10 +304,10 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
 
   /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
       int bitrate, int maxInputSize, int width, int height, float frameRate, int rotationDegrees,
-      float pixelWidthHeightRatio, byte[] projectionData, int stereoMode, int channelCount,
-      int sampleRate, int pcmEncoding, int encoderDelay, int encoderPadding, int selectionFlags,
-      String language, long subsampleOffsetUs, List<byte[]> initializationData,
-      DrmInitData drmInitData) {
+      float pixelWidthHeightRatio, byte[] projectionData, @C.StereoMode int stereoMode,
+      int channelCount, int sampleRate, @C.PcmEncoding int pcmEncoding, int encoderDelay,
+      int encoderPadding, @C.SelectionFlags int selectionFlags, String language,
+      long subsampleOffsetUs, List<byte[]> initializationData, DrmInitData drmInitData) {
     this.id = id;
     this.containerMimeType = containerMimeType;
     this.sampleMimeType = sampleMimeType;
@@ -343,6 +334,7 @@ public static Format createSampleFormat(String id, String sampleMimeType, String
     this.drmInitData = drmInitData;
   }
 
+  @SuppressWarnings("ResourceType")
   /* package */ Format(Parcel in) {
     id = in.readString();
     containerMimeType = in.readString();
@@ -388,8 +380,8 @@ public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
         selectionFlags, language, subsampleOffsetUs, initializationData, drmInitData);
   }
 
-  public Format copyWithContainerInfo(String id, int bitrate, int width, int height,
-      int selectionFlags, String language) {
+  public Format copyWithContainerInfo(String id, String codecs, int bitrate, int width, int height,
+      @C.SelectionFlags int selectionFlags, String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize,
         width, height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData,
         stereoMode, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
@@ -402,7 +394,7 @@ public Format copyWithManifestFormatInfo(Format manifestFormat,
     String codecs = this.codecs == null ? manifestFormat.codecs : this.codecs;
     int bitrate = this.bitrate == NO_VALUE ? manifestFormat.bitrate : this.bitrate;
     float frameRate = this.frameRate == NO_VALUE ? manifestFormat.frameRate : this.frameRate;
-    int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
+    @C.SelectionFlags int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
     String language = this.language == null ? manifestFormat.language : this.language;
     DrmInitData drmInitData = (preferManifestDrmInitData && manifestFormat.drmInitData != null)
         || this.drmInitData == null ? manifestFormat.drmInitData : this.drmInitData;
diff --git a/library/src/main/java/com/google/android/exoplayer2/LoadControl.java b/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
index 213d5e5297..6176c6085b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/LoadControl.java
@@ -17,8 +17,7 @@
 
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
 import com.google.android.exoplayer2.upstream.Allocator;
 
 /**
@@ -26,20 +25,30 @@
  */
 public interface LoadControl {
 
+  /**
+   * Called by the player when prepared with a new source.
+   */
+  void onPrepared();
+
   /**
    * Called by the player when a track selection occurs.
    *
    * @param renderers The renderers.
    * @param trackGroups The {@link TrackGroup}s from which the selection was made.
-   * @param trackSelections The {@link TrackSelection}s that were made.
+   * @param trackSelections The track selections that were made.
    */
   void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
-      TrackSelectionArray trackSelections);
+      TrackSelections<?> trackSelections);
+
+  /**
+   * Called by the player when stopped.
+   */
+  void onStopped();
 
   /**
-   * Called by the player when all tracks are disabled.
+   * Called by the player when released.
    */
-  void onTracksDisabled();
+  void onReleased();
 
   /**
    * Returns the {@link Allocator} that should be used to obtain media buffer allocations.
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 07702c8f8c..4b673d3750 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
@@ -40,6 +41,7 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.trackselection.TrackSelections;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
@@ -80,18 +82,14 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
 
     /**
      * Called when a frame is rendered for the first time since setting the surface, and when a
-     * frame is rendered for the first time since the renderer was reset.
-     *
-     * @param surface The {@link Surface} to which a first frame has been rendered.
+     * frame is rendered for the first time since a video track was selected.
      */
-    void onRenderedFirstFrame(Surface surface);
+    void onRenderedFirstFrame();
 
     /**
-     * Called when the renderer is disabled.
-     *
-     * @param counters {@link DecoderCounters} that were updated by the renderer.
+     * Called when a video track is no longer selected.
      */
-    void onVideoDisabled(DecoderCounters counters);
+    void onVideoTracksDisabled();
 
   }
 
@@ -105,9 +103,12 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private final int videoRendererCount;
   private final int audioRendererCount;
 
+  private boolean videoTracksEnabled;
   private Format videoFormat;
   private Format audioFormat;
 
+  private Surface surface;
+  private boolean ownsSurface;
   private SurfaceHolder surfaceHolder;
   private TextureView textureView;
   private TextRenderer.Output textOutput;
@@ -121,11 +122,12 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private float volume;
   private PlaybackParamsHolder playbackParamsHolder;
 
-  /* package */ SimpleExoPlayer(Context context, TrackSelector trackSelector,
-      LoadControl loadControl, DrmSessionManager drmSessionManager,
+  /* package */ SimpleExoPlayer(Context context, TrackSelector<?> trackSelector,
+      LoadControl loadControl, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean preferExtensionDecoders, long allowedVideoJoiningTimeMs) {
     mainHandler = new Handler();
     componentListener = new ComponentListener();
+    trackSelector.addListener(componentListener);
 
     // Build the renderers.
     ArrayList<Renderer> renderersList = new ArrayList<>();
@@ -182,6 +184,14 @@ public int getRendererType(int index) {
     return renderers[index].getTrackType();
   }
 
+  /**
+   * Clears any {@link Surface}, {@link SurfaceHolder}, {@link SurfaceView} or {@link TextureView}
+   * currently set on the player.
+   */
+  public void clearVideoSurface() {
+    setVideoSurface(null);
+  }
+
   /**
    * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
    * tracking the lifecycle of the surface, and must clear the surface by calling
@@ -197,7 +207,7 @@ public int getRendererType(int index) {
    */
   public void setVideoSurface(Surface surface) {
     removeSurfaceCallbacks();
-    setVideoSurfaceInternal(surface);
+    setVideoSurfaceInternal(surface, false);
   }
 
   /**
@@ -210,9 +220,9 @@ public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
     removeSurfaceCallbacks();
     this.surfaceHolder = surfaceHolder;
     if (surfaceHolder == null) {
-      setVideoSurfaceInternal(null);
+      setVideoSurfaceInternal(null, false);
     } else {
-      setVideoSurfaceInternal(surfaceHolder.getSurface());
+      setVideoSurfaceInternal(surfaceHolder.getSurface(), false);
       surfaceHolder.addCallback(componentListener);
     }
   }
@@ -237,10 +247,13 @@ public void setVideoTextureView(TextureView textureView) {
     removeSurfaceCallbacks();
     this.textureView = textureView;
     if (textureView == null) {
-      setVideoSurfaceInternal(null);
+      setVideoSurfaceInternal(null, true);
     } else {
+      if (textureView.getSurfaceTextureListener() != null) {
+        Log.w(TAG, "Replacing existing SurfaceTextureListener.");
+      }
       SurfaceTexture surfaceTexture = textureView.getSurfaceTexture();
-      setVideoSurfaceInternal(surfaceTexture == null ? null : new Surface(surfaceTexture));
+      setVideoSurfaceInternal(surfaceTexture == null ? null : new Surface(surfaceTexture), true);
       textureView.setSurfaceTextureListener(componentListener);
     }
   }
@@ -408,8 +421,8 @@ public void prepare(MediaSource mediaSource) {
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition) {
-    player.prepare(mediaSource, resetPosition);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
+    player.prepare(mediaSource, resetPosition, resetTimeline);
   }
 
   @Override
@@ -455,6 +468,13 @@ public void stop() {
   @Override
   public void release() {
     player.release();
+    removeSurfaceCallbacks();
+    if (surface != null) {
+      if (ownsSurface) {
+        surface.release();
+      }
+      surface = null;
+    }
   }
 
   @Override
@@ -509,8 +529,9 @@ public Object getCurrentManifest() {
 
   // Internal methods.
 
-  private void buildRenderers(Context context, DrmSessionManager drmSessionManager,
-      ArrayList<Renderer> renderersList, long allowedVideoJoiningTimeMs) {
+  private void buildRenderers(Context context,
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, ArrayList<Renderer> renderersList,
+      long allowedVideoJoiningTimeMs) {
     MediaCodecVideoRenderer videoRenderer = new MediaCodecVideoRenderer(context,
         MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
         allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, componentListener,
@@ -590,17 +611,23 @@ private void buildExtensionRenderers(ArrayList<Renderer> renderersList,
   }
 
   private void removeSurfaceCallbacks() {
-    if (this.textureView != null) {
-      this.textureView.setSurfaceTextureListener(null);
-      this.textureView = null;
+    if (textureView != null) {
+      if (textureView.getSurfaceTextureListener() != componentListener) {
+        Log.w(TAG, "SurfaceTextureListener already unset or replaced.");
+      } else {
+        textureView.setSurfaceTextureListener(null);
+      }
+      textureView = null;
     }
-    if (this.surfaceHolder != null) {
-      this.surfaceHolder.removeCallback(componentListener);
-      this.surfaceHolder = null;
+    if (surfaceHolder != null) {
+      surfaceHolder.removeCallback(componentListener);
+      surfaceHolder = null;
     }
   }
 
-  private void setVideoSurfaceInternal(Surface surface) {
+  private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
+    // Note: We don't turn this method into a no-op if the surface is being replaced with itself
+    // so as to ensure onRenderedFirstFrame callbacks are still called in this case.
     ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
     int count = 0;
     for (Renderer renderer : renderers) {
@@ -608,17 +635,24 @@ private void setVideoSurfaceInternal(Surface surface) {
         messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SURFACE, surface);
       }
     }
-    if (surface == null) {
-      // Block to ensure that the surface is not accessed after the method returns.
+    if (this.surface != null && this.surface != surface) {
+      // If we created this surface, we are responsible for releasing it.
+      if (this.ownsSurface) {
+        this.surface.release();
+      }
+      // We're replacing a surface. Block to ensure that it's not accessed after the method returns.
       player.blockingSendMessages(messages);
     } else {
       player.sendMessages(messages);
     }
+    this.surface = surface;
+    this.ownsSurface = ownsSurface;
   }
 
   private final class ComponentListener implements VideoRendererEventListener,
       AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output<List<Id3Frame>>,
-      SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
+      SurfaceHolder.Callback, TextureView.SurfaceTextureListener,
+      TrackSelector.EventListener<Object> {
 
     // VideoRendererEventListener implementation
 
@@ -669,8 +703,8 @@ public void onVideoSizeChanged(int width, int height, int unappliedRotationDegre
 
     @Override
     public void onRenderedFirstFrame(Surface surface) {
-      if (videoListener != null) {
-        videoListener.onRenderedFirstFrame(surface);
+      if (videoListener != null && SimpleExoPlayer.this.surface == surface) {
+        videoListener.onRenderedFirstFrame();
       }
       if (videoDebugListener != null) {
         videoDebugListener.onRenderedFirstFrame(surface);
@@ -679,9 +713,6 @@ public void onRenderedFirstFrame(Surface surface) {
 
     @Override
     public void onVideoDisabled(DecoderCounters counters) {
-      if (videoListener != null) {
-        videoListener.onVideoDisabled(counters);
-      }
       if (videoDebugListener != null) {
         videoDebugListener.onVideoDisabled(counters);
       }
@@ -764,7 +795,7 @@ public void onMetadata(List<Id3Frame> id3Frames) {
 
     @Override
     public void surfaceCreated(SurfaceHolder holder) {
-      setVideoSurfaceInternal(holder.getSurface());
+      setVideoSurfaceInternal(holder.getSurface(), false);
     }
 
     @Override
@@ -774,14 +805,14 @@ public void surfaceChanged(SurfaceHolder holder, int format, int width, int heig
 
     @Override
     public void surfaceDestroyed(SurfaceHolder holder) {
-      setVideoSurfaceInternal(null);
+      setVideoSurfaceInternal(null, false);
     }
 
     // TextureView.SurfaceTextureListener implementation
 
     @Override
     public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {
-      setVideoSurfaceInternal(new Surface(surfaceTexture));
+      setVideoSurfaceInternal(new Surface(surfaceTexture), true);
     }
 
     @Override
@@ -791,7 +822,7 @@ public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int width
 
     @Override
     public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
-      setVideoSurface(null);
+      setVideoSurfaceInternal(null, true);
       return true;
     }
 
@@ -800,6 +831,23 @@ public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
       // Do nothing.
     }
 
+    // TrackSelector.EventListener implementation
+
+    @Override
+    public void onTrackSelectionsChanged(TrackSelections<?> trackSelections) {
+      boolean videoTracksEnabled = false;
+      for (int i = 0; i < renderers.length; i++) {
+        if (renderers[i].getTrackType() == C.TRACK_TYPE_VIDEO && trackSelections.get(i) != null) {
+          videoTracksEnabled = true;
+          break;
+        }
+      }
+      if (videoListener != null && SimpleExoPlayer.this.videoTracksEnabled && !videoTracksEnabled) {
+        videoListener.onVideoTracksDisabled();
+      }
+      SimpleExoPlayer.this.videoTracksEnabled = videoTracksEnabled;
+    }
+
   }
 
   @TargetApi(23)
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index c2ab70608c..adb3d5999b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -175,9 +176,12 @@ public static Format parseEac3SyncframeFormat(ParsableBitArray data, String trac
    * Returns the size in bytes of the given AC-3 syncframe.
    *
    * @param data The syncframe to parse.
-   * @return The syncframe size in bytes.
+   * @return The syncframe size in bytes. {@link C#LENGTH_UNSET} if the input is invalid.
    */
   public static int parseAc3SyncframeSize(byte[] data) {
+    if (data.length < 5) {
+      return C.LENGTH_UNSET;
+    }
     int fscod = (data[4] & 0xC0) >> 6;
     int frmsizecod = data[4] & 0x3F;
     return getAc3SyncframeSize(fscod, frmsizecod);
@@ -227,11 +231,17 @@ public static int parseEAc3SyncframeAudioSampleCount(ByteBuffer buffer) {
   }
 
   private static int getAc3SyncframeSize(int fscod, int frmsizecod) {
+    int halfFrmsizecod = frmsizecod / 2;
+    if (fscod < 0 || fscod >= SAMPLE_RATE_BY_FSCOD.length || frmsizecod < 0
+        || halfFrmsizecod >= SYNCFRAME_SIZE_WORDS_BY_HALF_FRMSIZECOD_44_1.length) {
+      // Invalid values provided.
+      return C.LENGTH_UNSET;
+    }
     int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     if (sampleRate == 44100) {
-      return 2 * (SYNCFRAME_SIZE_WORDS_BY_HALF_FRMSIZECOD_44_1[frmsizecod / 2] + (frmsizecod % 2));
+      return 2 * (SYNCFRAME_SIZE_WORDS_BY_HALF_FRMSIZECOD_44_1[halfFrmsizecod] + (frmsizecod % 2));
     }
-    int bitrate = BITRATE_BY_HALF_FRMSIZECOD[frmsizecod / 2];
+    int bitrate = BITRATE_BY_HALF_FRMSIZECOD[halfFrmsizecod];
     if (sampleRate == 32000) {
       return 6 * bitrate;
     } else { // sampleRate == 48000
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
index 02fa2b8f85..87f6546e1f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
@@ -208,7 +208,9 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
+  @C.Encoding
   private int sourceEncoding;
+  @C.Encoding
   private int targetEncoding;
   private boolean passthrough;
   private int pcmFrameSize;
@@ -348,8 +350,8 @@ public long getCurrentPositionUs(boolean sourceEnded) {
    * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
    *     suitable buffer size automatically.
    */
-  public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding,
-      int specifiedBufferSize) {
+  public void configure(String mimeType, int channelCount, int sampleRate,
+      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize) {
     int channelConfig;
     switch (channelCount) {
       case 1:
@@ -381,7 +383,7 @@ public void configure(String mimeType, int channelCount, int sampleRate, int pcm
     }
 
     boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
-    int sourceEncoding;
+    @C.Encoding int sourceEncoding;
     if (passthrough) {
       sourceEncoding = getEncodingForMimeType(mimeType);
     } else if (pcmEncoding == C.ENCODING_PCM_8BIT || pcmEncoding == C.ENCODING_PCM_16BIT
@@ -470,7 +472,7 @@ public int initialize(int sessionId) throws InitializationException {
         if (keepSessionIdAudioTrack == null) {
           int sampleRate = 4000; // Equal to private android.media.AudioTrack.MIN_SAMPLE_RATE.
           int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
-          int encoding = C.ENCODING_PCM_16BIT;
+          @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
               channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STATIC, sessionId);
@@ -962,7 +964,7 @@ private boolean overrideHasPendingData() {
    * @return The 16-bit PCM output. Different to the out parameter if null was passed, or if the
    *     capacity was insufficient for the output.
    */
-  private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int sourceEncoding,
+  private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, @C.PcmEncoding int sourceEncoding,
       ByteBuffer out) {
     int offset = buffer.position();
     int limit = buffer.limit();
@@ -1023,6 +1025,7 @@ private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int sourceEncodi
     return resampledBuffer;
   }
 
+  @C.Encoding
   private static int getEncodingForMimeType(String mimeType) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AC3:
@@ -1038,7 +1041,7 @@ private static int getEncodingForMimeType(String mimeType) {
     }
   }
 
-  private static int getFramesPerEncodedSample(int encoding, ByteBuffer buffer) {
+  private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffer buffer) {
     if (encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD) {
       return DtsUtil.parseDtsAudioSampleCount(buffer);
     } else if (encoding == C.ENCODING_AC3) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java b/library/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
index cb408714f4..773959fbfc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/decoder/Buffer.java
@@ -22,6 +22,7 @@
  */
 public abstract class Buffer {
 
+  @C.BufferFlags
   private int flags;
 
   /**
@@ -58,7 +59,7 @@ public final boolean isKeyFrame() {
    * @param flags The flags to set, which should be a combination of the {@code C.BUFFER_FLAG_*}
    *     constants.
    */
-  public final void setFlags(int flags) {
+  public final void setFlags(@C.BufferFlags int flags) {
     this.flags = flags;
   }
 
@@ -68,7 +69,7 @@ public final void setFlags(int flags) {
    * @param flag The flag to add to this buffer's flags, which should be one of the
    *     {@code C.BUFFER_FLAG_*} constants.
    */
-  public final void addFlag(int flag) {
+  public final void addFlag(@C.BufferFlags int flag) {
     flags |= flag;
   }
 
@@ -77,7 +78,7 @@ public final void addFlag(int flag) {
    *
    * @param flag The flag to remove.
    */
-  public final void clearFlag(int flag) {
+  public final void clearFlag(@C.BufferFlags int flag) {
     flags &= ~flag;
   }
 
@@ -87,7 +88,7 @@ public final void clearFlag(int flag) {
    * @param flag The flag to check.
    * @return Whether the flag is set.
    */
-  protected final boolean getFlag(int flag) {
+  protected final boolean getFlag(@C.BufferFlags int flag) {
     return (flags & flag) == flag;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java b/library/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
index bde46738fe..866e421acc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/decoder/CryptoInfo.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.decoder;
 
 import android.annotation.TargetApi;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -34,6 +35,7 @@
   /**
    * @see android.media.MediaCodec.CryptoInfo#mode
    */
+  @C.CryptoMode
   public int mode;
   /**
    * @see android.media.MediaCodec.CryptoInfo#numBytesOfClearData
@@ -58,7 +60,7 @@ public CryptoInfo() {
    * @see android.media.MediaCodec.CryptoInfo#set(int, int[], int[], byte[], byte[], int)
    */
   public void set(int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData,
-      byte[] key, byte[] iv, int mode) {
+      byte[] key, byte[] iv, @C.CryptoMode int mode) {
     this.numSubSamples = numSubSamples;
     this.numBytesOfClearData = numBytesOfClearData;
     this.numBytesOfEncryptedData = numBytesOfEncryptedData;
diff --git a/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index f34861a0e0..b76f3e8d0c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.decoder;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
 
 /**
@@ -23,16 +26,21 @@
  */
 public class DecoderInputBuffer extends Buffer {
 
+  /**
+   * The buffer replacement mode, which may disable replacement.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({BUFFER_REPLACEMENT_MODE_DISABLED, BUFFER_REPLACEMENT_MODE_NORMAL,
+      BUFFER_REPLACEMENT_MODE_DIRECT})
+  public @interface BufferReplacementMode {}
   /**
    * Disallows buffer replacement.
    */
   public static final int BUFFER_REPLACEMENT_MODE_DISABLED = 0;
-
   /**
    * Allows buffer replacement using {@link ByteBuffer#allocate(int)}.
    */
   public static final int BUFFER_REPLACEMENT_MODE_NORMAL = 1;
-
   /**
    * Allows buffer replacement using {@link ByteBuffer#allocateDirect(int)}.
    */
@@ -53,6 +61,7 @@
    */
   public long timeUs;
 
+  @BufferReplacementMode
   private final int bufferReplacementMode;
 
   /**
@@ -60,7 +69,7 @@
    *     of {@link #BUFFER_REPLACEMENT_MODE_DISABLED}, {@link #BUFFER_REPLACEMENT_MODE_NORMAL} and
    *     {@link #BUFFER_REPLACEMENT_MODE_DIRECT}.
    */
-  public DecoderInputBuffer(int bufferReplacementMode) {
+  public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
     this.cryptoInfo = new CryptoInfo();
     this.bufferReplacementMode = bufferReplacementMode;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index 8f0ff961a9..6f84395072 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -16,6 +16,9 @@
 package com.google.android.exoplayer2.drm;
 
 import android.annotation.TargetApi;
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * A DRM session.
@@ -23,6 +26,12 @@
 @TargetApi(16)
 public interface DrmSession<T extends ExoMediaCrypto> {
 
+  /**
+   * The state of the DRM session.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STATE_ERROR, STATE_CLOSED, STATE_OPENING, STATE_OPENED, STATE_OPENED_WITH_KEYS})
+  @interface State {}
   /**
    * The session has encountered an error. {@link #getError()} can be used to retrieve the cause.
    */
@@ -50,6 +59,7 @@
    * @return One of {@link #STATE_ERROR}, {@link #STATE_CLOSED}, {@link #STATE_OPENING},
    *     {@link #STATE_OPENED} and {@link #STATE_OPENED_WITH_KEYS}.
    */
+  @State
   int getState();
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index 375ffc2733..8e63fbfaae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -37,6 +37,6 @@
   /**
    * Releases a {@link DrmSession}.
    */
-  void releaseSession(DrmSession drmSession);
+  void releaseSession(DrmSession<T> drmSession);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 14329d47ee..65e41dd91e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -71,7 +71,7 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return executePost(url, null, null);
+    return executePost(url, new byte[0], null);
   }
 
   @Override
@@ -81,6 +81,7 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
       url = defaultUrl;
     }
     Map<String, String> requestProperties = new HashMap<>();
+    requestProperties.put("Content-Type", "application/octet-stream");
     if (C.PLAYREADY_UUID.equals(uuid)) {
       requestProperties.putAll(PLAYREADY_KEY_REQUEST_PROPERTIES);
     }
@@ -93,8 +94,6 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
   private byte[] executePost(String url, byte[] data, Map<String, String> requestProperties)
       throws IOException {
     HttpDataSource dataSource = dataSourceFactory.createDataSource();
-    // Note: This will be overridden by a Content-Type in requestProperties, if one is set.
-    dataSource.setRequestProperty("Content-Type", "application/octet-stream");
     if (requestProperties != null) {
       for (Map.Entry<String, String> requestProperty : requestProperties.entrySet()) {
         dataSource.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
index 8428b0cdf9..f3c6595736 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
@@ -40,7 +40,7 @@
  * A {@link DrmSessionManager} that supports streaming playbacks using {@link MediaDrm}.
  */
 @TargetApi(18)
-public class StreamingDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager,
+public class StreamingDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
     DrmSession<T> {
 
   /**
@@ -87,6 +87,7 @@
 
   private int openCount;
   private boolean provisioningInProgress;
+  @DrmSession.State
   private int state;
   private T mediaCrypto;
   private Exception lastException;
@@ -267,7 +268,7 @@ public final void setPropertyByteArray(String key, byte[] value) {
   }
 
   @Override
-  public void releaseSession(DrmSession session) {
+  public void releaseSession(DrmSession<T> session) {
     if (--openCount != 0) {
       return;
     }
@@ -291,6 +292,7 @@ public void releaseSession(DrmSession session) {
   // DrmSession implementation.
 
   @Override
+  @DrmSession.State
   public final int getState() {
     return state;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java b/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
index d1b70279ce..505750efaa 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
@@ -15,11 +15,21 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Thrown when the requested DRM scheme is not supported.
  */
 public final class UnsupportedDrmException extends Exception {
 
+  /**
+   * The reason for the exception.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({REASON_UNSUPPORTED_SCHEME, REASON_INSTANTIATION_ERROR})
+  public @interface Reason {}
   /**
    * The requested DRM scheme is unsupported by the device.
    */
@@ -33,12 +43,13 @@
   /**
    * Either {@link #REASON_UNSUPPORTED_SCHEME} or {@link #REASON_INSTANTIATION_ERROR}.
    */
+  @Reason
   public final int reason;
 
   /**
    * @param reason {@link #REASON_UNSUPPORTED_SCHEME} or {@link #REASON_INSTANTIATION_ERROR}.
    */
-  public UnsupportedDrmException(int reason) {
+  public UnsupportedDrmException(@Reason int reason) {
     this.reason = reason;
   }
 
@@ -46,7 +57,7 @@ public UnsupportedDrmException(int reason) {
    * @param reason {@link #REASON_UNSUPPORTED_SCHEME} or {@link #REASON_INSTANTIATION_ERROR}.
    * @param cause The cause of this exception.
    */
-  public UnsupportedDrmException(int reason, Exception cause) {
+  public UnsupportedDrmException(@Reason int reason, Exception cause) {
     super(cause);
     this.reason = reason;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index 6a20b08113..bca5ecf3bd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -125,7 +125,6 @@ public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
     ensureSpaceForPeek(length);
     int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
-    peekBufferLength += length - bytesPeeked;
     while (bytesPeeked < length) {
       bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
           allowEndOfInput);
@@ -134,6 +133,7 @@ public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       }
     }
     peekBufferPosition += length;
+    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
     return true;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index 847d429090..cb9e41aa62 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -298,6 +298,7 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
     long offset = extrasHolder.offset;
 
     // Read the signal byte.
+    scratch.reset(1);
     readData(offset, scratch.data, 1);
     offset++;
     byte signalByte = scratch.data[0];
@@ -314,9 +315,9 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
     // Read the subsample count, if present.
     int subsampleCount;
     if (subsampleEncryption) {
+      scratch.reset(2);
       readData(offset, scratch.data, 2);
       offset += 2;
-      scratch.setPosition(0);
       subsampleCount = scratch.readUnsignedShort();
     } else {
       subsampleCount = 1;
@@ -333,7 +334,7 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
     }
     if (subsampleEncryption) {
       int subsampleDataLength = 6 * subsampleCount;
-      ensureCapacity(scratch, subsampleDataLength);
+      scratch.reset(subsampleDataLength);
       readData(offset, scratch.data, subsampleDataLength);
       offset += subsampleDataLength;
       scratch.setPosition(0);
@@ -412,15 +413,6 @@ private void dropDownstreamTo(long absolutePosition) {
     }
   }
 
-  /**
-   * Ensure that the passed {@link ParsableByteArray} is of at least the specified limit.
-   */
-  private static void ensureCapacity(ParsableByteArray byteArray, int limit) {
-    if (byteArray.limit() < limit) {
-      byteArray.reset(new byte[limit], limit);
-    }
-  }
-
   // Called by the loading thread.
 
   /**
@@ -504,7 +496,8 @@ public void sampleData(ParsableByteArray buffer, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey) {
     if (!startWriteOperation()) {
       infoQueue.commitSampleTimestamp(timeUs);
       return;
@@ -844,8 +837,8 @@ public synchronized boolean format(Format format) {
       }
     }
 
-    public synchronized void commitSample(long timeUs, int sampleFlags, long offset, int size,
-        byte[] encryptionKey) {
+    public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlags, long offset,
+        int size, byte[] encryptionKey) {
       Assertions.checkState(!upstreamFormatRequired);
       commitSampleTimestamp(timeUs);
       timesUs[relativeWriteIndex] = timeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
index e317dd589c..61f97887be 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DummyTrackOutput.java
@@ -50,7 +50,8 @@ public void sampleData(ParsableByteArray data, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey) {
     // Do nothing.
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 6bf65710fc..4120110afb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -56,7 +56,7 @@
   boolean sniff(ExtractorInput input) throws IOException, InterruptedException;
 
   /**
-   * Initializes the extractor with an {@link ExtractorOutput}.
+   * Initializes the extractor with an {@link ExtractorOutput}. Called at most once.
    *
    * @param output An {@link ExtractorOutput} to receive extracted data.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
index d138c7ce3a..a547f745ca 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
@@ -21,18 +21,19 @@
 public interface ExtractorOutput {
 
   /**
-   * Called when the {@link Extractor} identifies the existence of a track in the stream.
+   * Called by the {@link Extractor} to get the {@link TrackOutput} for a specific track.
    * <p>
-   * Returns a {@link TrackOutput} that will receive track level data belonging to the track.
+   * The same {@link TrackOutput} is returned if multiple calls are made with the same
+   * {@code trackId}.
    *
-   * @param trackId A unique track identifier.
-   * @return The {@link TrackOutput} that should receive track level data belonging to the track.
+   * @param trackId A track identifier.
+   * @return The {@link TrackOutput} for the given track identifier.
    */
   TrackOutput track(int trackId);
 
   /**
-   * Called when all tracks have been identified, meaning that {@link #track(int)} will not be
-   * called again.
+   * Called when all tracks have been identified, meaning no new {@code trackId} values will be
+   * passed to {@link #track(int)}.
    */
   void endTracks();
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
similarity index 98%
rename from library/src/main/java/com/google/android/exoplayer2/extractor/ts/TimestampAdjuster.java
rename to library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
index c2d80fc146..4de4b38897 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.extractor.ts;
+package com.google.android.exoplayer2.extractor;
 
 import com.google.android.exoplayer2.C;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
index 0ce807ebb1..c4dee4b6a7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/TrackOutput.java
@@ -72,6 +72,7 @@ int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
    *     whose metadata is being passed.
    * @param encryptionKey The encryption key associated with the sample. May be null.
    */
-  void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey);
+  void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index c658ab3bcd..bc2d891dab 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -163,6 +163,9 @@
   private static final int ID_CUE_TRACK_POSITIONS = 0xB7;
   private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
   private static final int ID_LANGUAGE = 0x22B59C;
+  private static final int ID_PROJECTION = 0x7670;
+  private static final int ID_PROJECTION_PRIVATE = 0x7672;
+  private static final int ID_STEREO_MODE = 0x53B8;
 
   private static final int LACING_NONE = 0;
   private static final int LACING_XIPH = 1;
@@ -264,6 +267,7 @@
   private int[] blockLacingSampleSizes;
   private int blockTrackNumber;
   private int blockTrackNumberLength;
+  @C.BufferFlags
   private int blockFlags;
 
   // Sample reading state.
@@ -361,6 +365,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_POINT:
       case ID_CUE_TRACK_POSITIONS:
       case ID_BLOCK_GROUP:
+      case ID_PROJECTION:
         return EbmlReader.TYPE_MASTER;
       case ID_EBML_READ_VERSION:
       case ID_DOC_TYPE_READ_VERSION:
@@ -390,6 +395,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_TIME:
       case ID_CUE_CLUSTER_POSITION:
       case ID_REFERENCE_BLOCK:
+      case ID_STEREO_MODE:
         return EbmlReader.TYPE_UNSIGNED_INT;
       case ID_DOC_TYPE:
       case ID_CODEC_ID:
@@ -401,6 +407,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_SIMPLE_BLOCK:
       case ID_BLOCK:
       case ID_CODEC_PRIVATE:
+      case ID_PROJECTION_PRIVATE:
         return EbmlReader.TYPE_BINARY;
       case ID_DURATION:
       case ID_SAMPLING_FREQUENCY:
@@ -655,6 +662,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_BLOCK_DURATION:
         blockDurationUs = scaleTimecodeToUs(value);
         return;
+      case ID_STEREO_MODE:
+        int layout = (int) value;
+        switch (layout) {
+          case 0:
+            currentTrack.stereoMode = C.STEREO_MODE_MONO;
+            break;
+          case 1:
+            currentTrack.stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+            break;
+          case 3:
+            currentTrack.stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+            break;
+          default:
+            break;
+        }
+        return;
       default:
         return;
     }
@@ -705,6 +728,10 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         currentTrack.codecPrivate = new byte[contentSize];
         input.readFully(currentTrack.codecPrivate, 0, contentSize);
         return;
+      case ID_PROJECTION_PRIVATE:
+        currentTrack.projectionData = new byte[contentSize];
+        input.readFully(currentTrack.projectionData, 0, contentSize);
+        return;
       case ID_CONTENT_COMPRESSION_SETTINGS:
         // This extractor only supports header stripping, so the payload is the stripped bytes.
         currentTrack.sampleStrippedBytes = new byte[contentSize];
@@ -950,13 +977,9 @@ private void writeSampleData(ExtractorInput input, Track track, int size)
               samplePartitionCountRead = true;
             }
             int samplePartitionDataSize = samplePartitionCount * 4;
-            if (scratch.limit() < samplePartitionDataSize) {
-              scratch.reset(new byte[samplePartitionDataSize], samplePartitionDataSize);
-            }
+            scratch.reset(samplePartitionDataSize);
             input.readFully(scratch.data, 0, samplePartitionDataSize);
             sampleBytesRead += samplePartitionDataSize;
-            scratch.setPosition(0);
-            scratch.setLimit(samplePartitionDataSize);
             short subsampleCount = (short) (1 + (samplePartitionCount / 2));
             int subsampleDataSize = 2 + 6 * subsampleCount;
             if (encryptionSubsampleDataBuffer == null
@@ -1295,6 +1318,9 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public int displayWidth = Format.NO_VALUE;
     public int displayHeight = Format.NO_VALUE;
     public int displayUnit = DISPLAY_UNIT_PIXELS;
+    public byte[] projectionData = null;
+    @C.StereoMode
+    public int stereoMode = Format.NO_VALUE;
 
     // Audio elements. Initially set to their default values.
     public int channelCount = 1;
@@ -1318,7 +1344,7 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public void initializeOutput(ExtractorOutput output, int trackId) throws ParserException {
       String mimeType;
       int maxInputSize = Format.NO_VALUE;
-      int pcmEncoding = Format.NO_VALUE;
+      @C.PcmEncoding int pcmEncoding = Format.NO_VALUE;
       List<byte[]> initializationData = null;
       switch (codecId) {
         case CODEC_ID_VP8:
@@ -1433,9 +1459,9 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
       }
 
       Format format;
-      int selectionFlags = 0;
-      selectionFlags |= flagDefault ? Format.SELECTION_FLAG_DEFAULT : 0;
-      selectionFlags |= flagForced ? Format.SELECTION_FLAG_FORCED : 0;
+      @C.SelectionFlags int selectionFlags = 0;
+      selectionFlags |= flagDefault ? C.SELECTION_FLAG_DEFAULT : 0;
+      selectionFlags |= flagForced ? C.SELECTION_FLAG_FORCED : 0;
       // TODO: Consider reading the name elements of the tracks and, if present, incorporating them
       // into the trackId passed when creating the formats.
       if (MimeTypes.isAudio(mimeType)) {
@@ -1453,7 +1479,7 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
         }
         format = Format.createVideoSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, maxInputSize, width, height, Format.NO_VALUE, initializationData,
-            Format.NO_VALUE, pixelWidthHeightRatio, drmInitData);
+            Format.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode, drmInitData);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, selectionFlags, language, drmInitData);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index fdd037cde3..ab501af1cb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -131,8 +131,12 @@ public void release() {
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
-    if (synchronizedHeaderData == 0 && !synchronizeCatchingEndOfInput(input)) {
-      return RESULT_END_OF_INPUT;
+    if (synchronizedHeaderData == 0) {
+      try {
+        synchronize(input, false);
+      } catch (EOFException e) {
+        return RESULT_END_OF_INPUT;
+      }
     }
     if (seeker == null) {
       seeker = setupSeeker(input);
@@ -147,9 +151,20 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
   private int readSample(ExtractorInput extractorInput) throws IOException, InterruptedException {
     if (sampleBytesRemaining == 0) {
-      if (!maybeResynchronize(extractorInput)) {
+      extractorInput.resetPeekPosition();
+      if (!extractorInput.peekFully(scratch.data, 0, 4, true)) {
         return RESULT_END_OF_INPUT;
       }
+      scratch.setPosition(0);
+      int sampleHeaderData = scratch.readInt();
+      if ((sampleHeaderData & HEADER_MASK) != (synchronizedHeaderData & HEADER_MASK)
+          || MpegAudioHeader.getFrameSize(sampleHeaderData) == C.LENGTH_UNSET) {
+        // We have lost synchronization, so attempt to resynchronize starting at the next byte.
+        extractorInput.skipFully(1);
+        synchronizedHeaderData = 0;
+        return RESULT_CONTINUE;
+      }
+      MpegAudioHeader.populateHeader(sampleHeaderData, synchronizedHeader);
       if (basisTimeUs == C.TIME_UNSET) {
         basisTimeUs = seeker.getTimeUs(extractorInput.getPosition());
         if (forcedFirstSampleTimestampUs != C.TIME_UNSET) {
@@ -175,49 +190,13 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
     return RESULT_CONTINUE;
   }
 
-  /**
-   * Attempts to read an MPEG audio header at the current offset, resynchronizing if necessary.
-   */
-  private boolean maybeResynchronize(ExtractorInput extractorInput)
-      throws IOException, InterruptedException {
-    extractorInput.resetPeekPosition();
-    if (!extractorInput.peekFully(scratch.data, 0, 4, true)) {
-      return false;
-    }
-
-    scratch.setPosition(0);
-    int sampleHeaderData = scratch.readInt();
-    if ((sampleHeaderData & HEADER_MASK) == (synchronizedHeaderData & HEADER_MASK)) {
-      int frameSize = MpegAudioHeader.getFrameSize(sampleHeaderData);
-      if (frameSize != C.LENGTH_UNSET) {
-        MpegAudioHeader.populateHeader(sampleHeaderData, synchronizedHeader);
-        return true;
-      }
-    }
-
-    synchronizedHeaderData = 0;
-    extractorInput.skipFully(1);
-    return synchronizeCatchingEndOfInput(extractorInput);
-  }
-
-  private boolean synchronizeCatchingEndOfInput(ExtractorInput input)
-      throws IOException, InterruptedException {
-    // An EOFException will be raised if any peek operation was partially satisfied. If a seek
-    // operation resulted in reading from within the last frame, we may try to peek past the end of
-    // the file in a partially-satisfied read operation, so we need to catch the exception.
-    try {
-      return synchronize(input, false);
-    } catch (EOFException e) {
-      return false;
-    }
-  }
-
   private boolean synchronize(ExtractorInput input, boolean sniffing)
       throws IOException, InterruptedException {
-    int searched = 0;
     int validFrameCount = 0;
     int candidateSynchronizedHeaderData = 0;
     int peekedId3Bytes = 0;
+    int searchedBytes = 0;
+    int searchLimitBytes = sniffing ? MAX_SNIFF_BYTES : MAX_SYNC_BYTES;
     input.resetPeekPosition();
     if (input.getPosition() == 0) {
       Id3Util.parseId3(input, gaplessInfoHolder);
@@ -227,14 +206,9 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
       }
     }
     while (true) {
-      if (sniffing && searched == MAX_SNIFF_BYTES) {
-        return false;
-      }
-      if (!sniffing && searched == MAX_SYNC_BYTES) {
-        throw new ParserException("Searched too many bytes.");
-      }
-      if (!input.peekFully(scratch.data, 0, 4, true)) {
-        return false;
+      if (!input.peekFully(scratch.data, 0, 4, validFrameCount > 0)) {
+        // We reached the end of the stream but found at least one valid frame.
+        break;
       }
       scratch.setPosition(0);
       int headerData = scratch.readInt();
@@ -242,18 +216,23 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
       if ((candidateSynchronizedHeaderData != 0
           && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK))
           || (frameSize = MpegAudioHeader.getFrameSize(headerData)) == C.LENGTH_UNSET) {
-        // The header is invalid or doesn't match the candidate header. Try the next byte offset.
+        // The header doesn't match the candidate header or is invalid. Try the next byte offset.
+        if (searchedBytes++ == searchLimitBytes) {
+          if (!sniffing) {
+            throw new ParserException("Searched too many bytes.");
+          }
+          return false;
+        }
         validFrameCount = 0;
         candidateSynchronizedHeaderData = 0;
-        searched++;
         if (sniffing) {
           input.resetPeekPosition();
-          input.advancePeekPosition(peekedId3Bytes + searched);
+          input.advancePeekPosition(peekedId3Bytes + searchedBytes);
         } else {
           input.skipFully(1);
         }
       } else {
-        // The header is valid and matches the candidate header.
+        // The header matches the candidate header and/or is valid.
         validFrameCount++;
         if (validFrameCount == 1) {
           MpegAudioHeader.populateHeader(headerData, synchronizedHeader);
@@ -266,7 +245,7 @@ private boolean synchronize(ExtractorInput input, boolean sniffing)
     }
     // Prepare to read the synchronized frame.
     if (sniffing) {
-      input.skipFully(peekedId3Bytes + searched);
+      input.skipFully(peekedId3Bytes + searchedBytes);
     } else {
       input.resetPeekPosition();
     }
@@ -293,14 +272,17 @@ private Seeker setupSeeker(ExtractorInput input) throws IOException, Interrupted
 
     long position = input.getPosition();
     long length = input.getLength();
+    int headerData = 0;
+    Seeker seeker = null;
 
     // Check if there is a Xing header.
     int xingBase = (synchronizedHeader.version & 1) != 0
         ? (synchronizedHeader.channels != 1 ? 36 : 21) // MPEG 1
         : (synchronizedHeader.channels != 1 ? 21 : 13); // MPEG 2 or 2.5
-    frame.setPosition(xingBase);
-    int headerData = frame.readInt();
-    Seeker seeker = null;
+    if (frame.limit() >= xingBase + 4) {
+      frame.setPosition(xingBase);
+      headerData = frame.readInt();
+    }
     if (headerData == XING_HEADER || headerData == INFO_HEADER) {
       seeker = XingSeeker.create(synchronizedHeader, frame, position, length);
       if (seeker != null && !gaplessInfoHolder.hasGaplessInfo()) {
@@ -312,7 +294,7 @@ private Seeker setupSeeker(ExtractorInput input) throws IOException, Interrupted
         gaplessInfoHolder.setFromXingHeaderValue(scratch.readUnsignedInt24());
       }
       input.skipFully(synchronizedHeader.frameSize);
-    } else {
+    } else if (frame.limit() >= 40) {
       // Check if there is a VBRI header.
       frame.setPosition(36); // MPEG audio header (4 bytes) + 32 bytes.
       headerData = frame.readInt();
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 11a25fe419..0b2d5ec330 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -38,12 +39,15 @@
  */
 /* package */ final class AtomParsers {
 
+  private static final String TAG = "AtomParsers";
+
   private static final int TYPE_vide = Util.getIntegerCodeForString("vide");
   private static final int TYPE_soun = Util.getIntegerCodeForString("soun");
   private static final int TYPE_text = Util.getIntegerCodeForString("text");
   private static final int TYPE_sbtl = Util.getIntegerCodeForString("sbtl");
   private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
   private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
+  private static final int TYPE_cenc = Util.getIntegerCodeForString("cenc");
 
   /**
    * Parses a trak atom (defined in 14496-12).
@@ -248,11 +252,16 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         remainingTimestampOffsetChanges--;
       }
 
-      // Check all the expected samples have been seen.
-      Assertions.checkArgument(remainingSynchronizationSamples == 0);
-      Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
-      Assertions.checkArgument(remainingSamplesInChunk == 0);
-      Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
+      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
+      // still be playable.
+      if (remainingSynchronizationSamples != 0 || remainingSamplesAtTimestampDelta != 0
+          || remainingSamplesInChunk != 0 || remainingTimestampDeltaChanges != 0) {
+        Log.w(TAG, "Inconsistent stbl box for track " + track.id
+            + ": remainingSynchronizationSamples " + remainingSynchronizationSamples
+            + ", remainingSamplesAtTimestampDelta " + remainingSamplesAtTimestampDelta
+            + ", remainingSamplesInChunk " + remainingSamplesInChunk
+            + ", remainingTimestampDeltaChanges " + remainingTimestampDeltaChanges);
+      }
     } else {
       long[] chunkOffsetsBytes = new long[chunkIterator.length];
       int[] chunkSampleCounts = new int[chunkIterator.length];
@@ -636,7 +645,7 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
             0 /* subsample timing is absolute */);
       } else if (childAtomType == Atom.TYPE_c608) {
         out.format = Format.createTextSampleFormat(Integer.toString(trackId),
-            MimeTypes.APPLICATION_EIA608, null, Format.NO_VALUE, 0, language, drmInitData);
+            MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE, 0, language, drmInitData);
         out.requiredSampleTransformation = Track.TRANSFORMATION_CEA608_CDAT;
       }
       stsd.setPosition(childStartPosition + childAtomSize);
@@ -665,6 +674,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
     List<byte[]> initializationData = null;
     String mimeType = null;
     byte[] projectionData = null;
+    @C.StereoMode
     int stereoMode = Format.NO_VALUE;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
@@ -889,7 +899,7 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
 
     if (out.format == null && mimeType != null) {
       // TODO: Determine the correct PCM encoding.
-      int pcmEncoding =
+      @C.PcmEncoding int pcmEncoding =
           MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT : Format.NO_VALUE;
       out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
           Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, pcmEncoding,
@@ -995,7 +1005,7 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
 
   /**
    * Parses encryption data from an audio/video sample entry, populating {@code out} and returning
-   * the unencrypted atom type, or 0 if no sinf atom was present.
+   * the unencrypted atom type, or 0 if no common encryption sinf atom was present.
    */
   private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int position,
       int size, StsdData out, int entryIndex) {
@@ -1008,10 +1018,10 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
       if (childAtomType == Atom.TYPE_sinf) {
         Pair<Integer, TrackEncryptionBox> result = parseSinfFromParent(parent, childPosition,
             childAtomSize);
-        Integer dataFormat = result.first;
-        Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
-        out.trackEncryptionBoxes[entryIndex] = result.second;
-        return dataFormat;
+        if (result != null) {
+          out.trackEncryptionBoxes[entryIndex] = result.second;
+          return result.first;
+        }
       }
       childPosition += childAtomSize;
     }
@@ -1023,6 +1033,7 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
       int position, int size) {
     int childPosition = position + Atom.HEADER_SIZE;
 
+    boolean isCencScheme = false;
     TrackEncryptionBox trackEncryptionBox = null;
     Integer dataFormat = null;
     while (childPosition - position < size) {
@@ -1033,15 +1044,20 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
         dataFormat = parent.readInt();
       } else if (childAtomType == Atom.TYPE_schm) {
         parent.skipBytes(4);
-        parent.readInt(); // schemeType. Expect cenc
-        parent.readInt(); // schemeVersion. Expect 0x00010000
+        isCencScheme = parent.readInt() == TYPE_cenc;
       } else if (childAtomType == Atom.TYPE_schi) {
         trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
       }
       childPosition += childAtomSize;
     }
 
-    return Pair.create(dataFormat, trackEncryptionBox);
+    if (isCencScheme) {
+      Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
+      Assertions.checkArgument(trackEncryptionBox != null, "schi->tenc atom is mandatory");
+      return Pair.create(dataFormat, trackEncryptionBox);
+    } else {
+      return null;
+    }
   }
 
   private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
@@ -1169,6 +1185,7 @@ public TkhdData(int id, long duration, int rotationDegrees) {
 
     public Format format;
     public int nalUnitLengthFieldLength;
+    @Track.Transformation
     public int requiredSampleTransformation;
 
     public StsdData(int numberOfEntries) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 103acdd6f9..9966125c46 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import android.support.annotation.IntDef;
 import android.util.Log;
 import android.util.Pair;
 import android.util.SparseArray;
@@ -29,6 +30,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.extractor.mp4.Atom.LeafAtom;
@@ -38,6 +40,8 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -64,6 +68,13 @@
   private static final String TAG = "FragmentedMp4Extractor";
   private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
 
+  /**
+   * Flags controlling the behavior of the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
+      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_SIDELOADED})
+  public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
    * The workaround overrides the sync frame flags in the stream, forcing them to false except for
@@ -72,12 +83,10 @@
    * This flag does nothing if the stream is not a video stream.
    */
   public static final int FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME = 1;
-
   /**
    * Flag to ignore any tfdt boxes in the stream.
    */
   public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
-
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
@@ -95,6 +104,7 @@
   private static final int STATE_READING_SAMPLE_CONTINUE = 4;
 
   // Workarounds.
+  @Flags
   private final int flags;
   private final Track sideloadedTrack;
 
@@ -106,6 +116,9 @@
   private final ParsableByteArray nalLength;
   private final ParsableByteArray encryptionSignalByte;
 
+  // Adjusts sample timestamps.
+  private final TimestampAdjuster timestampAdjuster;
+
   // Parser state.
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
@@ -131,24 +144,28 @@
   private boolean haveOutputSeekMap;
 
   public FragmentedMp4Extractor() {
-    this(0);
+    this(0, null);
   }
 
   /**
-   * @param flags Flags to allow parsing of faulty streams.
+   * @param flags Flags that control the extractor's behavior.
+   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    */
-  public FragmentedMp4Extractor(int flags) {
-    this(flags, null);
+  public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster) {
+    this(flags, null, timestampAdjuster);
   }
 
   /**
-   * @param flags Flags to allow parsing of faulty streams.
+   * @param flags Flags that control the extractor's behavior.
    * @param sideloadedTrack Sideloaded track information, in the case that the extractor
    *     will not receive a moov box in the input data.
+   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    */
-  public FragmentedMp4Extractor(int flags, Track sideloadedTrack) {
+  public FragmentedMp4Extractor(@Flags int flags, Track sideloadedTrack,
+      TimestampAdjuster timestampAdjuster) {
     this.sideloadedTrack = sideloadedTrack;
     this.flags = flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
+    this.timestampAdjuster = timestampAdjuster;
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
@@ -422,7 +439,7 @@ private static long parseMehd(ParsableByteArray mehd) {
   }
 
   private static void parseMoof(ContainerAtom moof, SparseArray<TrackBundle> trackBundleArray,
-      int flags, byte[] extendedTypeScratch) throws ParserException {
+      @Flags int flags, byte[] extendedTypeScratch) throws ParserException {
     int moofContainerChildrenSize = moof.containerChildren.size();
     for (int i = 0; i < moofContainerChildrenSize; i++) {
       Atom.ContainerAtom child = moof.containerChildren.get(i);
@@ -437,7 +454,7 @@ private static void parseMoof(ContainerAtom moof, SparseArray<TrackBundle> track
    * Parses a traf atom (defined in 14496-12).
    */
   private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> trackBundleArray,
-      int flags, byte[] extendedTypeScratch) throws ParserException {
+      @Flags int flags, byte[] extendedTypeScratch) throws ParserException {
     LeafAtom tfhd = traf.getLeafAtomOfType(Atom.TYPE_tfhd);
     TrackBundle trackBundle = parseTfhd(tfhd.data, trackBundleArray, flags);
     if (trackBundle == null) {
@@ -488,7 +505,7 @@ private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> track
   }
 
   private static void parseTruns(ContainerAtom traf, TrackBundle trackBundle, long decodeTime,
-      int flags) {
+      @Flags int flags) {
     int trunCount = 0;
     int totalSampleCount = 0;
     List<LeafAtom> leafChildren = traf.leafChildren;
@@ -643,8 +660,8 @@ private static long parseTfdt(ParsableByteArray tfdt) {
    * @param trun The trun atom to decode.
    * @return The starting position of samples for the next run.
    */
-  private static int parseTrun(TrackBundle trackBundle, int index, long decodeTime, int flags,
-      ParsableByteArray trun, int trackRunStart) {
+  private static int parseTrun(TrackBundle trackBundle, int index, long decodeTime,
+      @Flags int flags, ParsableByteArray trun, int trackRunStart) {
     trun.setPosition(Atom.HEADER_SIZE);
     int fullAtom = trun.readInt();
     int atomFlags = Atom.parseFullAtomFlags(fullAtom);
@@ -994,7 +1011,7 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     }
 
     long sampleTimeUs = fragment.getSamplePresentationTime(sampleIndex) * 1000L;
-    int sampleFlags = (fragment.definesEncryptionData ? C.BUFFER_FLAG_ENCRYPTED : 0)
+    @C.BufferFlags int sampleFlags = (fragment.definesEncryptionData ? C.BUFFER_FLAG_ENCRYPTED : 0)
         | (fragment.sampleIsSyncFrameTable[sampleIndex] ? C.BUFFER_FLAG_KEY_FRAME : 0);
     int sampleDescriptionIndex = fragment.header.sampleDescriptionIndex;
     byte[] encryptionKey = null;
@@ -1003,6 +1020,9 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           ? fragment.trackEncryptionBox.keyId
           : track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex].keyId;
     }
+    if (timestampAdjuster != null) {
+      sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
+    }
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
     currentTrackBundle.currentSampleIndex++;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
index 842b648ec2..44d5824945 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
@@ -100,13 +100,14 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
     while (bytesSearched < bytesToSearch) {
       // Read an atom header.
       int headerSize = Atom.HEADER_SIZE;
+      buffer.reset(headerSize);
       input.peekFully(buffer.data, 0, headerSize);
-      buffer.setPosition(0);
       long atomSize = buffer.readUnsignedInt();
       int atomType = buffer.readInt();
       if (atomSize == Atom.LONG_SIZE_PREFIX) {
         headerSize = Atom.LONG_HEADER_SIZE;
         input.peekFully(buffer.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
+        buffer.setLimit(Atom.LONG_HEADER_SIZE);
         atomSize = buffer.readUnsignedLongToLong();
       }
 
@@ -139,9 +140,7 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
         if (atomDataSize < 8) {
           return false;
         }
-        if (buffer.capacity() < atomDataSize) {
-          buffer.reset(new byte[atomDataSize], atomDataSize);
-        }
+        buffer.reset(atomDataSize);
         input.peekFully(buffer.data, 0, atomDataSize);
         int brandsCount = atomDataSize / 4;
         for (int i = 0; i < brandsCount; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index 5d48529794..c723704d37 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -15,14 +15,23 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Encapsulates information describing an MP4 track.
  */
 public final class Track {
 
+  /**
+   * The transformation to apply to samples in the track, if any.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TRANSFORMATION_NONE, TRANSFORMATION_CEA608_CDAT})
+  public @interface Transformation {}
   /**
    * A no-op sample transformation.
    */
@@ -66,6 +75,7 @@
    * One of {@code TRANSFORMATION_*}. Defines the transformation to apply before outputting each
    * sample.
    */
+  @Transformation
   public final int sampleTransformation;
 
   /**
@@ -90,7 +100,7 @@
   public final int nalUnitLengthFieldLength;
 
   public Track(int id, int type, long timescale, long movieTimescale, long durationUs,
-      Format format, int sampleTransformation,
+      Format format, @Transformation int sampleTransformation,
       TrackEncryptionBox[] sampleDescriptionEncryptionBoxes, int nalUnitLengthFieldLength,
       long[] editListDurations, long[] editListMediaTimes) {
     this.id = id;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
index 54e3fcd957..cf479eaf3e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
@@ -49,7 +49,8 @@
    */
   public final int[] flags;
 
-  TrackSampleTable(long[] offsets, int[] sizes, int maximumSize, long[] timestampsUs, int[] flags) {
+  public TrackSampleTable(long[] offsets, int[] sizes, int maximumSize, long[] timestampsUs,
+      int[] flags) {
     Assertions.checkArgument(sizes.length == timestampsUs.length);
     Assertions.checkArgument(offsets.length == timestampsUs.length);
     Assertions.checkArgument(flags.length == timestampsUs.length);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
index 8a63c5557b..ea9458a657 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
@@ -30,7 +30,7 @@
 import java.io.IOException;
 
 /**
- * Extracts EIA-608 data from a RawCC file
+ * Extracts CEA data from a RawCC file.
  */
 public final class RawCcExtractor implements Extractor {
 
@@ -68,7 +68,7 @@ public void init(ExtractorOutput output) {
     trackOutput = extractorOutput.track(0);
     extractorOutput.endTracks();
 
-    trackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_EIA608,
+    trackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608,
         null, Format.NO_VALUE, 0, null, null));
   }
 
@@ -154,13 +154,8 @@ private void parseSamples(ExtractorInput input) throws IOException, InterruptedE
       dataScratch.reset();
       input.readFully(dataScratch.data, 0, 3);
 
-      // only accept EIA-608 packets which have validity (6th bit) == 1 and
-      // type (7-8th bits) == 0; i.e. ccDataPkt[0] == 0bXXXXX100
-      int ccValidityAndType = dataScratch.readUnsignedByte() & 0x07;
-      if (ccValidityAndType == 0x04) {
-        trackOutput.sampleData(dataScratch, 2);
-        sampleBytesWritten += 2;
-      }
+      trackOutput.sampleData(dataScratch, 3);
+      sampleBytesWritten += 3;
     }
 
     if (sampleBytesWritten > 0) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 8d67be4434..7fc8b429a8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -107,6 +108,9 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
           return true;
         }
         int frameSize = Ac3Util.parseAc3SyncframeSize(scratch.data);
+        if (frameSize == C.LENGTH_UNSET) {
+          return false;
+        }
         input.advancePeekPosition(frameSize - 5);
       }
     }
@@ -114,7 +118,8 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-    reader = new Ac3Reader(output.track(0)); // TODO: Add support for embedded ID3.
+    reader = new Ac3Reader(); // TODO: Add support for embedded ID3.
+    reader.init(output, new TrackIdGenerator(0, 1));
     output.endTracks();
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index cbe6d2e9c8..a9d3319f87 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.Ac3Util;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -37,6 +38,8 @@
   private final ParsableByteArray headerScratchBytes;
   private final String language;
 
+  private TrackOutput output;
+
   private int state;
   private int bytesRead;
 
@@ -54,21 +57,17 @@
 
   /**
    * Constructs a new reader for (E-)AC-3 elementary streams.
-   *
-   * @param output Track output for extracted samples.
    */
-  public Ac3Reader(TrackOutput output) {
-    this(output, null);
+  public Ac3Reader() {
+    this(null);
   }
 
   /**
    * Constructs a new reader for (E-)AC-3 elementary streams.
    *
-   * @param output Track output for extracted samples.
    * @param language Track language.
    */
-  public Ac3Reader(TrackOutput output, String language) {
-    super(output);
+  public Ac3Reader(String language) {
     headerScratchBits = new ParsableBitArray(new byte[HEADER_SIZE]);
     headerScratchBytes = new ParsableByteArray(headerScratchBits.data);
     state = STATE_FINDING_SYNC;
@@ -82,6 +81,11 @@ public void seek() {
     lastByteWas0B = false;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator generator) {
+    output = extractorOutput.track(generator.getNextId());
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     timeUs = pesTimeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index f131d8997b..7a9cbd4bb1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
@@ -126,7 +127,8 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-    reader = new AdtsReader(output.track(0), output.track(1));
+    reader = new AdtsReader(true);
+    reader.init(output, new TrackIdGenerator(0, 1));
     output.endTracks();
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index ac493c7d32..d0474f7e44 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -19,6 +19,8 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.DummyTrackOutput;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -53,11 +55,14 @@
   private static final int ID3_SIZE_OFFSET = 6;
   private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
 
+  private final boolean exposeId3;
   private final ParsableBitArray adtsScratch;
   private final ParsableByteArray id3HeaderBuffer;
-  private final TrackOutput id3Output;
   private final String language;
 
+  private TrackOutput output;
+  private TrackOutput id3Output;
+
   private int state;
   private int bytesRead;
 
@@ -77,26 +82,21 @@
   private long currentSampleDuration;
 
   /**
-   * @param output A {@link TrackOutput} to which AAC samples should be written.
-   * @param id3Output A {@link TrackOutput} to which ID3 samples should be written.
+   * @param exposeId3 True if the reader should expose ID3 information.
    */
-  public AdtsReader(TrackOutput output, TrackOutput id3Output) {
-    this(output, id3Output, null);
+  public AdtsReader(boolean exposeId3) {
+    this(exposeId3, null);
   }
 
   /**
-   * @param output A {@link TrackOutput} to which AAC samples should be written.
-   * @param id3Output A {@link TrackOutput} to which ID3 samples should be written.
+   * @param exposeId3 True if the reader should expose ID3 information.
    * @param language Track language.
    */
-  public AdtsReader(TrackOutput output, TrackOutput id3Output, String language) {
-    super(output);
-    this.id3Output = id3Output;
-    id3Output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null,
-        Format.NO_VALUE, null));
+  public AdtsReader(boolean exposeId3, String language) {
     adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
     id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
     setFindingSampleState();
+    this.exposeId3 = exposeId3;
     this.language = language;
   }
 
@@ -105,6 +105,18 @@ public void seek() {
     setFindingSampleState();
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+    if (exposeId3) {
+      id3Output = extractorOutput.track(idGenerator.getNextId());
+      id3Output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null,
+          Format.NO_VALUE, null));
+    } else {
+      id3Output = new DummyTrackOutput();
+    }
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     timeUs = pesTimeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java
new file mode 100644
index 0000000000..58a0e55f02
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultStreamReaderFactory.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ts;
+
+import android.support.annotation.IntDef;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Default implementation for {@link ElementaryStreamReader.Factory}.
+ */
+public final class DefaultStreamReaderFactory implements ElementaryStreamReader.Factory {
+
+  /**
+   * Flags controlling elementary stream readers behaviour.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_ALLOW_NON_IDR_KEYFRAMES, FLAG_IGNORE_AAC_STREAM,
+      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS})
+  public @interface Flags {
+  }
+  public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
+  public static final int FLAG_IGNORE_AAC_STREAM = 2;
+  public static final int FLAG_IGNORE_H264_STREAM = 4;
+  public static final int FLAG_DETECT_ACCESS_UNITS = 8;
+
+  @Flags
+  private final int flags;
+
+  public DefaultStreamReaderFactory() {
+    this(0);
+  }
+
+  public DefaultStreamReaderFactory(@Flags int flags) {
+    this.flags = flags;
+  }
+
+  @Override
+  public ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo) {
+    switch (streamType) {
+      case TsExtractor.TS_STREAM_TYPE_MPA:
+      case TsExtractor.TS_STREAM_TYPE_MPA_LSF:
+        return new MpegAudioReader(esInfo.language);
+      case TsExtractor.TS_STREAM_TYPE_AAC:
+        return (flags & FLAG_IGNORE_AAC_STREAM) != 0 ? null
+            : new AdtsReader(false, esInfo.language);
+      case TsExtractor.TS_STREAM_TYPE_AC3:
+      case TsExtractor.TS_STREAM_TYPE_E_AC3:
+        return new Ac3Reader(esInfo.language);
+      case TsExtractor.TS_STREAM_TYPE_DTS:
+      case TsExtractor.TS_STREAM_TYPE_HDMV_DTS:
+        return new DtsReader(esInfo.language);
+      case TsExtractor.TS_STREAM_TYPE_H262:
+        return new H262Reader();
+      case TsExtractor.TS_STREAM_TYPE_H264:
+        return (flags & FLAG_IGNORE_H264_STREAM) != 0 ? null
+            : new H264Reader((flags & FLAG_ALLOW_NON_IDR_KEYFRAMES) != 0,
+                (flags & FLAG_DETECT_ACCESS_UNITS) != 0);
+      case TsExtractor.TS_STREAM_TYPE_H265:
+        return new H265Reader();
+      case TsExtractor.TS_STREAM_TYPE_ID3:
+        return new Id3Reader();
+      default:
+        return null;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index e2112df755..42223ef285 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.DtsUtil;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
@@ -37,6 +38,8 @@
   private final ParsableByteArray headerScratchBytes;
   private final String language;
 
+  private TrackOutput output;
+
   private int state;
   private int bytesRead;
 
@@ -54,20 +57,9 @@
   /**
    * Constructs a new reader for DTS elementary streams.
    *
-   * @param output Track output for extracted samples.
-   */
-  public DtsReader(TrackOutput output) {
-    this(output, null);
-  }
-
-  /**
-   * Constructs a new reader for DTS elementary streams.
-   *
-   * @param output Track output for extracted samples.
    * @param language Track language.
    */
-  public DtsReader(TrackOutput output, String language) {
-    super(output);
+  public DtsReader(String language) {
     headerScratchBytes = new ParsableByteArray(new byte[HEADER_SIZE]);
     headerScratchBytes.data[0] = (byte) ((SYNC_VALUE >> 24) & 0xFF);
     headerScratchBytes.data[1] = (byte) ((SYNC_VALUE >> 16) & 0xFF);
@@ -84,6 +76,11 @@ public void seek() {
     syncBytes = 0;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     timeUs = pesTimeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index 13029ca04e..e2efbebb43 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -15,21 +15,74 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
  * Extracts individual samples from an elementary media stream, preserving original order.
  */
-/* package */ abstract class ElementaryStreamReader {
+public abstract class ElementaryStreamReader {
 
-  protected final TrackOutput output;
+  /**
+   * Factory of {@link ElementaryStreamReader} instances.
+   */
+  public interface Factory {
+
+    /**
+     * Returns an {@link ElementaryStreamReader} for a given PMT entry. May return null if the
+     * stream type is not supported or if the stream already has a reader assigned to it.
+     *
+     * @param streamType Stream type value as defined in the PMT entry or associated descriptors.
+     * @param esInfo Information associated to the elementary stream provided in the PMT.
+     * @return An {@link ElementaryStreamReader} for the elementary streams carried by the provided
+     *     pid. {@code null} if the stream is not supported or if it should be ignored.
+     */
+    ElementaryStreamReader createStreamReader(int streamType, EsInfo esInfo);
+
+  }
+
+  /**
+   * Holds descriptor information associated with an elementary stream.
+   */
+  public static final class EsInfo {
+
+    public final int streamType;
+    public String language;
+    public byte[] descriptorBytes;
+
+    /**
+     * @param streamType The type of the stream as defined by the
+     *     {@link TsExtractor}{@code .TS_STREAM_TYPE_*}.
+     * @param language The language of the stream, as defined by ISO/IEC 13818-1, section 2.6.18.
+     * @param descriptorBytes The descriptor bytes associated to the stream.
+     */
+    public EsInfo(int streamType, String language, byte[] descriptorBytes) {
+      this.streamType = streamType;
+      this.language = language;
+      this.descriptorBytes = descriptorBytes;
+    }
+
+  }
 
   /**
-   * @param output A {@link TrackOutput} to which samples should be written.
+   * Generates track ids for initializing {@link ElementaryStreamReader}s' {@link TrackOutput}s.
    */
-  protected ElementaryStreamReader(TrackOutput output) {
-    this.output = output;
+  public static final class TrackIdGenerator {
+
+    private final int firstId;
+    private final int idIncrement;
+    private int generatedIdCount;
+
+    public TrackIdGenerator(int firstId, int idIncrement) {
+      this.firstId = firstId;
+      this.idIncrement = idIncrement;
+    }
+
+    public int getNextId() {
+      return firstId + idIncrement * generatedIdCount++;
+    }
+
   }
 
   /**
@@ -37,6 +90,15 @@ protected ElementaryStreamReader(TrackOutput output) {
    */
   public abstract void seek();
 
+  /**
+   * Initializes the reader by providing outputs and ids for the tracks.
+   *
+   * @param extractorOutput The {@link ExtractorOutput} that receives the extracted data.
+   * @param idGenerator A {@link TrackIdGenerator} that generates unique track ids for the
+   *     {@link TrackOutput}s.
+   */
+  public abstract void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator);
+
   /**
    * Called when a packet starts.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index a898ff598c..fbfe7e1209 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -18,6 +18,7 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
@@ -35,6 +36,8 @@
   private static final int START_EXTENSION = 0xB5;
   private static final int START_GROUP = 0xB8;
 
+  private TrackOutput output;
+
   // Maps (frame_rate_code - 1) indices to values, as defined in ITU-T H.262 Table 6-4.
   private static final double[] FRAME_RATE_VALUES = new double[] {
       24000d / 1001, 24, 25, 30000d / 1001, 30, 50, 60000d / 1001, 60};
@@ -58,8 +61,7 @@
   private long framePosition;
   private long frameTimeUs;
 
-  public H262Reader(TrackOutput output) {
-    super(output);
+  public H262Reader() {
     prefixFlags = new boolean[4];
     csdBuffer = new CsdBuffer(128);
   }
@@ -73,6 +75,11 @@ public void seek() {
     totalBytesWritten = 0;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     pesPtsUsAvailable = pesTimeUs != C.TIME_UNSET;
@@ -128,7 +135,7 @@ public void consume(ParsableByteArray data) {
       if (hasOutputFormat && (startCodeValue == START_GROUP || startCodeValue == START_PICTURE)) {
         int bytesWrittenPastStartCode = limit - startCodeOffset;
         if (foundFirstFrameInGroup) {
-          int flags = isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+          @C.BufferFlags int flags = isKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
           int size = (int) (totalBytesWritten - framePosition) - bytesWrittenPastStartCode;
           output.sampleMetadata(frameTimeUs, flags, size, bytesWrittenPastStartCode, null);
           isKeyframe = false;
@@ -136,7 +143,7 @@ public void consume(ParsableByteArray data) {
         if (startCodeValue == START_GROUP) {
           foundFirstFrameInGroup = false;
           isKeyframe = true;
-        } else /* startCode == START_PICTURE */ {
+        } else /* startCodeValue == START_PICTURE */ {
           frameTimeUs = pesPtsUsAvailable ? pesTimeUs : (frameTimeUs + frameDurationUs);
           framePosition = totalBytesWritten - bytesWrittenPastStartCode;
           pesPtsUsAvailable = false;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 8bb72f6e79..6fee9ea6d7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -18,6 +18,7 @@
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
@@ -37,17 +38,20 @@
   private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
   private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
 
-  // State that should not be reset on seek.
-  private boolean hasOutputFormat;
-
-  // State that should be reset on seek.
-  private final SeiReader seiReader;
-  private final boolean[] prefixFlags;
-  private final SampleReader sampleReader;
+  private final boolean allowNonIdrKeyframes;
+  private final boolean detectAccessUnits;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer sei;
   private long totalBytesWritten;
+  private final boolean[] prefixFlags;
+
+  private TrackOutput output;
+  private SeiReader seiReader;
+  private SampleReader sampleReader;
+
+  // State that should not be reset on seek.
+  private boolean hasOutputFormat;
 
   // Per packet state that gets reset at the start of each packet.
   private long pesTimeUs;
@@ -56,19 +60,15 @@
   private final ParsableByteArray seiWrapper;
 
   /**
-   * @param output A {@link TrackOutput} to which H.264 samples should be written.
-   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
    * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
    *     synchronization samples (key-frames).
    * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
    *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
    */
-  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes,
-      boolean detectAccessUnits) {
-    super(output);
-    this.seiReader = seiReader;
+  public H264Reader(boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
     prefixFlags = new boolean[3];
-    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
+    this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+    this.detectAccessUnits = detectAccessUnits;
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
@@ -85,6 +85,13 @@ public void seek() {
     totalBytesWritten = 0;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
+    seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     this.pesTimeUs = pesTimeUs;
@@ -420,7 +427,7 @@ public void endNalUnit(long position, int offset) {
     }
 
     private void outputSample(int offset) {
-      int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+      @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
       int size = (int) (nalUnitStartPosition - samplePosition);
       output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index d6c431edec..57d7e77bb7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -18,6 +18,7 @@
 import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
@@ -42,18 +43,20 @@
   private static final int PREFIX_SEI_NUT = 39;
   private static final int SUFFIX_SEI_NUT = 40;
 
+  private TrackOutput output;
+  private SampleReader sampleReader;
+  private SeiReader seiReader;
+
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
 
   // State that should be reset on seek.
-  private final SeiReader seiReader;
   private final boolean[] prefixFlags;
   private final NalUnitTargetBuffer vps;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer prefixSei;
   private final NalUnitTargetBuffer suffixSei; // TODO: Are both needed?
-  private final SampleReader sampleReader;
   private long totalBytesWritten;
 
   // Per packet state that gets reset at the start of each packet.
@@ -62,20 +65,13 @@
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
-  /**
-   * @param output A {@link TrackOutput} to which H.265 samples should be written.
-   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
-   */
-  public H265Reader(TrackOutput output, SeiReader seiReader) {
-    super(output);
-    this.seiReader = seiReader;
+  public H265Reader() {
     prefixFlags = new boolean[3];
     vps = new NalUnitTargetBuffer(VPS_NUT, 128);
     sps = new NalUnitTargetBuffer(SPS_NUT, 128);
     pps = new NalUnitTargetBuffer(PPS_NUT, 128);
     prefixSei = new NalUnitTargetBuffer(PREFIX_SEI_NUT, 128);
     suffixSei = new NalUnitTargetBuffer(SUFFIX_SEI_NUT, 128);
-    sampleReader = new SampleReader(output);
     seiWrapper = new ParsableByteArray();
   }
 
@@ -91,6 +87,13 @@ public void seek() {
     totalBytesWritten = 0;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+    sampleReader = new SampleReader(output);
+    seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     this.pesTimeUs = pesTimeUs;
@@ -471,7 +474,7 @@ public void endNalUnit(long position, int offset) {
     }
 
     private void outputSample(int offset) {
-      int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
+      @C.BufferFlags int flags = sampleIsKeyframe ? C.BUFFER_FLAG_KEY_FRAME : 0;
       int size = (int) (nalUnitStartPosition - samplePosition);
       output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index 1001f1a1ae..2c657d4aca 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -30,6 +31,8 @@
 
   private final ParsableByteArray id3Header;
 
+  private TrackOutput output;
+
   // State that should be reset on seek.
   private boolean writingSample;
 
@@ -38,10 +41,7 @@
   private int sampleSize;
   private int sampleBytesRead;
 
-  public Id3Reader(TrackOutput output) {
-    super(output);
-    output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE,
-        null));
+  public Id3Reader() {
     id3Header = new ParsableByteArray(ID3_HEADER_SIZE);
   }
 
@@ -50,6 +50,13 @@ public void seek() {
     writingSample = false;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+    output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE,
+        null));
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     if (!dataAlignmentIndicator) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index c78882c2c9..d25d0703ae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -36,6 +37,8 @@
   private final MpegAudioHeader header;
   private final String language;
 
+  private TrackOutput output;
+
   private int state;
   private int frameBytesRead;
   private boolean hasOutputFormat;
@@ -50,12 +53,11 @@
   // The timestamp to attach to the next sample in the current packet.
   private long timeUs;
 
-  public MpegAudioReader(TrackOutput output) {
-    this(output, null);
+  public MpegAudioReader() {
+    this(null);
   }
 
-  public MpegAudioReader(TrackOutput output, String language) {
-    super(output);
+  public MpegAudioReader(String language) {
     state = STATE_FINDING_HEADER;
     // The first byte of an MPEG Audio frame header is always 0xFF.
     headerScratch = new ParsableByteArray(4);
@@ -71,6 +73,11 @@ public void seek() {
     lastByteWasFF = false;
   }
 
+  @Override
+  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    output = extractorOutput.track(idGenerator.getNextId());
+  }
+
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
     timeUs = pesTimeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index ff86be4165..b615a3e8ee 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -23,6 +23,8 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
@@ -48,6 +50,7 @@
   private static final int SYSTEM_HEADER_START_CODE = 0x000001BB;
   private static final int PACKET_START_CODE_PREFIX = 0x000001;
   private static final int MPEG_PROGRAM_END_CODE = 0x000001B9;
+  private static final int MAX_STREAM_ID_PLUS_ONE = 0x100;
   private static final long MAX_SEARCH_LENGTH = 1024 * 1024;
 
   public static final int PRIVATE_STREAM_1 = 0xBD;
@@ -153,8 +156,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       input.peekFully(psPacketBuffer.data, 0, 10);
 
       // We only care about the pack_stuffing_length in here, skip the first 77 bits.
-      psPacketBuffer.setPosition(0);
-      psPacketBuffer.skipBytes(9);
+      psPacketBuffer.setPosition(9);
 
       // Last 3 bits is the length.
       int packStuffingLength = psPacketBuffer.readUnsignedByte() & 0x07;
@@ -189,16 +191,18 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
           // Private stream, used for AC3 audio.
           // NOTE: This may need further parsing to determine if its DTS, but that's likely only
           // valid for DVDs.
-          elementaryStreamReader = new Ac3Reader(output.track(streamId));
+          elementaryStreamReader = new Ac3Reader();
           foundAudioTrack = true;
         } else if (!foundAudioTrack && (streamId & AUDIO_STREAM_MASK) == AUDIO_STREAM) {
-          elementaryStreamReader = new MpegAudioReader(output.track(streamId));
+          elementaryStreamReader = new MpegAudioReader();
           foundAudioTrack = true;
         } else if (!foundVideoTrack && (streamId & VIDEO_STREAM_MASK) == VIDEO_STREAM) {
-          elementaryStreamReader = new H262Reader(output.track(streamId));
+          elementaryStreamReader = new H262Reader();
           foundVideoTrack = true;
         }
         if (elementaryStreamReader != null) {
+          TrackIdGenerator idGenerator = new TrackIdGenerator(streamId, MAX_STREAM_ID_PLUS_ONE);
+          elementaryStreamReader.init(output, idGenerator);
           payloadReader = new PesReader(elementaryStreamReader, timestampAdjuster);
           psPayloadReaders.put(streamId, payloadReader);
         }
@@ -209,7 +213,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       }
     }
 
-    // The next 2 bytes are the length, once we have that we can consume the complete packet.
+    // The next 2 bytes are the length. Once we have that we can consume the complete packet.
     input.peekFully(psPacketBuffer.data, 0, 2);
     psPacketBuffer.setPosition(0);
     int payloadLength = psPacketBuffer.readUnsignedShort();
@@ -219,14 +223,10 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       // Just skip this data.
       input.skipFully(pesLength);
     } else {
-      if (psPacketBuffer.capacity() < pesLength) {
-        // Reallocate for this and future packets.
-        psPacketBuffer.reset(new byte[pesLength], pesLength);
-      }
+      psPacketBuffer.reset(pesLength);
       // Read the whole packet and the header for consumption.
       input.readFully(psPacketBuffer.data, 0, pesLength);
       psPacketBuffer.setPosition(6);
-      psPacketBuffer.setLimit(pesLength);
       payloadReader.consume(psPacketBuffer);
       psPacketBuffer.setLimit(psPacketBuffer.capacity());
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index a921e4c38f..4971c0c2b1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -18,12 +18,12 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.text.eia608.Eia608Decoder;
+import com.google.android.exoplayer2.text.cea.Cea608Decoder;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
 /**
- * Consumes SEI buffers, outputting contained EIA608 messages to a {@link TrackOutput}.
+ * Consumes SEI buffers, outputting contained CEA-608 messages to a {@link TrackOutput}.
  */
 /* package */ final class SeiReader {
 
@@ -31,7 +31,7 @@
 
   public SeiReader(TrackOutput output) {
     this.output = output;
-    output.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_EIA608, null,
+    output.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, null,
         Format.NO_VALUE, 0, null, null));
   }
 
@@ -51,7 +51,7 @@ public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
         payloadSize += b;
       } while (b == 0xFF);
       // Process the payload.
-      if (Eia608Decoder.isSeiMessageEia608(payloadType, payloadSize, seiBuffer)) {
+      if (Cea608Decoder.isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
         // Ignore country_code (1) + provider_code (2) + user_identifier (4)
         // + user_data_type_code (1).
         seiBuffer.skipBytes(8);
@@ -60,13 +60,13 @@ public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
         seiBuffer.skipBytes(1);
         int sampleBytes = 0;
         for (int i = 0; i < ccCount; i++) {
-          int ccValidityAndType = seiBuffer.readUnsignedByte() & 0x07;
-          // Check that validity == 1 and type == 0.
+          int ccValidityAndType = seiBuffer.peekUnsignedByte() & 0x07;
+          // Check that validity == 1 and type == 0 (i.e. NTSC_CC_FIELD_1).
           if (ccValidityAndType != 0x04) {
-            seiBuffer.skipBytes(2);
+            seiBuffer.skipBytes(3);
           } else {
-            sampleBytes += 2;
-            output.sampleData(seiBuffer, 2);
+            sampleBytes += 3;
+            output.sampleData(seiBuffer, 3);
           }
         }
         output.sampleMetadata(pesTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleBytes, 0, null);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 5c9e8cf673..bac362d711 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -20,18 +20,22 @@
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.EsInfo;
+import com.google.android.exoplayer2.extractor.ts.ElementaryStreamReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.Arrays;
 
 /**
  * Facilitates the extraction of data from the MPEG-2 TS container format.
@@ -50,30 +54,24 @@
 
   };
 
-  public static final int WORKAROUND_ALLOW_NON_IDR_KEYFRAMES = 1;
-  public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
-  public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
-  public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
-  public static final int WORKAROUND_MAP_BY_TYPE = 16;
+  public static final int TS_STREAM_TYPE_MPA = 0x03;
+  public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
+  public static final int TS_STREAM_TYPE_AAC = 0x0F;
+  public static final int TS_STREAM_TYPE_AC3 = 0x81;
+  public static final int TS_STREAM_TYPE_DTS = 0x8A;
+  public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
+  public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+  public static final int TS_STREAM_TYPE_H262 = 0x02;
+  public static final int TS_STREAM_TYPE_H264 = 0x1B;
+  public static final int TS_STREAM_TYPE_H265 = 0x24;
+  public static final int TS_STREAM_TYPE_ID3 = 0x15;
 
   private static final String TAG = "TsExtractor";
 
   private static final int TS_PACKET_SIZE = 188;
   private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
   private static final int TS_PAT_PID = 0;
-
-  private static final int TS_STREAM_TYPE_MPA = 0x03;
-  private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
-  private static final int TS_STREAM_TYPE_AAC = 0x0F;
-  private static final int TS_STREAM_TYPE_AC3 = 0x81;
-  private static final int TS_STREAM_TYPE_DTS = 0x8A;
-  private static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
-  private static final int TS_STREAM_TYPE_E_AC3 = 0x87;
-  private static final int TS_STREAM_TYPE_H262 = 0x02;
-  private static final int TS_STREAM_TYPE_H264 = 0x1B;
-  private static final int TS_STREAM_TYPE_H265 = 0x24;
-  private static final int TS_STREAM_TYPE_ID3 = 0x15;
-  private static final int BASE_EMBEDDED_TRACK_ID = 0x2000; // 0xFF + 1
+  private static final int MAX_PID_PLUS_ONE = 0x2000;
 
   private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
   private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
@@ -82,37 +80,48 @@
   private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
 
+  private final boolean mapByType;
   private final TimestampAdjuster timestampAdjuster;
-  private final int workaroundFlags;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
   private final SparseIntArray continuityCounters;
-  /* package */ final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-  /* package */ final SparseBooleanArray trackIds;
+  private final ElementaryStreamReader.Factory streamReaderFactory;
+  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+  private final SparseBooleanArray trackIds;
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
-  private int nextEmbeddedTrackId;
-  /* package */ Id3Reader id3Reader;
+  private boolean tracksEnded;
+  private ElementaryStreamReader id3Reader;
 
   public TsExtractor() {
     this(new TimestampAdjuster(0));
   }
 
+  /**
+   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   */
   public TsExtractor(TimestampAdjuster timestampAdjuster) {
-    this(timestampAdjuster, 0);
+    this(timestampAdjuster, new DefaultStreamReaderFactory(), false);
   }
 
-  public TsExtractor(TimestampAdjuster timestampAdjuster, int workaroundFlags) {
+  /**
+   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   * @param customReaderFactory Factory for injecting a custom set of elementary stream readers.
+   * @param mapByType True if {@link TrackOutput}s should be mapped by their type, false to map them
+   *     by their PID.
+   */
+  public TsExtractor(TimestampAdjuster timestampAdjuster,
+      ElementaryStreamReader.Factory customReaderFactory, boolean mapByType) {
     this.timestampAdjuster = timestampAdjuster;
-    this.workaroundFlags = workaroundFlags;
+    this.streamReaderFactory = Assertions.checkNotNull(customReaderFactory);
+    this.mapByType = mapByType;
     tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
-    tsPayloadReaders = new SparseArray<>();
-    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
     trackIds = new SparseBooleanArray();
-    nextEmbeddedTrackId = BASE_EMBEDDED_TRACK_ID;
+    tsPayloadReaders = new SparseArray<>();
     continuityCounters = new SparseIntArray();
+    resetPayloadReaders();
   }
 
   // Extractor implementation.
@@ -144,11 +153,10 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek(long position) {
     timestampAdjuster.reset();
-    for (int i = 0; i < tsPayloadReaders.size(); i++) {
-      tsPayloadReaders.valueAt(i).seek();
-    }
     tsPacketBuffer.reset();
     continuityCounters.clear();
+    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
+    resetPayloadReaders();
   }
 
   @Override
@@ -243,6 +251,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
   // Internals.
 
+  private void resetPayloadReaders() {
+    trackIds.clear();
+    tsPayloadReaders.clear();
+    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
+    id3Reader = null;
+  }
+
   /**
    * Parses TS packet payload data.
    */
@@ -336,7 +351,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           patScratch.skipBits(13); // network_PID (13)
         } else {
           int pid = patScratch.readBits(13);
-          tsPayloadReaders.put(pid, new PmtReader());
+          tsPayloadReaders.put(pid, new PmtReader(pid));
         }
       }
     }
@@ -356,14 +371,16 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
 
     private final ParsableBitArray pmtScratch;
     private final ParsableByteArray sectionData;
+    private final int pid;
 
     private int sectionLength;
     private int sectionBytesRead;
     private int crc;
 
-    public PmtReader() {
+    public PmtReader(int pid) {
       pmtScratch = new ParsableBitArray(new byte[5]);
       sectionData = new ParsableByteArray();
+      this.pid = pid;
     }
 
     @Override
@@ -416,10 +433,12 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 && id3Reader == null) {
+      if (mapByType && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
-        // appears intermittently during playback. See b/20261500.
-        id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
+        // appears intermittently during playback. See [Internal: b/20261500].
+        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, new byte[0]);
+        id3Reader = streamReaderFactory.createStreamReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
+        id3Reader.init(output, new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
       }
 
       int remainingEntriesLength = sectionLength - 9 /* Length of fields before descriptors */
@@ -436,79 +455,49 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           streamType = esInfo.streamType;
         }
         remainingEntriesLength -= esInfoLength + 5;
-        int trackId = (workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0 ? streamType : elementaryPid;
+
+        int trackId = mapByType ? streamType : elementaryPid;
         if (trackIds.get(trackId)) {
           continue;
         }
+        trackIds.put(trackId, true);
+
         ElementaryStreamReader pesPayloadReader;
-        switch (streamType) {
-          case TS_STREAM_TYPE_MPA:
-            pesPayloadReader = new MpegAudioReader(output.track(trackId), esInfo.language);
-            break;
-          case TS_STREAM_TYPE_MPA_LSF:
-            pesPayloadReader = new MpegAudioReader(output.track(trackId), esInfo.language);
-            break;
-          case TS_STREAM_TYPE_AAC:
-            pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_AAC_STREAM) != 0 ? null
-                : new AdtsReader(output.track(trackId), new DummyTrackOutput(), esInfo.language);
-            break;
-          case TS_STREAM_TYPE_AC3:
-          case TS_STREAM_TYPE_E_AC3:
-            pesPayloadReader = new Ac3Reader(output.track(trackId), esInfo.language);
-            break;
-          case TS_STREAM_TYPE_DTS:
-          case TS_STREAM_TYPE_HDMV_DTS:
-            pesPayloadReader = new DtsReader(output.track(trackId), esInfo.language);
-            break;
-          case TS_STREAM_TYPE_H262:
-            pesPayloadReader = new H262Reader(output.track(trackId));
-            break;
-          case TS_STREAM_TYPE_H264:
-            pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_H264_STREAM) != 0 ? null
-                : new H264Reader(output.track(trackId),
-                    new SeiReader(output.track(nextEmbeddedTrackId++)),
-                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0,
-                    (workaroundFlags & WORKAROUND_DETECT_ACCESS_UNITS) != 0);
-            break;
-          case TS_STREAM_TYPE_H265:
-            pesPayloadReader = new H265Reader(output.track(trackId),
-                new SeiReader(output.track(nextEmbeddedTrackId++)));
-            break;
-          case TS_STREAM_TYPE_ID3:
-            if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
-              pesPayloadReader = id3Reader;
-            } else {
-              pesPayloadReader = new Id3Reader(output.track(nextEmbeddedTrackId++));
-            }
-            break;
-          default:
-            pesPayloadReader = null;
-            break;
+        if (mapByType && streamType == TS_STREAM_TYPE_ID3) {
+          pesPayloadReader = id3Reader;
+        } else {
+          pesPayloadReader = streamReaderFactory.createStreamReader(streamType, esInfo);
+          pesPayloadReader.init(output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
         }
 
         if (pesPayloadReader != null) {
-          trackIds.put(trackId, true);
-          tsPayloadReaders.put(elementaryPid,
-              new PesReader(pesPayloadReader, timestampAdjuster));
+          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader, timestampAdjuster));
         }
       }
-
-      output.endTracks();
+      if (mapByType) {
+        if (!tracksEnded) {
+          output.endTracks();
+        }
+      } else {
+        tsPayloadReaders.remove(TS_PAT_PID);
+        tsPayloadReaders.remove(pid);
+        output.endTracks();
+      }
+      tracksEnded = true;
     }
 
     /**
-     * Returns the stream info read from the available descriptors, or -1 if no
-     * descriptors are present. Sets {@code data}'s position to the end of the descriptors.
+     * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
+     * the end of the descriptors.
      *
      * @param data A buffer with its position set to the start of the first descriptor.
      * @param length The length of descriptors to read from the current position in {@code data}.
-     * @return The stream info read from the available descriptors, or -1 if no
-     *     descriptors are present.
+     * @return The stream info read from the available descriptors.
      */
     private EsInfo readEsInfo(ParsableByteArray data, int length) {
-      int descriptorsEndPosition = data.getPosition() + length;
+      int descriptorsStartPosition = data.getPosition();
+      int descriptorsEndPosition = descriptorsStartPosition + length;
       int streamType = -1;
-      int audioType = -1;
       String language = null;
       while (data.getPosition() < descriptorsEndPosition) {
         int descriptorTag = data.readUnsignedByte();
@@ -531,27 +520,14 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
           streamType = TS_STREAM_TYPE_DTS;
         } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
           language = new String(data.data, data.getPosition(), 3).trim();
-          audioType = data.data[data.getPosition() + 3];
+          // Audio type is ignored.
         }
         // Skip unused bytes of current descriptor.
         data.skipBytes(positionOfNextDescriptor - data.getPosition());
       }
       data.setPosition(descriptorsEndPosition);
-      return new EsInfo(streamType, audioType, language);
-    }
-
-    private final class EsInfo {
-
-      final int streamType;
-      final int audioType;
-      final String language;
-
-      public EsInfo(int streamType, int audioType, String language) {
-        this.streamType = streamType;
-        this.audioType = audioType;
-        this.language = language;
-      }
-
+      return new EsInfo(streamType, language,
+          Arrays.copyOfRange(sectionData.data, descriptorsStartPosition, descriptorsEndPosition));
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
index b5e2268b53..a57060f604 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
@@ -31,6 +31,7 @@
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
   /** The PCM encoding */
+  @C.PcmEncoding
   private final int encoding;
 
   /** Offset to the start of sample data. */
@@ -39,7 +40,7 @@
   private long dataSize;
 
   public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, int blockAlignment,
-      int bitsPerSample, int encoding) {
+      int bitsPerSample, @C.PcmEncoding int encoding) {
     this.numChannels = numChannels;
     this.sampleRateHz = sampleRateHz;
     this.averageBytesPerSecond = averageBytesPerSecond;
@@ -99,6 +100,7 @@ public void setDataBounds(long dataStartPosition, long dataSize) {
   }
 
   /** Returns the PCM encoding. **/
+  @C.PcmEncoding
   public int getEncoding() {
     return encoding;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
index 36fbcf40af..0e99380a1c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
@@ -87,7 +87,7 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
           + blockAlignment);
     }
 
-    int encoding = Util.getPcmEncoding(bitsPerSample);
+    @C.PcmEncoding int encoding = Util.getPcmEncoding(bitsPerSample);
     if (encoding == C.ENCODING_INVALID) {
       Log.e(TAG, "Unsupported WAV bit depth: " + bitsPerSample);
       return null;
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index dfc37f8472..63a77e2215 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -293,7 +293,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     MediaCrypto mediaCrypto = null;
     boolean drmSessionRequiresSecureDecoder = false;
     if (drmSession != null) {
-      int drmSessionState = drmSession.getState();
+      @DrmSession.State int drmSessionState = drmSession.getState();
       if (drmSessionState == DrmSession.STATE_ERROR) {
         throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
       } else if (drmSessionState == DrmSession.STATE_OPENED
@@ -682,7 +682,7 @@ private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackExc
     if (drmSession == null) {
       return false;
     }
-    int drmSessionState = drmSession.getState();
+    @DrmSession.State int drmSessionState = drmSession.getState();
     if (drmSessionState == DrmSession.STATE_ERROR) {
       throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 90af3936a4..3b743c5fda 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -18,7 +18,6 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -79,12 +78,11 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     int sourceIndex = timeline.getSourceIndexForPeriod(index);
     int periodIndexInSource = index - timeline.getFirstPeriodIndexInSource(sourceIndex);
-    MediaPeriod mediaPeriod = mediaSources[sourceIndex].createPeriod(periodIndexInSource, callback,
-        allocator, positionUs);
+    MediaPeriod mediaPeriod = mediaSources[sourceIndex].createPeriod(periodIndexInSource, allocator,
+        positionUs);
     sourceIndexByMediaPeriod.put(mediaPeriod, sourceIndex);
     return mediaPeriod;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index a9d4c18db6..27bd1f677f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -41,7 +42,6 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
-import java.util.Arrays;
 
 /**
  * A {@link MediaPeriod} that extracts data using an {@link Extractor}.
@@ -61,12 +61,16 @@
   private final Handler eventHandler;
   private final ExtractorMediaSource.EventListener eventListener;
   private final MediaSource.Listener sourceListener;
-  private final Callback callback;
   private final Allocator allocator;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
   private final ConditionVariable loadCondition;
+  private final Runnable maybeFinishPrepareRunnable;
+  private final Runnable onContinueLoadingRequestedRunnable;
+  private final Handler handler;
+  private final SparseArray<DefaultTrackOutput> sampleQueues;
 
+  private Callback callback;
   private SeekMap seekMap;
   private boolean tracksBuilt;
   private boolean prepared;
@@ -74,7 +78,6 @@
   private boolean seenFirstTrackSelection;
   private boolean notifyReset;
   private int enabledTrackCount;
-  private DefaultTrackOutput[] sampleQueues;
   private TrackGroupArray tracks;
   private long durationUs;
   private boolean[] trackEnabledStates;
@@ -85,6 +88,7 @@
 
   private int extractedSamplesCountAtStartOfLoad;
   private boolean loadingFinished;
+  private boolean released;
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -94,30 +98,41 @@
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param sourceListener A listener to notify when the timeline has been loaded.
-   * @param callback A callback to receive updates from the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    */
   public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extractors,
       int minLoadableRetryCount, Handler eventHandler,
       ExtractorMediaSource.EventListener eventListener, MediaSource.Listener sourceListener,
-      Callback callback, Allocator allocator) {
+      Allocator allocator) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.sourceListener = sourceListener;
-    this.callback = callback;
     this.allocator = allocator;
     loader = new Loader("Loader:ExtractorMediaPeriod");
     extractorHolder = new ExtractorHolder(extractors, this);
     loadCondition = new ConditionVariable();
+    maybeFinishPrepareRunnable = new Runnable() {
+      @Override
+      public void run() {
+        maybeFinishPrepare();
+      }
+    };
+    onContinueLoadingRequestedRunnable = new Runnable() {
+      @Override
+      public void run() {
+        if (!released) {
+          callback.onContinueLoadingRequested(ExtractorMediaPeriod.this);
+        }
+      }
+    };
+    handler = new Handler();
 
     pendingResetPositionUs = C.TIME_UNSET;
-    sampleQueues = new DefaultTrackOutput[0];
+    sampleQueues = new SparseArray<>();
     length = C.LENGTH_UNSET;
-    loadCondition.open();
-    startLoading();
   }
 
   public void release() {
@@ -126,11 +141,21 @@ public void release() {
       @Override
       public void run() {
         extractorHolder.release();
+        int trackCount = sampleQueues.size();
+        for (int i = 0; i < trackCount; i++) {
+          sampleQueues.valueAt(i).disable();
+        }
       }
     });
-    for (DefaultTrackOutput sampleQueue : sampleQueues) {
-      sampleQueue.disable();
-    }
+    handler.removeCallbacksAndMessages(null);
+    released = true;
+  }
+
+  @Override
+  public void prepare(Callback callback) {
+    this.callback = callback;
+    loadCondition.open();
+    startLoading();
   }
 
   @Override
@@ -154,7 +179,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
         Assertions.checkState(trackEnabledStates[track]);
         enabledTrackCount--;
         trackEnabledStates[track] = false;
-        sampleQueues[track].disable();
+        sampleQueues.valueAt(track).disable();
         streams[i] = null;
       }
     }
@@ -177,9 +202,10 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     if (!seenFirstTrackSelection) {
       // At the time of the first track selection all queues will be enabled, so we need to disable
       // any that are no longer required.
-      for (int i = 0; i < sampleQueues.length; i++) {
+      int trackCount = sampleQueues.size();
+      for (int i = 0; i < trackCount; i++) {
         if (!trackEnabledStates[i]) {
-          sampleQueues[i].disable();
+          sampleQueues.valueAt(i).disable();
         }
       }
     }
@@ -246,11 +272,12 @@ public long seekToUs(long positionUs) {
     // Treat all seeks into non-seekable media as being to t=0.
     positionUs = seekMap.isSeekable() ? positionUs : 0;
     lastSeekPositionUs = positionUs;
+    int trackCount = sampleQueues.size();
     // If we're not pending a reset, see if we can seek within the sample queues.
     boolean seekInsideBuffer = !isPendingReset();
-    for (int i = 0; seekInsideBuffer && i < sampleQueues.length; i++) {
+    for (int i = 0; seekInsideBuffer && i < trackCount; i++) {
       if (trackEnabledStates[i]) {
-        seekInsideBuffer = sampleQueues[i].skipToKeyframeBefore(positionUs);
+        seekInsideBuffer = sampleQueues.valueAt(i).skipToKeyframeBefore(positionUs);
       }
     }
     // If we failed to seek within the sample queues, we need to restart.
@@ -260,8 +287,8 @@ public long seekToUs(long positionUs) {
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
-        for (int i = 0; i < sampleQueues.length; i++) {
-          sampleQueues[i].reset(trackEnabledStates[i]);
+        for (int i = 0; i < trackCount; i++) {
+          sampleQueues.valueAt(i).reset(trackEnabledStates[i]);
         }
       }
     }
@@ -272,7 +299,7 @@ public long seekToUs(long positionUs) {
   // SampleStream methods.
 
   /* package */ boolean isReady(int track) {
-    return loadingFinished || (!isPendingReset() && !sampleQueues[track].isEmpty());
+    return loadingFinished || (!isPendingReset() && !sampleQueues.valueAt(track).isEmpty());
   }
 
   /* package */ void maybeThrowError() throws IOException {
@@ -284,7 +311,8 @@ public long seekToUs(long positionUs) {
       return C.RESULT_NOTHING_READ;
     }
 
-    return sampleQueues[track].readData(formatHolder, buffer, loadingFinished, lastSeekPositionUs);
+    return sampleQueues.valueAt(track).readData(formatHolder, buffer, loadingFinished,
+        lastSeekPositionUs);
   }
 
   // Loader.Callback implementation.
@@ -308,8 +336,9 @@ public void onLoadCanceled(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs, boolean released) {
     copyLengthFromLoader(loadable);
     if (!released && enabledTrackCount > 0) {
-      for (int i = 0; i < sampleQueues.length; i++) {
-        sampleQueues[i].reset(trackEnabledStates[i]);
+      int trackCount = sampleQueues.size();
+      for (int i = 0; i < trackCount; i++) {
+        sampleQueues.valueAt(i).reset(trackEnabledStates[i]);
       }
       callback.onContinueLoadingRequested(this);
     }
@@ -330,54 +359,56 @@ public int onLoadError(ExtractingLoadable loadable, long elapsedRealtimeMs,
     return madeProgress ? Loader.RETRY_RESET_ERROR_COUNT : Loader.RETRY;
   }
 
-  // ExtractorOutput implementation.
+  // ExtractorOutput implementation. Called by the loading thread.
 
   @Override
   public TrackOutput track(int id) {
-    sampleQueues = Arrays.copyOf(sampleQueues, sampleQueues.length + 1);
-    DefaultTrackOutput sampleQueue = new DefaultTrackOutput(allocator);
-    sampleQueue.setUpstreamFormatChangeListener(this);
-    sampleQueues[sampleQueues.length - 1] = sampleQueue;
-    return sampleQueue;
+    DefaultTrackOutput trackOutput = sampleQueues.get(id);
+    if (trackOutput == null) {
+      trackOutput = new DefaultTrackOutput(allocator);
+      trackOutput.setUpstreamFormatChangeListener(this);
+      sampleQueues.put(id, trackOutput);
+    }
+    return trackOutput;
   }
 
   @Override
   public void endTracks() {
     tracksBuilt = true;
-    maybeFinishPrepare();
+    handler.post(maybeFinishPrepareRunnable);
   }
 
   @Override
   public void seekMap(SeekMap seekMap) {
     this.seekMap = seekMap;
-    maybeFinishPrepare();
+    handler.post(maybeFinishPrepareRunnable);
   }
 
-  // UpstreamFormatChangedListener implementation
+  // UpstreamFormatChangedListener implementation. Called by the loading thread.
 
   @Override
   public void onUpstreamFormatChanged(Format format) {
-    maybeFinishPrepare();
+    handler.post(maybeFinishPrepareRunnable);
   }
 
   // Internal methods.
 
   private void maybeFinishPrepare() {
-    if (prepared || seekMap == null || !tracksBuilt) {
+    if (released || prepared || seekMap == null || !tracksBuilt) {
       return;
     }
-    for (DefaultTrackOutput sampleQueue : sampleQueues) {
-      if (sampleQueue.getUpstreamFormat() == null) {
+    int trackCount = sampleQueues.size();
+    for (int i = 0; i < trackCount; i++) {
+      if (sampleQueues.valueAt(i).getUpstreamFormat() == null) {
         return;
       }
     }
     loadCondition.close();
-    int trackCount = sampleQueues.length;
     TrackGroup[] trackArray = new TrackGroup[trackCount];
     trackEnabledStates = new boolean[trackCount];
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
-      trackArray[i] = new TrackGroup(sampleQueues[i].getUpstreamFormat());
+      trackArray[i] = new TrackGroup(sampleQueues.valueAt(i).getUpstreamFormat());
     }
     tracks = new TrackGroupArray(trackArray);
     prepared = true;
@@ -431,8 +462,9 @@ private void configureRetry(ExtractingLoadable loadable) {
       // a new load.
       lastSeekPositionUs = 0;
       notifyReset = prepared;
-      for (int i = 0; i < sampleQueues.length; i++) {
-        sampleQueues[i].reset(trackEnabledStates[i]);
+      int trackCount = sampleQueues.size();
+      for (int i = 0; i < trackCount; i++) {
+        sampleQueues.valueAt(i).reset(!prepared || trackEnabledStates[i]);
       }
       loadable.setLoadPosition(0);
     }
@@ -440,17 +472,19 @@ private void configureRetry(ExtractingLoadable loadable) {
 
   private int getExtractedSamplesCount() {
     int extractedSamplesCount = 0;
-    for (DefaultTrackOutput sampleQueue : sampleQueues) {
-      extractedSamplesCount += sampleQueue.getWriteIndex();
+    int trackCount = sampleQueues.size();
+    for (int i = 0; i < trackCount; i++) {
+      extractedSamplesCount += sampleQueues.valueAt(i).getWriteIndex();
     }
     return extractedSamplesCount;
   }
 
   private long getLargestQueuedTimestampUs() {
     long largestQueuedTimestampUs = Long.MIN_VALUE;
-    for (DefaultTrackOutput sampleQueue : sampleQueues) {
+    int trackCount = sampleQueues.size();
+    for (int i = 0; i < trackCount; i++) {
       largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
-          sampleQueue.getLargestQueuedTimestampUs());
+          sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
     }
     return largestQueuedTimestampUs;
   }
@@ -499,7 +533,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
 
     @Override
     public void skipToKeyframeBefore(long timeUs) {
-      sampleQueues[track].skipToKeyframeBefore(timeUs);
+      sampleQueues.valueAt(track).skipToKeyframeBefore(timeUs);
     }
 
   }
@@ -576,7 +610,7 @@ public void load() throws IOException, InterruptedException {
             if (input.getPosition() > position + CONTINUE_LOADING_CHECK_INTERVAL_BYTES) {
               position = input.getPosition();
               loadCondition.close();
-              callback.onContinueLoadingRequested(ExtractorMediaPeriod.this);
+              handler.post(onContinueLoadingRequestedRunnable);
             }
           }
         } finally {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 936358352e..bf795241bc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -23,7 +23,6 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
@@ -148,12 +147,11 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
     return new ExtractorMediaPeriod(uri, dataSourceFactory.createDataSource(),
         extractorsFactory.createExtractors(), minLoadableRetryCount, eventHandler, eventListener,
-        this, callback, allocator);
+        this, allocator);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index e41f5cdc1e..21455ed89d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -19,7 +19,6 @@
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -76,9 +75,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
-    return childSource.createPeriod(index % childPeriodCount, callback, allocator, positionUs);
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+    return childSource.createPeriod(index % childPeriodCount, allocator, positionUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index 80424d445e..a3c1c88df4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -32,7 +32,7 @@
     /**
      * Called when preparation completes.
      * <p>
-     * May be called from any thread. After invoking this method, the {@link MediaPeriod} can expect
+     * Called on the playback thread. After invoking this method, the {@link MediaPeriod} can expect
      * for {@link #selectTracks(TrackSelection[], boolean[], SampleStream[], boolean[], long)} to be
      * called with the initial track selection.
      *
@@ -42,6 +42,17 @@
 
   }
 
+  /**
+   * Prepares this media period asynchronously.
+   * <p>
+   * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
+   * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
+   *
+   * @param callback Callback to receive updates from this period, including being notified when
+   *     preparation completes.
+   */
+  void prepare(Callback callback);
+
   /**
    * Throws an error that's preventing the period from becoming prepared. Does nothing if no such
    * error exists.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 4c0686eec1..709a92cbf5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
 import java.io.IOException;
 
@@ -54,18 +53,13 @@
 
   /**
    * Returns a {@link MediaPeriod} corresponding to the period at the specified index.
-   * <p>
-   * {@link Callback#onPrepared(MediaPeriod)} is called when the new period is prepared. If
-   * preparation fails, {@link MediaPeriod#maybeThrowPrepareError()} will throw an
-   * {@link IOException} if called on the returned instance.
    *
    * @param index The index of the period.
-   * @param callback A callback to receive updates from the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param positionUs The player's current playback position.
    * @return A new {@link MediaPeriod}.
    */
-  MediaPeriod createPeriod(int index, Callback callback, Allocator allocator, long positionUs);
+  MediaPeriod createPeriod(int index, Allocator allocator, long positionUs);
 
   /**
    * Releases the period.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index 4df6cdfebf..cfab4b14aa 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -28,20 +29,27 @@
 
   public final MediaPeriod[] periods;
 
-  private final Callback callback;
   private final IdentityHashMap<SampleStream, Integer> streamPeriodIndices;
 
+  private Callback callback;
   private int pendingChildPrepareCount;
   private TrackGroupArray trackGroups;
 
   private MediaPeriod[] enabledPeriods;
   private SequenceableLoader sequenceableLoader;
 
-  public MergingMediaPeriod(Callback callback, MediaPeriod... periods) {
+  public MergingMediaPeriod(MediaPeriod... periods) {
     this.periods = periods;
-    this.callback = callback;
     streamPeriodIndices = new IdentityHashMap<>();
+  }
+
+  @Override
+  public void prepare(Callback callback) {
+    this.callback = callback;
     pendingChildPrepareCount = periods.length;
+    for (MediaPeriod period : periods) {
+      period.prepare(this);
+    }
   }
 
   @Override
@@ -77,7 +85,8 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       }
     }
     streamPeriodIndices.clear();
-    // Select tracks for each child, copying the resulting streams back into the streams array.
+    // Select tracks for each child, copying the resulting streams back into a new streams array.
+    SampleStream[] newStreams = new SampleStream[selections.length];
     SampleStream[] childStreams = new SampleStream[selections.length];
     TrackSelection[] childSelections = new TrackSelection[selections.length];
     ArrayList<MediaPeriod> enabledPeriodsList = new ArrayList<>(periods.length);
@@ -96,17 +105,22 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       boolean periodEnabled = false;
       for (int j = 0; j < selections.length; j++) {
         if (selectionChildIndices[j] == i) {
-          streams[j] = childStreams[j];
-          if (childStreams[j] != null) {
-            periodEnabled = true;
-            streamPeriodIndices.put(childStreams[j], i);
-          }
+          // Assert that the child provided a stream for the selection.
+          Assertions.checkState(childStreams[j] != null);
+          newStreams[j] = childStreams[j];
+          periodEnabled = true;
+          streamPeriodIndices.put(childStreams[j], i);
+        } else if (streamChildIndices[j] == i) {
+          // Assert that the child cleared any previous stream.
+          Assertions.checkState(childStreams[j] == null);
         }
       }
       if (periodEnabled) {
         enabledPeriodsList.add(periods[i]);
       }
     }
+    // Copy the new streams back into the streams array.
+    System.arraycopy(newStreams, 0, streams, 0, newStreams.length);
     // Update the local state.
     enabledPeriods = new MediaPeriod[enabledPeriodsList.size()];
     enabledPeriodsList.toArray(enabledPeriods);
@@ -126,21 +140,22 @@ public long getNextLoadPositionUs() {
 
   @Override
   public long readDiscontinuity() {
-    long positionUs = enabledPeriods[0].readDiscontinuity();
+    long positionUs = periods[0].readDiscontinuity();
+    // Periods other than the first one are not allowed to report discontinuities.
+    for (int i = 1; i < periods.length; i++) {
+      if (periods[i].readDiscontinuity() != C.TIME_UNSET) {
+        throw new IllegalStateException("Child reported discontinuity");
+      }
+    }
+    // It must be possible to seek enabled periods to the new position, if there is one.
     if (positionUs != C.TIME_UNSET) {
-      // It must be possible to seek additional periods to the new position.
-      for (int i = 1; i < enabledPeriods.length; i++) {
-        if (enabledPeriods[i].seekToUs(positionUs) != positionUs) {
+      for (int i = 0; i < enabledPeriods.length; i++) {
+        if (enabledPeriods[i] != periods[0]
+            && enabledPeriods[i].seekToUs(positionUs) != positionUs) {
           throw new IllegalStateException("Children seeked to different positions");
         }
       }
     }
-    // Additional periods are not allowed to report discontinuities.
-    for (int i = 1; i < enabledPeriods.length; i++) {
-      if (enabledPeriods[i].readDiscontinuity() != C.TIME_UNSET) {
-        throw new IllegalStateException("Child reported discontinuity");
-      }
-    }
     return positionUs;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index b213928516..7d5f78c1cd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -15,11 +15,12 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -36,11 +37,16 @@
    */
   public static final class IllegalMergeException extends IOException {
 
+    /**
+     * The reason the merge failed.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({REASON_WINDOWS_ARE_DYNAMIC, REASON_PERIOD_COUNT_MISMATCH})
+    public @interface Reason {}
     /**
      * The merge failed because one of the sources being merged has a dynamic window.
      */
     public static final int REASON_WINDOWS_ARE_DYNAMIC = 0;
-
     /**
      * The merge failed because the sources have different period counts.
      */
@@ -50,13 +56,14 @@
      * The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
      * {@link #REASON_PERIOD_COUNT_MISMATCH}.
      */
+    @Reason
     public final int reason;
 
     /**
      * @param reason The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
      *     {@link #REASON_PERIOD_COUNT_MISMATCH}.
      */
-    public IllegalMergeException(int reason) {
+    public IllegalMergeException(@Reason int reason) {
       this.reason = reason;
     }
 
@@ -109,16 +116,12 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     MediaPeriod[] periods = new MediaPeriod[mediaSources.length];
-    // The periods are only referenced after they have all been prepared.
-    MergingMediaPeriod mergingPeriod = new MergingMediaPeriod(callback, periods);
     for (int i = 0; i < periods.length; i++) {
-      periods[i] = mediaSources[i].createPeriod(index, mergingPeriod, allocator, positionUs);
-      Assertions.checkState(periods[i] != null, "Child source must not return null period");
+      periods[i] = mediaSources[i].createPeriod(index, allocator, positionUs);
     }
-    return mergingPeriod;
+    return new MergingMediaPeriod(periods);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 5ade51376f..9aebcece9e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -29,7 +29,7 @@
 
     /**
      * Called by the loader to indicate that it wishes for its {@link #continueLoading(long)} method
-     * to be called when it can continue to load data.
+     * to be called when it can continue to load data. Called on the playback thread.
      */
     void onContinueLoadingRequested(T source);
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 2e6b22e05c..1ad448bd12 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -41,7 +41,7 @@
   /**
    * The initial size of the allocation used to hold the sample data.
    */
-  private static final int INITIAL_SAMPLE_SIZE = 1;
+  private static final int INITIAL_SAMPLE_SIZE = 1024;
 
   private final Uri uri;
   private final DataSource.Factory dataSourceFactory;
@@ -71,13 +71,17 @@ public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Fo
     tracks = new TrackGroupArray(new TrackGroup(format));
     sampleStreams = new ArrayList<>();
     loader = new Loader("Loader:SingleSampleMediaPeriod");
-    sampleData = new byte[INITIAL_SAMPLE_SIZE];
   }
 
   public void release() {
     loader.release();
   }
 
+  @Override
+  public void prepare(Callback callback) {
+    callback.onPrepared(this);
+  }
+
   @Override
   public void maybeThrowPrepareError() throws IOException {
     loader.maybeThrowError();
@@ -264,7 +268,9 @@ public void load() throws IOException, InterruptedException {
         int result = 0;
         while (result != C.RESULT_END_OF_INPUT) {
           sampleSize += result;
-          if (sampleSize == sampleData.length) {
+          if (sampleData == null) {
+            sampleData = new byte[INITIAL_SAMPLE_SIZE];
+          } else if (sampleSize == sampleData.length) {
             sampleData = Arrays.copyOf(sampleData, sampleData.length * 2);
           }
           result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index c0902f5a84..385bebfb88 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Handler;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
@@ -95,13 +94,10 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
-    MediaPeriod mediaPeriod = new SingleSampleMediaPeriod(uri, dataSourceFactory, format,
-        minLoadableRetryCount, eventHandler, eventListener, eventSourceId);
-    callback.onPrepared(mediaPeriod);
-    return mediaPeriod;
+    return new SingleSampleMediaPeriod(uri, dataSourceFactory, format, minLoadableRetryCount,
+        eventHandler, eventListener, eventSourceId);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index e14daf0d20..b9aa098b9d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -58,6 +59,7 @@
 
   // Accessed only on the loader thread.
   private boolean seenTrack;
+  private int seenTrackId;
 
   /**
    * @param extractor The extractor to wrap.
@@ -115,8 +117,9 @@ public int read(ExtractorInput input) throws IOException, InterruptedException {
 
   @Override
   public TrackOutput track(int id) {
-    Assertions.checkState(!seenTrack);
+    Assertions.checkState(!seenTrack || seenTrackId == id);
     seenTrack = true;
+    seenTrackId = id;
     return this;
   }
 
@@ -150,7 +153,8 @@ public void sampleData(ParsableByteArray data, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey) {
     trackOutput.sampleMetadata(timeUs, flags, size, offset, encryptionKey);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index 945a9b7487..388dc63899 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -111,7 +111,8 @@ public void sampleData(ParsableByteArray data, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey) {
     throw new IllegalStateException("Unexpected sample data in initialization chunk");
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index c5a18b9d2b..4a24c7c176 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -48,10 +48,10 @@
   private final EventDispatcher eventDispatcher;
   private final long elapsedRealtimeOffset;
   private final LoaderErrorThrower manifestLoaderErrorThrower;
-  private final Callback callback;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
 
+  private Callback callback;
   private ChunkSampleStream<DashChunkSource>[] sampleStreams;
   private CompositeSequenceableLoader sequenceableLoader;
   private DashManifest manifest;
@@ -61,7 +61,7 @@
   public DashMediaPeriod(int id, DashManifest manifest, int index,
       DashChunkSource.Factory chunkSourceFactory,  int minLoadableRetryCount,
       EventDispatcher eventDispatcher, long elapsedRealtimeOffset,
-      LoaderErrorThrower manifestLoaderErrorThrower, Callback callback, Allocator allocator) {
+      LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
     this.id = id;
     this.manifest = manifest;
     this.index = index;
@@ -70,13 +70,11 @@ public DashMediaPeriod(int id, DashManifest manifest, int index,
     this.eventDispatcher = eventDispatcher;
     this.elapsedRealtimeOffset = elapsedRealtimeOffset;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
-    this.callback = callback;
     this.allocator = allocator;
     sampleStreams = newSampleStreamArray(0);
     sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
     period = manifest.getPeriod(index);
     trackGroups = buildTrackGroups(period);
-    callback.onPrepared(this);
   }
 
   public void updateManifest(DashManifest manifest, int index) {
@@ -97,6 +95,12 @@ public void release() {
     }
   }
 
+  @Override
+  public void prepare(Callback callback) {
+    this.callback = callback;
+    callback.onPrepared(this);
+  }
+
   @Override
   public void maybeThrowPrepareError() throws IOException {
     manifestLoaderErrorThrower.maybeThrowError();
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index a6e54ef4a1..766f1e0ebf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -26,7 +26,6 @@
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
@@ -171,11 +170,10 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     DashMediaPeriod mediaPeriod = new DashMediaPeriod(firstPeriodId + index, manifest, index,
         chunkSourceFactory, minLoadableRetryCount, eventDispatcher, elapsedRealtimeOffsetMs, loader,
-        callback, allocator);
+        allocator);
     periodsById.put(mediaPeriod.id, mediaPeriod);
     return mediaPeriod;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index e0bf7d00e6..b2f0ae6f98 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -654,9 +654,12 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
     } else if (MimeTypes.isVideo(containerMimeType)) {
       return MimeTypes.getVideoMediaMimeType(codecs);
     } else if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
-      // We currently only support EIA-608 through RawCC
-      if (codecs != null && codecs.contains("eia608")) {
-        return MimeTypes.APPLICATION_EIA608;
+      if (codecs != null) {
+        if (codecs.contains("cea708")) {
+          return MimeTypes.APPLICATION_CEA708;
+        } else if (codecs.contains("eia608") || codecs.contains("cea608")) {
+          return MimeTypes.APPLICATION_CEA608;
+        }
       }
       return null;
     } else if (mimeTypeIsRawText(containerMimeType)) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 79205ccbc6..53d9e70d76 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -21,10 +21,12 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
-import com.google.android.exoplayer2.extractor.ts.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.ts.DefaultStreamReaderFactory;
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -33,6 +35,7 @@
 import com.google.android.exoplayer2.source.chunk.DataChunk;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
 import com.google.android.exoplayer2.trackselection.BaseTrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -100,6 +103,7 @@ public void clear() {
   private static final String AC3_FILE_EXTENSION = ".ac3";
   private static final String EC3_FILE_EXTENSION = ".ec3";
   private static final String MP3_FILE_EXTENSION = ".mp3";
+  private static final String MP4_FILE_EXTENSION = ".mp4";
   private static final String VTT_FILE_EXTENSION = ".vtt";
   private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
@@ -117,6 +121,7 @@ public void clear() {
   private long durationUs;
   private IOException fatalError;
 
+  private HlsInitializationChunk lastLoadedInitializationChunk;
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
@@ -252,8 +257,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
             newVariantIndex);
         if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-          fatalError = new BehindLiveWindowException();
-          return;
+          // We try getting the next chunk without adapting in case that's the reason for falling
+          // behind the live window.
+          newVariantIndex = oldVariantIndex;
+          mediaPlaylist = variantPlaylists[newVariantIndex];
+          chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
+              newVariantIndex);
+          if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+            fatalError = new BehindLiveWindowException();
+            return;
+          }
         }
       }
     } else {
@@ -288,7 +301,6 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     }
 
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
-    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
 
     // Check if encryption is specified.
     if (segment.isEncrypted) {
@@ -306,10 +318,6 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       clearEncryptionData();
     }
 
-    // Configure the data source and spec for the chunk.
-    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
-        null);
-
     // Compute start and end times, and the sequence number of the next chunk.
     long startTimeUs;
     if (live) {
@@ -326,8 +334,15 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
     Format format = variants[newVariantIndex].format;
 
+    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
+
     // Configure the extractor that will read the chunk.
     Extractor extractor;
+    boolean useInitializedExtractor = lastLoadedInitializationChunk != null
+        && lastLoadedInitializationChunk.format == format;
+    boolean needNewExtractor = previous == null
+        || previous.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
+        || format != previous.trackFormat;
     boolean extractorNeedsInit = true;
     boolean isTimestampMaster = false;
     TimestampAdjuster timestampAdjuster = null;
@@ -347,34 +362,61 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       timestampAdjuster = timestampAdjusterProvider.getAdjuster(segment.discontinuitySequenceNumber,
           startTimeUs);
       extractor = new WebvttExtractor(format.language, timestampAdjuster);
-    } else if (previous == null
-        || previous.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
-        || format != previous.trackFormat) {
-      // MPEG-2 TS segments, but we need a new extractor.
+    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
       isTimestampMaster = true;
-      timestampAdjuster = timestampAdjusterProvider.getAdjuster(segment.discontinuitySequenceNumber,
-          startTimeUs);
-      // This flag ensures the change of pid between streams does not affect the sample queues.
-      int workaroundFlags = TsExtractor.WORKAROUND_MAP_BY_TYPE;
-      String codecs = variants[newVariantIndex].format.codecs;
-      if (!TextUtils.isEmpty(codecs)) {
-        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
-        // exist. If we know from the codec attribute that they don't exist, then we can explicitly
-        // ignore them even if they're declared.
-        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-          workaroundFlags |= TsExtractor.WORKAROUND_IGNORE_AAC_STREAM;
+      if (needNewExtractor) {
+        if (useInitializedExtractor) {
+          extractor = lastLoadedInitializationChunk.extractor;
+        } else {
+          timestampAdjuster = timestampAdjusterProvider.getAdjuster(
+              segment.discontinuitySequenceNumber, startTimeUs);
+          extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
         }
-        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-          workaroundFlags |= TsExtractor.WORKAROUND_IGNORE_H264_STREAM;
+      } else {
+        extractor = previous.extractor;
+      }
+    } else if (needNewExtractor) {
+      // MPEG-2 TS segments, but we need a new extractor.
+      isTimestampMaster = true;
+      if (useInitializedExtractor) {
+        extractor = lastLoadedInitializationChunk.extractor;
+      } else {
+        timestampAdjuster = timestampAdjusterProvider.getAdjuster(
+            segment.discontinuitySequenceNumber, startTimeUs);
+        // This flag ensures the change of pid between streams does not affect the sample queues.
+        @DefaultStreamReaderFactory.Flags
+        int esReaderFactoryFlags = 0;
+        String codecs = variants[newVariantIndex].format.codecs;
+        if (!TextUtils.isEmpty(codecs)) {
+          // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+          // exist. If we know from the codec attribute that they don't exist, then we can
+          // explicitly ignore them even if they're declared.
+          if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
+            esReaderFactoryFlags |= DefaultStreamReaderFactory.FLAG_IGNORE_AAC_STREAM;
+          }
+          if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
+            esReaderFactoryFlags |= DefaultStreamReaderFactory.FLAG_IGNORE_H264_STREAM;
+          }
         }
+        extractor = new TsExtractor(timestampAdjuster,
+            new DefaultStreamReaderFactory(esReaderFactoryFlags), true);
       }
-      extractor = new TsExtractor(timestampAdjuster, workaroundFlags);
     } else {
       // MPEG-2 TS segments, and we need to continue using the same extractor.
       extractor = previous.extractor;
       extractorNeedsInit = false;
     }
 
+    if (needNewExtractor && mediaPlaylist.initializationSegment != null
+        && !useInitializedExtractor) {
+      out.chunk = buildInitializationChunk(mediaPlaylist, extractor, format);
+      return;
+    }
+
+    lastLoadedInitializationChunk = null;
+    // Configure the data source and spec for the chunk.
+    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
+        null);
     out.chunk = new HlsMediaChunk(dataSource, dataSpec, format,
         trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
         startTimeUs, endTimeUs, chunkMediaSequence, segment.discontinuitySequenceNumber,
@@ -431,7 +473,9 @@ private int getLiveNextChunkSequenceNumber(int previousChunkIndex, int oldVarian
    * @param chunk The chunk whose load has been completed.
    */
   public void onChunkLoadCompleted(Chunk chunk) {
-    if (chunk instanceof MediaPlaylistChunk) {
+    if (chunk instanceof HlsInitializationChunk) {
+      lastLoadedInitializationChunk = (HlsInitializationChunk) chunk;
+    } else if (chunk instanceof MediaPlaylistChunk) {
       MediaPlaylistChunk mediaPlaylistChunk = (MediaPlaylistChunk) chunk;
       scratchSpace = mediaPlaylistChunk.getDataHolder();
       setMediaPlaylist(mediaPlaylistChunk.variantIndex, mediaPlaylistChunk.getResult());
@@ -459,6 +503,18 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException e)
 
   // Private methods.
 
+  private HlsInitializationChunk buildInitializationChunk(HlsMediaPlaylist mediaPlaylist,
+      Extractor extractor, Format format) {
+    Segment initSegment = mediaPlaylist.initializationSegment;
+    // The initialization segment is required before the actual media chunk.
+    Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
+    DataSpec initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
+        initSegment.byterangeLength, null);
+    return new HlsInitializationChunk(dataSource, initDataSpec,
+        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), extractor,
+        format);
+  }
+
   private long msToRerequestLiveMediaPlaylist(int variantIndex) {
     HlsMediaPlaylist mediaPlaylist = variantPlaylists[variantIndex];
     long timeSinceLastMediaPlaylistLoadMs =
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java
new file mode 100644
index 0000000000..c571b2f9df
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsInitializationChunk.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.source.chunk.Chunk;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.IOException;
+
+/**
+ * An HLS initialization chunk. Provides the extractor with information required for extracting the
+ * samples.
+ */
+/* package */ final class HlsInitializationChunk extends Chunk {
+
+  public final Format format;
+
+  public final Extractor extractor;
+
+  private int bytesLoaded;
+  private volatile boolean loadCanceled;
+
+  public HlsInitializationChunk(DataSource dataSource, DataSpec dataSpec, int trackSelectionReason,
+      Object trackSelectionData, Extractor extractor, Format format) {
+    super(dataSource, dataSpec, C.TRACK_TYPE_DEFAULT, null, trackSelectionReason,
+        trackSelectionData, C.TIME_UNSET, C.TIME_UNSET);
+    this.extractor = extractor;
+    this.format = format;
+  }
+
+  /**
+   * Sets the {@link HlsSampleStreamWrapper} that will receive the sample format information from
+   * the initialization chunk.
+   *
+   * @param output The output that will receive the format information.
+   */
+  public void init(HlsSampleStreamWrapper output) {
+    extractor.init(output);
+  }
+
+  @Override
+  public long bytesLoaded() {
+    return bytesLoaded;
+  }
+
+  @Override
+  public void cancelLoad() {
+    loadCanceled = true;
+  }
+
+  @Override
+  public boolean isLoadCanceled() {
+    return loadCanceled;
+  }
+
+  @Override
+  public void load() throws IOException, InterruptedException {
+    DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+    try {
+      ExtractorInput input = new DefaultExtractorInput(dataSource,
+          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+      try {
+        int result = Extractor.RESULT_CONTINUE;
+        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+          result = extractor.read(input, null);
+        }
+      } finally {
+        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+      }
+    } finally {
+      dataSource.close();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 657b1e3dae..5c316a5653 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -19,7 +19,7 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.ts.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 288412ccbb..f4c8177f21 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -39,6 +39,7 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -50,11 +51,11 @@
 /* package */ final class HlsMediaPeriod implements MediaPeriod,
     Loader.Callback<ParsingLoadable<HlsPlaylist>>, HlsSampleStreamWrapper.Callback  {
 
+  private final Uri manifestUri;
   private final DataSource.Factory dataSourceFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
   private final MediaSource.Listener sourceListener;
-  private final Callback callback;
   private final Allocator allocator;
   private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
@@ -62,7 +63,9 @@
   private final Handler continueLoadingHandler;
   private final Loader manifestFetcher;
   private final long preparePositionUs;
+  private final Runnable continueLoadingRunnable;
 
+  private Callback callback;
   private int pendingPrepareCount;
   private HlsPlaylist playlist;
   private boolean seenFirstTrackSelection;
@@ -72,17 +75,16 @@
   private HlsSampleStreamWrapper[] sampleStreamWrappers;
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
   private CompositeSequenceableLoader sequenceableLoader;
-  private Runnable continueLoadingRunnable;
 
   public HlsMediaPeriod(Uri manifestUri, DataSource.Factory dataSourceFactory,
       int minLoadableRetryCount, EventDispatcher eventDispatcher,
-      MediaSource.Listener sourceListener, final Callback callback, Allocator allocator,
+      MediaSource.Listener sourceListener, Allocator allocator,
       long positionUs) {
+    this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
     this.sourceListener = sourceListener;
-    this.callback = callback;
     this.allocator = allocator;
     streamWrapperIndices = new IdentityHashMap<>();
     timestampAdjusterProvider = new TimestampAdjusterProvider();
@@ -96,21 +98,27 @@ public void run() {
         callback.onContinueLoadingRequested(HlsMediaPeriod.this);
       }
     };
-
-    ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(
-        dataSourceFactory.createDataSource(), manifestUri, C.DATA_TYPE_MANIFEST, manifestParser);
-    long elapsedRealtimeMs = manifestFetcher.startLoading(loadable, this, minLoadableRetryCount);
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, elapsedRealtimeMs);
   }
 
   public void release() {
     continueLoadingHandler.removeCallbacksAndMessages(null);
     manifestFetcher.release();
-    for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-      sampleStreamWrapper.release();
+    if (sampleStreamWrappers != null) {
+      for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
+        sampleStreamWrapper.release();
+      }
     }
   }
 
+  @Override
+  public void prepare(Callback callback) {
+    this.callback = callback;
+    ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(
+        dataSourceFactory.createDataSource(), manifestUri, C.DATA_TYPE_MANIFEST, manifestParser);
+    long elapsedRealtimeMs = manifestFetcher.startLoading(loadable, this, minLoadableRetryCount);
+    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, elapsedRealtimeMs);
+  }
+
   @Override
   public void maybeThrowPrepareError() throws IOException {
     if (sampleStreamWrappers == null) {
@@ -149,7 +157,8 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     }
     boolean selectedNewTracks = false;
     streamWrapperIndices.clear();
-    // Select tracks for each child, copying the resulting streams back into the streams array.
+    // Select tracks for each child, copying the resulting streams back into a new streams array.
+    SampleStream[] newStreams = new SampleStream[selections.length];
     SampleStream[] childStreams = new SampleStream[selections.length];
     TrackSelection[] childSelections = new TrackSelection[selections.length];
     ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList = new ArrayList<>(
@@ -163,19 +172,23 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
           mayRetainStreamFlags, childStreams, streamResetFlags, !seenFirstTrackSelection);
       boolean wrapperEnabled = false;
       for (int j = 0; j < selections.length; j++) {
-        if (selectionChildIndices[j] == i
-            || (selectionChildIndices[j] == C.INDEX_UNSET && streamChildIndices[j] == i)) {
-          streams[j] = childStreams[j];
-          if (childStreams[j] != null) {
-            wrapperEnabled = true;
-            streamWrapperIndices.put(childStreams[j], i);
-          }
+        if (selectionChildIndices[j] == i) {
+          // Assert that the child provided a stream for the selection.
+          Assertions.checkState(childStreams[j] != null);
+          newStreams[j] = childStreams[j];
+          wrapperEnabled = true;
+          streamWrapperIndices.put(childStreams[j], i);
+        } else if (streamChildIndices[j] == i) {
+          // Assert that the child cleared any previous stream.
+          Assertions.checkState(childStreams[j] == null);
         }
       }
       if (wrapperEnabled) {
         enabledSampleStreamWrapperList.add(sampleStreamWrappers[i]);
       }
     }
+    // Copy the new streams back into the streams array.
+    System.arraycopy(newStreams, 0, streams, 0, newStreams.length);
     // Update the local state.
     enabledSampleStreamWrappers = new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
     enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
@@ -239,13 +252,7 @@ public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedR
     eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
         loadDurationMs, loadable.bytesLoaded());
     playlist = loadable.getResult();
-    List<HlsSampleStreamWrapper> sampleStreamWrapperList = buildSampleStreamWrappers();
-    sampleStreamWrappers = new HlsSampleStreamWrapper[sampleStreamWrapperList.size()];
-    sampleStreamWrapperList.toArray(sampleStreamWrappers);
-    pendingPrepareCount = sampleStreamWrappers.length;
-    for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-      sampleStreamWrapper.prepare();
-    }
+    buildAndPrepareSampleStreamWrappers();
   }
 
   @Override
@@ -313,16 +320,16 @@ public void onContinueLoadingRequested(HlsSampleStreamWrapper sampleStreamWrappe
 
   // Internal methods.
 
-  private List<HlsSampleStreamWrapper> buildSampleStreamWrappers() {
-    ArrayList<HlsSampleStreamWrapper> sampleStreamWrappers = new ArrayList<>();
+  private void buildAndPrepareSampleStreamWrappers() {
     String baseUri = playlist.baseUri;
-
     if (playlist instanceof HlsMediaPlaylist) {
       HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[] {
           HlsMasterPlaylist.HlsUrl.createMediaPlaylistHlsUrl(playlist.baseUri)};
-      sampleStreamWrappers.add(buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT, baseUri, variants,
-          null, null));
-      return sampleStreamWrappers;
+      sampleStreamWrappers = new HlsSampleStreamWrapper[] {
+          buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT, baseUri, variants, null, null)};
+      pendingPrepareCount = 1;
+      sampleStreamWrappers[0].continuePreparing();
+      return;
     }
 
     HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
@@ -351,32 +358,37 @@ public void onContinueLoadingRequested(HlsSampleStreamWrapper sampleStreamWrappe
     } else {
       // Leave the enabled variants unchanged. They're likely either all video or all audio.
     }
+    List<HlsMasterPlaylist.HlsUrl> audioVariants = masterPlaylist.audios;
+    List<HlsMasterPlaylist.HlsUrl> subtitleVariants = masterPlaylist.subtitles;
+    sampleStreamWrappers = new HlsSampleStreamWrapper[(selectedVariants.isEmpty() ? 0 : 1)
+        + audioVariants.size() + subtitleVariants.size()];
+    int currentWrapperIndex = 0;
+    pendingPrepareCount = sampleStreamWrappers.length;
     if (!selectedVariants.isEmpty()) {
       HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
       selectedVariants.toArray(variants);
-      sampleStreamWrappers.add(buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT, baseUri, variants,
-          masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat));
+      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
+          baseUri, variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
+      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+      sampleStreamWrapper.continuePreparing();
     }
 
-    // Build the audio stream wrapper if applicable.
-    List<HlsMasterPlaylist.HlsUrl> audioVariants = masterPlaylist.audios;
-    if (!audioVariants.isEmpty()) {
-      HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[audioVariants.size()];
-      audioVariants.toArray(variants);
-      sampleStreamWrappers.add(buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO, baseUri, variants, null,
-          null));
+    // Build audio stream wrappers.
+    for (int i = 0; i < audioVariants.size(); i++) {
+      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
+          baseUri, new HlsMasterPlaylist.HlsUrl[] {audioVariants.get(i)}, null, null);
+      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+      sampleStreamWrapper.continuePreparing();
     }
 
-    // Build the text stream wrapper if applicable.
-    List<HlsMasterPlaylist.HlsUrl> subtitleVariants = masterPlaylist.subtitles;
-    if (!subtitleVariants.isEmpty()) {
-      HlsMasterPlaylist.HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[subtitleVariants.size()];
-      subtitleVariants.toArray(variants);
-      sampleStreamWrappers.add(buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, baseUri, variants, null,
-          null));
+    // Build subtitle stream wrappers.
+    for (int i = 0; i < subtitleVariants.size(); i++) {
+      HlsMasterPlaylist.HlsUrl url = subtitleVariants.get(i);
+      HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT,
+          baseUri, new HlsMasterPlaylist.HlsUrl[] {url}, null, null);
+      sampleStreamWrapper.prepareSingleTrack(url.format);
+      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     }
-
-    return sampleStreamWrappers;
   }
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, String baseUri,
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 72a9fd6c0c..b8b6c033b3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -73,11 +72,10 @@ public void maybeThrowSourceInfoRefreshError() {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
     return new HlsMediaPeriod(manifestUri, dataSourceFactory, minLoadableRetryCount,
-        eventDispatcher, sourceListener, callback, allocator, positionUs);
+        eventDispatcher, sourceListener, allocator, positionUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 83de29c039..fe756da0ef 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
+import android.os.Handler;
+import android.text.TextUtils;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -80,13 +82,15 @@ void onContinueLoadingRequiredInMs(HlsSampleStreamWrapper sampleStreamSource,
   private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
   private final SparseArray<DefaultTrackOutput> sampleQueues;
   private final LinkedList<HlsMediaChunk> mediaChunks;
+  private final Runnable maybeFinishPrepareRunnable;
+  private final Handler handler;
 
-  private volatile boolean sampleQueuesBuilt;
-
+  private boolean sampleQueuesBuilt;
   private boolean prepared;
   private int enabledTrackCount;
   private Format downstreamTrackFormat;
   private int upstreamChunkUid;
+  private boolean released;
 
   // Tracks are complicated in HLS. See documentation of buildTracks for details.
   // Indexed by track (as exposed by this source).
@@ -129,12 +133,31 @@ public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource c
     nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
     sampleQueues = new SparseArray<>();
     mediaChunks = new LinkedList<>();
+    maybeFinishPrepareRunnable = new Runnable() {
+      @Override
+      public void run() {
+        maybeFinishPrepare();
+      }
+    };
+    handler = new Handler();
     lastSeekPositionUs = positionUs;
     pendingResetPositionUs = positionUs;
   }
 
-  public void prepare() {
-    continueLoading(lastSeekPositionUs);
+  public void continuePreparing() {
+    if (!prepared) {
+      continueLoading(lastSeekPositionUs);
+    }
+  }
+
+  /**
+   * Prepares a sample stream wrapper for which the master playlist provides enough information to
+   * prepare.
+   */
+  public void prepareSingleTrack(Format format) {
+    track(0).format(format);
+    sampleQueuesBuilt = true;
+    maybeFinishPrepare();
   }
 
   public void maybeThrowPrepareError() throws IOException {
@@ -245,6 +268,8 @@ public void release() {
       sampleQueues.valueAt(i).disable();
     }
     loader.release();
+    handler.removeCallbacksAndMessages(null);
+    released = true;
   }
 
   public long getLargestQueuedTimestampUs() {
@@ -336,6 +361,8 @@ public boolean continueLoading(long positionUs) {
       HlsMediaChunk mediaChunk = (HlsMediaChunk) loadable;
       mediaChunk.init(this);
       mediaChunks.add(mediaChunk);
+    } else if (loadable instanceof HlsInitializationChunk) {
+      ((HlsInitializationChunk) loadable).init(this);
     }
     long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
     eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
@@ -454,7 +481,7 @@ public DefaultTrackOutput track(int id) {
   @Override
   public void endTracks() {
     sampleQueuesBuilt = true;
-    maybeFinishPrepare();
+    handler.post(maybeFinishPrepareRunnable);
   }
 
   @Override
@@ -462,17 +489,17 @@ public void seekMap(SeekMap seekMap) {
     // Do nothing.
   }
 
-  // UpstreamFormatChangedListener implementation.
+  // UpstreamFormatChangedListener implementation. Called by the loading thread.
 
   @Override
   public void onUpstreamFormatChanged(Format format) {
-    maybeFinishPrepare();
+    handler.post(maybeFinishPrepareRunnable);
   }
 
   // Internal methods.
 
   private void maybeFinishPrepare() {
-    if (prepared || !sampleQueuesBuilt) {
+    if (released || prepared || !sampleQueuesBuilt) {
       return;
     }
     int sampleQueueCount = sampleQueues.size();
@@ -558,7 +585,7 @@ private void buildTracks() {
       if (i == primaryExtractorTrackIndex) {
         Format[] formats = new Format[chunkSourceTrackCount];
         for (int j = 0; j < chunkSourceTrackCount; j++) {
-          formats[j] = getSampleFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat);
+          formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat);
         }
         trackGroups[i] = new TrackGroup(formats);
         primaryTrackGroupIndex = i;
@@ -567,11 +594,11 @@ private void buildTracks() {
         if (primaryExtractorTrackType == PRIMARY_TYPE_VIDEO) {
           if (MimeTypes.isAudio(sampleFormat.sampleMimeType)) {
             trackFormat = muxedAudioFormat;
-          } else if (MimeTypes.APPLICATION_EIA608.equals(sampleFormat.sampleMimeType)) {
+          } else if (MimeTypes.APPLICATION_CEA608.equals(sampleFormat.sampleMimeType)) {
             trackFormat = muxedCaptionFormat;
           }
         }
-        trackGroups[i] = new TrackGroup(getSampleFormat(trackFormat, sampleFormat));
+        trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat));
       }
     }
     this.trackGroups = new TrackGroupArray(trackGroups);
@@ -590,18 +617,25 @@ private void setTrackGroupEnabledState(int group, boolean enabledState) {
   }
 
   /**
-   * Derives a sample format corresponding to a given container format, by combining it with sample
-   * level information obtained from a second sample format.
+   * Derives a track format corresponding to a given container format, by combining it with sample
+   * level information obtained from the samples.
    *
-   * @param containerFormat The container format for which the sample format should be derived.
+   * @param containerFormat The container format for which the track format should be derived.
    * @param sampleFormat A sample format from which to obtain sample level information.
-   * @return The derived sample format.
+   * @return The derived track format.
    */
-  private static Format getSampleFormat(Format containerFormat, Format sampleFormat) {
+  private static Format deriveFormat(Format containerFormat, Format sampleFormat) {
     if (containerFormat == null) {
       return sampleFormat;
     }
-    return sampleFormat.copyWithContainerInfo(containerFormat.id, containerFormat.bitrate,
+    String codecs = null;
+    int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
+    if (sampleTrackType == C.TRACK_TYPE_AUDIO) {
+      codecs = getAudioCodecs(containerFormat.codecs);
+    } else if (sampleTrackType == C.TRACK_TYPE_VIDEO) {
+      codecs = getVideoCodecs(containerFormat.codecs);
+    }
+    return sampleFormat.copyWithContainerInfo(containerFormat.id, codecs, containerFormat.bitrate,
         containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
         containerFormat.language);
   }
@@ -614,4 +648,29 @@ private boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
+  private static String getAudioCodecs(String codecs) {
+    return getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO);
+  }
+
+  private static String getVideoCodecs(String codecs) {
+    return getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO);
+  }
+
+  private static String getCodecsOfType(String codecs, int trackType) {
+    if (TextUtils.isEmpty(codecs)) {
+      return null;
+    }
+    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
+    StringBuilder builder = new StringBuilder();
+    for (String codec : codecArray) {
+      if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
+        if (builder.length() > 0) {
+          builder.append(",");
+        }
+        builder.append(codec);
+      }
+    }
+    return builder.length() > 0 ? builder.toString() : null;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
index 53bfa9338a..624e5fa4f8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.util.SparseArray;
-import com.google.android.exoplayer2.extractor.ts.TimestampAdjuster;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 
 /**
  * Provides {@link TimestampAdjuster} instances for use during HLS playbacks.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
index 68b489c72b..f565fdf9ea 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
@@ -24,8 +24,8 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.extractor.ts.TimestampAdjuster;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index 439f57be9a..5aa0c8a3d8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -38,6 +38,10 @@
     public final long byterangeOffset;
     public final long byterangeLength;
 
+    public Segment(String uri, long byterangeOffset, long byterangeLength) {
+      this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
+    }
+
     public Segment(String uri, double durationSecs, int discontinuitySequenceNumber,
         long startTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
         long byterangeOffset, long byterangeLength) {
@@ -64,17 +68,19 @@ public int compareTo(Long startTimeUs) {
   public final int mediaSequence;
   public final int targetDurationSecs;
   public final int version;
+  public final Segment initializationSegment;
   public final List<Segment> segments;
   public final boolean live;
   public final long durationUs;
 
   public HlsMediaPlaylist(String baseUri, int mediaSequence, int targetDurationSecs, int version,
-      boolean live, List<Segment> segments) {
+      boolean live, Segment initializationSegment, List<Segment> segments) {
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
     this.mediaSequence = mediaSequence;
     this.targetDurationSecs = targetDurationSecs;
     this.version = version;
     this.live = live;
+    this.initializationSegment = initializationSegment;
     this.segments = segments;
 
     if (!segments.isEmpty()) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index 98f4b20723..fb62d9978e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -15,18 +15,29 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
+import android.support.annotation.IntDef;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Represents an HLS playlist.
  */
 public abstract class HlsPlaylist {
 
+  /**
+   * The type of playlist.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_MASTER, TYPE_MEDIA})
+  public @interface Type {}
   public static final int TYPE_MASTER = 0;
   public static final int TYPE_MEDIA = 1;
 
   public final String baseUri;
+  @Type
   public final int type;
 
-  protected HlsPlaylist(String baseUri, int type) {
+  protected HlsPlaylist(String baseUri, @Type int type) {
     this.baseUri = baseUri;
     this.type = type;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 96f69b69db..21cc75765f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -44,6 +44,7 @@
   private static final String TAG_MEDIA = "#EXT-X-MEDIA";
   private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
   private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
+  private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
   private static final String TAG_MEDIA_DURATION = "#EXTINF";
   private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
   private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
@@ -62,7 +63,6 @@
   private static final String BOOLEAN_TRUE = "YES";
   private static final String BOOLEAN_FALSE = "NO";
 
-
   private static final Pattern REGEX_GROUP_ID = Pattern.compile("GROUP-ID=\"(.+?)\"");
   private static final Pattern REGEX_VIDEO = Pattern.compile("VIDEO=\"(.+?)\"");
   private static final Pattern REGEX_AUDIO = Pattern.compile("AUDIO=\"(.+?)\"");
@@ -80,6 +80,8 @@
       + ":([\\d\\.]+)\\b");
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
+  private static final Pattern REGEX_ATTR_BYTERANGE =
+      Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
   private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
       + METHOD_AES128 + ")");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
@@ -138,7 +140,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
     while (iterator.hasNext()) {
       line = iterator.next();
       if (line.startsWith(TAG_MEDIA)) {
-        int selectionFlags = parseSelectionFlags(line);
+        @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
         String uri = parseOptionalStringAttr(line, REGEX_URI);
         String name = parseStringAttr(line, REGEX_NAME);
         String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
@@ -162,7 +164,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           case TYPE_CLOSED_CAPTIONS:
             if ("CC1".equals(parseOptionalStringAttr(line, REGEX_INSTREAM_ID))) {
               muxedCaptionFormat = Format.createTextContainerFormat(name,
-                  MimeTypes.APPLICATION_M3U8, MimeTypes.APPLICATION_EIA608, null, Format.NO_VALUE,
+                  MimeTypes.APPLICATION_M3U8, MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE,
                   selectionFlags, language);
             }
             break;
@@ -200,11 +202,11 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         muxedCaptionFormat);
   }
 
+  @C.SelectionFlags
   private static int parseSelectionFlags(String line) {
-    return (parseBooleanAttribute(line, REGEX_DEFAULT, false) ? Format.SELECTION_FLAG_DEFAULT : 0)
-        | (parseBooleanAttribute(line, REGEX_FORCED, false) ? Format.SELECTION_FLAG_FORCED : 0)
-        | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? Format.SELECTION_FLAG_AUTOSELECT
-        : 0);
+    return (parseBooleanAttribute(line, REGEX_DEFAULT, false) ? C.SELECTION_FLAG_DEFAULT : 0)
+        | (parseBooleanAttribute(line, REGEX_FORCED, false) ? C.SELECTION_FLAG_FORCED : 0)
+        | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? C.SELECTION_FLAG_AUTOSELECT : 0);
   }
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
@@ -213,13 +215,14 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     int targetDurationSecs = 0;
     int version = 1; // Default version == 1.
     boolean live = true;
+    Segment initializationSegment = null;
     List<Segment> segments = new ArrayList<>();
 
     double segmentDurationSecs = 0.0;
     int discontinuitySequenceNumber = 0;
     long segmentStartTimeUs = 0;
-    long segmentByterangeOffset = 0;
-    long segmentByterangeLength = C.LENGTH_UNSET;
+    long segmentByteRangeOffset = 0;
+    long segmentByteRangeLength = C.LENGTH_UNSET;
     int segmentMediaSequence = 0;
 
     boolean isEncrypted = false;
@@ -229,7 +232,20 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-      if (line.startsWith(TAG_TARGET_DURATION)) {
+      if (line.startsWith(TAG_INIT_SEGMENT)) {
+        String uri = parseStringAttr(line, REGEX_URI);
+        String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
+        if (byteRange != null) {
+          String[] splitByteRange = byteRange.split("@");
+          segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
+          if (splitByteRange.length > 1) {
+            segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
+          }
+        }
+        initializationSegment = new Segment(uri, segmentByteRangeOffset, segmentByteRangeLength);
+        segmentByteRangeOffset = 0;
+        segmentByteRangeLength = C.LENGTH_UNSET;
+      } else if (line.startsWith(TAG_TARGET_DURATION)) {
         targetDurationSecs = parseIntAttr(line, REGEX_TARGET_DURATION);
       } else if (line.startsWith(TAG_MEDIA_SEQUENCE)) {
         mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
@@ -251,9 +267,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       } else if (line.startsWith(TAG_BYTERANGE)) {
         String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
         String[] splitByteRange = byteRange.split("@");
-        segmentByterangeLength = Long.parseLong(splitByteRange[0]);
+        segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
         if (splitByteRange.length > 1) {
-          segmentByterangeOffset = Long.parseLong(splitByteRange[1]);
+          segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
         }
       } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
         discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
@@ -269,24 +285,24 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
         }
         segmentMediaSequence++;
-        if (segmentByterangeLength == C.LENGTH_UNSET) {
-          segmentByterangeOffset = 0;
+        if (segmentByteRangeLength == C.LENGTH_UNSET) {
+          segmentByteRangeOffset = 0;
         }
         segments.add(new Segment(line, segmentDurationSecs, discontinuitySequenceNumber,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
-            segmentByterangeOffset, segmentByterangeLength));
+            segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += (long) (segmentDurationSecs * C.MICROS_PER_SECOND);
         segmentDurationSecs = 0.0;
-        if (segmentByterangeLength != C.LENGTH_UNSET) {
-          segmentByterangeOffset += segmentByterangeLength;
+        if (segmentByteRangeLength != C.LENGTH_UNSET) {
+          segmentByteRangeOffset += segmentByteRangeLength;
         }
-        segmentByterangeLength = C.LENGTH_UNSET;
+        segmentByteRangeLength = C.LENGTH_UNSET;
       } else if (line.equals(TAG_ENDLIST)) {
         live = false;
       }
     }
     return new HlsMediaPlaylist(baseUri, mediaSequence, targetDurationSecs, version, live,
-        Collections.unmodifiableList(segments));
+        initializationSegment, Collections.unmodifiableList(segments));
   }
 
   private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index c4118d1de4..f51280e0b9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -101,7 +101,7 @@ public DefaultSsChunkSource(LoaderErrorThrower manifestLoaderErrorThrower, SsMan
           trackEncryptionBoxes, nalUnitLengthFieldLength, null, null);
       FragmentedMp4Extractor extractor = new FragmentedMp4Extractor(
           FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
-          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, track);
+          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, track, null);
       extractorWrappers[i] = new ChunkExtractorWrapper(extractor, format, false, false);
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 9512d60f7d..fef2480fd6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -46,23 +46,22 @@
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
-  private final Callback callback;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
   private final TrackEncryptionBox[] trackEncryptionBoxes;
 
+  private Callback callback;
   private SsManifest manifest;
   private ChunkSampleStream<SsChunkSource>[] sampleStreams;
   private CompositeSequenceableLoader sequenceableLoader;
 
   public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
       int minLoadableRetryCount, EventDispatcher eventDispatcher,
-      LoaderErrorThrower manifestLoaderErrorThrower, Callback callback, Allocator allocator) {
+      LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
     this.chunkSourceFactory = chunkSourceFactory;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
-    this.callback = callback;
     this.allocator = allocator;
 
     trackGroups = buildTrackGroups(manifest);
@@ -77,7 +76,6 @@ public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFacto
     this.manifest = manifest;
     sampleStreams = newSampleStreamArray(0);
     sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
-    callback.onPrepared(this);
   }
 
   public void updateManifest(SsManifest manifest) {
@@ -94,6 +92,12 @@ public void release() {
     }
   }
 
+  @Override
+  public void prepare(Callback callback) {
+    this.callback = callback;
+    callback.onPrepared(this);
+  }
+
   @Override
   public void maybeThrowPrepareError() throws IOException {
     manifestLoaderErrorThrower.maybeThrowError();
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index ef8129e228..d328e5ecf2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -24,7 +24,6 @@
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
@@ -122,11 +121,10 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(int index, Callback callback, Allocator allocator,
-      long positionUs) {
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
     Assertions.checkArgument(index == 0);
     SsMediaPeriod period = new SsMediaPeriod(manifest, chunkSourceFactory, minLoadableRetryCount,
-        eventDispatcher, manifestLoader, callback, allocator);
+        eventDispatcher, manifestLoader, allocator);
     mediaPeriods.add(period);
     return period;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java b/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
index b7b6c701bf..b7a75ed679 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
@@ -18,35 +18,41 @@
 import android.annotation.TargetApi;
 import android.graphics.Color;
 import android.graphics.Typeface;
+import android.support.annotation.IntDef;
 import android.view.accessibility.CaptioningManager;
 import android.view.accessibility.CaptioningManager.CaptionStyle;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * A compatibility wrapper for {@link CaptionStyle}.
  */
 public final class CaptionStyleCompat {
 
+  /**
+   * The type of edge, which may be none.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({EDGE_TYPE_NONE, EDGE_TYPE_OUTLINE, EDGE_TYPE_DROP_SHADOW, EDGE_TYPE_RAISED,
+      EDGE_TYPE_DEPRESSED})
+  public @interface EdgeType {}
   /**
    * Edge type value specifying no character edges.
    */
   public static final int EDGE_TYPE_NONE = 0;
-
   /**
    * Edge type value specifying uniformly outlined character edges.
    */
   public static final int EDGE_TYPE_OUTLINE = 1;
-
   /**
    * Edge type value specifying drop-shadowed character edges.
    */
   public static final int EDGE_TYPE_DROP_SHADOW = 2;
-
   /**
    * Edge type value specifying raised bevel character edges.
    */
   public static final int EDGE_TYPE_RAISED = 3;
-
   /**
    * Edge type value specifying depressed bevel character edges.
    */
@@ -88,6 +94,7 @@
    * <li>{@link #EDGE_TYPE_DEPRESSED}
    * </ul>
    */
+  @EdgeType
   public final int edgeType;
 
   /**
@@ -126,8 +133,8 @@ public static CaptionStyleCompat createFromCaptionStyle(
    * @param edgeColor See {@link #edgeColor}.
    * @param typeface See {@link #typeface}.
    */
-  public CaptionStyleCompat(int foregroundColor, int backgroundColor, int windowColor, int edgeType,
-      int edgeColor, Typeface typeface) {
+  public CaptionStyleCompat(int foregroundColor, int backgroundColor, int windowColor,
+      @EdgeType int edgeType, int edgeColor, Typeface typeface) {
     this.foregroundColor = foregroundColor;
     this.backgroundColor = backgroundColor;
     this.windowColor = windowColor;
@@ -137,6 +144,7 @@ public CaptionStyleCompat(int foregroundColor, int backgroundColor, int windowCo
   }
 
   @TargetApi(19)
+  @SuppressWarnings("ResourceType")
   private static CaptionStyleCompat createFromCaptionStyleV19(
       CaptioningManager.CaptionStyle captionStyle) {
     return new CaptionStyleCompat(
@@ -145,6 +153,7 @@ private static CaptionStyleCompat createFromCaptionStyleV19(
   }
 
   @TargetApi(21)
+  @SuppressWarnings("ResourceType")
   private static CaptionStyleCompat createFromCaptionStyleV21(
       CaptioningManager.CaptionStyle captionStyle) {
     return new CaptionStyleCompat(
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 01d5b53c86..93b1dc1d9a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Contains information about a specific cue, including textual content and formatting data.
@@ -26,6 +29,13 @@
    * An unset position or width.
    */
   public static final float DIMEN_UNSET = Float.MIN_VALUE;
+
+  /**
+   * The type of anchor, which may be unset.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
+  public @interface AnchorType {}
   /**
    * An unset anchor or line type value.
    */
@@ -44,6 +54,13 @@
    * box.
    */
   public static final int ANCHOR_TYPE_END = 2;
+
+  /**
+   * The type of line, which may be unset.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
+  public @interface LineType {}
   /**
    * Value for {@link #lineType} when {@link #line} is a fractional position.
    */
@@ -83,6 +100,7 @@
    * -1). For horizontal text the size of the first line of the cue is its height, and the start
    * and end of the viewport are the top and bottom respectively.
    */
+  @LineType
   public final int lineType;
   /**
    * The cue box anchor positioned by {@link #line}. One of {@link #ANCHOR_TYPE_START},
@@ -92,6 +110,7 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the top, middle and bottom of the cue box
    * respectively.
    */
+  @AnchorType
   public final int lineAnchor;
   /**
    * The fractional position of the {@link #positionAnchor} of the cue box within the viewport in
@@ -110,6 +129,7 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the left, middle and right of the cue box
    * respectively.
    */
+  @AnchorType
   public final int positionAnchor;
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
@@ -137,8 +157,8 @@ public Cue(CharSequence text) {
    * @param positionAnchor See {@link #positionAnchor}.
    * @param size See {@link #size}.
    */
-  public Cue(CharSequence text, Alignment textAlignment, float line, int lineType, int lineAnchor,
-      float position, int positionAnchor, float size) {
+  public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index 918d0b37b7..2cbc1ab622 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.text;
 
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.text.eia608.Eia608Decoder;
+import com.google.android.exoplayer2.text.cea.Cea608Decoder;
 import com.google.android.exoplayer2.text.subrip.SubripDecoder;
 import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
 import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
@@ -57,7 +57,7 @@
    * <li>TTML ({@link TtmlDecoder})</li>
    * <li>SubRip ({@link SubripDecoder})</li>
    * <li>TX3G ({@link Tx3gDecoder})</li>
-   * <li>Eia608 ({@link Eia608Decoder})</li>
+   * <li>Cea608 ({@link Cea608Decoder})</li>
    * </ul>
    */
   SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
@@ -93,8 +93,8 @@ public SubtitleDecoder createDecoder(Format format) {
             return Class.forName("com.google.android.exoplayer2.text.subrip.SubripDecoder");
           case MimeTypes.APPLICATION_TX3G:
             return Class.forName("com.google.android.exoplayer2.text.tx3g.Tx3gDecoder");
-          case MimeTypes.APPLICATION_EIA608:
-            return Class.forName("com.google.android.exoplayer2.text.eia608.Eia608Decoder");
+          case MimeTypes.APPLICATION_CEA608:
+            return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
           default:
             return null;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index d69a2339a1..e28363f9e4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -160,21 +160,27 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       }
     }
 
-    if (nextSubtitle != null && nextSubtitle.timeUs <= positionUs) {
-      // Advance to the next subtitle. Sync the next event index and trigger an update.
-      if (subtitle != null) {
-        subtitle.release();
-      }
-      subtitle = nextSubtitle;
-      nextSubtitle = null;
-      if (subtitle.isEndOfStream()) {
-        outputStreamEnded = true;
-        subtitle.release();
-        subtitle = null;
-        return;
+    if (nextSubtitle != null) {
+      if (nextSubtitle.isEndOfStream()) {
+        if (!textRendererNeedsUpdate && getNextEventTime() == Long.MAX_VALUE) {
+          if (subtitle != null) {
+            subtitle.release();
+            subtitle = null;
+          }
+          nextSubtitle.release();
+          nextSubtitle = null;
+          outputStreamEnded = true;
+        }
+      } else if (nextSubtitle.timeUs <= positionUs) {
+        // Advance to the next subtitle. Sync the next event index and trigger an update.
+        if (subtitle != null) {
+          subtitle.release();
+        }
+        subtitle = nextSubtitle;
+        nextSubtitle = null;
+        nextSubtitleEventIndex = subtitle.getNextEventTimeIndex(positionUs);
+        textRendererNeedsUpdate = true;
       }
-      nextSubtitleEventIndex = subtitle.getNextEventTimeIndex(positionUs);
-      textRendererNeedsUpdate = true;
     }
 
     if (textRendererNeedsUpdate) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
similarity index 73%
rename from library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Decoder.java
rename to library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index b5249cde78..2715b0cbe0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -13,26 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.text.eia608;
+package com.google.android.exoplayer2.text.cea;
 
 import android.text.TextUtils;
-import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
-import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.SubtitleInputBuffer;
-import com.google.android.exoplayer2.text.SubtitleOutputBuffer;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import java.util.LinkedList;
-import java.util.TreeSet;
 
 /**
- * A {@link SubtitleDecoder} for EIA-608 (also known as "line 21 captions" and "CEA-608").
+ * A {@link SubtitleDecoder} for CEA-608 (also known as "line 21 captions" and "EIA-608").
  */
-public final class Eia608Decoder implements SubtitleDecoder {
+public final class Cea608Decoder extends CeaDecoder {
 
-  private static final int NUM_INPUT_BUFFERS = 10;
-  private static final int NUM_OUTPUT_BUFFERS = 2;
+  private static final int NTSC_CC_FIELD_1 = 0x00;
+  private static final int CC_VALID_FLAG = 0x04;
 
   private static final int PAYLOAD_TYPE_CC = 4;
   private static final int COUNTRY_CODE = 0xB5;
@@ -159,18 +155,10 @@
     0xC5, 0xE5, 0xD8, 0xF8, 0x250C, 0x2510, 0x2514, 0x2518
   };
 
-  private final LinkedList<SubtitleInputBuffer> availableInputBuffers;
-  private final LinkedList<SubtitleOutputBuffer> availableOutputBuffers;
-  private final TreeSet<SubtitleInputBuffer> queuedInputBuffers;
-
   private final ParsableByteArray ccData;
 
   private final StringBuilder captionStringBuilder;
 
-  private long playbackPositionUs;
-
-  private SubtitleInputBuffer dequeuedInputBuffer;
-
   private int captionMode;
   private int captionRowCount;
   private String captionString;
@@ -181,17 +169,7 @@
   private byte repeatableControlCc1;
   private byte repeatableControlCc2;
 
-  public Eia608Decoder() {
-    availableInputBuffers = new LinkedList<>();
-    for (int i = 0; i < NUM_INPUT_BUFFERS; i++) {
-      availableInputBuffers.add(new SubtitleInputBuffer());
-    }
-    availableOutputBuffers = new LinkedList<>();
-    for (int i = 0; i < NUM_OUTPUT_BUFFERS; i++) {
-      availableOutputBuffers.add(new Eia608SubtitleOutputBuffer(this));
-    }
-    queuedInputBuffers = new TreeSet<>();
-
+  public Cea608Decoder() {
     ccData = new ParsableByteArray();
 
     captionStringBuilder = new StringBuilder();
@@ -202,101 +180,20 @@ public Eia608Decoder() {
 
   @Override
   public String getName() {
-    return "Eia608Decoder";
-  }
-
-  @Override
-  public void setPositionUs(long positionUs) {
-    playbackPositionUs = positionUs;
-  }
-
-  @Override
-  public SubtitleInputBuffer dequeueInputBuffer() throws SubtitleDecoderException {
-    Assertions.checkState(dequeuedInputBuffer == null);
-    if (availableInputBuffers.isEmpty()) {
-      return null;
-    }
-    dequeuedInputBuffer = availableInputBuffers.pollFirst();
-    return dequeuedInputBuffer;
-  }
-
-  @Override
-  public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
-    Assertions.checkArgument(inputBuffer != null);
-    Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
-    queuedInputBuffers.add(inputBuffer);
-    dequeuedInputBuffer = null;
-  }
-
-  @Override
-  public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
-    if (availableOutputBuffers.isEmpty()) {
-      return null;
-    }
-
-    // iterate through all available input buffers whose timestamps are less than or equal
-    // to the current playback position; processing input buffers for future content should
-    // be deferred until they would be applicable
-    while (!queuedInputBuffers.isEmpty()
-        && queuedInputBuffers.first().timeUs <= playbackPositionUs) {
-      SubtitleInputBuffer inputBuffer = queuedInputBuffers.pollFirst();
-
-      // If the input buffer indicates we've reached the end of the stream, we can
-      // return immediately with an output buffer propagating that
-      if (inputBuffer.isEndOfStream()) {
-        SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
-        outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
-        releaseInputBuffer(inputBuffer);
-        return outputBuffer;
-      }
-
-      decode(inputBuffer);
-
-      // check if we have any caption updates to report
-      if (!TextUtils.equals(captionString, lastCaptionString)) {
-        lastCaptionString = captionString;
-        if (!inputBuffer.isDecodeOnly()) {
-          SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
-          outputBuffer.setContent(inputBuffer.timeUs, new Eia608Subtitle(captionString), 0);
-          releaseInputBuffer(inputBuffer);
-          return outputBuffer;
-        }
-      }
-
-      releaseInputBuffer(inputBuffer);
-    }
-
-    return null;
-  }
-
-  private void releaseInputBuffer(SubtitleInputBuffer inputBuffer) {
-    inputBuffer.clear();
-    availableInputBuffers.add(inputBuffer);
-  }
-
-  protected void releaseOutputBuffer(SubtitleOutputBuffer outputBuffer) {
-    outputBuffer.clear();
-    availableOutputBuffers.add(outputBuffer);
+    return "Cea608Decoder";
   }
 
   @Override
   public void flush() {
+    super.flush();
     setCaptionMode(CC_MODE_UNKNOWN);
     captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
-    playbackPositionUs = 0;
     captionStringBuilder.setLength(0);
     captionString = null;
     lastCaptionString = null;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
-    while (!queuedInputBuffers.isEmpty()) {
-      releaseInputBuffer(queuedInputBuffers.pollFirst());
-    }
-    if (dequeuedInputBuffer != null) {
-      releaseInputBuffer(dequeuedInputBuffer);
-      dequeuedInputBuffer = null;
-    }
   }
 
   @Override
@@ -304,14 +201,33 @@ public void release() {
     // Do nothing
   }
 
-  private void decode(SubtitleInputBuffer inputBuffer) {
+  @Override
+  protected boolean isNewSubtitleDataAvailable() {
+    return !TextUtils.equals(captionString, lastCaptionString);
+  }
+
+  @Override
+  protected Subtitle createSubtitle() {
+    lastCaptionString = captionString;
+    return new CeaSubtitle(new Cue(captionString));
+  }
+
+  @Override
+  protected void decode(SubtitleInputBuffer inputBuffer) {
     ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
     boolean captionDataProcessed = false;
     boolean isRepeatableControl = false;
     while (ccData.bytesLeft() > 0) {
+      byte ccTypeAndValid = (byte) (ccData.readUnsignedByte() & 0x07);
       byte ccData1 = (byte) (ccData.readUnsignedByte() & 0x7F);
       byte ccData2 = (byte) (ccData.readUnsignedByte() & 0x7F);
 
+      // Only examine valid NTSC_CC_FIELD_1 packets
+      if (ccTypeAndValid != (CC_VALID_FLAG | NTSC_CC_FIELD_1)) {
+        // TODO: Add support for NTSC_CC_FIELD_2 packets
+        continue;
+      }
+
       // Ignore empty captions.
       if (ccData1 == 0 && ccData2 == 0) {
         continue;
@@ -320,26 +236,33 @@ private void decode(SubtitleInputBuffer inputBuffer) {
       captionDataProcessed = true;
 
       // Special North American character set.
+      // ccData1 - P|0|0|1|C|0|0|1
       // ccData2 - P|0|1|1|X|X|X|X
       if ((ccData1 == 0x11 || ccData1 == 0x19) && ((ccData2 & 0x70) == 0x30)) {
+        // TODO: Make use of the channel bit
         captionStringBuilder.append(getSpecialChar(ccData2));
         continue;
       }
 
-      // Extended Spanish/Miscellaneous and French character set.
+      // Extended Western European character set.
+      // ccData1 - P|0|0|1|C|0|1|S
       // ccData2 - P|0|1|X|X|X|X|X
-      if ((ccData1 == 0x12 || ccData1 == 0x1A) && ((ccData2 & 0x60) == 0x20)) {
-        backspace(); // Remove standard equivalent of the special extended char.
-        captionStringBuilder.append(getExtendedEsFrChar(ccData2));
-        continue;
-      }
+      if ((ccData2 & 0x60) == 0x20) {
+        // Extended Spanish/Miscellaneous and French character set (S = 0).
+        if (ccData1 == 0x12 || ccData1 == 0x1A) {
+          // TODO: Make use of the channel bit
+          backspace(); // Remove standard equivalent of the special extended char.
+          captionStringBuilder.append(getExtendedEsFrChar(ccData2));
+          continue;
+        }
 
-      // Extended Portuguese and German/Danish character set.
-      // ccData2 - P|0|1|X|X|X|X|X
-      if ((ccData1 == 0x13 || ccData1 == 0x1B) && ((ccData2 & 0x60) == 0x20)) {
-        backspace(); // Remove standard equivalent of the special extended char.
-        captionStringBuilder.append(getExtendedPtDeChar(ccData2));
-        continue;
+        // Extended Portuguese and German/Danish character set (S = 1).
+        if (ccData1 == 0x13 || ccData1 == 0x1B) {
+          // TODO: Make use of the channel bit
+          backspace(); // Remove standard equivalent of the special extended char.
+          captionStringBuilder.append(getExtendedPtDeChar(ccData2));
+          continue;
+        }
       }
 
       // Control character.
@@ -367,15 +290,17 @@ private void decode(SubtitleInputBuffer inputBuffer) {
 
   private boolean handleCtrl(byte cc1, byte cc2) {
     boolean isRepeatableControl = isRepeatable(cc1);
-    if (isRepeatableControl && repeatableControlSet
-        && repeatableControlCc1 == cc1
-        && repeatableControlCc2 == cc2) {
-      repeatableControlSet = false;
-      return true;
-    } else if (isRepeatableControl) {
-      repeatableControlSet = true;
-      repeatableControlCc1 = cc1;
-      repeatableControlCc2 = cc2;
+    if (isRepeatableControl) {
+      if (repeatableControlSet
+          && repeatableControlCc1 == cc1
+          && repeatableControlCc2 == cc2) {
+        repeatableControlSet = false;
+        return true;
+      } else {
+        repeatableControlSet = true;
+        repeatableControlCc1 = cc1;
+        repeatableControlCc2 = cc2;
+      }
     }
     if (isMiscCode(cc1, cc2)) {
       handleMiscCode(cc2);
@@ -526,16 +451,16 @@ private static boolean isRepeatable(byte cc1) {
   }
 
   /**
-   * Inspects an sei message to determine whether it contains EIA-608.
+   * Inspects an sei message to determine whether it contains CEA-608.
    * <p>
    * The position of {@code payload} is left unchanged.
    *
    * @param payloadType The payload type of the message.
    * @param payloadLength The length of the payload.
    * @param payload A {@link ParsableByteArray} containing the payload.
-   * @return Whether the sei message contains EIA-608.
+   * @return Whether the sei message contains CEA-608.
    */
-  public static boolean isSeiMessageEia608(int payloadType, int payloadLength,
+  public static boolean isSeiMessageCea608(int payloadType, int payloadLength,
       ParsableByteArray payload) {
     if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
       return false;
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
new file mode 100644
index 0000000000..ae92d7fab8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.text.SubtitleDecoder;
+import com.google.android.exoplayer2.text.SubtitleDecoderException;
+import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.text.SubtitleOutputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.LinkedList;
+import java.util.TreeSet;
+
+/**
+ * Base class for subtitle parsers for CEA captions.
+ */
+/* package */ abstract class CeaDecoder implements SubtitleDecoder {
+
+  private static final int NUM_INPUT_BUFFERS = 10;
+  private static final int NUM_OUTPUT_BUFFERS = 2;
+
+  private final LinkedList<SubtitleInputBuffer> availableInputBuffers;
+  private final LinkedList<SubtitleOutputBuffer> availableOutputBuffers;
+  private final TreeSet<SubtitleInputBuffer> queuedInputBuffers;
+
+  private SubtitleInputBuffer dequeuedInputBuffer;
+  private long playbackPositionUs;
+
+  public CeaDecoder() {
+    availableInputBuffers = new LinkedList<>();
+    for (int i = 0; i < NUM_INPUT_BUFFERS; i++) {
+      availableInputBuffers.add(new SubtitleInputBuffer());
+    }
+    availableOutputBuffers = new LinkedList<>();
+    for (int i = 0; i < NUM_OUTPUT_BUFFERS; i++) {
+      availableOutputBuffers.add(new CeaOutputBuffer(this));
+    }
+    queuedInputBuffers = new TreeSet<>();
+  }
+
+  @Override
+  public abstract String getName();
+
+  @Override
+  public void setPositionUs(long positionUs) {
+    playbackPositionUs = positionUs;
+  }
+
+  @Override
+  public SubtitleInputBuffer dequeueInputBuffer() throws SubtitleDecoderException {
+    Assertions.checkState(dequeuedInputBuffer == null);
+    if (availableInputBuffers.isEmpty()) {
+      return null;
+    }
+    dequeuedInputBuffer = availableInputBuffers.pollFirst();
+    return dequeuedInputBuffer;
+  }
+
+  @Override
+  public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
+    Assertions.checkArgument(inputBuffer != null);
+    Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
+    queuedInputBuffers.add(inputBuffer);
+    dequeuedInputBuffer = null;
+  }
+
+  @Override
+  public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
+    if (availableOutputBuffers.isEmpty()) {
+      return null;
+    }
+
+    // iterate through all available input buffers whose timestamps are less than or equal
+    // to the current playback position; processing input buffers for future content should
+    // be deferred until they would be applicable
+    while (!queuedInputBuffers.isEmpty()
+        && queuedInputBuffers.first().timeUs <= playbackPositionUs) {
+      SubtitleInputBuffer inputBuffer = queuedInputBuffers.pollFirst();
+
+      // If the input buffer indicates we've reached the end of the stream, we can
+      // return immediately with an output buffer propagating that
+      if (inputBuffer.isEndOfStream()) {
+        SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
+        outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        releaseInputBuffer(inputBuffer);
+        return outputBuffer;
+      }
+
+      decode(inputBuffer);
+
+      // check if we have any caption updates to report
+      if (isNewSubtitleDataAvailable()) {
+        // Even if the subtitle is decode-only; we need to generate it to consume the data so it
+        // isn't accidentally prepended to the next subtitle
+        Subtitle subtitle = createSubtitle();
+        if (!inputBuffer.isDecodeOnly()) {
+          SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
+          outputBuffer.setContent(inputBuffer.timeUs, subtitle, 0);
+          releaseInputBuffer(inputBuffer);
+          return outputBuffer;
+        }
+      }
+
+      releaseInputBuffer(inputBuffer);
+    }
+
+    return null;
+  }
+
+  private void releaseInputBuffer(SubtitleInputBuffer inputBuffer) {
+    inputBuffer.clear();
+    availableInputBuffers.add(inputBuffer);
+  }
+
+  protected void releaseOutputBuffer(SubtitleOutputBuffer outputBuffer) {
+    outputBuffer.clear();
+    availableOutputBuffers.add(outputBuffer);
+  }
+
+  @Override
+  public void flush() {
+    playbackPositionUs = 0;
+    while (!queuedInputBuffers.isEmpty()) {
+      releaseInputBuffer(queuedInputBuffers.pollFirst());
+    }
+    if (dequeuedInputBuffer != null) {
+      releaseInputBuffer(dequeuedInputBuffer);
+      dequeuedInputBuffer = null;
+    }
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  /**
+   * Returns whether there is data available to create a new {@link Subtitle}.
+   */
+  protected abstract boolean isNewSubtitleDataAvailable();
+
+  /**
+   * Creates a {@link Subtitle} from the available data.
+   */
+  protected abstract Subtitle createSubtitle();
+
+  /**
+   * Filters and processes the raw data, providing {@link Subtitle}s via {@link #createSubtitle()}
+   * when sufficient data has been processed.
+   */
+  protected abstract void decode(SubtitleInputBuffer inputBuffer);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608SubtitleOutputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java
similarity index 72%
rename from library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608SubtitleOutputBuffer.java
rename to library/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java
index 7e5ba062ab..4cc32bb9e4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608SubtitleOutputBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java
@@ -13,22 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.text.eia608;
+package com.google.android.exoplayer2.text.cea;
 
-import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleOutputBuffer;
 
 /**
- * A {@link Subtitle} output from an {@link Eia608Decoder}.
+ * A {@link SubtitleOutputBuffer} for {@link CeaDecoder}s.
  */
-/* package */ final class Eia608SubtitleOutputBuffer extends SubtitleOutputBuffer {
+public final class CeaOutputBuffer extends SubtitleOutputBuffer {
 
-  private Eia608Decoder owner;
+  private final CeaDecoder owner;
 
   /**
    * @param owner The decoder that owns this buffer.
    */
-  public Eia608SubtitleOutputBuffer(Eia608Decoder owner) {
+  public CeaOutputBuffer(CeaDecoder owner) {
     super();
     this.owner = owner;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Subtitle.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
similarity index 71%
rename from library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Subtitle.java
rename to library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
index 6b27004174..5becefe106 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/eia608/Eia608Subtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
@@ -13,26 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.text.eia608;
+package com.google.android.exoplayer2.text.cea;
 
-import android.text.TextUtils;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * A representation of an EIA-608 subtitle.
+ * A representation of a CEA subtitle.
  */
-/* package */ final class Eia608Subtitle implements Subtitle {
+/* package */ final class CeaSubtitle implements Subtitle {
 
-  private final String text;
+  private final List<Cue> cues;
 
   /**
-   * @param text The subtitle text.
+   * @param cue The subtitle cue.
    */
-  public Eia608Subtitle(String text) {
-    this.text = text;
+  public CeaSubtitle(Cue cue) {
+    if (cue == null) {
+      cues = Collections.emptyList();
+    } else {
+      cues = Collections.singletonList(cue);
+    }
   }
 
   @Override
@@ -52,11 +55,8 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    if (TextUtils.isEmpty(text)) {
-      return Collections.emptyList();
-    } else {
-      return Collections.singletonList(new Cue(text));
-    }
+    return cues;
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
index 75fe1154a9..5f30834b4d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java
@@ -24,6 +24,7 @@
 
   public final float position;
   public final float line;
+  @Cue.LineType
   public final int lineType;
   public final float width;
 
@@ -31,7 +32,7 @@ public TtmlRegion() {
     this(Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
   }
 
-  public TtmlRegion(float position, float line, int lineType, float width) {
+  public TtmlRegion(float position, float line, @Cue.LineType int lineType, float width) {
     this.position = position;
     this.line = line;
     this.lineType = lineType;
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
index aa87af0e57..e4c36be03a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
@@ -16,8 +16,11 @@
 package com.google.android.exoplayer2.text.ttml;
 
 import android.graphics.Typeface;
+import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Style object of a <code>TtmlNode</code>
@@ -26,15 +29,25 @@
 
   public static final int UNSPECIFIED = -1;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
+      STYLE_BOLD_ITALIC})
+  public @interface StyleFlags {}
   public static final int STYLE_NORMAL = Typeface.NORMAL;
   public static final int STYLE_BOLD = Typeface.BOLD;
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
+  public @interface FontSizeUnit {}
   public static final int FONT_SIZE_UNIT_PIXEL = 1;
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({UNSPECIFIED, OFF, ON})
+  private @interface OptionalBoolean {}
   private static final int OFF = 0;
   private static final int ON = 1;
 
@@ -43,10 +56,15 @@
   private boolean hasFontColor;
   private int backgroundColor;
   private boolean hasBackgroundColor;
+  @OptionalBoolean
   private int linethrough;
+  @OptionalBoolean
   private int underline;
+  @OptionalBoolean
   private int bold;
+  @OptionalBoolean
   private int italic;
+  @FontSizeUnit
   private int fontSizeUnit;
   private float fontSize;
   private String id;
@@ -67,12 +85,13 @@ public TtmlStyle() {
    * @return {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link #STYLE_BOLD}, {@link #STYLE_BOLD}
    *     or {@link #STYLE_BOLD_ITALIC}.
    */
+  @StyleFlags
   public int getStyle() {
     if (bold == UNSPECIFIED && italic == UNSPECIFIED) {
       return UNSPECIFIED;
     }
-    return (bold != UNSPECIFIED ? bold : STYLE_NORMAL)
-        | (italic != UNSPECIFIED ? italic : STYLE_NORMAL);
+    return (bold == ON ? STYLE_BOLD : STYLE_NORMAL)
+        | (italic == ON ? STYLE_ITALIC : STYLE_NORMAL);
   }
 
   public boolean isLinethrough() {
@@ -95,6 +114,18 @@ public TtmlStyle setUnderline(boolean underline) {
     return this;
   }
 
+  public TtmlStyle setBold(boolean bold) {
+    Assertions.checkState(inheritableStyle == null);
+    this.bold = bold ? ON : OFF;
+    return this;
+  }
+
+  public TtmlStyle setItalic(boolean italic) {
+    Assertions.checkState(inheritableStyle == null);
+    this.italic = italic ? ON : OFF;
+    return this;
+  }
+
   public String getFontFamily() {
     return fontFamily;
   }
@@ -140,18 +171,6 @@ public boolean hasBackgroundColor() {
     return hasBackgroundColor;
   }
 
-  public TtmlStyle setBold(boolean isBold) {
-    Assertions.checkState(inheritableStyle == null);
-    bold = isBold ? STYLE_BOLD : STYLE_NORMAL;
-    return this;
-  }
-
-  public TtmlStyle setItalic(boolean isItalic) {
-    Assertions.checkState(inheritableStyle == null);
-    italic = isItalic ? STYLE_ITALIC : STYLE_NORMAL;
-    return this;
-  }
-
   /**
    * Inherits from an ancestor style. Properties like <i>tts:backgroundColor</i> which
    * are not inheritable are not inherited as well as properties which are already set locally
@@ -236,6 +255,7 @@ public TtmlStyle setFontSizeUnit(int fontSizeUnit) {
     return this;
   }
 
+  @FontSizeUnit
   public int getFontSizeUnit() {
     return fontSizeUnit;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index 169bc6a8bf..157174a8f0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -16,8 +16,11 @@
 package com.google.android.exoplayer2.text.webvtt;
 
 import android.graphics.Typeface;
+import android.support.annotation.IntDef;
 import android.text.Layout;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -32,15 +35,25 @@
 
   public static final int UNSPECIFIED = -1;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
+      STYLE_BOLD_ITALIC})
+  public @interface StyleFlags {}
   public static final int STYLE_NORMAL = Typeface.NORMAL;
   public static final int STYLE_BOLD = Typeface.BOLD;
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
+  public @interface FontSizeUnit {}
   public static final int FONT_SIZE_UNIT_PIXEL = 1;
   public static final int FONT_SIZE_UNIT_EM = 2;
   public static final int FONT_SIZE_UNIT_PERCENT = 3;
 
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({UNSPECIFIED, OFF, ON})
+  private @interface OptionalBoolean {}
   private static final int OFF = 0;
   private static final int ON = 1;
 
@@ -56,10 +69,15 @@
   private boolean hasFontColor;
   private int backgroundColor;
   private boolean hasBackgroundColor;
+  @OptionalBoolean
   private int linethrough;
+  @OptionalBoolean
   private int underline;
+  @OptionalBoolean
   private int bold;
+  @OptionalBoolean
   private int italic;
+  @FontSizeUnit
   private int fontSizeUnit;
   private float fontSize;
   private Layout.Alignment textAlign;
@@ -144,12 +162,13 @@ public int getSpecificityScore(String id, String tag, String[] classes, String v
    * @return {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link #STYLE_BOLD}, {@link #STYLE_BOLD}
    *     or {@link #STYLE_BOLD_ITALIC}.
    */
+  @StyleFlags
   public int getStyle() {
     if (bold == UNSPECIFIED && italic == UNSPECIFIED) {
       return UNSPECIFIED;
     }
-    return (bold != UNSPECIFIED ? bold : STYLE_NORMAL)
-        | (italic != UNSPECIFIED ? italic : STYLE_NORMAL);
+    return (bold == ON ? STYLE_BOLD : STYLE_NORMAL)
+        | (italic == ON ? STYLE_ITALIC : STYLE_NORMAL);
   }
 
   public boolean isLinethrough() {
@@ -169,6 +188,15 @@ public WebvttCssStyle setUnderline(boolean underline) {
     this.underline = underline ? ON : OFF;
     return this;
   }
+  public WebvttCssStyle setBold(boolean bold) {
+    this.bold = bold ? ON : OFF;
+    return this;
+  }
+
+  public WebvttCssStyle setItalic(boolean italic) {
+    this.italic = italic ? ON : OFF;
+    return this;
+  }
 
   public String getFontFamily() {
     return fontFamily;
@@ -213,16 +241,6 @@ public boolean hasBackgroundColor() {
     return hasBackgroundColor;
   }
 
-  public WebvttCssStyle setBold(boolean isBold) {
-    bold = isBold ? STYLE_BOLD : STYLE_NORMAL;
-    return this;
-  }
-
-  public WebvttCssStyle setItalic(boolean isItalic) {
-    italic = isItalic ? STYLE_ITALIC : STYLE_NORMAL;
-    return this;
-  }
-
   public Layout.Alignment getTextAlign() {
     return textAlign;
   }
@@ -242,6 +260,7 @@ public WebvttCssStyle setFontSizeUnit(short unit) {
     return this;
   }
 
+  @FontSizeUnit
   public int getFontSizeUnit() {
     return fontSizeUnit;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
index f1ce0e28fc..295fdc656f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
@@ -37,8 +37,9 @@ public WebvttCue(long startTime, long endTime, CharSequence text) {
         Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
   }
 
-  public WebvttCue(long startTime, long endTime, CharSequence text, Alignment textAlignment, 
-      float line, int lineType, int lineAnchor, float position, int positionAnchor, float width) {
+  public WebvttCue(long startTime, long endTime, CharSequence text, Alignment textAlignment,
+      float line, @Cue.LineType int lineType, @Cue.AnchorType int lineAnchor, float position,
+      @Cue.AnchorType int positionAnchor, float width) {
     super(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, width);
     this.startTime = startTime;
     this.endTime = endTime;
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 4f76983d15..81d79ac055 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -18,22 +18,301 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.os.Handler;
+import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
 
 /**
- * A {@link MappingTrackSelector} that allows configuration of common parameters.
+ * A {@link MappingTrackSelector} that allows configuration of common parameters. It is safe to call
+ * the methods of this class from the application thread. See {@link Parameters#Parameters()} for
+ * default selection parameters.
  */
 public class DefaultTrackSelector extends MappingTrackSelector {
 
+  /**
+   * Holder for available configurations for the {@link DefaultTrackSelector}.
+   */
+  public static final class Parameters {
+
+    // Audio.
+    public final String preferredAudioLanguage;
+
+    // Text.
+    public final String preferredTextLanguage;
+
+    // Video.
+    public final boolean allowMixedMimeAdaptiveness;
+    public final boolean allowNonSeamlessAdaptiveness;
+    public final int maxVideoWidth;
+    public final int maxVideoHeight;
+    public final boolean exceedVideoConstraintsIfNecessary;
+    public final int viewportWidth;
+    public final int viewportHeight;
+    public final boolean orientationMayChange;
+
+    /**
+     * Constructor with default selection parameters:
+     * <ul>
+     *   <li>No preferred audio language is set.</li>
+     *   <li>No preferred text language is set.</li>
+     *   <li>Adaptation between different mime types is not allowed.</li>
+     *   <li>Non seamless adaptation is allowed.</li>
+     *   <li>No max limit for video width/height.</li>
+     *   <li>Video constraints are ignored if no supported selection can be made otherwise.</li>
+     *   <li>No viewport width/height constraints are set.</li>
+     * </ul>
+     */
+    public Parameters() {
+      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, Integer.MAX_VALUE,
+          Integer.MAX_VALUE, true);
+    }
+
+    /**
+     * @param preferredAudioLanguage The preferred language for audio, as well as for forced text
+     *     tracks as defined by RFC 5646. {@code null} to select the default track, or first track
+     *     if there's no default.
+     * @param preferredTextLanguage The preferred language for text tracks as defined by RFC 5646.
+     *     {@code null} to select the default track, or first track if there's no default.
+     * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
+     * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
+     * @param maxVideoWidth Maximum allowed video width.
+     * @param maxVideoHeight Maximum allowed video height.
+     * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
+     *     can be made otherwise. False to force constraints anyway.
+     * @param viewportWidth Viewport width in pixels.
+     * @param viewportHeight Viewport height in pixels.
+     * @param orientationMayChange Whether orientation may change during playback.
+     */
+    public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
+        boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
+        int maxVideoWidth, int maxVideoHeight, boolean exceedVideoConstraintsIfNecessary,
+        int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+      this.preferredAudioLanguage = preferredAudioLanguage;
+      this.preferredTextLanguage = preferredTextLanguage;
+      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+      this.maxVideoWidth = maxVideoWidth;
+      this.maxVideoHeight = maxVideoHeight;
+      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+      this.viewportWidth = viewportWidth;
+      this.viewportHeight = viewportHeight;
+      this.orientationMayChange = orientationMayChange;
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided preferred language for audio and
+     * forced text tracks.
+     *
+     * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
+     *     select the default track, or first track if there's no default.
+     * @return A {@link Parameters} instance with the provided preferred language for audio and
+     *     forced text tracks.
+     */
+    public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
+      preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
+      if (TextUtils.equals(preferredAudioLanguage, this.preferredAudioLanguage)) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight, orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided preferred language for text tracks.
+     *
+     * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
+     *     select the default track, or no track if there's no default.
+     * @return A {@link Parameters} instance with the provided preferred language for text tracks.
+     */
+    public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
+      preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+      if (TextUtils.equals(preferredTextLanguage, this.preferredTextLanguage)) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
+     *
+     * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
+     * @return A {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
+     */
+    public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
+      if (allowMixedMimeAdaptiveness == this.allowMixedMimeAdaptiveness) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided seamless adaptiveness allowance.
+     *
+     * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
+     * @return A {@link Parameters} instance with the provided seamless adaptiveness allowance.
+     */
+    public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
+      if (allowNonSeamlessAdaptiveness == this.allowNonSeamlessAdaptiveness) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided max video size.
+     *
+     * @param maxVideoWidth The max video width.
+     * @param maxVideoHeight The max video width.
+     * @return A {@link Parameters} instance with the provided max video size.
+     */
+    public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
+      if (maxVideoWidth == this.maxVideoWidth && maxVideoHeight == this.maxVideoHeight) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Equivalent to {@code withMaxVideoSize(1279, 719)}.
+     *
+     * @return A {@link Parameters} instance with maximum standard definition as maximum video size.
+     */
+    public Parameters withMaxVideoSizeSd() {
+      return withMaxVideoSize(1279, 719);
+    }
+
+    /**
+     * Equivalent to {@code withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
+     *
+     * @return A {@link Parameters} instance without video size constraints.
+     */
+    public Parameters withoutVideoSizeConstraints() {
+      return withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided
+     * {@code exceedVideoConstraintsIfNecessary} value.
+     *
+     * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
+     *     can be made otherwise. False to force constraints anyway.
+     * @return A {@link Parameters} instance with the provided
+     *     {@code exceedVideoConstraintsIfNecessary} value.
+     */
+    public Parameters withExceedVideoConstraintsIfNecessary(
+        boolean exceedVideoConstraintsIfNecessary) {
+      if (exceedVideoConstraintsIfNecessary == this.exceedVideoConstraintsIfNecessary) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided viewport size.
+     *
+     * @param viewportWidth Viewport width in pixels.
+     * @param viewportHeight Viewport height in pixels.
+     * @param orientationMayChange Whether orientation may change during playback.
+     * @return A {@link Parameters} instance with the provided viewport size.
+     */
+    public Parameters withViewportSize(int viewportWidth, int viewportHeight,
+        boolean orientationMayChange) {
+      if (viewportWidth == this.viewportWidth && viewportHeight == this.viewportHeight
+          && orientationMayChange == this.orientationMayChange) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth,
+          maxVideoHeight, exceedVideoConstraintsIfNecessary, viewportWidth, viewportHeight,
+          orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance where the viewport size is obtained from the provided
+     * {@link Context}.
+     *
+     * @param context The context to obtain the viewport size from.
+     * @param orientationMayChange Whether orientation may change during playback.
+     * @return A {@link Parameters} instance where the viewport size is obtained from the provided
+     *     {@link Context}.
+     */
+    public Parameters withViewportSizeFromContext(Context context, boolean orientationMayChange) {
+      // Assume the viewport is fullscreen.
+      Point viewportSize = Util.getPhysicalDisplaySize(context);
+      return withViewportSize(viewportSize.x, viewportSize.y, orientationMayChange);
+    }
+
+    /**
+     * Equivalent to {@code withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+     *
+     * @return A {@link Parameters} instance without viewport size constraints.
+     */
+    public Parameters withoutViewportSizeConstraints() {
+      return withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      }
+      Parameters other = (Parameters) obj;
+      return allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
+          && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
+          && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
+          && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
+          && orientationMayChange == other.orientationMayChange
+          && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
+          && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
+          && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = preferredAudioLanguage.hashCode();
+      result = 31 * result + preferredTextLanguage.hashCode();
+      result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
+      result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
+      result = 31 * result + maxVideoWidth;
+      result = 31 * result + maxVideoHeight;
+      result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
+      result = 31 * result + (orientationMayChange ? 1 : 0);
+      result = 31 * result + viewportWidth;
+      result = 31 * result + viewportHeight;
+      return result;
+    }
+
+  }
+
   /**
    * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
    * corresponding viewport dimension, then the video is considered as filling the viewport (in that
@@ -43,22 +322,7 @@
   private static final int[] NO_TRACKS = new int[0];
 
   private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
-
-  // Audio.
-  private String preferredAudioLanguage;
-
-  // Text.
-  private String preferredTextLanguage;
-
-  // Video.
-  private boolean allowMixedMimeAdaptiveness;
-  private boolean allowNonSeamlessAdaptiveness;
-  private int maxVideoWidth;
-  private int maxVideoHeight;
-  private boolean exceedVideoConstraintsIfNecessary;
-  private boolean orientationMayChange;
-  private int viewportWidth;
-  private int viewportHeight;
+  private final AtomicReference<Parameters> params;
 
   /**
    * Constructs an instance that does not support adaptive video.
@@ -82,142 +346,28 @@ public DefaultTrackSelector(Handler eventHandler,
       TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
     super(eventHandler);
     this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
-    allowNonSeamlessAdaptiveness = true;
-    exceedVideoConstraintsIfNecessary = true;
-    maxVideoWidth = Integer.MAX_VALUE;
-    maxVideoHeight = Integer.MAX_VALUE;
-    viewportWidth = Integer.MAX_VALUE;
-    viewportHeight = Integer.MAX_VALUE;
-    orientationMayChange = true;
-  }
-
-  /**
-   * Sets the preferred language for audio, as well as for forced text tracks.
-   *
-   * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
-   *     select the default track, or first track if there's no default.
-   */
-  public void setPreferredLanguages(String preferredAudioLanguage) {
-    preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
-    if (!Util.areEqual(this.preferredAudioLanguage, preferredAudioLanguage)) {
-      this.preferredAudioLanguage = preferredAudioLanguage;
-      invalidate();
-    }
-  }
-
-  /**
-   * Sets the preferred language for text tracks.
-   *
-   * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
-   *     select the default track, or no track if there's no default.
-   */
-  public void setPreferredTextLanguage(String preferredTextLanguage) {
-    preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
-    if (!Util.areEqual(this.preferredTextLanguage, preferredTextLanguage)) {
-      this.preferredTextLanguage = preferredTextLanguage;
-      invalidate();
-    }
-  }
-
-  /**
-   * Sets whether to allow selections to contain mixed mime types.
-   *
-   * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
-   */
-  public void allowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
-    if (this.allowMixedMimeAdaptiveness != allowMixedMimeAdaptiveness) {
-      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
-      invalidate();
-    }
-  }
-
-  /**
-   * Sets whether non-seamless adaptation is allowed.
-   *
-   * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
-   */
-  public void allowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
-    if (this.allowNonSeamlessAdaptiveness != allowNonSeamlessAdaptiveness) {
-      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
-      invalidate();
-    }
-  }
-
-  /**
-   * Sets the maximum allowed size for video tracks.
-   *
-   * @param maxVideoWidth Maximum allowed width.
-   * @param maxVideoHeight Maximum allowed height.
-   */
-  public void setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
-    if (this.maxVideoWidth != maxVideoWidth || this.maxVideoHeight != maxVideoHeight) {
-      this.maxVideoWidth = maxVideoWidth;
-      this.maxVideoHeight = maxVideoHeight;
-      invalidate();
-    }
-  }
-
-  /**
-   * Equivalent to {@code setMaxVideoSize(1279, 719)}.
-   */
-  public void setMaxVideoSizeSd() {
-    setMaxVideoSize(1279, 719);
-  }
-
-  /**
-   * Equivalent to {@code setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
-   */
-  public void clearMaxVideoSize() {
-    setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
+    params = new AtomicReference<>(new Parameters());
   }
 
   /**
-   * Sets whether video constraints should be ignored when no selection can be made otherwise.
+   * Atomically sets the provided parameters for track selection.
    *
-   * @param exceedVideoConstraintsIfNecessary True to ignore video constraints when no selections
-   *     can be made otherwise. False to force constraints anyway.
+   * @param params The parameters for track selection.
    */
-  public void setExceedVideoConstraintsIfNecessary(boolean exceedVideoConstraintsIfNecessary) {
-    if (this.exceedVideoConstraintsIfNecessary != exceedVideoConstraintsIfNecessary) {
-      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+  public void setParameters(Parameters params) {
+    if (!this.params.get().equals(params)) {
+      this.params.set(Assertions.checkNotNull(params));
       invalidate();
     }
   }
 
   /**
-   * Sets the target viewport size for selecting video tracks.
+   * Gets the current selection parameters.
    *
-   * @param viewportWidth Viewport width in pixels.
-   * @param viewportHeight Viewport height in pixels.
-   * @param orientationMayChange Whether orientation may change during playback.
-   */
-  public void setViewportSize(int viewportWidth, int viewportHeight, boolean orientationMayChange) {
-    if (this.viewportWidth != viewportWidth || this.viewportHeight != viewportHeight
-        || this.orientationMayChange != orientationMayChange) {
-      this.viewportWidth = viewportWidth;
-      this.viewportHeight = viewportHeight;
-      this.orientationMayChange = orientationMayChange;
-      invalidate();
-    }
-  }
-
-  /**
-   * Retrieves the viewport size from the provided {@link Context} and calls
-   * {@link #setViewportSize(int, int, boolean)} with this information.
-   *
-   * @param context The context to obtain the viewport size from.
-   * @param orientationMayChange Whether orientation may change during playback.
-   */
-  public void setViewportSizeFromContext(Context context, boolean orientationMayChange) {
-    Point viewportSize = Util.getPhysicalDisplaySize(context); // Assume the viewport is fullscreen.
-    setViewportSize(viewportSize.x, viewportSize.y, orientationMayChange);
-  }
-
-  /**
-   * Equivalent to {@code setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+   * @return The current selection parameters.
    */
-  public void clearViewportConstraints() {
-    setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+  public Parameters getParameters() {
+    return params.get();
   }
 
   // MappingTrackSelector implementation.
@@ -228,22 +378,25 @@ public void clearViewportConstraints() {
       throws ExoPlaybackException {
     // Make a track selection for each renderer.
     TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
+    Parameters params = this.params.get();
     for (int i = 0; i < rendererCapabilities.length; i++) {
       switch (rendererCapabilities[i].getTrackType()) {
         case C.TRACK_TYPE_VIDEO:
           rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
-              rendererTrackGroupArrays[i], rendererFormatSupports[i], maxVideoWidth, maxVideoHeight,
-              allowNonSeamlessAdaptiveness, allowMixedMimeAdaptiveness, viewportWidth,
-              viewportHeight, orientationMayChange, adaptiveVideoTrackSelectionFactory,
-              exceedVideoConstraintsIfNecessary);
+              rendererTrackGroupArrays[i], rendererFormatSupports[i], params.maxVideoWidth,
+              params.maxVideoHeight, params.allowNonSeamlessAdaptiveness,
+              params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
+              params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
+              params.exceedVideoConstraintsIfNecessary);
           break;
         case C.TRACK_TYPE_AUDIO:
           rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
-              rendererFormatSupports[i], preferredAudioLanguage);
+              rendererFormatSupports[i], params.preferredAudioLanguage);
           break;
         case C.TRACK_TYPE_TEXT:
           rendererTrackSelections[i] = selectTextTrack(rendererTrackGroupArrays[i],
-              rendererFormatSupports[i], preferredTextLanguage, preferredAudioLanguage);
+              rendererFormatSupports[i], params.preferredTextLanguage,
+              params.preferredAudioLanguage);
           break;
         default:
           rendererTrackSelections[i] = selectOtherTrack(rendererCapabilities[i].getTrackType(),
@@ -442,7 +595,7 @@ protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] format
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex])) {
           Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
+          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           int trackScore;
           if (formatHasLanguage(format, preferredAudioLanguage)) {
             if (isDefault) {
@@ -480,8 +633,8 @@ protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatS
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex])) {
           Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
-          boolean isForced = (format.selectionFlags & Format.SELECTION_FLAG_FORCED) != 0;
+          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+          boolean isForced = (format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0;
           int trackScore;
           if (formatHasLanguage(format, preferredTextLanguage)) {
             if (isDefault) {
@@ -530,7 +683,7 @@ protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
       for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
         if (isSupported(trackFormatSupport[trackIndex])) {
           Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & Format.SELECTION_FLAG_DEFAULT) != 0;
+          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
           int trackScore = isDefault ? 2 : 1;
           if (trackScore > selectedTrackScore) {
             selectedGroup = trackGroup;
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 5097079874..3826ee4668 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -16,39 +16,23 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.Handler;
-import android.util.Pair;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
  * Base class for {@link TrackSelector}s that first establish a mapping between {@link TrackGroup}s
  * and renderers, and then from that mapping create a {@link TrackSelection} for each renderer.
  */
-public abstract class MappingTrackSelector extends TrackSelector {
-
-  /**
-   * Listener of {@link MappingTrackSelector} events.
-   */
-  public interface EventListener {
-
-    /**
-     * Called when the track information has changed.
-     *
-     * @param trackInfo Contains the new track and track selection information.
-     */
-    void onTracksChanged(TrackInfo trackInfo);
-
-  }
+public abstract class MappingTrackSelector extends TrackSelector<MappedTrackInfo> {
 
   /**
    * A track selection override.
@@ -96,51 +80,19 @@ public boolean containsTrack(int track) {
 
   }
 
-  private final Handler eventHandler;
-  private final CopyOnWriteArraySet<EventListener> listeners;
   private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
   private final SparseBooleanArray rendererDisabledFlags;
 
-  private TrackInfo activeTrackInfo;
-
   /**
    * @param eventHandler A handler to use when delivering events to listeners added via
    *     {@link #addListener(EventListener)}.
    */
   public MappingTrackSelector(Handler eventHandler) {
-    this.eventHandler = eventHandler;
-    this.listeners = new CopyOnWriteArraySet<>();
+    super(eventHandler);
     selectionOverrides = new SparseArray<>();
     rendererDisabledFlags = new SparseBooleanArray();
   }
 
-  /**
-   * Register a listener to receive events from the selector. The listener's methods will be called
-   * using the {@link Handler} that was passed to the constructor.
-   *
-   * @param listener The listener to register.
-   */
-  public final void addListener(EventListener listener) {
-    Assertions.checkState(eventHandler != null);
-    listeners.add(listener);
-  }
-
-  /**
-   * Unregister a listener. The listener will no longer receive events from the selector.
-   *
-   * @param listener The listener to unregister.
-   */
-  public final void removeListener(EventListener listener) {
-    listeners.remove(listener);
-  }
-
-  /**
-   * Returns information about the current tracks and track selection for each renderer.
-   */
-  public final TrackInfo getTrackInfo() {
-    return activeTrackInfo;
-  }
-
   /**
    * Sets whether the renderer at the specified index is disabled.
    *
@@ -272,13 +224,7 @@ public final void clearSelectionOverrides() {
   // TrackSelector implementation.
 
   @Override
-  public final void onSelectionActivated(Object selectionInfo) {
-    activeTrackInfo = (TrackInfo) selectionInfo;
-    notifyTrackInfoChanged(activeTrackInfo);
-  }
-
-  @Override
-  public final Pair<TrackSelectionArray, Object> selectTracks(
+  public final TrackSelections<MappedTrackInfo> selectTracks(
       RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
       throws ExoPlaybackException {
     // Structures into which data will be written during the selection. The extra item at the end
@@ -345,11 +291,10 @@ public final void onSelectionActivated(Object selectionInfo) {
     }
 
     // Package up the track information and selections.
-    TrackSelectionArray trackSelectionArray = new TrackSelectionArray(trackSelections);
-    TrackInfo trackInfo = new TrackInfo(rendererTrackTypes, rendererTrackGroupArrays,
-        trackSelections, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
+    MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
+        rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
         unassociatedTrackGroupArray);
-    return Pair.<TrackSelectionArray, Object>create(trackSelectionArray, trackInfo);
+    return new TrackSelections<>(mappedTrackInfo, trackSelections);
   }
 
   /**
@@ -446,23 +391,10 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
     return mixedMimeTypeAdaptationSupport;
   }
 
-  private void notifyTrackInfoChanged(final TrackInfo trackInfo) {
-    if (eventHandler != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          for (EventListener listener : listeners) {
-            listener.onTracksChanged(trackInfo);
-          }
-        }
-      });
-    }
-  }
-
   /**
    * Provides track information for each renderer.
    */
-  public static final class TrackInfo {
+  public static final class MappedTrackInfo {
 
     /**
      * The renderer does not have any associated tracks.
@@ -477,34 +409,27 @@ public void run() {
      */
     public static final int RENDERER_SUPPORT_PLAYABLE_TRACKS = 2;
 
-    /**
-     * The number of renderers.
-     */
-    public final int rendererCount;
-
     private final int[] rendererTrackTypes;
     private final TrackGroupArray[] trackGroups;
-    private final TrackSelection[] trackSelections;
     private final int[] mixedMimeTypeAdaptiveSupport;
     private final int[][][] formatSupport;
     private final TrackGroupArray unassociatedTrackGroups;
+    private final int rendererCount;
 
     /**
      * @param rendererTrackTypes The track type supported by each renderer.
      * @param trackGroups The {@link TrackGroupArray}s for each renderer.
-     * @param trackSelections The current {@link TrackSelection}s for each renderer.
      * @param mixedMimeTypeAdaptiveSupport The result of
      *     {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
      * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each
      *     track, indexed by renderer index, group index and track index (in that order).
      * @param unassociatedTrackGroups Contains {@link TrackGroup}s not associated with any renderer.
      */
-    /* package */ TrackInfo(int[] rendererTrackTypes, TrackGroupArray[] trackGroups,
-        TrackSelection[] trackSelections, int[] mixedMimeTypeAdaptiveSupport,
+    /* package */ MappedTrackInfo(int[] rendererTrackTypes,
+        TrackGroupArray[] trackGroups, int[] mixedMimeTypeAdaptiveSupport,
         int[][][] formatSupport, TrackGroupArray unassociatedTrackGroups) {
       this.rendererTrackTypes = rendererTrackTypes;
       this.trackGroups = trackGroups;
-      this.trackSelections = trackSelections;
       this.formatSupport = formatSupport;
       this.mixedMimeTypeAdaptiveSupport = mixedMimeTypeAdaptiveSupport;
       this.unassociatedTrackGroups = unassociatedTrackGroups;
@@ -521,16 +446,6 @@ public TrackGroupArray getTrackGroups(int rendererIndex) {
       return trackGroups[rendererIndex];
     }
 
-    /**
-     * Returns the current {@link TrackSelection} for the renderer at a specified index.
-     *
-     * @param rendererIndex The renderer index.
-     * @return The corresponding {@link TrackSelection}, or null if the renderer is disabled.
-     */
-    public TrackSelection getTrackSelection(int rendererIndex) {
-      return trackSelections[rendererIndex];
-    }
-
     /**
      * Returns the extent to which a renderer can support playback of the tracks associated to it.
      *
@@ -657,7 +572,7 @@ public TrackGroupArray getUnassociatedTrackGroups() {
      *     unplayable. False in all other cases.
      */
     public boolean hasOnlyUnplayableTracks(int trackType) {
-      int rendererSupport = TrackInfo.RENDERER_SUPPORT_NO_TRACKS;
+      int rendererSupport = RENDERER_SUPPORT_NO_TRACKS;
       for (int i = 0; i < rendererCount; i++) {
         if (rendererTrackTypes[i] == trackType) {
           rendererSupport = Math.max(rendererSupport, getRendererSupport(i));
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java
similarity index 80%
rename from library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
rename to library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java
index 4d4b4c614e..31ed838310 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelections.java
@@ -18,12 +18,16 @@
 import java.util.Arrays;
 
 /**
- * An array of {@link TrackSelection}s generated by a {@link TrackSelector}.
+ * The result of a {@link TrackSelector} operation.
  */
-public final class TrackSelectionArray {
+public final class TrackSelections<T> {
 
   /**
-   * The number of selections in the array. Greater than or equal to zero.
+   * Opaque information associated with the result.
+   */
+  public final T info;
+  /**
+   * The number of selections in the result. Greater than or equal to zero.
    */
   public final int length;
 
@@ -33,9 +37,11 @@
   private int hashCode;
 
   /**
+   * @param info Opaque information associated with the result.
    * @param trackSelections The selections. Must not be null, but may contain null elements.
    */
-  public TrackSelectionArray(TrackSelection... trackSelections) {
+  public TrackSelections(T info, TrackSelection... trackSelections) {
+    this.info = info;
     this.trackSelections = trackSelections;
     this.length = trackSelections.length;
   }
@@ -75,7 +81,7 @@ public boolean equals(Object obj) {
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    TrackSelectionArray other = (TrackSelectionArray) obj;
+    TrackSelections<?> other = (TrackSelections<?>) obj;
     return Arrays.equals(trackSelections, other.trackSelections);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index b18184ab3e..41c62f6e0e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -15,15 +15,15 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.util.Pair;
+import android.os.Handler;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.concurrent.CopyOnWriteArraySet;
 
-/**
- * Selects tracks to be consumed by available renderers.
- */
-public abstract class TrackSelector {
+/** Selects tracks to be consumed by available renderers. */
+public abstract class TrackSelector<T> {
 
   /**
    * Notified when previous selections by a {@link TrackSelector} are no longer valid.
@@ -37,7 +37,55 @@
 
   }
 
+  /** Listener of {@link TrackSelector} events. */
+  public interface EventListener<T> {
+
+    /**
+     * Called when the track selections have changed.
+     *
+     * @param trackSelections The new track selections.
+     */
+    void onTrackSelectionsChanged(TrackSelections<? extends T> trackSelections);
+  }
+
+  private final Handler eventHandler;
+  private final CopyOnWriteArraySet<MappingTrackSelector.EventListener<? super T>> listeners;
+
   private InvalidationListener listener;
+  private TrackSelections<T> activeSelections;
+
+  /**
+   * @param eventHandler A handler to use when delivering events to listeners added via {@link
+   *     #addListener(EventListener)}.
+   */
+  public TrackSelector(Handler eventHandler) {
+    this.eventHandler = Assertions.checkNotNull(eventHandler);
+    this.listeners = new CopyOnWriteArraySet<>();
+  }
+
+  /**
+   * Registers a listener to receive events from the selector. The listener's methods will be called
+   * using the {@link Handler} that was passed to the constructor.
+   *
+   * @param listener The listener to register.
+   */
+  public final void addListener(EventListener<? super T> listener) {
+    listeners.add(listener);
+  }
+
+  /**
+   * Unregister a listener. The listener will no longer receive events from the selector.
+   *
+   * @param listener The listener to unregister.
+   */
+  public final void removeListener(EventListener<? super T> listener) {
+    listeners.remove(listener);
+  }
+
+  /** Returns the current track selections. */
+  public final TrackSelections<T> getCurrentSelections() {
+    return activeSelections;
+  }
 
   /**
    * Initializes the selector.
@@ -49,31 +97,28 @@ public final void init(InvalidationListener listener) {
   }
 
   /**
-   * Generates a {@link TrackSelection} for each renderer.
-   * <P>
-   * The selections are returned in a {@link TrackSelectionArray}, together with an opaque object
-   * that the selector wishes to receive in an invocation of {@link #onSelectionActivated(Object)}
-   * should the selection be activated.
+   * Generates {@link TrackSelections} for the renderers.
    *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
-   *     {@link TrackSelection}s are to be generated.
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which {@link
+   *     TrackSelection}s are to be generated.
    * @param trackGroups The available track groups.
-   * @return A {@link TrackSelectionArray} containing a {@link TrackSelection} for each renderer,
-   *     together with an opaque object that will be passed to {@link #onSelectionActivated(Object)}
-   *     if the selection is activated.
+   * @return The track selections.
    * @throws ExoPlaybackException If an error occurs selecting tracks.
    */
-  public abstract Pair<TrackSelectionArray, Object> selectTracks(
+  public abstract TrackSelections<T> selectTracks(
       RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
       throws ExoPlaybackException;
 
   /**
-   * Called when a selection previously generated by
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} is activated.
+   * Called when {@link TrackSelections} previously generated by {@link
+   * #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
    *
-   * @param selectionInfo The opaque object associated with the selection.
+   * @param activeSelections The activated {@link TrackSelections}.
    */
-  public abstract void onSelectionActivated(Object selectionInfo);
+  public final void onSelectionActivated(TrackSelections<T> activeSelections) {
+    this.activeSelections = activeSelections;
+    notifyTrackSelectionsChanged(activeSelections);
+  }
 
   /**
    * Invalidates all previously generated track selections.
@@ -84,4 +129,18 @@ protected final void invalidate() {
     }
   }
 
+  private void notifyTrackSelectionsChanged(final TrackSelections<T> activeSelections) {
+    if (eventHandler != null) {
+      eventHandler.post(
+          new Runnable() {
+            @Override
+            public void run() {
+              for (EventListener<? super T> listener : listeners) {
+                listener.onTrackSelectionsChanged(activeSelections);
+              }
+            }
+          });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index 30c1b88c79..e6f18c882b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -16,14 +16,30 @@
 package com.google.android.exoplayer2.ui;
 
 import android.content.Context;
+import android.content.res.TypedArray;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 
+import com.google.android.exoplayer2.R;
+
 /**
  * A {@link FrameLayout} that resizes itself to match a specified aspect ratio.
  */
 public final class AspectRatioFrameLayout extends FrameLayout {
 
+  /**
+   * Either the width or height is decreased to obtain the desired aspect ratio.
+   */
+  public static final int RESIZE_MODE_FIT = 0;
+  /**
+   * The width is fixed and the height is increased or decreased to obtain the desired aspect ratio.
+   */
+  public static final int RESIZE_MODE_FIXED_WIDTH = 1;
+  /**
+   * The height is fixed and the width is increased or decreased to obtain the desired aspect ratio.
+   */
+  public static final int RESIZE_MODE_FIXED_HEIGHT = 2;
+
   /**
    * The {@link FrameLayout} will not resize itself if the fractional difference between its natural
    * aspect ratio and the requested aspect ratio falls below this threshold.
@@ -36,13 +52,24 @@
   private static final float MAX_ASPECT_RATIO_DEFORMATION_FRACTION = 0.01f;
 
   private float videoAspectRatio;
+  private int resizeMode;
 
   public AspectRatioFrameLayout(Context context) {
-    super(context);
+    this(context, null);
   }
 
   public AspectRatioFrameLayout(Context context, AttributeSet attrs) {
     super(context, attrs);
+    resizeMode = RESIZE_MODE_FIT;
+    if (attrs != null) {
+      TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
+          R.styleable.AspectRatioFrameLayout, 0, 0);
+      try {
+        resizeMode = a.getInt(R.styleable.AspectRatioFrameLayout_resize_mode, RESIZE_MODE_FIT);
+      } finally {
+        a.recycle();
+      }
+    }
   }
 
   /**
@@ -57,6 +84,19 @@ public void setAspectRatio(float widthHeightRatio) {
     }
   }
 
+  /**
+   * Sets the resize mode which can be of value {@link #RESIZE_MODE_FIT},
+   * {@link #RESIZE_MODE_FIXED_HEIGHT} or {@link #RESIZE_MODE_FIXED_WIDTH}.
+   *
+   * @param resizeMode The resize mode.
+   */
+  public void setResizeMode(int resizeMode) {
+    if (this.resizeMode != resizeMode) {
+      this.resizeMode = resizeMode;
+      requestLayout();
+    }
+  }
+
   @Override
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     super.onMeasure(widthMeasureSpec, heightMeasureSpec);
@@ -74,10 +114,20 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
       return;
     }
 
-    if (aspectDeformation > 0) {
-      height = (int) (width / videoAspectRatio);
-    } else {
-      width = (int) (height * videoAspectRatio);
+    switch (resizeMode) {
+      case RESIZE_MODE_FIXED_WIDTH:
+        height = (int) (width / videoAspectRatio);
+        break;
+      case RESIZE_MODE_FIXED_HEIGHT:
+        width = (int) (height * videoAspectRatio);
+        break;
+      default:
+        if (aspectDeformation > 0) {
+          height = (int) (width / videoAspectRatio);
+        } else {
+          width = (int) (height * videoAspectRatio);
+        }
+        break;
     }
     super.onMeasure(MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
         MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 25a8e1e716..89c778d072 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.ui;
 
+import android.annotation.TargetApi;
 import android.content.Context;
+import android.content.res.TypedArray;
+import android.os.SystemClock;
 import android.util.AttributeSet;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -52,7 +55,7 @@
 
   public static final int DEFAULT_FAST_FORWARD_MS = 15000;
   public static final int DEFAULT_REWIND_MS = 5000;
-  public static final int DEFAULT_SHOW_DURATION_MS = 5000;
+  public static final int DEFAULT_SHOW_TIMEOUT_MS = 5000;
 
   private static final int PROGRESS_BAR_MAX = 1000;
   private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
@@ -73,10 +76,12 @@
   private ExoPlayer player;
   private VisibilityListener visibilityListener;
 
+  private boolean isAttachedToWindow;
   private boolean dragging;
-  private int rewindMs = DEFAULT_REWIND_MS;
-  private int fastForwardMs = DEFAULT_FAST_FORWARD_MS;
-  private int showDurationMs = DEFAULT_SHOW_DURATION_MS;
+  private int rewindMs;
+  private int fastForwardMs;
+  private int showTimeoutMs;
+  private long hideAtMs;
 
   private final Runnable updateProgressAction = new Runnable() {
     @Override
@@ -103,12 +108,28 @@ public PlaybackControlView(Context context, AttributeSet attrs) {
   public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
 
+    rewindMs = DEFAULT_REWIND_MS;
+    fastForwardMs = DEFAULT_FAST_FORWARD_MS;
+    showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
+    if (attrs != null) {
+      TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
+          R.styleable.PlaybackControlView, 0, 0);
+      try {
+        rewindMs = a.getInt(R.styleable.PlaybackControlView_rewind_increment, rewindMs);
+        fastForwardMs = a.getInt(R.styleable.PlaybackControlView_fastforward_increment,
+            fastForwardMs);
+        showTimeoutMs = a.getInt(R.styleable.PlaybackControlView_show_timeout, showTimeoutMs);
+      } finally {
+        a.recycle();
+      }
+    }
+
     currentWindow = new Timeline.Window();
     formatBuilder = new StringBuilder();
     formatter = new Formatter(formatBuilder, Locale.getDefault());
     componentListener = new ComponentListener();
 
-    LayoutInflater.from(context).inflate(R.layout.playback_control_view, this);
+    LayoutInflater.from(context).inflate(R.layout.exo_playback_control_view, this);
     time = (TextView) findViewById(R.id.time);
     timeCurrent = (TextView) findViewById(R.id.time_current);
     progressBar = (SeekBar) findViewById(R.id.mediacontroller_progress);
@@ -124,7 +145,13 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
     rewindButton.setOnClickListener(componentListener);
     fastForwardButton = findViewById(R.id.ffwd);
     fastForwardButton.setOnClickListener(componentListener);
-    updateAll();
+  }
+
+  /**
+   * Returns the player currently being controlled by this view, or null if no player is set.
+   */
+  public ExoPlayer getPlayer() {
+    return player;
   }
 
   /**
@@ -133,6 +160,9 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
    * @param player the {@code ExoPlayer} to control.
    */
   public void setPlayer(ExoPlayer player) {
+    if (this.player == player) {
+      return;
+    }
     if (this.player != null) {
       this.player.removeListener(componentListener);
     }
@@ -159,6 +189,7 @@ public void setVisibilityListener(VisibilityListener listener) {
    */
   public void setRewindIncrementMs(int rewindMs) {
     this.rewindMs = rewindMs;
+    updateNavigation();
   }
 
   /**
@@ -168,51 +199,60 @@ public void setRewindIncrementMs(int rewindMs) {
    */
   public void setFastForwardIncrementMs(int fastForwardMs) {
     this.fastForwardMs = fastForwardMs;
+    updateNavigation();
   }
 
   /**
-   * Sets the duration to show the playback control in milliseconds.
+   * Returns the playback controls timeout. The playback controls are automatically hidden after
+   * this duration of time has elapsed without user input.
    *
-   * @param showDurationMs The duration in milliseconds.
+   * @return The duration in milliseconds. A non-positive value indicates that the controls will
+   *     remain visible indefinitely.
    */
-  public void setShowDurationMs(int showDurationMs) {
-    this.showDurationMs = showDurationMs;
+  public int getShowTimeoutMs() {
+    return showTimeoutMs;
   }
 
   /**
-   * Shows the controller for the duration last passed to {@link #setShowDurationMs(int)}, or for
-   * {@link #DEFAULT_SHOW_DURATION_MS} if {@link #setShowDurationMs(int)} has not been called.
+   * Sets the playback controls timeout. The playback controls are automatically hidden after this
+   * duration of time has elapsed without user input.
+   *
+   * @param showTimeoutMs The duration in milliseconds. A non-positive value will cause the controls
+   *     to remain visible indefinitely.
    */
-  public void show() {
-    show(showDurationMs);
+  public void setShowTimeoutMs(int showTimeoutMs) {
+    this.showTimeoutMs = showTimeoutMs;
   }
 
   /**
-   * Shows the controller for the {@code durationMs}. If {@code durationMs} is 0 the controller is
-   * shown until {@link #hide()} is called.
-   *
-   * @param durationMs The duration in milliseconds.
+   * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
+   * be automatically hidden after this duration of time has elapsed without user input.
    */
-  public void show(int durationMs) {
-    setVisibility(VISIBLE);
-    if (visibilityListener != null) {
-      visibilityListener.onVisibilityChange(getVisibility());
+  public void show() {
+    if (!isVisible()) {
+      setVisibility(VISIBLE);
+      if (visibilityListener != null) {
+        visibilityListener.onVisibilityChange(getVisibility());
+      }
+      updateAll();
     }
-    updateAll();
-    showDurationMs = durationMs;
-    hideDeferred();
+    // Call hideAfterTimeout even if already visible to reset the timeout.
+    hideAfterTimeout();
   }
 
   /**
    * Hides the controller.
    */
   public void hide() {
-    setVisibility(GONE);
-    if (visibilityListener != null) {
-      visibilityListener.onVisibilityChange(getVisibility());
+    if (isVisible()) {
+      setVisibility(GONE);
+      if (visibilityListener != null) {
+        visibilityListener.onVisibilityChange(getVisibility());
+      }
+      removeCallbacks(updateProgressAction);
+      removeCallbacks(hideAction);
+      hideAtMs = C.TIME_UNSET;
     }
-    removeCallbacks(updateProgressAction);
-    removeCallbacks(hideAction);
   }
 
   /**
@@ -222,10 +262,15 @@ public boolean isVisible() {
     return getVisibility() == VISIBLE;
   }
 
-  private void hideDeferred() {
+  private void hideAfterTimeout() {
     removeCallbacks(hideAction);
-    if (showDurationMs > 0) {
-      postDelayed(hideAction, showDurationMs);
+    if (showTimeoutMs > 0) {
+      hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs;
+      if (isAttachedToWindow) {
+        postDelayed(hideAction, showTimeoutMs);
+      }
+    } else {
+      hideAtMs = C.TIME_UNSET;
     }
   }
 
@@ -236,17 +281,19 @@ private void updateAll() {
   }
 
   private void updatePlayPauseButton() {
-    if (!isVisible()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
     boolean playing = player != null && player.getPlayWhenReady();
-    playButton.setImageResource(playing ? R.drawable.ic_media_pause : R.drawable.ic_media_play);
-    playButton.setContentDescription(
-        getResources().getString(playing ? R.string.pause_description : R.string.play_description));
+    String contentDescription = getResources().getString(
+        playing ? R.string.exo_controls_pause_description : R.string.exo_controls_play_description);
+    playButton.setContentDescription(contentDescription);
+    playButton.setImageResource(
+        playing ? R.drawable.exo_controls_pause : R.drawable.exo_controls_play);
   }
 
   private void updateNavigation() {
-    if (!isVisible()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
     Timeline currentTimeline = player != null ? player.getCurrentTimeline() : null;
@@ -264,13 +311,13 @@ private void updateNavigation() {
     }
     setButtonEnabled(enablePrevious , previousButton);
     setButtonEnabled(enableNext, nextButton);
-    setButtonEnabled(isSeekable, fastForwardButton);
-    setButtonEnabled(isSeekable, rewindButton);
+    setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
+    setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
     progressBar.setEnabled(isSeekable);
   }
 
   private void updateProgress() {
-    if (!isVisible()) {
+    if (!isVisible() || !isAttachedToWindow) {
       return;
     }
     long duration = player == null ? 0 : player.getDuration();
@@ -305,13 +352,18 @@ private void updateProgress() {
   private void setButtonEnabled(boolean enabled, View view) {
     view.setEnabled(enabled);
     if (Util.SDK_INT >= 11) {
-      view.setAlpha(enabled ? 1f : 0.3f);
+      setViewAlphaV11(view, enabled ? 1f : 0.3f);
       view.setVisibility(VISIBLE);
     } else {
       view.setVisibility(enabled ? VISIBLE : INVISIBLE);
     }
   }
 
+  @TargetApi(11)
+  private void setViewAlphaV11(View view, float alpha) {
+    view.setAlpha(alpha);
+  }
+
   private String stringForTime(long timeMs) {
     if (timeMs == C.TIME_UNSET) {
       timeMs = 0;
@@ -365,13 +417,42 @@ private void next() {
   }
 
   private void rewind() {
+    if (rewindMs <= 0) {
+      return;
+    }
     player.seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
   }
 
   private void fastForward() {
+    if (fastForwardMs <= 0) {
+      return;
+    }
     player.seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
   }
 
+  @Override
+  public void onAttachedToWindow() {
+    super.onAttachedToWindow();
+    isAttachedToWindow = true;
+    if (hideAtMs != C.TIME_UNSET) {
+      long delayMs = hideAtMs - SystemClock.uptimeMillis();
+      if (delayMs <= 0) {
+        hide();
+      } else {
+        postDelayed(hideAction, delayMs);
+      }
+    }
+    updateAll();
+  }
+
+  @Override
+  public void onDetachedFromWindow() {
+    super.onDetachedFromWindow();
+    isAttachedToWindow = false;
+    removeCallbacks(updateProgressAction);
+    removeCallbacks(hideAction);
+  }
+
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     if (player == null || event.getAction() != KeyEvent.ACTION_DOWN) {
@@ -428,7 +509,7 @@ public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
     public void onStopTrackingTouch(SeekBar seekBar) {
       dragging = false;
       player.seekTo(positionValue(seekBar.getProgress()));
-      hideDeferred();
+      hideAfterTimeout();
     }
 
     @Override
@@ -473,7 +554,7 @@ public void onClick(View view) {
       } else if (playButton == view) {
         player.setPlayWhenReady(!player.getPlayWhenReady());
       }
-      hideDeferred();
+      hideAfterTimeout();
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index 390ab2ee7a..51955ccef3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -22,22 +22,18 @@
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
-import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.TextureView;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.FrameLayout;
-
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.R;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextRenderer;
-
 import java.util.List;
 
 /**
@@ -52,8 +48,10 @@
   private final AspectRatioFrameLayout layout;
   private final PlaybackControlView controller;
   private final ComponentListener componentListener;
+
   private SimpleExoPlayer player;
   private boolean useController = true;
+  private int controllerShowTimeoutMs;
 
   public SimpleExoPlayerView(Context context) {
     this(context, null);
@@ -67,28 +65,44 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     super(context, attrs, defStyleAttr);
 
     boolean useTextureView = false;
+    int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
+    int rewindMs = PlaybackControlView.DEFAULT_REWIND_MS;
+    int fastForwardMs = PlaybackControlView.DEFAULT_FAST_FORWARD_MS;
+    int controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;
     if (attrs != null) {
       TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
           R.styleable.SimpleExoPlayerView, 0, 0);
       try {
-        useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller,
-            useController);
+        useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);
         useTextureView = a.getBoolean(R.styleable.SimpleExoPlayerView_use_texture_view,
             useTextureView);
+        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode,
+            AspectRatioFrameLayout.RESIZE_MODE_FIT);
+        rewindMs = a.getInt(R.styleable.SimpleExoPlayerView_rewind_increment, rewindMs);
+        fastForwardMs = a.getInt(R.styleable.SimpleExoPlayerView_fastforward_increment,
+            fastForwardMs);
+        controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,
+            controllerShowTimeoutMs);
       } finally {
         a.recycle();
       }
     }
 
-    LayoutInflater.from(context).inflate(R.layout.exoplayer_video_view, this);
+    LayoutInflater.from(context).inflate(R.layout.exo_simple_player_view, this);
     componentListener = new ComponentListener();
     layout = (AspectRatioFrameLayout) findViewById(R.id.video_frame);
-    controller = (PlaybackControlView) findViewById(R.id.control);
+    layout.setResizeMode(resizeMode);
     shutterView = findViewById(R.id.shutter);
     subtitleLayout = (SubtitleView) findViewById(R.id.subtitles);
     subtitleLayout.setUserDefaultStyle();
     subtitleLayout.setUserDefaultTextSize();
 
+    controller = (PlaybackControlView) findViewById(R.id.control);
+    controller.hide();
+    controller.setRewindIncrementMs(rewindMs);
+    controller.setFastForwardIncrementMs(fastForwardMs);
+    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
+
     View view = useTextureView ? new TextureView(context) : new SurfaceView(context);
     ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
         ViewGroup.LayoutParams.MATCH_PARENT,
@@ -98,6 +112,13 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     layout.addView(surfaceView, 0);
   }
 
+  /**
+   * Returns the player currently set on this view, or null if no player is set.
+   */
+  public SimpleExoPlayer getPlayer() {
+    return player;
+  }
+
   /**
    * Set the {@link SimpleExoPlayer} to use. The {@link SimpleExoPlayer#setTextOutput} and
    * {@link SimpleExoPlayer#setVideoListener} method of the player will be called and previous
@@ -106,6 +127,9 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
    * @param player The {@link SimpleExoPlayer} to use.
    */
   public void setPlayer(SimpleExoPlayer player) {
+    if (this.player == player) {
+      return;
+    }
     if (this.player != null) {
       this.player.setTextOutput(null);
       this.player.setVideoListener(null);
@@ -113,7 +137,9 @@ public void setPlayer(SimpleExoPlayer player) {
       this.player.setVideoSurface(null);
     }
     this.player = player;
-
+    if (useController) {
+      controller.setPlayer(player);
+    }
     if (player != null) {
       if (surfaceView instanceof TextureView) {
         player.setVideoTextureView((TextureView) surfaceView);
@@ -123,18 +149,41 @@ public void setPlayer(SimpleExoPlayer player) {
       player.setVideoListener(componentListener);
       player.addListener(componentListener);
       player.setTextOutput(componentListener);
+      maybeShowController(false);
+    } else {
+      shutterView.setVisibility(VISIBLE);
+      controller.hide();
     }
-    setUseController(useController);
   }
 
   /**
-   * Set the {@code useController} flag which indicates whether the playback control view should
-   * be used or not. If set to {@code false} the controller is never visible and is disconnected
-   * from the player.
+   * Sets the resize mode which can be of value {@link AspectRatioFrameLayout#RESIZE_MODE_FIT},
+   * {@link AspectRatioFrameLayout#RESIZE_MODE_FIXED_HEIGHT} or
+   * {@link AspectRatioFrameLayout#RESIZE_MODE_FIXED_WIDTH}.
+   *
+   * @param resizeMode The resize mode.
+   */
+  public void setResizeMode(int resizeMode) {
+    layout.setResizeMode(resizeMode);
+  }
+
+  /**
+   * Returns whether the playback controls are enabled.
+   */
+  public boolean getUseController() {
+    return useController;
+  }
+
+  /**
+   * Sets whether playback controls are enabled. If set to {@code false} the playback controls are
+   * never visible and are disconnected from the player.
    *
-   * @param useController If {@code false} the playback control is never used.
+   * @param useController Whether playback controls should be enabled.
    */
   public void setUseController(boolean useController) {
+    if (this.useController == useController) {
+      return;
+    }
     this.useController = useController;
     if (useController) {
       controller.setPlayer(player);
@@ -144,6 +193,29 @@ public void setUseController(boolean useController) {
     }
   }
 
+  /**
+   * Returns the playback controls timeout. The playback controls are automatically hidden after
+   * this duration of time has elapsed without user input and with playback or buffering in
+   * progress.
+   *
+   * @return The timeout in milliseconds. A non-positive value will cause the controller to remain
+   *     visible indefinitely.
+   */
+  public int getControllerShowTimeoutMs() {
+    return controllerShowTimeoutMs;
+  }
+
+  /**
+   * Sets the playback controls timeout. The playback controls are automatically hidden after this
+   * duration of time has elapsed without user input and with playback or buffering in progress.
+   *
+   * @param controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause
+   *     the controller to remain visible indefinitely.
+   */
+  public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
+    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
+  }
+
   /**
    * Set the {@link PlaybackControlView.VisibilityListener}.
    *
@@ -171,15 +243,6 @@ public void setFastForwardIncrementMs(int fastForwardMs) {
     controller.setFastForwardIncrementMs(fastForwardMs);
   }
 
-  /**
-   * Sets the duration to show the playback control in milliseconds.
-   *
-   * @param showDurationMs The duration in milliseconds.
-   */
-  public void setControlShowDurationMs(int showDurationMs) {
-    controller.setShowDurationMs(showDurationMs);
-  }
-
   /**
    * Get the view onto which video is rendered. This is either a {@link SurfaceView} (default)
    * or a {@link TextureView} if the {@code use_texture_view} view attribute has been set to true.
@@ -192,21 +255,23 @@ public View getVideoSurfaceView() {
 
   @Override
   public boolean onTouchEvent(MotionEvent ev) {
-    if (useController && ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
-      if (controller.isVisible()) {
-        controller.hide();
-      } else {
-        controller.show();
-      }
+    if (!useController || player == null || ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+      return false;
+    }
+    if (controller.isVisible()) {
+      controller.hide();
+    } else {
+      maybeShowController(true);
     }
     return true;
   }
+
   @Override
   public boolean onTrackballEvent(MotionEvent ev) {
-    if (!useController) {
+    if (!useController || player == null) {
       return false;
     }
-    controller.show();
+    maybeShowController(true);
     return true;
   }
 
@@ -215,6 +280,20 @@ public boolean dispatchKeyEvent(KeyEvent event) {
     return useController ? controller.dispatchKeyEvent(event) : super.dispatchKeyEvent(event);
   }
 
+  private void maybeShowController(boolean isForced) {
+    if (!useController || player == null) {
+      return;
+    }
+    int playbackState = player.getPlaybackState();
+    boolean showIndefinitely = playbackState == ExoPlayer.STATE_IDLE
+        || playbackState == ExoPlayer.STATE_ENDED || !player.getPlayWhenReady();
+    boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
+    controller.setShowTimeoutMs(showIndefinitely ? 0 : controllerShowTimeoutMs);
+    if (isForced || showIndefinitely || wasShowingIndefinitely) {
+      controller.show();
+    }
+  }
+
   private final class ComponentListener implements SimpleExoPlayer.VideoListener,
       TextRenderer.Output, ExoPlayer.EventListener {
 
@@ -234,12 +313,12 @@ public void onVideoSizeChanged(int width, int height, int unappliedRotationDegre
     }
 
     @Override
-    public void onRenderedFirstFrame(Surface surface) {
+    public void onRenderedFirstFrame() {
       shutterView.setVisibility(GONE);
     }
 
     @Override
-    public void onVideoDisabled(DecoderCounters counters) {
+    public void onVideoTracksDisabled() {
       shutterView.setVisibility(VISIBLE);
     }
 
@@ -252,9 +331,7 @@ public void onLoadingChanged(boolean isLoading) {
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      if (useController && playbackState == ExoPlayer.STATE_ENDED) {
-        controller.show(0);
-      }
+      maybeShowController(false);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index cb4eec40f1..8c3ac77cb2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -66,9 +66,12 @@
   private CharSequence cueText;
   private Alignment cueTextAlignment;
   private float cueLine;
+  @Cue.LineType
   private int cueLineType;
+  @Cue.AnchorType
   private int cueLineAnchor;
   private float cuePosition;
+  @Cue.AnchorType
   private int cuePositionAnchor;
   private float cueSize;
   private boolean applyEmbeddedStyles;
@@ -76,6 +79,7 @@
   private int backgroundColor;
   private int windowColor;
   private int edgeColor;
+  @CaptionStyleCompat.EdgeType
   private int edgeType;
   private float textSizePx;
   private float bottomPaddingFraction;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
index 1a685ca1af..d0b18bb765 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/AssetDataSource.java
@@ -104,29 +104,35 @@ public long open(DataSpec dataSpec) throws AssetDataSourceException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws AssetDataSourceException {
-    if (bytesRemaining == 0) {
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
-    } else {
-      int bytesRead;
-      try {
-        int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
-            : (int) Math.min(bytesRemaining, readLength);
-        bytesRead = inputStream.read(buffer, offset, bytesToRead);
-      } catch (IOException e) {
-        throw new AssetDataSourceException(e);
-      }
+    }
 
-      if (bytesRead > 0) {
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          bytesRemaining -= bytesRead;
-        }
-        if (listener != null) {
-          listener.onBytesTransferred(this, bytesRead);
-        }
-      }
+    int bytesRead;
+    try {
+      int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
+          : (int) Math.min(bytesRemaining, readLength);
+      bytesRead = inputStream.read(buffer, offset, bytesToRead);
+    } catch (IOException e) {
+      throw new AssetDataSourceException(e);
+    }
 
-      return bytesRead;
+    if (bytesRead == -1) {
+      if (bytesRemaining != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
+        throw new AssetDataSourceException(new EOFException());
+      }
+      return C.RESULT_END_OF_INPUT;
+    }
+    if (bytesRemaining != C.LENGTH_UNSET) {
+      bytesRemaining -= bytesRead;
+    }
+    if (listener != null) {
+      listener.onBytesTransferred(this, bytesRead);
     }
+    return bytesRead;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
index dd787d05b9..e5311e783b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
@@ -54,15 +54,18 @@ public long open(DataSpec dataSpec) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int offset, int length) throws IOException {
-    if (bytesRemaining == 0) {
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
     }
-    length = Math.min(length, bytesRemaining);
-    System.arraycopy(data, readPosition, buffer, offset, length);
-    readPosition += length;
-    bytesRemaining -= length;
-    return length;
+
+    readLength = Math.min(readLength, bytesRemaining);
+    System.arraycopy(data, readPosition, buffer, offset, readLength);
+    readPosition += readLength;
+    bytesRemaining -= readLength;
+    return readLength;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
index 2a0ad01489..f806f47410 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java
@@ -103,29 +103,35 @@ public long open(DataSpec dataSpec) throws ContentDataSourceException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws ContentDataSourceException {
-    if (bytesRemaining == 0) {
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
-    } else {
-      int bytesRead;
-      try {
-        int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
-            : (int) Math.min(bytesRemaining, readLength);
-        bytesRead = inputStream.read(buffer, offset, bytesToRead);
-      } catch (IOException e) {
-        throw new ContentDataSourceException(e);
-      }
+    }
 
-      if (bytesRead > 0) {
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          bytesRemaining -= bytesRead;
-        }
-        if (listener != null) {
-          listener.onBytesTransferred(this, bytesRead);
-        }
-      }
+    int bytesRead;
+    try {
+      int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
+          : (int) Math.min(bytesRemaining, readLength);
+      bytesRead = inputStream.read(buffer, offset, bytesToRead);
+    } catch (IOException e) {
+      throw new ContentDataSourceException(e);
+    }
 
-      return bytesRead;
+    if (bytesRead == -1) {
+      if (bytesRemaining != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
+        throw new ContentDataSourceException(new EOFException());
+      }
+      return C.RESULT_END_OF_INPUT;
+    }
+    if (bytesRemaining != C.LENGTH_UNSET) {
+      bytesRemaining -= bytesRead;
+    }
+    if (listener != null) {
+      listener.onBytesTransferred(this, bytesRead);
     }
+    return bytesRead;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index 2b445fc05b..0ddf17cbe9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -55,14 +55,18 @@
 
   /**
    * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
-   * index {@code offset}. Blocks until at least one byte of data can be read, the end of the opened
-   * range is detected, or an exception is thrown.
+   * index {@code offset}.
+   * <p>
+   * If {@code length} is zero then 0 is returned. Otherwise, if no data is available because the
+   * end of the opened range has been reached, then {@link C#RESULT_END_OF_INPUT} is returned.
+   * Otherwise, the call will block until at least one byte of data has been read and the number of
+   * bytes read is returned.
    *
    * @param buffer The buffer into which the read data should be stored.
    * @param offset The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
-   *     range is reached.
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is avaliable
+   *     because the end of the opened range has been reached.
    * @throws IOException If an error occurs reading from the source.
    */
   int read(byte[] buffer, int offset, int readLength) throws IOException;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index 5a469e1c90..d251446976 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -16,8 +16,11 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 
 /**
@@ -25,6 +28,12 @@
  */
 public final class DataSpec {
 
+  /**
+   * The flags that apply to any request for data.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP})
+  public @interface Flags {}
   /**
    * Permits an underlying network stack to request that the server use gzip compression.
    * <p>
@@ -69,6 +78,7 @@
   /**
    * Request flags. Currently {@link #FLAG_ALLOW_GZIP} is the only supported flag.
    */
+  @Flags
   public final int flags;
 
   /**
@@ -86,7 +96,7 @@ public DataSpec(Uri uri) {
    * @param uri {@link #uri}.
    * @param flags {@link #flags}.
    */
-  public DataSpec(Uri uri, int flags) {
+  public DataSpec(Uri uri, @Flags int flags) {
     this(uri, 0, C.LENGTH_UNSET, null, flags);
   }
 
@@ -111,7 +121,7 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key) {
    * @param key {@link #key}.
    * @param flags {@link #flags}.
    */
-  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, int flags) {
+  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, @Flags int flags) {
     this(uri, absoluteStreamPosition, absoluteStreamPosition, length, key, flags);
   }
 
@@ -127,7 +137,7 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, i
    * @param flags {@link #flags}.
    */
   public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length, String key,
-      int flags) {
+      @Flags int flags) {
     this(uri, null, absoluteStreamPosition, position, length, key, flags);
   }
 
@@ -144,7 +154,7 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length
    * @param flags {@link #flags}.
    */
   public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long position, long length,
-      String key, int flags) {
+      String key, @Flags int flags) {
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNSET);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
index 5ccfa5f899..d9bd5873f0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
@@ -26,6 +26,7 @@
 
   private static final int AVAILABLE_EXTRA_CAPACITY = 100;
 
+  private final boolean trimOnReset;
   private final int individualAllocationSize;
   private final byte[] initialAllocationBlock;
   private final Allocation[] singleAllocationReleaseHolder;
@@ -38,10 +39,12 @@
   /**
    * Constructs an instance without creating any {@link Allocation}s up front.
    *
+   * @param trimOnReset Whether memory is freed when the allocator is reset. Should be true unless
+   *     the allocator will be re-used by multiple player instances.
    * @param individualAllocationSize The length of each individual {@link Allocation}.
    */
-  public DefaultAllocator(int individualAllocationSize) {
-    this(individualAllocationSize, 0);
+  public DefaultAllocator(boolean trimOnReset, int individualAllocationSize) {
+    this(trimOnReset, individualAllocationSize, 0);
   }
 
   /**
@@ -49,12 +52,16 @@ public DefaultAllocator(int individualAllocationSize) {
    * <p>
    * Note: {@link Allocation}s created up front will never be discarded by {@link #trim()}.
    *
+   * @param trimOnReset Whether memory is freed when the allocator is reset. Should be true unless
+   *     the allocator will be re-used by multiple player instances.
    * @param individualAllocationSize The length of each individual {@link Allocation}.
    * @param initialAllocationCount The number of allocations to create up front.
    */
-  public DefaultAllocator(int individualAllocationSize, int initialAllocationCount) {
+  public DefaultAllocator(boolean trimOnReset, int individualAllocationSize,
+      int initialAllocationCount) {
     Assertions.checkArgument(individualAllocationSize > 0);
     Assertions.checkArgument(initialAllocationCount >= 0);
+    this.trimOnReset = trimOnReset;
     this.individualAllocationSize = individualAllocationSize;
     this.availableCount = initialAllocationCount;
     this.availableAllocations = new Allocation[initialAllocationCount + AVAILABLE_EXTRA_CAPACITY];
@@ -70,6 +77,12 @@ public DefaultAllocator(int individualAllocationSize, int initialAllocationCount
     singleAllocationReleaseHolder = new Allocation[1];
   }
 
+  public synchronized void reset() {
+    if (trimOnReset) {
+      setTargetBufferSize(0);
+    }
+  }
+
   public synchronized void setTargetBufferSize(int targetBufferSize) {
     boolean targetBufferSizeReduced = targetBufferSize < this.targetBufferSize;
     this.targetBufferSize = targetBufferSize;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index bcb4b9d2bd..b326c41b18 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -231,10 +231,13 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
 
     // Determine the length of the data to be read, after skipping.
     if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
-      long contentLength = getContentLength(connection);
-      bytesToRead = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length
-          : contentLength != C.LENGTH_UNSET ? contentLength - bytesToSkip
-          : C.LENGTH_UNSET;
+      if (dataSpec.length != C.LENGTH_UNSET) {
+        bytesToRead = dataSpec.length;
+      } else {
+        long contentLength = getContentLength(connection);
+        bytesToRead = contentLength != C.LENGTH_UNSET ? (contentLength - bytesToSkip)
+            : C.LENGTH_UNSET;
+      }
     } else {
       // Gzip is enabled. If the server opts to use gzip then the content length in the response
       // will be that of the compressed data, which isn't what we want. Furthermore, there isn't a
@@ -410,11 +413,16 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(postBody != null);
     if (postBody != null) {
-      connection.setFixedLengthStreamingMode(postBody.length);
-      connection.connect();
-      OutputStream os = connection.getOutputStream();
-      os.write(postBody);
-      os.close();
+      connection.setRequestMethod("POST");
+      if (postBody.length == 0) {
+        connection.connect();
+      } else  {
+        connection.setFixedLengthStreamingMode(postBody.length);
+        connection.connect();
+        OutputStream os = connection.getOutputStream();
+        os.write(postBody);
+        os.close();
+      }
     } else {
       connection.connect();
     }
@@ -547,17 +555,21 @@ private void skipInternal() throws IOException {
    * @throws IOException If an error occurs reading from the source.
    */
   private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
-    readLength = bytesToRead == C.LENGTH_UNSET ? readLength
-        : (int) Math.min(readLength, bytesToRead - bytesRead);
     if (readLength == 0) {
-      // We've read all of the requested data.
-      return C.RESULT_END_OF_INPUT;
+      return 0;
+    }
+    if (bytesToRead != C.LENGTH_UNSET) {
+      long bytesRemaining = bytesToRead - bytesRead;
+      if (bytesRemaining == 0) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      readLength = (int) Math.min(readLength, bytesRemaining);
     }
 
     int read = inputStream.read(buffer, offset, readLength);
     if (read == -1) {
-      if (bytesToRead != C.LENGTH_UNSET && bytesToRead != bytesRead) {
-        // The server closed the connection having not sent sufficient data.
+      if (bytesToRead != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
         throw new EOFException();
       }
       return C.RESULT_END_OF_INPUT;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index d211cfacbd..898d2169b3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -80,7 +80,9 @@ public long open(DataSpec dataSpec) throws FileDataSourceException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws FileDataSourceException {
-    if (bytesRemaining == 0) {
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
     } else {
       int bytesRead;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index b96fe515fc..f915ee4e24 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -15,10 +15,13 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import android.support.annotation.IntDef;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.List;
 import java.util.Map;
 
@@ -57,10 +60,14 @@ public boolean evaluate(String contentType) {
    */
   class HttpDataSourceException extends IOException {
 
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({TYPE_OPEN, TYPE_READ, TYPE_CLOSE})
+    public @interface Type {}
     public static final int TYPE_OPEN = 1;
     public static final int TYPE_READ = 2;
     public static final int TYPE_CLOSE = 3;
 
+    @Type
     public final int type;
 
     /**
@@ -68,25 +75,26 @@ public boolean evaluate(String contentType) {
      */
     public final DataSpec dataSpec;
 
-    public HttpDataSourceException(DataSpec dataSpec, int type) {
+    public HttpDataSourceException(DataSpec dataSpec, @Type int type) {
       super();
       this.dataSpec = dataSpec;
       this.type = type;
     }
 
-    public HttpDataSourceException(String message, DataSpec dataSpec, int type) {
+    public HttpDataSourceException(String message, DataSpec dataSpec, @Type int type) {
       super(message);
       this.dataSpec = dataSpec;
       this.type = type;
     }
 
-    public HttpDataSourceException(IOException cause, DataSpec dataSpec, int type) {
+    public HttpDataSourceException(IOException cause, DataSpec dataSpec, @Type int type) {
       super(cause);
       this.dataSpec = dataSpec;
       this.type = type;
     }
 
-    public HttpDataSourceException(String message, IOException cause, DataSpec dataSpec, int type) {
+    public HttpDataSourceException(String message, IOException cause, DataSpec dataSpec,
+        @Type int type) {
       super(message, cause);
       this.dataSpec = dataSpec;
       this.type = type;
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 74c38ba31e..3a9ea0cff0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -132,29 +132,35 @@ public long open(DataSpec dataSpec) throws RawResourceDataSourceException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws RawResourceDataSourceException {
-    if (bytesRemaining == 0) {
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
-    } else {
-      int bytesRead;
-      try {
-        int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
-            : (int) Math.min(bytesRemaining, readLength);
-        bytesRead = inputStream.read(buffer, offset, bytesToRead);
-      } catch (IOException e) {
-        throw new RawResourceDataSourceException(e);
-      }
+    }
 
-      if (bytesRead > 0) {
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          bytesRemaining -= bytesRead;
-        }
-        if (listener != null) {
-          listener.onBytesTransferred(this, bytesRead);
-        }
-      }
+    int bytesRead;
+    try {
+      int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
+          : (int) Math.min(bytesRemaining, readLength);
+      bytesRead = inputStream.read(buffer, offset, bytesToRead);
+    } catch (IOException e) {
+      throw new RawResourceDataSourceException(e);
+    }
 
-      return bytesRead;
+    if (bytesRead == -1) {
+      if (bytesRemaining != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
+        throw new RawResourceDataSourceException(new EOFException());
+      }
+      return C.RESULT_END_OF_INPUT;
+    }
+    if (bytesRemaining != C.LENGTH_UNSET) {
+      bytesRemaining -= bytesRead;
+    }
+    if (listener != null) {
+      listener.onBytesTransferred(this, bytesRead);
     }
+    return bytesRead;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
index db5decb55d..68a04d9182 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
@@ -129,6 +129,10 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceException {
+    if (readLength == 0) {
+      return 0;
+    }
+
     if (packetRemaining == 0) {
       // We've read all of the data from the current packet. Get another.
       try {
@@ -136,7 +140,6 @@ public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceE
       } catch (IOException e) {
         throw new UdpDataSourceException(e);
       }
-
       packetRemaining = packet.getLength();
       if (listener != null) {
         listener.onBytesTransferred(this, packetRemaining);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 0cd7d54564..727eb068ce 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.net.Uri;
+import android.support.annotation.IntDef;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
@@ -27,6 +28,8 @@
 import com.google.android.exoplayer2.upstream.cache.CacheDataSink.CacheDataSinkException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
@@ -43,6 +46,13 @@
    */
   public static final long DEFAULT_MAX_CACHE_FILE_SIZE = 2 * 1024 * 1024;
 
+  /**
+   * Flags controlling the cache's behavior.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_BLOCK_ON_CACHE, FLAG_IGNORE_CACHE_ON_ERROR,
+      FLAG_CACHE_UNBOUNDED_REQUESTS})
+  public @interface Flags {}
   /**
    * A flag indicating whether we will block reads if the cache key is locked. If this flag is
    * set, then we will read from upstream if the cache key is locked.
@@ -106,7 +116,7 @@
    * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
    * reading and writing the cache and with {@link #DEFAULT_MAX_CACHE_FILE_SIZE}.
    */
-  public CacheDataSource(Cache cache, DataSource upstream, int flags) {
+  public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags) {
     this(cache, upstream, flags, DEFAULT_MAX_CACHE_FILE_SIZE);
   }
 
@@ -123,7 +133,8 @@ public CacheDataSource(Cache cache, DataSource upstream, int flags) {
    *     exceeds this value, then the data will be fragmented into multiple cache files. The
    *     finer-grained this is the finer-grained the eviction policy can be.
    */
-  public CacheDataSource(Cache cache, DataSource upstream, int flags, long maxCacheFileSize) {
+  public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
+      long maxCacheFileSize) {
     this(cache, upstream, new FileDataSource(), new CacheDataSink(cache, maxCacheFileSize),
         flags, null);
   }
@@ -142,7 +153,7 @@ public CacheDataSource(Cache cache, DataSource upstream, int flags, long maxCach
    * @param eventListener An optional {@link EventListener} to receive events.
    */
   public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
-      DataSink cacheWriteDataSink, int flags, EventListener eventListener) {
+      DataSink cacheWriteDataSink, @Flags int flags, EventListener eventListener) {
     this.cache = cache;
     this.cacheReadDataSource = cacheReadDataSource;
     this.blockOnCache = (flags & FLAG_BLOCK_ON_CACHE) != 0;
@@ -183,12 +194,15 @@ public long open(DataSpec dataSpec) throws IOException {
   }
 
   @Override
-  public int read(byte[] buffer, int offset, int max) throws IOException {
+  public int read(byte[] buffer, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    }
     if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
     }
     try {
-      int bytesRead = currentDataSource.read(buffer, offset, max);
+      int bytesRead = currentDataSource.read(buffer, offset, readLength);
       if (bytesRead >= 0) {
         if (currentDataSource == cacheReadDataSource) {
           totalCachedBytesRead += bytesRead;
@@ -207,7 +221,7 @@ public int read(byte[] buffer, int offset, int max) throws IOException {
         closeCurrentSource();
         if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
           if (openNextSource(false)) {
-            return read(buffer, offset, max);
+            return read(buffer, offset, readLength);
           }
         }
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index a678d9487b..4776e4d008 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.text.TextUtils;
+import com.google.android.exoplayer2.C;
+
 /**
  * Defines common MIME types and helper methods.
  */
@@ -61,7 +64,8 @@
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
-  public static final String APPLICATION_EIA608 = BASE_TYPE_APPLICATION + "/eia-608";
+  public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
+  public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
   public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
@@ -191,6 +195,44 @@ public static String getMediaMimeType(String codec) {
     return null;
   }
 
+  /**
+   * Returns the {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
+   * {@link C#TRACK_TYPE_UNKNOWN} if the mime type is not known or the mapping cannot be
+   * established.
+   *
+   * @param mimeType The mimeType.
+   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
+   */
+  public static int getTrackType(String mimeType) {
+    if (TextUtils.isEmpty(mimeType)) {
+      return C.TRACK_TYPE_UNKNOWN;
+    } else if (isAudio(mimeType)) {
+      return C.TRACK_TYPE_AUDIO;
+    } else if (isVideo(mimeType)) {
+      return C.TRACK_TYPE_VIDEO;
+    } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
+        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
+        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
+        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
+        || APPLICATION_PGS.equals(mimeType)) {
+      return C.TRACK_TYPE_TEXT;
+    } else if (APPLICATION_ID3.equals(mimeType)) {
+      return C.TRACK_TYPE_METADATA;
+    } else {
+      return C.TRACK_TYPE_UNKNOWN;
+    }
+  }
+
+  /**
+   * Equivalent to {@code getTrackType(getMediaMimeType(codec))}.
+   *
+   * @param codec The codec.
+   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified codec.
+   */
+  public static int getTrackTypeOfCodec(String codec) {
+    return getTrackType(getMediaMimeType(codec));
+  }
+
   /**
    * Returns the top-level type of {@code mimeType}.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index a499dc8012..b306fbf76e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -35,17 +35,17 @@
   public ParsableByteArray() {}
 
   /**
-   * Creates a new instance with {@code length} bytes.
+   * Creates a new instance with {@code limit} bytes and sets the limit.
    *
-   * @param length The length of the array.
+   * @param limit The limit to set.
    */
-  public ParsableByteArray(int length) {
-    this.data = new byte[length];
-    limit = data.length;
+  public ParsableByteArray(int limit) {
+    this.data = new byte[limit];
+    this.limit = limit;
   }
 
   /**
-   * Creates a new instance wrapping {@code data}.
+   * Creates a new instance wrapping {@code data}, and sets the limit to {@code data.length}.
    *
    * @param data The array to wrap.
    */
@@ -58,7 +58,7 @@ public ParsableByteArray(byte[] data) {
    * Creates a new instance that wraps an existing array.
    *
    * @param data The data to wrap.
-   * @param limit The limit.
+   * @param limit The limit to set.
    */
   public ParsableByteArray(byte[] data, int limit) {
     this.data = data;
@@ -79,7 +79,7 @@ public void reset(int limit) {
    * Updates the instance to wrap {@code data}, and resets the position to zero.
    *
    * @param data The array to wrap.
-   * @param limit The limit.
+   * @param limit The limit to set.
    */
   public void reset(byte[] data, int limit) {
     this.data = data;
@@ -194,6 +194,13 @@ public void readBytes(ByteBuffer buffer, int length) {
     position += length;
   }
 
+  /**
+   * Peeks at the next byte as an unsigned value.
+   */
+  public int peekUnsignedByte() {
+    return (data[position] & 0xFF);
+  }
+
   /**
    * Reads the next byte as an unsigned value.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
index 6e11c43db1..c4505fd8b9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -88,27 +88,6 @@
    */
   public static final String MODEL = Build.MODEL;
 
-  /**
-   * Value returned by {@link #inferContentType(String)} for DASH manifests.
-   */
-  public static final int TYPE_DASH = 0;
-
-  /**
-   * Value returned by {@link #inferContentType(String)} for Smooth Streaming manifests.
-   */
-  public static final int TYPE_SS = 1;
-
-  /**
-   * Value returned by {@link #inferContentType(String)} for HLS manifests.
-   */
-  public static final int TYPE_HLS = 2;
-
-  /**
-   * Value returned by {@link #inferContentType(String)} for files other than DASH, HLS or Smooth
-   * Streaming manifests.
-   */
-  public static final int TYPE_OTHER = 3;
-
   private static final String TAG = "Util";
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
@@ -712,6 +691,7 @@ public static String getUserAgent(Context context, String applicationName) {
    *     {@link C#ENCODING_PCM_32BIT}. If the bit depth is unsupported then
    *     {@link C#ENCODING_INVALID} is returned.
    */
+  @C.PcmEncoding
   public static int getPcmEncoding(int bitDepth) {
     switch (bitDepth) {
       case 8:
@@ -731,19 +711,20 @@ public static int getPcmEncoding(int bitDepth) {
    * Makes a best guess to infer the type from a file name.
    *
    * @param fileName Name of the file. It can include the path of the file.
-   * @return One of {@link #TYPE_DASH}, {@link #TYPE_SS}, {@link #TYPE_HLS} or {@link #TYPE_OTHER}.
+   * @return The content type.
    */
+  @C.ContentType
   public static int inferContentType(String fileName) {
     if (fileName == null) {
-      return TYPE_OTHER;
+      return C.TYPE_OTHER;
     } else if (fileName.endsWith(".mpd")) {
-      return TYPE_DASH;
+      return C.TYPE_DASH;
     } else if (fileName.endsWith(".ism") || fileName.endsWith(".isml")) {
-      return TYPE_SS;
+      return C.TYPE_SS;
     } else if (fileName.endsWith(".m3u8")) {
-      return TYPE_HLS;
+      return C.TYPE_HLS;
     } else {
-      return TYPE_OTHER;
+      return C.TYPE_OTHER;
     }
   }
 
diff --git a/library/src/main/res/drawable-hdpi/ic_media_ff.png b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_ff.png
rename to library/src/main/res/drawable-hdpi/exo_controls_fastforward.png
diff --git a/library/src/main/res/drawable-hdpi/ic_media_next.png b/library/src/main/res/drawable-hdpi/exo_controls_next.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_next.png
rename to library/src/main/res/drawable-hdpi/exo_controls_next.png
diff --git a/library/src/main/res/drawable-hdpi/ic_media_pause.png b/library/src/main/res/drawable-hdpi/exo_controls_pause.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_pause.png
rename to library/src/main/res/drawable-hdpi/exo_controls_pause.png
diff --git a/library/src/main/res/drawable-hdpi/ic_media_play.png b/library/src/main/res/drawable-hdpi/exo_controls_play.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_play.png
rename to library/src/main/res/drawable-hdpi/exo_controls_play.png
diff --git a/library/src/main/res/drawable-hdpi/ic_media_previous.png b/library/src/main/res/drawable-hdpi/exo_controls_previous.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_previous.png
rename to library/src/main/res/drawable-hdpi/exo_controls_previous.png
diff --git a/library/src/main/res/drawable-hdpi/ic_media_rew.png b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png
similarity index 100%
rename from library/src/main/res/drawable-hdpi/ic_media_rew.png
rename to library/src/main/res/drawable-hdpi/exo_controls_rewind.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_ff.png b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_ff.png
rename to library/src/main/res/drawable-ldpi/exo_controls_fastforward.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_next.png b/library/src/main/res/drawable-ldpi/exo_controls_next.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_next.png
rename to library/src/main/res/drawable-ldpi/exo_controls_next.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_pause.png b/library/src/main/res/drawable-ldpi/exo_controls_pause.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_pause.png
rename to library/src/main/res/drawable-ldpi/exo_controls_pause.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_play.png b/library/src/main/res/drawable-ldpi/exo_controls_play.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_play.png
rename to library/src/main/res/drawable-ldpi/exo_controls_play.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_previous.png b/library/src/main/res/drawable-ldpi/exo_controls_previous.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_previous.png
rename to library/src/main/res/drawable-ldpi/exo_controls_previous.png
diff --git a/library/src/main/res/drawable-ldpi/ic_media_rew.png b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png
similarity index 100%
rename from library/src/main/res/drawable-ldpi/ic_media_rew.png
rename to library/src/main/res/drawable-ldpi/exo_controls_rewind.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_ff.png b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_ff.png
rename to library/src/main/res/drawable-mdpi/exo_controls_fastforward.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_next.png b/library/src/main/res/drawable-mdpi/exo_controls_next.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_next.png
rename to library/src/main/res/drawable-mdpi/exo_controls_next.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_pause.png b/library/src/main/res/drawable-mdpi/exo_controls_pause.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_pause.png
rename to library/src/main/res/drawable-mdpi/exo_controls_pause.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_play.png b/library/src/main/res/drawable-mdpi/exo_controls_play.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_play.png
rename to library/src/main/res/drawable-mdpi/exo_controls_play.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_previous.png b/library/src/main/res/drawable-mdpi/exo_controls_previous.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_previous.png
rename to library/src/main/res/drawable-mdpi/exo_controls_previous.png
diff --git a/library/src/main/res/drawable-mdpi/ic_media_rew.png b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png
similarity index 100%
rename from library/src/main/res/drawable-mdpi/ic_media_rew.png
rename to library/src/main/res/drawable-mdpi/exo_controls_rewind.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_ff.png b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_ff.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_next.png b/library/src/main/res/drawable-xhdpi/exo_controls_next.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_next.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_next.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_pause.png b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_pause.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_pause.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_play.png b/library/src/main/res/drawable-xhdpi/exo_controls_play.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_play.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_play.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_previous.png b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_previous.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_previous.png
diff --git a/library/src/main/res/drawable-xhdpi/ic_media_rew.png b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png
similarity index 100%
rename from library/src/main/res/drawable-xhdpi/ic_media_rew.png
rename to library/src/main/res/drawable-xhdpi/exo_controls_rewind.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_ff.png b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_ff.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_next.png b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_next.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_next.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_pause.png b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_pause.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_pause.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_play.png b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_play.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_play.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_previous.png b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_previous.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_previous.png
diff --git a/library/src/main/res/drawable-xxhdpi/ic_media_rew.png b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png
similarity index 100%
rename from library/src/main/res/drawable-xxhdpi/ic_media_rew.png
rename to library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png
diff --git a/library/src/main/res/layout/playback_control_view.xml b/library/src/main/res/layout/exo_playback_control_view.xml
similarity index 82%
rename from library/src/main/res/layout/playback_control_view.xml
rename to library/src/main/res/layout/exo_playback_control_view.xml
index 21194ef54f..a0be4a8149 100644
--- a/library/src/main/res/layout/playback_control_view.xml
+++ b/library/src/main/res/layout/exo_playback_control_view.xml
@@ -29,23 +29,23 @@
     android:orientation="horizontal">
 
     <ImageButton android:id="@+id/prev"
-      android:contentDescription="@string/prev_description"
-      style="@style/MediaButton.Previous"/>
+      android:contentDescription="@string/exo_controls_previous_description"
+      style="@style/ExoMediaButton.Previous"/>
 
     <ImageButton android:id="@+id/rew"
-      android:contentDescription="@string/rew_description"
-      style="@style/MediaButton.Rew"/>
+      android:contentDescription="@string/exo_controls_rewind_description"
+      style="@style/ExoMediaButton.Rewind"/>
 
     <ImageButton android:id="@+id/play"
-      style="@style/MediaButton"/>
+      style="@style/ExoMediaButton"/>
 
     <ImageButton android:id="@+id/ffwd"
-      android:contentDescription="@string/ffw_description"
-      style="@style/MediaButton.Ffwd"/>
+      android:contentDescription="@string/exo_controls_fastforward_description"
+      style="@style/ExoMediaButton.FastForward"/>
 
     <ImageButton android:id="@+id/next"
-      android:contentDescription="@string/prev_description"
-      style="@style/MediaButton.Next"/>
+      android:contentDescription="@string/exo_controls_previous_description"
+      style="@style/ExoMediaButton.Next"/>
 
   </LinearLayout>
 
diff --git a/library/src/main/res/layout/exoplayer_video_view.xml b/library/src/main/res/layout/exo_simple_player_view.xml
similarity index 97%
rename from library/src/main/res/layout/exoplayer_video_view.xml
rename to library/src/main/res/layout/exo_simple_player_view.xml
index e1745abcff..99945b8d25 100644
--- a/library/src/main/res/layout/exoplayer_video_view.xml
+++ b/library/src/main/res/layout/exo_simple_player_view.xml
@@ -22,17 +22,17 @@
       android:layout_height="match_parent"
       android:layout_gravity="center">
 
+    <View android:id="@+id/shutter"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:background="@android:color/black"/>
+
     <com.google.android.exoplayer2.ui.SubtitleView android:id="@+id/subtitles"
         android:layout_width="match_parent"
         android:layout_height="match_parent"/>
 
   </com.google.android.exoplayer2.ui.AspectRatioFrameLayout>
 
-  <View android:id="@+id/shutter"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      android:background="@android:color/black"/>
-
   <com.google.android.exoplayer2.ui.PlaybackControlView android:id="@+id/control"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
diff --git a/library/src/main/res/values-af/strings.xml b/library/src/main/res/values-af/strings.xml
index 2ce5c415de..9f1bce53d9 100644
--- a/library/src/main/res/values-af/strings.xml
+++ b/library/src/main/res/values-af/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Vorige snit"</string>
-  <string name="next_description">"Volgende snit"</string>
-  <string name="pause_description">"Wag"</string>
-  <string name="play_description">"Speel"</string>
-  <string name="stop_description">"Stop"</string>
-  <string name="rew_description">"Spoel terug"</string>
-  <string name="ffw_description">"Vinnig vorentoe"</string>
+  <string name="exo_controls_previous_description">"Vorige snit"</string>
+  <string name="exo_controls_next_description">"Volgende snit"</string>
+  <string name="exo_controls_pause_description">"Wag"</string>
+  <string name="exo_controls_play_description">"Speel"</string>
+  <string name="exo_controls_stop_description">"Stop"</string>
+  <string name="exo_controls_rewind_description">"Spoel terug"</string>
+  <string name="exo_controls_fastforward_description">"Vinnig vorentoe"</string>
 </resources>
diff --git a/library/src/main/res/values-am/strings.xml b/library/src/main/res/values-am/strings.xml
index 39591a86f3..f06c2a664e 100644
--- a/library/src/main/res/values-am/strings.xml
+++ b/library/src/main/res/values-am/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"ቀዳሚ ትራክ"</string>
-  <string name="next_description">"ቀጣይ ትራክ"</string>
-  <string name="pause_description">"ለአፍታ አቁም"</string>
-  <string name="play_description">"አጫውት"</string>
-  <string name="stop_description">"አቁም"</string>
-  <string name="rew_description">"ወደኋላ አጠንጥን"</string>
-  <string name="ffw_description">"በፍጥነት አሳልፍ"</string>
+  <string name="exo_controls_previous_description">"ቀዳሚ ትራክ"</string>
+  <string name="exo_controls_next_description">"ቀጣይ ትራክ"</string>
+  <string name="exo_controls_pause_description">"ለአፍታ አቁም"</string>
+  <string name="exo_controls_play_description">"አጫውት"</string>
+  <string name="exo_controls_stop_description">"አቁም"</string>
+  <string name="exo_controls_rewind_description">"ወደኋላ አጠንጥን"</string>
+  <string name="exo_controls_fastforward_description">"በፍጥነት አሳልፍ"</string>
 </resources>
diff --git a/library/src/main/res/values-ar/strings.xml b/library/src/main/res/values-ar/strings.xml
index 96b7772ba1..a40c961bf7 100644
--- a/library/src/main/res/values-ar/strings.xml
+++ b/library/src/main/res/values-ar/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"المقطع الصوتي السابق"</string>
-  <string name="next_description">"المقطع الصوتي التالي"</string>
-  <string name="pause_description">"إيقاف مؤقت"</string>
-  <string name="play_description">"تشغيل"</string>
-  <string name="stop_description">"إيقاف"</string>
-  <string name="rew_description">"إرجاع"</string>
-  <string name="ffw_description">"تقديم سريع"</string>
+  <string name="exo_controls_previous_description">"المقطع الصوتي السابق"</string>
+  <string name="exo_controls_next_description">"المقطع الصوتي التالي"</string>
+  <string name="exo_controls_pause_description">"إيقاف مؤقت"</string>
+  <string name="exo_controls_play_description">"تشغيل"</string>
+  <string name="exo_controls_stop_description">"إيقاف"</string>
+  <string name="exo_controls_rewind_description">"إرجاع"</string>
+  <string name="exo_controls_fastforward_description">"تقديم سريع"</string>
 </resources>
diff --git a/library/src/main/res/values-az-rAZ/strings.xml b/library/src/main/res/values-az-rAZ/strings.xml
index aa85203b4d..7b3b9366b5 100644
--- a/library/src/main/res/values-az-rAZ/strings.xml
+++ b/library/src/main/res/values-az-rAZ/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Öncəki trek"</string>
-  <string name="next_description">"Növbəti trek"</string>
-  <string name="pause_description">"Pauza"</string>
-  <string name="play_description">"Oyun"</string>
-  <string name="stop_description">"Dayandır"</string>
-  <string name="rew_description">"Geri sarıma"</string>
-  <string name="ffw_description">"Sürətlə irəli"</string>
+  <string name="exo_controls_previous_description">"Öncəki trek"</string>
+  <string name="exo_controls_next_description">"Növbəti trek"</string>
+  <string name="exo_controls_pause_description">"Pauza"</string>
+  <string name="exo_controls_play_description">"Oyun"</string>
+  <string name="exo_controls_stop_description">"Dayandır"</string>
+  <string name="exo_controls_rewind_description">"Geri sarıma"</string>
+  <string name="exo_controls_fastforward_description">"Sürətlə irəli"</string>
 </resources>
diff --git a/library/src/main/res/values-b+sr+Latn/strings.xml b/library/src/main/res/values-b+sr+Latn/strings.xml
index 5798cfb96d..b5fdd74402 100644
--- a/library/src/main/res/values-b+sr+Latn/strings.xml
+++ b/library/src/main/res/values-b+sr+Latn/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Prethodna pesma"</string>
-  <string name="next_description">"Sledeća pesma"</string>
-  <string name="pause_description">"Pauza"</string>
-  <string name="play_description">"Pusti"</string>
-  <string name="stop_description">"Zaustavi"</string>
-  <string name="rew_description">"Premotaj unazad"</string>
-  <string name="ffw_description">"Premotaj unapred"</string>
+  <string name="exo_controls_previous_description">"Prethodna pesma"</string>
+  <string name="exo_controls_next_description">"Sledeća pesma"</string>
+  <string name="exo_controls_pause_description">"Pauza"</string>
+  <string name="exo_controls_play_description">"Pusti"</string>
+  <string name="exo_controls_stop_description">"Zaustavi"</string>
+  <string name="exo_controls_rewind_description">"Premotaj unazad"</string>
+  <string name="exo_controls_fastforward_description">"Premotaj unapred"</string>
 </resources>
diff --git a/library/src/main/res/values-be-rBY/strings.xml b/library/src/main/res/values-be-rBY/strings.xml
index 7c77eef2f2..890c23ebd5 100644
--- a/library/src/main/res/values-be-rBY/strings.xml
+++ b/library/src/main/res/values-be-rBY/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Папярэдні трэк"</string>
-  <string name="next_description">"Наступны трэк"</string>
-  <string name="pause_description">"Прыпыніць"</string>
-  <string name="play_description">"Прайграць"</string>
-  <string name="stop_description">"Спыніць"</string>
-  <string name="rew_description">"Перамотка назад"</string>
-  <string name="ffw_description">"Перамотка ўперад"</string>
+  <string name="exo_controls_previous_description">"Папярэдні трэк"</string>
+  <string name="exo_controls_next_description">"Наступны трэк"</string>
+  <string name="exo_controls_pause_description">"Прыпыніць"</string>
+  <string name="exo_controls_play_description">"Прайграць"</string>
+  <string name="exo_controls_stop_description">"Спыніць"</string>
+  <string name="exo_controls_rewind_description">"Перамотка назад"</string>
+  <string name="exo_controls_fastforward_description">"Перамотка ўперад"</string>
 </resources>
diff --git a/library/src/main/res/values-bg/strings.xml b/library/src/main/res/values-bg/strings.xml
index 2f771368c4..30b905fb8e 100644
--- a/library/src/main/res/values-bg/strings.xml
+++ b/library/src/main/res/values-bg/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Предишен запис"</string>
-  <string name="next_description">"Следващ запис"</string>
-  <string name="pause_description">"Пауза"</string>
-  <string name="play_description">"Пускане"</string>
-  <string name="stop_description">"Спиране"</string>
-  <string name="rew_description">"Превъртане назад"</string>
-  <string name="ffw_description">"Превъртане напред"</string>
+  <string name="exo_controls_previous_description">"Предишен запис"</string>
+  <string name="exo_controls_next_description">"Следващ запис"</string>
+  <string name="exo_controls_pause_description">"Пауза"</string>
+  <string name="exo_controls_play_description">"Пускане"</string>
+  <string name="exo_controls_stop_description">"Спиране"</string>
+  <string name="exo_controls_rewind_description">"Превъртане назад"</string>
+  <string name="exo_controls_fastforward_description">"Превъртане напред"</string>
 </resources>
diff --git a/library/src/main/res/values-bn-rBD/strings.xml b/library/src/main/res/values-bn-rBD/strings.xml
index 7140ab7f8d..ca5d9461d3 100644
--- a/library/src/main/res/values-bn-rBD/strings.xml
+++ b/library/src/main/res/values-bn-rBD/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"পূর্ববর্তী ট্র্যাক"</string>
-  <string name="next_description">"পরবর্তী ট্র্যাক"</string>
-  <string name="pause_description">"বিরাম দিন"</string>
-  <string name="play_description">"প্লে করুন"</string>
-  <string name="stop_description">"থামান"</string>
-  <string name="rew_description">"গুটিয়ে নিন"</string>
-  <string name="ffw_description">"দ্রুত সামনে এগোন"</string>
+  <string name="exo_controls_previous_description">"পূর্ববর্তী ট্র্যাক"</string>
+  <string name="exo_controls_next_description">"পরবর্তী ট্র্যাক"</string>
+  <string name="exo_controls_pause_description">"বিরাম দিন"</string>
+  <string name="exo_controls_play_description">"প্লে করুন"</string>
+  <string name="exo_controls_stop_description">"থামান"</string>
+  <string name="exo_controls_rewind_description">"গুটিয়ে নিন"</string>
+  <string name="exo_controls_fastforward_description">"দ্রুত সামনে এগোন"</string>
 </resources>
diff --git a/library/src/main/res/values-bs-rBA/strings.xml b/library/src/main/res/values-bs-rBA/strings.xml
index 0f578946e6..9cb0ca4d76 100644
--- a/library/src/main/res/values-bs-rBA/strings.xml
+++ b/library/src/main/res/values-bs-rBA/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Prethodna numera"</string>
-  <string name="next_description">"Sljedeća numera"</string>
-  <string name="pause_description">"Pauziraj"</string>
-  <string name="play_description">"Reproduciraj"</string>
-  <string name="stop_description">"Zaustavi"</string>
-  <string name="rew_description">"Premotaj"</string>
-  <string name="ffw_description">"Ubrzaj"</string>
+  <string name="exo_controls_previous_description">"Prethodna numera"</string>
+  <string name="exo_controls_next_description">"Sljedeća numera"</string>
+  <string name="exo_controls_pause_description">"Pauziraj"</string>
+  <string name="exo_controls_play_description">"Reproduciraj"</string>
+  <string name="exo_controls_stop_description">"Zaustavi"</string>
+  <string name="exo_controls_rewind_description">"Premotaj"</string>
+  <string name="exo_controls_fastforward_description">"Ubrzaj"</string>
 </resources>
diff --git a/library/src/main/res/values-ca/strings.xml b/library/src/main/res/values-ca/strings.xml
index 03ea1f0790..0816c76b12 100644
--- a/library/src/main/res/values-ca/strings.xml
+++ b/library/src/main/res/values-ca/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Ruta anterior"</string>
-  <string name="next_description">"Ruta següent"</string>
-  <string name="pause_description">"Posa en pausa"</string>
-  <string name="play_description">"Reprodueix"</string>
-  <string name="stop_description">"Atura"</string>
-  <string name="rew_description">"Rebobina"</string>
-  <string name="ffw_description">"Avança ràpidament"</string>
+  <string name="exo_controls_previous_description">"Ruta anterior"</string>
+  <string name="exo_controls_next_description">"Ruta següent"</string>
+  <string name="exo_controls_pause_description">"Posa en pausa"</string>
+  <string name="exo_controls_play_description">"Reprodueix"</string>
+  <string name="exo_controls_stop_description">"Atura"</string>
+  <string name="exo_controls_rewind_description">"Rebobina"</string>
+  <string name="exo_controls_fastforward_description">"Avança ràpidament"</string>
 </resources>
diff --git a/library/src/main/res/values-cs/strings.xml b/library/src/main/res/values-cs/strings.xml
index eb28c8d756..22cff4041e 100644
--- a/library/src/main/res/values-cs/strings.xml
+++ b/library/src/main/res/values-cs/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Předchozí skladba"</string>
-  <string name="next_description">"Další skladba"</string>
-  <string name="pause_description">"Pozastavit"</string>
-  <string name="play_description">"Přehrát"</string>
-  <string name="stop_description">"Zastavit"</string>
-  <string name="rew_description">"Přetočit zpět"</string>
-  <string name="ffw_description">"Přetočit vpřed"</string>
+  <string name="exo_controls_previous_description">"Předchozí skladba"</string>
+  <string name="exo_controls_next_description">"Další skladba"</string>
+  <string name="exo_controls_pause_description">"Pozastavit"</string>
+  <string name="exo_controls_play_description">"Přehrát"</string>
+  <string name="exo_controls_stop_description">"Zastavit"</string>
+  <string name="exo_controls_rewind_description">"Přetočit zpět"</string>
+  <string name="exo_controls_fastforward_description">"Přetočit vpřed"</string>
 </resources>
diff --git a/library/src/main/res/values-da/strings.xml b/library/src/main/res/values-da/strings.xml
index 04d64f9632..a6710bea50 100644
--- a/library/src/main/res/values-da/strings.xml
+++ b/library/src/main/res/values-da/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Forrige nummer"</string>
-  <string name="next_description">"Næste nummer"</string>
-  <string name="pause_description">"Pause"</string>
-  <string name="play_description">"Afspil"</string>
-  <string name="stop_description">"Stop"</string>
-  <string name="rew_description">"Spol tilbage"</string>
-  <string name="ffw_description">"Spol frem"</string>
+  <string name="exo_controls_previous_description">"Forrige nummer"</string>
+  <string name="exo_controls_next_description">"Næste nummer"</string>
+  <string name="exo_controls_pause_description">"Pause"</string>
+  <string name="exo_controls_play_description">"Afspil"</string>
+  <string name="exo_controls_stop_description">"Stop"</string>
+  <string name="exo_controls_rewind_description">"Spol tilbage"</string>
+  <string name="exo_controls_fastforward_description">"Spol frem"</string>
 </resources>
diff --git a/library/src/main/res/values-de/strings.xml b/library/src/main/res/values-de/strings.xml
index 63ebd19301..cdfd2d4baf 100644
--- a/library/src/main/res/values-de/strings.xml
+++ b/library/src/main/res/values-de/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Vorheriger Titel"</string>
-  <string name="next_description">"Nächster Titel"</string>
-  <string name="pause_description">"Pausieren"</string>
-  <string name="play_description">"Wiedergabe"</string>
-  <string name="stop_description">"Beenden"</string>
-  <string name="rew_description">"Zurückspulen"</string>
-  <string name="ffw_description">"Vorspulen"</string>
+  <string name="exo_controls_previous_description">"Vorheriger Titel"</string>
+  <string name="exo_controls_next_description">"Nächster Titel"</string>
+  <string name="exo_controls_pause_description">"Pausieren"</string>
+  <string name="exo_controls_play_description">"Wiedergabe"</string>
+  <string name="exo_controls_stop_description">"Beenden"</string>
+  <string name="exo_controls_rewind_description">"Zurückspulen"</string>
+  <string name="exo_controls_fastforward_description">"Vorspulen"</string>
 </resources>
diff --git a/library/src/main/res/values-el/strings.xml b/library/src/main/res/values-el/strings.xml
index f1744519c4..1e11df3b14 100644
--- a/library/src/main/res/values-el/strings.xml
+++ b/library/src/main/res/values-el/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Προηγούμενο κομμάτι"</string>
-  <string name="next_description">"Επόμενο κομμάτι"</string>
-  <string name="pause_description">"Παύση"</string>
-  <string name="play_description">"Αναπαραγωγή"</string>
-  <string name="stop_description">"Διακοπή"</string>
-  <string name="rew_description">"Επαναφορά"</string>
-  <string name="ffw_description">"Γρήγορη προώθηση"</string>
+  <string name="exo_controls_previous_description">"Προηγούμενο κομμάτι"</string>
+  <string name="exo_controls_next_description">"Επόμενο κομμάτι"</string>
+  <string name="exo_controls_pause_description">"Παύση"</string>
+  <string name="exo_controls_play_description">"Αναπαραγωγή"</string>
+  <string name="exo_controls_stop_description">"Διακοπή"</string>
+  <string name="exo_controls_rewind_description">"Επαναφορά"</string>
+  <string name="exo_controls_fastforward_description">"Γρήγορη προώθηση"</string>
 </resources>
diff --git a/library/src/main/res/values-en-rAU/strings.xml b/library/src/main/res/values-en-rAU/strings.xml
index a89377fc1d..5077cf2b94 100644
--- a/library/src/main/res/values-en-rAU/strings.xml
+++ b/library/src/main/res/values-en-rAU/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Previous track"</string>
-  <string name="next_description">"Next track"</string>
-  <string name="pause_description">"Pause"</string>
-  <string name="play_description">"Play"</string>
-  <string name="stop_description">"Stop"</string>
-  <string name="rew_description">"Rewind"</string>
-  <string name="ffw_description">"Fast-forward"</string>
+  <string name="exo_controls_previous_description">"Previous track"</string>
+  <string name="exo_controls_next_description">"Next track"</string>
+  <string name="exo_controls_pause_description">"Pause"</string>
+  <string name="exo_controls_play_description">"Play"</string>
+  <string name="exo_controls_stop_description">"Stop"</string>
+  <string name="exo_controls_rewind_description">"Rewind"</string>
+  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
 </resources>
diff --git a/library/src/main/res/values-en-rGB/strings.xml b/library/src/main/res/values-en-rGB/strings.xml
index a89377fc1d..5077cf2b94 100644
--- a/library/src/main/res/values-en-rGB/strings.xml
+++ b/library/src/main/res/values-en-rGB/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Previous track"</string>
-  <string name="next_description">"Next track"</string>
-  <string name="pause_description">"Pause"</string>
-  <string name="play_description">"Play"</string>
-  <string name="stop_description">"Stop"</string>
-  <string name="rew_description">"Rewind"</string>
-  <string name="ffw_description">"Fast-forward"</string>
+  <string name="exo_controls_previous_description">"Previous track"</string>
+  <string name="exo_controls_next_description">"Next track"</string>
+  <string name="exo_controls_pause_description">"Pause"</string>
+  <string name="exo_controls_play_description">"Play"</string>
+  <string name="exo_controls_stop_description">"Stop"</string>
+  <string name="exo_controls_rewind_description">"Rewind"</string>
+  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
 </resources>
diff --git a/library/src/main/res/values-en-rIN/strings.xml b/library/src/main/res/values-en-rIN/strings.xml
index a89377fc1d..5077cf2b94 100644
--- a/library/src/main/res/values-en-rIN/strings.xml
+++ b/library/src/main/res/values-en-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Previous track"</string>
-  <string name="next_description">"Next track"</string>
-  <string name="pause_description">"Pause"</string>
-  <string name="play_description">"Play"</string>
-  <string name="stop_description">"Stop"</string>
-  <string name="rew_description">"Rewind"</string>
-  <string name="ffw_description">"Fast-forward"</string>
+  <string name="exo_controls_previous_description">"Previous track"</string>
+  <string name="exo_controls_next_description">"Next track"</string>
+  <string name="exo_controls_pause_description">"Pause"</string>
+  <string name="exo_controls_play_description">"Play"</string>
+  <string name="exo_controls_stop_description">"Stop"</string>
+  <string name="exo_controls_rewind_description">"Rewind"</string>
+  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
 </resources>
diff --git a/library/src/main/res/values-es-rUS/strings.xml b/library/src/main/res/values-es-rUS/strings.xml
index 6e1dcf01de..72b176e538 100644
--- a/library/src/main/res/values-es-rUS/strings.xml
+++ b/library/src/main/res/values-es-rUS/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Pista anterior"</string>
-  <string name="next_description">"Siguiente pista"</string>
-  <string name="pause_description">"Pausar"</string>
-  <string name="play_description">"Reproducir"</string>
-  <string name="stop_description">"Detener"</string>
-  <string name="rew_description">"Retroceder"</string>
-  <string name="ffw_description">"Avanzar"</string>
+  <string name="exo_controls_previous_description">"Pista anterior"</string>
+  <string name="exo_controls_next_description">"Siguiente pista"</string>
+  <string name="exo_controls_pause_description">"Pausar"</string>
+  <string name="exo_controls_play_description">"Reproducir"</string>
+  <string name="exo_controls_stop_description">"Detener"</string>
+  <string name="exo_controls_rewind_description">"Retroceder"</string>
+  <string name="exo_controls_fastforward_description">"Avanzar"</string>
 </resources>
diff --git a/library/src/main/res/values-es/strings.xml b/library/src/main/res/values-es/strings.xml
index 4f108bc5df..3b188d266d 100644
--- a/library/src/main/res/values-es/strings.xml
+++ b/library/src/main/res/values-es/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Canción anterior"</string>
-  <string name="next_description">"Siguiente canción"</string>
-  <string name="pause_description">"Pausar"</string>
-  <string name="play_description">"Reproducir"</string>
-  <string name="stop_description">"Detener"</string>
-  <string name="rew_description">"Rebobinar"</string>
-  <string name="ffw_description">"Avance rápido"</string>
+  <string name="exo_controls_previous_description">"Canción anterior"</string>
+  <string name="exo_controls_next_description">"Siguiente canción"</string>
+  <string name="exo_controls_pause_description">"Pausar"</string>
+  <string name="exo_controls_play_description">"Reproducir"</string>
+  <string name="exo_controls_stop_description">"Detener"</string>
+  <string name="exo_controls_rewind_description">"Rebobinar"</string>
+  <string name="exo_controls_fastforward_description">"Avance rápido"</string>
 </resources>
diff --git a/library/src/main/res/values-et-rEE/strings.xml b/library/src/main/res/values-et-rEE/strings.xml
index 588510dc32..7a01bd9d5a 100644
--- a/library/src/main/res/values-et-rEE/strings.xml
+++ b/library/src/main/res/values-et-rEE/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Eelmine lugu"</string>
-  <string name="next_description">"Järgmine lugu"</string>
-  <string name="pause_description">"Peata"</string>
-  <string name="play_description">"Esita"</string>
-  <string name="stop_description">"Peata"</string>
-  <string name="rew_description">"Keri tagasi"</string>
-  <string name="ffw_description">"Keri edasi"</string>
+  <string name="exo_controls_previous_description">"Eelmine lugu"</string>
+  <string name="exo_controls_next_description">"Järgmine lugu"</string>
+  <string name="exo_controls_pause_description">"Peata"</string>
+  <string name="exo_controls_play_description">"Esita"</string>
+  <string name="exo_controls_stop_description">"Peata"</string>
+  <string name="exo_controls_rewind_description">"Keri tagasi"</string>
+  <string name="exo_controls_fastforward_description">"Keri edasi"</string>
 </resources>
diff --git a/library/src/main/res/values-eu-rES/strings.xml b/library/src/main/res/values-eu-rES/strings.xml
index fa96388522..3dd51d2138 100644
--- a/library/src/main/res/values-eu-rES/strings.xml
+++ b/library/src/main/res/values-eu-rES/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Aurreko pista"</string>
-  <string name="next_description">"Hurrengo pista"</string>
-  <string name="pause_description">"Pausatu"</string>
-  <string name="play_description">"Erreproduzitu"</string>
-  <string name="stop_description">"Gelditu"</string>
-  <string name="rew_description">"Atzeratu"</string>
-  <string name="ffw_description">"Aurreratu"</string>
+  <string name="exo_controls_previous_description">"Aurreko pista"</string>
+  <string name="exo_controls_next_description">"Hurrengo pista"</string>
+  <string name="exo_controls_pause_description">"Pausatu"</string>
+  <string name="exo_controls_play_description">"Erreproduzitu"</string>
+  <string name="exo_controls_stop_description">"Gelditu"</string>
+  <string name="exo_controls_rewind_description">"Atzeratu"</string>
+  <string name="exo_controls_fastforward_description">"Aurreratu"</string>
 </resources>
diff --git a/library/src/main/res/values-fa/strings.xml b/library/src/main/res/values-fa/strings.xml
index 84c99cae18..a8955ca2f3 100644
--- a/library/src/main/res/values-fa/strings.xml
+++ b/library/src/main/res/values-fa/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"آهنگ قبلی"</string>
-  <string name="next_description">"آهنگ بعدی"</string>
-  <string name="pause_description">"مکث"</string>
-  <string name="play_description">"پخش"</string>
-  <string name="stop_description">"توقف"</string>
-  <string name="rew_description">"عقب بردن"</string>
-  <string name="ffw_description">"جلو بردن سریع"</string>
+  <string name="exo_controls_previous_description">"آهنگ قبلی"</string>
+  <string name="exo_controls_next_description">"آهنگ بعدی"</string>
+  <string name="exo_controls_pause_description">"مکث"</string>
+  <string name="exo_controls_play_description">"پخش"</string>
+  <string name="exo_controls_stop_description">"توقف"</string>
+  <string name="exo_controls_rewind_description">"عقب بردن"</string>
+  <string name="exo_controls_fastforward_description">"جلو بردن سریع"</string>
 </resources>
diff --git a/library/src/main/res/values-fi/strings.xml b/library/src/main/res/values-fi/strings.xml
index ae0e25b1aa..5f1352d1af 100644
--- a/library/src/main/res/values-fi/strings.xml
+++ b/library/src/main/res/values-fi/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Edellinen raita"</string>
-  <string name="next_description">"Seuraava raita"</string>
-  <string name="pause_description">"Tauko"</string>
-  <string name="play_description">"Toista"</string>
-  <string name="stop_description">"Seis"</string>
-  <string name="rew_description">"Kelaa taakse"</string>
-  <string name="ffw_description">"Kelaa eteen"</string>
+  <string name="exo_controls_previous_description">"Edellinen raita"</string>
+  <string name="exo_controls_next_description">"Seuraava raita"</string>
+  <string name="exo_controls_pause_description">"Tauko"</string>
+  <string name="exo_controls_play_description">"Toista"</string>
+  <string name="exo_controls_stop_description">"Seis"</string>
+  <string name="exo_controls_rewind_description">"Kelaa taakse"</string>
+  <string name="exo_controls_fastforward_description">"Kelaa eteen"</string>
 </resources>
diff --git a/library/src/main/res/values-fr-rCA/strings.xml b/library/src/main/res/values-fr-rCA/strings.xml
index 5215b00d82..51ba11e0c0 100644
--- a/library/src/main/res/values-fr-rCA/strings.xml
+++ b/library/src/main/res/values-fr-rCA/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Chanson précédente"</string>
-  <string name="next_description">"Chanson suivante"</string>
-  <string name="pause_description">"Pause"</string>
-  <string name="play_description">"Lecture"</string>
-  <string name="stop_description">"Arrêter"</string>
-  <string name="rew_description">"Reculer"</string>
-  <string name="ffw_description">"Avance rapide"</string>
+  <string name="exo_controls_previous_description">"Chanson précédente"</string>
+  <string name="exo_controls_next_description">"Chanson suivante"</string>
+  <string name="exo_controls_pause_description">"Pause"</string>
+  <string name="exo_controls_play_description">"Lecture"</string>
+  <string name="exo_controls_stop_description">"Arrêter"</string>
+  <string name="exo_controls_rewind_description">"Reculer"</string>
+  <string name="exo_controls_fastforward_description">"Avance rapide"</string>
 </resources>
diff --git a/library/src/main/res/values-fr/strings.xml b/library/src/main/res/values-fr/strings.xml
index 7980c80b47..d55b32b6f7 100644
--- a/library/src/main/res/values-fr/strings.xml
+++ b/library/src/main/res/values-fr/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Piste précédente"</string>
-  <string name="next_description">"Piste suivante"</string>
-  <string name="pause_description">"Interrompre"</string>
-  <string name="play_description">"Lire"</string>
-  <string name="stop_description">"Arrêter"</string>
-  <string name="rew_description">"Retour arrière"</string>
-  <string name="ffw_description">"Avance rapide"</string>
+  <string name="exo_controls_previous_description">"Piste précédente"</string>
+  <string name="exo_controls_next_description">"Piste suivante"</string>
+  <string name="exo_controls_pause_description">"Interrompre"</string>
+  <string name="exo_controls_play_description">"Lire"</string>
+  <string name="exo_controls_stop_description">"Arrêter"</string>
+  <string name="exo_controls_rewind_description">"Retour arrière"</string>
+  <string name="exo_controls_fastforward_description">"Avance rapide"</string>
 </resources>
diff --git a/library/src/main/res/values-gl-rES/strings.xml b/library/src/main/res/values-gl-rES/strings.xml
index 05864b2633..99ae59c7f9 100644
--- a/library/src/main/res/values-gl-rES/strings.xml
+++ b/library/src/main/res/values-gl-rES/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Pista anterior"</string>
-  <string name="next_description">"Seguinte pista"</string>
-  <string name="pause_description">"Pausar"</string>
-  <string name="play_description">"Reproducir"</string>
-  <string name="stop_description">"Deter"</string>
-  <string name="rew_description">"Rebobinar"</string>
-  <string name="ffw_description">"Avance rápido"</string>
+  <string name="exo_controls_previous_description">"Pista anterior"</string>
+  <string name="exo_controls_next_description">"Seguinte pista"</string>
+  <string name="exo_controls_pause_description">"Pausar"</string>
+  <string name="exo_controls_play_description">"Reproducir"</string>
+  <string name="exo_controls_stop_description">"Deter"</string>
+  <string name="exo_controls_rewind_description">"Rebobinar"</string>
+  <string name="exo_controls_fastforward_description">"Avance rápido"</string>
 </resources>
diff --git a/library/src/main/res/values-gu-rIN/strings.xml b/library/src/main/res/values-gu-rIN/strings.xml
index b935154cc4..6feab0a3a6 100644
--- a/library/src/main/res/values-gu-rIN/strings.xml
+++ b/library/src/main/res/values-gu-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"પહેલાનો ટ્રૅક"</string>
-  <string name="next_description">"આગલો ટ્રૅક"</string>
-  <string name="pause_description">"થોભો"</string>
-  <string name="play_description">"ચલાવો"</string>
-  <string name="stop_description">"રોકો"</string>
-  <string name="rew_description">"રીવાઇન્ડ કરો"</string>
-  <string name="ffw_description">"ઝડપી ફોરવર્ડ કરો"</string>
+  <string name="exo_controls_previous_description">"પહેલાનો ટ્રૅક"</string>
+  <string name="exo_controls_next_description">"આગલો ટ્રૅક"</string>
+  <string name="exo_controls_pause_description">"થોભો"</string>
+  <string name="exo_controls_play_description">"ચલાવો"</string>
+  <string name="exo_controls_stop_description">"રોકો"</string>
+  <string name="exo_controls_rewind_description">"રીવાઇન્ડ કરો"</string>
+  <string name="exo_controls_fastforward_description">"ઝડપી ફોરવર્ડ કરો"</string>
 </resources>
diff --git a/library/src/main/res/values-hi/strings.xml b/library/src/main/res/values-hi/strings.xml
index 08415bc992..5229b67d0e 100644
--- a/library/src/main/res/values-hi/strings.xml
+++ b/library/src/main/res/values-hi/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"पिछला ट्रैक"</string>
-  <string name="next_description">"अगला ट्रैक"</string>
-  <string name="pause_description">"रोकें"</string>
-  <string name="play_description">"चलाएं"</string>
-  <string name="stop_description">"बंद करें"</string>
-  <string name="rew_description">"रिवाइंड करें"</string>
-  <string name="ffw_description">"फ़ास्ट फ़ॉरवर्ड"</string>
+  <string name="exo_controls_previous_description">"पिछला ट्रैक"</string>
+  <string name="exo_controls_next_description">"अगला ट्रैक"</string>
+  <string name="exo_controls_pause_description">"रोकें"</string>
+  <string name="exo_controls_play_description">"चलाएं"</string>
+  <string name="exo_controls_stop_description">"बंद करें"</string>
+  <string name="exo_controls_rewind_description">"रिवाइंड करें"</string>
+  <string name="exo_controls_fastforward_description">"फ़ास्ट फ़ॉरवर्ड"</string>
 </resources>
diff --git a/library/src/main/res/values-hr/strings.xml b/library/src/main/res/values-hr/strings.xml
index 6fe1ba9288..c0b075edde 100644
--- a/library/src/main/res/values-hr/strings.xml
+++ b/library/src/main/res/values-hr/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Prethodna pjesma"</string>
-  <string name="next_description">"Sljedeća pjesma"</string>
-  <string name="pause_description">"Pauziraj"</string>
-  <string name="play_description">"Reproduciraj"</string>
-  <string name="stop_description">"Zaustavi"</string>
-  <string name="rew_description">"Unatrag"</string>
-  <string name="ffw_description">"Brzo unaprijed"</string>
+  <string name="exo_controls_previous_description">"Prethodna pjesma"</string>
+  <string name="exo_controls_next_description">"Sljedeća pjesma"</string>
+  <string name="exo_controls_pause_description">"Pauziraj"</string>
+  <string name="exo_controls_play_description">"Reproduciraj"</string>
+  <string name="exo_controls_stop_description">"Zaustavi"</string>
+  <string name="exo_controls_rewind_description">"Unatrag"</string>
+  <string name="exo_controls_fastforward_description">"Brzo unaprijed"</string>
 </resources>
diff --git a/library/src/main/res/values-hu/strings.xml b/library/src/main/res/values-hu/strings.xml
index be28793dc3..2a34684edb 100644
--- a/library/src/main/res/values-hu/strings.xml
+++ b/library/src/main/res/values-hu/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Előző szám"</string>
-  <string name="next_description">"Következő szám"</string>
-  <string name="pause_description">"Szünet"</string>
-  <string name="play_description">"Lejátszás"</string>
-  <string name="stop_description">"Leállítás"</string>
-  <string name="rew_description">"Visszatekerés"</string>
-  <string name="ffw_description">"Előretekerés"</string>
+  <string name="exo_controls_previous_description">"Előző szám"</string>
+  <string name="exo_controls_next_description">"Következő szám"</string>
+  <string name="exo_controls_pause_description">"Szünet"</string>
+  <string name="exo_controls_play_description">"Lejátszás"</string>
+  <string name="exo_controls_stop_description">"Leállítás"</string>
+  <string name="exo_controls_rewind_description">"Visszatekerés"</string>
+  <string name="exo_controls_fastforward_description">"Előretekerés"</string>
 </resources>
diff --git a/library/src/main/res/values-hy-rAM/strings.xml b/library/src/main/res/values-hy-rAM/strings.xml
index 3052d6c26b..05f9d04ab7 100644
--- a/library/src/main/res/values-hy-rAM/strings.xml
+++ b/library/src/main/res/values-hy-rAM/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Նախորդը"</string>
-  <string name="next_description">"Հաջորդը"</string>
-  <string name="pause_description">"Դադարեցնել"</string>
-  <string name="play_description">"Նվագարկել"</string>
-  <string name="stop_description">"Դադարեցնել"</string>
-  <string name="rew_description">"Հետ փաթաթել"</string>
-  <string name="ffw_description">"Արագ առաջ անցնել"</string>
+  <string name="exo_controls_previous_description">"Նախորդը"</string>
+  <string name="exo_controls_next_description">"Հաջորդը"</string>
+  <string name="exo_controls_pause_description">"Դադարեցնել"</string>
+  <string name="exo_controls_play_description">"Նվագարկել"</string>
+  <string name="exo_controls_stop_description">"Դադարեցնել"</string>
+  <string name="exo_controls_rewind_description">"Հետ փաթաթել"</string>
+  <string name="exo_controls_fastforward_description">"Արագ առաջ անցնել"</string>
 </resources>
diff --git a/library/src/main/res/values-in/strings.xml b/library/src/main/res/values-in/strings.xml
index 6be2c2155c..062933a0a8 100644
--- a/library/src/main/res/values-in/strings.xml
+++ b/library/src/main/res/values-in/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Lagu sebelumnya"</string>
-  <string name="next_description">"Lagu berikutnya"</string>
-  <string name="pause_description">"Jeda"</string>
-  <string name="play_description">"Putar"</string>
-  <string name="stop_description">"Berhenti"</string>
-  <string name="rew_description">"Putar Ulang"</string>
-  <string name="ffw_description">"Maju cepat"</string>
+  <string name="exo_controls_previous_description">"Lagu sebelumnya"</string>
+  <string name="exo_controls_next_description">"Lagu berikutnya"</string>
+  <string name="exo_controls_pause_description">"Jeda"</string>
+  <string name="exo_controls_play_description">"Putar"</string>
+  <string name="exo_controls_stop_description">"Berhenti"</string>
+  <string name="exo_controls_rewind_description">"Putar Ulang"</string>
+  <string name="exo_controls_fastforward_description">"Maju cepat"</string>
 </resources>
diff --git a/library/src/main/res/values-is-rIS/strings.xml b/library/src/main/res/values-is-rIS/strings.xml
index 80b81fa7fb..9c4421a272 100644
--- a/library/src/main/res/values-is-rIS/strings.xml
+++ b/library/src/main/res/values-is-rIS/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Fyrra lag"</string>
-  <string name="next_description">"Næsta lag"</string>
-  <string name="pause_description">"Hlé"</string>
-  <string name="play_description">"Spila"</string>
-  <string name="stop_description">"Stöðva"</string>
-  <string name="rew_description">"Spóla til baka"</string>
-  <string name="ffw_description">"Spóla áfram"</string>
+  <string name="exo_controls_previous_description">"Fyrra lag"</string>
+  <string name="exo_controls_next_description">"Næsta lag"</string>
+  <string name="exo_controls_pause_description">"Hlé"</string>
+  <string name="exo_controls_play_description">"Spila"</string>
+  <string name="exo_controls_stop_description">"Stöðva"</string>
+  <string name="exo_controls_rewind_description">"Spóla til baka"</string>
+  <string name="exo_controls_fastforward_description">"Spóla áfram"</string>
 </resources>
diff --git a/library/src/main/res/values-it/strings.xml b/library/src/main/res/values-it/strings.xml
index 4d84822b8e..71525a2b3e 100644
--- a/library/src/main/res/values-it/strings.xml
+++ b/library/src/main/res/values-it/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Traccia precedente"</string>
-  <string name="next_description">"Traccia successiva"</string>
-  <string name="pause_description">"Metti in pausa"</string>
-  <string name="play_description">"Riproduci"</string>
-  <string name="stop_description">"Interrompi"</string>
-  <string name="rew_description">"Riavvolgi"</string>
-  <string name="ffw_description">"Avanti veloce"</string>
+  <string name="exo_controls_previous_description">"Traccia precedente"</string>
+  <string name="exo_controls_next_description">"Traccia successiva"</string>
+  <string name="exo_controls_pause_description">"Metti in pausa"</string>
+  <string name="exo_controls_play_description">"Riproduci"</string>
+  <string name="exo_controls_stop_description">"Interrompi"</string>
+  <string name="exo_controls_rewind_description">"Riavvolgi"</string>
+  <string name="exo_controls_fastforward_description">"Avanti veloce"</string>
 </resources>
diff --git a/library/src/main/res/values-iw/strings.xml b/library/src/main/res/values-iw/strings.xml
index 5449bb1a7c..f33cc2adb0 100644
--- a/library/src/main/res/values-iw/strings.xml
+++ b/library/src/main/res/values-iw/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"הרצועה הקודמת"</string>
-  <string name="next_description">"הרצועה הבאה"</string>
-  <string name="pause_description">"השהה"</string>
-  <string name="play_description">"הפעל"</string>
-  <string name="stop_description">"הפסק"</string>
-  <string name="rew_description">"הרץ אחורה"</string>
-  <string name="ffw_description">"הרץ קדימה"</string>
+  <string name="exo_controls_previous_description">"הרצועה הקודמת"</string>
+  <string name="exo_controls_next_description">"הרצועה הבאה"</string>
+  <string name="exo_controls_pause_description">"השהה"</string>
+  <string name="exo_controls_play_description">"הפעל"</string>
+  <string name="exo_controls_stop_description">"הפסק"</string>
+  <string name="exo_controls_rewind_description">"הרץ אחורה"</string>
+  <string name="exo_controls_fastforward_description">"הרץ קדימה"</string>
 </resources>
diff --git a/library/src/main/res/values-ja/strings.xml b/library/src/main/res/values-ja/strings.xml
index e745b18ee0..baa459aeca 100644
--- a/library/src/main/res/values-ja/strings.xml
+++ b/library/src/main/res/values-ja/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"前のトラック"</string>
-  <string name="next_description">"次のトラック"</string>
-  <string name="pause_description">"一時停止"</string>
-  <string name="play_description">"再生"</string>
-  <string name="stop_description">"停止"</string>
-  <string name="rew_description">"巻き戻し"</string>
-  <string name="ffw_description">"早送り"</string>
+  <string name="exo_controls_previous_description">"前のトラック"</string>
+  <string name="exo_controls_next_description">"次のトラック"</string>
+  <string name="exo_controls_pause_description">"一時停止"</string>
+  <string name="exo_controls_play_description">"再生"</string>
+  <string name="exo_controls_stop_description">"停止"</string>
+  <string name="exo_controls_rewind_description">"巻き戻し"</string>
+  <string name="exo_controls_fastforward_description">"早送り"</string>
 </resources>
diff --git a/library/src/main/res/values-ka-rGE/strings.xml b/library/src/main/res/values-ka-rGE/strings.xml
index 652186360c..5b87f86c34 100644
--- a/library/src/main/res/values-ka-rGE/strings.xml
+++ b/library/src/main/res/values-ka-rGE/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"წინა ჩანაწერი"</string>
-  <string name="next_description">"შემდეგი ჩანაწერი"</string>
-  <string name="pause_description">"პაუზა"</string>
-  <string name="play_description">"დაკვრა"</string>
-  <string name="stop_description">"შეწყვეტა"</string>
-  <string name="rew_description">"უკან გადახვევა"</string>
-  <string name="ffw_description">"წინ გადახვევა"</string>
+  <string name="exo_controls_previous_description">"წინა ჩანაწერი"</string>
+  <string name="exo_controls_next_description">"შემდეგი ჩანაწერი"</string>
+  <string name="exo_controls_pause_description">"პაუზა"</string>
+  <string name="exo_controls_play_description">"დაკვრა"</string>
+  <string name="exo_controls_stop_description">"შეწყვეტა"</string>
+  <string name="exo_controls_rewind_description">"უკან გადახვევა"</string>
+  <string name="exo_controls_fastforward_description">"წინ გადახვევა"</string>
 </resources>
diff --git a/library/src/main/res/values-kk-rKZ/strings.xml b/library/src/main/res/values-kk-rKZ/strings.xml
index eff4c334e0..c1bf5c8b4b 100644
--- a/library/src/main/res/values-kk-rKZ/strings.xml
+++ b/library/src/main/res/values-kk-rKZ/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Алдыңғы трек"</string>
-  <string name="next_description">"Келесі трек"</string>
-  <string name="pause_description">"Кідірту"</string>
-  <string name="play_description">"Ойнату"</string>
-  <string name="stop_description">"Тоқтату"</string>
-  <string name="rew_description">"Кері айналдыру"</string>
-  <string name="ffw_description">"Жылдам алға айналдыру"</string>
+  <string name="exo_controls_previous_description">"Алдыңғы трек"</string>
+  <string name="exo_controls_next_description">"Келесі трек"</string>
+  <string name="exo_controls_pause_description">"Кідірту"</string>
+  <string name="exo_controls_play_description">"Ойнату"</string>
+  <string name="exo_controls_stop_description">"Тоқтату"</string>
+  <string name="exo_controls_rewind_description">"Кері айналдыру"</string>
+  <string name="exo_controls_fastforward_description">"Жылдам алға айналдыру"</string>
 </resources>
diff --git a/library/src/main/res/values-km-rKH/strings.xml b/library/src/main/res/values-km-rKH/strings.xml
index 8298655078..dbeeab60a6 100644
--- a/library/src/main/res/values-km-rKH/strings.xml
+++ b/library/src/main/res/values-km-rKH/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"បទ​មុន"</string>
-  <string name="next_description">"បទ​បន្ទាប់"</string>
-  <string name="pause_description">"ផ្អាក"</string>
-  <string name="play_description">"ចាក់"</string>
-  <string name="stop_description">"បញ្ឈប់"</string>
-  <string name="rew_description">"ខា​ថយក្រោយ"</string>
-  <string name="ffw_description">"ទៅ​មុខ​​​រហ័ស"</string>
+  <string name="exo_controls_previous_description">"បទ​មុន"</string>
+  <string name="exo_controls_next_description">"បទ​បន្ទាប់"</string>
+  <string name="exo_controls_pause_description">"ផ្អាក"</string>
+  <string name="exo_controls_play_description">"ចាក់"</string>
+  <string name="exo_controls_stop_description">"បញ្ឈប់"</string>
+  <string name="exo_controls_rewind_description">"ខា​ថយក្រោយ"</string>
+  <string name="exo_controls_fastforward_description">"ទៅ​មុខ​​​រហ័ស"</string>
 </resources>
diff --git a/library/src/main/res/values-kn-rIN/strings.xml b/library/src/main/res/values-kn-rIN/strings.xml
index ac210680d8..b73cf0fdb0 100644
--- a/library/src/main/res/values-kn-rIN/strings.xml
+++ b/library/src/main/res/values-kn-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"ಹಿಂದಿನ ಟ್ರ್ಯಾಕ್"</string>
-  <string name="next_description">"ಮುಂದಿನ ಟ್ರ್ಯಾಕ್"</string>
-  <string name="pause_description">"ವಿರಾಮಗೊಳಿಸು"</string>
-  <string name="play_description">"ಪ್ಲೇ ಮಾಡು"</string>
-  <string name="stop_description">"ನಿಲ್ಲಿಸು"</string>
-  <string name="rew_description">"ರಿವೈಂಡ್ ಮಾಡು"</string>
-  <string name="ffw_description">"ವೇಗವಾಗಿ ಮುಂದಕ್ಕೆ"</string>
+  <string name="exo_controls_previous_description">"ಹಿಂದಿನ ಟ್ರ್ಯಾಕ್"</string>
+  <string name="exo_controls_next_description">"ಮುಂದಿನ ಟ್ರ್ಯಾಕ್"</string>
+  <string name="exo_controls_pause_description">"ವಿರಾಮಗೊಳಿಸು"</string>
+  <string name="exo_controls_play_description">"ಪ್ಲೇ ಮಾಡು"</string>
+  <string name="exo_controls_stop_description">"ನಿಲ್ಲಿಸು"</string>
+  <string name="exo_controls_rewind_description">"ರಿವೈಂಡ್ ಮಾಡು"</string>
+  <string name="exo_controls_fastforward_description">"ವೇಗವಾಗಿ ಮುಂದಕ್ಕೆ"</string>
 </resources>
diff --git a/library/src/main/res/values-ko/strings.xml b/library/src/main/res/values-ko/strings.xml
index 38f9b7aae9..7097e2d9f7 100644
--- a/library/src/main/res/values-ko/strings.xml
+++ b/library/src/main/res/values-ko/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"이전 트랙"</string>
-  <string name="next_description">"다음 트랙"</string>
-  <string name="pause_description">"일시중지"</string>
-  <string name="play_description">"재생"</string>
-  <string name="stop_description">"중지"</string>
-  <string name="rew_description">"되감기"</string>
-  <string name="ffw_description">"빨리 감기"</string>
+  <string name="exo_controls_previous_description">"이전 트랙"</string>
+  <string name="exo_controls_next_description">"다음 트랙"</string>
+  <string name="exo_controls_pause_description">"일시중지"</string>
+  <string name="exo_controls_play_description">"재생"</string>
+  <string name="exo_controls_stop_description">"중지"</string>
+  <string name="exo_controls_rewind_description">"되감기"</string>
+  <string name="exo_controls_fastforward_description">"빨리 감기"</string>
 </resources>
diff --git a/library/src/main/res/values-ky-rKG/strings.xml b/library/src/main/res/values-ky-rKG/strings.xml
index 43591d760c..7090c178c3 100644
--- a/library/src/main/res/values-ky-rKG/strings.xml
+++ b/library/src/main/res/values-ky-rKG/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Мурунку трек"</string>
-  <string name="next_description">"Кийинки трек"</string>
-  <string name="pause_description">"Тындыруу"</string>
-  <string name="play_description">"Ойнотуу"</string>
-  <string name="stop_description">"Токтотуу"</string>
-  <string name="rew_description">"Артка түрүү"</string>
-  <string name="ffw_description">"Алдыга түрүү"</string>
+  <string name="exo_controls_previous_description">"Мурунку трек"</string>
+  <string name="exo_controls_next_description">"Кийинки трек"</string>
+  <string name="exo_controls_pause_description">"Тындыруу"</string>
+  <string name="exo_controls_play_description">"Ойнотуу"</string>
+  <string name="exo_controls_stop_description">"Токтотуу"</string>
+  <string name="exo_controls_rewind_description">"Артка түрүү"</string>
+  <string name="exo_controls_fastforward_description">"Алдыга түрүү"</string>
 </resources>
diff --git a/library/src/main/res/values-lo-rLA/strings.xml b/library/src/main/res/values-lo-rLA/strings.xml
index 885005406d..44095e4323 100644
--- a/library/src/main/res/values-lo-rLA/strings.xml
+++ b/library/src/main/res/values-lo-rLA/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"​ເພງ​ກ່ອນ​ໜ້າ"</string>
-  <string name="next_description">"​ເພງ​ຕໍ່​ໄປ"</string>
-  <string name="pause_description">"ຢຸດຊົ່ວຄາວ"</string>
-  <string name="play_description">"ຫຼິ້ນ"</string>
-  <string name="stop_description">"ຢຸດ"</string>
-  <string name="rew_description">"​ຣີ​​ວາຍກັບ"</string>
-  <string name="ffw_description">"ເລື່ອນ​ໄປ​ໜ້າ"</string>
+  <string name="exo_controls_previous_description">"​ເພງ​ກ່ອນ​ໜ້າ"</string>
+  <string name="exo_controls_next_description">"​ເພງ​ຕໍ່​ໄປ"</string>
+  <string name="exo_controls_pause_description">"ຢຸດຊົ່ວຄາວ"</string>
+  <string name="exo_controls_play_description">"ຫຼິ້ນ"</string>
+  <string name="exo_controls_stop_description">"ຢຸດ"</string>
+  <string name="exo_controls_rewind_description">"​ຣີ​​ວາຍກັບ"</string>
+  <string name="exo_controls_fastforward_description">"ເລື່ອນ​ໄປ​ໜ້າ"</string>
 </resources>
diff --git a/library/src/main/res/values-lt/strings.xml b/library/src/main/res/values-lt/strings.xml
index f828226100..138caec322 100644
--- a/library/src/main/res/values-lt/strings.xml
+++ b/library/src/main/res/values-lt/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Ankstesnis takelis"</string>
-  <string name="next_description">"Kitas takelis"</string>
-  <string name="pause_description">"Pristabdyti"</string>
-  <string name="play_description">"Leisti"</string>
-  <string name="stop_description">"Stabdyti"</string>
-  <string name="rew_description">"Sukti atgal"</string>
-  <string name="ffw_description">"Sukti pirmyn"</string>
+  <string name="exo_controls_previous_description">"Ankstesnis takelis"</string>
+  <string name="exo_controls_next_description">"Kitas takelis"</string>
+  <string name="exo_controls_pause_description">"Pristabdyti"</string>
+  <string name="exo_controls_play_description">"Leisti"</string>
+  <string name="exo_controls_stop_description">"Stabdyti"</string>
+  <string name="exo_controls_rewind_description">"Sukti atgal"</string>
+  <string name="exo_controls_fastforward_description">"Sukti pirmyn"</string>
 </resources>
diff --git a/library/src/main/res/values-lv/strings.xml b/library/src/main/res/values-lv/strings.xml
index b5f8f00e84..4c91da86cc 100644
--- a/library/src/main/res/values-lv/strings.xml
+++ b/library/src/main/res/values-lv/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Iepriekšējais ieraksts"</string>
-  <string name="next_description">"Nākamais ieraksts"</string>
-  <string name="pause_description">"Pārtraukt"</string>
-  <string name="play_description">"Atskaņot"</string>
-  <string name="stop_description">"Apturēt"</string>
-  <string name="rew_description">"Attīt atpakaļ"</string>
-  <string name="ffw_description">"Ātri patīt"</string>
+  <string name="exo_controls_previous_description">"Iepriekšējais ieraksts"</string>
+  <string name="exo_controls_next_description">"Nākamais ieraksts"</string>
+  <string name="exo_controls_pause_description">"Pārtraukt"</string>
+  <string name="exo_controls_play_description">"Atskaņot"</string>
+  <string name="exo_controls_stop_description">"Apturēt"</string>
+  <string name="exo_controls_rewind_description">"Attīt atpakaļ"</string>
+  <string name="exo_controls_fastforward_description">"Ātri patīt"</string>
 </resources>
diff --git a/library/src/main/res/values-mk-rMK/strings.xml b/library/src/main/res/values-mk-rMK/strings.xml
index aa96af37a1..e9fedf689f 100644
--- a/library/src/main/res/values-mk-rMK/strings.xml
+++ b/library/src/main/res/values-mk-rMK/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Претходна песна"</string>
-  <string name="next_description">"Следна песна"</string>
-  <string name="pause_description">"Пауза"</string>
-  <string name="play_description">"Пушти"</string>
-  <string name="stop_description">"Запри"</string>
-  <string name="rew_description">"Премотај назад"</string>
-  <string name="ffw_description">"Брзо премотај напред"</string>
+  <string name="exo_controls_previous_description">"Претходна песна"</string>
+  <string name="exo_controls_next_description">"Следна песна"</string>
+  <string name="exo_controls_pause_description">"Пауза"</string>
+  <string name="exo_controls_play_description">"Пушти"</string>
+  <string name="exo_controls_stop_description">"Запри"</string>
+  <string name="exo_controls_rewind_description">"Премотај назад"</string>
+  <string name="exo_controls_fastforward_description">"Брзо премотај напред"</string>
 </resources>
diff --git a/library/src/main/res/values-ml-rIN/strings.xml b/library/src/main/res/values-ml-rIN/strings.xml
index f59e90d24a..acc33934fb 100644
--- a/library/src/main/res/values-ml-rIN/strings.xml
+++ b/library/src/main/res/values-ml-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"മുമ്പത്തെ ട്രാക്ക്"</string>
-  <string name="next_description">"അടുത്ത ട്രാക്ക്"</string>
-  <string name="pause_description">"താൽക്കാലികമായി നിർത്തുക"</string>
-  <string name="play_description">"പ്ലേ ചെയ്യുക"</string>
-  <string name="stop_description">"നിര്‍ത്തുക"</string>
-  <string name="rew_description">"റിവൈൻഡുചെയ്യുക"</string>
-  <string name="ffw_description">"വേഗത്തിലുള്ള കൈമാറൽ"</string>
+  <string name="exo_controls_previous_description">"മുമ്പത്തെ ട്രാക്ക്"</string>
+  <string name="exo_controls_next_description">"അടുത്ത ട്രാക്ക്"</string>
+  <string name="exo_controls_pause_description">"താൽക്കാലികമായി നിർത്തുക"</string>
+  <string name="exo_controls_play_description">"പ്ലേ ചെയ്യുക"</string>
+  <string name="exo_controls_stop_description">"നിര്‍ത്തുക"</string>
+  <string name="exo_controls_rewind_description">"റിവൈൻഡുചെയ്യുക"</string>
+  <string name="exo_controls_fastforward_description">"വേഗത്തിലുള്ള കൈമാറൽ"</string>
 </resources>
diff --git a/library/src/main/res/values-mn-rMN/strings.xml b/library/src/main/res/values-mn-rMN/strings.xml
index 2ab27a803e..6434e9ea16 100644
--- a/library/src/main/res/values-mn-rMN/strings.xml
+++ b/library/src/main/res/values-mn-rMN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Өмнөх трек"</string>
-  <string name="next_description">"Дараагийн трек"</string>
-  <string name="pause_description">"Түр зогсоох"</string>
-  <string name="play_description">"Тоглуулах"</string>
-  <string name="stop_description">"Зогсоох"</string>
-  <string name="rew_description">"Буцааж хураах"</string>
-  <string name="ffw_description">"Хурдан урагшлуулах"</string>
+  <string name="exo_controls_previous_description">"Өмнөх трек"</string>
+  <string name="exo_controls_next_description">"Дараагийн трек"</string>
+  <string name="exo_controls_pause_description">"Түр зогсоох"</string>
+  <string name="exo_controls_play_description">"Тоглуулах"</string>
+  <string name="exo_controls_stop_description">"Зогсоох"</string>
+  <string name="exo_controls_rewind_description">"Буцааж хураах"</string>
+  <string name="exo_controls_fastforward_description">"Хурдан урагшлуулах"</string>
 </resources>
diff --git a/library/src/main/res/values-mr-rIN/strings.xml b/library/src/main/res/values-mr-rIN/strings.xml
index 827259e68b..8f4d0d75b1 100644
--- a/library/src/main/res/values-mr-rIN/strings.xml
+++ b/library/src/main/res/values-mr-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"मागील ट्रॅक"</string>
-  <string name="next_description">"पुढील ट्रॅक"</string>
-  <string name="pause_description">"विराम द्या"</string>
-  <string name="play_description">"प्ले करा"</string>
-  <string name="stop_description">"थांबा"</string>
-  <string name="rew_description">"रिवाईँड करा"</string>
-  <string name="ffw_description">"फास्ट फॉरवर्ड करा"</string>
+  <string name="exo_controls_previous_description">"मागील ट्रॅक"</string>
+  <string name="exo_controls_next_description">"पुढील ट्रॅक"</string>
+  <string name="exo_controls_pause_description">"विराम द्या"</string>
+  <string name="exo_controls_play_description">"प्ले करा"</string>
+  <string name="exo_controls_stop_description">"थांबा"</string>
+  <string name="exo_controls_rewind_description">"रिवाईँड करा"</string>
+  <string name="exo_controls_fastforward_description">"फास्ट फॉरवर्ड करा"</string>
 </resources>
diff --git a/library/src/main/res/values-ms-rMY/strings.xml b/library/src/main/res/values-ms-rMY/strings.xml
index e8bf6ec693..91f74bbc1c 100644
--- a/library/src/main/res/values-ms-rMY/strings.xml
+++ b/library/src/main/res/values-ms-rMY/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Lagu sebelumnya"</string>
-  <string name="next_description">"Lagu seterusnya"</string>
-  <string name="pause_description">"Jeda"</string>
-  <string name="play_description">"Main"</string>
-  <string name="stop_description">"Berhenti"</string>
-  <string name="rew_description">"Gulung semula"</string>
-  <string name="ffw_description">"Mara laju"</string>
+  <string name="exo_controls_previous_description">"Lagu sebelumnya"</string>
+  <string name="exo_controls_next_description">"Lagu seterusnya"</string>
+  <string name="exo_controls_pause_description">"Jeda"</string>
+  <string name="exo_controls_play_description">"Main"</string>
+  <string name="exo_controls_stop_description">"Berhenti"</string>
+  <string name="exo_controls_rewind_description">"Gulung semula"</string>
+  <string name="exo_controls_fastforward_description">"Mara laju"</string>
 </resources>
diff --git a/library/src/main/res/values-my-rMM/strings.xml b/library/src/main/res/values-my-rMM/strings.xml
index 62e4e6c0c7..4b68e6e950 100644
--- a/library/src/main/res/values-my-rMM/strings.xml
+++ b/library/src/main/res/values-my-rMM/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"ယခင် တစ်ပုဒ်"</string>
-  <string name="next_description">"နောက် တစ်ပုဒ်"</string>
-  <string name="pause_description">"ခဏရပ်ရန်"</string>
-  <string name="play_description">"ဖွင့်ရန်"</string>
-  <string name="stop_description">"ရပ်ရန်"</string>
-  <string name="rew_description">"ပြန်ရစ်ရန်"</string>
-  <string name="ffw_description">"ရှေ့သို့ သွားရန်"</string>
+  <string name="exo_controls_previous_description">"ယခင် တစ်ပုဒ်"</string>
+  <string name="exo_controls_next_description">"နောက် တစ်ပုဒ်"</string>
+  <string name="exo_controls_pause_description">"ခဏရပ်ရန်"</string>
+  <string name="exo_controls_play_description">"ဖွင့်ရန်"</string>
+  <string name="exo_controls_stop_description">"ရပ်ရန်"</string>
+  <string name="exo_controls_rewind_description">"ပြန်ရစ်ရန်"</string>
+  <string name="exo_controls_fastforward_description">"ရှေ့သို့ သွားရန်"</string>
 </resources>
diff --git a/library/src/main/res/values-nb/strings.xml b/library/src/main/res/values-nb/strings.xml
index b5e7c6d05b..37454235ad 100644
--- a/library/src/main/res/values-nb/strings.xml
+++ b/library/src/main/res/values-nb/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Forrige spor"</string>
-  <string name="next_description">"Neste spor"</string>
-  <string name="pause_description">"Sett på pause"</string>
-  <string name="play_description">"Spill av"</string>
-  <string name="stop_description">"Stopp"</string>
-  <string name="rew_description">"Tilbakespoling"</string>
-  <string name="ffw_description">"Fremoverspoling"</string>
+  <string name="exo_controls_previous_description">"Forrige spor"</string>
+  <string name="exo_controls_next_description">"Neste spor"</string>
+  <string name="exo_controls_pause_description">"Sett på pause"</string>
+  <string name="exo_controls_play_description">"Spill av"</string>
+  <string name="exo_controls_stop_description">"Stopp"</string>
+  <string name="exo_controls_rewind_description">"Tilbakespoling"</string>
+  <string name="exo_controls_fastforward_description">"Fremoverspoling"</string>
 </resources>
diff --git a/library/src/main/res/values-ne-rNP/strings.xml b/library/src/main/res/values-ne-rNP/strings.xml
index 47ce703544..375e44afce 100644
--- a/library/src/main/res/values-ne-rNP/strings.xml
+++ b/library/src/main/res/values-ne-rNP/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"अघिल्लो ट्रयाक"</string>
-  <string name="next_description">"अर्को ट्रयाक"</string>
-  <string name="pause_description">"रोक्नुहोस्"</string>
-  <string name="play_description">"चलाउनुहोस्"</string>
-  <string name="stop_description">"रोक्नुहोस्"</string>
-  <string name="rew_description">"दोहोर्याउनुहोस्"</string>
-  <string name="ffw_description">"फास्ट फर्वार्ड"</string>
+  <string name="exo_controls_previous_description">"अघिल्लो ट्रयाक"</string>
+  <string name="exo_controls_next_description">"अर्को ट्रयाक"</string>
+  <string name="exo_controls_pause_description">"रोक्नुहोस्"</string>
+  <string name="exo_controls_play_description">"चलाउनुहोस्"</string>
+  <string name="exo_controls_stop_description">"रोक्नुहोस्"</string>
+  <string name="exo_controls_rewind_description">"दोहोर्याउनुहोस्"</string>
+  <string name="exo_controls_fastforward_description">"फास्ट फर्वार्ड"</string>
 </resources>
diff --git a/library/src/main/res/values-nl/strings.xml b/library/src/main/res/values-nl/strings.xml
index 092165db53..2bdbf0bdae 100644
--- a/library/src/main/res/values-nl/strings.xml
+++ b/library/src/main/res/values-nl/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Vorig nummer"</string>
-  <string name="next_description">"Volgend nummer"</string>
-  <string name="pause_description">"Onderbreken"</string>
-  <string name="play_description">"Afspelen"</string>
-  <string name="stop_description">"Stoppen"</string>
-  <string name="rew_description">"Terugspoelen"</string>
-  <string name="ffw_description">"Vooruitspoelen"</string>
+  <string name="exo_controls_previous_description">"Vorig nummer"</string>
+  <string name="exo_controls_next_description">"Volgend nummer"</string>
+  <string name="exo_controls_pause_description">"Onderbreken"</string>
+  <string name="exo_controls_play_description">"Afspelen"</string>
+  <string name="exo_controls_stop_description">"Stoppen"</string>
+  <string name="exo_controls_rewind_description">"Terugspoelen"</string>
+  <string name="exo_controls_fastforward_description">"Vooruitspoelen"</string>
 </resources>
diff --git a/library/src/main/res/values-pa-rIN/strings.xml b/library/src/main/res/values-pa-rIN/strings.xml
index 96654b89f0..143508e071 100644
--- a/library/src/main/res/values-pa-rIN/strings.xml
+++ b/library/src/main/res/values-pa-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"ਪਿਛਲਾ ਟਰੈਕ"</string>
-  <string name="next_description">"ਅਗਲਾ ਟਰੈਕ"</string>
-  <string name="pause_description">"ਰੋਕੋ"</string>
-  <string name="play_description">"ਪਲੇ ਕਰੋ"</string>
-  <string name="stop_description">"ਰੋਕੋ"</string>
-  <string name="rew_description">"ਰੀਵਾਈਂਡ ਕਰੋ"</string>
-  <string name="ffw_description">"ਅੱਗੇ ਭੇਜੋ"</string>
+  <string name="exo_controls_previous_description">"ਪਿਛਲਾ ਟਰੈਕ"</string>
+  <string name="exo_controls_next_description">"ਅਗਲਾ ਟਰੈਕ"</string>
+  <string name="exo_controls_pause_description">"ਰੋਕੋ"</string>
+  <string name="exo_controls_play_description">"ਪਲੇ ਕਰੋ"</string>
+  <string name="exo_controls_stop_description">"ਰੋਕੋ"</string>
+  <string name="exo_controls_rewind_description">"ਰੀਵਾਈਂਡ ਕਰੋ"</string>
+  <string name="exo_controls_fastforward_description">"ਅੱਗੇ ਭੇਜੋ"</string>
 </resources>
diff --git a/library/src/main/res/values-pl/strings.xml b/library/src/main/res/values-pl/strings.xml
index 131e0630f3..64f52d5d09 100644
--- a/library/src/main/res/values-pl/strings.xml
+++ b/library/src/main/res/values-pl/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Poprzedni utwór"</string>
-  <string name="next_description">"Następny utwór"</string>
-  <string name="pause_description">"Wstrzymaj"</string>
-  <string name="play_description">"Odtwórz"</string>
-  <string name="stop_description">"Zatrzymaj"</string>
-  <string name="rew_description">"Przewiń do tyłu"</string>
-  <string name="ffw_description">"Przewiń do przodu"</string>
+  <string name="exo_controls_previous_description">"Poprzedni utwór"</string>
+  <string name="exo_controls_next_description">"Następny utwór"</string>
+  <string name="exo_controls_pause_description">"Wstrzymaj"</string>
+  <string name="exo_controls_play_description">"Odtwórz"</string>
+  <string name="exo_controls_stop_description">"Zatrzymaj"</string>
+  <string name="exo_controls_rewind_description">"Przewiń do tyłu"</string>
+  <string name="exo_controls_fastforward_description">"Przewiń do przodu"</string>
 </resources>
diff --git a/library/src/main/res/values-pt-rBR/strings.xml b/library/src/main/res/values-pt-rBR/strings.xml
index 3e3ac47be9..51bcf4d723 100644
--- a/library/src/main/res/values-pt-rBR/strings.xml
+++ b/library/src/main/res/values-pt-rBR/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Faixa anterior"</string>
-  <string name="next_description">"Próxima faixa"</string>
-  <string name="pause_description">"Pausar"</string>
-  <string name="play_description">"Reproduzir"</string>
-  <string name="stop_description">"Parar"</string>
-  <string name="rew_description">"Retroceder"</string>
-  <string name="ffw_description">"Avançar"</string>
+  <string name="exo_controls_previous_description">"Faixa anterior"</string>
+  <string name="exo_controls_next_description">"Próxima faixa"</string>
+  <string name="exo_controls_pause_description">"Pausar"</string>
+  <string name="exo_controls_play_description">"Reproduzir"</string>
+  <string name="exo_controls_stop_description">"Parar"</string>
+  <string name="exo_controls_rewind_description">"Retroceder"</string>
+  <string name="exo_controls_fastforward_description">"Avançar"</string>
 </resources>
diff --git a/library/src/main/res/values-pt-rPT/strings.xml b/library/src/main/res/values-pt-rPT/strings.xml
index 0d0d0ec183..5b3c9131d0 100644
--- a/library/src/main/res/values-pt-rPT/strings.xml
+++ b/library/src/main/res/values-pt-rPT/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Faixa anterior"</string>
-  <string name="next_description">"Faixa seguinte"</string>
-  <string name="pause_description">"Interromper"</string>
-  <string name="play_description">"Reproduzir"</string>
-  <string name="stop_description">"Parar"</string>
-  <string name="rew_description">"Rebobinar"</string>
-  <string name="ffw_description">"Avançar"</string>
+  <string name="exo_controls_previous_description">"Faixa anterior"</string>
+  <string name="exo_controls_next_description">"Faixa seguinte"</string>
+  <string name="exo_controls_pause_description">"Interromper"</string>
+  <string name="exo_controls_play_description">"Reproduzir"</string>
+  <string name="exo_controls_stop_description">"Parar"</string>
+  <string name="exo_controls_rewind_description">"Rebobinar"</string>
+  <string name="exo_controls_fastforward_description">"Avançar"</string>
 </resources>
diff --git a/library/src/main/res/values-pt/strings.xml b/library/src/main/res/values-pt/strings.xml
index 3e3ac47be9..51bcf4d723 100644
--- a/library/src/main/res/values-pt/strings.xml
+++ b/library/src/main/res/values-pt/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Faixa anterior"</string>
-  <string name="next_description">"Próxima faixa"</string>
-  <string name="pause_description">"Pausar"</string>
-  <string name="play_description">"Reproduzir"</string>
-  <string name="stop_description">"Parar"</string>
-  <string name="rew_description">"Retroceder"</string>
-  <string name="ffw_description">"Avançar"</string>
+  <string name="exo_controls_previous_description">"Faixa anterior"</string>
+  <string name="exo_controls_next_description">"Próxima faixa"</string>
+  <string name="exo_controls_pause_description">"Pausar"</string>
+  <string name="exo_controls_play_description">"Reproduzir"</string>
+  <string name="exo_controls_stop_description">"Parar"</string>
+  <string name="exo_controls_rewind_description">"Retroceder"</string>
+  <string name="exo_controls_fastforward_description">"Avançar"</string>
 </resources>
diff --git a/library/src/main/res/values-ro/strings.xml b/library/src/main/res/values-ro/strings.xml
index 3cb6730c99..5a7feda78c 100644
--- a/library/src/main/res/values-ro/strings.xml
+++ b/library/src/main/res/values-ro/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Melodia anterioară"</string>
-  <string name="next_description">"Melodia următoare"</string>
-  <string name="pause_description">"Pauză"</string>
-  <string name="play_description">"Redați"</string>
-  <string name="stop_description">"Opriți"</string>
-  <string name="rew_description">"Derulați"</string>
-  <string name="ffw_description">"Derulați rapid înainte"</string>
+  <string name="exo_controls_previous_description">"Melodia anterioară"</string>
+  <string name="exo_controls_next_description">"Melodia următoare"</string>
+  <string name="exo_controls_pause_description">"Pauză"</string>
+  <string name="exo_controls_play_description">"Redați"</string>
+  <string name="exo_controls_stop_description">"Opriți"</string>
+  <string name="exo_controls_rewind_description">"Derulați"</string>
+  <string name="exo_controls_fastforward_description">"Derulați rapid înainte"</string>
 </resources>
diff --git a/library/src/main/res/values-ru/strings.xml b/library/src/main/res/values-ru/strings.xml
index 59a6923954..da47546a8b 100644
--- a/library/src/main/res/values-ru/strings.xml
+++ b/library/src/main/res/values-ru/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Предыдущий трек"</string>
-  <string name="next_description">"Следующий трек"</string>
-  <string name="pause_description">"Приостановить"</string>
-  <string name="play_description">"Воспроизвести"</string>
-  <string name="stop_description">"Остановить"</string>
-  <string name="rew_description">"Перемотать назад"</string>
-  <string name="ffw_description">"Перемотать вперед"</string>
+  <string name="exo_controls_previous_description">"Предыдущий трек"</string>
+  <string name="exo_controls_next_description">"Следующий трек"</string>
+  <string name="exo_controls_pause_description">"Приостановить"</string>
+  <string name="exo_controls_play_description">"Воспроизвести"</string>
+  <string name="exo_controls_stop_description">"Остановить"</string>
+  <string name="exo_controls_rewind_description">"Перемотать назад"</string>
+  <string name="exo_controls_fastforward_description">"Перемотать вперед"</string>
 </resources>
diff --git a/library/src/main/res/values-si-rLK/strings.xml b/library/src/main/res/values-si-rLK/strings.xml
index d634b82374..0b579240e8 100644
--- a/library/src/main/res/values-si-rLK/strings.xml
+++ b/library/src/main/res/values-si-rLK/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"පෙර ගීතය"</string>
-  <string name="next_description">"ඊළඟ ගීතය"</string>
-  <string name="pause_description">"විරාමය"</string>
-  <string name="play_description">"ධාවනය කරන්න"</string>
-  <string name="stop_description">"නතර කරන්න"</string>
-  <string name="rew_description">"නැවත ඔතන්න"</string>
-  <string name="ffw_description">"වේගයෙන් ඉදිරියට යන"</string>
+  <string name="exo_controls_previous_description">"පෙර ගීතය"</string>
+  <string name="exo_controls_next_description">"ඊළඟ ගීතය"</string>
+  <string name="exo_controls_pause_description">"විරාමය"</string>
+  <string name="exo_controls_play_description">"ධාවනය කරන්න"</string>
+  <string name="exo_controls_stop_description">"නතර කරන්න"</string>
+  <string name="exo_controls_rewind_description">"නැවත ඔතන්න"</string>
+  <string name="exo_controls_fastforward_description">"වේගයෙන් ඉදිරියට යන"</string>
 </resources>
diff --git a/library/src/main/res/values-sk/strings.xml b/library/src/main/res/values-sk/strings.xml
index b0965864d6..7596497e06 100644
--- a/library/src/main/res/values-sk/strings.xml
+++ b/library/src/main/res/values-sk/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Predchádzajúca stopa"</string>
-  <string name="next_description">"Ďalšia stopa"</string>
-  <string name="pause_description">"Pozastaviť"</string>
-  <string name="play_description">"Prehrať"</string>
-  <string name="stop_description">"Zastaviť"</string>
-  <string name="rew_description">"Pretočiť späť"</string>
-  <string name="ffw_description">"Pretočiť dopredu"</string>
+  <string name="exo_controls_previous_description">"Predchádzajúca stopa"</string>
+  <string name="exo_controls_next_description">"Ďalšia stopa"</string>
+  <string name="exo_controls_pause_description">"Pozastaviť"</string>
+  <string name="exo_controls_play_description">"Prehrať"</string>
+  <string name="exo_controls_stop_description">"Zastaviť"</string>
+  <string name="exo_controls_rewind_description">"Pretočiť späť"</string>
+  <string name="exo_controls_fastforward_description">"Pretočiť dopredu"</string>
 </resources>
diff --git a/library/src/main/res/values-sl/strings.xml b/library/src/main/res/values-sl/strings.xml
index f2edda42dd..a77586b50c 100644
--- a/library/src/main/res/values-sl/strings.xml
+++ b/library/src/main/res/values-sl/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Prejšnja skladba"</string>
-  <string name="next_description">"Naslednja skladba"</string>
-  <string name="pause_description">"Zaustavi"</string>
-  <string name="play_description">"Predvajaj"</string>
-  <string name="stop_description">"Ustavi"</string>
-  <string name="rew_description">"Previj nazaj"</string>
-  <string name="ffw_description">"Previj naprej"</string>
+  <string name="exo_controls_previous_description">"Prejšnja skladba"</string>
+  <string name="exo_controls_next_description">"Naslednja skladba"</string>
+  <string name="exo_controls_pause_description">"Zaustavi"</string>
+  <string name="exo_controls_play_description">"Predvajaj"</string>
+  <string name="exo_controls_stop_description">"Ustavi"</string>
+  <string name="exo_controls_rewind_description">"Previj nazaj"</string>
+  <string name="exo_controls_fastforward_description">"Previj naprej"</string>
 </resources>
diff --git a/library/src/main/res/values-sq-rAL/strings.xml b/library/src/main/res/values-sq-rAL/strings.xml
index 6716a32486..1fb824366d 100644
--- a/library/src/main/res/values-sq-rAL/strings.xml
+++ b/library/src/main/res/values-sq-rAL/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Kënga e mëparshme"</string>
-  <string name="next_description">"Kënga tjetër"</string>
-  <string name="pause_description">"Pauzë"</string>
-  <string name="play_description">"Luaj"</string>
-  <string name="stop_description">"Ndalo"</string>
-  <string name="rew_description">"Kthehu pas"</string>
-  <string name="ffw_description">"Përparo me shpejtësi"</string>
+  <string name="exo_controls_previous_description">"Kënga e mëparshme"</string>
+  <string name="exo_controls_next_description">"Kënga tjetër"</string>
+  <string name="exo_controls_pause_description">"Pauzë"</string>
+  <string name="exo_controls_play_description">"Luaj"</string>
+  <string name="exo_controls_stop_description">"Ndalo"</string>
+  <string name="exo_controls_rewind_description">"Kthehu pas"</string>
+  <string name="exo_controls_fastforward_description">"Përparo me shpejtësi"</string>
 </resources>
diff --git a/library/src/main/res/values-sr/strings.xml b/library/src/main/res/values-sr/strings.xml
index cfb3d20c6a..175ad4fe7f 100644
--- a/library/src/main/res/values-sr/strings.xml
+++ b/library/src/main/res/values-sr/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Претходна песма"</string>
-  <string name="next_description">"Следећа песма"</string>
-  <string name="pause_description">"Пауза"</string>
-  <string name="play_description">"Пусти"</string>
-  <string name="stop_description">"Заустави"</string>
-  <string name="rew_description">"Премотај уназад"</string>
-  <string name="ffw_description">"Премотај унапред"</string>
+  <string name="exo_controls_previous_description">"Претходна песма"</string>
+  <string name="exo_controls_next_description">"Следећа песма"</string>
+  <string name="exo_controls_pause_description">"Пауза"</string>
+  <string name="exo_controls_play_description">"Пусти"</string>
+  <string name="exo_controls_stop_description">"Заустави"</string>
+  <string name="exo_controls_rewind_description">"Премотај уназад"</string>
+  <string name="exo_controls_fastforward_description">"Премотај унапред"</string>
 </resources>
diff --git a/library/src/main/res/values-sv/strings.xml b/library/src/main/res/values-sv/strings.xml
index 35b987db48..e6a8960458 100644
--- a/library/src/main/res/values-sv/strings.xml
+++ b/library/src/main/res/values-sv/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Föregående spår"</string>
-  <string name="next_description">"Nästa spår"</string>
-  <string name="pause_description">"Pausa"</string>
-  <string name="play_description">"Spela upp"</string>
-  <string name="stop_description">"Avbryt"</string>
-  <string name="rew_description">"Spola tillbaka"</string>
-  <string name="ffw_description">"Snabbspola framåt"</string>
+  <string name="exo_controls_previous_description">"Föregående spår"</string>
+  <string name="exo_controls_next_description">"Nästa spår"</string>
+  <string name="exo_controls_pause_description">"Pausa"</string>
+  <string name="exo_controls_play_description">"Spela upp"</string>
+  <string name="exo_controls_stop_description">"Avbryt"</string>
+  <string name="exo_controls_rewind_description">"Spola tillbaka"</string>
+  <string name="exo_controls_fastforward_description">"Snabbspola framåt"</string>
 </resources>
diff --git a/library/src/main/res/values-sw/strings.xml b/library/src/main/res/values-sw/strings.xml
index 32e2799e97..8055b7daff 100644
--- a/library/src/main/res/values-sw/strings.xml
+++ b/library/src/main/res/values-sw/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Wimbo uliotangulia"</string>
-  <string name="next_description">"Wimbo unaofuata"</string>
-  <string name="pause_description">"Sitisha"</string>
-  <string name="play_description">"Cheza"</string>
-  <string name="stop_description">"Simamisha"</string>
-  <string name="rew_description">"Rudisha nyuma"</string>
-  <string name="ffw_description">"Peleka mbele kwa kasi"</string>
+  <string name="exo_controls_previous_description">"Wimbo uliotangulia"</string>
+  <string name="exo_controls_next_description">"Wimbo unaofuata"</string>
+  <string name="exo_controls_pause_description">"Sitisha"</string>
+  <string name="exo_controls_play_description">"Cheza"</string>
+  <string name="exo_controls_stop_description">"Simamisha"</string>
+  <string name="exo_controls_rewind_description">"Rudisha nyuma"</string>
+  <string name="exo_controls_fastforward_description">"Peleka mbele kwa kasi"</string>
 </resources>
diff --git a/library/src/main/res/values-ta-rIN/strings.xml b/library/src/main/res/values-ta-rIN/strings.xml
index 32d88cf9f0..3eb995d467 100644
--- a/library/src/main/res/values-ta-rIN/strings.xml
+++ b/library/src/main/res/values-ta-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"முந்தைய ட்ராக்"</string>
-  <string name="next_description">"அடுத்த ட்ராக்"</string>
-  <string name="pause_description">"இடைநிறுத்து"</string>
-  <string name="play_description">"இயக்கு"</string>
-  <string name="stop_description">"நிறுத்து"</string>
-  <string name="rew_description">"மீண்டும் காட்டு"</string>
-  <string name="ffw_description">"வேகமாக முன்செல்"</string>
+  <string name="exo_controls_previous_description">"முந்தைய ட்ராக்"</string>
+  <string name="exo_controls_next_description">"அடுத்த ட்ராக்"</string>
+  <string name="exo_controls_pause_description">"இடைநிறுத்து"</string>
+  <string name="exo_controls_play_description">"இயக்கு"</string>
+  <string name="exo_controls_stop_description">"நிறுத்து"</string>
+  <string name="exo_controls_rewind_description">"மீண்டும் காட்டு"</string>
+  <string name="exo_controls_fastforward_description">"வேகமாக முன்செல்"</string>
 </resources>
diff --git a/library/src/main/res/values-te-rIN/strings.xml b/library/src/main/res/values-te-rIN/strings.xml
index f527c30270..fe7930455a 100644
--- a/library/src/main/res/values-te-rIN/strings.xml
+++ b/library/src/main/res/values-te-rIN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"మునుపటి ట్రాక్"</string>
-  <string name="next_description">"తదుపరి ట్రాక్"</string>
-  <string name="pause_description">"పాజ్ చేయి"</string>
-  <string name="play_description">"ప్లే చేయి"</string>
-  <string name="stop_description">"ఆపివేయి"</string>
-  <string name="rew_description">"రివైండ్ చేయి"</string>
-  <string name="ffw_description">"వేగంగా ఫార్వార్డ్ చేయి"</string>
+  <string name="exo_controls_previous_description">"మునుపటి ట్రాక్"</string>
+  <string name="exo_controls_next_description">"తదుపరి ట్రాక్"</string>
+  <string name="exo_controls_pause_description">"పాజ్ చేయి"</string>
+  <string name="exo_controls_play_description">"ప్లే చేయి"</string>
+  <string name="exo_controls_stop_description">"ఆపివేయి"</string>
+  <string name="exo_controls_rewind_description">"రివైండ్ చేయి"</string>
+  <string name="exo_controls_fastforward_description">"వేగంగా ఫార్వార్డ్ చేయి"</string>
 </resources>
diff --git a/library/src/main/res/values-th/strings.xml b/library/src/main/res/values-th/strings.xml
index 3b86808ee7..deb2aac87d 100644
--- a/library/src/main/res/values-th/strings.xml
+++ b/library/src/main/res/values-th/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"แทร็กก่อนหน้า"</string>
-  <string name="next_description">"แทร็กถัดไป"</string>
-  <string name="pause_description">"หยุดชั่วคราว"</string>
-  <string name="play_description">"เล่น"</string>
-  <string name="stop_description">"หยุด"</string>
-  <string name="rew_description">"กรอกลับ"</string>
-  <string name="ffw_description">"กรอไปข้างหน้า"</string>
+  <string name="exo_controls_previous_description">"แทร็กก่อนหน้า"</string>
+  <string name="exo_controls_next_description">"แทร็กถัดไป"</string>
+  <string name="exo_controls_pause_description">"หยุดชั่วคราว"</string>
+  <string name="exo_controls_play_description">"เล่น"</string>
+  <string name="exo_controls_stop_description">"หยุด"</string>
+  <string name="exo_controls_rewind_description">"กรอกลับ"</string>
+  <string name="exo_controls_fastforward_description">"กรอไปข้างหน้า"</string>
 </resources>
diff --git a/library/src/main/res/values-tl/strings.xml b/library/src/main/res/values-tl/strings.xml
index 2381287624..28dcb3267e 100644
--- a/library/src/main/res/values-tl/strings.xml
+++ b/library/src/main/res/values-tl/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Nakaraang track"</string>
-  <string name="next_description">"Susunod na track"</string>
-  <string name="pause_description">"I-pause"</string>
-  <string name="play_description">"I-play"</string>
-  <string name="stop_description">"Ihinto"</string>
-  <string name="rew_description">"I-rewind"</string>
-  <string name="ffw_description">"I-fast forward"</string>
+  <string name="exo_controls_previous_description">"Nakaraang track"</string>
+  <string name="exo_controls_next_description">"Susunod na track"</string>
+  <string name="exo_controls_pause_description">"I-pause"</string>
+  <string name="exo_controls_play_description">"I-play"</string>
+  <string name="exo_controls_stop_description">"Ihinto"</string>
+  <string name="exo_controls_rewind_description">"I-rewind"</string>
+  <string name="exo_controls_fastforward_description">"I-fast forward"</string>
 </resources>
diff --git a/library/src/main/res/values-tr/strings.xml b/library/src/main/res/values-tr/strings.xml
index cd05be1551..4265d796fe 100644
--- a/library/src/main/res/values-tr/strings.xml
+++ b/library/src/main/res/values-tr/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Önceki parça"</string>
-  <string name="next_description">"Sonraki parça"</string>
-  <string name="pause_description">"Duraklat"</string>
-  <string name="play_description">"Çal"</string>
-  <string name="stop_description">"Durdur"</string>
-  <string name="rew_description">"Geri sar"</string>
-  <string name="ffw_description">"İleri sar"</string>
+  <string name="exo_controls_previous_description">"Önceki parça"</string>
+  <string name="exo_controls_next_description">"Sonraki parça"</string>
+  <string name="exo_controls_pause_description">"Duraklat"</string>
+  <string name="exo_controls_play_description">"Çal"</string>
+  <string name="exo_controls_stop_description">"Durdur"</string>
+  <string name="exo_controls_rewind_description">"Geri sar"</string>
+  <string name="exo_controls_fastforward_description">"İleri sar"</string>
 </resources>
diff --git a/library/src/main/res/values-uk/strings.xml b/library/src/main/res/values-uk/strings.xml
index ec249b7f9f..487ca07556 100644
--- a/library/src/main/res/values-uk/strings.xml
+++ b/library/src/main/res/values-uk/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Попередня композиція"</string>
-  <string name="next_description">"Наступна композиція"</string>
-  <string name="pause_description">"Пауза"</string>
-  <string name="play_description">"Відтворити"</string>
-  <string name="stop_description">"Зупинити"</string>
-  <string name="rew_description">"Перемотати назад"</string>
-  <string name="ffw_description">"Перемотати вперед"</string>
+  <string name="exo_controls_previous_description">"Попередня композиція"</string>
+  <string name="exo_controls_next_description">"Наступна композиція"</string>
+  <string name="exo_controls_pause_description">"Пауза"</string>
+  <string name="exo_controls_play_description">"Відтворити"</string>
+  <string name="exo_controls_stop_description">"Зупинити"</string>
+  <string name="exo_controls_rewind_description">"Перемотати назад"</string>
+  <string name="exo_controls_fastforward_description">"Перемотати вперед"</string>
 </resources>
diff --git a/library/src/main/res/values-ur-rPK/strings.xml b/library/src/main/res/values-ur-rPK/strings.xml
index 002bf8e780..55fa908bcd 100644
--- a/library/src/main/res/values-ur-rPK/strings.xml
+++ b/library/src/main/res/values-ur-rPK/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"پچھلا ٹریک"</string>
-  <string name="next_description">"اگلا ٹریک"</string>
-  <string name="pause_description">"موقوف کریں"</string>
-  <string name="play_description">"چلائیں"</string>
-  <string name="stop_description">"روکیں"</string>
-  <string name="rew_description">"ریوائینڈ کریں"</string>
-  <string name="ffw_description">"تیزی سے فارورڈ کریں"</string>
+  <string name="exo_controls_previous_description">"پچھلا ٹریک"</string>
+  <string name="exo_controls_next_description">"اگلا ٹریک"</string>
+  <string name="exo_controls_pause_description">"موقوف کریں"</string>
+  <string name="exo_controls_play_description">"چلائیں"</string>
+  <string name="exo_controls_stop_description">"روکیں"</string>
+  <string name="exo_controls_rewind_description">"ریوائینڈ کریں"</string>
+  <string name="exo_controls_fastforward_description">"تیزی سے فارورڈ کریں"</string>
 </resources>
diff --git a/library/src/main/res/values-uz-rUZ/strings.xml b/library/src/main/res/values-uz-rUZ/strings.xml
index 5b96983ad5..9cee926844 100644
--- a/library/src/main/res/values-uz-rUZ/strings.xml
+++ b/library/src/main/res/values-uz-rUZ/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Avvalgi musiqa"</string>
-  <string name="next_description">"Keyingi musiqa"</string>
-  <string name="pause_description">"To‘xtatib turish"</string>
-  <string name="play_description">"Ijro qilish"</string>
-  <string name="stop_description">"To‘xtatish"</string>
-  <string name="rew_description">"Orqaga o‘tkazish"</string>
-  <string name="ffw_description">"Oldinga o‘tkazish"</string>
+  <string name="exo_controls_previous_description">"Avvalgi musiqa"</string>
+  <string name="exo_controls_next_description">"Keyingi musiqa"</string>
+  <string name="exo_controls_pause_description">"To‘xtatib turish"</string>
+  <string name="exo_controls_play_description">"Ijro qilish"</string>
+  <string name="exo_controls_stop_description">"To‘xtatish"</string>
+  <string name="exo_controls_rewind_description">"Orqaga o‘tkazish"</string>
+  <string name="exo_controls_fastforward_description">"Oldinga o‘tkazish"</string>
 </resources>
diff --git a/library/src/main/res/values-vi/strings.xml b/library/src/main/res/values-vi/strings.xml
index 2f0dce399a..917ec8e95c 100644
--- a/library/src/main/res/values-vi/strings.xml
+++ b/library/src/main/res/values-vi/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Bản nhạc trước"</string>
-  <string name="next_description">"Bản nhạc tiếp theo"</string>
-  <string name="pause_description">"Tạm dừng"</string>
-  <string name="play_description">"Phát"</string>
-  <string name="stop_description">"Ngừng"</string>
-  <string name="rew_description">"Tua lại"</string>
-  <string name="ffw_description">"Tua đi"</string>
+  <string name="exo_controls_previous_description">"Bản nhạc trước"</string>
+  <string name="exo_controls_next_description">"Bản nhạc tiếp theo"</string>
+  <string name="exo_controls_pause_description">"Tạm dừng"</string>
+  <string name="exo_controls_play_description">"Phát"</string>
+  <string name="exo_controls_stop_description">"Ngừng"</string>
+  <string name="exo_controls_rewind_description">"Tua lại"</string>
+  <string name="exo_controls_fastforward_description">"Tua đi"</string>
 </resources>
diff --git a/library/src/main/res/values-zh-rCN/strings.xml b/library/src/main/res/values-zh-rCN/strings.xml
index ebec8de267..41e02409e2 100644
--- a/library/src/main/res/values-zh-rCN/strings.xml
+++ b/library/src/main/res/values-zh-rCN/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"上一曲"</string>
-  <string name="next_description">"下一曲"</string>
-  <string name="pause_description">"暂停"</string>
-  <string name="play_description">"播放"</string>
-  <string name="stop_description">"停止"</string>
-  <string name="rew_description">"快退"</string>
-  <string name="ffw_description">"快进"</string>
+  <string name="exo_controls_previous_description">"上一曲"</string>
+  <string name="exo_controls_next_description">"下一曲"</string>
+  <string name="exo_controls_pause_description">"暂停"</string>
+  <string name="exo_controls_play_description">"播放"</string>
+  <string name="exo_controls_stop_description">"停止"</string>
+  <string name="exo_controls_rewind_description">"快退"</string>
+  <string name="exo_controls_fastforward_description">"快进"</string>
 </resources>
diff --git a/library/src/main/res/values-zh-rHK/strings.xml b/library/src/main/res/values-zh-rHK/strings.xml
index b97fab76af..a3244bcd70 100644
--- a/library/src/main/res/values-zh-rHK/strings.xml
+++ b/library/src/main/res/values-zh-rHK/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"上一首曲目"</string>
-  <string name="next_description">"下一首曲目"</string>
-  <string name="pause_description">"暫停"</string>
-  <string name="play_description">"播放"</string>
-  <string name="stop_description">"停止"</string>
-  <string name="rew_description">"倒帶"</string>
-  <string name="ffw_description">"向前快轉"</string>
+  <string name="exo_controls_previous_description">"上一首曲目"</string>
+  <string name="exo_controls_next_description">"下一首曲目"</string>
+  <string name="exo_controls_pause_description">"暫停"</string>
+  <string name="exo_controls_play_description">"播放"</string>
+  <string name="exo_controls_stop_description">"停止"</string>
+  <string name="exo_controls_rewind_description">"倒帶"</string>
+  <string name="exo_controls_fastforward_description">"向前快轉"</string>
 </resources>
diff --git a/library/src/main/res/values-zh-rTW/strings.xml b/library/src/main/res/values-zh-rTW/strings.xml
index 7b8552f1b6..ee915c5d9d 100644
--- a/library/src/main/res/values-zh-rTW/strings.xml
+++ b/library/src/main/res/values-zh-rTW/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"上一首曲目"</string>
-  <string name="next_description">"下一首曲目"</string>
-  <string name="pause_description">"暫停"</string>
-  <string name="play_description">"播放"</string>
-  <string name="stop_description">"停止"</string>
-  <string name="rew_description">"倒轉"</string>
-  <string name="ffw_description">"快轉"</string>
+  <string name="exo_controls_previous_description">"上一首曲目"</string>
+  <string name="exo_controls_next_description">"下一首曲目"</string>
+  <string name="exo_controls_pause_description">"暫停"</string>
+  <string name="exo_controls_play_description">"播放"</string>
+  <string name="exo_controls_stop_description">"停止"</string>
+  <string name="exo_controls_rewind_description">"倒轉"</string>
+  <string name="exo_controls_fastforward_description">"快轉"</string>
 </resources>
diff --git a/library/src/main/res/values-zu/strings.xml b/library/src/main/res/values-zu/strings.xml
index 3ed91417f2..e998846454 100644
--- a/library/src/main/res/values-zu/strings.xml
+++ b/library/src/main/res/values-zu/strings.xml
@@ -15,11 +15,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">"Ithrekhi yangaphambilini"</string>
-  <string name="next_description">"Ithrekhi elandelayo"</string>
-  <string name="pause_description">"Misa isikhashana"</string>
-  <string name="play_description">"Dlala"</string>
-  <string name="stop_description">"Misa"</string>
-  <string name="rew_description">"Buyisela emumva"</string>
-  <string name="ffw_description">"Ukudlulisa ngokushesha"</string>
+  <string name="exo_controls_previous_description">"Ithrekhi yangaphambilini"</string>
+  <string name="exo_controls_next_description">"Ithrekhi elandelayo"</string>
+  <string name="exo_controls_pause_description">"Misa isikhashana"</string>
+  <string name="exo_controls_play_description">"Dlala"</string>
+  <string name="exo_controls_stop_description">"Misa"</string>
+  <string name="exo_controls_rewind_description">"Buyisela emumva"</string>
+  <string name="exo_controls_fastforward_description">"Ukudlulisa ngokushesha"</string>
 </resources>
diff --git a/library/src/main/res/values/attrs.xml b/library/src/main/res/values/attrs.xml
index 2aa6fcd86b..d58882c0aa 100644
--- a/library/src/main/res/values/attrs.xml
+++ b/library/src/main/res/values/attrs.xml
@@ -14,9 +14,33 @@
      limitations under the License.
 -->
 <resources>
+
+  <attr name="resize_mode" format="enum">
+    <enum name="fit" value="0"/>
+    <enum name="fixed_width" value="1"/>
+    <enum name="fixed_height" value="2"/>
+  </attr>
+  <attr name="show_timeout" format="integer"/>
+  <attr name="rewind_increment" format="integer"/>
+  <attr name="fastforward_increment" format="integer"/>
+
   <declare-styleable name="SimpleExoPlayerView">
-    <attr name="use_controller" format="boolean" />
-    <attr name="use_texture_view" format="boolean" />
+    <attr name="use_controller" format="boolean"/>
+    <attr name="use_texture_view" format="boolean"/>
+    <attr name="show_timeout"/>
+    <attr name="rewind_increment"/>
+    <attr name="fastforward_increment"/>
+    <attr name="resize_mode"/>
+  </declare-styleable>
+
+  <declare-styleable name="AspectRatioFrameLayout">
+    <attr name="resize_mode"/>
+  </declare-styleable>
+
+  <declare-styleable name="PlaybackControlView">
+    <attr name="show_timeout"/>
+    <attr name="rewind_increment"/>
+    <attr name="fastforward_increment"/>
   </declare-styleable>
-</resources>
 
+</resources>
diff --git a/library/src/main/res/values/strings.xml b/library/src/main/res/values/strings.xml
index 83bb88cc04..1e652dddb3 100644
--- a/library/src/main/res/values/strings.xml
+++ b/library/src/main/res/values/strings.xml
@@ -14,12 +14,11 @@
      limitations under the License.
 -->
 <resources>
-  <string name="prev_description">Previous track</string>
-  <string name="next_description">Next track</string>
-  <string name="pause_description">Pause</string>
-  <string name="play_description">Play</string>
-  <string name="stop_description">Stop</string>
-  <string name="rew_description">Rewind</string>
-  <string name="ffw_description">Fast forward</string>
+  <string name="exo_controls_previous_description">Previous track</string>
+  <string name="exo_controls_next_description">Next track</string>
+  <string name="exo_controls_pause_description">Pause</string>
+  <string name="exo_controls_play_description">Play</string>
+  <string name="exo_controls_stop_description">Stop</string>
+  <string name="exo_controls_rewind_description">Rewind</string>
+  <string name="exo_controls_fastforward_description">Fast forward</string>
 </resources>
-
diff --git a/library/src/main/res/values/styles.xml b/library/src/main/res/values/styles.xml
index 18109e581c..fe1e26e967 100644
--- a/library/src/main/res/values/styles.xml
+++ b/library/src/main/res/values/styles.xml
@@ -15,31 +15,30 @@
 -->
 <resources>
 
-  <style name="MediaButton">
+  <style name="ExoMediaButton">
     <item name="android:background">@null</item>
     <item name="android:layout_width">71dip</item>
     <item name="android:layout_height">52dip</item>
   </style>
 
-  <style name="MediaButton.Previous">
-    <item name="android:src">@drawable/ic_media_previous</item>
-    <item name="android:contentDescription">@string/prev_description</item>
+  <style name="ExoMediaButton.Previous">
+    <item name="android:src">@drawable/exo_controls_previous</item>
+    <item name="android:contentDescription">@string/exo_controls_previous_description</item>
   </style>
 
-  <style name="MediaButton.Next">
-    <item name="android:src">@drawable/ic_media_next</item>
-    <item name="android:contentDescription">@string/next_description</item>
+  <style name="ExoMediaButton.Next">
+    <item name="android:src">@drawable/exo_controls_next</item>
+    <item name="android:contentDescription">@string/exo_controls_next_description</item>
   </style>
 
-  <style name="MediaButton.Ffwd">
-    <item name="android:src">@drawable/ic_media_ff</item>
-    <item name="android:contentDescription">@string/ffw_description</item>
+  <style name="ExoMediaButton.FastForward">
+    <item name="android:src">@drawable/exo_controls_fastforward</item>
+    <item name="android:contentDescription">@string/exo_controls_fastforward_description</item>
   </style>
 
-  <style name="MediaButton.Rew">
-    <item name="android:src">@drawable/ic_media_rew</item>
-    <item name="android:contentDescription">@string/rew_description</item>
+  <style name="ExoMediaButton.Rewind">
+    <item name="android:src">@drawable/exo_controls_rewind</item>
+    <item name="android:contentDescription">@string/exo_controls_rewind_description</item>
   </style>
 
 </resources>
-
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 38e8491b31..6a10654af7 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.playbacktests"
-    android:versionCode="2000"
-    android:versionName="2.0.0">
+    android:versionCode="2004"
+    android:versionName="2.0.4">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
index 2c36140498..d9eade1c2f 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
@@ -19,6 +19,8 @@
 import android.media.MediaDrm;
 import android.media.UnsupportedSchemeException;
 import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
@@ -801,7 +803,7 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
 
     private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
         boolean canIncludeAdditionalVideoFormats) {
-      super(null);
+      super(new Handler(Looper.getMainLooper()));
       this.audioFormatId = audioFormatId;
       this.videoFormatIds = videoFormatIds;
       this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
index 090d8549be..5cb11fdd81 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
@@ -84,7 +84,7 @@ private FakeExtractorInput(byte[] data, boolean simulateUnknownLength,
    * @param position The position to set.
    */
   public void setPosition(int position) {
-    Assert.assertTrue(0 <= position && position < data.length);
+    Assert.assertTrue(0 <= position && position <= data.length);
     readPosition = position;
     peekPosition = position;
   }
@@ -203,7 +203,7 @@ private boolean checkXFully(boolean allowEndOfInput, int position, int length,
       peekPosition = readPosition;
       throw new SimulatedIOException("Simulated IO error at position: " + position);
     }
-    if (isEof()) {
+    if (length > 0 && position == data.length) {
       if (allowEndOfInput) {
         return false;
       }
@@ -217,6 +217,10 @@ private boolean checkXFully(boolean allowEndOfInput, int position, int length,
   }
 
   private int getReadLength(int requestedLength) {
+    if (readPosition == data.length) {
+      // If the requested length is non-zero, the end of the input will be read.
+      return requestedLength == 0 ? 0 : Integer.MAX_VALUE;
+    }
     int targetPosition = readPosition + requestedLength;
     if (simulatePartialReads && requestedLength > 1
         && !partiallySatisfiedTargetPositions.get(targetPosition)) {
@@ -226,10 +230,6 @@ private int getReadLength(int requestedLength) {
     return Math.min(requestedLength, data.length - readPosition);
   }
 
-  private boolean isEof() {
-    return readPosition == data.length;
-  }
-
   /**
    * Builder of {@link FakeExtractorInput} instances.
    */
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
index b0ab90789c..3716c6d37f 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
@@ -23,7 +23,6 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 import junit.framework.Assert;
-import junit.framework.TestCase;
 
 /**
  * A fake {@link ExtractorOutput}.
@@ -37,8 +36,6 @@
    */
   private static final boolean WRITE_DUMP = false;
 
-  private final boolean allowDuplicateTrackIds;
-
   public final SparseArray<FakeTrackOutput> trackOutputs;
 
   public int numberOfTracks;
@@ -46,11 +43,6 @@
   public SeekMap seekMap;
 
   public FakeExtractorOutput() {
-    this(false);
-  }
-
-  public FakeExtractorOutput(boolean allowDuplicateTrackIds) {
-    this.allowDuplicateTrackIds = allowDuplicateTrackIds;
     trackOutputs = new SparseArray<>();
   }
 
@@ -58,11 +50,10 @@ public FakeExtractorOutput(boolean allowDuplicateTrackIds) {
   public FakeTrackOutput track(int trackId) {
     FakeTrackOutput output = trackOutputs.get(trackId);
     if (output == null) {
+      Assert.assertFalse(tracksEnded);
       numberOfTracks++;
       output = new FakeTrackOutput();
       trackOutputs.put(trackId, output);
-    } else {
-      TestCase.assertTrue("Duplicate track id: " + trackId, allowDuplicateTrackIds);
     }
     return output;
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
index a66e13cfd6..b399d79e8d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
@@ -88,7 +88,8 @@ public void sampleData(ParsableByteArray data, int length) {
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+      byte[] encryptionKey) {
     sampleTimesUs.add(timeUs);
     sampleFlags.add(flags);
     sampleStartOffsets.add(sampleData.length - offset - size);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 7b88062718..6f4578b694 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -267,8 +267,8 @@ public static void assertOutput(ExtractorFactory factory, String sampleFile, byt
    */
   public static FakeExtractorOutput assertOutput(Extractor extractor, String sampleFile,
       byte[] fileData, Instrumentation instrumentation, boolean simulateIOErrors,
-      boolean simulateUnknownLength,
-      boolean simulatePartialReads) throws IOException, InterruptedException {
+      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
+      InterruptedException {
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(fileData)
         .setSimulateIOErrors(simulateIOErrors)
         .setSimulateUnknownLength(simulateUnknownLength)
