diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
index f5644ab..3cda44a 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
@@ -26,12 +26,17 @@
     private Set<String> readonlyTags;
 
     private transient int currentRunCount;
-    private transient int priority;
+    transient int priority;
     private transient long delayInMs;
     transient boolean cancelled;
 
     private transient Context applicationContext;
 
+    /**
+     * Only set if a job fails. Will be cleared by JobManager after it is handled
+     */
+    transient RetryConstraint retryConstraint;
+
 
     protected Job(Params params) {
         this.requiresNetwork = params.doesRequireNetwork();
@@ -45,7 +50,6 @@ protected Job(Params params) {
 
     /**
      * used by {@link JobManager} to assign proper priority at the time job is added.
-     * This field is not preserved!
      * @return priority (higher = better)
      */
     public final int getPriority() {
@@ -54,7 +58,7 @@ public final int getPriority() {
 
     /**
      * used by {@link JobManager} to assign proper delay at the time job is added.
-     * This field is not preserved!
+     * This field is not persisted!
      * @return delay in ms
      */
     public final long getDelayInMs() {
@@ -120,7 +124,8 @@ public final boolean isPersistent() {
 
     /**
      * The actual method that should to the work.
-     * It should finish w/o any exception. If it throws any exception, {@code shouldReRunOnThrowable} will be called to
+     * It should finish w/o any exception. If it throws any exception,
+     * {@link #shouldReRunOnThrowable(Throwable, int, int)} will be called to
      * decide either to dismiss the job or re-run it.
      * @throws Throwable
      */
@@ -131,12 +136,42 @@ public final boolean isPersistent() {
      */
     abstract protected void onCancel();
 
+    /**
+     * @deprecated use {@link #shouldReRunOnThrowable(Throwable, int, int)}
+     * This method will be removed in v2.0 and {@link #shouldReRunOnThrowable(Throwable, int, int)}
+     * will become abstract.
+     */
+    @Deprecated
+    protected boolean shouldReRunOnThrowable(Throwable throwable) {
+        return true;
+    }
+
     /**
      * If {@code onRun} method throws an exception, this method is called.
-     * return true if you want to run your job again, return false if you want to dismiss it. If you return false,
-     * onCancel will be called.
+     * <p>
+     * If you simply want to return retry or cancel, you can use {@link RetryConstraint#RETRY} or
+     * {@link RetryConstraint#CANCEL}.
+     * <p>
+     * You can also use a custom {@link RetryConstraint} where you can change the Job's priority or
+     * add a delay until the next run (e.g. exponential back off).
+     * <p>
+     * Note that changing the Job's priority or adding a delay may alter the original run order of
+     * the job. So if the job was added to the queue with other jobs and their execution order is
+     * important (e.g. they use the same groupId), you should not change job's priority or add a
+     * delay unless you really want to change their execution order.
+     *
+     * @param throwable The exception that was thrown from {@link #onRun()}
+     * @param runCount The number of times this job run. Starts from 1.
+     * @param maxRunCount The max number of times this job can run. Decided by {@link #getRetryLimit()}
+     * @return A {@link RetryConstraint} to decide whether this Job should be tried again or not and
+     * if yes, whether we should add a delay or alter its priority. Returning null from this method
+     * is equal to returning {@link RetryConstraint#RETRY}. Default implementation calls
+     * {@link #shouldReRunOnThrowable(Throwable)}.
      */
-    abstract protected boolean shouldReRunOnThrowable(Throwable throwable);
+    protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
+        boolean reRun = shouldReRunOnThrowable(throwable);
+        return reRun ? RetryConstraint.RETRY : RetryConstraint.CANCEL;
+    }
 
     /**
      * Runs the job and catches any exception
@@ -161,7 +196,13 @@ final int safeRun(JobHolder holder, int currentRunCount) {
             reRun = currentRunCount < getRetryLimit();
             if(reRun && !cancelled) {
                 try {
-                    reRun = shouldReRunOnThrowable(t);
+                    RetryConstraint retryConstraint = shouldReRunOnThrowable(t, currentRunCount,
+                            getRetryLimit());
+                    if (retryConstraint == null) {
+                        retryConstraint = RetryConstraint.RETRY;
+                    }
+                    this.retryConstraint = retryConstraint;
+                    reRun = retryConstraint.shouldRetry();
                 } catch (Throwable t2) {
                     JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
                 }
@@ -215,7 +256,7 @@ public final String getRunGroupId() {
 
     /**
      * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
-     * If job fails this many times, onCancel will be called w/o calling {@code shouldReRunOnThrowable}
+     * If job fails this many times, onCancel will be called w/o calling {@link #shouldReRunOnThrowable(Throwable, int, int)}
      * @return
      */
     protected int getRetryLimit() {
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
index bbcd272..ba73f4d 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
@@ -68,6 +68,7 @@ public JobHolder(Long id, int priority, String groupId, int runCount, Job job, l
         this.createdNs = createdNs;
         this.delayUntilNs = delayUntilNs;
         this.job = job;
+        job.priority = priority;
         this.runningSessionId = runningSessionId;
         this.requiresNetwork = job.requiresNetwork();
         this.tags = job.getTags() == null ? null : Collections.unmodifiableSet(job.getTags());
@@ -108,6 +109,11 @@ public int getPriority() {
 
     public void setPriority(int priority) {
         this.priority = priority;
+        this.job.priority = this.priority;
+    }
+
+    void setDelayUntilNs(long delayUntilNs) {
+        this.delayUntilNs = delayUntilNs;
     }
 
     public int getRunCount() {
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index e3c1ea0..30846c9 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -652,6 +652,21 @@ public boolean isRunning() {
 
         @Override
         public void insertOrReplace(JobHolder jobHolder) {
+            RetryConstraint retryConstraint = jobHolder.getJob().retryConstraint;
+            if (retryConstraint == null) {
+                reAddJob(jobHolder);
+                return;
+            }
+            if (retryConstraint.getNewPriority() != null) {
+                jobHolder.setPriority(retryConstraint.getNewPriority());
+            }
+            long delay = -1;
+            if (retryConstraint.getNewDelayInMs() != null) {
+                delay = retryConstraint.getNewDelayInMs();
+            }
+            jobHolder.setDelayUntilNs(
+                    delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY
+            );
             reAddJob(jobHolder);
         }
 
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
new file mode 100644
index 0000000..d7ccd83
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
@@ -0,0 +1,52 @@
+package com.path.android.jobqueue;
+
+/**
+ * Created when a job fails in onRun method.
+ * <p>
+ *
+ */
+public class RetryConstraint {
+    public static final RetryConstraint RETRY = new RetryConstraint(true);
+    public static final RetryConstraint CANCEL = new RetryConstraint(false);
+    private boolean retry;
+    private Long newDelayInMs;
+    private Integer newPriority;
+
+    public RetryConstraint(boolean retry) {
+        this.retry = retry;
+    }
+
+    public static RetryConstraint simpleResult(boolean reRun) {
+        return reRun ? RETRY : CANCEL;
+    }
+
+    public boolean shouldRetry() {
+        return retry;
+    }
+
+    public void setRetry(boolean retry) {
+        this.retry = retry;
+    }
+
+    public Long getNewDelayInMs() {
+        return newDelayInMs;
+    }
+
+    public void setNewDelayInMs(Long newDelayInMs) {
+        this.newDelayInMs = newDelayInMs;
+    }
+
+    public Integer getNewPriority() {
+        return newPriority;
+    }
+
+    public void setNewPriority(Integer newPriority) {
+        this.newPriority = newPriority;
+    }
+
+    public static RetryConstraint createExponentialBackoff(int runCount, long initialBackOffInMs) {
+        RetryConstraint constraint = new RetryConstraint(true);
+        constraint.setNewDelayInMs((long) Math.pow(initialBackOffInMs, runCount));
+        return constraint;
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
new file mode 100644
index 0000000..64b31bd
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
@@ -0,0 +1,342 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.RetryConstraint;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class RetryLogicTest extends JobManagerTestBase {
+
+    static RetryProvider retryProvider;
+
+    static boolean canRun;
+
+    static int runCount;
+
+    static CountDownLatch onRunLatch;
+
+    static Callback onRunCallback;
+
+    static CountDownLatch cancelLatch;
+
+    @Before
+    public void clear() {
+        retryProvider = null;
+        canRun = false;
+        runCount = 0;
+        onRunLatch = null;
+        onRunCallback = null;
+        cancelLatch = new CountDownLatch(1);
+    }
+
+    @Test
+    public void testExponential() {
+        assertThat("exp 1",RetryConstraint.createExponentialBackoff(1, 10).getNewDelayInMs(), is(10L));
+        assertThat("exp 2",RetryConstraint.createExponentialBackoff(2, 10).getNewDelayInMs(), is(
+                100L));
+        assertThat("exp 3",RetryConstraint.createExponentialBackoff(3, 10).getNewDelayInMs(), is(
+                1000L));
+    }
+
+    @Test
+    public void testRunCountPersistent() throws InterruptedException {
+        testFirstRunCount(true);
+    }
+
+    @Test
+    public void testRunCountNonPersistent() throws InterruptedException {
+        testFirstRunCount(false);
+    }
+
+    public void testFirstRunCount(boolean persistent) throws InterruptedException {
+        final AtomicInteger runCnt = new AtomicInteger(0);
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                assertThat("run count should match", ((RetryJob) job).getCurrentRunCount(),
+                        is(runCnt.incrementAndGet()));
+            }
+        };
+        canRun = true;
+        RetryJob job = new RetryJob(new Params(0));
+        job.retryLimit = 10;
+        createJobManager().addJob(job);
+        assertThat("", cancelLatch.await(4, TimeUnit.SECONDS), is(true));
+        assertThat("", runCount, is(10));
+    }
+
+    @Test
+    public void testChangeDelayPersistent() throws InterruptedException {
+        testChangeDelay(true);
+    }
+
+    @Test
+    public void testChangeDelayNonPersistent() throws InterruptedException {
+        testChangeDelay(false);
+    }
+
+    public void testChangeDelay(boolean persistent) throws InterruptedException {
+        canRun = true;
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 2;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount,
+                    int maxRunCount) {
+                RetryConstraint constraint = new RetryConstraint(true);
+                constraint.setNewDelayInMs(2000L);
+                return constraint;
+            }
+        };
+        final List<Long> runTimes = new ArrayList<>();
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                runTimes.add(System.nanoTime());
+            }
+        };
+        createJobManager().addJob(job);
+        assertThat("job should be canceled", cancelLatch.await(4, TimeUnit.SECONDS), is(true));
+        assertThat("should run 2 times", runCount, is(2));
+        long timeInBetween = TimeUnit.NANOSECONDS.toSeconds(runTimes.get(1) - runTimes.get(0));
+        assertThat("time between two runs should be at least 2 seconds. " + timeInBetween,
+                 2 <= timeInBetween, is(true));
+    }
+
+    @Test
+    public void testChangePriorityAndObserveExecutionOrderPersistent() throws InterruptedException {
+        testChangePriorityAndObserveExecutionOrder(true);
+    }
+
+    @Test
+    public void testChangePriorityAndObserveExecutionOrderNonPersistent()
+            throws InterruptedException {
+        testChangePriorityAndObserveExecutionOrder(false);
+    }
+
+    public void testChangePriorityAndObserveExecutionOrder(boolean persistent)
+            throws InterruptedException {
+        cancelLatch = new CountDownLatch(2);
+        RetryJob job1 = new RetryJob(new Params(10).setPersistent(persistent).groupBy("group"));
+        job1.identifier = "1";
+        RetryJob job2 = new RetryJob(new Params(5).setPersistent(persistent).groupBy("group"));
+        job2.identifier = "2";
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        jobManager.addJob(job1);
+        jobManager.addJob(job2);
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount,
+                    int maxRunCount) {
+                RetryJob retryJob = (RetryJob) job;
+                if ("1".equals(retryJob.identifier)) {
+                    if (retryJob.getPriority() == 1) {
+                        return RetryConstraint.CANCEL;
+                    }
+                    RetryConstraint retryConstraint = new RetryConstraint(true);
+                    retryConstraint.setNewPriority(1);
+                    return retryConstraint;
+                } else {
+                    return RetryConstraint.CANCEL;
+                }
+            }
+        };
+        final List<String> runOrder = new ArrayList<>();
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                runOrder.add(((RetryJob) job).identifier);
+            }
+        };
+        canRun = true;
+        jobManager.start();
+        assertThat("both jobs should be canceled eventually", cancelLatch.await(3, TimeUnit.MINUTES)
+                , is(true));
+        assertThat("jobs should run a total of 3 times", runCount, is(3));
+        final List<String> expectedRunOrder = Arrays.asList("1", "2", "1");
+        assertThat("expected run order count should match", runOrder.size(), is(expectedRunOrder.size()));
+        for (int i = 0; i < expectedRunOrder.size(); i++) {
+            assertThat("at iteration " + i + ", this job should run",
+                    runOrder.get(i), is(expectedRunOrder.get(i)));
+        }
+    }
+
+    @Test
+    public void testChangePriorityPersistent() throws InterruptedException {
+        testChangePriority(true);
+    }
+
+    @Test
+    public void testChangePriorityNonPersistent() throws InterruptedException {
+        testChangePriority(false);
+    }
+
+    @Ignore
+    public void testChangePriority(boolean persistent) throws InterruptedException {
+        final AtomicInteger priority = new AtomicInteger(1);
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                RetryConstraint constraint = new RetryConstraint(true);
+                priority.set(job.getPriority() * 2);
+                constraint.setNewPriority(priority.get());
+                return constraint;
+            }
+        };
+
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                assertThat("priority should be the expected value", job.getPriority(), is(priority.get()));
+            }
+        };
+        RetryJob retryJob = new RetryJob(new Params(priority.get()).setPersistent(persistent));
+        retryJob.retryLimit = 3;
+        canRun = true;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(retryJob);
+        assertThat(onRunLatch.await(5, TimeUnit.SECONDS), is(true));
+        assertThat("it should run 3 times", runCount, is(3));
+        assertThat(cancelLatch.await(5, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void testCancelPersistent() throws InterruptedException {
+        testCancel(true);
+    }
+
+    @Test
+    public void testCancelNonPersistent() throws InterruptedException {
+        testCancel(false);
+    }
+
+    public void testCancel(boolean persistent) throws InterruptedException {
+        canRun = true;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                return RetryConstraint.CANCEL;
+            }
+        };
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 3;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(job);
+        assertThat(onRunLatch.await(2, TimeUnit.SECONDS), is(false));
+        assertThat("it should run 1 time", runCount, is(1));
+        assertThat(cancelLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void retryPersistent() throws InterruptedException {
+        testRetry(true, true);
+    }
+
+    @Test
+    public void retryNonPersistent() throws InterruptedException {
+        testRetry(false, true);
+    }
+
+    @Test
+    public void retryPersistentWithNull() throws InterruptedException {
+        testRetry(true, false);
+    }
+
+    @Test
+    public void retryNonPersistentWithNull() throws InterruptedException {
+        testRetry(false, false);
+    }
+
+    public void testRetry(boolean persistent, final boolean returnTrue) throws InterruptedException {
+        canRun = true;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                return returnTrue ? RetryConstraint.RETRY : null;
+            }
+        };
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 3;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(job);
+        assertThat(onRunLatch.await(2, TimeUnit.SECONDS), is(true));
+        assertThat("it should run 3 times", runCount, is(3));
+        assertThat(cancelLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    public static class RetryJob extends Job {
+        int retryLimit = 5;
+        String identifier;
+        protected RetryJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            assertThat("should be allowed to run", canRun, is(true));
+            if (onRunCallback != null) {
+                onRunCallback.on(this);
+            }
+            runCount++;
+            if (onRunLatch != null) {
+                onRunLatch.countDown();
+            }
+            throw new RuntimeException("i like to fail please");
+        }
+
+        @Override
+        protected int getRetryLimit() {
+            return retryLimit;
+        }
+
+        @Override
+        protected void onCancel() {
+            cancelLatch.countDown();
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount,
+                int maxRunCount) {
+            return retryProvider.build(this, throwable, runCount, maxRunCount);
+        }
+
+        @Override
+        public int getCurrentRunCount() {
+            return super.getCurrentRunCount();
+        }
+    }
+
+    interface RetryProvider {
+        RetryConstraint build(Job job, Throwable throwable, int runCount,
+                int maxRunCount);
+    }
+
+    interface Callback {
+        public void on(Job job);
+    }
+}
