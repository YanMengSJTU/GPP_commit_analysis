diff --git a/.gitignore b/.gitignore
index 631f182..b5b1921 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,6 +15,9 @@ gen/
 # Local configuration file (sdk path, etc)
 local.properties
 
+# release configuration
+releaseConfig.properties
+
 # Eclipse project files
 .classpath
 .project
@@ -33,5 +36,3 @@ out
 pages
 .gradle
 build
-
-jobqueue/.settings/org.eclipse.jdt.core.prefs
diff --git a/README.md b/README.md
index c3be0e8..8c014c8 100644
--- a/README.md
+++ b/README.md
@@ -15,8 +15,7 @@ It is written primarily with [flexibility][10] & [functionality][11] in mind. Th
   - [Advantages](#advantages)
   - [Getting Started](#getting-started)
   - [Version History](#version-history)
-  - [Building](#building)
-   - [Running Tests](#running-tests)
+  - [Running Tests](#running-tests)
   - [wiki][9]
   - [Dependencies](#dependencies)
   - [License](#license)
@@ -41,7 +40,7 @@ Although not required, it is most useful when used with an event bus. It also su
 
 Since a code example is worth thousands of documentation pages, here it is.
 
-File: [PostTweetJob.java](https://github.com/path/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java)
+File: [PostTweetJob.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java)
 ``` java
 // A job to send a tweet
 public class PostTweetJob extends Job {
@@ -64,9 +63,12 @@ public class PostTweetJob extends Job {
         webservice.postTweet(text);
     }
     @Override
-    protected boolean shouldReRunOnThrowable(Throwable throwable) {
+    protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount,
+            int maxRunCount) {
         // An error occurred in onRun.
-        // Return value determines whether this job should retry running (true) or abort (false).
+        // Return value determines whether this job should retry or cancel. You can further
+        // specifcy a backoff strategy or change the job's priority.
+        return RetryConstraint.createExponentialBackoff(runCount, 1000);
     }
     @Override
     protected void onCancel() {
@@ -77,7 +79,7 @@ public class PostTweetJob extends Job {
 
 ```
 
-File: [TweetActivity.java](https://github.com/path/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java#L53)
+File: [TweetActivity.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java#L53)
 ``` java
 //...
 public void onSendClick() {
@@ -129,15 +131,15 @@ At Path, we use [greenrobot's EventBus](https://github.com/greenrobot/EventBus);
 ### Getting Started
 We distribute artifacts through maven central repository.
 
-Gradle: `compile 'com.path:android-priority-jobqueue:1.1.2'`
+Gradle: `compile 'com.birbit:android-priority-jobqueue:1.3.3'`
 
 Maven:
 
 ``` xml
 <dependency>
-    <groupId>com.path</groupId>
+    <groupId>com.birbit</groupId>
     <artifactId>android-priority-jobqueue</artifactId>
-    <version>1.1.2</version>
+    <version>1.3.3</version>
 </dependency>
 ```
 
@@ -150,6 +152,19 @@ We highly recommend checking how you can configure job manager and individual jo
 * [Review sample configuration][7]
 
 ### Version History
+  - 1.3.3 (July 12, 2015)
+   - Fixed default exponential backoff. Issue #33
+  - 1.3.2 (July 5, 2015)
+   - Added ability to change a Job's priority or add delay before it is retried. This mechanism can be used to add exponential backoff to jobs.
+   - Added `Job#getApplicationContext` as a convenience method to get the Context inside a Job.
+  - 1.3.1 (April 19, 2015)
+   - Fixed issue #19 which was blocking a group forever if a job from that group is cancelled while running and then onRun fails.
+   - Updated Robolectric version and moved all testing to Gradle.
+   - Goodbye Cobertura, Welcome Jacoco!
+  - 1.3 (March 23, 2015)
+   - Ability to add tags to jobs. These tags can be used to later retrieve jobs.
+   - Added long awaited job cancellation. You can use tags to cancel jobs.
+   - Removed deprecated BaseJob class. This may break backward compatibility.
   - 1.1.2 (Feb 18, 2014)
    - Report exceptions to logger if addInBackground fails. (#31)
   - 1.1.1 (Feb 8, 2014)
@@ -174,24 +189,22 @@ We highly recommend checking how you can configure job manager and individual jo
 - - [Fest Util](http://easytesting.org/) ([license](http://www.apache.org/licenses/LICENSE-2.0))
 - - [Hamcrest](https://code.google.com/p/hamcrest/) ([license](http://opensource.org/licenses/BSD-3-Clause))
 - For code coverage report, we use:
-- - [Cobertura](http://cobertura.github.io/cobertura/) ([license](https://github.com/cobertura/cobertura/blob/master/LICENSE.txt/))
 - Sample Twitter client uses:
 - - [Twitter4j](http://twitter4j.org/en)
 - - [EventBus](https://github.com/greenrobot/EventBus)
 - - [Path's fork of greenDAO](https://github.com/path/greenDAO) . ([original repo](https://github.com/greenrobot/greenDAO))
 
 ### Building
-We are in the process of moving build system from ant to gradle. Right now, you can build with gradle but if you want to run tests, you'll need ant.
 
 * Clone the repo
 * `> cd jobqueue`
-* `> ant clean build-jar`
+* `> ./gradlew clean assembleDebug assembleDebugUnitTest test`
 *
 This will create a jar file under _release_ folder.
 
 #### Running Tests
 * > `cd jobqueue`
-* > `ant clean test`
+* > `./gradlew clean assembleDebug assembleDebugUnitTest test`
 
 
 ## License
@@ -202,6 +215,7 @@ Android Priority Jobqueue is made available under the [MIT license](http://opens
 The MIT License (MIT)
 
 Copyright (c) 2013 Path, Inc.
+Copyright (c) 2014 Google, Inc.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -223,15 +237,15 @@ THE SOFTWARE.
 </pre>
 
 
-[1]: https://github.com/path/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkUtil.java
-[2]: https://github.com/path/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkEventProvider.java
-[3]: http://path.github.io/android-priority-jobqueue/coverage-report/index.html
-[4]: http://path.github.io/android-priority-jobqueue/javadoc/index.html
+[1]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkUtil.java
+[2]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkEventProvider.java
+[3]: http://yigit.github.io/android-priority-jobqueue/coverage-report/index.html
+[4]: http://yigit.github.io/android-priority-jobqueue/javadoc/index.html
 [5]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22android-priority-jobqueue%22
-[6]: https://github.com/path/android-priority-jobqueue/tree/master/examples
-[7]: https://github.com/path/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java#L26
+[6]: https://github.com/yigit/android-priority-jobqueue/tree/master/examples
+[7]: https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java#L26
 [8]: http://www.youtube.com/watch?v=xHXn3Kg2IQE
-[9]: https://github.com/path/android-priority-jobqueue/wiki
-[10]: https://github.com/path/android-priority-jobqueue/wiki/Job-Manager-Configuration
-[11]: https://github.com/path/android-priority-jobqueue/wiki/Job-Configuration
-[12]: https://github.com/path/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/Params.java
+[9]: https://github.com/yigit/android-priority-jobqueue/wiki
+[10]: https://github.com/yigit/android-priority-jobqueue/wiki/Job-Manager-Configuration
+[11]: https://github.com/yigit/android-priority-jobqueue/wiki/Job-Configuration
+[12]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/Params.java
diff --git a/build.gradle b/build.gradle
index 6356aab..45b57de 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,10 +2,11 @@
 
 buildscript {
     repositories {
+        mavenCentral()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:1.2.3'
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
@@ -14,6 +15,7 @@ buildscript {
 
 allprojects {
     repositories {
+        mavenCentral()
         jcenter()
     }
 }
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
index 2276788..0168987 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
@@ -1,6 +1,5 @@
 package com.path.android.jobqueue.examples.twitter.jobs;
 
-import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
index a83ef66..2c77dd8 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
@@ -1,6 +1,5 @@
 package com.path.android.jobqueue.examples.twitter.jobs;
 
-import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
diff --git a/gradle.properties b/gradle.properties
deleted file mode 100644
index 1d3591c..0000000
--- a/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Gradle settings configured through the IDE *will override*
-# any settings specified in this file.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64..0000000
Binary files a/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/jobqueue/LICENSE.txt b/jobqueue/LICENSE.txt
index bde5e4c..4c405ad 100644
--- a/jobqueue/LICENSE.txt
+++ b/jobqueue/LICENSE.txt
@@ -1,6 +1,7 @@
 The MIT License (MIT)
 
 Copyright (c) 2013 Path, Inc.
+Copyright (c) 2014 Google, Inc.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 0a9c500..6806b5d 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -1,30 +1,181 @@
+import java.util.regex.Pattern
+
 apply plugin: 'com.android.library'
 
+/*Properties releaseConfig = new Properties()
+releaseConfig.load(new FileInputStream("${projectDir}/releaseConfig.properties"))
+ext.releaseConfig = releaseConfig*/
+task wrapper(type: Wrapper) {
+    gradleVersion = '2.2.1'
+}
+
+apply plugin: 'maven'
+apply plugin: 'signing'
+apply plugin: 'jacoco'
+
+configurations {
+    archives {
+        extendsFrom configurations.default
+    }
+}
+
+dependencies {
+    testCompile 'junit:junit:4.12'
+    testCompile "org.robolectric:robolectric:3.0-rc3"
+    testCompile 'org.hamcrest:hamcrest-core:1.3'
+    testCompile 'org.easytesting:fest-util:1.2.5'
+    testCompile 'org.easytesting:fest-reflect:1.4.1'
+
+}
+
+
+
 android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.2"
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            java.srcDirs = ['src']
-            res.srcDirs = ['res']
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
+    buildTypes {
+        debug {
+            testCoverageEnabled = true
         }
     }
+
     defaultConfig {
-        minSdkVersion 8
-        targetSdkVersion 21
-        versionCode 1
-        versionName "1.0"
+        minSdkVersion 7
+        targetSdkVersion 22
     }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'
-        }
+}
+
+//READ VERSION NAME
+def manifestFile = file("${projectDir}/src/main/AndroidManifest.xml")
+def pattern = Pattern.compile("versionName=\"([\\d\\.\\w\\-]+)\"")
+def manifestText = manifestFile.getText()
+def matcher = pattern.matcher(manifestText)
+matcher.find()
+def manifestVersionName = matcher.group(1)
+println "version name:${manifestVersionName}"
+
+//create jar tasks
+android.libraryVariants.all { variant ->
+    def name = variant.buildType.name
+    println "checking variant ${name}"
+    if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
+        return; // Skip debug builds.
+    }
+    def suffix = name.capitalize()
+    println "found release variant"
+    def jarTask = project.tasks.create(name: "jar${suffix}", type: Jar){
+        dependsOn variant.javaCompile
+        from variant.javaCompile.destinationDir
+        from 'LICENSE.txt'
+    }
+    def javadocTask = project.tasks.create(name: "javadoc${suffix}", type: Javadoc) {
+        source = variant.javaCompile.source
+        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
+        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+    }
+
+    def javadocJarTask = project.tasks.create(name: "javadocJar${suffix}", type: Jar) {
+        classifier = 'javadoc'
+        from 'build/docs/javadoc'
     }
+
+    def sourcesJarTask = project.tasks.create(name: "sourceJar${suffix}", type: Jar) {
+        from android.sourceSets.main.getJava().getSrcDirs()
+        classifier = 'sources'
+    }
+    artifacts.add('archives', jarTask);
+    artifacts.add('archives', javadocJarTask);
+    artifacts.add('archives', sourcesJarTask);
 }
+//create jar tasks end
+
+/*afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment {
+                    MavenDeployment deployment -> signing.signPom(deployment)
+                }
+                println "ossr username: ${releaseConfig.ossrhUsername}"
+
+                pom.artifactId = 'android-priority-jobqueue'
+
+
+                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots") {
+                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
+                }
+
+                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2") {
+                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
+                }
+
+                pom.project {
+                    modelVersion '4.0.0'
+                    groupId 'com.birbit'
+                    artifactId 'android-priority-jobqueue'
+                    packaging 'jar'
+                    name 'Android Priority Job Queue'
+                    version manifestVersionName
+                    description 'a Job Queue specifically written for Android to easily schedule jobs (tasks) that run in the background, improving UX and application stability.'
+                    url 'https://github.com/yigit/android-priority-jobqueue'
+
+                    parent {
+                        groupId 'org.sonatype.oss'
+                        artifactId 'oss-parent'
+                        version 7
+                    }
+
+                    scm {
+                        connection 'scm:git:git@github.com:yigit/android-priority-jobqueue.git'
+                        developerConnection 'scm:git:git@github.com:yigit/android-priority-jobqueue.git'
+                        url 'git@github.com:yigit/android-priority-jobqueue.git'
+                    }
+
+                    licenses {
+                        license {
+                            name 'The MIT License (MIT)'
+                            url 'http://opensource.org/licenses/MIT'
+                            distribution 'repo'
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id "yigit"
+                            name "Yigit Boyar"
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+}*/
+
+task jacocoTestReport(type:JacocoReport, dependsOn: "testDebug") {
+    group = "Reporting"
+
+    description = "Generate Jacoco coverage reports"
+
+    classDirectories = fileTree(
+            dir: "$buildDir/intermediates/classes/debug",
+            excludes: ['**/R.class',
+                       '**/R$*.class',
+                       '**/BuildConfig.*',
+                       '**/Manifest*.*']
+    )
+
+    additionalSourceDirs = files(android.sourceSets.main.getJava().getSrcDirs())
+    sourceDirectories = files(android.sourceSets.main.getJava().getSrcDirs())
+    executionData = files("$buildDir/jacoco/testDebug.exec")
+
+    reports {
+        xml.enabled = true
+        html.enabled = true
+    }
 
-dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
 }
\ No newline at end of file
diff --git a/jobqueue/build.xml b/jobqueue/build.xml
deleted file mode 100644
index 279be48..0000000
--- a/jobqueue/build.xml
+++ /dev/null
@@ -1,261 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="jobqueue" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties"/>
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties"/>
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env"/>
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME"/>
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties"/>
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-            />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <!-- <import file="custom_rules.xml" optional="true" /> -->
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml"/>
-
-
-    <property name="test.absolute.dir" location="${test.dir}"/>
-    <property name="out.test-classes.dir" value="${out.absolute.dir}/testClasses"/>
-    <property name="out.test-classes.absolute.dir" value="${out.test-classes.dir}"/>
-    <property name="test.external.libs.absolute.dir" location="${test.external.libs.dir}"/>
-    <property name="publish.dir" location="${out.absolute.dir}/publish"/>
-
-    <property name="instrumented.dir" value="${out.absolute.dir}/instrumented"/>
-    <property name="cobertura.dir" value="${basedir}/cobertura"/>
-
-    <property name="cobertura.absolute" location="${basedir}/cobertura.ser"/>
-    <property name="instrumented.absolute.dir" location="${instrumented.dir}"/>
-
-    <property name="coverate.report.dir" value="coverage-report"/>
-    <property name="coverate.report.absolute.dir" location="${coverate.report.dir}"/>
-
-    <path id="cobertura.classpath">
-        <fileset dir="${cobertura.dir}">
-            <include name="cobertura.jar"/>
-            <include name="lib/**/*.jar"/>
-        </fileset>
-    </path>
-    <taskdef classpathref="cobertura.classpath" resource="tasks.properties"/>
-
-
-    <property environment="env"/>
-    <condition property="build.number" value="${env.BUILD_NUMBER}" else="unknown">
-        <isset property="env.BUILD_NUMBER"/>
-    </condition>
-    <exec executable="date" outputproperty="build.date"/>
-
-    <target name="-pre-compile">
-        <!-- android uses this property for its generated testing framework. We'll set it manually.-->
-        <property name="tested.project.absolute.dir" location="."/>
-        <property name="tested.project.test.absolute.dir" location="${tested.project.absolute.dir}/test"/>
-        <property name="out.test.classes.absolute.dir" location="${out.dir}/testClasses"/>
-    </target>
-
-    <target name="compile.tests" depends="-set-debug-files, -set-debug-mode, -compile">
-        <mkdir dir="${out.test.classes.absolute.dir}"/>
-
-        <path id="project.javac.classpath">
-            <path refid="project.all.jars.path"/>
-            <path refid="tested.project.classpath"/>
-        </path>
-
-        <javac encoding="${java.encoding}"
-               source="${java.source}"
-               target="${java.target}"
-               debug="true"
-               extdirs=""
-               destdir="${out.test.classes.absolute.dir}"
-               bootclasspathref="project.target.class.path"
-               verbose="${verbose}"
-               classpathref="project.javac.classpath"
-               includeantruntime="false">
-            <src path="${source.absolute.dir}"/>
-            <src path="${gen.absolute.dir}"/>
-            <!-- test src -->
-            <src path="${tested.project.test.absolute.dir}"/>
-            <classpath>
-                <pathelement path="${out.classes.absolute.dir}"/>
-                <fileset dir="${jar.libs.dir}" includes="*.jar"/>
-                <fileset dir="${tested.project.absolute.dir}/test-libs" includes="**/*.jar"/>
-            </classpath>
-        </javac>
-    </target>
-
-    <target name="coverage-report">
-        <cobertura-report format="html" destdir="${coveragereport.dir}" srcdir="${src.dir}"/>
-    </target>
-
-    <target name="build-jar" depends="release" description="builds jar from compiled code">
-        <mkdir dir="release" />
-        <xpath input="AndroidManifest.xml" expression="/manifest/@android:versionName"
-               output="versionName" default="unknown"/>
-        <jar jarfile="release/android-priority-jobqueue-${versionName}.jar">
-            <fileset dir="${out.dir}/classes">
-                <include name="com/path/android/jobqueue/**" />
-            </fileset>
-            <file name="LICENSE.txt"/>
-        </jar>
-    </target>
-
-    <target name="-pre-clean" description="cleanup module">
-        <delete dir="${out.test-classes.absolute.dir}"/>
-        <delete dir="${tmp.dir}"/>
-    </target>
-
-    <target name="test" depends="compile.tests" description="test all">
-        <delete file="${cobertura.absolute}"/>
-        <delete dir="${coverate.report.absolute.dir}"/>
-        <delete dir="${instrumented.absolute.dir}"/>
-        <cobertura-instrument todir="${instrumented.absolute.dir}">
-            <ignore regex="com.path.android.jobqueue.log.JqLog.*"/>
-            <fileset dir="${out.classes.absolute.dir}">
-                <include name="**/*.class"/>
-                <exclude name="com/path/android/jobqueue/log/**/*"/>
-                <exclude name="com/path/android/jobqueue/R**"/>
-            </fileset>
-        </cobertura-instrument>
-
-
-        <mkdir dir="${basedir}/out/reports/tests"/>
-        <junit showoutput="true" fork="no" haltonfailure="yes" failureproperty="junit.failure" printsummary="yes" logfailedtests="true">
-            <jvmarg value="-Xmx2g"/>
-            <formatter type="plain" usefile="false"/>
-            <formatter type="plain"/>
-            <sysproperty key="net.sourceforge.cobertura.datafile"
-                         file="${cobertura.absolute}"/>
-            <classpath location="${instrumented.absolute.dir}"/>
-            <classpath>
-                <pathelement path="${out.classes.absolute.dir}"/>
-                <pathelement path="${out.test-classes.absolute.dir}"/>
-                <fileset dir="${test.external.libs.absolute.dir}" includes="*.jar"/>
-                <fileset dir="${jar.libs.dir}" includes="*.jar"/>
-                <path refid="project.target.class.path"/>
-                <pathelement path="${sdk.dir}/extras/android/support/v4/android-support-v4.jar"/>
-            </classpath>
-            <classpath refid="cobertura.classpath"/>
-            <batchtest todir="${basedir}/out/reports/tests">
-                <fileset dir="${test.absolute.dir}">
-                    <include name="**/*Test.java"/>
-                </fileset>
-            </batchtest>
-        </junit>
-        <!-- Generate Cobertura html file report  containing the coverage data
-     -->
-        <cobertura-report format="html" srcdir="${source.absolute.dir}" destdir="${coverate.report.absolute.dir}"
-                          datafile="${cobertura.absolute}"/>
-        <fail if="junit.failure" message="Unit test(s) failed.  See reports!"/>
-    </target>
-
-    <target name="javadoc">
-        <javadoc destdir="${basedir}/javadoc/"      additionalparam="-J-Dorg.apache.commons.attributes.javadoc.CATaglet.sources=${source.absolute.dir}">
-        <taglet name="org.apache.commons.attributes.javadoc.CATaglet" path="${ant.home}/lib/commons-attributes-compiler-2.2.jar"/>
-        <fileset dir="${source.absolute.dir}" includes="**/*.java"/>
-        </javadoc>
-    </target>
-
-    <target name="ensure-test-name" unless="test">
-        <fail message="You must run this target with -Dtest=TestName"/>
-    </target>
-
-    <target name="runtest" description="Runs the test you specify on the command
-    line with -Dtest=" depends="compile.tests, ensure-test-name">
-        <junit showoutput="true" fork="yes" failureproperty="junit.failure" printsummary="yes" logfailedtests="true">
-            <formatter type="plain" usefile="false"/>
-            <formatter type="plain"/>
-            <sysproperty key="net.sourceforge.cobertura.datafile"
-                         file="${cobertura.absolute}"/>
-            <sysproperty key="tests" value="${tests}"/>
-            <classpath location="${instrumented.absolute.dir}"/>
-            <classpath>
-                <pathelement path="${out.classes.absolute.dir}"/>
-                <pathelement path="${out.test-classes.absolute.dir}"/>
-                <fileset dir="${test.external.libs.absolute.dir}" includes="*.jar"/>
-                <fileset dir="${jar.libs.dir}" includes="*.jar"/>
-                <path refid="project.target.class.path"/>
-                <pathelement path="${sdk.dir}/extras/android/support/v4/android-support-v4.jar"/>
-            </classpath>
-            <classpath refid="cobertura.classpath"/>
-            <batchtest>
-                <fileset dir="${test.absolute.dir}">
-                    <include name="**/${test}.java"/>
-                </fileset>
-            </batchtest>
-        </junit>
-    </target>
-</project>
diff --git a/jobqueue/cobertura/cobertura.jar b/jobqueue/cobertura/cobertura.jar
deleted file mode 100644
index 438fe55..0000000
Binary files a/jobqueue/cobertura/cobertura.jar and /dev/null differ
diff --git a/jobqueue/cobertura/lib/asm-3.0.jar b/jobqueue/cobertura/lib/asm-3.0.jar
deleted file mode 100644
index 112f5bd..0000000
Binary files a/jobqueue/cobertura/lib/asm-3.0.jar and /dev/null differ
diff --git a/jobqueue/cobertura/lib/asm-tree-3.0.jar b/jobqueue/cobertura/lib/asm-tree-3.0.jar
deleted file mode 100644
index 2a4b208..0000000
Binary files a/jobqueue/cobertura/lib/asm-tree-3.0.jar and /dev/null differ
diff --git a/jobqueue/cobertura/lib/jakarta-oro-2.0.8.jar b/jobqueue/cobertura/lib/jakarta-oro-2.0.8.jar
deleted file mode 100644
index 23488d2..0000000
Binary files a/jobqueue/cobertura/lib/jakarta-oro-2.0.8.jar and /dev/null differ
diff --git a/jobqueue/cobertura/lib/jakarta-oro-license.txt b/jobqueue/cobertura/lib/jakarta-oro-license.txt
deleted file mode 100644
index 100f86b..0000000
--- a/jobqueue/cobertura/lib/jakarta-oro-license.txt
+++ /dev/null
@@ -1,53 +0,0 @@
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation", "Jakarta-Oro" 
- *    must not be used to endorse or promote products derived from this
- *    software without prior written permission. For written
- *    permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache" 
- *    or "Jakarta-Oro", nor may "Apache" or "Jakarta-Oro" appear in their 
- *    name, without prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
diff --git a/jobqueue/cobertura/lib/log4j-1.2.9.jar b/jobqueue/cobertura/lib/log4j-1.2.9.jar
deleted file mode 100644
index a6568b0..0000000
Binary files a/jobqueue/cobertura/lib/log4j-1.2.9.jar and /dev/null differ
diff --git a/jobqueue/cobertura/lib/log4j-license.txt b/jobqueue/cobertura/lib/log4j-license.txt
deleted file mode 100644
index 030564f..0000000
--- a/jobqueue/cobertura/lib/log4j-license.txt
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * ============================================================================
- *                   The Apache Software License, Version 1.1
- * ============================================================================
- * 
- *    Copyright (C) 1999 The Apache Software Foundation. All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modifica-
- * tion, are permitted provided that the following conditions are met:
- * 
- * 1. Redistributions of  source code must  retain the above copyright  notice,
- *    this list of conditions and the following disclaimer.
- * 
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 
- * 3. The end-user documentation included with the redistribution, if any, must
- *    include  the following  acknowledgment:  "This product includes  software
- *    developed  by the  Apache Software Foundation  (http://www.apache.org/)."
- *    Alternately, this  acknowledgment may  appear in the software itself,  if
- *    and wherever such third-party acknowledgments normally appear.
- * 
- * 4. The names "log4j" and  "Apache Software Foundation"  must not be used to
- *    endorse  or promote  products derived  from this  software without  prior
- *    written permission. For written permission, please contact
- *    apache@apache.org.
- * 
- * 5. Products  derived from this software may not  be called "Apache", nor may
- *    "Apache" appear  in their name,  without prior written permission  of the
- *    Apache Software Foundation.
- * 
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS  FOR A PARTICULAR  PURPOSE ARE  DISCLAIMED.  IN NO  EVENT SHALL  THE
- * APACHE SOFTWARE  FOUNDATION  OR ITS CONTRIBUTORS  BE LIABLE FOR  ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLU-
- * DING, BUT NOT LIMITED TO, PROCUREMENT  OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR  PROFITS; OR BUSINESS  INTERRUPTION)  HOWEVER CAUSED AND ON
- * ANY  THEORY OF LIABILITY,  WHETHER  IN CONTRACT,  STRICT LIABILITY,  OR TORT
- * (INCLUDING  NEGLIGENCE OR  OTHERWISE) ARISING IN  ANY WAY OUT OF THE  USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * This software  consists of voluntary contributions made  by many individuals
- * on  behalf of the Apache Software  Foundation.  For more  information on the 
- * Apache Software Foundation, please see <http://www.apache.org/>.
- *
- */
diff --git a/jobqueue/gradle.properties b/jobqueue/gradle.properties
new file mode 100644
index 0000000..c127799
--- /dev/null
+++ b/jobqueue/gradle.properties
@@ -0,0 +1,2 @@
+sonatypeUsername=yigit
+sonotypePassword=xxxx
diff --git a/jobqueue/gradle/wrapper/gradle-wrapper.jar b/jobqueue/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..c97a8bd
Binary files /dev/null and b/jobqueue/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/jobqueue/gradle/wrapper/gradle-wrapper.properties
similarity index 87%
rename from gradle/wrapper/gradle-wrapper.properties
rename to jobqueue/gradle/wrapper/gradle-wrapper.properties
index 0c71e76..d17e36c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/jobqueue/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Wed Apr 10 15:27:10 PDT 2013
+#Fri Jul 03 10:16:32 PDT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/gradlew b/jobqueue/gradlew
similarity index 100%
rename from gradlew
rename to jobqueue/gradlew
diff --git a/gradlew.bat b/jobqueue/gradlew.bat
similarity index 100%
rename from gradlew.bat
rename to jobqueue/gradlew.bat
diff --git a/jobqueue/AndroidManifest.xml b/jobqueue/src/main/AndroidManifest.xml
similarity index 74%
rename from jobqueue/AndroidManifest.xml
rename to jobqueue/src/main/AndroidManifest.xml
index fc39c78..0a7b7c1 100644
--- a/jobqueue/AndroidManifest.xml
+++ b/jobqueue/src/main/AndroidManifest.xml
@@ -2,7 +2,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.path.android.jobqueue"
           android:versionCode="2"
-          android:versionName="1.3.1">
-    <application android:label="">
+          android:versionName="1.3.3">
+    <application>
     </application>
 </manifest>
diff --git a/jobqueue/src/com/path/android/jobqueue/AsyncAddCallback.java b/jobqueue/src/main/java/com/path/android/jobqueue/AsyncAddCallback.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/AsyncAddCallback.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/AsyncAddCallback.java
diff --git a/jobqueue/src/com/path/android/jobqueue/CancelResult.java b/jobqueue/src/main/java/com/path/android/jobqueue/CancelResult.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/CancelResult.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/CancelResult.java
diff --git a/jobqueue/src/com/path/android/jobqueue/CopyOnWriteGroupSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/CopyOnWriteGroupSet.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/CopyOnWriteGroupSet.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/CopyOnWriteGroupSet.java
diff --git a/jobqueue/src/com/path/android/jobqueue/Job.java b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
old mode 100755
new mode 100644
similarity index 69%
rename from jobqueue/src/com/path/android/jobqueue/Job.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/Job.java
index 5b1ddb9..3cda44a
--- a/jobqueue/src/com/path/android/jobqueue/Job.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
@@ -2,6 +2,8 @@
 
 import com.path.android.jobqueue.log.JqLog;
 
+import android.content.Context;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -24,10 +26,17 @@
     private Set<String> readonlyTags;
 
     private transient int currentRunCount;
-    private transient int priority;
+    transient int priority;
     private transient long delayInMs;
     transient boolean cancelled;
 
+    private transient Context applicationContext;
+
+    /**
+     * Only set if a job fails. Will be cleared by JobManager after it is handled
+     */
+    transient RetryConstraint retryConstraint;
+
 
     protected Job(Params params) {
         this.requiresNetwork = params.doesRequireNetwork();
@@ -41,7 +50,6 @@ protected Job(Params params) {
 
     /**
      * used by {@link JobManager} to assign proper priority at the time job is added.
-     * This field is not preserved!
      * @return priority (higher = better)
      */
     public final int getPriority() {
@@ -50,7 +58,7 @@ public final int getPriority() {
 
     /**
      * used by {@link JobManager} to assign proper delay at the time job is added.
-     * This field is not preserved!
+     * This field is not persisted!
      * @return delay in ms
      */
     public final long getDelayInMs() {
@@ -106,12 +114,18 @@ public final boolean isPersistent() {
      * Changes to this class will not be preserved if your job is persistent !!!
      * <p>
      * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
+     * <p>
+     * Note that this method is called on the thread the job is added. (e.g. {@link JobManager#addJob(Job)})
+     * is called. If job was added via {@link  JobManager#addJobInBackground(Job)} or
+     * {@link JobManager#addJobInBackground(Job, AsyncAddCallback)}, it will be run on JobManager's
+     * utility thread.
      */
     abstract public void onAdded();
 
     /**
      * The actual method that should to the work.
-     * It should finish w/o any exception. If it throws any exception, {@code shouldReRunOnThrowable} will be called to
+     * It should finish w/o any exception. If it throws any exception,
+     * {@link #shouldReRunOnThrowable(Throwable, int, int)} will be called to
      * decide either to dismiss the job or re-run it.
      * @throws Throwable
      */
@@ -122,12 +136,42 @@ public final boolean isPersistent() {
      */
     abstract protected void onCancel();
 
+    /**
+     * @deprecated use {@link #shouldReRunOnThrowable(Throwable, int, int)}
+     * This method will be removed in v2.0 and {@link #shouldReRunOnThrowable(Throwable, int, int)}
+     * will become abstract.
+     */
+    @Deprecated
+    protected boolean shouldReRunOnThrowable(Throwable throwable) {
+        return true;
+    }
+
     /**
      * If {@code onRun} method throws an exception, this method is called.
-     * return true if you want to run your job again, return false if you want to dismiss it. If you return false,
-     * onCancel will be called.
+     * <p>
+     * If you simply want to return retry or cancel, you can use {@link RetryConstraint#RETRY} or
+     * {@link RetryConstraint#CANCEL}.
+     * <p>
+     * You can also use a custom {@link RetryConstraint} where you can change the Job's priority or
+     * add a delay until the next run (e.g. exponential back off).
+     * <p>
+     * Note that changing the Job's priority or adding a delay may alter the original run order of
+     * the job. So if the job was added to the queue with other jobs and their execution order is
+     * important (e.g. they use the same groupId), you should not change job's priority or add a
+     * delay unless you really want to change their execution order.
+     *
+     * @param throwable The exception that was thrown from {@link #onRun()}
+     * @param runCount The number of times this job run. Starts from 1.
+     * @param maxRunCount The max number of times this job can run. Decided by {@link #getRetryLimit()}
+     * @return A {@link RetryConstraint} to decide whether this Job should be tried again or not and
+     * if yes, whether we should add a delay or alter its priority. Returning null from this method
+     * is equal to returning {@link RetryConstraint#RETRY}. Default implementation calls
+     * {@link #shouldReRunOnThrowable(Throwable)}.
      */
-    abstract protected boolean shouldReRunOnThrowable(Throwable throwable);
+    protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
+        boolean reRun = shouldReRunOnThrowable(throwable);
+        return reRun ? RetryConstraint.RETRY : RetryConstraint.CANCEL;
+    }
 
     /**
      * Runs the job and catches any exception
@@ -152,7 +196,13 @@ final int safeRun(JobHolder holder, int currentRunCount) {
             reRun = currentRunCount < getRetryLimit();
             if(reRun && !cancelled) {
                 try {
-                    reRun = shouldReRunOnThrowable(t);
+                    RetryConstraint retryConstraint = shouldReRunOnThrowable(t, currentRunCount,
+                            getRetryLimit());
+                    if (retryConstraint == null) {
+                        retryConstraint = RetryConstraint.RETRY;
+                    }
+                    this.retryConstraint = retryConstraint;
+                    reRun = retryConstraint.shouldRetry();
                 } catch (Throwable t2) {
                     JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
                 }
@@ -206,7 +256,7 @@ public final String getRunGroupId() {
 
     /**
      * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
-     * If job fails this many times, onCancel will be called w/o calling {@code shouldReRunOnThrowable}
+     * If job fails this many times, onCancel will be called w/o calling {@link #shouldReRunOnThrowable(Throwable, int, int)}
      * @return
      */
     protected int getRetryLimit() {
@@ -240,4 +290,19 @@ public void assertNotCancelled() {
             throw new RuntimeException("job is cancelled");
         }
     }
+
+    /*package*/ void setApplicationContext(Context context) {
+        this.applicationContext = context;
+    }
+
+    /**
+     * Convenience method to get the application context in a Job.
+     * <p>
+     * This context is set when job is added to a JobManager.
+     *
+     * @return The application context
+     */
+    public Context getApplicationContext() {
+        return applicationContext;
+    }
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
old mode 100755
new mode 100644
similarity index 96%
rename from jobqueue/src/com/path/android/jobqueue/JobHolder.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
index bbcd272..ba73f4d
--- a/jobqueue/src/com/path/android/jobqueue/JobHolder.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
@@ -68,6 +68,7 @@ public JobHolder(Long id, int priority, String groupId, int runCount, Job job, l
         this.createdNs = createdNs;
         this.delayUntilNs = delayUntilNs;
         this.job = job;
+        job.priority = priority;
         this.runningSessionId = runningSessionId;
         this.requiresNetwork = job.requiresNetwork();
         this.tags = job.getTags() == null ? null : Collections.unmodifiableSet(job.getTags());
@@ -108,6 +109,11 @@ public int getPriority() {
 
     public void setPriority(int priority) {
         this.priority = priority;
+        this.job.priority = this.priority;
+    }
+
+    void setDelayUntilNs(long delayUntilNs) {
+        this.delayUntilNs = delayUntilNs;
     }
 
     public int getRunCount() {
diff --git a/jobqueue/src/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
old mode 100755
new mode 100644
similarity index 97%
rename from jobqueue/src/com/path/android/jobqueue/JobManager.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index ffdf63f..ad30c02
--- a/jobqueue/src/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -178,6 +178,7 @@ public long addJob(Job job) {
             //inject members b4 calling onAdded
             dependencyInjector.inject(job);
         }
+        jobHolder.getJob().setApplicationContext(appContext);
         jobHolder.getJob().onAdded();
         if(job.isPersistent()) {
             synchronized (persistentJobQueue) {
@@ -188,7 +189,7 @@ public long addJob(Job job) {
                 clearOnAddedLock(nonPersistentOnAddedLocks, id);
             }
         }
-        notifyJobConsumer();
+        ensureConsumerWhenNeeded(null);
         return id;
     }
 
@@ -530,7 +531,7 @@ private JobHolder getNextJob() {
         } else {
             waitForOnAddedLock(nonPersistentOnAddedLocks, jobHolder.getId());
         }
-
+        jobHolder.getJob().setApplicationContext(appContext);
         return jobHolder;
     }
 
@@ -651,6 +652,21 @@ public boolean isRunning() {
 
         @Override
         public void insertOrReplace(JobHolder jobHolder) {
+            RetryConstraint retryConstraint = jobHolder.getJob().retryConstraint;
+            if (retryConstraint == null) {
+                reAddJob(jobHolder);
+                return;
+            }
+            if (retryConstraint.getNewPriority() != null) {
+                jobHolder.setPriority(retryConstraint.getNewPriority());
+            }
+            long delay = -1;
+            if (retryConstraint.getNewDelayInMs() != null) {
+                delay = retryConstraint.getNewDelayInMs();
+            }
+            jobHolder.setDelayUntilNs(
+                    delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY
+            );
             reAddJob(jobHolder);
         }
 
diff --git a/jobqueue/src/com/path/android/jobqueue/JobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/JobQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/JobStatus.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobStatus.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/JobStatus.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/JobStatus.java
diff --git a/jobqueue/src/com/path/android/jobqueue/Params.java b/jobqueue/src/main/java/com/path/android/jobqueue/Params.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/Params.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/Params.java
diff --git a/jobqueue/src/com/path/android/jobqueue/QueueFactory.java b/jobqueue/src/main/java/com/path/android/jobqueue/QueueFactory.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/QueueFactory.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/QueueFactory.java
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
new file mode 100644
index 0000000..a725340
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
@@ -0,0 +1,90 @@
+package com.path.android.jobqueue;
+
+/**
+ * Created by {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+ * <p>
+ * This object keeps additional data about handling job failures. You can simply use
+ * {@link #RETRY} or {@link #CANCEL} if you just want to retry or cancel a job. Alternatively,
+ * you can create your own instance where you can add a delay {@link #setNewDelayInMs(Long)} or
+ * change Job's prioritiy {@link #setNewPriority(Integer)}.
+ * <p>
+ * A common use case is exponentially backing off a Job and you can use
+ * {@link #createExponentialBackoff(int, long)} method to do that.
+ */
+public class RetryConstraint {
+    public static final RetryConstraint RETRY = new ImmutableRetryConstraint(true);
+    public static final RetryConstraint CANCEL = new ImmutableRetryConstraint(false);
+    private boolean retry;
+    private Long newDelayInMs;
+    private Integer newPriority;
+
+    public RetryConstraint(boolean retry) {
+        this.retry = retry;
+    }
+
+    public boolean shouldRetry() {
+        return retry;
+    }
+
+    /**
+     * Set whether the Job should be run again or cancelled.
+     * @param retry
+     */
+    public void setRetry(boolean retry) {
+        this.retry = retry;
+    }
+
+    public Long getNewDelayInMs() {
+        return newDelayInMs;
+    }
+
+    /**
+     * Sets a timeout until the Job is tried again.
+     * @param newDelayInMs
+     */
+    public void setNewDelayInMs(Long newDelayInMs) {
+        this.newDelayInMs = newDelayInMs;
+    }
+
+    public Integer getNewPriority() {
+        return newPriority;
+    }
+
+    /**
+     * Updates the Job's prioritiy.
+     * @param newPriority
+     */
+    public void setNewPriority(Integer newPriority) {
+        this.newPriority = newPriority;
+    }
+
+    public static RetryConstraint createExponentialBackoff(int runCount, long initialBackOffInMs) {
+        RetryConstraint constraint = new RetryConstraint(true);
+        constraint.setNewDelayInMs(initialBackOffInMs *
+                (long) Math.pow(2, Math.max(0, runCount - 1)));
+        return constraint;
+    }
+
+    private static class ImmutableRetryConstraint extends RetryConstraint {
+        private static final String MESSAGE = "This object is immutable. Create a new one using the"
+                + " constructor.";
+        public ImmutableRetryConstraint(boolean retry) {
+            super(retry);
+        }
+
+        @Override
+        public void setRetry(boolean retry) {
+            throw new IllegalStateException(MESSAGE);
+        }
+
+        @Override
+        public void setNewDelayInMs(Long newDelayInMs) {
+            throw new IllegalStateException(MESSAGE);
+        }
+
+        @Override
+        public void setNewPriority(Integer newPriority) {
+            throw new IllegalStateException(MESSAGE);
+        }
+    }
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/TagConstraint.java b/jobqueue/src/main/java/com/path/android/jobqueue/TagConstraint.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/TagConstraint.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/TagConstraint.java
diff --git a/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/config/Configuration.java b/jobqueue/src/main/java/com/path/android/jobqueue/config/Configuration.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/config/Configuration.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/config/Configuration.java
diff --git a/jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java b/jobqueue/src/main/java/com/path/android/jobqueue/di/DependencyInjector.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/di/DependencyInjector.java
diff --git a/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
diff --git a/jobqueue/src/com/path/android/jobqueue/log/CustomLogger.java b/jobqueue/src/main/java/com/path/android/jobqueue/log/CustomLogger.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/log/CustomLogger.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/log/CustomLogger.java
diff --git a/jobqueue/src/com/path/android/jobqueue/log/JqLog.java b/jobqueue/src/main/java/com/path/android/jobqueue/log/JqLog.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/log/JqLog.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/log/JqLog.java
diff --git a/jobqueue/src/com/path/android/jobqueue/network/NetworkEventProvider.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkEventProvider.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/network/NetworkEventProvider.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkEventProvider.java
diff --git a/jobqueue/src/com/path/android/jobqueue/network/NetworkUtil.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtil.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/network/NetworkUtil.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtil.java
diff --git a/jobqueue/src/com/path/android/jobqueue/network/NetworkUtilImpl.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/network/NetworkUtilImpl.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
similarity index 100%
rename from jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
similarity index 95%
rename from jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
rename to jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
index 190e3d8..b09eb30 100755
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -302,32 +302,37 @@ public void onJobCancelled(JobHolder holder) {
     public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups) {
         //we can even keep these prepared but not sure the cost of them in db layer
         String selectQuery = nextJobsQueryCache.get(hasNetwork, excludeGroups);
-        if(selectQuery == null) {
+        if (selectQuery == null) {
             String where = createReadyJobWhereSql(hasNetwork, excludeGroups, false);
             selectQuery = sqlHelper.createSelect(
                     where,
                     1,
-                    new SqlHelper.Order(DbOpenHelper.PRIORITY_COLUMN, SqlHelper.Order.Type.DESC),
-                    new SqlHelper.Order(DbOpenHelper.CREATED_NS_COLUMN, SqlHelper.Order.Type.ASC),
+                    new SqlHelper.Order(DbOpenHelper.PRIORITY_COLUMN,
+                            SqlHelper.Order.Type.DESC),
+                    new SqlHelper.Order(DbOpenHelper.CREATED_NS_COLUMN,
+                            SqlHelper.Order.Type.ASC),
                     new SqlHelper.Order(DbOpenHelper.ID_COLUMN, SqlHelper.Order.Type.ASC)
             );
             nextJobsQueryCache.set(selectQuery, hasNetwork, excludeGroups);
         }
-        Cursor cursor = db.rawQuery(selectQuery, new String[]{Long.toString(sessionId),Long.toString(System.nanoTime())});
-        try {
-            if (!cursor.moveToNext()) {
-                return null;
+        while (true) {
+            Cursor cursor = db.rawQuery(selectQuery,
+                    new String[]{Long.toString(sessionId), Long.toString(System.nanoTime())});
+            try {
+                if (!cursor.moveToNext()) {
+                    return null;
+                }
+                JobHolder holder = createJobHolderFromCursor(cursor);
+                setSessionIdOnJob(holder);
+                return holder;
+            } catch (InvalidJobException e) {
+                //delete
+                Long jobId = cursor.getLong(0);
+                delete(jobId);
+                return nextJobAndIncRunCount(true, null);
+            } finally {
+                cursor.close();
             }
-            JobHolder holder = createJobHolderFromCursor(cursor);
-            setSessionIdOnJob(holder);
-            return holder;
-        } catch (InvalidJobException e) {
-            //delete
-            Long jobId = cursor.getLong(0);
-            delete(jobId);
-            return nextJobAndIncRunCount(true, null);
-        } finally {
-            cursor.close();
         }
     }
 
@@ -471,8 +476,6 @@ private Job safeDeserialize(byte[] bytes) {
 
     private static class InvalidJobException extends Exception {
 
-        private static final long serialVersionUID = -5825656163831895628L;
-
     }
 
     public static class JavaSerializer implements JobSerializer {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/TestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
similarity index 97%
rename from jobqueue/test/com/path/android/jobqueue/test/TestBase.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
index 576452e..e358846 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/TestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
@@ -15,7 +15,7 @@ public void setUp() throws Exception {
         }
     }
 
-    private void enableDebug() {
+    protected void enableDebug() {
         ShadowLog.stream = System.out;
         JqLog.setCustomLogger(new CustomLogger() {
             private String TAG = "test_logger";
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
similarity index 92%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
index 454d3c5..59f9ed2 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
@@ -1,7 +1,6 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.AsyncAddCallback;
-import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
@@ -10,14 +9,17 @@
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import org.fest.reflect.core.*;
 import org.hamcrest.*;
+import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicLong;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class AddInBackgroundTest extends JobManagerTestBase {
     @Test
     public void testAddInBackground() throws InterruptedException {
@@ -63,7 +65,7 @@ public void onAdded(long id) {
             JobHolder holder = queue.findJobById(jobId.longValue());
             MatcherAssert.assertThat("there should be a job in the holder. id:" + jobId.longValue() +", delayed:" + delayed + ", use cb:" + useCallback
                     , holder, CoreMatchers.notNullValue());
-            MatcherAssert.assertThat("id callback should have the proper id:", holder.getBaseJob(), CoreMatchers.is((BaseJob) dummyJob));
+            MatcherAssert.assertThat("id callback should have the proper id:", holder.getJob(), CoreMatchers.is((Job)dummyJob));
         }
     }
 
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
similarity index 80%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
index 327ea69..356b829 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
@@ -6,11 +6,13 @@
 import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
 
 import static org.hamcrest.CoreMatchers.equalTo;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class AddedCountTest extends JobManagerTestBase {
     @Test
     public void testAddedCount() throws Exception {
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java
new file mode 100644
index 0000000..a85fa16
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java
@@ -0,0 +1,90 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Matcher;
+import org.hamcrest.MatcherAssert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import android.content.Context;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class ApplicationContextTests extends JobManagerTestBase {
+    static int retryCount = 0;
+    static CountDownLatch doneLatch;
+    @Before
+    public void clear() {
+        retryCount = 0;
+        doneLatch = new CountDownLatch(1);
+    }
+
+    @Test
+    public void getContextNonPersistent() throws InterruptedException {
+        getContextTest(false);
+    }
+
+    @Test
+    public void getContextPersistent() throws InterruptedException {
+        getContextTest(true);
+    }
+
+    public void getContextTest(boolean persistent) throws InterruptedException {
+        ContextCheckJob job = new ContextCheckJob(new Params(1).setPersistent(persistent));
+        JobManager jobManager = createJobManager();
+        jobManager.addJob(job);
+        doneLatch.await(2, TimeUnit.SECONDS);
+    }
+
+    public static class ContextCheckJob extends Job {
+        protected ContextCheckJob(Params params) {
+            super(params);
+        }
+
+        private void assertContext(String method) {
+            Context applicationContext = getApplicationContext();
+            assertThat("Context should be application context in " + method,
+                    applicationContext, sameInstance((Context)RuntimeEnvironment.application));
+        }
+
+        @Override
+        public void onAdded() {
+            assertContext("onAdded");
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            assertContext("onRun");
+            if (retryCount < 2) {
+                retryCount ++;
+                throw new RuntimeException("failure on purpose");
+            }
+        }
+
+        @Override
+        protected void onCancel() {
+            assertContext("onCancel");
+            doneLatch.countDown();
+        }
+
+        @Override
+        protected boolean shouldReRunOnThrowable(Throwable throwable) {
+            assertContext("shouldReRunOnThrowable");
+            return retryCount < 2;
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
new file mode 100644
index 0000000..bd54746
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
@@ -0,0 +1,99 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CancelBeforeRunningTest extends JobManagerTestBase {
+    @Test
+    public void testCancelBeforeRunning() {
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        DummyJob nonPersistentJob = new DummyJob(new Params(0).addTags("dummyTag"));
+        DummyJob persistentJob = new DummyJob(new Params(0).addTags("dummyTag").persist());
+
+        jobManager.addJob(nonPersistentJob);
+        jobManager.addJob(persistentJob);
+        CancelResult result = jobManager.cancelJobs(TagConstraint.ANY, "dummyTag");
+        assertThat("both jobs should be cancelled", result.getCancelledJobs().size(), is(2));
+        assertThat("both jobs should be cancelled", result.getFailedToCancel().size(), is(0));
+        for (Job j : result.getCancelledJobs()) {
+            DummyJob job = (DummyJob) j;
+            if (!job.isPersistent()) {
+                assertThat("job is still added", job.getOnAddedCnt(), is(1));
+            }
+            assertThat("job is cancelled", job.getOnCancelCnt(), is(1));
+            assertThat("job is NOT run", job.getOnRunCnt(), is(0));
+        }
+    }
+
+    public static CountDownLatch persistentJobLatch = new CountDownLatch(1);
+    CountDownLatch nonPersistentJobLatch = new CountDownLatch(1);
+    @Test
+    public void testCancelBeforeRunningWithGroups() throws InterruptedException {
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        DummyJob nonPersistentJob = new DummyJob(new Params(0).addTags("dummyTag")
+                .groupBy("group1"));
+        DummyJob persistentJob = new DummyJob(new Params(0).addTags("dummyTag").persist()
+                .groupBy("group2"));
+        jobManager.addJob(nonPersistentJob);
+        jobManager.addJob(persistentJob);
+        CancelResult result = jobManager.cancelJobs(TagConstraint.ANY, "dummyTag");
+        assertThat("both jobs should be cancelled", result.getCancelledJobs().size(), is(2));
+        assertThat("both jobs should be cancelled", result.getFailedToCancel().size(), is(0));
+        for (Job j : result.getCancelledJobs()) {
+            DummyJob job = (DummyJob) j;
+            if (!job.isPersistent()) {
+                assertThat("job is still added", job.getOnAddedCnt(), is(1));
+            }
+            assertThat("job is cancelled", job.getOnCancelCnt(), is(1));
+            assertThat("job is NOT run", job.getOnRunCnt(), is(0));
+        }
+        assertThat("there should not be any jobs in the queue", jobManager.count(), is(0));
+        jobManager.start();
+        DummyJob nonPersistentJob2 = new DummyJob(new Params(0).addTags("dummyTag")
+                .groupBy("group1")) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                nonPersistentJobLatch.countDown();
+            }
+        };
+        DummyJob persistentJob2 = new PersistentDummyJob(new Params(0).addTags("dummyTag")
+                .groupBy("group2"));
+        jobManager.addJob(persistentJob2);
+        jobManager.addJob(nonPersistentJob2);
+        assertThat("a new job in the same group with canceled job should run",
+                nonPersistentJobLatch.await(1, TimeUnit.SECONDS), is(true));
+        assertThat("a new persistent job in the same group with canceled job should run",
+                persistentJobLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    public static class PersistentDummyJob extends DummyJob {
+        public PersistentDummyJob(Params params) {
+            super(params.persist());
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            persistentJobLatch.countDown();
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
new file mode 100644
index 0000000..a94edea
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
@@ -0,0 +1,181 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.config.Configuration;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CancelFailingJobsTest extends JobManagerTestBase {
+    static DummyNetworkUtilWithConnectivityEventSupport networkUtil = new
+            DummyNetworkUtilWithConnectivityEventSupport();
+
+    @Test
+    public void testCancelAnyAsyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAnySyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAllAsyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ALL);
+    }
+
+    @Test
+    public void testCancelAllSyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ALL);
+    }
+
+
+    public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
+            throws InterruptedException {
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .minConsumerCount(5)
+                .networkUtil(networkUtil));
+        networkUtil.setHasNetwork(false, true);
+        jobManager.addJob(new FailingJob(new Params(1).groupBy("group").addTags("tag")));
+        jobManager.addJob(new FailingJob(new Params(2).groupBy("group").addTags("tag")));
+        jobManager.addJob(new FailingJob(new Params(3).groupBy("group").addTags("tag")));
+        final CancelResult[] result = new CancelResult[1];
+        if (async) {
+            final CountDownLatch cancelLatch = new CountDownLatch(1);
+            jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+                @Override
+                public void onCancelled(CancelResult cancelResult) {
+                    result[0] = cancelResult;
+                    cancelLatch.countDown();
+                }
+            }, constraint, "tag");
+            cancelLatch.await(2, TimeUnit.SECONDS);
+        } else {
+            result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
+        }
+
+        assertThat("all jobs should be cancelled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
+        final CountDownLatch runLatch = new CountDownLatch(1);
+        jobManager.addJob(new DummyJob(new Params(1).groupBy("group").addTags("tag")) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                runLatch.countDown();
+            }
+        });
+        networkUtil.setHasNetwork(true, true);
+        assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void testCancelAnyAsyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAnySyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAllAsyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ALL);
+    }
+
+    @Test
+    public void testCancelAllSyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ALL);
+    }
+
+
+    static CountDownLatch[] persistentLatches = new CountDownLatch[]{new CountDownLatch(1), new CountDownLatch(1),
+            new CountDownLatch(1), new CountDownLatch(1)};
+    static int latchCounter = 0;
+    public void testCancelWithoutNetworkPersistent(boolean async, TagConstraint constraint)
+            throws InterruptedException {
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .minConsumerCount(5)
+                .networkUtil(networkUtil));
+        networkUtil.setHasNetwork(false, true);
+        jobManager.addJob(new DummyJob(new Params(1).persist().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(2).persist().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(3).persist().groupBy("group").addTags("tag")));
+        final CancelResult[] result = new CancelResult[1];
+        if (async) {
+            final CountDownLatch cancelLatch = new CountDownLatch(1);
+            jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+                @Override
+                public void onCancelled(CancelResult cancelResult) {
+                    result[0] = cancelResult;
+                    cancelLatch.countDown();
+                }
+            }, constraint, "tag");
+            cancelLatch.await(2, TimeUnit.SECONDS);
+        } else {
+            result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
+        }
+
+        assertThat("all jobs should be canceled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
+        final CountDownLatch runLatch = persistentLatches[latchCounter ++];
+        jobManager.addJob(new PersistentDummyJob(new Params(3).persist().groupBy("group").addTags("tag"), latchCounter - 1));
+        networkUtil.setHasNetwork(true, true);
+        assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    public static class FailingJob extends DummyJob {
+        public FailingJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public int getShouldReRunOnThrowableCnt() {
+            return 20;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            if (!networkUtil.isConnected()) {
+                Thread.sleep(getCurrentRunCount() * 200);
+                throw new RuntimeException("I'm bad, i crash!");
+            }
+        }
+    }
+
+    public static class PersistentDummyJob extends DummyJob {
+        final int latch;
+        public PersistentDummyJob(Params params, int latch) {
+            super(params.persist());
+            this.latch = latch;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            if (!networkUtil.isConnected()) {
+                Thread.sleep(getCurrentRunCount() * 200);
+                throw new RuntimeException("I'm bad, i crash!");
+            }
+            persistentLatches[latch].countDown();
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
new file mode 100644
index 0000000..9adc156
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
@@ -0,0 +1,149 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.config.Configuration;
+import com.path.android.jobqueue.log.JqLog;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CancelWhileRunningTest extends JobManagerTestBase {
+    @Test
+    public void testCancelBeforeRunning() throws InterruptedException {
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).minConsumerCount(5));
+        JobWithEndLatch nonPersistent1 = new JobWithEndLatch(new Params(0).addTags("dummyTag"), true);
+        JobWithEndLatch nonPersistent2 = new JobWithEndLatch(new Params(0).addTags("dummyTag"), false);
+        DummyJob persistentJob1 = new PersistentJobWithEndLatch(new Params(0).addTags("dummyTag"), false);
+        DummyJob persistentJob2 = new PersistentJobWithEndLatch(new Params(0).addTags("dummyTag"), true);
+
+        jobManager.addJob(nonPersistent1);
+        jobManager.addJob(nonPersistent2);
+        jobManager.addJob(persistentJob1);
+        jobManager.addJob(persistentJob2);
+
+        onStartLatch.await();
+        nonPersistent1.onStartLatch.await();
+        nonPersistent2.onStartLatch.await();
+        final CancelResult[] resultHolder = new CancelResult[1];
+        final CountDownLatch cancelLatch = new CountDownLatch(1);
+        jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+            @Override
+            public void onCancelled(CancelResult cancelResult) {
+                resultHolder[0] = cancelResult;
+                cancelLatch.countDown();
+            }
+        }, TagConstraint.ANY, "dummyTag");
+
+        assertThat("result should not arrive until existing jobs finish",
+                cancelLatch.await(4, TimeUnit.SECONDS), is(false));
+
+        onEndLatch.countDown();
+        nonPersistent1.onEndLatch.countDown();
+        nonPersistent2.onEndLatch.countDown();
+        assertThat("when jobs in question are finished, cancel callback should be triggered",
+                cancelLatch.await(1, TimeUnit.SECONDS), is(true));
+        final CancelResult result = resultHolder[0];
+        JqLog.d("cancelled jobs %s", result.getCancelledJobs());
+        JqLog.d("failed to cancel %s", result.getFailedToCancel());
+        assertThat("two jobs should be cancelled", result.getCancelledJobs().size(), is(2));
+        assertThat("two jobs should fail to cancel", result.getFailedToCancel().size(), is(2));
+
+        for (Job j : result.getCancelledJobs()) {
+            FailingJob job = (FailingJob) j;
+            if (!job.isPersistent()) {
+                assertThat("job is still added", job.getOnAddedCnt(), is(1));
+            }
+            if (job.fail) {
+                assertThat("job is cancelled", job.getOnCancelCnt(), is(1));
+            } else {
+                assertThat("job could not be cancelled", job.getOnCancelCnt(), is(0));
+            }
+        }
+
+        for (Job j : result.getFailedToCancel()) {
+            FailingJob job = (FailingJob) j;
+            if (!job.isPersistent()) {
+                assertThat("job is still added", job.getOnAddedCnt(), is(1));
+            }
+            if (job.fail) {
+                assertThat("job is cancelled", job.getOnCancelCnt(), is(1));
+            } else {
+                assertThat("job could not be cancelled", job.getOnCancelCnt(), is(0));
+            }
+        }
+    }
+
+    public static CountDownLatch onStartLatch = new CountDownLatch(2);
+    public static CountDownLatch onEndLatch = new CountDownLatch(1);
+
+    public static class PersistentJobWithEndLatch extends FailingJob {
+
+        public PersistentJobWithEndLatch(Params params, boolean fail) {
+            super(params.persist(), fail);
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            JqLog.d("starting running %s", this);
+            onStartLatch.countDown();
+            onEndLatch.await();
+            if (fail) {
+                throw new RuntimeException("been asked to fail");
+            }
+            JqLog.d("finished w/ success %s", this);
+        }
+    }
+
+    public static class JobWithEndLatch extends FailingJob {
+        public final CountDownLatch onStartLatch = new CountDownLatch(1);
+        public final CountDownLatch onEndLatch = new CountDownLatch(1);
+
+        public JobWithEndLatch(Params params, boolean fail) {
+            super(params, fail);
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            JqLog.d("starting running %s", this);
+            onStartLatch.countDown();
+            onEndLatch.await();
+            if (fail) {
+                throw new RuntimeException("been asked to fail");
+            }
+            JqLog.d("finished w/ success %s", this);
+        }
+    }
+
+    public static class FailingJob extends DummyJob {
+        private static int idCounter = 0;
+        final boolean fail;
+        final int id = idCounter++;
+
+        public FailingJob(Params params, boolean fail) {
+            super(params);
+            this.fail = fail;
+        }
+
+        @Override
+        public String toString() {
+            return getClass().getSimpleName() + "[" +id + "](" + System.identityHashCode(this) + ")";
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
new file mode 100644
index 0000000..1dfb76b
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
@@ -0,0 +1,74 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.config.Configuration;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CancelWhileRunningWithGroupsTest extends JobManagerTestBase {
+    public static CountDownLatch[] endLatches = new CountDownLatch[]{new CountDownLatch(2), new CountDownLatch(2)};
+    public static CountDownLatch[] startLatches = new CountDownLatch[]{new CountDownLatch(2), new CountDownLatch(2)};
+    @Test
+    public void testCancelBeforeRunning() throws InterruptedException {
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).minConsumerCount(5));
+        jobManager.addJob(new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group1")));
+        jobManager.addJob(new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group2").persist()));
+        assertThat("both jobs should start", startLatches[0].await(2, TimeUnit.SECONDS), is(true));
+        final CancelResult[] cancelResults = new CancelResult[1];
+        final CountDownLatch resultLatch = new CountDownLatch(1);
+        startLatches[0].await(2, TimeUnit.SECONDS);
+        jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+            @Override
+            public void onCancelled(CancelResult cancelResult) {
+                cancelResults[0] = cancelResult;
+                resultLatch.countDown();
+            }
+        }, TagConstraint.ANY, "dummyTag");
+        // give time to cancel request to be processed
+        Thread.sleep(1000);
+        endLatches[0].countDown();
+        endLatches[0].countDown();
+
+        assertThat("result should come after jobs end", resultLatch.await(2, TimeUnit.SECONDS), is(true));
+        assertThat("no jobs should be canceled", cancelResults[0].getCancelledJobs().size(), is(0));
+        assertThat("both jobs should fail to cancel", cancelResults[0].getFailedToCancel().size(), is(2));
+
+        jobManager.addJob(new DummyJobWithLatches(1, new Params(1).addTags("dummyTag").groupBy("group1")));
+        jobManager.addJob(new DummyJobWithLatches(1, new Params(1).addTags("dummyTag").groupBy("group2").persist()));
+        assertThat("new jobs with canceled groups should start", startLatches[1].await(10, TimeUnit.SECONDS), is(true));
+        endLatches[1].countDown();
+        endLatches[1].countDown();
+    }
+
+    public static class DummyJobWithLatches extends DummyJob {
+        final int latchIndex;
+        public DummyJobWithLatches(int latchIndex, Params params) {
+            super(params);
+            this.latchIndex =latchIndex;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            startLatches[latchIndex].countDown();
+            endLatches[latchIndex].await(10, TimeUnit.SECONDS);
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
new file mode 100644
index 0000000..666a705
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
@@ -0,0 +1,159 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.config.Configuration;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CancelWithNetworkToggleTest extends JobManagerTestBase {
+
+    @Test
+    public void testCancelAnyAsyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAnySyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAllAsyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ALL);
+    }
+
+    @Test
+    public void testCancelAllSyncWithoutNetwork() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ALL);
+    }
+
+
+    public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
+            throws InterruptedException {
+        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new
+                DummyNetworkUtilWithConnectivityEventSupport();
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .minConsumerCount(5)
+                .networkUtil(networkUtil));
+        networkUtil.setHasNetwork(false, true);
+        jobManager.addJob(new DummyJob(new Params(1).requireNetwork().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(2).requireNetwork().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(3).requireNetwork().groupBy("group").addTags("tag")));
+        final CancelResult[] result = new CancelResult[1];
+        if (async) {
+            final CountDownLatch cancelLatch = new CountDownLatch(1);
+            jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+                @Override
+                public void onCancelled(CancelResult cancelResult) {
+                    result[0] = cancelResult;
+                    cancelLatch.countDown();
+                }
+            }, constraint, "tag");
+            cancelLatch.await(2, TimeUnit.SECONDS);
+        } else {
+            result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
+        }
+
+        assertThat("all jobs should be canceled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
+        final CountDownLatch runLatch = new CountDownLatch(1);
+        jobManager.addJob(new DummyJob(new Params(1).requireNetwork().groupBy("group").addTags("tag")) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                runLatch.countDown();
+            }
+        });
+        networkUtil.setHasNetwork(true, true);
+        assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void testCancelAnyAsyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAnySyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ANY);
+    }
+
+    @Test
+    public void testCancelAllAsyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(true, TagConstraint.ALL);
+    }
+
+    @Test
+    public void testCancelAllSyncWithoutNetworAndPersistent() throws InterruptedException {
+        testCancelWithoutNetwork(false, TagConstraint.ALL);
+    }
+
+
+    static CountDownLatch[] persistentLatches = new CountDownLatch[]{new CountDownLatch(1), new CountDownLatch(1),
+            new CountDownLatch(1), new CountDownLatch(1)};
+    static int latchCounter = 0;
+    public void testCancelWithoutNetworkPersistent(boolean async, TagConstraint constraint)
+            throws InterruptedException {
+        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new
+                DummyNetworkUtilWithConnectivityEventSupport();
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .minConsumerCount(5)
+                .networkUtil(networkUtil));
+        networkUtil.setHasNetwork(false, true);
+        jobManager.addJob(new DummyJob(new Params(1).persist().requireNetwork().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(2).persist().requireNetwork().groupBy("group").addTags("tag")));
+        jobManager.addJob(new DummyJob(new Params(3).persist().requireNetwork().groupBy("group").addTags("tag")));
+        final CancelResult[] result = new CancelResult[1];
+        if (async) {
+            final CountDownLatch cancelLatch = new CountDownLatch(1);
+            jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+                @Override
+                public void onCancelled(CancelResult cancelResult) {
+                    result[0] = cancelResult;
+                    cancelLatch.countDown();
+                }
+            }, constraint, "tag");
+            cancelLatch.await(2, TimeUnit.SECONDS);
+        } else {
+            result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
+        }
+
+        assertThat("all jobs should be canceled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
+        final CountDownLatch runLatch = persistentLatches[latchCounter ++];
+        jobManager.addJob(new PersistentDummyJob(new Params(3).persist().requireNetwork().groupBy("group").addTags("tag"), latchCounter - 1));
+        networkUtil.setHasNetwork(true, true);
+        assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    public static class PersistentDummyJob extends DummyJob {
+        final int latch;
+        public PersistentDummyJob(Params params, int latch) {
+            super(params.persist());
+            this.latch = latch;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            persistentLatches[latch].countDown();
+        }
+    }
+}
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
similarity index 84%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
index 89f2e81..4bea355 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
@@ -8,8 +8,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class ClearTest extends JobManagerTestBase {
     @Test
     public void testClear() throws Exception {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
similarity index 85%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
index 5fb1537..ecc2606 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
@@ -9,26 +9,28 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class ConsumerCountTest extends JobManagerTestBase {
     @Test
     public void testMaxConsumerCount() throws Exception {
         int maxConsumerCount = 2;
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .maxConsumerCount(maxConsumerCount)
                 .loadFactor(maxConsumerCount));
         Object runLock = new Object();
         Semaphore semaphore = new Semaphore(maxConsumerCount);
         int totalJobCount = maxConsumerCount * 3;
-        List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
+        List<NeverEndingDummyJob> runningJobs = new ArrayList<NeverEndingDummyJob>(totalJobCount);
         for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
+            NeverEndingDummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
             runningJobs.add(job);
             jobManager.addJob(job);
         }
@@ -66,6 +68,5 @@ public void testMaxConsumerCount() throws Exception {
             }
         }
         MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
-
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
similarity index 87%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
index 26a2604..9579181 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
@@ -8,8 +8,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class CountTest extends JobManagerTestBase {
     @Test
     public void testCount() throws Exception {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
similarity index 94%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
index 6d0139e..e5f06f0 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
@@ -11,8 +11,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class DelayTest extends JobManagerTestBase {
     @Test
     public void testDelay() throws Exception {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
similarity index 59%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
index f2d93e4..f13de6d 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
@@ -2,14 +2,22 @@
 
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
 import org.hamcrest.*;
+import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class DelayedRunTest extends JobManagerTestBase {
     @Test
     public void testDelayedRun() throws Exception {
@@ -18,6 +26,26 @@ public void testDelayedRun() throws Exception {
         testDelayedRun(false, true);
         testDelayedRun(true, true);
     }
+
+    @Test
+    public void testDelayWith0Consumers() throws InterruptedException {
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .minConsumerCount(0)
+                        .maxConsumerCount(3));
+        final CountDownLatch latch = new CountDownLatch(1);
+        DummyJob dummyJob = new DummyJob(new Params(0).delayInMs(2000)) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                latch.countDown();
+            }
+        };
+        jobManager.addJob(dummyJob);
+        assertThat("job should run in 3 seconds", latch.await(3, TimeUnit.DAYS),
+                is(true));
+    }
+
     public void testDelayedRun(boolean persist, boolean tryToStop) throws Exception {
         JobManager jobManager = createJobManager();
         DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(2000).setPersistent(persist));
@@ -35,6 +63,5 @@ public void testDelayedRun(boolean persist, boolean tryToStop) throws Exception
         }
         Thread.sleep(3000);
         MatcherAssert.assertThat("all jobs should be completed", jobManager.count(), equalTo(0));
-
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
similarity index 96%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
index 0739d3c..b2e10da 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
@@ -11,11 +11,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class GroupingTest extends JobManagerTestBase {
     @Test
     public void testGrouping() throws Exception {
@@ -43,7 +45,7 @@ public void testGrouping() throws Exception {
     @Test
     public void testGroupingRaceCondition() throws Exception {
         DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5).maxConsumerCount(10)
                 .networkUtil(dummyNetworkUtil));
         dummyNetworkUtil.setHasNetwork(false, true);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
similarity index 88%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
index 7129710..d14868a 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
@@ -1,6 +1,6 @@
 package com.path.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.Params;
@@ -13,21 +13,23 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class InjectorTest extends JobManagerTestBase {
     @Test
     public void testInjector() throws Exception {
-        Configuration.Builder builder = new Configuration.Builder(Robolectric.application);
+        Configuration.Builder builder = new Configuration.Builder(RuntimeEnvironment.application);
         final JobManagerTestBase.ObjectReference injectedJobReference = new JobManagerTestBase.ObjectReference();
         final AtomicInteger injectionCallCount = new AtomicInteger(0);
         DependencyInjector dependencyInjector = new DependencyInjector() {
             @Override
-            public void inject(BaseJob job) {
+            public void inject(Job job) {
                 injectedJobReference.setObject(job);
                 injectionCallCount.incrementAndGet();
             }
@@ -40,10 +42,10 @@ public void inject(BaseJob job) {
         jobManager.addJob(new DummyJob(new Params(1).persist()));
         MatcherAssert.assertThat("injection should be called after adding a persistent job", injectionCallCount.get(), equalTo(2));
         JobHolder holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getBaseJob(), not(injectedJobReference.getObject()));
+        MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getJob(), not(injectedJobReference.getObject()));
         MatcherAssert.assertThat("injection should be called once for non persistent job", injectionCallCount.get(), equalTo(2));
         holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should be called for persistent job", holder.getBaseJob(), equalTo(injectedJobReference.getObject()));
+        MatcherAssert.assertThat("injection should be called for persistent job", holder.getJob(), equalTo(injectedJobReference.getObject()));
         MatcherAssert.assertThat("injection should be called two times for persistent job", injectionCallCount.get(), equalTo(3));
     }
 
@@ -52,7 +54,7 @@ public void testInjectorCrash() throws Exception {
         final String EXCEPTION_MESSAGE = "could not inject for whatever reason :)";
         DependencyInjector dummyDependencyInjector = new DependencyInjector() {
             @Override
-            public void inject(BaseJob baseJob) {
+            public void inject(Job job) {
                 throw new RuntimeException(EXCEPTION_MESSAGE);
             }
         };
@@ -81,7 +83,7 @@ public void e(String s, Object... objects) {
                 //
             }
         };
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).injector(dummyDependencyInjector).customLogger(customLogger));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).injector(dummyDependencyInjector).customLogger(customLogger));
         Throwable addException = null;
         try {
             jobManager.addJob(new DummyJob(new Params(0)));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
similarity index 81%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
index d416b76..8bf9eb9 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
@@ -14,23 +14,41 @@
 import org.fest.reflect.method.*;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
+import org.junit.After;
 import org.robolectric.*;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicInteger;
 
+
 public class JobManagerTestBase extends TestBase {
+    List<JobManager> createdJobManagers = new ArrayList<JobManager>();
     protected JobManager createJobManager() {
-        return new JobManager(Robolectric.application, UUID.randomUUID().toString());
+        final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
+                UUID.randomUUID().toString());
+        createdJobManagers.add(jobManager);
+        return jobManager;
     }
 
     protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
-        return new JobManager(Robolectric.application, configurationBuilder.id(UUID.randomUUID().toString()).build());
+        final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
+                configurationBuilder.id(UUID.randomUUID().toString()).build());
+        createdJobManagers.add(jobManager);
+        return jobManager;
     }
 
-
+    @After
+    public void tearDown() throws InterruptedException {
+        for (JobManager jobManager : createdJobManagers) {
+            NeverEndingDummyJob.unlockAll();
+            jobManager.stopAndWaitUntilConsumersAreFinished();
+            jobManager.clear();
+        }
+    }
 
     protected static class DummyTwoLatchJob extends DummyJob {
         private final CountDownLatch waitFor;
@@ -83,7 +101,7 @@ protected DummyJobWithRunCount(boolean persistent) {
         public void onRun() throws Throwable {
             runCount++;
             super.onRun();
-            throw new RuntimeException("i am dummy, i throw exception when running");
+            throw new RuntimeException("i am dummy, i throw exception when running " + runCount);
         }
 
         @Override
@@ -97,9 +115,6 @@ protected int getRetryLimit() {
         }
     }
 
-
-
-
     protected static class DummyNetworkUtil implements NetworkUtil {
         private boolean hasNetwork;
 
@@ -168,12 +183,15 @@ protected JobConsumerExecutor getConsumerExecutor(JobManager jobManager) {
     }
 
     public static class NeverEndingDummyJob extends DummyJob {
+        // used for cleanup
+        static List<NeverEndingDummyJob> createdJobs = new ArrayList<NeverEndingDummyJob>();
         final Object lock;
         final Semaphore semaphore;
         public NeverEndingDummyJob(Params params, Object lock, Semaphore semaphore) {
             super(params);
             this.lock = lock;
             this.semaphore = semaphore;
+            createdJobs.add(this);
         }
 
         @Override
@@ -186,5 +204,13 @@ public void onRun() throws Throwable {
             }
             semaphore.release();
         }
+
+        static void unlockAll() {
+            for (NeverEndingDummyJob job : createdJobs) {
+                synchronized (job.lock) {
+                    job.lock.notifyAll();
+                }
+            }
+        }
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
similarity index 95%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
index 28656ba..d6d0c27 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
@@ -11,18 +11,20 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class JobStatusTest extends JobManagerTestBase {
     @Test
     public void testJobStatus() throws InterruptedException {
         DummyNetworkUtilWithConnectivityEventSupport networkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
         networkUtil.setHasNetwork(false, true);
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(networkUtil));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(networkUtil));
         jobManager.stop();
         List<Integer> networkRequiringJobIndices = new ArrayList<Integer>();
         Job[] jobs = new Job[] {
@@ -86,6 +88,8 @@ public void testJobStatus() throws InterruptedException {
         while (jobManager.count() > 0 && limit--  > 0) {
             Thread.sleep(1000);
         }
+        //we need a better api callback to do this
+        Thread.sleep(500);
         assertThat("jobs should finish", jobManager.count(), is(0));
         for(int i = 0; i < jobs.length; i ++) {
             //after all jobs finish, state should be unknown
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
similarity index 93%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
index fcdc80d..fc283c3 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
@@ -9,20 +9,22 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class KeepAliveTest extends JobManagerTestBase {
     @Test
     public void testKeepAlive() throws Exception {
         int keepAlive = 3 + (int)(Math.random() * 5);
         DummyNetworkUtil networkUtilWithoutEventSupport = new DummyNetworkUtil();
         DummyNetworkUtilWithConnectivityEventSupport networkUtilWithEventSupport = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager1 = createJobManager(new Configuration.Builder(Robolectric.application)
+        JobManager jobManager1 = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .consumerKeepAlive(keepAlive).networkUtil(networkUtilWithoutEventSupport));
-        JobManager jobManager2 = createJobManager(new Configuration.Builder(Robolectric.application)
+        JobManager jobManager2 = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .consumerKeepAlive(keepAlive)
                 .networkUtil(networkUtilWithEventSupport));
         //give it a little time to create first consumer
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
similarity index 95%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
index f713c47..212b64f 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
@@ -10,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -17,7 +18,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class LoadFactorTest extends JobManagerTestBase {
     @Test
     public void testLoadFactor() throws Exception {
@@ -25,7 +27,7 @@ public void testLoadFactor() throws Exception {
         int maxConsumerCount = 5;
         int minConsumerCount = 2;
         int loadFactor = 5;
-        com.path.android.jobqueue.JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
+        com.path.android.jobqueue.JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .maxConsumerCount(maxConsumerCount)
                 .minConsumerCount(minConsumerCount)
                 .customLogger(new CustomLogger() {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
similarity index 78%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
index bbfcbed..981a489 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
@@ -1,8 +1,11 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import android.util.Log;
+
+import com.path.android.jobqueue.CancelResult;
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
@@ -10,6 +13,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.Collection;
 import java.util.LinkedList;
@@ -20,16 +24,18 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class MultiThreadTest extends JobManagerTestBase {
     private static AtomicInteger multiThreadedJobCounter;
     @Test
     public void testMultiThreaded() throws Exception {
         multiThreadedJobCounter = new AtomicInteger(0);
-        final JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
+        final JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
             .loadFactor(3).maxConsumerCount(10));
         int limit = 200;
         ExecutorService executor = new ThreadPoolExecutor(20, 20, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(limit));
+        final String cancelTag = "iWillBeCancelled";
         Collection<Future<?>> futures = new LinkedList<Future<?>>();
         for(int i = 0; i < limit; i++) {
             final int id = i;
@@ -40,10 +46,21 @@ public void run() {
                     boolean requiresNetwork = Math.round(Math.random()) % 2 == 0;
                     int priority = (int) (Math.round(Math.random()) % 10);
                     multiThreadedJobCounter.incrementAndGet();
-                    jobManager.addJob(new DummyJobForMultiThread(id, new Params(priority).setRequiresNetwork(requiresNetwork).setPersistent(persistent)));
+                    Params params = new Params(priority).setRequiresNetwork(requiresNetwork)
+                            .setPersistent(persistent);
+                    if (Math.random() < .1) {
+                        params.addTags(cancelTag);
+                    }
+                    jobManager.addJob(new DummyJobForMultiThread(id, params));
                 }
             }));
         }
+        // wait for some jobs to start
+        Thread.sleep(1000);
+        CancelResult cancelResult = jobManager.cancelJobs(TagConstraint.ALL, cancelTag);
+        for (int  i = 0; i < cancelResult.getCancelledJobs().size(); i++) {
+            multiThreadedJobCounter.decrementAndGet();
+        }
         for (Future<?> future:futures) {
             future.get();
         }
@@ -76,7 +93,7 @@ public void onRun() throws Throwable {
             int remaining = multiThreadedJobCounter.decrementAndGet();
             //take some time
             Thread.sleep((long) (Math.random() * 1000));
-            //throw exception w/ small change
+            //throw exception w/ small chance
             if(Math.random() < .1) {
                 throw new Exception("decided to die, will retry");
             }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
similarity index 90%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
index 15e9819..dfed6da 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
@@ -9,13 +9,15 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class NetworkJobTest extends JobManagerTestBase {
     @Test
     public void testNetworkJob() throws Exception {
         JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
         jobManager.stop();
 
         DummyJob networkDummyJob = new DummyJob(new Params(5).requireNetwork());
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
similarity index 89%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
index d275718..3446739 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
@@ -8,15 +8,17 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import static org.hamcrest.CoreMatchers.equalTo;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class NetworkJobWithConnectivityListenerTest extends JobManagerTestBase {
     @Test
     public void testNetworkJobWithConnectivityListener() throws Exception {
         DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
         dummyNetworkUtil.setHasNetwork(false, true);
         DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
         long dummyJobId = jobManager.addJob(dummyJob);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
similarity index 87%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
index f07f629..56c34a8 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
@@ -10,17 +10,19 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.CoreMatchers.nullValue;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class NetworkNextJobTest extends JobManagerTestBase {
     @Test
     public void testNetworkNextJob() throws Exception {
         DummyNetworkUtil dummyNetworkUtil = new DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
         jobManager.stop();
         DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
         long dummyJobId = jobManager.addJob(dummyJob);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
similarity index 84%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
index 2e1b721..dae3514 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
@@ -8,11 +8,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class PersistentJobTest extends JobManagerTestBase {
     //TEST parallel running
     public static CountDownLatch persistentRunLatch = new CountDownLatch(1);
@@ -20,7 +22,7 @@
     @Test
     public void testPersistentJob() throws Exception {
         JobManager jobManager = createJobManager();
-        jobManager.addJob(0, new DummyPersistentLatchJob());
+        jobManager.addJob(new DummyPersistentLatchJob());
         persistentRunLatch.await(5, TimeUnit.SECONDS);
         MatcherAssert.assertThat((int) persistentRunLatch.getCount(), equalTo(0));
     }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PriorityTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
similarity index 73%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
index 3f35e2b..982d8fd 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
@@ -1,48 +1,51 @@
 package com.path.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class PriorityTest extends JobManagerTestBase {
     private static CountDownLatch priorityRunLatch;
 
     @Test
     public void testPriority() throws Exception {
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).maxConsumerCount(1));
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).maxConsumerCount(1));
         testPriority(jobManager, false);
     }
 
     public void testPriority(JobManager jobManager, boolean persist) throws Exception {
         priorityRunLatch = new CountDownLatch(2);
         DummyJobWithRunOrderAssert.globalRunCount = new AtomicInteger(0);
-        BaseJob job1 = new DummyJobWithRunOrderAssert(2, persist);
-        BaseJob job2 = new DummyJobWithRunOrderAssert(1, persist);
+        Job job1 = new DummyJobWithRunOrderAssert(2, new Params(1).setPersistent(persist));
+        Job job2 = new DummyJobWithRunOrderAssert(1, new Params(2).setPersistent(persist));
         jobManager.stop();
-        jobManager.addJob(1, job1);
-        jobManager.addJob(2, job2);
+        jobManager.addJob(job1);
+        jobManager.addJob(job2);
         jobManager.start();
         priorityRunLatch.await(4, TimeUnit.SECONDS);
         //ensure both jobs did run
         MatcherAssert.assertThat((int) priorityRunLatch.getCount(), equalTo(0));
     }
 
-    public static class DummyJobWithRunOrderAssert extends BaseJob {
+    public static class DummyJobWithRunOrderAssert extends Job {
         transient public static AtomicInteger globalRunCount;
         private int expectedRunOrder;
 
-        public DummyJobWithRunOrderAssert(int expectedRunOrder, boolean persist) {
-            super(true, persist);
+        public DummyJobWithRunOrderAssert(int expectedRunOrder, Params params) {
+            super(params.requireNetwork());
             this.expectedRunOrder = expectedRunOrder;
         }
 
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
similarity index 71%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
index e936235..2c128c5 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
@@ -1,14 +1,17 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
 
 import static org.hamcrest.CoreMatchers.equalTo;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class ReRunWithLimitTest extends JobManagerTestBase {
     @Test
     public void testReRunWithLimit() throws Exception {
@@ -18,11 +21,12 @@ public void testReRunWithLimit() throws Exception {
     }
 
     private void testReRun(JobManager jobManager, boolean persist) throws InterruptedException {
+        enableDebug();
         DummyJobWithRunCount.runCount = 0;//reset
         DummyJobWithRunCount job = new DummyJobWithRunCount(persist);
-        jobManager.addJob(0, job);
+        jobManager.addJob(job);
         int limit = 25;
-        while (limit-- > 0 && DummyJobWithRunCount.runCount != 5) {
+        while (limit-- > 0 && DummyJobWithRunCount.runCount != job.getRetryLimit()) {
             Thread.sleep(100);
         }
         MatcherAssert.assertThat(DummyJobWithRunCount.runCount, equalTo(job.getRetryLimit()));
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
new file mode 100644
index 0000000..cb8a309
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
@@ -0,0 +1,350 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.RetryConstraint;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class RetryLogicTest extends JobManagerTestBase {
+
+    static RetryProvider retryProvider;
+
+    static boolean canRun;
+
+    static int runCount;
+
+    static CountDownLatch onRunLatch;
+
+    static Callback onRunCallback;
+
+    static CountDownLatch cancelLatch;
+
+    @Before
+    public void clear() {
+        retryProvider = null;
+        canRun = false;
+        runCount = 0;
+        onRunLatch = null;
+        onRunCallback = null;
+        cancelLatch = new CountDownLatch(1);
+    }
+
+    @Test
+    public void testExponential() {
+        assertThat("exp 1",RetryConstraint.createExponentialBackoff(1, 10).getNewDelayInMs(),
+                is(10L));
+        assertThat("exp 2",RetryConstraint.createExponentialBackoff(2, 10).getNewDelayInMs(),
+                is(20L));
+        assertThat("exp 3",RetryConstraint.createExponentialBackoff(3, 10).getNewDelayInMs(),
+                is(40L));
+
+        assertThat("exp 1",RetryConstraint.createExponentialBackoff(1, 5).getNewDelayInMs(),
+                is(5L));
+        assertThat("exp 2",RetryConstraint.createExponentialBackoff(2, 5).getNewDelayInMs(),
+                is(10L));
+        assertThat("exp 3",RetryConstraint.createExponentialBackoff(3, 5).getNewDelayInMs(),
+                is(20L));
+    }
+
+    @Test
+    public void testRunCountPersistent() throws InterruptedException {
+        testFirstRunCount(true);
+    }
+
+    @Test
+    public void testRunCountNonPersistent() throws InterruptedException {
+        testFirstRunCount(false);
+    }
+
+    public void testFirstRunCount(boolean persistent) throws InterruptedException {
+        final AtomicInteger runCnt = new AtomicInteger(0);
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                assertThat("run count should match", ((RetryJob) job).getCurrentRunCount(),
+                        is(runCnt.incrementAndGet()));
+            }
+        };
+        canRun = true;
+        RetryJob job = new RetryJob(new Params(0).setPersistent(persistent));
+        job.retryLimit = 10;
+        createJobManager().addJob(job);
+        assertThat("", cancelLatch.await(4, TimeUnit.SECONDS), is(true));
+        assertThat("", runCount, is(10));
+    }
+
+    @Test
+    public void testChangeDelayPersistent() throws InterruptedException {
+        testChangeDelay(true);
+    }
+
+    @Test
+    public void testChangeDelayNonPersistent() throws InterruptedException {
+        testChangeDelay(false);
+    }
+
+    public void testChangeDelay(boolean persistent) throws InterruptedException {
+        canRun = true;
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 2;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount,
+                    int maxRunCount) {
+                RetryConstraint constraint = new RetryConstraint(true);
+                constraint.setNewDelayInMs(2000L);
+                return constraint;
+            }
+        };
+        final List<Long> runTimes = new ArrayList<>();
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                runTimes.add(System.nanoTime());
+            }
+        };
+        createJobManager().addJob(job);
+        assertThat("job should be canceled", cancelLatch.await(4, TimeUnit.SECONDS), is(true));
+        assertThat("should run 2 times", runCount, is(2));
+        long timeInBetween = TimeUnit.NANOSECONDS.toSeconds(runTimes.get(1) - runTimes.get(0));
+        assertThat("time between two runs should be at least 2 seconds. " + timeInBetween,
+                 2 <= timeInBetween, is(true));
+    }
+
+    @Test
+    public void testChangePriorityAndObserveExecutionOrderPersistent() throws InterruptedException {
+        testChangePriorityAndObserveExecutionOrder(true);
+    }
+
+    @Test
+    public void testChangePriorityAndObserveExecutionOrderNonPersistent()
+            throws InterruptedException {
+        testChangePriorityAndObserveExecutionOrder(false);
+    }
+
+    public void testChangePriorityAndObserveExecutionOrder(boolean persistent)
+            throws InterruptedException {
+        cancelLatch = new CountDownLatch(2);
+        RetryJob job1 = new RetryJob(new Params(10).setPersistent(persistent).groupBy("group"));
+        job1.identifier = "1";
+        RetryJob job2 = new RetryJob(new Params(5).setPersistent(persistent).groupBy("group"));
+        job2.identifier = "2";
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        jobManager.addJob(job1);
+        jobManager.addJob(job2);
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount,
+                    int maxRunCount) {
+                RetryJob retryJob = (RetryJob) job;
+                if ("1".equals(retryJob.identifier)) {
+                    if (retryJob.getPriority() == 1) {
+                        return RetryConstraint.CANCEL;
+                    }
+                    RetryConstraint retryConstraint = new RetryConstraint(true);
+                    retryConstraint.setNewPriority(1);
+                    return retryConstraint;
+                } else {
+                    return RetryConstraint.CANCEL;
+                }
+            }
+        };
+        final List<String> runOrder = new ArrayList<>();
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                runOrder.add(((RetryJob) job).identifier);
+            }
+        };
+        canRun = true;
+        jobManager.start();
+        assertThat("both jobs should be canceled eventually", cancelLatch.await(3, TimeUnit.MINUTES)
+                , is(true));
+        assertThat("jobs should run a total of 3 times", runCount, is(3));
+        final List<String> expectedRunOrder = Arrays.asList("1", "2", "1");
+        assertThat("expected run order count should match", runOrder.size(), is(expectedRunOrder.size()));
+        for (int i = 0; i < expectedRunOrder.size(); i++) {
+            assertThat("at iteration " + i + ", this job should run",
+                    runOrder.get(i), is(expectedRunOrder.get(i)));
+        }
+    }
+
+    @Test
+    public void testChangePriorityPersistent() throws InterruptedException {
+        testChangePriority(true);
+    }
+
+    @Test
+    public void testChangePriorityNonPersistent() throws InterruptedException {
+        testChangePriority(false);
+    }
+
+    @Ignore
+    public void testChangePriority(boolean persistent) throws InterruptedException {
+        final AtomicInteger priority = new AtomicInteger(1);
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                RetryConstraint constraint = new RetryConstraint(true);
+                priority.set(job.getPriority() * 2);
+                constraint.setNewPriority(priority.get());
+                return constraint;
+            }
+        };
+
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                assertThat("priority should be the expected value", job.getPriority(), is(priority.get()));
+            }
+        };
+        RetryJob retryJob = new RetryJob(new Params(priority.get()).setPersistent(persistent));
+        retryJob.retryLimit = 3;
+        canRun = true;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(retryJob);
+        assertThat(onRunLatch.await(5, TimeUnit.SECONDS), is(true));
+        assertThat("it should run 3 times", runCount, is(3));
+        assertThat(cancelLatch.await(5, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void testCancelPersistent() throws InterruptedException {
+        testCancel(true);
+    }
+
+    @Test
+    public void testCancelNonPersistent() throws InterruptedException {
+        testCancel(false);
+    }
+
+    public void testCancel(boolean persistent) throws InterruptedException {
+        canRun = true;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                return RetryConstraint.CANCEL;
+            }
+        };
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 3;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(job);
+        assertThat(onRunLatch.await(2, TimeUnit.SECONDS), is(false));
+        assertThat("it should run 1 time", runCount, is(1));
+        assertThat(cancelLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void retryPersistent() throws InterruptedException {
+        testRetry(true, true);
+    }
+
+    @Test
+    public void retryNonPersistent() throws InterruptedException {
+        testRetry(false, true);
+    }
+
+    @Test
+    public void retryPersistentWithNull() throws InterruptedException {
+        testRetry(true, false);
+    }
+
+    @Test
+    public void retryNonPersistentWithNull() throws InterruptedException {
+        testRetry(false, false);
+    }
+
+    public void testRetry(boolean persistent, final boolean returnTrue) throws InterruptedException {
+        canRun = true;
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount, int maxRunCount) {
+                return returnTrue ? RetryConstraint.RETRY : null;
+            }
+        };
+        RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
+        job.retryLimit = 3;
+        onRunLatch = new CountDownLatch(3);
+        createJobManager().addJob(job);
+        assertThat(onRunLatch.await(2, TimeUnit.SECONDS), is(true));
+        assertThat("it should run 3 times", runCount, is(3));
+        assertThat(cancelLatch.await(2, TimeUnit.SECONDS), is(true));
+    }
+
+    public static class RetryJob extends Job {
+        int retryLimit = 5;
+        String identifier;
+        protected RetryJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            assertThat("should be allowed to run", canRun, is(true));
+            if (onRunCallback != null) {
+                onRunCallback.on(this);
+            }
+            runCount++;
+            if (onRunLatch != null) {
+                onRunLatch.countDown();
+            }
+            throw new RuntimeException("i like to fail please");
+        }
+
+        @Override
+        protected int getRetryLimit() {
+            return retryLimit;
+        }
+
+        @Override
+        protected void onCancel() {
+            cancelLatch.countDown();
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount,
+                int maxRunCount) {
+            return RetryConstraint.createExponentialBackoff(runCount, 1000);
+        }
+
+        @Override
+        public int getCurrentRunCount() {
+            return super.getCurrentRunCount();
+        }
+    }
+
+    interface RetryProvider {
+        RetryConstraint build(Job job, Throwable throwable, int runCount,
+                int maxRunCount);
+    }
+
+    interface Callback {
+        public void on(Job job);
+    }
+}
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
similarity index 79%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
index 9d49dda..3c30f03 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
@@ -1,23 +1,27 @@
 package com.path.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobManager;
 import static org.hamcrest.CoreMatchers.*;
+
+import com.path.android.jobqueue.Params;
 import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class RunFailingJobTest extends JobManagerTestBase {
     @Test
     public void runFailingJob() throws Exception {
         final CountDownLatch latch = new CountDownLatch(1);
         JobManager jobManager = createJobManager();
-        jobManager.addJob(0, new BaseJob(true) {
+        jobManager.addJob(new Job(new Params(0).requireNetwork()) {
             @Override
             public void onAdded() {
 
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
similarity index 86%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
index 0828286..6a74541 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
@@ -7,11 +7,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class RunManyNonPersistentTest extends JobManagerTestBase {
     @Test
     public void runManyNonPersistentJobs() throws Exception {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
similarity index 89%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
index 35e9aae..f145a6e 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
@@ -13,8 +13,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class SessionIdTest extends JobManagerTestBase {
     @Test
     public void testSessionId() throws Exception {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
similarity index 95%
rename from jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
index fda6e29..e39a844 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
@@ -9,10 +9,12 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class SlowOnAddedTest extends JobManagerTestBase {
     @Test
     public void testNonPersistent() throws InterruptedException {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
similarity index 79%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
index 013c1bd..a6d3873 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
@@ -7,14 +7,16 @@
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class CachedNonPersistentJobQueueTest extends JobQueueTestBase {
     public CachedNonPersistentJobQueueTest() {
         super(new JobQueueFactory() {
             @Override
             public JobQueue createNew(long sessionId, String id) {
-                return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id));
+                return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id, true));
             }
         });
     }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
similarity index 66%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
index 80099c3..473cb4a 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
@@ -5,14 +5,16 @@
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class CachedPersistentJobQueueTest extends JobQueueTestBase {
     public CachedPersistentJobQueueTest() {
         super(new JobQueueFactory() {
             @Override
             public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(Robolectric.application, sessionId, id, new SqliteJobQueue.JavaSerializer());
+                return new SqliteJobQueue(RuntimeEnvironment.application, sessionId, id, new SqliteJobQueue.JavaSerializer(), true);
             }
         });
     }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
similarity index 90%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
index fb60538..b3458e0 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
@@ -8,8 +8,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class JobParamsTest extends TestBase {
     @Test
     public void assertParamsUnderstood() {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
similarity index 70%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
index 2805e54..a0df8ff 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
@@ -4,17 +4,32 @@
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
 import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.test.TestBase;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import org.fest.reflect.core.*;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Matcher;
+import org.hamcrest.MatcherAssert;
+import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import static com.path.android.jobqueue.TagConstraint.ALL;
+import static com.path.android.jobqueue.TagConstraint.ANY;
 
 @Ignore
 public abstract class JobQueueTestBase extends TestBase {
@@ -24,6 +39,11 @@ public JobQueueTestBase(JobQueueFactory factory) {
         currentFactory = factory;
     }
 
+    @Before
+    public void setup() {
+        enableDebug();
+    }
+
     @Test
     public void testBasicAddRemoveCount() throws Exception {
         final int ADD_COUNT = 6;
@@ -99,7 +119,7 @@ public void testGroupId() throws Exception {
         long jobId5 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
         JobHolder holder1 = jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group2"}));
         assertThat("first jobs should be from group group2 if group1 is excluded",
-                holder1.getBaseJob().getRunGroupId(), equalTo("group1"));
+                holder1.getJob().getRunGroupId(), equalTo("group1"));
         assertThat("correct job should be returned if groupId is provided",
                 holder1.getId(), equalTo(jobId1));
         assertThat("no jobs should be returned if all groups are excluded",
@@ -112,7 +132,7 @@ public void testGroupId() throws Exception {
                         Arrays.asList(new String[]{"group1", "group2"})).getId(),
                 is(jobId6));
         assertThat("if group1 is excluded, next job should be from group2",
-                jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group1"})).getBaseJob().getRunGroupId()
+                jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group1"})).getJob().getRunGroupId()
                 , equalTo("group2"));
 
         //to test re-run case, add the job back in
@@ -416,7 +436,7 @@ public void testJobFields() throws Exception {
         int priority = (int) (Math.random() * 1000);
         jobHolder.setPriority(priority);
         DummyJob dummyJob = new DummyJob(new Params(0));
-        jobHolder.setBaseJob(dummyJob);
+        jobHolder.setJob(dummyJob);
         int runCount = (int) (Math.random() * 10);
         jobHolder.setRunCount(runCount);
 
@@ -483,6 +503,212 @@ public void testFindJobHolderById() {
         }
     }
 
+    @Test
+    public void testTagsWithMultipleHolders() {
+        JobQueue jobQueue = createNewJobQueue();
+        final String tag1 = UUID.randomUUID().toString();
+        String tag2 = UUID.randomUUID().toString();
+        while (tag2.equals(tag1)) {
+            tag2 = UUID.randomUUID().toString();
+        }
+        String tag3 = UUID.randomUUID().toString();
+        while (tag3.equals(tag1) || tag3.equals(tag2)) {
+            tag3 = UUID.randomUUID().toString();
+        }
+
+        JobHolder holder1 = createNewJobHolder(new Params(0).addTags(tag1, tag2));
+        JobHolder holder2 = createNewJobHolder(new Params(0).addTags(tag1, tag3));
+        jobQueue.insert(holder1);
+        jobQueue.insert(holder2);
+        Set<JobHolder> twoJobs = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1);
+        Set<Long> resultIds = ids(twoJobs);
+
+        assertThat("two jobs should be returned", twoJobs.size(), is(2));
+        assertThat("should have job id 1", resultIds, hasItems(holder1.getId(), holder2.getId()));
+        for (String tag : new String[]{tag2, tag3}) {
+            Set<JobHolder> oneJob = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag);
+            resultIds = ids(oneJob);
+            assertThat("one job should be returned", oneJob.size(), is(1));
+            if (tag.equals(tag2)) {
+                assertThat("should have job id 1", resultIds, hasItems(holder1.getId()));
+            } else {
+                assertThat("should have job id 2", resultIds, hasItems(holder2.getId()));
+            }
+        }
+        jobQueue.remove(holder1);
+        assertTags("after one of the jobs is removed", jobQueue, holder2);
+    }
+
+    private Set<Long> ids(Collection<JobHolder> result) {
+        HashSet<Long> ids = new HashSet<Long>();
+        for (JobHolder holder : result) {
+            ids.add(holder.getId());
+        }
+        return ids;
+    }
+
+    @Test
+    public void testFindByMultipleTags() {
+        JobQueue jobQueue = createNewJobQueue();
+        final String tag1 = UUID.randomUUID().toString();
+        String tag2 = UUID.randomUUID().toString();
+        while (tag2.equals(tag1)) {
+            tag2 = UUID.randomUUID().toString();
+        }
+        JobHolder holder = createNewJobHolder(new Params(0).addTags(tag1, tag2));
+        jobQueue.insert(holder);
+
+        assertTags("job with two tags", jobQueue, holder);
+        jobQueue.insertOrReplace(holder);
+        assertTags("job with two tags, reinserted", jobQueue, holder);
+        jobQueue.remove(holder);
+        assertThat("when job is removed, it should return none",
+                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1).size(), is(0));
+        assertThat("when job is removed, it should return none",
+                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag2).size(), is(0));
+    }
+
+    @Test
+    public void testFindByTags() {
+        JobQueue jobQueue = createNewJobQueue();
+        assertThat("empty queue should return 0",jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), "abc").size(), is(0));
+        jobQueue.insert(createNewJobHolder());
+        Set<JobHolder> result = jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), "blah");
+        assertThat("if job does not have a tag, it should return 0", result.size(), is(0));
+
+        final String tag1 = UUID.randomUUID().toString();
+        JobHolder holder = createNewJobHolder(new Params(0).addTags(tag1));
+        jobQueue.insert(holder);
+        assertTags("holder with 1 tag", jobQueue, holder);
+        jobQueue.insertOrReplace(holder);
+        assertTags("holder with 1 tag reinserted", jobQueue, holder);
+        jobQueue.remove(holder);
+        assertThat("when job is removed, it should return none", jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), tag1).size(), is(0));
+
+        JobHolder holder2 = createNewJobHolder(new Params(0).addTags(tag1));
+        jobQueue.insert(holder2);
+        assertThat("it should return the job", jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), tag1).size(), is(1));
+        jobQueue.onJobCancelled(holder2);
+        assertThat("when queried w/ exclude cancelled, it should not return the job",
+                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1).size(), is(0));
+
+    }
+
+    private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
+        Set<JobHolder> result;
+        String wrongTag;
+        final long id = holder.getId();
+        boolean found;
+        Matcher allTagsMatcher = CoreMatchers.hasItems(holder.getTags().toArray(new String[holder.getTags().size()]));
+        do {
+            wrongTag = UUID.randomUUID().toString();
+            found = false;
+            if(holder.getTags() != null) {
+                for(String tag : holder.getTags()) {
+                    if(tag.equals(wrongTag)) {
+                        found = true;
+                        break;
+                    }
+                }
+            }
+        } while (found);
+        result = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), wrongTag);
+        found = false;
+        for(JobHolder received : result) {
+            if(received.getId().equals(holder.getId())) {
+                found = true;
+            }
+        }
+        assertThat(msg + " when wrong tag is given, our job should not return", found, is(false));
+
+        if(holder.getTags() == null) {
+            return;// done
+        }
+        Collection<Long> exclude = Arrays.asList(holder.getId());
+        for(String[] tags : combinations(holder.getTags())) {
+            result = jobQueue.findJobsByTags(TagConstraint.ANY, true, Collections.<Long>emptyList(), tags);
+            if (tags.length == 0) {
+                assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
+            } else {
+                assertThat(msg + " any combinations: when correct tag is given, it should return one", result.size(), is(1));
+                assertThat(msg + " any combinations: returned job should be the correct one", result.iterator().next().getId(), is(id));
+                assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
+            }
+            result = jobQueue.findJobsByTags(TagConstraint.ANY,true,  exclude, tags);
+            assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(
+                    0));
+
+        }
+
+        for(String[] tags : combinations(holder.getTags())) {
+            result = jobQueue.findJobsByTags(ALL, true, Collections.<Long>emptyList(), tags);
+            if (tags.length == 0) {
+                assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
+            } else {
+                assertThat(msg + " all combinations: when correct tag is given, it should return one",
+                        result.size(), is(1));
+                assertThat(msg + " all combinations: returned job should be the correct one",
+                        result.iterator().next().getId(), is(id));
+                assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
+            }
+            result = jobQueue.findJobsByTags(ALL, true, exclude, tags);
+            assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(0));
+        }
+
+        for(String[] tags : combinations(holder.getTags())) {
+            String[] tagsWithAdditional = new String[tags.length + 1];
+            System.arraycopy(tags, 0, tagsWithAdditional, 0, tags.length);
+            tagsWithAdditional[tags.length] = wrongTag;
+            result = jobQueue.findJobsByTags(TagConstraint.ANY, true, Collections.<Long>emptyList(), tagsWithAdditional);
+            if (tags.length == 0) {
+                assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
+            } else {
+                assertThat(msg + " any combinations with wrong tag: when correct tag is given, it should return one",
+                        result.size(), is(1));
+                assertThat(msg + " any combinations with wrong tag: returned job should be the correct one",
+                        result.iterator().next().getId(), is(id));
+                assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
+            }
+
+            result = jobQueue.findJobsByTags(ALL, true, Collections.<Long>emptyList(), tagsWithAdditional);
+            assertThat(msg + " all combinations with wrong tag: when an additional wrong tag is given, it should return 0", result.size(), is(0));
+
+            result = jobQueue.findJobsByTags(ALL, true, exclude, tagsWithAdditional);
+            assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(0));
+        }
+    }
+
+    List<String[]> combinations(Set<String> strings) {
+        if(strings.size() == 0) {
+            List<String[]> result = new ArrayList<String[]>();
+            result.add(new String[]{});
+            return result;
+        }
+        Set<String> remaining = new HashSet<String>();
+        boolean skip = true;
+        for(String str : strings) {
+            if(skip) {
+                skip = false;
+            } else {
+                remaining.add(str);
+            }
+        }
+        List<String[]> others = combinations(remaining);
+        List<String[]> result = new ArrayList<String[]>();
+        for(String[] subset : others) {
+            result.add(subset);
+            // add myself
+            String[] copy = new String[subset.length + 1];
+            copy[0] = strings.iterator().next();
+            for(int i = 1; i <= subset.length; i++) {
+                copy[i] = subset[i - 1];
+            }
+            result.add(copy);
+        }
+        return result;
+    }
+
+
     protected JobHolder createNewJobHolder() {
         return createNewJobHolder(new Params(0));
     }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
similarity index 77%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
index aec3924..08164be 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
@@ -7,18 +7,25 @@
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.assertThat;
 import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
+import org.robolectric.annotation.Config;
 
-@RunWith(RobolectricTestRunner.class)
+import java.util.Collections;
+
+import static com.path.android.jobqueue.TagConstraint.ANY;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class NonPersistentJobQueueTest extends JobQueueTestBase {
     public NonPersistentJobQueueTest() {
         super(new JobQueueFactory() {
             @Override
             public JobQueue createNew(long sessionId, String id) {
-                return new NonPersistentPriorityQueue(sessionId, id);
+                return new NonPersistentPriorityQueue(sessionId, id, true);
             }
         });
     }
@@ -48,6 +55,13 @@ public void testTooManyQueueChanges() throws InterruptedException {
             MatcherAssert.assertThat("should get a next job", holder, notNullValue());
             jobQueue.remove(holder);
         }
+    }
+
+    @Test
+    public void testFindByTags() {
+        JobQueue jobQueue = createNewJobQueue();
+        assertThat("empty queue should return 0",jobQueue.findJobsByTags(ANY,
+                false, Collections.<Long>emptyList(), "abc").size(), is(0));
 
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
similarity index 75%
rename from jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
index 7325e3d..a38ba87 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
@@ -1,6 +1,6 @@
 package com.path.android.jobqueue.test.jobqueue;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobQueue;
 import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
@@ -10,19 +10,22 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-@RunWith(RobolectricTestRunner.class)
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
 public class SqliteJobQueueTest extends JobQueueTestBase {
     public SqliteJobQueueTest() {
         super(new JobQueueFactory() {
             @Override
             public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(Robolectric.application, sessionId, id, new SqliteJobQueue.JavaSerializer());
+                return new SqliteJobQueue(RuntimeEnvironment.application, sessionId, id, new SqliteJobQueue.JavaSerializer(), true);
             }
         });
     }
@@ -39,13 +42,13 @@ public void testCustomSerializer() throws Exception {
             }
 
             @Override
-            public <T extends BaseJob> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
+            public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
                 calledForDeserialize.countDown();
                 return super.deserialize(bytes);
             }
         };
-        SqliteJobQueue jobQueue = new SqliteJobQueue(Robolectric.application, System.nanoTime(), "__" + System.nanoTime(),
-                jobSerializer);
+        SqliteJobQueue jobQueue = new SqliteJobQueue(RuntimeEnvironment.application, System.nanoTime(), "__" + System.nanoTime(),
+                jobSerializer, true);
         jobQueue.insert(createNewJobHolder(new Params(0)));
         calledForSerialize.await(1, TimeUnit.SECONDS);
         MatcherAssert.assertThat("custom serializer should be called for serialize", (int) calledForSerialize.getCount(), CoreMatchers.equalTo(0));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
similarity index 100%
rename from jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
diff --git a/jobqueue/test/com/path/android/jobqueue/test/util/JobQueueFactory.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
similarity index 100%
rename from jobqueue/test/com/path/android/jobqueue/test/util/JobQueueFactory.java
rename to jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
diff --git a/jobqueue/test-libs/fest-util-1.1.2.jar b/jobqueue/test-libs/fest-util-1.1.2.jar
deleted file mode 100644
index e2ef62f..0000000
Binary files a/jobqueue/test-libs/fest-util-1.1.2.jar and /dev/null differ
diff --git a/jobqueue/test-libs/hamcrest-core-1.3.jar b/jobqueue/test-libs/hamcrest-core-1.3.jar
deleted file mode 100644
index 9d5fe16..0000000
Binary files a/jobqueue/test-libs/hamcrest-core-1.3.jar and /dev/null differ
diff --git a/jobqueue/test-libs/junit-4.11.jar b/jobqueue/test-libs/junit-4.11.jar
deleted file mode 100644
index aaf7444..0000000
Binary files a/jobqueue/test-libs/junit-4.11.jar and /dev/null differ
diff --git a/jobqueue/test-libs/robolectric-2.0-alpha-3-20130412.000302-32-jar-with-dependencies.jar b/jobqueue/test-libs/robolectric-2.0-alpha-3-20130412.000302-32-jar-with-dependencies.jar
deleted file mode 100644
index 7be506e..0000000
Binary files a/jobqueue/test-libs/robolectric-2.0-alpha-3-20130412.000302-32-jar-with-dependencies.jar and /dev/null differ
