diff --git a/.travis.yml b/.travis.yml
index 4ad3bd8..a0b9aa6 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,11 +4,12 @@ android:
     - tools
     - build-tools-23.0.2
     - android-23
-script: cd jobqueue && ./gradlew --stacktrace clean check 
+script: cd jobqueue && ./gradlew --stacktrace clean check --info
 addons:
   artifacts: true
   s3_region: "us-west-1"
   debug: true
   paths:
       - $(ls jobqueue/build/outputs/* | tr "\n" ":")
-      - $(ls jobqueue/build/reports/* | tr "\n" ":")
\ No newline at end of file
+      - $(ls jobqueue/build/reports/* | tr "\n" ":")
+
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 2d7612b..d2426f5 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -20,11 +20,11 @@ apply plugin: 'jacoco'
 
 buildscript {
     repositories {
-        mavenCentral()
+        jcenter()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.1'
+        classpath 'com.android.tools.build:gradle:1.5.0'
 
     }
 }
@@ -46,6 +46,7 @@ dependencies {
     testCompile 'org.hamcrest:hamcrest-core:1.3'
     testCompile 'org.easytesting:fest-util:1.2.5'
     testCompile 'org.easytesting:fest-reflect:1.4.1'
+    testCompile 'org.mockito:mockito-core:2.0.2-beta'
 }
 
 android {
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
index 3cda44a..6fc1ab5 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
@@ -218,13 +218,11 @@ final int safeRun(JobHolder holder, int currentRunCount) {
         if (reRun) {
             return JobHolder.RUN_RESULT_TRY_AGAIN;
         }
-        // failed.
-        try {
-            onCancel();
-        } catch (Throwable ignored) {
+        if (currentRunCount < getRetryLimit()) {
+            return JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+        } else {
+            return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
         }
-        return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
-
     }
 
     /**
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
index ba73f4d..4e5fd19 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
@@ -30,6 +30,11 @@
      */
     public static final int RUN_RESULT_TRY_AGAIN = 4;
 
+    /**
+     * The job decided not to run in shouldReRun method.
+     */
+    public static final int RUN_RESULT_FAIL_SHOULD_RE_RUN = 5;
+
     protected Long id;
     protected int priority;
     protected String groupId;
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index 2169e50..0137bcd 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
+import com.path.android.jobqueue.callback.JobManagerCallback;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.di.DependencyInjector;
 import com.path.android.jobqueue.executor.JobConsumerExecutor;
@@ -50,8 +51,9 @@
     private ScheduledExecutorService timedExecutor;
     // lazily created
     private final Object cancelExecutorInitLock = new Object();
-    private Executor cancelExecutor;
+    private ExecutorService cancelExecutor;
     private final Object getNextJobLock = new Object();
+    private final CopyOnWriteArrayList<JobManagerCallback> callbacks = new CopyOnWriteArrayList<>();
 
 
     /**
@@ -122,6 +124,14 @@ public void start() {
         notifyJobConsumer();
     }
 
+    public void addCallback(JobManagerCallback callback) {
+        callbacks.add(callback);
+    }
+
+    public boolean removeCallback(JobManagerCallback callback) {
+        return callbacks.remove(callback);
+    }
+
     /**
      * returns the # of jobs that are waiting to be executed.
      * This might be a good place to decide whether you should wake your app up on boot etc. to complete pending jobs.
@@ -182,7 +192,8 @@ public long addJob(Job job) {
             dependencyInjector.inject(job);
         }
         jobHolder.getJob().setApplicationContext(appContext);
-        jobHolder.getJob().onAdded();
+        callOnAddedAndNotifyListeners(jobHolder);
+
         if(job.isPersistent()) {
             synchronized (persistentJobQueue) {
                 clearOnAddedLock(persistentOnAddedLocks, id);
@@ -338,7 +349,7 @@ public void run() {
             } else {
                 result.cancelledJobs.add(holder.getJob());
                 try {
-                    holder.getJob().onCancel();
+                    callOnCancelAndNotifyListeners(holder, true);
                 } catch (Throwable t) {
                     JqLog.e(t, "cancelled job's onCancel has thrown exception");
                 }
@@ -628,13 +639,21 @@ private void removeJob(JobHolder jobHolder) {
     }
 
     public synchronized void stopAndWaitUntilConsumersAreFinished() throws InterruptedException {
-        stop();
-        timedExecutor.shutdownNow();
         synchronized (newJobListeners) {
             newJobListeners.notifyAll();
         }
+        stop();
         jobConsumerExecutor.waitUntilAllConsumersAreFinished();
+        timedExecutor.shutdown();
+        timedExecutor.awaitTermination(100, TimeUnit.SECONDS);
         timedExecutor = Executors.newSingleThreadScheduledExecutor();
+        synchronized (cancelExecutorInitLock) {
+            if (cancelExecutor != null) {
+                cancelExecutor.shutdown();
+                cancelExecutor.awaitTermination(100, TimeUnit.SECONDS);
+            }
+            cancelExecutor = Executors.newSingleThreadExecutor();
+        }
     }
 
     public synchronized void clear() {
@@ -658,6 +677,40 @@ public void onNetworkChange(boolean isConnected) {
         ensureConsumerWhenNeeded(isConnected);
     }
 
+    private void callOnCancelAndNotifyListeners(JobHolder jobHolder, boolean byCancelRequest) {
+        try {
+            jobHolder.job.onCancel();
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onCancel did throw an exception, ignoring...");
+        }
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobCancelled(jobHolder.job, byCancelRequest);
+            } catch (Throwable t){}
+        }
+    }
+
+    private void notifyOnRunListeners(JobHolder jobHolder, int resultCode) {
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobRun(jobHolder.job, resultCode);
+            } catch (Throwable t){}
+        }
+    }
+
+    private void callOnAddedAndNotifyListeners(JobHolder jobHolder) {
+        try {
+            jobHolder.job.onAdded();
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onAdded did throw an exception, ignoring...");
+        }
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobAdded(jobHolder.job);
+            } catch (Throwable t){}
+        }
+    }
+
     @SuppressWarnings("FieldCanBeLocal")
     private final JobConsumerExecutor.Contract consumerContract = new JobConsumerExecutor.Contract() {
         @Override
@@ -755,6 +808,16 @@ public int countRemainingReadyJobs() {
             //noinspection SimplifiableConditionalExpression
             return countReadyJobs(networkUtil instanceof NetworkEventProvider ? hasNetwork() : true);
         }
+
+        @Override
+        public void callJobCancel(JobHolder jobHolder, boolean byCancelRequest) {
+            JobManager.this.callOnCancelAndNotifyListeners(jobHolder, byCancelRequest);
+        }
+
+        @Override
+        public void notifyJobRun(JobHolder jobHolder, int result) {
+            JobManager.this.notifyOnRunListeners(jobHolder, result);
+        }
     };
 
 
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
new file mode 100644
index 0000000..636b11e
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
@@ -0,0 +1,79 @@
+package com.path.android.jobqueue.callback;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.TagConstraint;
+
+/**
+ * A callback class that you can attach to the JobManager to get notified as Jobs change states.
+ */
+public interface JobManagerCallback {
+    /**
+     * Used in {@link #onJobRun(Job, int)} when properly completes {@link Job#onRun()}.
+     */
+    int RESULT_SUCCEED = JobHolder.RUN_RESULT_SUCCESS;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it has reached its retry limit.
+     *
+     * @see Job#getRetryLimit()
+     */
+    int RESULT_CANCEL_REACHED_RETRY_LIMIT = JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it was cancelled via
+     * {@link JobManager#cancelJobs(TagConstraint, String...)} while it was running.
+     *
+     * @see JobManager#cancelJobs(TagConstraint, String...)
+     * @see JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
+     */
+    int RESULT_CANCEL_CANCELLED_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it decided not to run again via
+     * {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+     */
+    int RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN = JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and wanted to retry via {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+     *
+     * @see Job#getRetryLimit()
+     */
+    int RESULT_FAIL_WILL_RETRY = JobHolder.RUN_RESULT_TRY_AGAIN;
+
+    /**
+     * Called when a Job is added to the JobManager. This method is called <b>after</b> Job's
+     * onAdded method is called.
+     *
+     * @param job The Job that was added to the JobManager.
+     */
+    void onJobAdded(Job job);
+
+    /**
+     * Called after a Job has been Run. Might be called multiple times if the Job runs multiple
+     * times (due to failures).
+     *
+     * @param job        The Job that did just run.
+     * @param resultCode The result of the {@link Job#onRun()}. It is one of:
+     *                   <ul>
+     *                   <li>{@link #RESULT_SUCCEED}</li>
+     *                   <li>{@link #RESULT_CANCEL_REACHED_RETRY_LIMIT}</li>
+     *                   <li>{@link #RESULT_CANCEL_CANCELLED_WHILE_RUNNING}</li>
+     *                   <li>{@link #RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN}</li>
+     *                   <li>{@link #RESULT_FAIL_WILL_RETRY}</li>
+     *                   </ul>
+     */
+    void onJobRun(Job job, int resultCode);
+
+    /**
+     * Called when a job is cancelled.
+     *
+     * @param job              The Job that was cancelled.
+     * @param byCancelRequest  If true, the Job was cancelled in response to a
+     *                         {@link JobManager#cancelJobs(TagConstraint, String...)} request.
+     */
+    void onJobCancelled(Job job, boolean byCancelRequest);
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
new file mode 100644
index 0000000..91fef1e
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
@@ -0,0 +1,24 @@
+package com.path.android.jobqueue.callback;
+
+import com.path.android.jobqueue.Job;
+
+/**
+ * An empty implementation of {@link JobManagerCallback}. You are advice to override this one
+ * instead so that if new methods are added to the interface, your code won't break.
+ */
+public class JobManagerCallbackAdapter implements JobManagerCallback {
+    @Override
+    public void onJobAdded(Job job) {
+
+    }
+
+    @Override
+    public void onJobRun(Job job, int resultCode) {
+
+    }
+
+    @Override
+    public void onJobCancelled(Job job, boolean byCancelRequest) {
+
+    }
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
index 723c1f7..84a105f 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
@@ -5,6 +5,7 @@
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
 import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.callback.JobManagerCallback;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.log.JqLog;
 
@@ -171,8 +172,8 @@ private boolean containsAny(List<String> ids) {
     }
 
     public void inRunningJobHoldersLock(Runnable runnable) {
-        synchronized (runnable) {
-            runnable.run();;
+        synchronized (runningJobHolders) {
+            runnable.run();
         }
     }
 
@@ -271,6 +272,20 @@ public void waitUntilAllConsumersAreFinished() throws InterruptedException {
          * @return the number of Jobs that are ready to be run
          */
         public int countRemainingReadyJobs();
+
+        /**
+         * Calls onCancel on the job, notifies listeners
+         * @param nextJob
+         * @param byCancelRequest
+         */
+        void callJobCancel(JobHolder nextJob, boolean byCancelRequest);
+
+        /**
+         * Calls the listeners about job state.
+         * @param nextJob
+         * @param result
+         */
+        void notifyJobRun(JobHolder nextJob, int result);
     }
 
     /**
@@ -304,12 +319,15 @@ public void run() {
                         if (nextJob != null) {
                             executor.onBeforeRun(nextJob);
                             int result = nextJob.safeRun(nextJob.getRunCount());
+                            contract.notifyJobRun(nextJob, result);
                             switch (result) {
                                 case JobHolder.RUN_RESULT_SUCCESS:
                                     nextJob.markAsSuccessful();
                                     contract.removeJob(nextJob);
                                     break;
                                 case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
+                                case JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN:
+                                    contract.callJobCancel(nextJob, false);
                                     contract.removeJob(nextJob);
                                     break;
                                 case JobHolder.RUN_RESULT_TRY_AGAIN:
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
new file mode 100644
index 0000000..a804a42
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
@@ -0,0 +1,178 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.RetryConstraint;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.callback.JobManagerCallback;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.*;
+
+import org.mockito.ArgumentCaptor;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CallbackTest extends JobManagerTestBase {
+    @Test
+    public void successNonPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        Job job = mock(Job.class);
+        doNothing().when(job).onAdded();
+        doNothing().when(job).onRun();
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(job).onAdded();
+        verify(job).onRun();
+        verify(callback).onJobAdded(job);
+        verify(callback).onJobRun(job, JobManagerCallback.RESULT_SUCCEED);
+    }
+
+    @Test
+    public void cancelViaRetryLimit() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        PublicJob job = mock(PublicJob.class);
+        doNothing().when(job).onAdded();
+        doThrow(new Exception()).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.RETRY).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(job);
+        verify(callback, times(2)).onJobRun(job, JobManagerCallback.RESULT_FAIL_WILL_RETRY);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_REACHED_RETRY_LIMIT);
+        verify(callback).onJobCancelled(job, false);
+    }
+
+    @Test
+    public void cancelViaShouldReRun() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        PublicJob job = mock(PublicJob.class);
+        doNothing().when(job).onAdded();
+        doThrow(new Exception()).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.CANCEL).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN);
+        verify(callback).onJobCancelled(job, false);
+    }
+
+    @Test
+    public void cancelViaCancelCall() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final CountDownLatch startLatch = new CountDownLatch(1);
+        final CountDownLatch endLatch = new CountDownLatch(1);
+        PublicJob job = spy(new PublicJob(new Params(1).addTags("tag1")) {
+            @Override
+            public void onRun() throws Throwable {
+                startLatch.countDown();
+                Assert.assertThat(endLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
+                throw new Exception("blah");
+            }
+        });
+        doCallRealMethod().when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        verify(job, times(0)).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        Assert.assertThat(startLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
+        jobManager.cancelJobsInBackground(null, TagConstraint.ANY, "tag1");
+        Thread.sleep(500); // to ensure cancel request has reached
+        endLatch.countDown();
+        busyDrain(jobManager, 2);
+        Thread.sleep(500); // wait until cancel finishes
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_WHILE_RUNNING);
+        verify(callback).onJobCancelled(job, true);
+    }
+
+    @Test
+    public void successPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        Job job = new PersistentDummyJob();
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(any(PersistentDummyJob.class));
+        verify(callback).onJobRun(any(PersistentDummyJob.class), eq(JobManagerCallback.RESULT_SUCCEED));
+    }
+
+    public static class PersistentDummyJob extends Job {
+        public PersistentDummyJob() {
+            super(new Params(1).persist());
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel() {
+
+        }
+    }
+
+    public static class PublicJob extends Job {
+
+        protected PublicJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
+            return super.shouldReRunOnThrowable(throwable, runCount, maxRunCount);
+        }
+
+        @Override
+        public int getCurrentRunCount() {
+            return super.getCurrentRunCount();
+        }
+
+        @Override
+        public int getRetryLimit() {
+            return super.getRetryLimit();
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel() {
+
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
index a94edea..177d5bd 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
@@ -49,13 +49,15 @@ public void testCancelAllSyncWithoutNetwork() throws InterruptedException {
 
     public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
             throws InterruptedException {
+        final int jobCount = 30;
         JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5)
                 .networkUtil(networkUtil));
         networkUtil.setHasNetwork(false, true);
-        jobManager.addJob(new FailingJob(new Params(1).groupBy("group").addTags("tag")));
-        jobManager.addJob(new FailingJob(new Params(2).groupBy("group").addTags("tag")));
-        jobManager.addJob(new FailingJob(new Params(3).groupBy("group").addTags("tag")));
+        for (int i = 0; i < jobCount; i ++) {
+            jobManager.addJob(new FailingJob(new Params(i).groupBy("group").addTags("tag")));
+        }
+
         final CancelResult[] result = new CancelResult[1];
         if (async) {
             final CountDownLatch cancelLatch = new CountDownLatch(1);
@@ -66,12 +68,12 @@ public void onCancelled(CancelResult cancelResult) {
                     cancelLatch.countDown();
                 }
             }, constraint, "tag");
-            cancelLatch.await(2, TimeUnit.SECONDS);
+            assertThat(cancelLatch.await(jobCount, TimeUnit.SECONDS), is(true));
         } else {
             result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
         }
 
-        assertThat("all jobs should be cancelled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("all jobs should be cancelled", result[0].getCancelledJobs().size(), is(jobCount));
         assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
         final CountDownLatch runLatch = new CountDownLatch(1);
         jobManager.addJob(new DummyJob(new Params(1).groupBy("group").addTags("tag")) {
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
index 8bf9eb9..0f41871 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
@@ -15,6 +15,7 @@
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.After;
+import org.junit.Assert;
 import org.robolectric.*;
 
 import java.util.ArrayList;
@@ -34,6 +35,16 @@ protected JobManager createJobManager() {
         return jobManager;
     }
 
+    public void busyDrain(JobManager jobManager, int limitInSeconds) throws InterruptedException {
+        int totalSleep = 0;
+        while (jobManager.count() > 0 && limitInSeconds * 1000 > totalSleep) {
+            Thread.sleep(100);
+            totalSleep += 100;
+        }
+        jobManager.stopAndWaitUntilConsumersAreFinished();
+        Assert.assertThat(limitInSeconds * 1000 > totalSleep, is(true));
+    }
+
     protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
         final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
                 configurationBuilder.id(UUID.randomUUID().toString()).build());
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
index 981a489..1adfd56 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
@@ -95,6 +95,7 @@ public void onRun() throws Throwable {
             Thread.sleep((long) (Math.random() * 1000));
             //throw exception w/ small chance
             if(Math.random() < .1) {
+                multiThreadedJobCounter.incrementAndGet();
                 throw new Exception("decided to die, will retry");
             }
             Log.d("DummyJobForMultiThread", "persistent:" + isPersistent() + ", requires network:" + requiresNetwork() + ", running " + id + ", remaining: " + remaining);
@@ -102,7 +103,6 @@ public void onRun() throws Throwable {
 
         @Override
         protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            multiThreadedJobCounter.incrementAndGet();
             return true;
         }
     };
