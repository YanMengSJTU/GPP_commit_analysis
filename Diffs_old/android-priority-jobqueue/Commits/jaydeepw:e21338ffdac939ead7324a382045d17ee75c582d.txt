diff --git a/EnhancedPriorityJobQueue/jobqueue/jobqueue.iml b/EnhancedPriorityJobQueue/jobqueue/jobqueue.iml
index 4f019c8..532a1b9 100644
--- a/EnhancedPriorityJobQueue/jobqueue/jobqueue.iml
+++ b/EnhancedPriorityJobQueue/jobqueue/jobqueue.iml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="EnhancedPriorityJobQueue" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="incidentchanger" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">
   <component name="FacetManager">
     <facet type="android-gradle" name="Android-Gradle">
       <configuration>
@@ -10,7 +10,7 @@
       <configuration>
         <option name="SELECTED_BUILD_VARIANT" value="debug" />
         <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />
-        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />
+        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugJava" />
         <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />
         <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />
         <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/AndroidManifest.xml b/EnhancedPriorityJobQueue/jobqueue/src/main/AndroidManifest.xml
index c5be25c..240d32d 100644
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/AndroidManifest.xml
+++ b/EnhancedPriorityJobQueue/jobqueue/src/main/AndroidManifest.xml
@@ -1,9 +1,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="nl.changer.enhancedpriorityjobqueue">
 
-    <application android:allowBackup="true" android:label="@string/app_name"
-        android:icon="@drawable/ic_launcher" android:theme="@style/AppTheme">
-
-    </application>
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name" />
 
 </manifest>
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index 40a9826..756a513 100644
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue;
 
 import android.content.Context;
+
 import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.di.DependencyInjector;
@@ -11,8 +12,13 @@
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
 
+import java.util.ArrayList;
 import java.util.Collection;
-import java.util.concurrent.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
 
 /**
  * a JobManager that supports;
@@ -45,6 +51,7 @@
 
     /**
      * Default constructor that will create a JobManager with 1 {@link SqliteJobQueue} and 1 {@link NonPersistentPriorityQueue}
+     *
      * @param context job manager will use applicationContext.
      */
     public JobManager(Context context) {
@@ -54,20 +61,20 @@ public JobManager(Context context) {
 
     /**
      * Default constructor that will create a JobManager with a default {@link Configuration}
+     *
      * @param context application context
-     * @param id an id that is unique to this JobManager
+     * @param id      an id that is unique to this JobManager
      */
     public JobManager(Context context, String id) {
         this(context, new Configuration.Builder(context).id(id).build());
     }
 
     /**
-     *
      * @param context used to acquire ApplicationContext
      * @param config
      */
     public JobManager(Context context, Configuration config) {
-        if(config.getCustomLogger() != null) {
+        if (config.getCustomLogger() != null) {
             JqLog.setCustomLogger(config.getCustomLogger());
         }
         appContext = context.getApplicationContext();
@@ -81,11 +88,11 @@ public JobManager(Context context, Configuration config) {
 
         networkUtil = config.getNetworkUtil();
         dependencyInjector = config.getDependencyInjector();
-        if(networkUtil instanceof NetworkEventProvider) {
+        if (networkUtil instanceof NetworkEventProvider) {
             ((NetworkEventProvider) networkUtil).setListener(this);
         }
         //is important to initialize consumers last so that they can start running
-        jobConsumerExecutor = new JobConsumerExecutor(config,consumerContract);
+        jobConsumerExecutor = new JobConsumerExecutor(config, consumerContract);
         timedExecutor = Executors.newSingleThreadScheduledExecutor();
         start();
     }
@@ -102,7 +109,7 @@ public void stop() {
      * restarts the JobManager. Will create a new consumer if necessary.
      */
     public void start() {
-        if(running) {
+        if (running) {
             return;
         }
         running = true;
@@ -112,6 +119,7 @@ public void start() {
     /**
      * returns the # of jobs that are waiting to be executed.
      * This might be a good place to decide whether you should wake your app up on boot etc. to complete pending jobs.
+     *
      * @return # of total jobs.
      */
     public int count() {
@@ -125,20 +133,6 @@ public int count() {
         return cnt;
     }
 
-    public JobHolder findJobById(Long id, boolean isPersistent) {
-        JobHolder holder;
-        if(isPersistent) {
-            synchronized (persistentJobQueue) {
-                holder = persistentJobQueue.findJobById(id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                holder = nonPersistentJobQueue.findJobById(id);
-            }
-        }
-        return holder;
-    }
-
     private int countReadyJobs(boolean hasNetwork) {
         //TODO we can cache this
         int total = 0;
@@ -153,6 +147,7 @@ private int countReadyJobs(boolean hasNetwork) {
 
     /**
      * Adds a new Job to the list and returns an ID for it.
+     *
      * @param job to add
      * @return id for the job.
      */
@@ -163,9 +158,9 @@ public long addJob(Job job) {
 
     /**
      * Non-blocking convenience method to add a job in background thread.
-     * @see #addJob(Job)
-     * @param job job to add
      *
+     * @param job job to add
+     * @see #addJob(Job)
      */
     public void addJobInBackground(Job job) {
         //noinspection deprecation
@@ -184,7 +179,7 @@ private void addOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, lon
     //need to sync on related job queue before calling this
     private void waitForOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, long id) {
         CountDownLatch latch = lockMap.get(id);
-        if(latch == null) {
+        if (latch == null) {
             return;
         }
         try {
@@ -197,7 +192,7 @@ private void waitForOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap,
     //need to sync on related job queue before calling this
     private void clearOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, long id) {
         CountDownLatch latch = lockMap.get(id);
-        if(latch != null) {
+        if (latch != null) {
             latch.countDown();
         }
         lockMap.remove(id);
@@ -206,11 +201,12 @@ private void clearOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, l
     /**
      * checks next available job and returns when it will be available (if it will, otherwise returns {@link Long#MAX_VALUE})
      * also creates a timer to notify listeners at that time
+     *
      * @param hasNetwork .
      * @return time wait until next job (in milliseconds)
      */
     private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
-        if(hasNetwork == null) {
+        if (hasNetwork == null) {
             //if network util can inform us when network is recovered, we we'll check only next job that does not
             //require network. if it does not know how to inform us, we have to keep a busy loop.
             //noinspection SimplifiableConditionalExpression
@@ -222,7 +218,7 @@ private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
         synchronized (nonPersistentJobQueue) {
             nextRunNs = nonPersistentJobQueue.getNextJobDelayUntilNs(hasNetwork);
         }
-        if(nextRunNs != null && nextRunNs <= System.nanoTime()) {
+        if (nextRunNs != null && nextRunNs <= System.nanoTime()) {
             notifyJobConsumer();
             return 0L;
         }
@@ -230,20 +226,20 @@ private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
         synchronized (persistentJobQueue) {
             persistedJobRunNs = persistentJobQueue.getNextJobDelayUntilNs(hasNetwork);
         }
-        if(persistedJobRunNs != null) {
-            if(nextRunNs == null) {
+        if (persistedJobRunNs != null) {
+            if (nextRunNs == null) {
                 nextRunNs = persistedJobRunNs;
-            } else if(persistedJobRunNs < nextRunNs) {
+            } else if (persistedJobRunNs < nextRunNs) {
                 nextRunNs = persistedJobRunNs;
             }
         }
-        if(nextRunNs != null) {
+        if (nextRunNs != null) {
             //to avoid overflow, we need to check equality first
-            if(nextRunNs < System.nanoTime()) {
+            if (nextRunNs < System.nanoTime()) {
                 notifyJobConsumer();
                 return 0L;
             }
-            long diff = (long)Math.ceil((double)(nextRunNs - System.nanoTime()) / NS_PER_MS);
+            long diff = (long) Math.ceil((double) (nextRunNs - System.nanoTime()) / NS_PER_MS);
             ensureConsumerOnTime(diff);
             return diff;
         }
@@ -288,19 +284,19 @@ private JobHolder getNextJob() {
                     persistent = true;
                 }
             }
-            if(jobHolder == null) {
+            if (jobHolder == null) {
                 return null;
             }
-            if(persistent && dependencyInjector != null) {
+            if (persistent && dependencyInjector != null) {
                 dependencyInjector.inject(jobHolder.getBaseJob());
             }
-            if(jobHolder.getGroupId() != null) {
+            if (jobHolder.getGroupId() != null) {
                 runningJobGroups.add(jobHolder.getGroupId());
             }
         }
 
         //wait for onAdded locks. wait for locks after job is selected so that we minimize the lock
-        if(persistent) {
+        if (persistent) {
             waitForOnAddedLock(persistentOnAddedLocks, jobHolder.getId());
         } else {
             waitForOnAddedLock(nonPersistentOnAddedLocks, jobHolder.getId());
@@ -320,7 +316,7 @@ private void reAddJob(JobHolder jobHolder) {
                 nonPersistentJobQueue.insertOrReplace(jobHolder);
             }
         }
-        if(jobHolder.getGroupId() != null) {
+        if (jobHolder.getGroupId() != null) {
             runningJobGroups.remove(jobHolder.getGroupId());
         }
     }
@@ -328,23 +324,24 @@ private void reAddJob(JobHolder jobHolder) {
     /**
      * Returns the current status of a {@link Job}.
      * <p>
-     *     You should not call this method on the UI thread because it may make a db request.
+     * You should not call this method on the UI thread because it may make a db request.
      * </p>
      * <p>
-     *     This is not a very fast call so try not to make it unless necessary. Consider using events if you need to be
-     *     informed about a job's lifecycle.
+     * This is not a very fast call so try not to make it unless necessary. Consider using events if you need to be
+     * informed about a job's lifecycle.
      * </p>
-     * @param id the ID, returned by the addJob method
+     *
+     * @param id           the ID, returned by the addJob method
      * @param isPersistent Jobs are added to different queues depending on if they are persistent or not. This is necessary
      *                     because each queue has independent id sets.
      * @return
      */
     public JobStatus getJobStatus(long id, boolean isPersistent) {
-        if(jobConsumerExecutor.isRunning(id, isPersistent)) {
+        if (jobConsumerExecutor.isRunning(id, isPersistent)) {
             return JobStatus.RUNNING;
         }
         JobHolder holder;
-        if(isPersistent) {
+        if (isPersistent) {
             synchronized (persistentJobQueue) {
                 holder = persistentJobQueue.findJobById(id);
             }
@@ -353,14 +350,14 @@ public JobStatus getJobStatus(long id, boolean isPersistent) {
                 holder = nonPersistentJobQueue.findJobById(id);
             }
         }
-        if(holder == null) {
+        if (holder == null) {
             return JobStatus.UNKNOWN;
         }
         boolean network = hasNetwork();
-        if(holder.requiresNetwork() && !network) {
+        if (holder.requiresNetwork() && !network) {
             return JobStatus.WAITING_NOT_READY;
         }
-        if(holder.getDelayUntilNs() > System.nanoTime()) {
+        if (holder.getDelayUntilNs() > System.nanoTime()) {
             return JobStatus.WAITING_NOT_READY;
         }
 
@@ -377,7 +374,7 @@ private void removeJob(JobHolder jobHolder) {
                 nonPersistentJobQueue.remove(jobHolder);
             }
         }
-        if(jobHolder.getGroupId() != null) {
+        if (jobHolder.getGroupId() != null) {
             runningJobGroups.remove(jobHolder.getGroupId());
         }
     }
@@ -396,6 +393,7 @@ public synchronized void clear() {
 
     /**
      * if {@link NetworkUtil} implements {@link NetworkEventProvider}, this method is called when network is recovered
+     *
      * @param isConnected network connection state.
      */
     @Override
@@ -424,7 +422,7 @@ public void removeJob(JobHolder jobHolder) {
         public JobHolder getNextJob(int wait, TimeUnit waitDuration) {
             //be optimistic
             JobHolder nextJob = JobManager.this.getNextJob();
-            if(nextJob != null) {
+            if (nextJob != null) {
                 return nextJob;
             }
             long start = System.nanoTime();
@@ -435,16 +433,16 @@ public JobHolder getNextJob(int wait, TimeUnit waitDuration) {
             while (nextJob == null && waitUntil > System.nanoTime()) {
                 //keep running inside here to avoid busy loop
                 nextJob = running ? JobManager.this.getNextJob() : null;
-                if(nextJob == null) {
+                if (nextJob == null) {
                     long remaining = waitUntil - System.nanoTime();
-                    if(remaining > 0) {
+                    if (remaining > 0) {
                         //if we can't detect network changes, we won't be notified.
                         //to avoid waiting up to give time, wait in chunks of 500 ms max
                         long maxWait = Math.min(nextJobDelay, TimeUnit.NANOSECONDS.toMillis(remaining));
-                        if(maxWait < 1) {
+                        if (maxWait < 1) {
                             continue;//wait(0) will cause infinite wait.
                         }
-                        if(networkUtil instanceof NetworkEventProvider) {
+                        if (networkUtil instanceof NetworkEventProvider) {
                             //to handle delayed jobs, make sure we trigger this first
                             //looks like there is no job available right now, wait for an event.
                             //there is a chance that if it triggers a timer and it gets called before I enter
@@ -484,10 +482,11 @@ public int countRemainingReadyJobs() {
 
     /**
      * Deprecated, please use {@link #addJob(Job)}.
-     *
+     * <p/>
      * <p>Adds a job with given priority and returns the JobId.</p>
+     *
      * @param priority Higher runs first
-     * @param baseJob The actual job to run
+     * @param baseJob  The actual job to run
      * @return job id
      */
     @Deprecated
@@ -497,11 +496,12 @@ public long addJob(int priority, BaseJob baseJob) {
 
     /**
      * Deprecated, please use {@link #addJob(Job)}.
-     *
+     * <p/>
      * <p>Adds a job with given priority and returns the JobId.</p>
+     *
      * @param priority Higher runs first
-     * @param delay number of milliseconds that this job should be delayed
-     * @param baseJob The actual job to run
+     * @param delay    number of milliseconds that this job should be delayed
+     * @param baseJob  The actual job to run
      * @return a job id. is useless for now but we'll use this to cancel jobs in the future.
      */
     @Deprecated
@@ -519,17 +519,17 @@ public long addJob(int priority, long delay, BaseJob baseJob) {
                 addOnAddedLock(nonPersistentOnAddedLocks, id);
             }
         }
-        if(JqLog.isDebugEnabled()) {
+        if (JqLog.isDebugEnabled()) {
             JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
                     , id, baseJob.getClass().getSimpleName(), priority, delay, baseJob.getRunGroupId()
                     , baseJob.isPersistent(), baseJob.requiresNetwork());
         }
-        if(dependencyInjector != null) {
+        if (dependencyInjector != null) {
             //inject members b4 calling onAdded
             dependencyInjector.inject(baseJob);
         }
         jobHolder.getBaseJob().onAdded();
-        if(baseJob.isPersistent()) {
+        if (baseJob.isPersistent()) {
             synchronized (persistentJobQueue) {
                 clearOnAddedLock(persistentOnAddedLocks, id);
             }
@@ -561,6 +561,7 @@ public void run() {
     /**
      * Deprecated, please use {@link #addJobInBackground(Job)}.
      * <p></p>Non-blocking convenience method to add a job in background thread.</p>
+     *
      * @see #addJob(int, long, BaseJob) addJob(priority, delay, job).
      */
     @Deprecated
@@ -577,11 +578,11 @@ public void run() {
                 try {
                     final long runDelay = (System.nanoTime() - callTime) / NS_PER_MS;
                     long id = addJob(priority, Math.max(0, delay - runDelay), baseJob);
-                    if(callback != null) {
+                    if (callback != null) {
                         callback.onAdded(id);
                     }
                 } catch (Throwable t) {
-                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", baseJob.getClass().getSimpleName() );
+                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", baseJob.getClass().getSimpleName());
                 }
             }
         });
@@ -607,9 +608,37 @@ public DefaultQueueFactory(SqliteJobQueue.JobSerializer jobSerializer) {
         public JobQueue createPersistentQueue(Context context, Long sessionId, String id) {
             return new CachedJobQueue(new SqliteJobQueue(context, sessionId, id, jobSerializer));
         }
+
         @Override
         public JobQueue createNonPersistent(Context context, Long sessionId, String id) {
             return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id));
         }
     }
+
+    /**
+     * Gets the job by id. Needs enhancement for this method.
+     *
+     * @param id
+     * @param isPersistent
+     * @return
+     */
+    public JobHolder findJobById(Long id, boolean isPersistent) {
+        JobHolder holder;
+        if (isPersistent) {
+            synchronized (persistentJobQueue) {
+                holder = persistentJobQueue.findJobById(id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                holder = nonPersistentJobQueue.findJobById(id);
+            }
+        }
+        return holder;
+    }
+
+    public ArrayList<JobHolder> getAllJobs(boolean isPersistent) {
+        // TODO: provide the implementation for this.
+        return new ArrayList<JobHolder>();
+    }
+
 }
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
index cd4476c..5fc7b3c 100644
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
+++ b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
@@ -107,11 +107,6 @@ public JobHolder findJobById(long id) {
         return jobs.findById(id);
     }
 
-    @Override
-    public JobHolder getAllJobs() {
-        return null;
-    }
-
     public final Comparator<JobHolder> jobComparator = new Comparator<JobHolder>() {
         @Override
         public int compare(JobHolder holder1, JobHolder holder2) {
@@ -153,5 +148,9 @@ private static int compareLong(long l1, long l2) {
         return 0;
     }
 
+    @Override
+    public JobHolder getAllJobs() {
+        return null;
+    }
 
 }
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
index 0b83dce..2a8846c 100644
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ b/EnhancedPriorityJobQueue/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -5,6 +5,7 @@
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDoneException;
 import android.database.sqlite.SQLiteStatement;
+
 import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
@@ -178,11 +179,6 @@ public JobHolder findJobById(long id) {
         }
     }
 
-    @Override
-    public JobHolder getAllJobs() {
-        return null;
-    }
-
     /**
      * {@inheritDoc}
      */
@@ -308,7 +304,6 @@ private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidBaseJob
                 cursor.getLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex),
                 cursor.getLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex)
         );
-
     }
 
     private BaseJob safeDeserialize(byte[] bytes) {
@@ -380,4 +375,10 @@ private BaseJob safeDeserialize(byte[] bytes) {
         public byte[] serialize(Object object) throws IOException;
         public <T extends BaseJob> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException;
     }
+
+
+    @Override
+    public JobHolder getAllJobs() {
+        return null;
+    }
 }
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/res/values-v21/styles.xml b/EnhancedPriorityJobQueue/jobqueue/src/main/res/values-v21/styles.xml
deleted file mode 100644
index dba3c41..0000000
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/res/values-v21/styles.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <style name="AppTheme" parent="android:Theme.Material.Light">
-    </style>
-</resources>
diff --git a/EnhancedPriorityJobQueue/jobqueue/src/main/res/values/styles.xml b/EnhancedPriorityJobQueue/jobqueue/src/main/res/values/styles.xml
deleted file mode 100644
index ff6c9d2..0000000
--- a/EnhancedPriorityJobQueue/jobqueue/src/main/res/values/styles.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<resources>
-
-    <!-- Base application theme. -->
-    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
-        <!-- Customize your theme here. -->
-    </style>
-
-</resources>
