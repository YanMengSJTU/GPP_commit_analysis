diff --git a/build.gradle b/build.gradle
index 80eec1a..347504f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.9.+'
+        classpath 'com.android.tools.build:gradle:0.10.+'
     }
 }
 
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 593c8a8..4b808fb 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -1,23 +1,17 @@
 buildscript {
     repositories {
         mavenCentral()
-        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.9.+'
-        classpath "com.squareup.gradle:gradle-android-test-plugin:0.9.1-SNAPSHOT"
+        classpath 'com.android.tools.build:gradle:0.10.+'
     }
 }
 
 apply plugin: 'android-library'
-apply plugin: 'android-test'
 
 repositories {
     mavenCentral()
-    maven {
-        url 'https://oss.sonatype.org/content/repositories/snapshots/'
-    }
 }
 
 android {
@@ -27,19 +21,4 @@ android {
         minSdkVersion 7
         targetSdkVersion 18
     }
-
-    dependencies {
-        androidTestCompile 'org.easytesting:fest-util:1.1.2'
-        androidTestCompile 'org.hamcrest:hamcrest-core:1.3'
-        androidTestCompile 'junit:junit:4.11'
-        androidTestCompile 'org.robolectric:robolectric:2.2'
-        testCompile 'org.easytesting:fest-util:1.1.2'
-        testCompile 'org.hamcrest:hamcrest-core:1.3'
-        testCompile 'junit:junit:4.11'
-        testCompile 'org.robolectric:robolectric:2.2'
-    }
-
-    sourceSets {
-        androidTest.setRoot('src/test')
-    }
 }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
deleted file mode 100644
index 576452e..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.path.android.jobqueue.test;
-
-import android.util.Log;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.log.JqLog;
-import org.junit.Before;
-import org.robolectric.shadows.ShadowLog;
-
-public class TestBase {
-    protected static boolean ENABLE_DEBUG = false;
-    @Before
-    public void setUp() throws Exception {
-        if(ENABLE_DEBUG) {
-            enableDebug();
-        }
-    }
-
-    private void enableDebug() {
-        ShadowLog.stream = System.out;
-        JqLog.setCustomLogger(new CustomLogger() {
-            private String TAG = "test_logger";
-
-            @Override
-            public boolean isDebugEnabled() {
-                return true;
-            }
-
-            @Override
-            public void d(String text, Object... args) {
-                Log.d(TAG, String.format(text, args));
-            }
-
-            @Override
-            public void e(Throwable t, String text, Object... args) {
-                Log.e(TAG, String.format(text, args), t);
-            }
-
-            @Override
-            public void e(String text, Object... args) {
-                Log.e(TAG, String.format(text, args));
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
deleted file mode 100644
index 454d3c5..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.AsyncAddCallback;
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicLong;
-
-@RunWith(RobolectricTestRunner.class)
-public class AddInBackgroundTest extends JobManagerTestBase {
-    @Test
-    public void testAddInBackground() throws InterruptedException {
-        for(boolean delay : new boolean[]{true, false}) {
-            for(boolean useCallback : new boolean[]{true, false}) {
-                addInBackground(delay, useCallback);
-            }
-        }
-    }
-
-    public void addInBackground(boolean delayed, boolean useCallback) throws InterruptedException {
-        long currentThreadId = Thread.currentThread().getId();
-        final AtomicLong onAddedThreadId = new AtomicLong();
-        final CountDownLatch addedLatch = new CountDownLatch(2);
-
-        Job dummyJob = new DummyJob(new Params(1).setDelayMs(delayed ? 1000 : 0)) {
-            @Override
-            public void onAdded() {
-                super.onAdded();
-                onAddedThreadId.set(Thread.currentThread().getId());
-                addedLatch.countDown();
-            }
-        };
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        final AtomicLong jobId = new AtomicLong(0);
-        if(useCallback) {
-            jobManager.addJobInBackground(dummyJob, new AsyncAddCallback() {
-                @Override
-                public void onAdded(long id) {
-                    jobId.set(id);
-                    addedLatch.countDown();
-                }
-            });
-        } else {
-            addedLatch.countDown();
-            jobManager.addJobInBackground(dummyJob);
-        }
-        addedLatch.await();
-        MatcherAssert.assertThat("thread ids should be different. delayed:" + delayed, currentThreadId, CoreMatchers.not(onAddedThreadId.get()));
-        if(useCallback) {
-            JobQueue queue = getNonPersistentQueue(jobManager);
-            JobHolder holder = queue.findJobById(jobId.longValue());
-            MatcherAssert.assertThat("there should be a job in the holder. id:" + jobId.longValue() +", delayed:" + delayed + ", use cb:" + useCallback
-                    , holder, CoreMatchers.notNullValue());
-            MatcherAssert.assertThat("id callback should have the proper id:", holder.getBaseJob(), CoreMatchers.is((BaseJob) dummyJob));
-        }
-    }
-
-    protected JobQueue getNonPersistentQueue(JobManager jobManager) {
-        return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
deleted file mode 100644
index 327ea69..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-
-@RunWith(RobolectricTestRunner.class)
-public class AddedCountTest extends JobManagerTestBase {
-    @Test
-    public void testAddedCount() throws Exception {
-        testAddedCount(new DummyJob(new Params(0)));
-        testAddedCount(new DummyJob(new Params(0).persist()));
-
-    }
-
-    private void testAddedCount(DummyJob dummyJob) {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        jobManager.addJob(dummyJob);
-        MatcherAssert.assertThat(1, equalTo(dummyJob.getOnAddedCnt()));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java
deleted file mode 100644
index a8a107e..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.AsyncCancelCallback;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-
-import org.fest.reflect.core.Reflection;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicLong;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(RobolectricTestRunner.class)
-public class CancelInBackgroundTest extends JobManagerTestBase {
-    @Test
-    public void testCancelInBackground() throws Exception {
-        cancelInBackground(true);
-        cancelInBackground(false);
-    }
-
-    public void cancelInBackground(final boolean useCallback) throws Exception {
-        long currentThreadId = Thread.currentThread().getId();
-        final AtomicLong onCancelThreadId = new AtomicLong();
-        final CountDownLatch cancelLatch = new CountDownLatch(2);
-
-        Job dummyJob = new DummyJob(new Params(1)) {
-            @Override
-            public void onCancel() {
-                super.onCancel();
-                onCancelThreadId.set(Thread.currentThread().getId());
-                cancelLatch.countDown();
-            }
-        };
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        final long jobId = jobManager.addJob(dummyJob);
-        final JobQueue queue = getNonPersistentQueue(jobManager);
-        assertNotNull(queue.findJobById(jobId));
-        if (useCallback) {
-            jobManager.cancelJobInBackground(jobId, false, new AsyncCancelCallback() {
-                @Override
-                public void onCancel(long callbackJobId, boolean isCanceled) {
-                    assertEquals("jobId should be passsed to callback. id:" + jobId + ", use cb: true"
-                            , jobId, callbackJobId);
-                    assertTrue("isCanceled should be true" , isCanceled);
-                    cancelLatch.countDown();
-                }
-            });
-        } else {
-            cancelLatch.countDown();
-            jobManager.cancelJobInBackground(jobId, false);
-        }
-        cancelLatch.await();
-        MatcherAssert.assertThat("thread ids should be different." , currentThreadId, CoreMatchers.not(onCancelThreadId.get()));
-        if (useCallback) {
-            JobHolder holder = queue.findJobById(jobId);
-            MatcherAssert.assertThat("there should not be a job in the holder. id:" + jobId + ", use cb: true"
-                    , holder, CoreMatchers.nullValue());
-        }
-    }
-
-    protected JobQueue getNonPersistentQueue(JobManager jobManager) {
-        return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java
deleted file mode 100644
index 027a57f..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-
-import org.fest.reflect.core.Reflection;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import java.util.concurrent.CountDownLatch;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(RobolectricTestRunner.class)
-public class CancelJobTest extends JobManagerTestBase {
-    @Test
-    public void testCancelJob() throws Exception {
-        testCancelJob(false);
-        testCancelJob(true);
-    }
-
-    private void testCancelJob(boolean isPersistent) {
-        DummyJob dummyJob = new DummyJob(new Params(0).setPersistent(isPersistent));
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        long jobId = jobManager.addJob(dummyJob);
-        JobQueue queue = getQueue(jobManager, isPersistent);
-        assertNotNull("there should be a job in the holder. id:" + jobId + ", isPersistent:" + isPersistent
-                , queue.findJobById(jobId));
-        boolean isCanceled = jobManager.cancelJob(jobId, isPersistent);
-        assertTrue("cancelJob() should return true. id: " + jobId + ", isPersistent:" + isPersistent
-                , isCanceled);
-        assertNull("there should not be a job exists in queue. id:" + jobId + ", isPersistent:" + isPersistent
-                , queue.findJobById(jobId));
-        // the job handled in manager and the one here are different instance if persistent.
-        if (!isPersistent) {
-            assertEquals("job.onCancel() should be called once. id:" + jobId + ", isPersistent: false"
-                    , 1, dummyJob.getOnCancelCnt());
-        }
-    }
-
-    @Test
-    public void testCancelRunningJob() throws Exception {
-        final CountDownLatch runWaitLatch = new CountDownLatch(1);
-        final CountDownLatch runEndLatch = new CountDownLatch(1);
-        DummyJob dummyJob = new DummyJob(new Params(0)) {
-            @Override
-            public void onRun() throws Throwable {
-                super.onRun();
-                runWaitLatch.countDown();
-                runEndLatch.await();
-            }
-        };
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        long jobId = jobManager.addJob(dummyJob);
-        JobQueue queue = getQueue(jobManager, false);
-        assertNotNull("there should be a job in the holder. id:" + jobId
-                , queue.findJobById(jobId));
-        jobManager.start();
-        runWaitLatch.await();
-        boolean isCanceled = jobManager.cancelJob(jobId, false);
-        assertFalse("cancelJob() should return false. id: " + jobId, isCanceled);
-        runEndLatch.countDown();
-        jobManager.stop();
-    }
-
-    @Test
-    public void testCancelNotExistJob() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        long jobId = 0xDEADBEEF;
-        boolean isCanceled = jobManager.cancelJob(jobId, false);
-        assertFalse("cancelJob() should return false. id: " + jobId, isCanceled);
-    }
-
-    private JobQueue getQueue(JobManager jobManager, boolean isPersistent) {
-        if (isPersistent) {
-            return Reflection.field("persistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
-        } else {
-            return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
deleted file mode 100644
index 89f2e81..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class ClearTest extends JobManagerTestBase {
-    @Test
-    public void testClear() throws Exception {
-        JobManager jobManager = createJobManager();
-        final int LIMIT = 20;
-        for(int i = 0; i < LIMIT; i++) {
-            jobManager.addJob(new DummyJob(new Params(0).setPersistent(i % 2 == 1)));
-        }
-        jobManager.clear();
-        MatcherAssert.assertThat("after clear, count should be 0", jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
deleted file mode 100644
index 5fb1537..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-public class ConsumerCountTest extends JobManagerTestBase {
-    @Test
-    public void testMaxConsumerCount() throws Exception {
-        int maxConsumerCount = 2;
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
-                .maxConsumerCount(maxConsumerCount)
-                .loadFactor(maxConsumerCount));
-        Object runLock = new Object();
-        Semaphore semaphore = new Semaphore(maxConsumerCount);
-        int totalJobCount = maxConsumerCount * 3;
-        List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
-        for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
-            runningJobs.add(job);
-            jobManager.addJob(job);
-        }
-        //wait till enough jobs start
-        long now = System.nanoTime();
-        long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            if(semaphore.availablePermits() == 0) {
-                //enough # of jobs started
-                break;
-            }
-        }
-        //wait some more to ensure no more jobs are started
-        Thread.sleep(TimeUnit.SECONDS.toMillis(3));
-        int totalRunningCount = 0;
-        for(DummyJob job : runningJobs) {
-            totalRunningCount += job.getOnRunCnt();
-        }
-        MatcherAssert.assertThat("only maxConsumerCount jobs should start", totalRunningCount, equalTo(maxConsumerCount));
-        //try to finish all jobs
-        //wait till enough jobs start
-        now = System.nanoTime();
-        waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            synchronized (runLock) {
-                runLock.notifyAll();
-            }
-            totalRunningCount = 0;
-            for(DummyJob job : runningJobs) {
-                totalRunningCount += job.getOnRunCnt();
-            }
-            if(totalJobCount == totalRunningCount) {
-                //cool!
-                break;
-            }
-        }
-        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
deleted file mode 100644
index 26a2604..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class CountTest extends JobManagerTestBase {
-    @Test
-    public void testCount() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        for (int i = 0; i < 10; i++) {
-            jobManager.addJob(new DummyJob(new Params(0).persist()));
-            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 1));
-            jobManager.addJob(new DummyJob(new Params(0).persist()));
-            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 2));
-        }
-        jobManager.start();
-        Thread.sleep(2000);
-        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
deleted file mode 100644
index 6d0139e..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.*;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class DelayTest extends JobManagerTestBase {
-    @Test
-    public void testDelay() throws Exception {
-        testDelay(false);
-        testDelay(true);
-    }
-
-    public void testDelay(boolean persist) throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(1000).setPersistent(persist));
-        DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
-        long jobId = jobManager.addJob(delayedJob);
-        long nonDelayedJobId = jobManager.addJob(nonDelayedJob);
-
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
-
-        JobHolder receivedJob = nextJobMethod.invoke();
-        MatcherAssert.assertThat("non-delayed job should be served", receivedJob, notNullValue());
-        MatcherAssert.assertThat("non-delayed job should id should match",  receivedJob.getId(), equalTo(nonDelayedJobId));
-        removeJobMethod.invoke(receivedJob);
-        MatcherAssert.assertThat("delayed job should not be served",  nextJobMethod.invoke(), nullValue());
-        MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        Thread.sleep(500);
-        MatcherAssert.assertThat("delayed job should not be served",  nextJobMethod.invoke(), nullValue());
-        MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        Thread.sleep(2000);
-        MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        receivedJob = nextJobMethod.invoke();
-        MatcherAssert.assertThat("now should be able to receive the delayed job.", receivedJob, notNullValue());
-        if(receivedJob != null) {
-            MatcherAssert.assertThat("received job should be the delayed job", receivedJob.getId(), equalTo(jobId));
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
deleted file mode 100644
index f2d93e4..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class DelayedRunTest extends JobManagerTestBase {
-    @Test
-    public void testDelayedRun() throws Exception {
-        testDelayedRun(false, false);
-        testDelayedRun(true, false);
-        testDelayedRun(false, true);
-        testDelayedRun(true, true);
-    }
-    public void testDelayedRun(boolean persist, boolean tryToStop) throws Exception {
-        JobManager jobManager = createJobManager();
-        DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(2000).setPersistent(persist));
-        DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
-        jobManager.addJob(delayedJob);
-        jobManager.addJob(nonDelayedJob);
-        Thread.sleep(500);
-        MatcherAssert.assertThat("there should be 1 delayed job waiting to be run", jobManager.count(), equalTo(1));
-        if(tryToStop) {//see issue #11
-            jobManager.stop();
-            Thread.sleep(3000);
-            MatcherAssert.assertThat("there should still be 1 delayed job waiting to be run when job manager is stopped",
-                    jobManager.count(), equalTo(1));
-            jobManager.start();
-        }
-        Thread.sleep(3000);
-        MatcherAssert.assertThat("all jobs should be completed", jobManager.count(), equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
deleted file mode 100644
index 0739d3c..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.*;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class GroupingTest extends JobManagerTestBase {
-    @Test
-    public void testGrouping() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
-
-        long jobId1 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
-        long jobId2 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
-        long jobId3 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group2")));
-        long jobId4 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group1")));
-        JobHolder nextJob = nextJobMethod.invoke();
-        MatcherAssert.assertThat("next job should be the first job from group1", nextJob.getId(), equalTo(jobId1));
-        JobHolder group2Job = nextJobMethod.invoke();
-        MatcherAssert.assertThat("since group 1 is running now, next job should be from group 2", group2Job.getId(), equalTo(jobId3));
-        removeJobMethod.invoke(nextJob);
-        JobHolder group1NextJob =nextJobMethod.invoke();
-        MatcherAssert.assertThat("after removing job from group 1, another job from group1 should be returned", group1NextJob.getId(), equalTo(jobId2));
-        MatcherAssert.assertThat("when jobs from both groups are running, no job should be returned from next job", nextJobMethod.invoke(), is(nullValue()));
-        removeJobMethod.invoke(group2Job);
-        MatcherAssert.assertThat("even after group2 job is complete, no jobs should be returned since we only have group1 jobs left", nextJobMethod.invoke(), is(nullValue()));
-    }
-
-    @Test
-    public void testGroupingRaceCondition() throws Exception {
-        DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
-                .minConsumerCount(5).maxConsumerCount(10)
-                .networkUtil(dummyNetworkUtil));
-        dummyNetworkUtil.setHasNetwork(false, true);
-        //add a bunch of network requring jobs
-        final String GROUP_ID = "shared_group_id";
-        final int AFTER_ADDED_JOBS_COUNT = 5;
-        final int NOT_SET_JOB_ID = -1;
-        final AtomicInteger firstRunJob = new AtomicInteger(NOT_SET_JOB_ID);
-        final int FIRST_JOB_ID = -10;
-        final CountDownLatch onAddedCalled = new CountDownLatch(1);
-        final CountDownLatch remainingJobsOnAddedCalled = new CountDownLatch(AFTER_ADDED_JOBS_COUNT);
-        jobManager.addJobInBackground(new DummyJob(new Params(10).requireNetwork().groupBy(GROUP_ID)) {
-            @Override
-            public void onAdded() {
-                super.onAdded();
-                onAddedCalled.countDown();
-                try {
-                    //wait until all other jobs are added
-                    remainingJobsOnAddedCalled.await();
-                    //wait a bit after all are added,
-                    Thread.sleep(1000);
-                } catch (InterruptedException e) {
-                }
-            }
-
-            @Override
-            public void onRun() throws Throwable {
-                super.onRun();
-                firstRunJob.compareAndSet(NOT_SET_JOB_ID, FIRST_JOB_ID);
-            }
-        });
-        //ensure first jobs on added is called
-        onAddedCalled.await();
-        for(int i = 0; i < AFTER_ADDED_JOBS_COUNT; i ++) {
-            final int finalI = i;
-            jobManager.addJob(new DummyJob(new Params(5).groupBy(GROUP_ID).requireNetwork()) {
-                final int id = finalI + 1;
-
-                @Override
-                public void onAdded() {
-                    super.onAdded();
-                    remainingJobsOnAddedCalled.countDown();
-                }
-
-                @Override
-                public void onRun() throws Throwable {
-                    super.onRun();
-                    firstRunJob.compareAndSet(NOT_SET_JOB_ID, id);
-                }
-            });
-        }
-        dummyNetworkUtil.setHasNetwork(true, true);
-        //wait until all jobs are completed
-        while(firstRunJob.get() == NOT_SET_JOB_ID) {
-            Thread.sleep(100);
-        }
-        MatcherAssert.assertThat("highest priority job should run if it is added before others", firstRunJob.get(), is(FIRST_JOB_ID));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
deleted file mode 100644
index 7129710..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.di.DependencyInjector;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class InjectorTest extends JobManagerTestBase {
-    @Test
-    public void testInjector() throws Exception {
-        Configuration.Builder builder = new Configuration.Builder(Robolectric.application);
-        final JobManagerTestBase.ObjectReference injectedJobReference = new JobManagerTestBase.ObjectReference();
-        final AtomicInteger injectionCallCount = new AtomicInteger(0);
-        DependencyInjector dependencyInjector = new DependencyInjector() {
-            @Override
-            public void inject(BaseJob job) {
-                injectedJobReference.setObject(job);
-                injectionCallCount.incrementAndGet();
-            }
-        };
-        builder.injector(dependencyInjector);
-        JobManager jobManager = createJobManager(builder);
-        jobManager.stop();
-        jobManager.addJob(new DummyJob(new Params(4)));
-        MatcherAssert.assertThat("injection should be called after adding a non-persistent job", injectionCallCount.get(), equalTo(1));
-        jobManager.addJob(new DummyJob(new Params(1).persist()));
-        MatcherAssert.assertThat("injection should be called after adding a persistent job", injectionCallCount.get(), equalTo(2));
-        JobHolder holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getBaseJob(), not(injectedJobReference.getObject()));
-        MatcherAssert.assertThat("injection should be called once for non persistent job", injectionCallCount.get(), equalTo(2));
-        holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should be called for persistent job", holder.getBaseJob(), equalTo(injectedJobReference.getObject()));
-        MatcherAssert.assertThat("injection should be called two times for persistent job", injectionCallCount.get(), equalTo(3));
-    }
-
-    @Test
-    public void testInjectorCrash() throws Exception {
-        final String EXCEPTION_MESSAGE = "could not inject for whatever reason :)";
-        DependencyInjector dummyDependencyInjector = new DependencyInjector() {
-            @Override
-            public void inject(BaseJob baseJob) {
-                throw new RuntimeException(EXCEPTION_MESSAGE);
-            }
-        };
-
-        final ObjectReference objectReference = new ObjectReference();
-        final CountDownLatch exceptionLatch = new CountDownLatch(1);
-        CustomLogger customLogger = new CustomLogger() {
-            @Override
-            public boolean isDebugEnabled() {
-                return false;
-            }
-
-            @Override
-            public void d(String s, Object... objects) {
-
-            }
-
-            @Override
-            public void e(Throwable throwable, String s, Object... objects) {
-                objectReference.setObject(throwable);
-                exceptionLatch.countDown();
-            }
-
-            @Override
-            public void e(String s, Object... objects) {
-                //
-            }
-        };
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).injector(dummyDependencyInjector).customLogger(customLogger));
-        Throwable addException = null;
-        try {
-            jobManager.addJob(new DummyJob(new Params(0)));
-        } catch (Throwable t) {
-            addException = t;
-        }
-        MatcherAssert.assertThat("addJob should throw exception if dependency injector throws exception", addException, notNullValue());
-        jobManager.addJobInBackground(new DummyJob(new Params(0)));
-        exceptionLatch.await(2, TimeUnit.SECONDS);
-        MatcherAssert.assertThat("there should be a received exception", objectReference.getObject(), notNullValue());
-        MatcherAssert.assertThat("logged exception should be a runtime exception", objectReference.getObject(), instanceOf(RuntimeException.class));
-        MatcherAssert.assertThat("logged exception should have expected message", ((Throwable)objectReference.getObject()).getMessage(), is(EXCEPTION_MESSAGE));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
deleted file mode 100644
index d416b76..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ /dev/null
@@ -1,190 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import android.content.Context;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.executor.JobConsumerExecutor;
-import com.path.android.jobqueue.network.NetworkEventProvider;
-import com.path.android.jobqueue.network.NetworkUtil;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.fest.reflect.method.*;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.robolectric.*;
-
-import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class JobManagerTestBase extends TestBase {
-    protected JobManager createJobManager() {
-        return new JobManager(Robolectric.application, UUID.randomUUID().toString());
-    }
-
-    protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
-        return new JobManager(Robolectric.application, configurationBuilder.id(UUID.randomUUID().toString()).build());
-    }
-
-
-
-    protected static class DummyTwoLatchJob extends DummyJob {
-        private final CountDownLatch waitFor;
-        private final CountDownLatch trigger;
-        private final CountDownLatch onRunLatch;
-
-        protected DummyTwoLatchJob(Params params, CountDownLatch waitFor, CountDownLatch trigger) {
-            super(params);
-            this.waitFor = waitFor;
-            this.trigger = trigger;
-            onRunLatch = new CountDownLatch(1);
-        }
-
-        public void waitTillOnRun() throws InterruptedException {
-            onRunLatch.await();
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            onRunLatch.countDown();
-            waitFor.await();
-            super.onRun();
-            trigger.countDown();
-        }
-    }
-
-    protected static class DummyLatchJob extends DummyJob {
-        private final CountDownLatch latch;
-
-        protected DummyLatchJob(Params params, CountDownLatch latch) {
-            super(params);
-            this.latch = latch;
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            super.onRun();
-            latch.countDown();
-        }
-    }
-
-
-    protected static class DummyJobWithRunCount extends DummyJob {
-        public static int runCount;
-        protected DummyJobWithRunCount(boolean persistent) {
-            super(new Params(0).setPersistent(persistent));
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            runCount++;
-            super.onRun();
-            throw new RuntimeException("i am dummy, i throw exception when running");
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return true;
-        }
-
-        @Override
-        protected int getRetryLimit() {
-            return 5;
-        }
-    }
-
-
-
-
-    protected static class DummyNetworkUtil implements NetworkUtil {
-        private boolean hasNetwork;
-
-        protected void setHasNetwork(boolean hasNetwork) {
-            this.hasNetwork = hasNetwork;
-        }
-
-        @Override
-        public boolean isConnected(Context context) {
-            return hasNetwork;
-        }
-    }
-
-    protected static class DummyNetworkUtilWithConnectivityEventSupport implements NetworkUtil, NetworkEventProvider {
-        private boolean hasNetwork;
-        private Listener listener;
-
-        protected void setHasNetwork(boolean hasNetwork, boolean notifyListener) {
-            this.hasNetwork = hasNetwork;
-            if(notifyListener && listener != null) {
-                listener.onNetworkChange(hasNetwork);
-            }
-        }
-
-        @Override
-        public boolean isConnected(Context context) {
-            return hasNetwork;
-        }
-
-        @Override
-        public void setListener(Listener listener) {
-            this.listener = listener;
-        }
-
-        public boolean isConnected() {
-            return hasNetwork;
-        }
-    }
-
-    protected static class ObjectReference {
-        Object object;
-
-        Object getObject() {
-            return object;
-        }
-
-        void setObject(Object object) {
-            this.object = object;
-        }
-    }
-
-    protected Invoker<JobHolder> getNextJobMethod(JobManager jobManager) {
-        return Reflection.method("getNextJob").withReturnType(JobHolder.class).in(jobManager);
-    }
-
-    protected Invoker<Void> getRemoveJobMethod(JobManager jobManager) {
-        return Reflection.method("removeJob").withParameterTypes(JobHolder.class).in(jobManager);
-    }
-
-    protected JobConsumerExecutor getConsumerExecutor(JobManager jobManager) {
-        return Reflection.field("jobConsumerExecutor").ofType(JobConsumerExecutor.class).in(jobManager).get();
-    }
-
-    protected org.fest.reflect.field.Invoker<AtomicInteger> getActiveConsumerCount(JobConsumerExecutor jobConsumerExecutor) {
-        return Reflection.field("activeConsumerCount").ofType(AtomicInteger.class).in(jobConsumerExecutor);
-    }
-
-    public static class NeverEndingDummyJob extends DummyJob {
-        final Object lock;
-        final Semaphore semaphore;
-        public NeverEndingDummyJob(Params params, Object lock, Semaphore semaphore) {
-            super(params);
-            this.lock = lock;
-            this.semaphore = semaphore;
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            super.onRun();
-            MatcherAssert.assertThat("job should be able to acquire a semaphore",
-                    semaphore.tryAcquire(), equalTo(true));
-            synchronized (lock) {
-                lock.wait();
-            }
-            semaphore.release();
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
deleted file mode 100644
index 28656ba..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobStatus;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
-@RunWith(RobolectricTestRunner.class)
-public class JobStatusTest extends JobManagerTestBase {
-    @Test
-    public void testJobStatus() throws InterruptedException {
-        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        networkUtil.setHasNetwork(false, true);
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(networkUtil));
-        jobManager.stop();
-        List<Integer> networkRequiringJobIndices = new ArrayList<Integer>();
-        Job[] jobs = new Job[] {
-                new DummyJob(new Params(0)),
-                new DummyJob(new Params(0).persist()),
-                new DummyJob(new Params(0).persist().requireNetwork())
-        };
-        long[] ids = new long[jobs.length];
-        for(int i = 0; i < jobs.length; i ++) {
-            ids[i] = jobManager.addJob(jobs[i]);
-            if(jobs[i].requiresNetwork()) {
-                networkRequiringJobIndices.add(i);
-            }
-            JobStatus expectedStatus = (networkUtil.isConnected() || jobs[i].requiresNetwork() == false) ? JobStatus.WAITING_READY :
-                    JobStatus.WAITING_NOT_READY;
-            assertThat("job should have correct status after being added",
-                    jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(expectedStatus));
-        }
-
-        //create an unknown id, ensure status for that
-
-        boolean exists;
-        long unknownId;
-        do {
-            unknownId = (long) (Math.random() * 10000 - 5000);
-            exists = false;
-            for(long id : ids) {
-                if(id == unknownId) {
-                    exists = true;
-                    continue;
-                }
-            }
-        } while (exists);
-        for(boolean persistent : new boolean[]{true, false}) {
-            assertThat("job with unknown id should return as expected", jobManager.getJobStatus(unknownId, persistent), is(JobStatus.UNKNOWN));
-        }
-
-        CountDownLatch startLatch = new CountDownLatch(1), endLatch = new CountDownLatch(1);
-        DummyTwoLatchJob twoLatchJob = new DummyTwoLatchJob(new Params(0), startLatch, endLatch);
-        jobManager.start();
-        long jobId = jobManager.addJob(twoLatchJob);
-        twoLatchJob.waitTillOnRun();
-        assertThat("job should be in running state", jobManager.getJobStatus(jobId, false), is(JobStatus.RUNNING));
-        startLatch.countDown();//let it run
-        endLatch.await();//wait till it finishes
-        Thread.sleep(500);//give some time to job manager to clear the job
-        assertThat("finished job should go to unknown state", jobManager.getJobStatus(jobId, false), is(JobStatus.UNKNOWN));
-
-        //network requiring job should not be ready
-        for(Integer i : networkRequiringJobIndices) {
-            assertThat("network requiring job should still be not-ready", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-        }
-        jobManager.stop();
-        networkUtil.setHasNetwork(true, true);
-        for(Integer i : networkRequiringJobIndices) {
-            assertThat("network requiring job should still be ready after network is there", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_READY));
-        }
-
-        jobManager.start();
-        int limit = 10;
-        while (jobManager.count() > 0 && limit--  > 0) {
-            Thread.sleep(1000);
-        }
-        assertThat("jobs should finish", jobManager.count(), is(0));
-        for(int i = 0; i < jobs.length; i ++) {
-            //after all jobs finish, state should be unknown
-            assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.UNKNOWN));
-        }
-        final long SHORT_SLEEP = 1000;
-        Job[] delayedJobs = new Job[]{
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
-        long[] delayedIds = new long[delayedJobs.length];
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            delayedIds[i] = jobManager.addJob(delayedJobs[i]);
-        }
-
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            assertThat("delayed job(" + i + ") should receive not ready status", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-        }
-        jobManager.stop();
-        //sleep
-        Thread.sleep(SHORT_SLEEP * 2);
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
-                assertThat("when enough time passes, delayed jobs should move to ready state", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_READY));
-            } else {
-                assertThat("delayed job should receive not ready status until their time comes", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-            }
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
deleted file mode 100644
index fcdc80d..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class KeepAliveTest extends JobManagerTestBase {
-    @Test
-    public void testKeepAlive() throws Exception {
-        int keepAlive = 3 + (int)(Math.random() * 5);
-        DummyNetworkUtil networkUtilWithoutEventSupport = new DummyNetworkUtil();
-        DummyNetworkUtilWithConnectivityEventSupport networkUtilWithEventSupport = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager1 = createJobManager(new Configuration.Builder(Robolectric.application)
-                .consumerKeepAlive(keepAlive).networkUtil(networkUtilWithoutEventSupport));
-        JobManager jobManager2 = createJobManager(new Configuration.Builder(Robolectric.application)
-                .consumerKeepAlive(keepAlive)
-                .networkUtil(networkUtilWithEventSupport));
-        //give it a little time to create first consumer
-        jobManager1.addJob(new DummyJob(new Params(0)));
-        jobManager2.addJob(new DummyJob(new Params(0)));
-        AtomicInteger activeThreadCount1 = getActiveConsumerCount(getConsumerExecutor(jobManager1)).get();
-        AtomicInteger activeThreadCount2 = getActiveConsumerCount(getConsumerExecutor(jobManager2)).get();
-
-        Thread.sleep(1000);
-        MatcherAssert.assertThat("there should be 1 thread  actively waiting for jobs",
-                activeThreadCount1.get(), equalTo(1));
-        MatcherAssert.assertThat("there should be one thread actively waiting for jobs",
-                activeThreadCount2.get(), equalTo(1));
-        //sleep till it dies
-        Thread.sleep((long) (TimeUnit.SECONDS.toMillis(keepAlive) * 1.33));
-        MatcherAssert.assertThat("after keep alive timeout, there should NOT be any threads waiting",
-                activeThreadCount1.get(), equalTo(0));
-        MatcherAssert.assertThat("after keep alive timeout, there should NOT be any threads waiting",
-                activeThreadCount2.get(), equalTo(0));
-
-
-        //disable network and add a network bound job
-        networkUtilWithoutEventSupport.setHasNetwork(false);
-        networkUtilWithEventSupport.setHasNetwork(false, true);
-        jobManager1.addJob(new DummyJob(new Params(0).requireNetwork()));
-        jobManager2.addJob(new DummyJob(new Params(0).requireNetwork()));
-        Thread.sleep(1000 + (long) (TimeUnit.SECONDS.toMillis(keepAlive) * 2));
-        MatcherAssert.assertThat("when network changes cannot be detected, there should be a consumer waiting alive",
-                activeThreadCount1.get(), equalTo(1));
-        MatcherAssert.assertThat("when network changes can be detected, there should not be a consumer waiting alive",
-                activeThreadCount2.get(), equalTo(0));
-        networkUtilWithEventSupport.setHasNetwork(true, true);
-        networkUtilWithoutEventSupport.setHasNetwork(true);
-        Thread.sleep(500);
-        MatcherAssert.assertThat("when network is recovered, job should be handled",
-                jobManager2.count(), equalTo(0));
-        Thread.sleep(1000);
-        MatcherAssert.assertThat("when network is recovered, job should be handled",
-                jobManager1.count(), equalTo(0));
-
-
-    }
-
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
deleted file mode 100644
index f713c47..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.executor.JobConsumerExecutor;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class LoadFactorTest extends JobManagerTestBase {
-    @Test
-    public void testLoadFactor() throws Exception {
-        //test adding zillions of jobs from the same group and ensure no more than 1 thread is created
-        int maxConsumerCount = 5;
-        int minConsumerCount = 2;
-        int loadFactor = 5;
-        com.path.android.jobqueue.JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
-                .maxConsumerCount(maxConsumerCount)
-                .minConsumerCount(minConsumerCount)
-                .customLogger(new CustomLogger() {
-                    public boolean isDebugEnabled() {return true;}
-                    public void d(String text, Object... args) {System.out.println(String.format(text, args));}
-                    public void e(Throwable t, String text, Object... args) {t.printStackTrace(); System.out.println(String.format(text, args));}
-                    public void e(String text, Object... args) {System.out.println(String.format(text, args));}
-                })
-                .loadFactor(loadFactor));
-        JobConsumerExecutor consumerExecutor = getConsumerExecutor(jobManager);
-        org.fest.reflect.field.Invoker<AtomicInteger> activeConsumerCnt = getActiveConsumerCount(consumerExecutor);
-        Object runLock = new Object();
-        Semaphore semaphore = new Semaphore(maxConsumerCount);
-        int totalJobCount = loadFactor * maxConsumerCount * 5;
-        List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
-        for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
-            runningJobs.add(job);
-            jobManager.addJob(job);
-
-            int expectedConsumerCount = Math.min(maxConsumerCount, (int)Math.ceil((float)(i+1) / loadFactor));
-            if(i >= minConsumerCount) {
-                expectedConsumerCount = Math.max(minConsumerCount, expectedConsumerCount);
-            }
-            //wait till enough jobs start
-            long now = System.nanoTime();
-            long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-            while(System.nanoTime() < waitTill) {
-                if(semaphore.availablePermits() == maxConsumerCount - expectedConsumerCount) {
-                    //enough # of jobs started
-                    break;
-                }
-            }
-            if(i < loadFactor) {
-                //make sure there is only min job running
-                MatcherAssert.assertThat("while below load factor, active consumer count should be = min",
-                        activeConsumerCnt.get().get(), equalTo(Math.min(i + 1, minConsumerCount)));
-            }
-            if(i > loadFactor) {
-                //make sure there is only 1 job running
-                MatcherAssert.assertThat("while above load factor. there should be more job consumers. i=" + i,
-                        activeConsumerCnt.get().get(), equalTo(expectedConsumerCount));
-            }
-        }
-
-        //finish all jobs
-        long now = System.nanoTime();
-        long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            synchronized (runLock) {
-                runLock.notifyAll();
-            }
-            long totalRunningCount = 0;
-            for(DummyJob job : runningJobs) {
-                totalRunningCount += job.getOnRunCnt();
-            }
-            if(totalJobCount == totalRunningCount) {
-                //cool!
-                break;
-            }
-        }
-        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
deleted file mode 100644
index bbfcbed..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import android.util.Log;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.Collection;
-import java.util.LinkedList;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class MultiThreadTest extends JobManagerTestBase {
-    private static AtomicInteger multiThreadedJobCounter;
-    @Test
-    public void testMultiThreaded() throws Exception {
-        multiThreadedJobCounter = new AtomicInteger(0);
-        final JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
-            .loadFactor(3).maxConsumerCount(10));
-        int limit = 200;
-        ExecutorService executor = new ThreadPoolExecutor(20, 20, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(limit));
-        Collection<Future<?>> futures = new LinkedList<Future<?>>();
-        for(int i = 0; i < limit; i++) {
-            final int id = i;
-            futures.add(executor.submit(new Runnable() {
-                @Override
-                public void run() {
-                    final boolean persistent = Math.round(Math.random()) % 2 == 0;
-                    boolean requiresNetwork = Math.round(Math.random()) % 2 == 0;
-                    int priority = (int) (Math.round(Math.random()) % 10);
-                    multiThreadedJobCounter.incrementAndGet();
-                    jobManager.addJob(new DummyJobForMultiThread(id, new Params(priority).setRequiresNetwork(requiresNetwork).setPersistent(persistent)));
-                }
-            }));
-        }
-        for (Future<?> future:futures) {
-            future.get();
-        }
-        Log.d("TAG", "added all jobs");
-        //wait until all jobs are added
-        long start = System.nanoTime();
-        long timeLimit = JobManager.NS_PER_MS * 20000;//20 seconds
-        while(System.nanoTime() - start < timeLimit && multiThreadedJobCounter.get() != 0) {
-            Thread.sleep(1000);
-        }
-        Log.d("TAG", "did we reach timeout? " + (System.nanoTime() - start >= timeLimit));
-
-        MatcherAssert.assertThat("jobmanager count should be 0",
-                jobManager.count(), equalTo(0));
-
-        MatcherAssert.assertThat("multiThreadedJobCounter should be 0",
-                multiThreadedJobCounter.get(), equalTo(0));
-
-    }
-    public static class DummyJobForMultiThread extends DummyJob {
-        private int id;
-        private DummyJobForMultiThread(int id, Params params) {
-            super(params);
-            this.id = id;
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            super.onRun();
-            int remaining = multiThreadedJobCounter.decrementAndGet();
-            //take some time
-            Thread.sleep((long) (Math.random() * 1000));
-            //throw exception w/ small change
-            if(Math.random() < .1) {
-                throw new Exception("decided to die, will retry");
-            }
-            Log.d("DummyJobForMultiThread", "persistent:" + isPersistent() + ", requires network:" + requiresNetwork() + ", running " + id + ", remaining: " + remaining);
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            multiThreadedJobCounter.incrementAndGet();
-            return true;
-        }
-    };
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
deleted file mode 100644
index 15e9819..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class NetworkJobTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkJob() throws Exception {
-        JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
-        jobManager.stop();
-
-        DummyJob networkDummyJob = new DummyJob(new Params(5).requireNetwork());
-        jobManager.addJob(networkDummyJob);
-
-        DummyJob noNetworkDummyJob = new DummyJob(new Params(2));
-        jobManager.addJob(noNetworkDummyJob);
-
-        DummyJob networkPersistentJob = new DummyJob(new Params(6).persist().requireNetwork());
-        jobManager.addJob(networkPersistentJob);
-
-        DummyJob noNetworkPersistentJob = new DummyJob(new Params(1).persist());
-        jobManager.addJob(noNetworkPersistentJob);
-
-        MatcherAssert.assertThat("count should be correct if there are network and non-network jobs w/o network", jobManager.count(), equalTo(4));
-        dummyNetworkUtil.setHasNetwork(true);
-        MatcherAssert.assertThat("count should be correct if there is network and non-network jobs w/o network", jobManager.count(), equalTo(4));
-        dummyNetworkUtil.setHasNetwork(false);
-        jobManager.start();
-        Thread.sleep(1000);//this should be enough to consume dummy jobs
-        MatcherAssert.assertThat("no network jobs should be executed even if there is no network", jobManager.count(), equalTo(2));
-        dummyNetworkUtil.setHasNetwork(true);
-        Thread.sleep(1000);//this should be enough to consume dummy jobs
-        MatcherAssert.assertThat("when network is recovered, all network jobs should be automatically consumed", jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
deleted file mode 100644
index d275718..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-
-@RunWith(RobolectricTestRunner.class)
-public class NetworkJobWithConnectivityListenerTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkJobWithConnectivityListener() throws Exception {
-        DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
-        dummyNetworkUtil.setHasNetwork(false, true);
-        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
-        long dummyJobId = jobManager.addJob(dummyJob);
-        Thread.sleep(2000);//sleep a while so that consumers die. they should die since we are using a network util
-        //with event support
-        MatcherAssert.assertThat("count should be 1 as no jobs should be consumed w/o network", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true, false);
-        Thread.sleep(1000); //wait a little bit more to consumer will run
-        MatcherAssert.assertThat("even though network is recovered, job manager should not consume any job because it " +
-                "does not know (we did not inform)", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true, true);
-        Thread.sleep(1000); //wait a little bit more to consumer will run
-        MatcherAssert.assertThat("job manager should consume network job after it is informed that network is recovered"
-                , jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
deleted file mode 100644
index f07f629..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.Invoker;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.notNullValue;
-import static org.hamcrest.CoreMatchers.nullValue;
-
-@RunWith(RobolectricTestRunner.class)
-public class NetworkNextJobTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkNextJob() throws Exception {
-        DummyNetworkUtil dummyNetworkUtil = new DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
-        jobManager.stop();
-        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
-        long dummyJobId = jobManager.addJob(dummyJob);
-        dummyNetworkUtil.setHasNetwork(false);
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        MatcherAssert.assertThat("when there isn't any network, next job should return null", nextJobMethod.invoke(), nullValue());
-        MatcherAssert.assertThat("even if there is network, job manager should return correct count", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true);
-        JobHolder retrieved = nextJobMethod.invoke();
-        MatcherAssert.assertThat("when network is recovered, next job should be retrieved", retrieved, notNullValue());
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
deleted file mode 100644
index 2e1b721..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-public class PersistentJobTest extends JobManagerTestBase {
-    //TEST parallel running
-    public static CountDownLatch persistentRunLatch = new CountDownLatch(1);
-
-    @Test
-    public void testPersistentJob() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.addJob(0, new DummyPersistentLatchJob());
-        persistentRunLatch.await(5, TimeUnit.SECONDS);
-        MatcherAssert.assertThat((int) persistentRunLatch.getCount(), equalTo(0));
-    }
-
-    protected static class DummyPersistentLatchJob extends DummyJob {
-
-        public DummyPersistentLatchJob() {
-            super(new Params(0).persist());
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            PersistentJobTest.persistentRunLatch.countDown();
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
deleted file mode 100644
index 3f35e2b..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.config.Configuration;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricTestRunner.class)
-public class PriorityTest extends JobManagerTestBase {
-    private static CountDownLatch priorityRunLatch;
-
-    @Test
-    public void testPriority() throws Exception {
-        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).maxConsumerCount(1));
-        testPriority(jobManager, false);
-    }
-
-    public void testPriority(JobManager jobManager, boolean persist) throws Exception {
-        priorityRunLatch = new CountDownLatch(2);
-        DummyJobWithRunOrderAssert.globalRunCount = new AtomicInteger(0);
-        BaseJob job1 = new DummyJobWithRunOrderAssert(2, persist);
-        BaseJob job2 = new DummyJobWithRunOrderAssert(1, persist);
-        jobManager.stop();
-        jobManager.addJob(1, job1);
-        jobManager.addJob(2, job2);
-        jobManager.start();
-        priorityRunLatch.await(4, TimeUnit.SECONDS);
-        //ensure both jobs did run
-        MatcherAssert.assertThat((int) priorityRunLatch.getCount(), equalTo(0));
-    }
-
-    public static class DummyJobWithRunOrderAssert extends BaseJob {
-        transient public static AtomicInteger globalRunCount;
-        private int expectedRunOrder;
-
-        public DummyJobWithRunOrderAssert(int expectedRunOrder, boolean persist) {
-            super(true, persist);
-            this.expectedRunOrder = expectedRunOrder;
-        }
-
-        @Override
-        public void onAdded() {
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            final int cnt = globalRunCount.incrementAndGet();
-            MatcherAssert.assertThat(expectedRunOrder, equalTo(cnt));
-            priorityRunLatch.countDown();
-        }
-
-        @Override
-        protected void onCancel() {
-
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return false;
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
deleted file mode 100644
index e936235..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-
-@RunWith(RobolectricTestRunner.class)
-public class ReRunWithLimitTest extends JobManagerTestBase {
-    @Test
-    public void testReRunWithLimit() throws Exception {
-        JobManager jobManager = createJobManager();
-        testReRun(jobManager, false);
-        testReRun(jobManager, true);
-    }
-
-    private void testReRun(JobManager jobManager, boolean persist) throws InterruptedException {
-        DummyJobWithRunCount.runCount = 0;//reset
-        DummyJobWithRunCount job = new DummyJobWithRunCount(persist);
-        jobManager.addJob(0, job);
-        int limit = 25;
-        while (limit-- > 0 && DummyJobWithRunCount.runCount != 5) {
-            Thread.sleep(100);
-        }
-        MatcherAssert.assertThat(DummyJobWithRunCount.runCount, equalTo(job.getRetryLimit()));
-        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
deleted file mode 100644
index 9d49dda..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.JobManager;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-public class RunFailingJobTest extends JobManagerTestBase {
-    @Test
-    public void runFailingJob() throws Exception {
-        final CountDownLatch latch = new CountDownLatch(1);
-        JobManager jobManager = createJobManager();
-        jobManager.addJob(0, new BaseJob(true) {
-            @Override
-            public void onAdded() {
-
-            }
-
-            @Override
-            public void onRun() throws Throwable {
-                throw new RuntimeException();
-            }
-
-            @Override
-            protected void onCancel() {
-                latch.countDown();
-            }
-
-            @Override
-            protected boolean shouldReRunOnThrowable(Throwable throwable) {
-                return false;
-            }
-        });
-        latch.await(10, TimeUnit.SECONDS);
-        MatcherAssert.assertThat((int) latch.getCount(), equalTo(0));
-    }
-
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
deleted file mode 100644
index 0828286..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-public class RunManyNonPersistentTest extends JobManagerTestBase {
-    @Test
-    public void runManyNonPersistentJobs() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        int limit = 2;
-        final CountDownLatch latch = new CountDownLatch(limit);
-        for (int i = 0; i < limit; i++) {
-            jobManager.addJob(new DummyLatchJob(new Params(i), latch));
-        }
-        jobManager.start();
-        latch.await(10, TimeUnit.SECONDS);
-        MatcherAssert.assertThat((int) latch.getCount(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
deleted file mode 100644
index 35e9aae..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.fest.reflect.method.*;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class SessionIdTest extends JobManagerTestBase {
-    @Test
-    public void testSessionId() throws Exception {
-        JobManager jobManager = createJobManager();
-        Long sessionId = Reflection.field("sessionId").ofType(long.class)
-                .in(jobManager).get();
-        jobManager.stop();
-        Job[] jobs = new Job[]{new DummyJob(new Params(0)), new DummyJob(new Params(0).persist())};
-        for (Job job : jobs) {
-            jobManager.addJob(job);
-        }
-
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        for (int i = 0; i < jobs.length; i++) {
-            JobHolder jobHolder = nextJobMethod.invoke();
-            MatcherAssert.assertThat("session id should be correct for job " + i, jobHolder.getRunningSessionId(), equalTo(sessionId));
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
deleted file mode 100644
index fda6e29..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-import java.util.concurrent.CountDownLatch;
-
-@RunWith(RobolectricTestRunner.class)
-public class SlowOnAddedTest extends JobManagerTestBase {
-    @Test
-    public void testNonPersistent() throws InterruptedException {
-        JobManager jobManager = createJobManager();
-        CountDownLatch runLatch = new CountDownLatch(1);
-        MyDummyJob job = new MyDummyJob(new Params(2), runLatch);
-        for(int i = 0; i < 50; i++) {
-            jobManager.addJob(new DummyJob(new Params(1)));
-        }
-        jobManager.addJob(job);
-        runLatch.await();
-        assertThat("on added should be called before on run", job.onAddedCntWhenRun, equalTo(1));
-    }
-
-    @Test
-    public void testPersistent() throws InterruptedException {
-        JobManager jobManager = createJobManager();
-        MyDummyPersistentJob.persistentJobLatch = new CountDownLatch(1);
-        for(int i = 0; i < 50; i++) {
-            jobManager.addJob(new DummyJob(new Params(1).persist()));
-        }
-        jobManager.addJob(new MyDummyPersistentJob(2));
-        MyDummyPersistentJob.persistentJobLatch.await();
-        assertThat("even if job is persistent, onAdded should be called b4 onRun",
-                MyDummyPersistentJob.onAddedCountWhenOnRun, equalTo(1));
-    }
-
-    public static class MyDummyPersistentJob extends Job {
-        private static CountDownLatch persistentJobLatch;
-        private static int persistentOnAdded = 0;
-        private static int onAddedCountWhenOnRun = -1;
-
-        protected MyDummyPersistentJob(int priority) {
-            super(new Params(priority).persist());
-        }
-
-        @Override
-        public void onAdded() {
-            try {
-                Thread.sleep(2000);
-            } catch (InterruptedException e) {
-                //
-            }
-            persistentOnAdded ++;
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            onAddedCountWhenOnRun = persistentOnAdded;
-            persistentJobLatch.countDown();
-        }
-
-        @Override
-        protected void onCancel() {
-
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return true;
-        }
-    }
-
-    private static class MyDummyJob extends DummyLatchJob {
-        int onAddedCntWhenRun = -1;
-
-        protected MyDummyJob(Params params, CountDownLatch latch) {
-            super(params, latch);
-        }
-
-        @Override
-        public void onAdded() {
-            try {
-                Thread.sleep(2000);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            super.onAdded();
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            onAddedCntWhenRun = super.getOnAddedCnt();
-            super.onRun();
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
deleted file mode 100644
index 013c1bd..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class CachedNonPersistentJobQueueTest extends JobQueueTestBase {
-    public CachedNonPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id));
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
deleted file mode 100644
index 80099c3..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class CachedPersistentJobQueueTest extends JobQueueTestBase {
-    public CachedPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(Robolectric.application, sessionId, id, new SqliteJobQueue.JavaSerializer());
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
deleted file mode 100644
index fb60538..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class JobParamsTest extends TestBase {
-    @Test
-    public void assertParamsUnderstood() {
-        DummyJob j1 = new DummyJob(new Params(1).requireNetwork());
-        assertThat("require network param should be understood properly", j1.requiresNetwork(), equalTo(true));
-        DummyJob j2 = new DummyJob(new Params(1).groupBy("blah"));
-        assertThat("group param should be understood properly", j2.getRunGroupId(), equalTo("blah"));
-        DummyJob j3 = new DummyJob(new Params(1).persist());
-        assertThat("group param should be understood properly", j3.isPersistent(), equalTo(true));
-        DummyJob j4 = new DummyJob(new Params(1).setPersistent(false).setRequiresNetwork(false).setGroupId(null));
-        assertThat("persist param should be understood properly", j4.isPersistent(), equalTo(false));
-        assertThat("require network param should be understood properly", j4.requiresNetwork(), equalTo(false));
-        assertThat("group param should be understood properly", j4.getRunGroupId(), nullValue());
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
deleted file mode 100644
index 2805e54..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
+++ /dev/null
@@ -1,509 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.fest.reflect.core.*;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-
-@Ignore
-public abstract class JobQueueTestBase extends TestBase {
-    JobQueueFactory currentFactory;
-
-    public JobQueueTestBase(JobQueueFactory factory) {
-        currentFactory = factory;
-    }
-
-    @Test
-    public void testBasicAddRemoveCount() throws Exception {
-        final int ADD_COUNT = 6;
-        JobQueue jobQueue = createNewJobQueue();
-        assertThat((int) jobQueue.count(), equalTo(0));
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
-        for (int i = 0; i < ADD_COUNT; i++) {
-            JobHolder holder = createNewJobHolder();
-            jobQueue.insert(holder);
-            assertThat((int) jobQueue.count(), equalTo(i + 1));
-            assertThat(holder.getId(), notNullValue());
-            jobQueue.insertOrReplace(holder);
-            assertThat((int) jobQueue.count(), equalTo(i + 1));
-        }
-        JobHolder firstHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat(firstHolder.getRunCount(), equalTo(1));
-        //size should be down 1
-        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 1));
-        //should return another job
-        JobHolder secondHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat(secondHolder.getRunCount(), equalTo(1));
-        //size should be down 2
-        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
-        //second holder and first holder should have different ids
-        assertThat(firstHolder.getId(), not(secondHolder.getId()));
-        jobQueue.remove(secondHolder);
-        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
-        jobQueue.remove(secondHolder);
-        //non existed job removed, count should be the same
-        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
-        jobQueue.remove(firstHolder);
-        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
-    }
-
-    @Test
-    public void testPriority() throws Exception {
-        int JOB_LIMIT = 20;
-        JobQueue jobQueue = createNewJobQueue();
-        //create and add JOB_LIMIT jobs with random priority
-        for (int i = 0; i < JOB_LIMIT; i++) {
-            jobQueue.insert(createNewJobHolder(new Params((int) (Math.random() * 10))));
-        }
-        //ensure we get jobs in correct priority order
-        int minPriority = Integer.MAX_VALUE;
-        for (int i = 0; i < JOB_LIMIT; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            assertThat(holder.getPriority() <= minPriority, is(true));
-        }
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
-    }
-
-
-    @Test
-    public void testDelayUntilWithPriority() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
-        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5), now + 10000 * JobManager.NS_PER_MS);
-        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now + 20000 * JobManager.NS_PER_MS);
-        jobQueue.insert(lowPriorityHolder);
-        jobQueue.insert(highPriorityHolder);
-        assertThat("when asked, if lower priority job has less delay until, we should return it",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(lowPriorityHolder.getDelayUntilNs()));
-
-    }
-
-    @Test
-    public void testGroupId() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        long jobId1 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        long jobId2 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        long jobId3 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
-        long jobId4 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
-        long jobId5 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        JobHolder holder1 = jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group2"}));
-        assertThat("first jobs should be from group group2 if group1 is excluded",
-                holder1.getBaseJob().getRunGroupId(), equalTo("group1"));
-        assertThat("correct job should be returned if groupId is provided",
-                holder1.getId(), equalTo(jobId1));
-        assertThat("no jobs should be returned if all groups are excluded",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})),
-                is(nullValue()));
-        long jobId6 = jobQueue.insert(createNewJobHolder(new Params(0)));
-        assertThat("both groups are disabled, null group job should be returned",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})).getId(),
-                is(jobId6));
-        assertThat("if group1 is excluded, next job should be from group2",
-                jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group1"})).getBaseJob().getRunGroupId()
-                , equalTo("group2"));
-
-        //to test re-run case, add the job back in
-        jobQueue.insertOrReplace(holder1);
-        //ask for it again, should return the same holder because it is grouped
-        JobHolder holder2 = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat("for grouped jobs, re-fetching job should work fine",
-                holder2.getId(), equalTo(holder1.getId()));
-
-        JobHolder holder3 = jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1"}));
-        assertThat("if a group it excluded, next available from another group should be returned",
-                holder3.getId(), equalTo(jobId4));
-
-        //add two more non-grouped jobs
-        long jobId7 = jobQueue.insert(createNewJobHolder(new Params(0)));
-        long jobId8 = jobQueue.insert(createNewJobHolder(new Params(0)));
-        JobHolder holder4 = jobQueue.nextJobAndIncRunCount(true,
-                Arrays.asList(new String[]{"group1", "group2"}));
-        assertThat("if all grouped jobs are excluded, non-grouped jobs should be returned",
-                holder4.getId(),
-                equalTo(jobId7));
-        jobQueue.insertOrReplace(holder4);
-        //for non-grouped jobs, run counts should be respected
-        assertThat("if all grouped jobs are excluded, re-inserted highest priority job should still be returned",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})).getId(),
-                equalTo(jobId7));
-    }
-
-    @Test
-    public void testDueDelayUntilWithPriority() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
-        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5),now - 1000 * JobManager.NS_PER_MS);
-        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now - 10000 * JobManager.NS_PER_MS);
-        jobQueue.insert(lowPriorityHolder);
-        jobQueue.insert(highPriorityHolder);
-        long soonJobDelay = 2000;
-        JobHolder highestPriorityDelayedJob = createNewJobHolderWithDelayUntil(new Params(12), now + soonJobDelay * JobManager.NS_PER_MS);
-        long highestPriorityDelayedJobId = jobQueue.insert(highestPriorityDelayedJob);
-        assertThat("when asked, if job's due has passed, highest priority jobs's delay until should be " +
-                "returned",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(highPriorityHolder.getDelayUntilNs()));
-        //make sure soon job is valid now
-        Thread.sleep(soonJobDelay);
-
-        assertThat("when a job's time come, it should be returned",
-                jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(highestPriorityDelayedJobId));
-    }
-
-    @Test
-    public void testDelayUntil() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
-        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork(), now + 200000 * JobManager.NS_PER_MS);
-
-        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(new Params(0), now + 500000 * JobManager.NS_PER_MS);
-
-        jobQueue.insert(networkJobHolder);
-        jobQueue.insert(noNetworkJobHolder);
-
-        assertThat("if there is no network, delay until should be provided for no network job",
-            jobQueue.getNextJobDelayUntilNs(false), equalTo(noNetworkJobHolder.getDelayUntilNs()));
-
-        assertThat("if there is network, delay until should be provided for network job because it is " +
-                "sooner", jobQueue.getNextJobDelayUntilNs(true), equalTo(networkJobHolder.getDelayUntilNs()));
-
-        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0), now + 100000 * JobManager.NS_PER_MS);
-
-        jobQueue.insert(noNetworkJobHolder2);
-        assertThat("if there is network, any job's delay until should be returned",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
-    }
-
-    @Test
-    public void testTruncate() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        final int LIMIT = 20;
-        for(int i = 0; i < LIMIT; i ++) {
-            jobQueue.insert(createNewJobHolder());
-        }
-        assertThat("queue should have all jobs", jobQueue.count(), equalTo(LIMIT));
-        jobQueue.clear();
-        assertThat("after clear, queue should be empty", jobQueue.count(), equalTo(0));
-        for(int i = 0; i < LIMIT; i ++) {
-            jobQueue.insert(createNewJobHolder());
-        }
-        assertThat("if we add jobs again, count should match", jobQueue.count(), equalTo(LIMIT));
-    }
-
-    @Test
-    public void testPriorityWithDelayedJobs() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        JobHolder delayedPriority_5 = createNewJobHolder(new Params(5));
-        org.fest.reflect.field.Invoker<Long> delayUntilField = getDelayUntilNsField(delayedPriority_5);
-        delayUntilField.set(System.nanoTime() - 1000);
-
-        JobHolder delayedPriority_2 = createNewJobHolder(new Params(2));
-        delayUntilField = getDelayUntilNsField(delayedPriority_2);
-        delayUntilField.set(System.nanoTime() - 500);
-
-
-
-        JobHolder nonDelayedPriority_6 = createNewJobHolder(new Params(6));
-        JobHolder nonDelayedPriority_3 = createNewJobHolder(new Params(3));
-        JobHolder nonDelayedPriority_2 = createNewJobHolder(new Params(2));
-
-
-        jobQueue.insert(delayedPriority_5);
-        jobQueue.insert(delayedPriority_2);
-        jobQueue.insert(nonDelayedPriority_6);
-        jobQueue.insert(nonDelayedPriority_2);
-        jobQueue.insert(nonDelayedPriority_3);
-
-        int lastPriority = Integer.MAX_VALUE;
-        for(int i = 0; i < 5; i++) {
-            JobHolder next = jobQueue.nextJobAndIncRunCount(true, null);
-            assertThat("next job should not be null", next, notNullValue());
-            assertThat("next job's priority should be lower then previous for job " + i, next.getPriority() <= lastPriority, is(true));
-            lastPriority = next.getPriority();
-        }
-
-    }
-
-    private org.fest.reflect.field.Invoker<Long> getDelayUntilNsField(JobHolder jobHolder) {
-        return Reflection.field("delayUntilNs").ofType(long.class).in(jobHolder);
-    }
-
-    private org.fest.reflect.field.Invoker<Integer> getPriorityField(Params params) {
-        return Reflection.field("priority").ofType(int.class).in(params);
-    }
-
-    private org.fest.reflect.field.Invoker<Long> getDelayMsField(Params params) {
-        return Reflection.field("delayMs").ofType(long.class).in(params);
-    }
-
-    private org.fest.reflect.field.Invoker<String> getGroupIdField(Params params) {
-        return Reflection.field("groupId").ofType(String.class).in(params);
-    }
-
-    @Test
-    public void testSessionId() throws Exception {
-        long sessionId = (long) (Math.random() * 100000);
-        JobQueue jobQueue = createNewJobQueueWithSessionId(sessionId);
-        JobHolder jobHolder = createNewJobHolder();
-        jobQueue.insert(jobHolder);
-        jobHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat("session id should be attached to next job",
-                jobHolder.getRunningSessionId(), equalTo(sessionId));
-    }
-
-    @Test
-    public void testPriorityWithReAdd() throws Exception {
-        int JOB_LIMIT = 20;
-        JobQueue jobQueue = createNewJobQueue();
-        //create and add JOB_LIMIT jobs with random priority
-        for (int i = 0; i < JOB_LIMIT; i++) {
-            jobQueue.insert(createNewJobHolder(new Params((int) (Math.random() * 10))));
-        }
-        //ensure we get jobs in correct priority order
-        int minPriority = Integer.MAX_VALUE;
-        for (int i = 0; i < JOB_LIMIT; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            assertThat(holder.getPriority() <= minPriority, is(true));
-            jobQueue.insertOrReplace(holder);
-        }
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), notNullValue());
-    }
-
-    @Test
-    public void testRemove() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        JobHolder holder = createNewJobHolder();
-        jobQueue.insert(holder);
-        Long jobId = holder.getId();
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(jobId));
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
-        jobQueue.remove(holder);
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
-    }
-
-    @Test
-    public void testNetwork() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        JobHolder jobHolder = createNewJobHolder(new Params(0));
-        jobQueue.insert(jobHolder);
-        assertThat("no network job should be returned even if there is no netowrk",
-                jobQueue.nextJobAndIncRunCount(false, null), notNullValue());
-        jobQueue.remove(jobHolder);
-
-        jobHolder = createNewJobHolder(new Params(0).requireNetwork());
-        assertThat("if there isn't any network, job with network requirement should not return",
-                jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-
-        assertThat("if there is network, job with network requirement should be returned",
-                jobQueue.nextJobAndIncRunCount(true, null), nullValue());
-
-        jobQueue.remove(jobHolder);
-
-        jobHolder = createNewJobHolder(new Params(1));
-        JobHolder jobHolder2 = createNewJobHolder(new Params(5).requireNetwork());
-        long firstJobId = jobQueue.insert(jobHolder);
-        long secondJobId = jobQueue.insert(jobHolder2);
-        JobHolder retrieved = jobQueue.nextJobAndIncRunCount(false, null);
-        assertThat("one job should be returned w/o network", retrieved, notNullValue());
-        if(retrieved != null) {
-            assertThat("no network job should be returned although it has lower priority", retrieved.getId(), equalTo(firstJobId));
-        }
-
-        assertThat("no other job should be returned w/o network", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat("if network is back, network requiring job should be returned", retrieved, notNullValue());
-        if(retrieved != null) {
-            assertThat("when there is network, network job should be returned", retrieved.getId(), equalTo(secondJobId));
-        }
-        //add first job back
-        jobQueue.insertOrReplace(jobHolder);
-        //add second job back
-        jobQueue.insertOrReplace(jobHolder2);
-
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat("if network is back, job w/ higher priority should be returned", retrieved, notNullValue());
-        if(retrieved != null) {
-            assertThat("if network is back, job w/ higher priority should be returned", retrieved.getId(), equalTo(secondJobId));
-        }
-        jobQueue.insertOrReplace(jobHolder2);
-
-        JobHolder highestPriorityJob = createNewJobHolder(new Params(10));
-        long highestPriorityJobId = jobQueue.insert(highestPriorityJob);
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        assertThat("w/ or w/o network, highest priority should be returned", retrieved, notNullValue());
-        if(retrieved != null) {
-            assertThat("w/ or w/o network, highest priority should be returned", retrieved.getId(), equalTo(highestPriorityJobId));
-        }
-
-        //TODO test delay until
-    }
-
-    @Test
-    public void testCountReadyJobs() throws Exception {
-        JobQueue jobQueue = createNewJobQueue();
-        assertThat("initial count should be 0 for ready jobs", jobQueue.countReadyJobs(true, null), equalTo(0));
-        //add some jobs
-        jobQueue.insert(createNewJobHolder());
-        jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork()));
-        long now = System.nanoTime();
-        long delay = 1000;
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0), now + TimeUnit.MILLISECONDS.toNanos(delay)));
-        assertThat("ready count should be 1 if there is no network", jobQueue.countReadyJobs(false, null), equalTo(1));
-        assertThat("ready count should be 2 if there is network", jobQueue.countReadyJobs(true, null), equalTo(2));
-        Thread.sleep(delay);
-        assertThat("when needed delay time passes, ready count should be 3", jobQueue.countReadyJobs(true, null), equalTo(3));
-        assertThat("when needed delay time passes but no network, ready count should be 2", jobQueue.countReadyJobs(false, null), equalTo(2));
-        jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
-        jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
-        assertThat("when more than 1 job from same group is created, ready jobs should increment only by 1",
-                jobQueue.countReadyJobs(true, null), equalTo(4));
-        assertThat("excluding groups should work",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1"})), equalTo(3));
-        assertThat("giving a non-existing group should not fool the count",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group3423"})), equalTo(4));
-        jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group2")));
-        assertThat("when a job from another group is added, ready job count should inc",
-                jobQueue.countReadyJobs(true, null), equalTo(5));
-        now = System.nanoTime();
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(3).groupBy("group3"), now + TimeUnit.MILLISECONDS.toNanos(delay)));
-        assertThat("when a delayed job from another group is added, ready count should not change",
-                jobQueue.countReadyJobs(true, null), equalTo(5));
-        jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group3")));
-        assertThat("when another job from delayed group is added, ready job count should inc",
-                jobQueue.countReadyJobs(true, null), equalTo(6));
-        Thread.sleep(delay);
-        assertThat("when delay passes and a job from existing group becomes available, ready job count should not change",
-                jobQueue.countReadyJobs(true, null), equalTo(6));
-        assertThat("when some groups are excluded, count should be correct",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
-
-        //jobs w/ same group id but with different persistence constraints should not fool the count
-        now = System.nanoTime();
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now + 1000));
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now + 1000));
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now - 1000));
-        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now - 1000));
-        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(5));
-        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(true, null), equalTo(7));
-        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(false, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
-    }
-
-    @Test
-    public void testJobFields() throws Exception {
-        long sessionId = (long) (Math.random() * 1000);
-        JobQueue jobQueue = createNewJobQueueWithSessionId(sessionId);
-        JobHolder jobHolder = createNewJobHolder();
-
-
-        int priority = (int) (Math.random() * 1000);
-        jobHolder.setPriority(priority);
-        DummyJob dummyJob = new DummyJob(new Params(0));
-        jobHolder.setBaseJob(dummyJob);
-        int runCount = (int) (Math.random() * 10);
-        jobHolder.setRunCount(runCount);
-
-        long id = jobQueue.insert(jobHolder);
-
-
-        for (int i = 0; i < 2; i++) {
-            JobHolder received = jobQueue.nextJobAndIncRunCount(true, null);
-            assertThat("job id should be preserved", received.getId(), equalTo(id));
-            assertThat("job priority should be preserved", received.getPriority(), equalTo(priority));
-            assertThat("job session id should be assigned", received.getRunningSessionId(), equalTo(sessionId));
-            assertThat("job run count should be incremented", received.getRunCount(), equalTo(runCount + i + 1));
-            jobQueue.insertOrReplace(received);
-        }
-    }
-
-    private void assertJob(JobQueue jobQueue, String msg, long id, /*nullable*/ JobHolder holder) {
-        if(holder == null) {
-            assertThat(msg, jobQueue.findJobById(id), nullValue());
-            return;
-        }
-        assertThat(msg + "(existence check)", jobQueue.findJobById(id), notNullValue());
-        assertThat(msg + "(id check)", jobQueue.findJobById(id).getId(), is(holder.getId()));
-    }
-
-    @Test
-    public void testFindJobHolderById() {
-        JobQueue jobQueue = createNewJobQueue();
-        assertJob(jobQueue, "non existing job (negative id)", -4, null);
-        assertJob(jobQueue, "non existing job (positive id)", +4, null);
-        final int LIMIT = 100;
-        JobHolder[] holders = new JobHolder[LIMIT];
-        long[] ids = new long[LIMIT];
-        for(int i =  0; i < LIMIT; i++) {
-            holders[i] = createNewJobHolder(new Params((int) (Math.random() * 50)).setPersistent(Math.random() < .5).setRequiresNetwork(Math.random() < .5));
-            ids[i] = jobQueue.insert(holders[i]);
-            assertJob(jobQueue, "job by id should work for inserted job", ids[i], holders[i]);
-        }
-        final int REMOVE_CNT = LIMIT / 2;
-        for(int i = 0; i < REMOVE_CNT; i++) {
-            int ind = (int) (Math.random() * LIMIT);
-            if(holders[ind] == null) {
-                continue;
-            }
-            //remove some randomly, up to half
-            jobQueue.remove(holders[ind]);
-            holders[ind] = null;
-        }
-        //re-query all, ensure we can still find non-removed jobs and not find removed jobs
-        for(int i =  0; i < LIMIT; i++) {
-            if(holders[i] != null) {
-                assertJob(jobQueue, "if job is still in the Q, it should be returned", ids[i], holders[i]);
-                //re add job
-                jobQueue.insertOrReplace(holders[i]);
-                //re-test after re-add
-                assertJob(jobQueue, "after re-insert, if job is still in the Q, it should be returned", ids[i], holders[i]);
-            } else {
-                assertJob(jobQueue, "removed job should not be returned in id query", ids[i], null);
-            }
-        }
-        jobQueue.clear();
-        for(int i = 0; i < LIMIT; i++) {
-            assertJob(jobQueue, "after clear, find by id should return null", ids[i], null);
-        }
-    }
-
-    protected JobHolder createNewJobHolder() {
-        return createNewJobHolder(new Params(0));
-    }
-
-    protected JobHolder createNewJobHolder(Params params) {
-        long delay = getDelayMsField(params).get();
-        return new JobHolder(null, getPriorityField(params).get(), getGroupIdField(params).get(), 0, new DummyJob(params), System.nanoTime(),
-                delay > 0 ? System.nanoTime() +  delay * JobManager.NS_PER_MS : JobManager.NOT_DELAYED_JOB_DELAY, JobManager.NOT_RUNNING_SESSION_ID);
-    }
-
-    private JobHolder createNewJobHolderWithDelayUntil(Params params, long delayUntil) {
-        JobHolder jobHolder = createNewJobHolder(params);
-        getDelayUntilNsField(jobHolder).set(delayUntil);
-        return jobHolder;
-    }
-
-    protected JobQueue createNewJobQueue() {
-        return createNewJobQueueWithSessionId(System.nanoTime());
-    }
-
-    private JobQueue createNewJobQueueWithSessionId(Long sessionId) {
-        return currentFactory.createNew(sessionId, "id_" + sessionId);
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
deleted file mode 100644
index aec3924..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-
-@RunWith(RobolectricTestRunner.class)
-public class NonPersistentJobQueueTest extends JobQueueTestBase {
-    public NonPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new NonPersistentPriorityQueue(sessionId, id);
-            }
-        });
-    }
-
-    /**
-     * issue #21 https://github.com/path/android-priority-jobqueue/issues/21
-     */
-    @Test
-    public void testTooManyQueueChanges() throws InterruptedException {
-        JobQueue jobQueue = createNewJobQueue();
-        int limit = 10000;
-        long delayMs = 2000;
-        long then = System.nanoTime() + delayMs * JobManager.NS_PER_MS;
-        for(int i = 0; i < limit; i++) {
-            jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork().delayInMs(delayMs)));
-        }
-
-        MatcherAssert.assertThat("all jobs require network, should return null", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-        long sleep = then - System.nanoTime();
-        sleep += JobManager.NS_PER_MS * 1000;
-        if (sleep > 0) {
-            Thread.sleep(sleep / JobManager.NS_PER_MS);
-        }
-        //should be able to get it w/o an overflow
-        for(int i = 0; i < limit; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat("should get a next job", holder, notNullValue());
-            jobQueue.remove(holder);
-        }
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
deleted file mode 100644
index 7325e3d..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricTestRunner.class)
-public class SqliteJobQueueTest extends JobQueueTestBase {
-    public SqliteJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(Robolectric.application, sessionId, id, new SqliteJobQueue.JavaSerializer());
-            }
-        });
-    }
-
-    @Test
-    public void testCustomSerializer() throws Exception {
-        final CountDownLatch calledForSerialize = new CountDownLatch(1);
-        final CountDownLatch calledForDeserialize = new CountDownLatch(1);
-        SqliteJobQueue.JobSerializer jobSerializer = new SqliteJobQueue.JavaSerializer() {
-            @Override
-            public byte[] serialize(Object object) throws IOException {
-                calledForSerialize.countDown();
-                return super.serialize(object);
-            }
-
-            @Override
-            public <T extends BaseJob> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
-                calledForDeserialize.countDown();
-                return super.deserialize(bytes);
-            }
-        };
-        SqliteJobQueue jobQueue = new SqliteJobQueue(Robolectric.application, System.nanoTime(), "__" + System.nanoTime(),
-                jobSerializer);
-        jobQueue.insert(createNewJobHolder(new Params(0)));
-        calledForSerialize.await(1, TimeUnit.SECONDS);
-        MatcherAssert.assertThat("custom serializer should be called for serialize", (int) calledForSerialize.getCount(), CoreMatchers.equalTo(0));
-        MatcherAssert.assertThat("custom serializer should NOT be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(1));
-        jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("custom serializer should be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
deleted file mode 100644
index d931e1e..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.path.android.jobqueue.test.jobs;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.Params;
-
-public class DummyJob extends Job {
-    int onAddedCnt = 0;
-    int onRunCnt = 0;
-    int onCancelCnt = 0;
-    int shouldReRunOnThrowableCnt = 0;
-
-    public DummyJob(Params params) {
-        super(params);
-    }
-
-    @Override
-    public void onAdded() {
-        onAddedCnt++;
-    }
-
-    @Override
-    public void onRun() throws Throwable {
-        onRunCnt++;
-    }
-
-    @Override
-    protected void onCancel() {
-        onCancelCnt++;
-    }
-
-    @Override
-    protected boolean shouldReRunOnThrowable(Throwable throwable) {
-        shouldReRunOnThrowableCnt++;
-        return false;
-    }
-
-    public int getOnAddedCnt() {
-        return onAddedCnt;
-    }
-
-    public int getOnRunCnt() {
-        return onRunCnt;
-    }
-
-    public int getOnCancelCnt() {
-        return onCancelCnt;
-    }
-
-    public int getShouldReRunOnThrowableCnt() {
-        return shouldReRunOnThrowableCnt;
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
deleted file mode 100644
index 8cb46ef..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.path.android.jobqueue.test.util;
-
-import com.path.android.jobqueue.JobQueue;
-
-public interface JobQueueFactory {
-    public JobQueue createNew(long sessionId, String id);
-}
