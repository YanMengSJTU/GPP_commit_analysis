diff --git a/jobqueue/AndroidManifest.xml b/jobqueue/AndroidManifest.xml
index 7e37c4b..fc39c78 100644
--- a/jobqueue/AndroidManifest.xml
+++ b/jobqueue/AndroidManifest.xml
@@ -2,7 +2,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.path.android.jobqueue"
           android:versionCode="2"
-          android:versionName="1.1.2">
+          android:versionName="1.3.1">
     <application android:label="">
     </application>
 </manifest>
diff --git a/jobqueue/project.properties b/jobqueue/project.properties
index ada602f..e584b26 100644
--- a/jobqueue/project.properties
+++ b/jobqueue/project.properties
@@ -12,5 +12,5 @@
 
 android.library=true
 # Project target.
-target=android-21
+target=android-22
 
diff --git a/jobqueue/res/values/strings.xml b/jobqueue/res/values/strings.xml
deleted file mode 100644
index 8ba55bc..0000000
--- a/jobqueue/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <string name="app_name">Android Priority Job Queue</string>
-</resources>
diff --git a/jobqueue/src/com/path/android/jobqueue/BaseJob.java b/jobqueue/src/com/path/android/jobqueue/BaseJob.java
deleted file mode 100644
index 0343605..0000000
--- a/jobqueue/src/com/path/android/jobqueue/BaseJob.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package com.path.android.jobqueue;
-
-import com.path.android.jobqueue.log.JqLog;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-
-/**
- * This class has been deprecated and will soon be removed from public api.
- * Please use {@link Job} instead which provider a cleaner constructor API.
- * Deprecated. Use {@link Job}
- */
-@Deprecated
-abstract public class BaseJob implements Serializable {
-    public static final int DEFAULT_RETRY_LIMIT = 20;
-    private boolean requiresNetwork;
-    private String groupId;
-    private boolean persistent;
-    private transient int currentRunCount;
-
-    protected BaseJob(boolean requiresNetwork) {
-        this(requiresNetwork, false, null);
-    }
-
-    protected BaseJob(String groupId) {
-        this(false, false, groupId);
-    }
-
-    protected BaseJob(boolean requiresNetwork, String groupId) {
-        this(requiresNetwork, false, groupId);
-    }
-
-    public BaseJob(boolean requiresNetwork, boolean persistent) {
-        this(requiresNetwork, persistent, null);
-    }
-
-    protected BaseJob(boolean requiresNetwork, boolean persistent, String groupId) {
-        this.requiresNetwork = requiresNetwork;
-        this.persistent = persistent;
-        this.groupId = groupId;
-    }
-
-    private void writeObject(ObjectOutputStream oos) throws IOException {
-        oos.writeBoolean(requiresNetwork);
-        oos.writeObject(groupId);
-        oos.writeBoolean(persistent);
-    }
-
-
-    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
-        requiresNetwork = ois.readBoolean();
-        groupId = (String) ois.readObject();
-        persistent = ois.readBoolean();
-    }
-
-    /**
-     * defines if we should add this job to disk or non-persistent queue
-     *
-     * @return
-     */
-    public final boolean isPersistent() {
-        return persistent;
-    }
-
-    /**
-     * called when the job is added to disk and committed.
-     * this means job will eventually run. this is a good time to update local database and dispatch events
-     * Changes to this class will not be preserved if your job is persistent !!!
-     * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
-     */
-    abstract public void onAdded();
-
-    /**
-     * The actual method that should to the work
-     * It should finish w/o any exception. If it throws any exception, {@code shouldReRunOnThrowable} will be called to
-     * decide either to dismiss the job or re-run it.
-     * @throws Throwable
-     */
-    abstract public void onRun() throws Throwable;
-
-    /**
-     * called when a job is cancelled.
-     */
-    abstract protected void onCancel();
-
-    /**
-     * if {@code onRun} method throws an exception, this method is called.
-     * return true if you want to run your job again, return false if you want to dismiss it. If you return false,
-     * onCancel will be called.
-     */
-    abstract protected boolean shouldReRunOnThrowable(Throwable throwable);
-
-    /**
-     * Runs the job and catches any exception
-     * @param currentRunCount
-     * @return
-     */
-    public final boolean safeRun(int currentRunCount) {
-        this.currentRunCount = currentRunCount;
-        if (JqLog.isDebugEnabled()) {
-            JqLog.d("running job %s", this.getClass().getSimpleName());
-        }
-        boolean reRun = false;
-        boolean failed = false;
-        try {
-            onRun();
-            if (JqLog.isDebugEnabled()) {
-                JqLog.d("finished job %s", this.getClass().getSimpleName());
-            }
-        } catch (Throwable t) {
-            failed = true;
-            JqLog.e(t, "error while executing job");
-            reRun = currentRunCount < getRetryLimit();
-            if(reRun) {
-                try {
-                    reRun = shouldReRunOnThrowable(t);
-                } catch (Throwable t2) {
-                    JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
-                }
-            }
-        } finally {
-            if (reRun) {
-                return false;
-            } else if (failed) {
-                try {
-                    onCancel();
-                } catch (Throwable ignored) {
-                }
-            }
-        }
-        return true;
-    }
-
-    /**
-     * before each run, JobManager sets this number. Might be useful for the {@link com.path.android.jobqueue.BaseJob#onRun()}
-     * method
-     * @return
-     */
-    protected int getCurrentRunCount() {
-        return currentRunCount;
-    }
-
-    /**
-     * if job is set to require network, it will not be called unless {@link com.path.android.jobqueue.network.NetworkUtil}
-     * reports that there is a network connection
-     * @return
-     */
-    public final boolean requiresNetwork() {
-        return requiresNetwork;
-    }
-
-    /**
-     * Some jobs may require being run synchronously. For instance, if it is a job like sending a comment, we should
-     * never run them in parallel (unless they are being sent to different conversations).
-     * By assigning same groupId to jobs, you can ensure that that type of jobs will be run in the order they were given
-     * (if their priority is the same).
-     * @return
-     */
-    public final String getRunGroupId() {
-        return groupId;
-    }
-
-    /**
-     * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
-     * If job fails this many times, onCancel will be called w/o calling {@code shouldReRunOnThrowable}
-     * @return
-     */
-    protected int getRetryLimit() {
-        return DEFAULT_RETRY_LIMIT;
-    }
-}
diff --git a/jobqueue/src/com/path/android/jobqueue/CancelResult.java b/jobqueue/src/com/path/android/jobqueue/CancelResult.java
new file mode 100755
index 0000000..20fc4e2
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/CancelResult.java
@@ -0,0 +1,49 @@
+package com.path.android.jobqueue;
+
+import java.util.Collection;
+import java.util.HashSet;
+import com.path.android.jobqueue.JobManager;
+
+/**
+ * This class holds the result of a cancel request via {@link JobManager#cancelJobs(TagConstraint, String...)}
+ * or {@link JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)}.
+ * <p>
+ * Cancelling jobs is an expensive operation because it requires JobManager to deserializer the job
+ * from databases and call onCancel method on it.
+ * <p>
+ * When cancelling jobs, if you need to get the list of cancelled jobs, you can provide this
+ * callback to {@link JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)}
+ * method.
+ */
+public class CancelResult {
+    Collection<Job> cancelledJobs;
+    Collection<Job> failedToCancel;
+
+    public CancelResult() {
+        this.cancelledJobs = new HashSet<Job>();
+        this.failedToCancel = new HashSet<Job>();
+    }
+
+    /**
+     * @return The list of jobs that are cancelled before they did run
+     */
+    public Collection<Job> getCancelledJobs() {
+        return cancelledJobs;
+    }
+
+    /**
+     * @return The list of jobs that were running when cancel was called and finished running
+     * successfully before they could be cancelled.
+     */
+    public Collection<Job> getFailedToCancel() {
+        return failedToCancel;
+    }
+
+    public static interface AsyncCancelCallback {
+
+        /**
+         * When job cancellation is complete, this method is called by the JobManager.
+         */
+        public void onCancelled(CancelResult cancelResult);
+    }
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/Job.java b/jobqueue/src/com/path/android/jobqueue/Job.java
old mode 100644
new mode 100755
index 15011dc..5b1ddb9
--- a/jobqueue/src/com/path/android/jobqueue/Job.java
+++ b/jobqueue/src/com/path/android/jobqueue/Job.java
@@ -1,21 +1,42 @@
 package com.path.android.jobqueue;
 
+import com.path.android.jobqueue.log.JqLog;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.io.Serializable;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
 
 /**
  * Base class for all of your jobs.
- * If you were using {@link BaseJob}, please move to this instance since BaseJob will be removed from the public api.
  */
 @SuppressWarnings("deprecation")
-abstract public class Job extends BaseJob implements Serializable {
-    private static final long serialVersionUID = 1L;
+abstract public class Job implements Serializable {
+    private static final long serialVersionUID = 3L;
+    public static final int DEFAULT_RETRY_LIMIT = 20;
+
+    private boolean requiresNetwork;
+    private String groupId;
+    private boolean persistent;
+    private Set<String> readonlyTags;
+
+    private transient int currentRunCount;
     private transient int priority;
     private transient long delayInMs;
+    transient boolean cancelled;
+
 
     protected Job(Params params) {
-        super(params.doesRequireNetwork(), params.isPersistent(), params.getGroupId());
+        this.requiresNetwork = params.doesRequireNetwork();
+        this.persistent = params.isPersistent();
+        this.groupId = params.getGroupId();
         this.priority = params.getPriority();
         this.delayInMs = params.getDelayMs();
+        final Set<String> tags = params.getTags();
+        this.readonlyTags = tags == null ? null : Collections.unmodifiableSet(tags);
     }
 
     /**
@@ -35,4 +56,188 @@ public final int getPriority() {
     public final long getDelayInMs() {
         return delayInMs;
     }
+
+    /**
+     * Returns a readonly set of tags attached to this Job.
+     * @return Set of Tags. If tags do not exists, returns null.
+     */
+    public final Set<String> getTags() {
+        return readonlyTags;
+    }
+
+    private void writeObject(ObjectOutputStream oos) throws IOException {
+        oos.writeBoolean(requiresNetwork);
+        oos.writeObject(groupId);
+        oos.writeBoolean(persistent);
+        final int tagCount = readonlyTags == null ? 0 : readonlyTags.size();
+        oos.writeInt(tagCount);
+        if (tagCount > 0) {
+            for (String tag : readonlyTags) {
+                oos.writeUTF(tag);
+            }
+        }
+    }
+
+
+    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
+        requiresNetwork = ois.readBoolean();
+        groupId = (String) ois.readObject();
+        persistent = ois.readBoolean();
+        final int tagCount = ois.readInt();
+        if (tagCount > 0) {
+            readonlyTags = new HashSet<String>(tagCount);
+            for (int i = 0; i < tagCount; i ++) {
+                readonlyTags.add(ois.readUTF());
+            }
+        }
+    }
+
+    /**
+     * defines if we should add this job to disk or non-persistent queue
+     */
+    public final boolean isPersistent() {
+        return persistent;
+    }
+
+    /**
+     * Called when the job is added to disk and committed.
+     * This means job will eventually run. This is a good time to update local database and dispatch events.
+     * <p>
+     * Changes to this class will not be preserved if your job is persistent !!!
+     * <p>
+     * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
+     */
+    abstract public void onAdded();
+
+    /**
+     * The actual method that should to the work.
+     * It should finish w/o any exception. If it throws any exception, {@code shouldReRunOnThrowable} will be called to
+     * decide either to dismiss the job or re-run it.
+     * @throws Throwable
+     */
+    abstract public void onRun() throws Throwable;
+
+    /**
+     * Called when a job is cancelled.
+     */
+    abstract protected void onCancel();
+
+    /**
+     * If {@code onRun} method throws an exception, this method is called.
+     * return true if you want to run your job again, return false if you want to dismiss it. If you return false,
+     * onCancel will be called.
+     */
+    abstract protected boolean shouldReRunOnThrowable(Throwable throwable);
+
+    /**
+     * Runs the job and catches any exception
+     * @param currentRunCount
+     * @return one of the RUN_RESULT ints
+     */
+    final int safeRun(JobHolder holder, int currentRunCount) {
+        this.currentRunCount = currentRunCount;
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("running job %s", this.getClass().getSimpleName());
+        }
+        boolean reRun = false;
+        boolean failed = false;
+        try {
+            onRun();
+            if (JqLog.isDebugEnabled()) {
+                JqLog.d("finished job %s", this);
+            }
+        } catch (Throwable t) {
+            failed = true;
+            JqLog.e(t, "error while executing job %s", this);
+            reRun = currentRunCount < getRetryLimit();
+            if(reRun && !cancelled) {
+                try {
+                    reRun = shouldReRunOnThrowable(t);
+                } catch (Throwable t2) {
+                    JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
+                }
+            }
+        }
+        JqLog.d("safeRunResult for %s : %s. re run:%s. cancelled: %s", this, !failed, reRun, cancelled);
+        if (!failed) {
+            return JobHolder.RUN_RESULT_SUCCESS;
+        }
+        if (holder.isCancelled()) {
+            return JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+        }
+        if (reRun) {
+            return JobHolder.RUN_RESULT_TRY_AGAIN;
+        }
+        // failed.
+        try {
+            onCancel();
+        } catch (Throwable ignored) {
+        }
+        return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
+
+    }
+
+    /**
+     * before each run, JobManager sets this number. Might be useful for the {@link com.path.android.jobqueue.Job#onRun()}
+     * method
+     */
+    protected int getCurrentRunCount() {
+        return currentRunCount;
+    }
+
+    /**
+     * if job is set to require network, it will not be called unless {@link com.path.android.jobqueue.network.NetworkUtil}
+     * reports that there is a network connection
+     */
+    public final boolean requiresNetwork() {
+        return requiresNetwork;
+    }
+
+    /**
+     * Some jobs may require being run synchronously. For instance, if it is a job like sending a comment, we should
+     * never run them in parallel (unless they are being sent to different conversations).
+     * By assigning same groupId to jobs, you can ensure that that type of jobs will be run in the order they were given
+     * (if their priority is the same).
+     * @return
+     */
+    public final String getRunGroupId() {
+        return groupId;
+    }
+
+    /**
+     * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
+     * If job fails this many times, onCancel will be called w/o calling {@code shouldReRunOnThrowable}
+     * @return
+     */
+    protected int getRetryLimit() {
+        return DEFAULT_RETRY_LIMIT;
+    }
+
+    /**
+     * Returns true if job is cancelled. Note that if the job is already running when it is cancelled,
+     * this flag is still set to true but job is NOT STOPPED (e.g. JobManager does not interrupt
+     * the thread).
+     * If you have a long job that may be cancelled, you can check this field and handle it manually.
+     * <p>
+     * Note that, if your job returns successfully from {@link #onRun()} method, it will be considered
+     * as successfully completed, thus will be added to {@link CancelResult#getFailedToCancel()}
+     * list. If you want this job to be considered as cancelled, you should throw an exception.
+     * You can also use {@link #assertNotCancelled()} method to do it.
+     * <p>
+     * Calling this method outside {@link #onRun()} method has no meaning since {@link #onRun()} will not
+     * be called if the job is cancelled before it is called.
+     */
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    /**
+     * Convenience method that checks if job is cancelled and throws a RuntimeException if it is
+     * cancelled.
+     */
+    public void assertNotCancelled() {
+        if (cancelled) {
+            throw new RuntimeException("job is cancelled");
+        }
+    }
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/com/path/android/jobqueue/JobHolder.java
old mode 100644
new mode 100755
index d8a32ba..bbcd272
--- a/jobqueue/src/com/path/android/jobqueue/JobHolder.java
+++ b/jobqueue/src/com/path/android/jobqueue/JobHolder.java
@@ -1,143 +1,198 @@
-package com.path.android.jobqueue;
-
-/**
- * Container class to address Jobs inside job manager.
- */
-public class JobHolder {
-    protected Long id;
-    protected int priority;
-    protected String groupId;
-    protected int runCount;
-    /**
-     * job will be delayed until this nanotime
-     */
-    protected long delayUntilNs;
-    /**
-     * When job is created, System.nanoTime() is assigned to {@code createdNs} value so that we know when job is created
-     * in relation to others
-     */
-    protected long createdNs;
-    protected long runningSessionId;
-    protected boolean requiresNetwork;
-    transient BaseJob baseJob;
-
-    /**
-     * @param id               Unique ID for the job. Should be unique per queue
-     * @param priority         Higher is better
-     * @param groupId          which group does this job belong to? default null
-     * @param runCount         Incremented each time job is fetched to run, initial value should be 0
-     * @param baseJob          Actual job to run
-     * @param createdNs        System.nanotime
-     * @param delayUntilNs     System.nanotime value where job can be run the very first time
-     * @param runningSessionId
-     */
-    public JobHolder(Long id, int priority, String groupId, int runCount, BaseJob baseJob, long createdNs, long delayUntilNs, long runningSessionId) {
-        this.id = id;
-        this.priority = priority;
-        this.groupId = groupId;
-        this.runCount = runCount;
-        this.createdNs = createdNs;
-        this.delayUntilNs = delayUntilNs;
-        this.baseJob = baseJob;
-        this.runningSessionId = runningSessionId;
-        this.requiresNetwork = baseJob.requiresNetwork();
-    }
-
-    public JobHolder(int priority, BaseJob baseJob, long runningSessionId) {
-        this(null, priority, null, 0, baseJob, System.nanoTime(), Long.MIN_VALUE, runningSessionId);
-    }
-
-    public JobHolder(int priority, BaseJob baseJob, long delayUntilNs, long runningSessionId) {
-        this(null, priority, baseJob.getRunGroupId(), 0, baseJob, System.nanoTime(), delayUntilNs, runningSessionId);
-    }
-
-    /**
-     * runs the job w/o throwing any exceptions
-     * @param currentRunCount
-     * @return
-     */
-    public final boolean safeRun(int currentRunCount) {
-        return baseJob.safeRun(currentRunCount);
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    public boolean requiresNetwork() {
-        return requiresNetwork;
-    }
-
-    public int getPriority() {
-        return priority;
-    }
-
-    public void setPriority(int priority) {
-        this.priority = priority;
-    }
-
-    public int getRunCount() {
-        return runCount;
-    }
-
-    public void setRunCount(int runCount) {
-        this.runCount = runCount;
-    }
-
-    public long getCreatedNs() {
-        return createdNs;
-    }
-
-    public void setCreatedNs(long createdNs) {
-        this.createdNs = createdNs;
-    }
-
-    public long getRunningSessionId() {
-        return runningSessionId;
-    }
-
-    public void setRunningSessionId(long runningSessionId) {
-        this.runningSessionId = runningSessionId;
-    }
-
-    public long getDelayUntilNs() {
-        return delayUntilNs;
-    }
-
-    public BaseJob getBaseJob() {
-        return baseJob;
-    }
-
-    public void setBaseJob(BaseJob baseJob) {
-        this.baseJob = baseJob;
-    }
-
-    public String getGroupId() {
-        return groupId;
-    }
-
-    @Override
-    public int hashCode() {
-        //we don't really care about overflow.
-        if(id == null) {
-            return super.hashCode();
-        }
-        return id.intValue();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if(o instanceof JobHolder == false) {
-            return false;
-        }
-        JobHolder other = (JobHolder) o;
-        if(id == null || other.id == null) {
-            return false;
-        }
-        return id.equals(other.id);
-    }
-}
+package com.path.android.jobqueue;
+
+import com.path.android.jobqueue.log.JqLog;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Container class to address Jobs inside job manager.
+ */
+public class JobHolder {
+
+    /**
+     * Internal constant. Job's onRun method completed w/o any exception.
+     */
+    public static final int RUN_RESULT_SUCCESS = 1;
+    /**
+     * Internal constant. Job's onRun method thrown an exception and either it does not want to
+     * run again or reached retry limit.
+     */
+    public static final int RUN_RESULT_FAIL_RUN_LIMIT = 2;
+
+    /**
+     * Internal constant. Job's onRun method has thrown an exception and it was cancelled after it
+     * started.
+     */
+    public static final int RUN_RESULT_FAIL_FOR_CANCEL = 3;
+    /**
+     * Internal constant. Job's onRun method failed but wants to retry.
+     */
+    public static final int RUN_RESULT_TRY_AGAIN = 4;
+
+    protected Long id;
+    protected int priority;
+    protected String groupId;
+    protected int runCount;
+    /**
+     * job will be delayed until this nanotime
+     */
+    protected long delayUntilNs;
+    /**
+     * When job is created, System.nanoTime() is assigned to {@code createdNs} value so that we know when job is created
+     * in relation to others
+     */
+    protected long createdNs;
+    protected long runningSessionId;
+    protected boolean requiresNetwork;
+    transient Job job;
+    protected final Set<String> tags;
+    private boolean cancelled;
+    private boolean successful;
+
+    /**
+     * @param id               Unique ID for the job. Should be unique per queue
+     * @param priority         Higher is better
+     * @param groupId          which group does this job belong to? default null
+     * @param runCount         Incremented each time job is fetched to run, initial value should be 0
+     * @param job              Actual job to run
+     * @param createdNs        System.nanotime
+     * @param delayUntilNs     System.nanotime value where job can be run the very first time
+     * @param runningSessionId
+     */
+    public JobHolder(Long id, int priority, String groupId, int runCount, Job job, long createdNs, long delayUntilNs, long runningSessionId) {
+        this.id = id;
+        this.priority = priority;
+        this.groupId = groupId;
+        this.runCount = runCount;
+        this.createdNs = createdNs;
+        this.delayUntilNs = delayUntilNs;
+        this.job = job;
+        this.runningSessionId = runningSessionId;
+        this.requiresNetwork = job.requiresNetwork();
+        this.tags = job.getTags() == null ? null : Collections.unmodifiableSet(job.getTags());
+    }
+
+    public JobHolder(int priority, Job job, long runningSessionId) {
+        this(null, priority, null, 0, job, System.nanoTime(), Long.MIN_VALUE, runningSessionId);
+    }
+
+    public JobHolder(int priority, Job job, long delayUntilNs, long runningSessionId) {
+        this(null, priority, job.getRunGroupId(), 0, job, System.nanoTime(), delayUntilNs, runningSessionId);
+    }
+
+    /**
+     * runs the job w/o throwing any exceptions
+     * @param currentRunCount
+     * @return RUN_RESULT*
+     */
+    public final int safeRun(int currentRunCount) {
+        return job.safeRun(this, currentRunCount);
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public boolean requiresNetwork() {
+        return requiresNetwork;
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public void setPriority(int priority) {
+        this.priority = priority;
+    }
+
+    public int getRunCount() {
+        return runCount;
+    }
+
+    public void setRunCount(int runCount) {
+        this.runCount = runCount;
+    }
+
+    public long getCreatedNs() {
+        return createdNs;
+    }
+
+    public void setCreatedNs(long createdNs) {
+        this.createdNs = createdNs;
+    }
+
+    public long getRunningSessionId() {
+        return runningSessionId;
+    }
+
+    public void setRunningSessionId(long runningSessionId) {
+        this.runningSessionId = runningSessionId;
+    }
+
+    public long getDelayUntilNs() {
+        return delayUntilNs;
+    }
+
+    public Job getJob() {
+        return job;
+    }
+
+    public void setJob(Job job) {
+        this.job = job;
+    }
+
+    public String getGroupId() {
+        return groupId;
+    }
+
+    public Set<String> getTags() {
+        return tags;
+    }
+
+    public void markAsCancelled() {
+        cancelled = true;
+        job.cancelled = true;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public int hashCode() {
+        //we don't really care about overflow.
+        if(id == null) {
+            return super.hashCode();
+        }
+        return id.intValue();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(o instanceof JobHolder == false) {
+            return false;
+        }
+        JobHolder other = (JobHolder) o;
+        if(id == null || other.id == null) {
+            return false;
+        }
+        return id.equals(other.id);
+    }
+
+    public boolean hasTags() {
+        return tags != null && tags.size() > 0;
+    }
+
+    public synchronized void markAsSuccessful() {
+        successful = true;
+    }
+
+    public synchronized boolean isSuccessful() {
+        return successful;
+    }
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/JobManager.java b/jobqueue/src/com/path/android/jobqueue/JobManager.java
old mode 100644
new mode 100755
index 1ac6968..ffdf63f
--- a/jobqueue/src/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/com/path/android/jobqueue/JobManager.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue;
 
 import android.content.Context;
+
 import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.di.DependencyInjector;
@@ -11,7 +12,12 @@
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
 import java.util.concurrent.*;
 
 /**
@@ -28,7 +34,7 @@
     public static final long NOT_DELAYED_JOB_DELAY = Long.MIN_VALUE;
     @SuppressWarnings("FieldCanBeLocal")//used for testing
     private final long sessionId;
-    private boolean running;
+    private volatile boolean running;
 
     private final Context appContext;
     private final NetworkUtil networkUtil;
@@ -40,7 +46,9 @@
     private final Object newJobListeners = new Object();
     private final ConcurrentHashMap<Long, CountDownLatch> persistentOnAddedLocks;
     private final ConcurrentHashMap<Long, CountDownLatch> nonPersistentOnAddedLocks;
-    private final ScheduledExecutorService timedExecutor;
+    private ScheduledExecutorService timedExecutor;
+    // lazily created
+    private Executor cancelExecutor;
     private final Object getNextJobLock = new Object();
 
     /**
@@ -74,8 +82,10 @@ public JobManager(Context context, Configuration config) {
         running = true;
         runningJobGroups = new CopyOnWriteGroupSet();
         sessionId = System.nanoTime();
-        this.persistentJobQueue = config.getQueueFactory().createPersistentQueue(context, sessionId, config.getId());
-        this.nonPersistentJobQueue = config.getQueueFactory().createNonPersistent(context, sessionId, config.getId());
+        this.persistentJobQueue = config.getQueueFactory()
+                .createPersistentQueue(context, sessionId, config.getId(), config.isInTestMode());
+        this.nonPersistentJobQueue = config.getQueueFactory()
+                .createNonPersistent(context, sessionId, config.getId(), config.isInTestMode());
         persistentOnAddedLocks = new ConcurrentHashMap<Long, CountDownLatch>();
         nonPersistentOnAddedLocks = new ConcurrentHashMap<Long, CountDownLatch>();
 
@@ -144,7 +154,224 @@ private int countReadyJobs(boolean hasNetwork) {
      */
     public long addJob(Job job) {
         //noinspection deprecation
-        return addJob(job.getPriority(), job.getDelayInMs(), job);
+        JobHolder jobHolder = new JobHolder(job.getPriority(), job
+                , job.getDelayInMs() > 0 ? System.nanoTime() + job.getDelayInMs() * NS_PER_MS : NOT_DELAYED_JOB_DELAY
+                , NOT_RUNNING_SESSION_ID);
+        long id;
+        if (job.isPersistent()) {
+            synchronized (persistentJobQueue) {
+                id = persistentJobQueue.insert(jobHolder);
+                addOnAddedLock(persistentOnAddedLocks, id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                id = nonPersistentJobQueue.insert(jobHolder);
+                addOnAddedLock(nonPersistentOnAddedLocks, id);
+            }
+        }
+        if(JqLog.isDebugEnabled()) {
+            JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
+                    , id, job.getClass().getSimpleName(), job.getPriority(), job.getDelayInMs(), job.getRunGroupId()
+                    , job.isPersistent(), job.requiresNetwork());
+        }
+        if(dependencyInjector != null) {
+            //inject members b4 calling onAdded
+            dependencyInjector.inject(job);
+        }
+        jobHolder.getJob().onAdded();
+        if(job.isPersistent()) {
+            synchronized (persistentJobQueue) {
+                clearOnAddedLock(persistentOnAddedLocks, id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                clearOnAddedLock(nonPersistentOnAddedLocks, id);
+            }
+        }
+        notifyJobConsumer();
+        return id;
+    }
+
+    /**
+     * Cancels all jobs matching the list of tags.
+     * <p>
+     * Note that, if any of the matching jobs is running, this method WILL wait for them to finish
+     * or fail.
+     * <p>
+     * This method uses a separate single threaded executor pool just for cancelling jobs
+     * because it may potentially wait for a long running job (if query matches that job). This
+     * pool is lazily created when the very first cancel request arrives.
+     * <p>
+     * A job may be already running when cancelJob is called. In this case, JobManager will wait
+     * until job fails or ends before returning from this method. If jobs succeeds before
+     * JobManager can cancel it, it will be added into {@link CancelResult#getFailedToCancel()}
+     * list.
+     * <p>
+     * If you call {@link #addJob(Job)} while {@link #cancelJobs(TagConstraint, String...)} is
+     * running, the behavior of that job will be undefined. If that jobs gets added to the queue
+     * before cancel query runs, it may be cancelled before running. It is up to you to sync these
+     * two requests if such cases may happen for you.
+     * <p/>
+     * This query is not atomic. If application terminates while jobs are being cancelled, some of
+     * them may be cancelled while some remain in the queue (for persistent jobs).
+     * <p/>
+     * This method guarantees calling {@link Job#onCancel()} before job is removed
+     * from the queue. If application terminates while {@link Job#onCancel()} is running, the
+     * Job will not be removed from disk (same behavior with jobs failing due to other reasons like
+     * hitting retry limit).
+     *
+     * @param constraint The constraint to use while selecting jobs. If set to {@link TagConstraint#ANY},
+     *                   any job that has one of the given tags will be cancelled. If set to
+     *                   {@link TagConstraint#ALL}, jobs that has all of the given tags will be cancelled.
+     * @param tags The list of tags
+     */
+    public void cancelJobsInBackground(final CancelResult.AsyncCancelCallback cancelCallback,
+            final TagConstraint constraint, final String... tags) {
+        synchronized (this) {
+            if (cancelExecutor == null) {
+                cancelExecutor = Executors.newSingleThreadExecutor();
+            }
+            cancelExecutor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    CancelResult result = cancelJobs(constraint, tags);
+                    if (cancelCallback != null) {
+                        cancelCallback.onCancelled(result);
+                    }
+                }
+            });
+        }
+    }
+
+    /**
+     * Cancel all jobs matching the list of tags.
+     * <p>
+     * Note that, you should NOT call this method on main thread because it queries database and
+     * may also need to wait for running jobs to finish.
+     * <p>
+     * A job may be already running when cancelJob is called. In this case, JobManager will wait
+     * until job fails or ends before returning from this method. If jobs succeeds before
+     * JobManager can cancel it, it will be added into {@link CancelResult#getFailedToCancel()}
+     * list.
+     * <p>
+     * If you call {@link #addJob(Job)} while {@link #cancelJobs(TagConstraint, String...)} is
+     * running, the behavior of that job will be undefined. If that jobs gets added to the queue
+     * before cancel query runs, it may be cancelled before running. It is up to you to sync these
+     * two requests if such cases may happen for you.
+     * <p/>
+     * This query is not atomic. If application terminates while jobs are being cancelled, some of
+     * them may be cancelled while some remain in the queue (for persistent jobs).
+     * <p/>
+     * This method guarantees calling {@link Job#onCancel()} before job is removed
+     * from the queue. If application terminates while {@link Job#onCancel()} is running, the
+     * Job will not be removed from disk (same behavior with jobs failing due to other reasons like
+     * hitting retry limit).
+     *
+     * @param constraint The constraint to use while selecting jobs. If set to {@link TagConstraint#ANY},
+     *                   any job that has one of the given tags will be cancelled. If set to
+     *                   {@link TagConstraint#ALL}, jobs that has all of the given tags will be cancelled.
+     * @param tags       The list of tags
+     * @return A Cancel result containing the list of jobs.
+     * @see #cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
+     */
+    public CancelResult cancelJobs(final TagConstraint constraint, final String... tags) {
+        final List<JobHolder> jobs = new ArrayList<JobHolder>();
+        final Set<Long> persistentJobIds = new HashSet<Long>();
+        final Set<Long> nonPersistentJobIds = new HashSet<Long>();
+        final Set<Long> runningNonPersistentJobIds = new HashSet<>();
+        final Set<Long> runningPersistentJobIds = new HashSet<>();
+        synchronized (getNextJobLock) {
+            jobConsumerExecutor.inRunningJobHoldersLock(new Runnable() {
+                @Override
+                public void run() {
+                    // TODO if app terminates while cancelling, job will be removed w/o receiving an onCancel call!!!
+                    Set<JobHolder> nonPersistentRunningJobs = jobConsumerExecutor
+                            .findRunningByTags(constraint, tags, false);
+                    synchronized (nonPersistentJobQueue) {
+                        markJobsAsCancelledAndFilterAlreadyCancelled(nonPersistentRunningJobs,
+                                nonPersistentJobQueue, nonPersistentJobIds);
+                        runningNonPersistentJobIds.addAll(nonPersistentJobIds);
+                        Set<JobHolder> nonPersistentJobs = nonPersistentJobQueue
+                                .findJobsByTags(constraint, true, nonPersistentJobIds, tags);
+                        markJobsAsCancelledAndFilterAlreadyCancelled(nonPersistentJobs,
+                                nonPersistentJobQueue, nonPersistentJobIds);
+                        jobs.addAll(nonPersistentJobs);
+                    }
+                    jobs.addAll(nonPersistentRunningJobs);
+
+                    Set<JobHolder> persistentRunningJobs = jobConsumerExecutor
+                            .findRunningByTags(constraint, tags, true);
+                    synchronized (persistentJobQueue) {
+                        markJobsAsCancelledAndFilterAlreadyCancelled(persistentRunningJobs,
+                                persistentJobQueue, persistentJobIds);
+                        runningPersistentJobIds.addAll(persistentJobIds);
+                        Set<JobHolder> persistentJobs = persistentJobQueue
+                                .findJobsByTags(constraint, true, persistentJobIds, tags);
+                        markJobsAsCancelledAndFilterAlreadyCancelled(persistentJobs,
+                                persistentJobQueue, persistentJobIds);
+                        jobs.addAll(persistentJobs);
+                    }
+                    jobs.addAll(persistentRunningJobs);
+                }
+            });
+        }
+
+        try {
+            // non persistent jobs are removed from queue as soon as they are marked as cancelled
+            // persistent jobs are given a running session id upon cancellation.
+            // this ensures that these jobs won't show up in next job queries.
+            // if subsequent cancel requests come for these jobs, they won't show up again either
+            // because markJobsAsCancelledAndFilterAlreadyCancelled will filter them out
+            jobConsumerExecutor.waitUntilDone(persistentJobIds, nonPersistentJobIds);
+        } catch (InterruptedException e) {
+            JqLog.e(e, "error while waiting for jobs to finish");
+        }
+        CancelResult result = new CancelResult();
+        for (JobHolder holder : jobs) {
+            JqLog.d("checking if I could cancel %s. Result: %s", holder.getJob(), !holder.isSuccessful());
+            if (holder.isSuccessful()) {
+                result.failedToCancel.add(holder.getJob());
+            } else {
+                result.cancelledJobs.add(holder.getJob());
+                try {
+                    holder.getJob().onCancel();
+                } catch (Throwable t) {
+                    JqLog.e(t, "cancelled job's onCancel has thrown exception");
+                }
+                // if job is removed while running, make sure we remove it from running job
+                // groups as well. JobExecutor won't remove the job.
+                if (holder.getJob().isPersistent()) {
+                    synchronized (persistentJobQueue) {
+                        persistentJobQueue.remove(holder);
+                    }
+                    if (holder.getGroupId() != null &&
+                            runningPersistentJobIds.contains(holder.getId())) {
+                        runningJobGroups.remove(holder.getGroupId());
+                    }
+                } else if (holder.getGroupId() != null &&
+                        runningNonPersistentJobIds.contains(holder.getId())) {
+                    runningJobGroups.remove(holder.getGroupId());
+                }
+            }
+        }
+        return result;
+    }
+
+    private void markJobsAsCancelledAndFilterAlreadyCancelled(Set<JobHolder> jobs, JobQueue queue,
+            Set<Long> outIds) {
+        Iterator<JobHolder> itr = jobs.iterator();
+        while (itr.hasNext()) {
+            JobHolder holder = itr.next();
+            // although cancelled is not persistent to disk, this will still work because we would
+            // receive the same job back if it was just cancelled in this session.
+            if (holder.isCancelled()) {
+                itr.remove();
+            } else {
+                holder.markAsCancelled();
+                outIds.add(holder.getId());
+                queue.onJobCancelled(holder);
+            }
+        }
     }
 
     /**
@@ -155,11 +382,23 @@ public long addJob(Job job) {
      */
     public void addJobInBackground(Job job) {
         //noinspection deprecation
-        addJobInBackground(job.getPriority(), job.getDelayInMs(), job);
+        addJobInBackground(job, null);
     }
 
-    public void addJobInBackground(Job job, /*nullable*/ AsyncAddCallback callback) {
-        addJobInBackground(job.getPriority(), job.getDelayInMs(), job, callback);
+    public void addJobInBackground(final Job job, /*nullable*/ final AsyncAddCallback callback) {
+        timedExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    long id = addJob(job);
+                    if(callback != null) {
+                        callback.onAdded(id);
+                    }
+                } catch (Throwable t) {
+                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", job.getClass().getSimpleName());
+                }
+            }
+        });
     }
 
     //need to sync on related job queue before calling this
@@ -263,14 +502,14 @@ private JobHolder getNextJob() {
         JobHolder jobHolder;
         boolean persistent = false;
         synchronized (getNextJobLock) {
-            final Collection<String> runningJobIds = runningJobGroups.getSafe();
+            final Collection<String> runningJobGroups = this.runningJobGroups.getSafe();
             synchronized (nonPersistentJobQueue) {
-                jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobIds);
+                jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
             }
             if (jobHolder == null) {
                 //go to disk, there aren't any non-persistent jobs
                 synchronized (persistentJobQueue) {
-                    jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobIds);
+                    jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
                     persistent = true;
                 }
             }
@@ -278,10 +517,10 @@ private JobHolder getNextJob() {
                 return null;
             }
             if(persistent && dependencyInjector != null) {
-                dependencyInjector.inject(jobHolder.getBaseJob());
+                dependencyInjector.inject(jobHolder.getJob());
             }
             if(jobHolder.getGroupId() != null) {
-                runningJobGroups.add(jobHolder.getGroupId());
+                this.runningJobGroups.add(jobHolder.getGroupId());
             }
         }
 
@@ -297,14 +536,18 @@ private JobHolder getNextJob() {
 
     private void reAddJob(JobHolder jobHolder) {
         JqLog.d("re-adding job %s", jobHolder.getId());
-        if (jobHolder.getBaseJob().isPersistent()) {
-            synchronized (persistentJobQueue) {
-                persistentJobQueue.insertOrReplace(jobHolder);
+        if (!jobHolder.isCancelled()) {
+            if (jobHolder.getJob().isPersistent()) {
+                synchronized (persistentJobQueue) {
+                    persistentJobQueue.insertOrReplace(jobHolder);
+                }
+            } else {
+                synchronized (nonPersistentJobQueue) {
+                    nonPersistentJobQueue.insertOrReplace(jobHolder);
+                }
             }
         } else {
-            synchronized (nonPersistentJobQueue) {
-                nonPersistentJobQueue.insertOrReplace(jobHolder);
-            }
+            JqLog.d("not re-adding cancelled job " + jobHolder);
         }
         if(jobHolder.getGroupId() != null) {
             runningJobGroups.remove(jobHolder.getGroupId());
@@ -354,7 +597,7 @@ public JobStatus getJobStatus(long id, boolean isPersistent) {
     }
 
     private void removeJob(JobHolder jobHolder) {
-        if (jobHolder.getBaseJob().isPersistent()) {
+        if (jobHolder.getJob().isPersistent()) {
             synchronized (persistentJobQueue) {
                 persistentJobQueue.remove(jobHolder);
             }
@@ -368,6 +611,16 @@ private void removeJob(JobHolder jobHolder) {
         }
     }
 
+    public synchronized void stopAndWaitUntilConsumersAreFinished() throws InterruptedException {
+        stop();
+        timedExecutor.shutdownNow();
+        synchronized (newJobListeners) {
+            newJobListeners.notifyAll();
+        }
+        jobConsumerExecutor.waitUntilAllConsumersAreFinished();
+        timedExecutor = Executors.newSingleThreadScheduledExecutor();
+    }
+
     public synchronized void clear() {
         synchronized (nonPersistentJobQueue) {
             nonPersistentJobQueue.clear();
@@ -418,7 +671,7 @@ public JobHolder getNextJob(int wait, TimeUnit waitDuration) {
             long waitUntil = remainingWait + start;
             //for delayed jobs,
             long nextJobDelay = ensureConsumerWhenNeeded(null);
-            while (nextJob == null && waitUntil > System.nanoTime()) {
+            while (nextJob == null && waitUntil > System.nanoTime() && running) {
                 //keep running inside here to avoid busy loop
                 nextJob = running ? JobManager.this.getNextJob() : null;
                 if(nextJob == null) {
@@ -427,7 +680,7 @@ public JobHolder getNextJob(int wait, TimeUnit waitDuration) {
                         //if we can't detect network changes, we won't be notified.
                         //to avoid waiting up to give time, wait in chunks of 500 ms max
                         long maxWait = Math.min(nextJobDelay, TimeUnit.NANOSECONDS.toMillis(remaining));
-                        if(maxWait < 1) {
+                        if(maxWait < 1 || !running) {
                             continue;//wait(0) will cause infinite wait.
                         }
                         if(networkUtil instanceof NetworkEventProvider) {
@@ -468,111 +721,6 @@ public int countRemainingReadyJobs() {
         }
     };
 
-    /**
-     * Deprecated, please use {@link #addJob(Job)}.
-     *
-     * <p>Adds a job with given priority and returns the JobId.</p>
-     * @param priority Higher runs first
-     * @param baseJob The actual job to run
-     * @return job id
-     */
-    @Deprecated
-    public long addJob(int priority, BaseJob baseJob) {
-        return addJob(priority, 0, baseJob);
-    }
-
-    /**
-     * Deprecated, please use {@link #addJob(Job)}.
-     *
-     * <p>Adds a job with given priority and returns the JobId.</p>
-     * @param priority Higher runs first
-     * @param delay number of milliseconds that this job should be delayed
-     * @param baseJob The actual job to run
-     * @return a job id. is useless for now but we'll use this to cancel jobs in the future.
-     */
-    @Deprecated
-    public long addJob(int priority, long delay, BaseJob baseJob) {
-        JobHolder jobHolder = new JobHolder(priority, baseJob, delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY, NOT_RUNNING_SESSION_ID);
-        long id;
-        if (baseJob.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                id = persistentJobQueue.insert(jobHolder);
-                addOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                id = nonPersistentJobQueue.insert(jobHolder);
-                addOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        if(JqLog.isDebugEnabled()) {
-            JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
-                    , id, baseJob.getClass().getSimpleName(), priority, delay, baseJob.getRunGroupId()
-                    , baseJob.isPersistent(), baseJob.requiresNetwork());
-        }
-        if(dependencyInjector != null) {
-            //inject members b4 calling onAdded
-            dependencyInjector.inject(baseJob);
-        }
-        jobHolder.getBaseJob().onAdded();
-        if(baseJob.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                clearOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                clearOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        notifyJobConsumer();
-        return id;
-    }
-
-    /**
-     * Please use {@link #addJobInBackground(Job)}.
-     * <p>Non-blocking convenience method to add a job in background thread.</p>
-     *
-     * @see #addJob(int, BaseJob) addJob(priority, job).
-     */
-    @Deprecated
-    public void addJobInBackground(final int priority, final BaseJob baseJob) {
-        timedExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                addJob(priority, baseJob);
-            }
-        });
-    }
-
-    /**
-     * Deprecated, please use {@link #addJobInBackground(Job)}.
-     * <p></p>Non-blocking convenience method to add a job in background thread.</p>
-     * @see #addJob(int, long, BaseJob) addJob(priority, delay, job).
-     */
-    @Deprecated
-    public void addJobInBackground(final int priority, final long delay, final BaseJob baseJob) {
-        addJobInBackground(priority, delay, baseJob, null);
-    }
-
-    protected void addJobInBackground(final int priority, final long delay, final BaseJob baseJob,
-        /*nullable*/final AsyncAddCallback callback) {
-        final long callTime = System.nanoTime();
-        timedExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    final long runDelay = (System.nanoTime() - callTime) / NS_PER_MS;
-                    long id = addJob(priority, Math.max(0, delay - runDelay), baseJob);
-                    if(callback != null) {
-                        callback.onAdded(id);
-                    }
-                } catch (Throwable t) {
-                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", baseJob.getClass().getSimpleName() );
-                }
-            }
-        });
-    }
-
 
     /**
      * Default implementation of QueueFactory that creates one {@link SqliteJobQueue} and one {@link NonPersistentPriorityQueue}
@@ -590,12 +738,16 @@ public DefaultQueueFactory(SqliteJobQueue.JobSerializer jobSerializer) {
         }
 
         @Override
-        public JobQueue createPersistentQueue(Context context, Long sessionId, String id) {
-            return new CachedJobQueue(new SqliteJobQueue(context, sessionId, id, jobSerializer));
+        public JobQueue createPersistentQueue(Context context, Long sessionId, String id,
+                boolean inTestMode) {
+            return new CachedJobQueue(new SqliteJobQueue(context, sessionId, id, jobSerializer,
+                    inTestMode));
         }
+
         @Override
-        public JobQueue createNonPersistent(Context context, Long sessionId, String id) {
-            return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id));
+        public JobQueue createNonPersistent(Context context, Long sessionId, String id,
+                boolean inTestMode) {
+            return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id, inTestMode));
         }
     }
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/JobQueue.java b/jobqueue/src/com/path/android/jobqueue/JobQueue.java
old mode 100644
new mode 100755
index a149a00..7542208
--- a/jobqueue/src/com/path/android/jobqueue/JobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/JobQueue.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue;
 
 import java.util.Collection;
+import java.util.Set;
 
 /**
  * Interface that any JobQueue should implement
@@ -51,8 +52,8 @@
     /**
      * Returns the next available job in the data set
      * It should also assign the sessionId as the RunningSessionId and persist that data if necessary.
-     * It should filter out all running jobs and
-     * exclude groups are guaranteed to be ordered in natural order
+     * It should filter out all running jobs and exclude groups are guaranteed to be ordered in natural order
+     *
      * @param hasNetwork if true, should return any job, if false, should return jobs that do NOT require network
      * @param excludeGroups if provided, jobs from these groups will NOT be returned
      * @return
@@ -79,4 +80,27 @@
      */
     JobHolder findJobById(long id);
 
+    /**
+     * Returns jobs that has the given tags.
+     *
+     * @param tagConstraint If set to {@link TagConstraint#ALL}, returned jobs should have all of
+     *                      the tags provided. If set to {@link TagConstraint#ANY}, returned jobs
+     *                      should have at least one of the provided tags
+     * @param excludeCancelled If true, cancelled jobs will not be returned. A job may be in cancelled
+     *                        state if a cancel request has arrived but it has not been removed from
+     *                        queue yet (e.g. still running).
+     * @param excludeIds Ids of jobs to ignore in the result
+     * @param tags The list of tags
+     */
+    Set<JobHolder> findJobsByTags(TagConstraint tagConstraint, boolean excludeCancelled,
+            Collection<Long> excludeIds, String... tags);
+
+    /**
+     * Called when a job is cancelled by the user.
+     * <p/>
+     * It is important to not return this job from queries anymore.
+     *
+     * @param holder The JobHolder that is being cancelled
+     */
+    void onJobCancelled(JobHolder holder);
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/Params.java b/jobqueue/src/com/path/android/jobqueue/Params.java
old mode 100644
new mode 100755
index 1695d94..f388971
--- a/jobqueue/src/com/path/android/jobqueue/Params.java
+++ b/jobqueue/src/com/path/android/jobqueue/Params.java
@@ -1,7 +1,9 @@
 package com.path.android.jobqueue;
 
+import java.util.HashSet;
+
 /**
- * BaseJob builder object to have a more readable design.
+ * Job builder object to have a more readable design.
  * Methods can be chained to have more readable code.
  */
 public class Params {
@@ -10,6 +12,7 @@
     private boolean persistent = false;
     private int priority;
     private long delayMs;
+    private HashSet<String> tags;
 
     /**
      *
@@ -97,6 +100,43 @@ public Params setDelayMs(long delayMs) {
         return this;
     }
 
+    /**
+     * Attaches given tags to the Job.
+     * These are initially used for cancelling or querying jobs but usage will be extended
+     * @param newTags List of tags to add
+     * @return
+     */
+    public Params addTags(String... newTags) {
+        if(tags == null) {
+            tags = new HashSet<String>();
+        }
+        for(String tag : newTags) {
+            tags.add(tag);
+        }
+        return this;
+    }
+
+    /**
+     * Removes the given tags from the Job.
+     *
+     * @param oldTags List of tags to be removed
+     * @return
+     */
+    public Params removeTags(String... oldTags) {
+        if(tags == null) {
+            return this;
+        }
+        for(String tag : oldTags) {
+            tags.remove(tag);
+        }
+        return this;
+    }
+
+    public Params clearTags() {
+        tags = null;
+        return this;
+    }
+
     public boolean doesRequireNetwork() {
         return requiresNetwork;
     }
@@ -116,4 +156,8 @@ public int getPriority() {
     public long getDelayMs() {
         return delayMs;
     }
+
+    public HashSet<String> getTags() {
+        return tags;
+    }
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/QueueFactory.java b/jobqueue/src/com/path/android/jobqueue/QueueFactory.java
old mode 100644
new mode 100755
index 5110677..bd6c981
--- a/jobqueue/src/com/path/android/jobqueue/QueueFactory.java
+++ b/jobqueue/src/com/path/android/jobqueue/QueueFactory.java
@@ -6,6 +6,8 @@
  * Interface to supply custom {@link JobQueue}s for JobManager
  */
 public interface QueueFactory {
-    public JobQueue createPersistentQueue(Context context, Long sessionId, String id);
-    public JobQueue createNonPersistent(Context context, Long sessionId, String id);
+    public JobQueue createPersistentQueue(Context context, Long sessionId, String id,
+            boolean inTestMode);
+    public JobQueue createNonPersistent(Context context, Long sessionId, String id,
+            boolean inTestMode);
 }
\ No newline at end of file
diff --git a/jobqueue/src/com/path/android/jobqueue/TagConstraint.java b/jobqueue/src/com/path/android/jobqueue/TagConstraint.java
new file mode 100755
index 0000000..0caa3b4
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/TagConstraint.java
@@ -0,0 +1,6 @@
+package com.path.android.jobqueue;
+
+public enum TagConstraint {
+    ALL,
+    ANY
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
old mode 100644
new mode 100755
index c373c99..4867fb4
--- a/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
@@ -2,8 +2,10 @@
 
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.TagConstraint;
 
 import java.util.Collection;
+import java.util.Set;
 
 /**
  * a class that implements {@link JobQueue} interface, wraps another {@link JobQueue} and caches
@@ -93,6 +95,17 @@ public void clear() {
         delegate.clear();
     }
 
+    @Override
+    public Set<JobHolder> findJobsByTags(TagConstraint constraint, boolean excludeCancelled,
+            Collection<Long> exclude, String... tags) {
+        return delegate.findJobsByTags(constraint, excludeCancelled, exclude, tags);
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        delegate.onJobCancelled(holder);
+    }
+
     @Override
     public JobHolder findJobById(long id) {
         return delegate.findJobById(id);
diff --git a/jobqueue/src/com/path/android/jobqueue/config/Configuration.java b/jobqueue/src/com/path/android/jobqueue/config/Configuration.java
old mode 100644
new mode 100755
index 6fb3fca..d877ea0
--- a/jobqueue/src/com/path/android/jobqueue/config/Configuration.java
+++ b/jobqueue/src/com/path/android/jobqueue/config/Configuration.java
@@ -31,6 +31,7 @@
     private DependencyInjector dependencyInjector;
     private NetworkUtil networkUtil;
     private CustomLogger customLogger;
+    private boolean inTestMode = false;
 
     private Configuration(){
         //use builder instead
@@ -72,6 +73,10 @@ public int getLoadFactor() {
         return loadFactor;
     }
 
+    public boolean isInTestMode() {
+        return inTestMode;
+    }
+
     public static final class Builder {
         private Configuration configuration;
         private Context appContext;
@@ -139,7 +144,7 @@ public Builder networkUtil(NetworkUtil networkUtil) {
 
         /**
          * JobManager is suitable for DependencyInjection. Just provide your DependencyInjector and it will call it
-         * before {BaseJob#onAdded} method is called.
+         * before {Job#onAdded} method is called.
          * if job is persistent, it will also be called before run method.
          * @param injector your dependency injector interface, if using one
          * @return
@@ -189,6 +194,16 @@ public Builder loadFactor(int loadFactor) {
             return this;
         }
 
+        /**
+         * Sets the JobManager in test mode. This information is passed to JobQueue's.
+         * If you are using default JobQueues, calling this method will cause {@link SqliteJobQueue}
+         * to use an in-memory database.
+         */
+        public Builder inTestMode() {
+            configuration.inTestMode = true;
+            return this;
+        }
+
         public Configuration build() {
             if(configuration.queueFactory == null) {
                 configuration.queueFactory = new JobManager.DefaultQueueFactory();
diff --git a/jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java b/jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java
old mode 100644
new mode 100755
index 7ff7b49..75d1d72
--- a/jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java
+++ b/jobqueue/src/com/path/android/jobqueue/di/DependencyInjector.java
@@ -1,6 +1,6 @@
 package com.path.android.jobqueue.di;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 
 /**
  * interface that can be provided to {@link com.path.android.jobqueue.JobManager} for dependency injection
@@ -8,5 +8,5 @@
  * back from disk.
  */
 public interface DependencyInjector {
-    public void inject(BaseJob job);
+    public void inject(Job job);
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
old mode 100644
new mode 100755
index 139d92c..723c1f7
--- a/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
+++ b/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
@@ -1,11 +1,17 @@
 package com.path.android.jobqueue.executor;
 
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.log.JqLog;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -107,15 +113,20 @@ private boolean isAboveLoadFactor(boolean inConsumerThread) {
     }
 
     private void onBeforeRun(JobHolder jobHolder) {
-        runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);
+        synchronized (runningJobHolders) {
+            runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);
+        }
     }
 
     private void onAfterRun(JobHolder jobHolder) {
-        runningJobHolders.remove(createRunningJobHolderKey(jobHolder));
+        synchronized (runningJobHolders) {
+            runningJobHolders.remove(createRunningJobHolderKey(jobHolder));
+            runningJobHolders.notifyAll();
+        }
     }
 
     private String createRunningJobHolderKey(JobHolder jobHolder) {
-        return createRunningJobHolderKey(jobHolder.getId(), jobHolder.getBaseJob().isPersistent());
+        return createRunningJobHolderKey(jobHolder.getId(), jobHolder.getJob().isPersistent());
     }
 
     private String createRunningJobHolderKey(long id, boolean isPersistent) {
@@ -129,7 +140,101 @@ private String createRunningJobHolderKey(long id, boolean isPersistent) {
      * @return true if job is currently handled here
      */
     public boolean isRunning(long id, boolean persistent) {
-        return runningJobHolders.containsKey(createRunningJobHolderKey(id, persistent));
+        synchronized (runningJobHolders) {
+            return runningJobHolders.containsKey(createRunningJobHolderKey(id, persistent));
+        }
+    }
+
+    public void waitUntilDone(Set<Long> persistentJobIds, Set<Long> nonPersistentJobIds)
+            throws InterruptedException {
+        List<String> ids = new ArrayList<String>();
+        for (Long id : persistentJobIds) {
+            ids.add(createRunningJobHolderKey(id, true));
+        }
+        for (Long id : nonPersistentJobIds) {
+            ids.add(createRunningJobHolderKey(id, false));
+        }
+        synchronized (runningJobHolders) {
+            while (containsAny(ids)) {
+                runningJobHolders.wait();
+            }
+        }
+    }
+
+    private boolean containsAny(List<String> ids) {
+        for (String id : ids) {
+            if (runningJobHolders.containsKey(id)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void inRunningJobHoldersLock(Runnable runnable) {
+        synchronized (runnable) {
+            runnable.run();;
+        }
+    }
+
+    /**
+     * Excludes cancelled jobs
+     */
+    public Set<JobHolder> findRunningByTags(TagConstraint constraint, String[] tags,
+            boolean persistent) {
+        Set<JobHolder> result = new HashSet<JobHolder>();
+        synchronized (runningJobHolders) {
+            for (JobHolder holder : runningJobHolders.values()) {
+                JqLog.d("checking job tag %s. tags of job: %s", holder.getJob(), holder.getJob().getTags());
+                if (!holder.hasTags() || persistent != holder.getJob().isPersistent()) {
+                    continue;
+                }
+                if (holder.isCancelled()) {
+                    continue;
+                }
+                if (doesHolderMatchTags(holder, constraint, tags)) {
+                    result.add(holder);
+                }
+            }
+        }
+        return result;
+    }
+
+    private boolean doesHolderMatchTags(JobHolder holder, TagConstraint constraint, String[] tags) {
+        if (constraint == TagConstraint.ANY) {
+            for (String tag : holder.getTags()) {
+                if (contains(tags, tag)) {
+                    return true;
+                }
+            }
+            return false;
+        } else {
+            final Set<String> holderTags = holder.getTags();
+            for (String tag : tags) {
+                if (!holderTags.contains(tag)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    private boolean contains(String[] arr, String val) {
+        for (int i = 0; i < arr.length; i ++) {
+            if (val.equals(arr[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void waitUntilAllConsumersAreFinished() throws InterruptedException {
+        Thread[] threads = new Thread[threadGroup.activeCount() * 3];
+        threadGroup.enumerate(threads);
+        for (Thread thread : threads) {
+            if (thread != null) {
+                thread.join();
+            }
+        }
     }
 
     /**
@@ -198,10 +303,23 @@ public void run() {
                         nextJob = contract.isRunning() ? contract.getNextJob(executor.keepAliveSeconds, TimeUnit.SECONDS) : null;
                         if (nextJob != null) {
                             executor.onBeforeRun(nextJob);
-                            if (nextJob.safeRun(nextJob.getRunCount())) {
-                                contract.removeJob(nextJob);
-                            } else {
-                                contract.insertOrReplace(nextJob);
+                            int result = nextJob.safeRun(nextJob.getRunCount());
+                            switch (result) {
+                                case JobHolder.RUN_RESULT_SUCCESS:
+                                    nextJob.markAsSuccessful();
+                                    contract.removeJob(nextJob);
+                                    break;
+                                case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
+                                    contract.removeJob(nextJob);
+                                    break;
+                                case JobHolder.RUN_RESULT_TRY_AGAIN:
+                                    contract.insertOrReplace(nextJob);
+                                    break;
+                                case JobHolder.RUN_RESULT_FAIL_FOR_CANCEL:
+                                    JqLog.d("running job failed and cancelled, doing nothing. "
+                                            + "Will be removed after it's onCancel is called by the "
+                                            + "JobManager");
+                                    break;
                             }
                             executor.onAfterRun(nextJob);
                         }
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
old mode 100644
new mode 100755
index b084a0e..fec848f
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
@@ -1,21 +1,25 @@
 package com.path.android.jobqueue.nonPersistentQueue;
 
 import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.TagConstraint;
 
 import java.util.Collection;
+import java.util.Set;
 
 /**
  * An interface for Job Containers
  * It is very similar to SortedSet
  */
 public interface JobSet {
-    public JobHolder peek(Collection<String> excludeGroupIds);
-    public JobHolder poll(Collection<String> excludeGroupIds);
-    public JobHolder findById(long id);
-    public boolean offer(JobHolder holder);
-    public boolean remove(JobHolder holder);
-    public void clear();
-    public int size();
-    public CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups);
-    public CountWithGroupIdsResult countReadyJobs(Collection<String> excludeGroups);
+    JobHolder peek(Collection<String> excludeGroupIds);
+    JobHolder poll(Collection<String> excludeGroupIds);
+    JobHolder findById(long id);
+    Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
+            String... tags);
+    boolean offer(JobHolder holder);
+    boolean remove(JobHolder holder);
+    void clear();
+    int size();
+    CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups);
+    CountWithGroupIdsResult countReadyJobs(Collection<String> excludeGroups);
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
old mode 100644
new mode 100755
index f32fd7c..9c56589
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue.nonPersistentQueue;
 
 import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.TagConstraint;
 
 import java.util.*;
 
@@ -201,8 +202,6 @@ public CountWithGroupIdsResult countReadyJobs(SetId setId, Collection<String> ex
         }
     }
 
-
-
     /**
      * Returns the JobHolder that has the given id
      * @param id id job the job
@@ -214,6 +213,15 @@ public JobHolder findById(long id) {
         return q0 == null ? queue1.findById(id) : q0;
     }
 
+    @Override
+    public Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
+            String... tags) {
+        Set<JobHolder> jobs = new HashSet<JobHolder>();
+        jobs.addAll(queue0.findByTags(constraint, exclude, tags));
+        jobs.addAll(queue1.findByTags(constraint, exclude, tags));
+        return jobs;
+    }
+
     /**
      * simple enum to identify queues
      */
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
old mode 100644
new mode 100755
index aec9272..fe5a800
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
@@ -1,12 +1,17 @@
 package com.path.android.jobqueue.nonPersistentQueue;
 
 import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.log.JqLog;
 
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
@@ -21,11 +26,13 @@
     //groupId -> # of jobs in that group
     private final Map<String, Integer> existingGroups;
     private final Map<Long, JobHolder> idCache;
+    private final Map<String, List<JobHolder>> tagCache;
 
     public NonPersistentJobSet(Comparator<JobHolder> comparator) {
         this.set = new TreeSet<JobHolder>(comparator);
         this.existingGroups = new HashMap<String, Integer>();
         this.idCache = new HashMap<Long, JobHolder>();
+        this.tagCache = new HashMap<String, List<JobHolder>>();
     }
 
     private JobHolder safeFirst() {
@@ -75,6 +82,60 @@ public JobHolder findById(long id) {
         return idCache.get(id);
     }
 
+    @Override
+    public Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
+            String... tags) {
+        if(tags == null) {
+            return Collections.emptySet();
+        }
+        Set<JobHolder> jobs = new HashSet<JobHolder>();
+        boolean first = true;
+        for(String tag : tags) {
+            List<JobHolder> found = tagCache.get(tag);
+            if(found == null || found.size() == 0) {
+                if (constraint == TagConstraint.ALL) {
+                    return Collections.emptySet();
+                } else {
+                    continue;
+                }
+            }
+            if (constraint == TagConstraint.ALL) {
+                jobs.addAll(found);
+            } else if (first) {
+                jobs.addAll(found);
+            } else {
+                removeIfNotExists(jobs, found);
+                if (jobs.size() == 0) {
+                    return Collections.emptySet();
+                }
+            }
+            first = false;
+        }
+        if (exclude != null) {
+            removeIds(jobs, exclude);
+        }
+        return jobs;
+    }
+
+    private void removeIds(Set<JobHolder> mainSet, Collection<Long> ids) {
+        final Iterator<JobHolder> itr = mainSet.iterator();
+        while (itr.hasNext()) {
+            JobHolder holder = itr.next();
+            if (ids.contains(holder.getId())) {
+                itr.remove();
+            }
+        }
+    }
+    private void removeIfNotExists(Set<JobHolder> mainSet, List<JobHolder> items) {
+        final Iterator<JobHolder> itr = mainSet.iterator();
+        while (itr.hasNext()) {
+            JobHolder holder = itr.next();
+            if (!items.contains(holder)) {
+                itr.remove();
+            }
+        }
+    }
+
     @Override
     public boolean offer(JobHolder holder) {
         if(holder.getId() == null) {
@@ -88,6 +149,7 @@ public boolean offer(JobHolder holder) {
         }
         if(result) {
             idCache.put(holder.getId(), holder);
+            addToTagCache(holder);
             if(holder.getGroupId() != null) {
                 incGroupCount(holder.getGroupId());
             }
@@ -96,6 +158,42 @@ public boolean offer(JobHolder holder) {
         return result;
     }
 
+    private void addToTagCache(JobHolder holder) {
+        final Set<String> tags = holder.getTags();
+        if(tags == null || tags.size() == 0) {
+            return;
+        }
+        for(String tag : tags) {
+            List<JobHolder> jobs = tagCache.get(tag);
+            if(jobs == null) {
+                jobs = new LinkedList<JobHolder>();
+                tagCache.put(tag, jobs);
+            }
+            jobs.add(holder);
+        }
+    }
+
+    private void removeFromTagCache(JobHolder holder) {
+        final Set<String> tags = holder.getTags();
+        if(tags == null || tags.size() == 0) {
+            return;
+        }
+        for(String tag : tags) {
+            List<JobHolder> jobs = tagCache.get(tag);
+            if(jobs == null) {
+                JqLog.e("trying to remove job from tag cache but cannot find the tag cache");
+                return;
+            }
+            if(jobs.remove(holder) == false) {
+                JqLog.e("trying to remove job from tag cache but cannot find it in the cache");
+            } else if(jobs.size() == 0) {
+                tagCache.remove(tag); // TODO pool?
+            }
+
+        }
+    }
+
+
     private void incGroupCount(String groupId) {
         if(existingGroups.containsKey(groupId) == false) {
             existingGroups.put(groupId, 1);
@@ -106,14 +204,18 @@ private void incGroupCount(String groupId) {
 
     private void decGroupCount(String groupId) {
         Integer val = existingGroups.get(groupId);
-        if(val == null || val == 0) {
+        if(val == null || val <= 0) {
             //TODO should we crash?
-            JqLog.e("detected inconsistency in NonPersistentJobSet's group id hash");
+            JqLog.e("detected inconsistency in NonPersistentJobSet's group id hash. Please report " +
+                    "a bug");
+            existingGroups.remove(groupId);
             return;
         }
         val -= 1;
         if(val == 0) {
             existingGroups.remove(groupId);
+        } else {
+            existingGroups.put(groupId, val);
         }
     }
 
@@ -122,6 +224,7 @@ public boolean remove(JobHolder holder) {
         boolean removed = set.remove(holder);
         if(removed) {
             idCache.remove(holder.getId());
+            removeFromTagCache(holder);
             if(holder.getGroupId() != null) {
                 decGroupCount(holder.getGroupId());
             }
@@ -136,6 +239,7 @@ public void clear() {
         set.clear();
         existingGroups.clear();
         idCache.clear();
+        tagCache.clear();
     }
 
     @Override
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
old mode 100644
new mode 100755
index 627d09b..8ed13de
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
@@ -3,6 +3,7 @@
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.TagConstraint;
 
 import java.util.*;
 
@@ -13,7 +14,7 @@
     private final String id;
     private final long sessionId;
 
-    public NonPersistentPriorityQueue(long sessionId, String id) {
+    public NonPersistentPriorityQueue(long sessionId, String id, boolean inTestMode) {
         this.id = id;
         this.sessionId = sessionId;
         jobs = new NetworkAwarePriorityQueue(5, jobComparator);
@@ -107,6 +108,22 @@ public JobHolder findJobById(long id) {
         return jobs.findById(id);
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Set<JobHolder> findJobsByTags(TagConstraint constraint, boolean excludeCancelled,
+            Collection<Long> exclude, String... tags) {
+        //we ignore excludeCancelled because we remove them as soon as they are cancelled
+        return jobs.findByTags(constraint, exclude, tags);
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        // we can remove instantly.
+        remove(holder);
+    }
+
     public final Comparator<JobHolder> jobComparator = new Comparator<JobHolder>() {
         @Override
         public int compare(JobHolder holder1, JobHolder holder2) {
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
old mode 100644
new mode 100755
index 2dd8dba..0762a37
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
+++ b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
@@ -8,8 +8,9 @@
  * Helper class for {@link SqliteJobQueue} to handle database connection
  */
 public class DbOpenHelper extends SQLiteOpenHelper {
-    private static final int DB_VERSION = 3;
+    private static final int DB_VERSION = 4;
     /*package*/ static final String JOB_HOLDER_TABLE_NAME = "job_holder";
+    /*package*/ static final String JOB_TAGS_TABLE_NAME = "job_holder_tags";
     /*package*/ static final SqlHelper.Property ID_COLUMN = new SqlHelper.Property("_id", "integer", 0);
     /*package*/ static final SqlHelper.Property PRIORITY_COLUMN = new SqlHelper.Property("priority", "integer", 1);
     /*package*/ static final SqlHelper.Property GROUP_ID_COLUMN = new SqlHelper.Property("group_id", "text", 2);
@@ -19,8 +20,14 @@
     /*package*/ static final SqlHelper.Property DELAY_UNTIL_NS_COLUMN = new SqlHelper.Property("delay_until_ns", "long", 6);
     /*package*/ static final SqlHelper.Property RUNNING_SESSION_ID_COLUMN = new SqlHelper.Property("running_session_id", "long", 7);
     /*package*/ static final SqlHelper.Property REQUIRES_NETWORK_COLUMN = new SqlHelper.Property("requires_network", "integer", 8);
+    /*package*/ static final SqlHelper.Property TAGS_ID_COLUMN = new SqlHelper.Property("_id", "integer", 0);
+    /*package*/ static final SqlHelper.Property TAGS_JOB_ID_COLUMN = new SqlHelper.Property("job_id", "integer", 1, new SqlHelper.ForeignKey(JOB_HOLDER_TABLE_NAME, ID_COLUMN.columnName));
+    /*package*/ static final SqlHelper.Property TAGS_NAME_COLUMN = new SqlHelper.Property("tag_name", "text", 2);
 
     /*package*/ static final int COLUMN_COUNT = 9;
+    /*package*/ static final int TAGS_COLUMN_COUNT = 3;
+
+    static final String TAG_INDEX_NAME = "TAG_NAME_INDEX";
 
     public DbOpenHelper(Context context, String name) {
         super(context, name, null, DB_VERSION);
@@ -40,11 +47,22 @@ public void onCreate(SQLiteDatabase sqLiteDatabase) {
                 REQUIRES_NETWORK_COLUMN
         );
         sqLiteDatabase.execSQL(createQuery);
+
+        String createTagsQuery = SqlHelper.create(JOB_TAGS_TABLE_NAME,
+                TAGS_ID_COLUMN,
+                TAGS_JOB_ID_COLUMN,
+                TAGS_NAME_COLUMN);
+        sqLiteDatabase.execSQL(createTagsQuery);
+
+        sqLiteDatabase.execSQL("CREATE INDEX IF NOT EXISTS " + TAG_INDEX_NAME + " ON "
+                + JOB_TAGS_TABLE_NAME + "(" + DbOpenHelper.TAGS_NAME_COLUMN.columnName + ")");
     }
 
     @Override
     public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
         sqLiteDatabase.execSQL(SqlHelper.drop(JOB_HOLDER_TABLE_NAME));
+        sqLiteDatabase.execSQL(SqlHelper.drop(JOB_TAGS_TABLE_NAME));
+        sqLiteDatabase.execSQL("DROP INDEX IF EXISTS " + TAG_INDEX_NAME);
         onCreate(sqLiteDatabase);
     }
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
old mode 100644
new mode 100755
index 50e3ad7..5e1c059
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
+++ b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
@@ -2,6 +2,8 @@
 
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
+
+import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.log.JqLog;
 
 /**
@@ -10,8 +12,10 @@
 public class SqlHelper {
 
     /**package**/ String FIND_BY_ID_QUERY;
+    /**package**/ String FIND_BY_TAG_QUERY;
 
     private SQLiteStatement insertStatement;
+    private SQLiteStatement insertTagsStatement;
     private SQLiteStatement insertOrReplaceStatement;
     private SQLiteStatement deleteStatement;
     private SQLiteStatement onJobFetchedForRunningStatement;
@@ -24,19 +28,27 @@
     final String tableName;
     final String primaryKeyColumnName;
     final int columnCount;
+    final String tagsTableName;
+    final int tagsColumnCount;
     final long sessionId;
 
-    public SqlHelper(SQLiteDatabase db, String tableName, String primaryKeyColumnName, int columnCount, long sessionId) {
+    public SqlHelper(SQLiteDatabase db, String tableName, String primaryKeyColumnName,
+            int columnCount, String tagsTableName, int tagsColumnCount, long sessionId) {
         this.db = db;
         this.tableName = tableName;
         this.columnCount = columnCount;
         this.primaryKeyColumnName = primaryKeyColumnName;
         this.sessionId = sessionId;
+        this.tagsColumnCount = tagsColumnCount;
+        this.tagsTableName = tagsTableName;
         FIND_BY_ID_QUERY = "SELECT * FROM " + tableName + " WHERE " + DbOpenHelper.ID_COLUMN.columnName + " = ?";
+        FIND_BY_TAG_QUERY = "SELECT * FROM " + tableName + " WHERE " + DbOpenHelper.ID_COLUMN.columnName
+                + " IN ( SELECT " + DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName + " FROM " + tagsTableName
+                + " WHERE " + DbOpenHelper.TAGS_NAME_COLUMN.columnName + " = ?)";
     }
 
     public static String create(String tableName, Property primaryKey, Property... properties) {
-        StringBuilder builder = new StringBuilder("CREATE TABLE ");
+        StringBuilder builder = new StringBuilder("CREATE TABLE IF NOT EXISTS ");
         builder.append(tableName).append(" (");
         builder.append(primaryKey.columnName).append(" ");
         builder.append(primaryKey.type);
@@ -44,11 +56,49 @@ public static String create(String tableName, Property primaryKey, Property... p
         for (Property property : properties) {
             builder.append(", `").append(property.columnName).append("` ").append(property.type);
         }
+        for (Property property : properties) {
+            if (property.foreignKey != null) {
+                ForeignKey key = property.foreignKey;
+                builder.append(", FOREIGN KEY(`").append(property.columnName)
+                        .append("`) REFERENCES ").append(key.targetTable).append("(`")
+                        .append(key.targetFieldName).append("`) ON DELETE CASCADE");
+            }
+        }
         builder.append(" );");
         JqLog.d(builder.toString());
         return builder.toString();
     }
 
+    public String createFindByTagsQuery(TagConstraint constraint, int numberOfExcludeIds,
+            int numberOfTags) {
+        StringBuilder query = new StringBuilder();
+        String placeHolders = createPlaceholders(numberOfTags);
+        query.append("SELECT * FROM ").append(tableName).append(" WHERE ");
+        query.append(DbOpenHelper.ID_COLUMN.columnName).append(" IN ( SELECT ")
+                .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append(" FROM ")
+                .append(tagsTableName).append(" WHERE ")
+                .append(DbOpenHelper.TAGS_NAME_COLUMN.columnName).append(" IN (")
+                .append(placeHolders).append(")");
+        if (constraint == TagConstraint.ANY) {
+            query.append(")");
+        } else if (constraint == TagConstraint.ALL) {
+            query.append(" GROUP BY (`")
+                    .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append("`)")
+                    .append(" HAVING count(*) = ")
+                    .append(numberOfTags).append(")");
+        } else {
+            // have this in place in case we change number of constraints
+            throw new IllegalArgumentException("unknown constraint " + constraint);
+        }
+        if (numberOfExcludeIds > 0) {
+            String idPlaceHolders = createPlaceholders(numberOfExcludeIds);
+            query.append(" AND ").append(DbOpenHelper.ID_COLUMN.columnName)
+                    .append(" NOT IN(").append(idPlaceHolders).append(")");
+        }
+
+        return query.toString();
+    }
+
     public static String drop(String tableName) {
         return "DROP TABLE IF EXISTS " + tableName;
     }
@@ -69,6 +119,22 @@ public SQLiteStatement getInsertStatement() {
         return insertStatement;
     }
 
+    public SQLiteStatement getInsertTagsStatement() {
+        if (insertTagsStatement == null) {
+            StringBuilder builder = new StringBuilder("INSERT INTO ").append(DbOpenHelper.JOB_TAGS_TABLE_NAME);
+            builder.append(" VALUES (");
+            for (int i = 0; i < tagsColumnCount; i++) {
+                if (i != 0) {
+                    builder.append(",");
+                }
+                builder.append("?");
+            }
+            builder.append(")");
+            insertTagsStatement = db.compileStatement(builder.toString());
+        }
+        return insertTagsStatement;
+    }
+
     public SQLiteStatement getCountStatement() {
         if (countStatement == null) {
             countStatement = db.compileStatement("SELECT COUNT(*) FROM " + tableName + " WHERE " +
@@ -158,6 +224,22 @@ public String createSelect(String where, Integer limit, Order... orders) {
         return builder.toString();
     }
 
+    /**
+     * returns a placeholder string that contains <code>count</code> placeholders. e.g. ?,?,? for
+     * 3.
+     * @param count Number of placeholders to add.
+     */
+    private static String createPlaceholders(int count) {
+        if (count == 0) {
+            throw new IllegalArgumentException("cannot create placeholders for 0 items");
+        }
+        final StringBuilder builder = new StringBuilder("?");
+        for (int i = 1; i < count; i ++) {
+            builder.append(",?");
+        }
+        return builder.toString();
+    }
+
     public void truncate() {
         db.execSQL("DELETE FROM " + DbOpenHelper.JOB_HOLDER_TABLE_NAME);
         vacuum();
@@ -176,11 +258,27 @@ public void resetDelayTimesTo(long newDelayTime) {
         /*package*/ final String columnName;
         /*package*/ final String type;
         public final int columnIndex;
+        public final ForeignKey foreignKey;
 
         public Property(String columnName, String type, int columnIndex) {
+            this(columnName, type, columnIndex, null);
+        }
+
+        public Property(String columnName, String type, int columnIndex, ForeignKey foreignKey) {
             this.columnName = columnName;
             this.type = type;
             this.columnIndex = columnIndex;
+            this.foreignKey = foreignKey;
+        }
+    }
+
+    public static class ForeignKey {
+        final String targetTable;
+        final String targetFieldName;
+
+        public ForeignKey(String targetTable, String targetFieldName) {
+            this.targetTable = targetTable;
+            this.targetFieldName = targetFieldName;
         }
     }
 
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
old mode 100644
new mode 100755
index ac7e4a4..190e3d8
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -1,13 +1,5 @@
 package com.path.android.jobqueue.persistentQueue.sqlite;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutput;
-import java.io.ObjectOutputStream;
-import java.util.Collection;
-
 import android.content.Context;
 import android.database.Cursor;
 import android.database.SQLException;
@@ -15,12 +7,20 @@
 import android.database.sqlite.SQLiteDoneException;
 import android.database.sqlite.SQLiteStatement;
 
-import com.path.android.jobqueue.BaseJob;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.*;
 import com.path.android.jobqueue.log.JqLog;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * Persistent Job Queue that keeps its data in an sqlite database.
  */
@@ -32,17 +32,24 @@
     JobSerializer jobSerializer;
     QueryCache readyJobsQueryCache;
     QueryCache nextJobsQueryCache;
+    // we keep a list of cancelled jobs in memory not to return them in subsequent find by tag
+    // queries. Set is cleaned when item is removed
+    Set<Long> pendingCancelations = new HashSet<Long>();
 
     /**
      * @param context application context
      * @param sessionId session id should match {@link JobManager}
      * @param id uses this value to construct database name {@code "db_" + id}
+     * @param jobSerializer The serializer to use while persisting jobs to database
+     * @param inTestMode If true, creates a memory only database
      */
-    public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer jobSerializer) {
+    public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer jobSerializer,
+            boolean inTestMode) {
         this.sessionId = sessionId;
-        dbOpenHelper = new DbOpenHelper(context, "db_" + id);
+        dbOpenHelper = new DbOpenHelper(context, inTestMode ? null : ("db_" + id));
         db = dbOpenHelper.getWritableDatabase();
-        sqlHelper = new SqlHelper(db, DbOpenHelper.JOB_HOLDER_TABLE_NAME, DbOpenHelper.ID_COLUMN.columnName, DbOpenHelper.COLUMN_COUNT, sessionId);
+        sqlHelper = new SqlHelper(db, DbOpenHelper.JOB_HOLDER_TABLE_NAME, DbOpenHelper.ID_COLUMN.columnName, DbOpenHelper.COLUMN_COUNT,
+                DbOpenHelper.JOB_TAGS_TABLE_NAME, DbOpenHelper.TAGS_COLUMN_COUNT, sessionId);
         this.jobSerializer = jobSerializer;
         readyJobsQueryCache = new QueryCache();
         nextJobsQueryCache = new QueryCache();
@@ -54,7 +61,10 @@ public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer
      */
     @Override
     public long insert(JobHolder jobHolder) {
-        SQLiteStatement stmt = sqlHelper.getInsertStatement();
+        if (jobHolder.hasTags()) {
+            return insertWithTags(jobHolder);
+        }
+        final SQLiteStatement stmt = sqlHelper.getInsertStatement();
         long id = -1;
         synchronized (stmt) {
             db.beginTransaction();
@@ -73,6 +83,37 @@ public long insert(JobHolder jobHolder) {
         return id;
     }
 
+    private long insertWithTags(JobHolder jobHolder) {
+        final SQLiteStatement stmt = sqlHelper.getInsertStatement();
+        final SQLiteStatement tagsStmt = sqlHelper.getInsertTagsStatement();
+        long id = -1;
+        synchronized (stmt) {
+            db.beginTransaction();
+            try {
+                stmt.clearBindings();
+                bindValues(stmt, jobHolder);
+                id = stmt.executeInsert();
+                for (String tag : jobHolder.getTags()) {
+                    tagsStmt.clearBindings();
+                    bindTag(tagsStmt, id, tag);
+                    tagsStmt.executeInsert();
+                }
+                db.setTransactionSuccessful();
+            } catch (SQLException e) {
+                JqLog.e(e, "called insertWithTags with sql exception.");
+            } finally {
+                db.endTransaction();
+            }
+        }
+        jobHolder.setId(id);
+        return id;
+    }
+
+    private void bindTag(SQLiteStatement stmt, long jobId, String tag) {
+        stmt.bindLong(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnIndex + 1, jobId);
+        stmt.bindString(DbOpenHelper.TAGS_NAME_COLUMN.columnIndex + 1, tag);
+    }
+
     private void bindValues(SQLiteStatement stmt, JobHolder jobHolder) {
         if (jobHolder.getId() != null) {
             stmt.bindLong(DbOpenHelper.ID_COLUMN.columnIndex + 1, jobHolder.getId());
@@ -82,9 +123,9 @@ private void bindValues(SQLiteStatement stmt, JobHolder jobHolder) {
             stmt.bindString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex + 1, jobHolder.getGroupId());
         }
         stmt.bindLong(DbOpenHelper.RUN_COUNT_COLUMN.columnIndex + 1, jobHolder.getRunCount());
-        byte[] baseJob = getSerializeBaseJob(jobHolder);
-        if (baseJob != null) {
-            stmt.bindBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex + 1, baseJob);
+        byte[] job = getSerializeJob(jobHolder);
+        if (job != null) {
+            stmt.bindBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex + 1, job);
         }
         stmt.bindLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex + 1, jobHolder.getCreatedNs());
         stmt.bindLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex + 1, jobHolder.getDelayUntilNs());
@@ -133,6 +174,7 @@ public void remove(JobHolder jobHolder) {
     }
 
     private void delete(Long id) {
+        pendingCancelations.remove(id);
         SQLiteStatement stmt = sqlHelper.getDeleteStatement();
         synchronized (stmt) {
             db.beginTransaction();
@@ -196,7 +238,7 @@ public JobHolder findJobById(long id) {
                 return null;
             }
             return createJobHolderFromCursor(cursor);
-        } catch (InvalidBaseJobException e) {
+        } catch (InvalidJobException e) {
             JqLog.e(e, "invalid job on findJobById");
             return null;
         } finally {
@@ -204,6 +246,55 @@ public JobHolder findJobById(long id) {
         }
     }
 
+    @Override
+    public Set<JobHolder> findJobsByTags(TagConstraint tagConstraint, boolean excludeCancelled,
+            Collection<Long> exclude, String... tags) {
+        if (tags == null || tags.length == 0) {
+            return Collections.emptySet();
+        }
+        Set<JobHolder> jobs = new HashSet<JobHolder>();
+        int excludeCount = exclude == null ? 0 : exclude.size();
+        if (excludeCancelled) {
+            excludeCount += pendingCancelations.size();
+        }
+        final String query = sqlHelper.createFindByTagsQuery(tagConstraint,
+                excludeCount, tags.length);
+        JqLog.d(query);
+        final String[] args;
+        if (excludeCount == 0) {
+            args = tags;
+        } else {
+            args = new String[excludeCount + tags.length];
+            System.arraycopy(tags, 0, args, 0, tags.length);
+            int i = tags.length;
+            for (Long ex : exclude) {
+                args[i ++] = ex.toString();
+            }
+            if (excludeCancelled) {
+                for (Long ex : pendingCancelations) {
+                    args[i ++] = ex.toString();
+                }
+            }
+        }
+        Cursor cursor = db.rawQuery(query, args);
+        try {
+            while (cursor.moveToNext()) {
+                jobs.add(createJobHolderFromCursor(cursor));
+            }
+        } catch (InvalidJobException e) {
+            JqLog.e(e, "invalid job found by tags.");
+        } finally {
+            cursor.close();
+        }
+        return jobs;
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        pendingCancelations.add(holder.getId());
+        setSessionIdOnJob(holder);
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -228,9 +319,9 @@ public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> ex
                 return null;
             }
             JobHolder holder = createJobHolderFromCursor(cursor);
-            onJobFetchedForRunning(holder);
+            setSessionIdOnJob(holder);
             return holder;
-        } catch (InvalidBaseJobException e) {
+        } catch (InvalidJobException e) {
             //delete
             Long jobId = cursor.getLong(0);
             delete(jobId);
@@ -309,7 +400,15 @@ public void clear() {
         nextJobsQueryCache.clear();
     }
 
-    private void onJobFetchedForRunning(JobHolder jobHolder) {
+    /**
+     * This method is called when a job is pulled to run.
+     * It is properly marked so that it won't be returned from next job queries.
+     * <p/>
+     * Same mechanism is also used for cancelled jobs.
+     *
+     * @param jobHolder
+     */
+    private void setSessionIdOnJob(JobHolder jobHolder) {
         SQLiteStatement stmt = sqlHelper.getOnJobFetchedForRunningStatement();
         jobHolder.setRunCount(jobHolder.getRunCount() + 1);
         jobHolder.setRunningSessionId(sessionId);
@@ -323,17 +422,17 @@ private void onJobFetchedForRunning(JobHolder jobHolder) {
                 stmt.execute();
                 db.setTransactionSuccessful();
             } catch (SQLException e) {
-                JqLog.e(e, "called onJobFetchedForRunning with sql exception.");
+                JqLog.e(e, "called setSessionIdOnJob with sql exception.");
             } finally {
                 db.endTransaction();
             }
         }
     }
 
-    private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidBaseJobException {
-        BaseJob job = safeDeserialize(cursor.getBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex));
+    private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidJobException {
+        Job job = safeDeserialize(cursor.getBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex));
         if (job == null) {
-            throw new InvalidBaseJobException();
+            throw new InvalidJobException();
         }
         return new JobHolder(
                 cursor.getLong(DbOpenHelper.ID_COLUMN.columnIndex),
@@ -348,7 +447,7 @@ private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidBaseJob
 
     }
 
-    private BaseJob safeDeserialize(byte[] bytes) {
+    private Job safeDeserialize(byte[] bytes) {
         try {
             return jobSerializer.deserialize(bytes);
         } catch (Throwable t) {
@@ -357,8 +456,8 @@ private BaseJob safeDeserialize(byte[] bytes) {
         return null;
     }
 
-    private byte[] getSerializeBaseJob(JobHolder jobHolder) {
-        return safeSerialize(jobHolder.getBaseJob());
+    private byte[] getSerializeJob(JobHolder jobHolder) {
+        return safeSerialize(jobHolder.getJob());
     }
 
     private byte[] safeSerialize(Object object) {
@@ -370,7 +469,9 @@ private BaseJob safeDeserialize(byte[] bytes) {
         return null;
     }
 
-    private static class InvalidBaseJobException extends Exception {
+    private static class InvalidJobException extends Exception {
+
+        private static final long serialVersionUID = -5825656163831895628L;
 
     }
 
@@ -397,7 +498,7 @@ private BaseJob safeDeserialize(byte[] bytes) {
         }
 
         @Override
-        public <T extends BaseJob> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
+        public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
             if (bytes == null || bytes.length == 0) {
                 return null;
             }
@@ -415,6 +516,6 @@ private BaseJob safeDeserialize(byte[] bytes) {
 
     public static interface JobSerializer {
         public byte[] serialize(Object object) throws IOException;
-        public <T extends BaseJob> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException;
+        public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException;
     }
 }
