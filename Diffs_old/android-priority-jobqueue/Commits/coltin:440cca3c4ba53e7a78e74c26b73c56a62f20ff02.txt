diff --git a/.travis.yml b/.travis.yml
index 3734ca6..fd95c5c 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -7,7 +7,7 @@ android:
     - tools-24.4.1
     - build-tools-23.0.2
     - android-23
-script: cd jobqueue && ./gradlew --stacktrace clean check --info
+script: cd jobqueue && ./gradlew --stacktrace clean check
 addons:
   artifacts: true
   s3_region: "us-west-1"
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
index d6d0c27..95ba3a0 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
@@ -95,28 +95,33 @@ public void testJobStatus() throws InterruptedException {
             //after all jobs finish, state should be unknown
             assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.UNKNOWN));
         }
-        final long SHORT_SLEEP = 1000;
+        final long SHORT_SLEEP = 2000;
         Job[] delayedJobs = new Job[]{
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
         long[] delayedIds = new long[delayedJobs.length];
+        long start = System.currentTimeMillis();
         for(int i = 0; i < delayedJobs.length; i ++) {
             delayedIds[i] = jobManager.addJob(delayedJobs[i]);
         }
-
+        assertThat("test sanity.", System.currentTimeMillis() - start < SHORT_SLEEP, is(true));
         for(int i = 0; i < delayedJobs.length; i ++) {
-            assertThat("delayed job(" + i + ") should receive not ready status", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+            assertThat("delayed job(" + i + ") should receive not ready status. startMs:" + start
+                            + ", now:" + System.currentTimeMillis() + ", limit:" + SHORT_SLEEP,
+                    jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
         }
         jobManager.stop();
         //sleep
         Thread.sleep(SHORT_SLEEP * 2);
         for(int i = 0; i < delayedJobs.length; i ++) {
             if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
-                assertThat("when enough time passes, delayed jobs should move to ready state", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_READY));
+                assertThat("when enough time passes, delayed jobs should move to ready state",
+                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()),is(JobStatus.WAITING_READY));
             } else {
-                assertThat("delayed job should receive not ready status until their time comes", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+                assertThat("delayed job should receive not ready status until their time comes",
+                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
             }
         }
     }
