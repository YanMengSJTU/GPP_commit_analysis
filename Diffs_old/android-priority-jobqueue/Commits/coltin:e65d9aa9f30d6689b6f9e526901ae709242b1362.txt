diff --git a/README.md b/README.md
index a658caa..aa1bfa8 100644
--- a/README.md
+++ b/README.md
@@ -65,7 +65,8 @@ public class PostTweetJob extends Job {
             int maxRunCount) {
         // An error occurred in onRun.
         // Return value determines whether this job should retry or cancel. You can further
-        // specifcy a backoff strategy or change the job's priority.
+        // specifcy a backoff strategy or change the job's priority. You can also apply the
+        // delay to the whole group to preserve jobs' running order.
         return RetryConstraint.createExponentialBackoff(runCount, 1000);
     }
     @Override
@@ -137,7 +138,7 @@ Maven:
 <dependency>
     <groupId>com.birbit</groupId>
     <artifactId>android-priority-jobqueue</artifactId>
-    <version>1.3.4</version>
+    <version>1.3.5</version>
 </dependency>
 ```
 
@@ -150,6 +151,9 @@ We highly recommend checking how you can configure job manager and individual jo
 * [Review sample configuration][7]
 
 ### Version History
+  - 1.3.5 (Nov 7, 2015)
+   - Default NetworkUtil is now Doze aware. (thanks @coltin)
+   - RetryConstraint Delay can be applied to the group to preserve jobs' execution order. (#41)
   - 1.3.4 (Sept 12, 2015)
    - Fixed a potential ANR that was caused by sync on main thread. Issue #40
   - 1.3.3 (July 12, 2015)
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 382aae8..2d7612b 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -3,7 +3,11 @@ import java.util.regex.Pattern
 apply plugin: 'com.android.library'
 
 Properties releaseConfig = new Properties()
-releaseConfig.load(new FileInputStream("${projectDir}/releaseConfig.properties"))
+File releaseFile = new File("${projectDir}/releaseConfig.properties")
+if (releaseFile.exists()) {
+    releaseConfig.load(new FileInputStream(releaseFile))
+}
+
 ext.releaseConfig = releaseConfig
 
 task wrapper(type: Wrapper) {
@@ -20,7 +24,8 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.1.3'
+        classpath 'com.android.tools.build:gradle:1.3.1'
+
     }
 }
 
@@ -45,7 +50,7 @@ dependencies {
 
 android {
     compileSdkVersion 23
-    buildToolsVersion "23.0.1"
+    buildToolsVersion "23.0.2"
     buildTypes {
         debug {
             testCoverageEnabled = true
@@ -54,7 +59,7 @@ android {
 
     defaultConfig {
         minSdkVersion 7
-        targetSdkVersion 21
+        targetSdkVersion 23
     }
 }
 
@@ -170,7 +175,7 @@ afterEvaluate { project ->
     }
 }
 
-task jacocoTestReport(type:JacocoReport, dependsOn: "testDebug") {
+task jacocoTestReport(type:JacocoReport, dependsOn: "testDebugUnitTest") {
     group = "Reporting"
 
     description = "Generate Jacoco coverage reports"
diff --git a/jobqueue/gradle/wrapper/gradle-wrapper.properties b/jobqueue/gradle/wrapper/gradle-wrapper.properties
index 515adf0..3dc818d 100644
--- a/jobqueue/gradle/wrapper/gradle-wrapper.properties
+++ b/jobqueue/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Nov 03 10:23:29 EST 2015
+#Sat Nov 07 16:10:08 PST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/jobqueue/src/main/AndroidManifest.xml b/jobqueue/src/main/AndroidManifest.xml
index 25d0c20..7249fc1 100644
--- a/jobqueue/src/main/AndroidManifest.xml
+++ b/jobqueue/src/main/AndroidManifest.xml
@@ -2,7 +2,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.path.android.jobqueue"
           android:versionCode="2"
-          android:versionName="1.3.4">
+          android:versionName="1.3.5">
     <application>
     </application>
 </manifest>
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/CopyOnWriteGroupSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/CopyOnWriteGroupSet.java
deleted file mode 100644
index 9ac0e97..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/CopyOnWriteGroupSet.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.path.android.jobqueue;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.TreeSet;
-
-/**
- * a util class that holds running jobs sorted by name and uniq.
- * it behaves like CopyOnWriteLists
- */
-public class CopyOnWriteGroupSet {
-    private ArrayList<String> publicClone;
-    private final TreeSet<String> internalSet;
-
-    public CopyOnWriteGroupSet() {
-        internalSet = new TreeSet<String>();
-    }
-
-    public synchronized Collection<String> getSafe() {
-        if(publicClone == null) {
-            publicClone = new ArrayList<String>(internalSet);
-        }
-        return publicClone;
-    }
-
-    public synchronized void add(String group) {
-        if(internalSet.add(group)) {
-            publicClone = null;//invalidate
-        }
-    }
-
-    public synchronized void remove(String group) {
-        if(internalSet.remove(group)) {
-            publicClone = null;
-        }
-    }
-
-    public synchronized void clear() {
-        internalSet.clear();
-        publicClone = null;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index 71ecab7..2169e50 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -10,6 +10,7 @@
 import com.path.android.jobqueue.network.NetworkEventProvider;
 import com.path.android.jobqueue.network.NetworkUtil;
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
+import com.path.android.jobqueue.persistentQueue.sqlite.SqlHelper;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
 
 import java.util.ArrayList;
@@ -41,7 +42,7 @@
     private final DependencyInjector dependencyInjector;
     private final JobQueue persistentJobQueue;
     private final JobQueue nonPersistentJobQueue;
-    private final CopyOnWriteGroupSet runningJobGroups;
+    private final RunningJobSet runningJobGroups;
     private final JobConsumerExecutor jobConsumerExecutor;
     private final Object newJobListeners = new Object();
     private final ConcurrentHashMap<Long, CountDownLatch> persistentOnAddedLocks;
@@ -82,7 +83,7 @@ public JobManager(Context context, Configuration config) {
         }
         appContext = context.getApplicationContext();
         running = true;
-        runningJobGroups = new CopyOnWriteGroupSet();
+        runningJobGroups = new RunningJobSet();
         sessionId = System.nanoTime();
         this.persistentJobQueue = config.getQueueFactory()
                 .createPersistentQueue(context, sessionId, config.getId(), config.isInTestMode());
@@ -394,11 +395,12 @@ public void addJobInBackground(final Job job, /*nullable*/ final AsyncAddCallbac
             public void run() {
                 try {
                     long id = addJob(job);
-                    if(callback != null) {
+                    if (callback != null) {
                         callback.onAdded(id);
                     }
                 } catch (Throwable t) {
-                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", job.getClass().getSimpleName());
+                    JqLog.e(t, "addJobInBackground received an exception. job class: %s",
+                            job.getClass().getSimpleName());
                 }
             }
         });
@@ -446,9 +448,14 @@ private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
         }
         //this method is called when there are jobs but job consumer was not given any
         //this may happen in a race condition or when the latest job is a delayed job
-        Long nextRunNs;
+        Long nextRunNs = runningJobGroups.getNextDelayForGroups();
+        Collection<String> runningGroups = runningJobGroups.getSafe();
+        Long nonPersistedJobRunNs;
         synchronized (nonPersistentJobQueue) {
-            nextRunNs = nonPersistentJobQueue.getNextJobDelayUntilNs(hasNetwork);
+            nonPersistedJobRunNs = nonPersistentJobQueue.getNextJobDelayUntilNs(hasNetwork, runningGroups);
+        }
+        if (nextRunNs == null || (nonPersistedJobRunNs != null && nonPersistedJobRunNs < nextRunNs)) {
+            nextRunNs = nonPersistedJobRunNs;
         }
         if(nextRunNs != null && nextRunNs <= System.nanoTime()) {
             notifyJobConsumer();
@@ -456,7 +463,7 @@ private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
         }
         Long persistedJobRunNs;
         synchronized (persistentJobQueue) {
-            persistedJobRunNs = persistentJobQueue.getNextJobDelayUntilNs(hasNetwork);
+            persistedJobRunNs = persistentJobQueue.getNextJobDelayUntilNs(hasNetwork, runningGroups);
         }
         if(persistedJobRunNs != null) {
             if(nextRunNs == null) {
@@ -504,17 +511,23 @@ private JobHolder getNextJob() {
         boolean haveNetwork = hasNetwork();
         JobHolder jobHolder;
         boolean persistent = false;
+        JqLog.d("looking for next job");
         synchronized (getNextJobLock) {
             final Collection<String> runningJobGroups = this.runningJobGroups.getSafe();
+            if (JqLog.isDebugEnabled()) {
+                JqLog.d("running groups %s", SqlHelper.joinStrings(",", runningJobGroups));
+            }
             synchronized (nonPersistentJobQueue) {
                 jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
             }
+            JqLog.d("non persistent result %s", jobHolder);
             if (jobHolder == null) {
                 //go to disk, there aren't any non-persistent jobs
                 synchronized (persistentJobQueue) {
                     jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
                     persistent = true;
                 }
+                JqLog.d("persistent result %s", jobHolder);
             }
             if(jobHolder == null) {
                 return null;
@@ -664,7 +677,12 @@ public void insertOrReplace(JobHolder jobHolder) {
             }
             long delay = -1;
             if (retryConstraint.getNewDelayInMs() != null) {
-                delay = retryConstraint.getNewDelayInMs();
+                if (retryConstraint.willApplyNewDelayToGroup() && jobHolder.getGroupId() != null) {
+                    runningJobGroups.addGroupUntil(jobHolder.getGroupId(),
+                            System.nanoTime() + retryConstraint.getNewDelayInMs() * NS_PER_MS);
+                } else {
+                    delay = retryConstraint.getNewDelayInMs();
+                }
             }
             jobHolder.setDelayUntilNs(
                     delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
index 7542208..e40e238 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
@@ -56,7 +56,6 @@
      *
      * @param hasNetwork if true, should return any job, if false, should return jobs that do NOT require network
      * @param excludeGroups if provided, jobs from these groups will NOT be returned
-     * @return
      */
     JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups);
 
@@ -64,9 +63,9 @@
      * returns when the next job should run (in nanoseconds), should return null if there are no jobs to run.
      * @param hasNetwork if true, should return nanoseconds for any job, if false, should return nanoseconds for next
      *                   job's delay until.
-     * @return
+     *  @param excludeGroups if provided, jobs from these groups will NOT be considered
      */
-    Long getNextJobDelayUntilNs(boolean hasNetwork);
+    Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups);
 
     /**
      * clear all jobs in the queue. should probably be called when user logs out.
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
index a725340..f57a9c2 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
@@ -1,5 +1,9 @@
 package com.path.android.jobqueue;
 
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  * Created by {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
  * <p>
@@ -17,6 +21,7 @@
     private boolean retry;
     private Long newDelayInMs;
     private Integer newPriority;
+    private boolean applyNewDelayToGroup = false;
 
     public RetryConstraint(boolean retry) {
         this.retry = retry;
@@ -58,6 +63,16 @@ public void setNewPriority(Integer newPriority) {
         this.newPriority = newPriority;
     }
 
+    /**
+     * Creates a response that will exponentially back off the job.
+     *
+     * @param runCount The run count that was passed to
+     * {@link Job#shouldReRunOnThrowable(Throwable, int, int)}
+     * @param initialBackOffInMs The initial back off time. This will be the back off for the inital
+     *                           run and then it will exponentially grow from this number.
+     *
+     * @return A RetryContraint that will report exponential back off.
+     */
     public static RetryConstraint createExponentialBackoff(int runCount, long initialBackOffInMs) {
         RetryConstraint constraint = new RetryConstraint(true);
         constraint.setNewDelayInMs(initialBackOffInMs *
@@ -65,6 +80,35 @@ public static RetryConstraint createExponentialBackoff(int runCount, long initia
         return constraint;
     }
 
+    /**
+     * Sets whether the delay in the constraint should be applied to the whole group.
+     * <p>
+     * Note that the delay will effect any Job that is added after this call until the delay ends.
+     * This will ensure that the Job execution order will be preserved.
+     * <p>
+     * If the job does not have a group id ({@link Job#getRunGroupId()}, calling this method has no
+     * effect.
+     * <p>
+     * The group delay is global so even after you cancel the jobs, it will still affect the group
+     * until delay times out.
+     *
+     * @param applyDelayToGroup Sets whether the delay should be applied to all jobs in this group.
+     *
+     */
+    public void setApplyNewDelayToGroup(boolean applyDelayToGroup) {
+        this.applyNewDelayToGroup = applyDelayToGroup;
+    }
+
+    /**
+     * Returns whether the delay in this retry constraint will be applied to all jobs in this group.
+     *
+     * @return Whether the delay will be applied to all jobs in this group or not. Defaults to
+     * false.
+     */
+    public boolean willApplyNewDelayToGroup() {
+        return applyNewDelayToGroup;
+    }
+
     private static class ImmutableRetryConstraint extends RetryConstraint {
         private static final String MESSAGE = "This object is immutable. Create a new one using the"
                 + " constructor.";
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java
new file mode 100644
index 0000000..b47662d
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java
@@ -0,0 +1,100 @@
+package com.path.android.jobqueue;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TreeSet;
+
+/**
+ * a util class that holds running jobs sorted by name and unique.
+ * it behaves like CopyOnWriteLists
+ */
+public class RunningJobSet {
+    private ArrayList<String> publicClone;
+    private final TreeSet<String> internalSet;
+    private final Map<String, Long> groupDelays;
+    private long groupDelayTimeout;
+
+    public RunningJobSet() {
+        internalSet = new TreeSet<>();
+        groupDelays = new HashMap<>();
+        groupDelayTimeout = Long.MAX_VALUE;
+    }
+
+    public synchronized void addGroupUntil(String group, long until) {
+        Long current = groupDelays.get(group);
+        if (current != null) {
+             if (current > until) {
+                 return; // nothing to change
+             }
+        }
+        groupDelays.put(group, until);
+        groupDelayTimeout = calculateNextDelayForGroups();
+        publicClone = null;
+    }
+
+    public synchronized Collection<String> getSafe() {
+        final long now = now();
+        if(publicClone == null || now > groupDelayTimeout) {
+            if (groupDelays.isEmpty()) {
+                publicClone = new ArrayList<>(internalSet);
+                groupDelayTimeout = Long.MAX_VALUE;
+            } else {
+                TreeSet<String> tmpClone = new TreeSet<>(internalSet);
+                Iterator<Map.Entry<String, Long>> itr = groupDelays.entrySet().iterator();
+                while(itr.hasNext()) {
+                    Map.Entry<String, Long> entry = itr.next();
+                    if (entry.getValue() > now) {
+                        if (!tmpClone.contains(entry.getKey())) {
+                            tmpClone.add(entry.getKey());
+                        }
+                    } else {
+                        itr.remove();
+                    }
+                }
+                publicClone = new ArrayList<>(tmpClone);
+                groupDelayTimeout = calculateNextDelayForGroups();
+            }
+        }
+        return publicClone;
+    }
+    public Long getNextDelayForGroups() {
+        if (groupDelayTimeout == Long.MAX_VALUE) {
+            return null;
+        }
+        return groupDelayTimeout;
+    }
+    private long calculateNextDelayForGroups() {
+        long result = Long.MAX_VALUE;
+        for (Long value : groupDelays.values()) {
+            if (value < result) {
+                result = value;
+            }
+        }
+        return result;
+    }
+
+    public synchronized void add(String group) {
+        if(internalSet.add(group)) {
+            publicClone = null;//invalidate
+        }
+    }
+
+    public synchronized void remove(String group) {
+        if(internalSet.remove(group)) {
+            publicClone = null;
+        }
+    }
+
+    public synchronized void clear() {
+        internalSet.clear();
+        groupDelays.clear();
+        publicClone = null;
+    }
+
+    protected long now() {
+        return System.nanoTime();
+    }
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
index 4867fb4..fcc7057 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
@@ -5,6 +5,8 @@
 import com.path.android.jobqueue.TagConstraint;
 
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
 import java.util.Set;
 
 /**
@@ -80,11 +82,13 @@ public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> ex
     }
 
     @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork) {
+    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
         if(cache.delayUntil == null) {
-            cache.delayUntil = new Cache.DelayUntil(hasNetwork, delegate.getNextJobDelayUntilNs(hasNetwork));
-        } else if(!cache.delayUntil.isValid(hasNetwork)) {
-            cache.delayUntil.set(hasNetwork, delegate.getNextJobDelayUntilNs(hasNetwork));
+            cache.delayUntil = new Cache.DelayUntil(hasNetwork,
+                    delegate.getNextJobDelayUntilNs(hasNetwork, excludeGroups), excludeGroups);
+        } else if(!cache.delayUntil.isValid(hasNetwork, excludeGroups)) {
+            cache.delayUntil.set(hasNetwork,
+                    delegate.getNextJobDelayUntilNs(hasNetwork, excludeGroups), excludeGroups);
         }
         return cache.delayUntil.value;
     }
@@ -124,19 +128,42 @@ public void invalidateAll() {
             //can be null, is OK
             Long value;
             boolean hasNetwork;
+            Collection<String> excludeGroups;
 
-            private DelayUntil(boolean hasNetwork, Long value) {
+            private DelayUntil(boolean hasNetwork, Long value, Collection<String> excludeGroups) {
                 this.value = value;
                 this.hasNetwork = hasNetwork;
+                this.excludeGroups = excludeGroups;
             }
 
-            private boolean isValid(boolean hasNetwork) {
-                return this.hasNetwork == hasNetwork;
+            private boolean isValid(boolean hasNetwork, Collection<String> excludeGroups) {
+                return this.hasNetwork == hasNetwork && validateExcludes(excludeGroups);
             }
 
-            public void set(boolean hasNetwork, Long value) {
+            private boolean validateExcludes(Collection<String> excludeGroups) {
+                if (this.excludeGroups == excludeGroups) {
+                    return true;
+                }
+                if (this.excludeGroups == null || excludeGroups == null) {
+                    return false;
+                }
+                if (this.excludeGroups.size() != excludeGroups.size()) {
+                    return false;
+                }
+                Iterator<String> itr1 = this.excludeGroups.iterator();
+                Iterator<String> itr2 = excludeGroups.iterator();
+                while (itr1.hasNext()) {
+                    if (!itr1.next().equals(itr2.next())) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+
+            public void set(boolean hasNetwork, Long value, Collection<String> excludeGroups) {
                 this.value = value;
                 this.hasNetwork = hasNetwork;
+                this.excludeGroups = excludeGroups;
             }
         }
     }
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
index 8ed13de..c0a6e52 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
@@ -87,8 +87,8 @@ public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> ex
      * {@inheritDoc}
      */
     @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork) {
-        JobHolder next = jobs.peek(hasNetwork, null);
+    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
+        JobHolder next = jobs.peek(hasNetwork, excludeGroups);
         return next == null ? null : next.getDelayUntilNs();
     }
 
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
index 5e1c059..3aee2f8 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
@@ -6,6 +6,8 @@
 import com.path.android.jobqueue.TagConstraint;
 import com.path.android.jobqueue.log.JqLog;
 
+import java.util.Collection;
+
 /**
  * Helper class for {@link SqliteJobQueue} to generate sql queries and statements.
  */
@@ -202,6 +204,24 @@ public SQLiteStatement getNextJobDelayedUntilWithoutNetworkStatement() {
         return nextJobDelayedUntilWithoutNetworkStatement;
     }
 
+    public String createNextJobDelayUntilQuery(boolean hasNetwork, Collection<String> excludeGroups) {
+        String sql = "SELECT " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName
+                + " FROM " + tableName + " WHERE "
+                + DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName + " != " + sessionId;
+        if (!hasNetwork) {
+            sql += " AND " + DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnName + " != 1";
+        }
+        if(excludeGroups != null && excludeGroups.size() > 0) {
+            sql +=  " AND (" + DbOpenHelper.GROUP_ID_COLUMN.columnName + " IS NULL OR " +
+                    DbOpenHelper.GROUP_ID_COLUMN.columnName +
+                    " NOT IN('" + joinStrings("','", excludeGroups) + "'))";
+        }
+        sql += " ORDER BY " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + " ASC"
+                + " LIMIT 1";
+        return sql;
+    }
+
+
     public String createSelect(String where, Integer limit, Order... orders) {
         StringBuilder builder = new StringBuilder("SELECT * FROM ");
         builder.append(tableName);
@@ -250,10 +270,23 @@ public void vacuum() {
     }
 
     public void resetDelayTimesTo(long newDelayTime) {
-        db.execSQL("UPDATE " + DbOpenHelper.JOB_HOLDER_TABLE_NAME + " SET " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + "=?"
+        db.execSQL("UPDATE " + DbOpenHelper.JOB_HOLDER_TABLE_NAME + " SET "
+                + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + "=?"
             , new Object[]{newDelayTime});
     }
 
+    // TODO we are using this to merge groups but not escaping :/
+    public static String joinStrings(String glue, Collection<String> strings) {
+        StringBuilder builder = new StringBuilder();
+        for(String str : strings) {
+            if(builder.length() != 0) {
+                builder.append(glue);
+            }
+            builder.append(str);
+        }
+        return builder.toString();
+    }
+
     public static class Property {
         /*package*/ final String columnName;
         /*package*/ final String type;
@@ -295,6 +328,5 @@ public Order(Property property, Type type) {
             ASC,
             DESC
         }
-
     }
 }
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
index 9c6c1ce..6595a55 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -30,6 +30,7 @@
     JobSerializer jobSerializer;
     QueryCache readyJobsQueryCache;
     QueryCache nextJobsQueryCache;
+    QueryCache nextJobDelayUntilQueryCache;
     // we keep a list of cancelled jobs in memory not to return them in subsequent find by tag
     // queries. Set is cleaned when item is removed
     Set<Long> pendingCancelations = new HashSet<Long>();
@@ -51,6 +52,7 @@ public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer
         this.jobSerializer = jobSerializer;
         readyJobsQueryCache = new QueryCache();
         nextJobsQueryCache = new QueryCache();
+        nextJobDelayUntilQueryCache = new QueryCache();
         sqlHelper.resetDelayTimesTo(JobManager.NOT_DELAYED_JOB_DELAY);
     }
 
@@ -118,7 +120,8 @@ private void bindValues(SQLiteStatement stmt, JobHolder jobHolder) {
         stmt.bindLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex + 1, jobHolder.getCreatedNs());
         stmt.bindLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex + 1, jobHolder.getDelayUntilNs());
         stmt.bindLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex + 1, jobHolder.getRunningSessionId());
-        stmt.bindLong(DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnIndex + 1, jobHolder.requiresNetwork() ? 1L : 0L);
+        stmt.bindLong(DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnIndex + 1,
+                jobHolder.requiresNetwork() ? 1L : 0L);
     }
 
     /**
@@ -317,7 +320,8 @@ private String createReadyJobWhereSql(boolean hasNetwork, Collection<String> exc
         String groupConstraint = null;
         if(excludeGroups != null && excludeGroups.size() > 0) {
             groupConstraint = DbOpenHelper.GROUP_ID_COLUMN.columnName + " IS NULL OR " +
-                    DbOpenHelper.GROUP_ID_COLUMN.columnName + " NOT IN('" + joinStrings("','", excludeGroups) + "')";
+                    DbOpenHelper.GROUP_ID_COLUMN.columnName + " NOT IN('" +
+                    SqlHelper.joinStrings("','", excludeGroups) + "')";
         }
         if(groupByRunningGroup) {
             where += " GROUP BY " + DbOpenHelper.GROUP_ID_COLUMN.columnName;
@@ -330,31 +334,38 @@ private String createReadyJobWhereSql(boolean hasNetwork, Collection<String> exc
         return where;
     }
 
-    private static String joinStrings(String glue, Collection<String> strings) {
-        StringBuilder builder = new StringBuilder();
-        for(String str : strings) {
-            if(builder.length() != 0) {
-                builder.append(glue);
-            }
-            builder.append(str);
-        }
-        return builder.toString();
-    }
-
     /**
      * {@inheritDoc}
      */
     @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork) {
-        SQLiteStatement stmt =
-                hasNetwork ? sqlHelper.getNextJobDelayedUntilWithNetworkStatement()
-                : sqlHelper.getNextJobDelayedUntilWithoutNetworkStatement();
-        synchronized (stmt) {
+    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
+        boolean hasExcludes = excludeGroups != null && !excludeGroups.isEmpty();
+        if (!hasExcludes) {
+            SQLiteStatement stmt =
+                    hasNetwork ? sqlHelper.getNextJobDelayedUntilWithNetworkStatement()
+                            : sqlHelper.getNextJobDelayedUntilWithoutNetworkStatement();
+            synchronized (stmt) {
+                try {
+                    stmt.clearBindings();
+                    return stmt.simpleQueryForLong();
+                } catch (SQLiteDoneException e) {
+                    return null;
+                }
+            }
+        } else {
+            String sql = nextJobDelayUntilQueryCache.get(hasNetwork, excludeGroups);
+            if (sql == null) {
+                sql = sqlHelper.createNextJobDelayUntilQuery(hasNetwork, excludeGroups);
+                nextJobDelayUntilQueryCache.set(sql, hasNetwork, excludeGroups);
+            }
+            Cursor cursor = db.rawQuery(sql, new String[0]);
             try {
-                stmt.clearBindings();
-                return stmt.simpleQueryForLong();
-            } catch (SQLiteDoneException e){
-                return null;
+                if(!cursor.moveToNext()) {
+                    return null;
+                }
+                return cursor.getLong(0);
+            } finally {
+                cursor.close();
             }
         }
     }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
index 08d0dbf..87f2a42 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
@@ -4,6 +4,8 @@
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.RetryConstraint;
+import com.path.android.jobqueue.log.JqLog;
+import com.path.android.jobqueue.test.jobs.DummyJob;
 
 import org.hamcrest.CoreMatchers;
 import org.junit.Before;
@@ -12,12 +14,18 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
+
+import android.util.Pair;
+
 import static org.hamcrest.MatcherAssert.*;
 import static org.hamcrest.CoreMatchers.*;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -36,8 +44,12 @@
 
     static Callback onRunCallback;
 
+    static Callback onCancelCallback;
+
     static CountDownLatch cancelLatch;
 
+    static CountDownLatch dummyJobRunLatch;
+
     @Before
     public void clear() {
         retryProvider = null;
@@ -45,7 +57,9 @@ public void clear() {
         runCount = 0;
         onRunLatch = null;
         onRunCallback = null;
+        onCancelCallback = null;
         cancelLatch = new CountDownLatch(1);
+        dummyJobRunLatch = new CountDownLatch(1);
     }
 
     @Test
@@ -61,7 +75,7 @@ public void testExponential() {
                 is(5L));
         assertThat("exp 2",RetryConstraint.createExponentialBackoff(2, 5).getNewDelayInMs(),
                 is(10L));
-        assertThat("exp 3",RetryConstraint.createExponentialBackoff(3, 5).getNewDelayInMs(),
+        assertThat("exp 3", RetryConstraint.createExponentialBackoff(3, 5).getNewDelayInMs(),
                 is(20L));
     }
 
@@ -99,6 +113,97 @@ public RetryConstraint build(Job job, Throwable throwable, int runCount,
         assertThat("", runCount, is(10));
     }
 
+    @Test
+    public void testChangeDelayOfTheGroup() throws InterruptedException {
+        testChangeDelayOfTheGroup(null);
+    }
+
+    @Test
+    public void testChangeDelayOfTheGroupPersistent() throws InterruptedException {
+        testChangeDelayOfTheGroup(true);
+    }
+
+    @Test
+    public void testChangeDelayOfTheGroupNonPersistent() throws InterruptedException {
+        testChangeDelayOfTheGroup(false);
+    }
+
+    public void testChangeDelayOfTheGroup(Boolean persistent) throws InterruptedException {
+        canRun = true;
+        enableDebug();
+        RetryJob job1 = new RetryJob(new Params(2).setPersistent(Boolean.TRUE.equals(persistent)).groupBy("g1"));
+        job1.identifier = "job 1 id";
+        RetryJob job2 = new RetryJob(new Params(2).setPersistent(!Boolean.FALSE.equals(persistent)).groupBy("g1"));
+        job2.identifier = "job 2 id";
+        job1.retryLimit = 2;
+        job2.retryLimit = 2;
+        final String job1Id = job1.identifier;
+        final String job2Id = job2.identifier;
+        final PersistableDummyJob postTestJob = new PersistableDummyJob(new Params(1)
+        .groupBy("g1").setPersistent(Boolean.TRUE.equals(persistent)));
+        retryProvider = new RetryProvider() {
+            @Override
+            public RetryConstraint build(Job job, Throwable throwable, int runCount,
+                    int maxRunCount) {
+                RetryConstraint constraint = new RetryConstraint(true);
+                constraint.setNewDelayInMs(2000L);
+                constraint.setApplyNewDelayToGroup(true);
+                return constraint;
+            }
+        };
+        final List<Pair<String, Long>> runTimes = new ArrayList<>();
+        final Map<String, Long> cancelTimes = new HashMap<>();
+        onRunCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                RetryJob retryJob = (RetryJob) job;
+                runTimes.add(new Pair<>(retryJob.identifier, System.nanoTime()));
+            }
+        };
+        onCancelCallback = new Callback() {
+            @Override
+            public void on(Job job) {
+                JqLog.d("on cancel of job %s", job);
+                RetryJob retryJob = (RetryJob) job;
+                assertThat("Job should cancel only once",
+                        cancelTimes.containsKey(retryJob.identifier), is(false));
+                cancelTimes.put(retryJob.identifier, System.nanoTime());
+                if (!job.isPersistent() || postTestJob.isPersistent()) {
+                    assertThat("the 3rd job should not run until others cancel fully",
+                            dummyJobRunLatch.getCount(), is(1L));
+                }
+            }
+        };
+        cancelLatch = new CountDownLatch(2);
+
+        JobManager jobManager = createJobManager();
+        jobManager.addJob(job1);
+        jobManager.addJob(job2);
+        jobManager.addJob(postTestJob);
+
+        assertThat("jobs should be canceled", cancelLatch.await(7, TimeUnit.SECONDS), is(true));
+        assertThat("should run 4 times", runTimes.size(), is(4));
+        for (int i = 0; i < 4; i ++) {
+            assertThat("first two runs should be job1, last two jobs should be job 2. checking " + i,
+                    runTimes.get(i).first, is(i < 2 ? job1Id : job2Id));
+        }
+        long timeInBetween = TimeUnit.NANOSECONDS.toSeconds(
+                runTimes.get(1).second - runTimes.get(0).second);
+        assertThat("time between two runs should be at least 2 seconds. job 1 and 2" + ":"
+                + timeInBetween, 2 <= timeInBetween, is(true));
+        timeInBetween = TimeUnit.NANOSECONDS.toSeconds(
+                runTimes.get(3).second - runTimes.get(2).second);
+        assertThat("time between two runs should be at least 2 seconds. job 3 and 4" + ":"
+                + timeInBetween, 2 <= timeInBetween, is(true));
+        assertThat("the other job should run after others are cancelled",
+                dummyJobRunLatch.await(1, TimeUnit.SECONDS), is(true));
+        // another job should just run
+        dummyJobRunLatch = new CountDownLatch(1);
+        jobManager.addJob(new PersistableDummyJob(new Params(1).groupBy("g1")));
+        assertThat("a newly added job should just run quickly", dummyJobRunLatch.await(500,
+                TimeUnit.MILLISECONDS), is(true));
+    }
+
     @Test
     public void testChangeDelayPersistent() throws InterruptedException {
         testChangeDelay(true);
@@ -331,6 +436,9 @@ protected int getRetryLimit() {
 
         @Override
         protected void onCancel() {
+            if (onCancelCallback != null) {
+                onCancelCallback.on(this);
+            }
             cancelLatch.countDown();
         }
 
@@ -349,6 +457,19 @@ public int getCurrentRunCount() {
         }
     }
 
+    private static class PersistableDummyJob extends DummyJob {
+        public PersistableDummyJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            dummyJobRunLatch.countDown();
+        }
+    }
+
+
     interface RetryProvider {
         RetryConstraint build(Job job, Throwable throwable, int runCount,
                 int maxRunCount);
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
index a0df8ff..c9c8343 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
@@ -105,7 +105,8 @@ public void testDelayUntilWithPriority() throws Exception {
         jobQueue.insert(lowPriorityHolder);
         jobQueue.insert(highPriorityHolder);
         assertThat("when asked, if lower priority job has less delay until, we should return it",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(lowPriorityHolder.getDelayUntilNs()));
+                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(
+                lowPriorityHolder.getDelayUntilNs()));
 
     }
 
@@ -176,7 +177,7 @@ public void testDueDelayUntilWithPriority() throws Exception {
         long highestPriorityDelayedJobId = jobQueue.insert(highestPriorityDelayedJob);
         assertThat("when asked, if job's due has passed, highest priority jobs's delay until should be " +
                 "returned",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(highPriorityHolder.getDelayUntilNs()));
+                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(highPriorityHolder.getDelayUntilNs()));
         //make sure soon job is valid now
         Thread.sleep(soonJobDelay);
 
@@ -196,16 +197,59 @@ public void testDelayUntil() throws Exception {
         jobQueue.insert(noNetworkJobHolder);
 
         assertThat("if there is no network, delay until should be provided for no network job",
-            jobQueue.getNextJobDelayUntilNs(false), equalTo(noNetworkJobHolder.getDelayUntilNs()));
+            jobQueue.getNextJobDelayUntilNs(false, null), equalTo(noNetworkJobHolder.getDelayUntilNs()));
 
         assertThat("if there is network, delay until should be provided for network job because it is " +
-                "sooner", jobQueue.getNextJobDelayUntilNs(true), equalTo(networkJobHolder.getDelayUntilNs()));
+                "sooner", jobQueue.getNextJobDelayUntilNs(true, null), equalTo(networkJobHolder.getDelayUntilNs()));
 
         JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0), now + 100000 * JobManager.NS_PER_MS);
 
         jobQueue.insert(noNetworkJobHolder2);
         assertThat("if there is network, any job's delay until should be returned",
-                jobQueue.getNextJobDelayUntilNs(true), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
+                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
+    }
+
+    @Test
+    public void testDelayUntilWithExcludeGroups() throws Exception {
+        JobQueue jobQueue = createNewJobQueue();
+        long now = System.nanoTime();
+        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork()
+                .groupBy("group1"), now + 200000 * JobManager.NS_PER_MS);
+
+        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(new Params(0)
+                .groupBy("group2"), now + 500000 * JobManager.NS_PER_MS);
+
+        jobQueue.insert(networkJobHolder);
+        jobQueue.insert(noNetworkJobHolder);
+
+        assertThat("if there is no network, delay until should be provided for no network job",
+                jobQueue.getNextJobDelayUntilNs(false, null),
+                equalTo(noNetworkJobHolder.getDelayUntilNs()));
+        assertThat("if there is no network, delay until should be provided for no network job",
+                jobQueue.getNextJobDelayUntilNs(false, new ArrayList<String>()),
+                equalTo(noNetworkJobHolder.getDelayUntilNs()));
+
+        assertThat("if there is no network, but the group is disabled, delay until should be null",
+                jobQueue.getNextJobDelayUntilNs(false, Arrays.asList("group2")), nullValue());
+
+        assertThat("if there is network, but both groups are disabled, delay until should be null"
+                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1", "group2")),
+                nullValue());
+        assertThat("if there is network, but group1 is disabled, delay should come from group2"
+                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1")),
+                equalTo(noNetworkJobHolder.getDelayUntilNs()));
+        assertThat("if there is network, but group2 is disabled, delay should come from group1"
+                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group2")),
+                equalTo(networkJobHolder.getDelayUntilNs()));
+
+        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0),
+                now + 100000 * JobManager.NS_PER_MS);
+
+        jobQueue.insert(noNetworkJobHolder2);
+        assertThat("if there is a 3rd job and other gorups are disabled. 3rd job's delay should be "
+                        + "returned",
+                jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1", "group2")),
+                equalTo(noNetworkJobHolder2.getDelayUntilNs()));
     }
 
     @Test
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java
new file mode 100644
index 0000000..67f025c
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java
@@ -0,0 +1,124 @@
+package com.path.android.jobqueue.test.util;
+
+import com.path.android.jobqueue.RunningJobSet;
+
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicLong;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class RunningJobSetTest {
+    RunningJobSet set;
+    @Before
+    public void setUp() {
+        set = new RunningJobSet();
+    }
+
+    @Test
+    public void testEmpty() {
+        assertThat(set.getSafe().size(), is(0));
+    }
+
+    @Test
+    public void testAdd() {
+        set.add("g1");
+        assertThat(set.getSafe().iterator().next(), is("g1"));
+    }
+
+    @Test
+    public void testAddTheSame() {
+        set.add("g1");
+        set.add("g1");
+        assertThat(set.getSafe().iterator().next(), is("g1"));
+        assertThat(set.getSafe().size(), is(1));
+    }
+
+    @Test
+    public void testRemove() {
+        set.add("g1");
+        set.remove("g1");
+        assertThat(set.getSafe().iterator().hasNext(), is(false));
+    }
+
+    @Test
+    public void testOrder() {
+        set.add("a");
+        set.add("z");
+        set.add("b");
+        assertList("a", "b", "z");
+    }
+
+    private void assertList(String... items) {
+        assertThat(set.getSafe().size(), is(items.length));
+        Iterator<String> iterator = set.getSafe().iterator();
+        for (int i = 0; i < items.length; i++) {
+            assertThat(iterator.next(), is(items[i]));
+        }
+    }
+
+    @Test
+    public void testAddWithTimeout() {
+        final AtomicLong time = new AtomicLong();
+        set = new RunningJobSet() {
+            @Override
+            protected long now() {
+                return time.get();
+            }
+        };
+        set.addGroupUntil("g1", 10L);
+        time.set(5);
+        assertList("g1");
+        time.set(11);
+        assertList();
+        time.set(3);
+        assertList(); // should've pruned the list
+    }
+
+    @Test
+    public void testAddSameGroupTwiceWithTimeout() {
+        final AtomicLong time = new AtomicLong();
+        set = new RunningJobSet() {
+            @Override
+            protected long now() {
+                return time.get();
+            }
+        };
+        set.addGroupUntil("g1", 10L);
+        set.addGroupUntil("g1", 12L);
+        time.set(5);
+        assertList("g1");
+        time.set(11);
+        assertList("g1");
+        time.set(13);
+        assertList();
+    }
+
+    @Test
+    public void testAddMultipleGroupTimeouts() {
+        final AtomicLong time = new AtomicLong();
+        set = new RunningJobSet() {
+            @Override
+            protected long now() {
+                return time.get();
+            }
+        };
+        set.addGroupUntil("g1", 10L);
+        set.addGroupUntil("g2", 20L);
+        time.set(5);
+        assertList("g1", "g2");
+        time.set(11);
+        assertList("g2");
+        time.set(21);
+        assertList();
+    }
+}
