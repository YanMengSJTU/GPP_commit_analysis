diff --git a/app/build.gradle b/app/build.gradle
index 745d606..0ec860f 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -20,6 +20,7 @@ android {
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile fileTree(include: ['*.jar'], dir: 'libs')
     compile 'com.android.support:appcompat-v7:21.0.3'
+    compile project(':jobmanagerlib')
 }
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index f68bc15..f306070 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -1,7 +1,24 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.spix.jobmanager">
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.spix.jobmanager">
 
-    <application android:allowBackup="true" android:label="@string/app_name"
-        android:icon="@drawable/ic_launcher" android:theme="@style/AppTheme">
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:icon="@drawable/ic_launcher"
+        android:theme="@style/AppTheme">
+
+        <activity
+            android:name=".activity.MainActivity"
+            android:label="@string/app_name"
+            android:configChanges="orientation|screenSize|keyboardHidden">
+
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
 
     </application>
 
diff --git a/app/src/main/java/com/spix/jobmanager/activity/MainActivity.java b/app/src/main/java/com/spix/jobmanager/activity/MainActivity.java
index a8cd773..7fc4975 100644
--- a/app/src/main/java/com/spix/jobmanager/activity/MainActivity.java
+++ b/app/src/main/java/com/spix/jobmanager/activity/MainActivity.java
@@ -1,14 +1,73 @@
 package com.spix.jobmanager.activity;
 
 import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.spix.jobmanager.R;
+import com.spix.jobqueue.Job;
+import com.spix.jobqueue.JobManager;
+import com.spix.jobqueue.Params;
+import com.spix.jobqueue.config.Configuration;
+
+import java.util.concurrent.atomic.AtomicInteger;
 
 public class MainActivity extends Activity {
 
+    private JobManager jobManager;
 
     @Override
-    protected void onResume() {
-        super.onResume();
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        Configuration configs = new Configuration.Builder(getApplicationContext()).id("test").loadFactor(1).build();
+        this.jobManager = new JobManager(getApplicationContext(), configs);
+        this.jobManager.start();
+        this.jobManager.setOnAllJobsFinishedListener(new JobManager.OnAllJobsFinishedListener() {
+            @Override
+            public void onAllJobsFinished() {
+                Log.d("Job", "On all jobs finished callback");
+            }
+        });
+        jobManager.addJob(new SimpleJob(jobManager));
+    }
+
+    private static class SimpleJob extends Job {
+
+        private static AtomicInteger i = new AtomicInteger(0);
+        private final JobManager jobManager;
+
+        protected SimpleJob(JobManager jobManager) {
+            super(new Params(1).setRequiresNetwork(false));
+            this.jobManager = jobManager;
+        }
+
+        @Override
+        public void onAdded() {
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            Log.d("Job", "Threadid: " + Thread.currentThread().getId() + "  job Nr: " + i.get());
+            Thread.sleep(300);
+
+            if (i.get() > 40) {
+                return;
+            }
+
+            jobManager.addJob(new SimpleJob(jobManager));
+
+            i.incrementAndGet();
+        }
+
+        @Override
+        protected void onCancel() {
+        }
 
+        @Override
+        protected boolean shouldReRunOnThrowable(Throwable throwable) {
+            return false;
+        }
     }
 
 
diff --git a/jobmanagerlib/src/main/java/com/spix/jobqueue/JobManager.java b/jobmanagerlib/src/main/java/com/spix/jobqueue/JobManager.java
index eba9a3e..2aa8c62 100644
--- a/jobmanagerlib/src/main/java/com/spix/jobqueue/JobManager.java
+++ b/jobmanagerlib/src/main/java/com/spix/jobqueue/JobManager.java
@@ -6,6 +6,7 @@
 import com.spix.jobqueue.config.Configuration;
 import com.spix.jobqueue.di.DependencyInjector;
 import com.spix.jobqueue.executor.JobConsumerExecutor;
+import com.spix.jobqueue.executor.JobConsumerExecutor.OnAllRunningJobsFinishedListener;
 import com.spix.jobqueue.log.JqLog;
 import com.spix.jobqueue.network.NetworkEventProvider;
 import com.spix.jobqueue.network.NetworkUtil;
@@ -27,7 +28,7 @@
  * -> Grouping jobs so that they won't run at the same time
  * -> Stats like waiting Job Count
  */
-public class JobManager implements NetworkEventProvider.Listener {
+public class JobManager implements NetworkEventProvider.Listener, OnAllRunningJobsFinishedListener {
     public static final long NS_PER_MS = 1000000;
     public static final long NOT_RUNNING_SESSION_ID = Long.MIN_VALUE;
     public static final long NOT_DELAYED_JOB_DELAY = Long.MIN_VALUE;
@@ -99,6 +100,11 @@ public JobManager(Context context, Configuration config) {
 
     public void setOnAllJobsFinishedListener(OnAllJobsFinishedListener onAllJobsFinishedListener) {
         this.onAllJobsFinishedListener = onAllJobsFinishedListener;
+        if (onAllJobsFinishedListener != null) {
+            this.jobConsumerExecutor.setOnAllRunningJobsFinishedListener(this);
+        } else {
+            this.jobConsumerExecutor.setOnAllRunningJobsFinishedListener(null);
+        }
     }
 
 
@@ -381,26 +387,8 @@ private void removeJob(JobHolder jobHolder) {
         if (jobHolder.getGroupId() != null) {
             runningJobGroups.remove(jobHolder.getGroupId());
         }
-        // if no more job fire callback
-        if (onAllJobsFinishedListener != null) {
-            onAllJobsFinishedListener.onAllJobsFinished();
-        }
     }
 
-    public boolean isEmpty() {
-        synchronized (persistentJobQueue) {
-            if (persistentJobQueue.count() > 0) {
-                return false;
-            }
-        }
-        synchronized (nonPersistentJobQueue) {
-            if (nonPersistentJobQueue.count() > 0) {
-                return false;
-            }
-        }
-
-        return runningJobGroups.isEmpty();
-    }
 
     public synchronized void clear() {
         synchronized (nonPersistentJobQueue) {
@@ -611,6 +599,16 @@ public void run() {
         });
     }
 
+    //Called when no more jobs are running
+    @Override
+    public void onAllRunningJobsFinished() {
+        if (count() == 0) {
+            if (onAllJobsFinishedListener != null) {
+                onAllJobsFinishedListener.onAllJobsFinished();
+            }
+        }
+    }
+
 
     /**
      * Default implementation of QueueFactory that creates one {@link SqliteJobQueue} and one {@link NonPersistentPriorityQueue}
diff --git a/jobmanagerlib/src/main/java/com/spix/jobqueue/executor/JobConsumerExecutor.java b/jobmanagerlib/src/main/java/com/spix/jobqueue/executor/JobConsumerExecutor.java
index 1e28fbb..453fd9f 100644
--- a/jobmanagerlib/src/main/java/com/spix/jobqueue/executor/JobConsumerExecutor.java
+++ b/jobmanagerlib/src/main/java/com/spix/jobqueue/executor/JobConsumerExecutor.java
@@ -24,6 +24,7 @@
     private final AtomicInteger activeConsumerCount = new AtomicInteger(0);
     // key : id + (isPersistent)
     private final ConcurrentHashMap<String, JobHolder> runningJobHolders;
+    private OnAllRunningJobsFinishedListener onAllRunningJobsFinishedListener;
 
 
     public JobConsumerExecutor(Configuration config, Contract contract) {
@@ -44,30 +45,34 @@ public void considerAddingConsumer() {
     }
 
     private boolean canIDie() {
-        if(doINeedANewThread(true, false) == false) {
+        if (doINeedANewThread(true, false) == false) {
             return true;
         }
         return false;
     }
 
+    public void setOnAllRunningJobsFinishedListener(OnAllRunningJobsFinishedListener onAllRunningJobsFinishedListener) {
+        this.onAllRunningJobsFinishedListener = onAllRunningJobsFinishedListener;
+    }
+
     private boolean doINeedANewThread(boolean inConsumerThread, boolean addIfNeeded) {
         //if network provider cannot notify us, we have to busy wait
-        if(contract.isRunning() == false) {
-            if(inConsumerThread) {
+        if (contract.isRunning() == false) {
+            if (inConsumerThread) {
                 activeConsumerCount.decrementAndGet();
             }
             return false;
         }
 
         synchronized (threadGroup) {
-            if(isAboveLoadFactor(inConsumerThread) && canAddMoreConsumers()) {
-                if(addIfNeeded) {
+            if (isAboveLoadFactor(inConsumerThread) && canAddMoreConsumers()) {
+                if (addIfNeeded) {
                     addConsumer();
                 }
                 return true;
             }
         }
-        if(inConsumerThread) {
+        if (inConsumerThread) {
             activeConsumerCount.decrementAndGet();
         }
         return false;
@@ -95,8 +100,8 @@ private boolean isAboveLoadFactor(boolean inConsumerThread) {
             int consumerCnt = activeConsumerCount.intValue() - (inConsumerThread ? 1 : 0);
             boolean res =
                     consumerCnt < minConsumerSize ||
-                    consumerCnt * loadFactor < contract.countRemainingReadyJobs() + runningJobHolders.size();
-            if(JqLog.isDebugEnabled()) {
+                            consumerCnt * loadFactor < contract.countRemainingReadyJobs() + runningJobHolders.size();
+            if (JqLog.isDebugEnabled()) {
                 JqLog.d("%s: load factor check. %s = (%d < %d)|| (%d * %d < %d + %d). consumer thread: %s", Thread.currentThread().getName(), res,
                         consumerCnt, minConsumerSize,
                         consumerCnt, loadFactor, contract.countRemainingReadyJobs(), runningJobHolders.size(), inConsumerThread);
@@ -106,12 +111,21 @@ private boolean isAboveLoadFactor(boolean inConsumerThread) {
 
     }
 
+    public int getRunningJobsCount() {
+        return runningJobHolders.size();
+    }
+
     private void onBeforeRun(JobHolder jobHolder) {
         runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);
     }
 
     private void onAfterRun(JobHolder jobHolder) {
         runningJobHolders.remove(createRunningJobHolderKey(jobHolder));
+        if (runningJobHolders.size() == 0) {
+            if (onAllRunningJobsFinishedListener != null) {
+                onAllRunningJobsFinishedListener.onAllRunningJobsFinished();
+            }
+        }
     }
 
     private String createRunningJobHolderKey(JobHolder jobHolder) {
@@ -124,7 +138,8 @@ private String createRunningJobHolderKey(long id, boolean isPersistent) {
 
     /**
      * returns true if job is currently handled by one of the executor threads
-     * @param id id of the job
+     *
+     * @param id         id of the job
      * @param persistent boolean flag to distinguish id conflicts
      * @return true if job is currently handled here
      */
@@ -144,18 +159,21 @@ public boolean isRunning(long id, boolean persistent) {
         /**
          * should insert the given {@link JobHolder} to related {@link JobQueue}. if it already exists, should replace the
          * existing one.
+         *
          * @param jobHolder
          */
         public void insertOrReplace(JobHolder jobHolder);
 
         /**
          * should remove the job from the related {@link JobQueue}
+         *
          * @param jobHolder
          */
         public void removeJob(JobHolder jobHolder);
 
         /**
          * should return the next job which is available to be run.
+         *
          * @param wait
          * @param waitUnit
          * @return next job to execute or null if no jobs are available
@@ -175,6 +193,7 @@ public boolean isRunning(long id, boolean persistent) {
         private final Contract contract;
         private final JobConsumerExecutor executor;
         private boolean didRunOnce = false;
+
         public JobConsumer(Contract contract, JobConsumerExecutor executor) {
             this.executor = executor;
             this.contract = contract;
@@ -185,8 +204,8 @@ public void run() {
             boolean canDie;
             do {
                 try {
-                    if(JqLog.isDebugEnabled()) {
-                        if(didRunOnce == false) {
+                    if (JqLog.isDebugEnabled()) {
+                        if (didRunOnce == false) {
                             JqLog.d("starting consumer %s", Thread.currentThread().getName());
                             didRunOnce = true;
                         } else {
@@ -209,8 +228,8 @@ public void run() {
                 } finally {
                     //to avoid creating a new thread for no reason, consider not killing this one first
                     canDie = executor.canIDie();
-                    if(JqLog.isDebugEnabled()) {
-                        if(canDie) {
+                    if (JqLog.isDebugEnabled()) {
+                        if (canDie) {
                             JqLog.d("finishing consumer %s", Thread.currentThread().getName());
                         } else {
                             JqLog.d("didn't allow me to die, re-running %s", Thread.currentThread().getName());
@@ -220,4 +239,8 @@ public void run() {
             } while (!canDie);
         }
     }
+
+    public interface OnAllRunningJobsFinishedListener {
+        public void onAllRunningJobsFinished();
+    }
 }
diff --git a/jobmanagerlib/src/main/res/layout/activity_main.xml b/jobmanagerlib/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000..174002e
--- /dev/null
+++ b/jobmanagerlib/src/main/res/layout/activity_main.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical" android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <ProgressBar
+        style="?android:attr/progressBarStyleLarge"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:id="@+id/progressBar" />
+
+    <SeekBar
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/seekBar" />
+</LinearLayout>
\ No newline at end of file
