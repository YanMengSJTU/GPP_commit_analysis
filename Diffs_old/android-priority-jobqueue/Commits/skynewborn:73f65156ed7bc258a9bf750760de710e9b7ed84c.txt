diff --git a/README.md b/README.md
index 65d2e69..a48a57b 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,12 @@
+### V2 is on the way!
+There is a major internal rewrite of this project for more stability and new features. Although API is not final, I highly suggest using 2.0..
+See the migration guide here: [migration from v1 to v2](https://github.com/yigit/android-priority-jobqueue/wiki/V1-to-V2-migration)
+
+``` gradle
+dependedencies {
+    compile 'com.birbit:android-priority-jobqueue:2.0.0-alpha2'
+}
+```
 Android Priority Job Queue (Job Manager)
 ==========================
 
@@ -38,7 +47,7 @@ Although not required, it is most useful when used with an event bus. It also su
 
 Since a code example is worth thousands of documentation pages, here it is.
 
-File: [PostTweetJob.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java)
+File: [PostTweetJob.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/PostTweetJob.java)
 ``` java
 // A job to send a tweet
 public class PostTweetJob extends Job {
@@ -58,6 +67,8 @@ public class PostTweetJob extends Job {
     @Override
     public void onRun() throws Throwable {
         // Job logic goes here. In this example, the network call to post to Twitter is done here.
+        // All work done here should be synchronous, a job is removed from the queue once 
+        // onRun() finishes.
         webservice.postTweet(text);
     }
     @Override
@@ -65,7 +76,7 @@ public class PostTweetJob extends Job {
             int maxRunCount) {
         // An error occurred in onRun.
         // Return value determines whether this job should retry or cancel. You can further
-        // specifcy a backoff strategy or change the job's priority. You can also apply the
+        // specify a backoff strategy or change the job's priority. You can also apply the
         // delay to the whole group to preserve jobs' running order.
         return RetryConstraint.createExponentialBackoff(runCount, 1000);
     }
@@ -78,7 +89,7 @@ public class PostTweetJob extends Job {
 
 ```
 
-File: [TweetActivity.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java#L53)
+File: [TweetActivity.java](https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/SampleTwitterClient.java#L53)
 ``` java
 //...
 public void onSendClick() {
@@ -151,6 +162,9 @@ We highly recommend checking how you can configure job manager and individual jo
 * [Review sample configuration][7]
 
 ### Version History
+  - 2.0.0-alpha1 (March 26, 2016)
+   - A major rewrite with 70+ commits
+   - [Migration guide][13]
   - 1.3.5 (Nov 7, 2015)
    - Default NetworkUtil is now Doze aware. (thanks @coltin)
    - RetryConstraint Delay can be applied to the group to preserve jobs' execution order. (#41)
@@ -241,15 +255,16 @@ THE SOFTWARE.
 </pre>
 
 
-[1]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkUtil.java
-[2]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/network/NetworkEventProvider.java
+[1]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/birbit/android/jobqueue/network/NetworkUtil.java
+[2]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/birbit/android/jobqueue/network/NetworkEventProvider.java
 [3]: http://yigit.github.io/android-priority-jobqueue/coverage-report/index.html
 [4]: http://yigit.github.io/android-priority-jobqueue/javadoc/index.html
 [5]: http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22android-priority-jobqueue%22
 [6]: https://github.com/yigit/android-priority-jobqueue/tree/master/examples
-[7]: https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java#L26
+[7]: https://github.com/yigit/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/TwitterApplication.java#L26
 [8]: http://www.youtube.com/watch?v=xHXn3Kg2IQE
 [9]: https://github.com/yigit/android-priority-jobqueue/wiki
 [10]: https://github.com/yigit/android-priority-jobqueue/wiki/Job-Manager-Configuration
 [11]: https://github.com/yigit/android-priority-jobqueue/wiki/Job-Configuration
-[12]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/Params.java
+[12]: https://github.com/yigit/android-priority-jobqueue/blob/master/jobqueue/src/com/birbit/android/jobqueue/Params.java
+[13]: https://github.com/yigit/android-priority-jobqueue/wiki/V1-to-V2-migration
diff --git a/build.gradle b/build.gradle
index 45b57de..83f847e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -6,7 +6,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.3'
+        classpath 'com.android.tools.build:gradle:2.1.0'
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
diff --git a/examples/twitter/DaoGenerator/src/TwitterDaoGenerator.java b/examples/twitter/DaoGenerator/src/TwitterDaoGenerator.java
index cc6255b..e0d6b7a 100644
--- a/examples/twitter/DaoGenerator/src/TwitterDaoGenerator.java
+++ b/examples/twitter/DaoGenerator/src/TwitterDaoGenerator.java
@@ -8,9 +8,9 @@
     public TwitterDaoGenerator() throws IOException {
     }
     public static void main(String[] args) {
-        Schema schema = new Schema(3, "com.path.android.jobqueue.examples.twitter.entities");
-        schema.setDefaultJavaPackageTest("com.path.android.jobqueue.examples.twitter.test");
-        schema.setDefaultJavaPackageDao("com.path.android.jobqueue.examples.twitter.dao");
+        Schema schema = new Schema(3, "com.birbit.android.jobqueue.examples.twitter.entities");
+        schema.setDefaultJavaPackageTest("com.birbit.android.jobqueue.examples.twitter.test");
+        schema.setDefaultJavaPackageDao("com.birbit.android.jobqueue.examples.twitter.dao");
         schema.enableKeepSectionsByDefault();
         Entity tweet = schema.addEntity("Tweet");
         tweet.addLongProperty("localId").primaryKey().autoincrement();
diff --git a/examples/twitter/TwitterClient/AndroidManifest.xml b/examples/twitter/TwitterClient/AndroidManifest.xml
index 6179257..7434c4a 100644
--- a/examples/twitter/TwitterClient/AndroidManifest.xml
+++ b/examples/twitter/TwitterClient/AndroidManifest.xml
@@ -1,21 +1,29 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.path.android.jobqueue.examples.twitter"
+          package="com.birbit.android.jobqueue.examples.twitter"
 
           android:versionCode="1"
           android:versionName="1.0">
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
-
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <application android:label="@string/app_name"
                  android:debuggable="true"
-                 android:name=".TwitterApplication">
-        <activity android:name=".SampleTwitterClient"
+                 android:name="com.birbit.android.jobqueue.examples.twitter.TwitterApplication">
+        <activity android:name="com.birbit.android.jobqueue.examples.twitter.SampleTwitterClient"
                   android:label="@string/app_name">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN"/>
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
+        <service android:name=".services.MyJobService"
+            android:permission="android.permission.BIND_JOB_SERVICE" />
+        <service
+            android:name=".services.MyGcmJobService"
+            android:exported="true"
+            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE">
+            <intent-filter>
+                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
+            </intent-filter>
+        </service>
     </application>
 </manifest>
diff --git a/examples/twitter/TwitterClient/build.gradle b/examples/twitter/TwitterClient/build.gradle
index d2b3aed..d006430 100644
--- a/examples/twitter/TwitterClient/build.gradle
+++ b/examples/twitter/TwitterClient/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.0'
+        classpath 'com.android.tools.build:gradle:2.0.0'
     }
 }
 
@@ -14,7 +14,7 @@ repositories {
     mavenLocal()
     mavenCentral()
     maven {
-        url 'https://oss.sonatype.org/content/repositories/snapshots/'
+        url "https://jitpack.io"
     }
 }
 
@@ -24,7 +24,7 @@ class RunApk extends DefaultTask {
     def runApp() {
         println "running path on device or emulator"
         println "adb:" + adbExec
-        def cmd = adbExec + " shell am start -a android.intent.action.MAIN -n com.path.android.jobqueue.examples.twitter/com.path.android.jobqueue.examples.twitter.SampleTwitterClient"
+        def cmd = adbExec + " shell am start -a android.intent.action.MAIN -n com.birbit.android.jobqueue.examples.twitter/com.birbit.android.jobqueue.examples.twitter.SampleTwitterClient"
         println cmd
         def proc = cmd.execute()
         proc.in.eachLine {line -> println line}
@@ -44,18 +44,22 @@ tasks.create(name: "runTwitter", type: RunApk){
 }
 
 android {
-    compileSdkVersion 17
+    compileSdkVersion 23
     buildToolsVersion "23"
     defaultConfig {
         minSdkVersion 15
-        targetSdkVersion 17
+        targetSdkVersion 23
     }
 
     dependencies {
-        compile 'de.greenrobot:eventbus:2.1.0-beta-1'
+        compile ('de.greenrobot:eventbus:2.1.0-beta-1') {
+            exclude module: 'support-v4'
+        }
         compile 'org.twitter4j:twitter4j-core:3.0.5'
-        compile 'com.birbit:android-priority-jobqueue:1.3.3'
+        compile project(":jobqueue")
         compile files('external-libs/greenDAO.jar')
+        compile 'com.google.android.gms:play-services-gcm:8.4.0'
+
     }
 
     sourceSets {
diff --git a/examples/twitter/TwitterClient/settings.gradle b/examples/twitter/TwitterClient/settings.gradle
new file mode 100644
index 0000000..dbbb724
--- /dev/null
+++ b/examples/twitter/TwitterClient/settings.gradle
@@ -0,0 +1,2 @@
+include ':jobqueue'
+project(':jobqueue').projectDir = new File(settingsDir, '../../../jobqueue')
\ No newline at end of file
diff --git a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoMaster.java b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoMaster.java
similarity index 94%
rename from examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoMaster.java
rename to examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoMaster.java
index 8de6cf1..7399628 100644
--- a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoMaster.java
+++ b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoMaster.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.dao;
+package com.birbit.android.jobqueue.examples.twitter.dao;
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
@@ -8,8 +8,6 @@
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.IdentityScopeType;
 
-import com.path.android.jobqueue.examples.twitter.dao.TweetDao;
-
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /**
  * Master of DAO (schema version 3): knows all DAOs.
diff --git a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoSession.java b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoSession.java
similarity index 85%
rename from examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoSession.java
rename to examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoSession.java
index 13e1191..62096e1 100644
--- a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/DaoSession.java
+++ b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/DaoSession.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.dao;
+package com.birbit.android.jobqueue.examples.twitter.dao;
 
 import android.database.sqlite.SQLiteDatabase;
 
@@ -9,9 +9,7 @@
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.IdentityScopeType;
 
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
-
-import com.path.android.jobqueue.examples.twitter.dao.TweetDao;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
diff --git a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/TweetDao.java b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/TweetDao.java
similarity index 97%
rename from examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/TweetDao.java
rename to examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/TweetDao.java
index f38a994..9f48756 100644
--- a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/dao/TweetDao.java
+++ b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/dao/TweetDao.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.dao;
+package com.birbit.android.jobqueue.examples.twitter.dao;
 
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
@@ -8,7 +8,7 @@
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
 
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /**
diff --git a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/entities/TweetBase.java b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/entities/TweetBase.java
similarity index 97%
rename from examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/entities/TweetBase.java
rename to examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/entities/TweetBase.java
index b88d897..586daf9 100644
--- a/examples/twitter/TwitterClient/src-gen/com/path/android/jobqueue/examples/twitter/entities/TweetBase.java
+++ b/examples/twitter/TwitterClient/src-gen/com/birbit/android/jobqueue/examples/twitter/entities/TweetBase.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.entities;
+package com.birbit.android.jobqueue.examples.twitter.entities;
 
 
 
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Config.java
similarity index 92%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Config.java
index dbcf4be..dc2e17a 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Config.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter;
+package com.birbit.android.jobqueue.examples.twitter;
 
 public class Config {
     public static final String CONSUMER_KEY = "GfonALJ3wScsJfPsjLpl5g";
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/SampleTwitterClient.java
similarity index 84%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/SampleTwitterClient.java
index 7584732..5a122da 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/SampleTwitterClient.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter;
+package com.birbit.android.jobqueue.examples.twitter;
 
 import android.graphics.Color;
 import android.os.Bundle;
@@ -9,18 +9,20 @@
 import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.examples.twitter.activities.BaseActivity;
-import com.path.android.jobqueue.examples.twitter.adapters.LazyListAdapter;
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
-import com.path.android.jobqueue.examples.twitter.events.DeletedTweetEvent;
-import com.path.android.jobqueue.examples.twitter.events.FetchedNewTweetsEvent;
-import com.path.android.jobqueue.examples.twitter.events.PostedTweetEvent;
-import com.path.android.jobqueue.examples.twitter.events.PostingTweetEvent;
-import com.path.android.jobqueue.examples.twitter.jobs.FetchTweetsJob;
-import com.path.android.jobqueue.examples.twitter.jobs.PostTweetJob;
-import com.path.android.jobqueue.examples.twitter.models.TweetModel;
-import com.path.android.jobqueue.examples.twitter.tasks.SimpleBackgroundTask;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.examples.twitter.R;
+import com.birbit.android.jobqueue.examples.twitter.activities.BaseActivity;
+import com.birbit.android.jobqueue.examples.twitter.adapters.LazyListAdapter;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.events.DeletedTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.events.FetchedNewTweetsEvent;
+import com.birbit.android.jobqueue.examples.twitter.events.PostedTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.events.PostingTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.jobs.FetchTweetsJob;
+import com.birbit.android.jobqueue.examples.twitter.jobs.PostTweetJob;
+import com.birbit.android.jobqueue.examples.twitter.models.TweetModel;
+import com.birbit.android.jobqueue.examples.twitter.tasks.SimpleBackgroundTask;
 import de.greenrobot.dao.LazyList;
 import de.greenrobot.event.EventBus;
 
diff --git a/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Test.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Test.java
new file mode 100644
index 0000000..0d9c7b6
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/Test.java
@@ -0,0 +1,7 @@
+package com.birbit.android.jobqueue.examples.twitter;
+
+/**
+ * Created by yboyar on 3/20/16.
+ */
+public class Test {
+}
diff --git a/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/TwitterApplication.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/TwitterApplication.java
new file mode 100644
index 0000000..f7198fd
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/TwitterApplication.java
@@ -0,0 +1,87 @@
+package com.birbit.android.jobqueue.examples.twitter;
+
+import android.app.Application;
+import android.os.Build;
+import android.util.Log;
+
+import com.birbit.android.jobqueue.examples.twitter.services.MyGcmJobService;
+import com.birbit.android.jobqueue.scheduling.FrameworkJobSchedulerService;
+import com.birbit.android.jobqueue.scheduling.FrameworkScheduler;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.examples.twitter.services.MyJobService;
+import com.birbit.android.jobqueue.log.CustomLogger;
+import com.birbit.android.jobqueue.scheduling.GcmJobSchedulerService;
+import com.birbit.android.jobqueue.scheduling.GcmScheduler;
+import com.google.android.gms.common.ConnectionResult;
+import com.google.android.gms.common.GoogleApiAvailability;
+
+
+public class TwitterApplication extends Application {
+    private static TwitterApplication instance;
+    private JobManager jobManager;
+
+    public TwitterApplication() {
+        instance = this;
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        configureJobManager();
+    }
+
+    private void configureJobManager() {
+        Configuration.Builder builder = new Configuration.Builder(this)
+        .customLogger(new CustomLogger() {
+            private static final String TAG = "JOBS";
+            @Override
+            public boolean isDebugEnabled() {
+                return true;
+            }
+
+            @Override
+            public void d(String text, Object... args) {
+                Log.d(TAG, String.format(text, args));
+            }
+
+            @Override
+            public void e(Throwable t, String text, Object... args) {
+                Log.e(TAG, String.format(text, args), t);
+            }
+
+            @Override
+            public void e(String text, Object... args) {
+                Log.e(TAG, String.format(text, args));
+            }
+
+            @Override
+            public void v(String text, Object... args) {
+
+            }
+        })
+        .minConsumerCount(1)//always keep at least one consumer alive
+        .maxConsumerCount(3)//up to 3 consumers at a time
+        .loadFactor(3)//3 jobs per consumer
+        .consumerKeepAlive(120);//wait 2 minute
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            builder.scheduler(FrameworkJobSchedulerService.createSchedulerFor(this,
+                    MyJobService.class), false);
+        } else {
+            int enableGcm = GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(this);
+            if (enableGcm == ConnectionResult.SUCCESS) {
+                builder.scheduler(GcmJobSchedulerService.createSchedulerFor(this,
+                        MyGcmJobService.class), false);
+            }
+        }
+        jobManager = new JobManager(builder.build());
+    }
+
+    public JobManager getJobManager() {
+        return jobManager;
+    }
+
+    public static TwitterApplication getInstance() {
+        return instance;
+    }
+}
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/activities/BaseActivity.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/activities/BaseActivity.java
similarity index 85%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/activities/BaseActivity.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/activities/BaseActivity.java
index cbb1b47..02d6ccd 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/activities/BaseActivity.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/activities/BaseActivity.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.activities;
+package com.birbit.android.jobqueue.examples.twitter.activities;
 
 import android.app.Activity;
 
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java
similarity index 92%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java
index b19e76a..03c7a51 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/adapters/LazyListAdapter.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.adapters;
+package com.birbit.android.jobqueue.examples.twitter.adapters;
 
 import android.widget.BaseAdapter;
 import de.greenrobot.dao.LazyList;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/controllers/TwitterController.java
similarity index 85%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/controllers/TwitterController.java
index abd4635..27330c4 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/controllers/TwitterController.java
@@ -1,6 +1,6 @@
-package com.path.android.jobqueue.examples.twitter.controllers;
+package com.birbit.android.jobqueue.examples.twitter.controllers;
 
-import com.path.android.jobqueue.examples.twitter.Config;
+import com.birbit.android.jobqueue.examples.twitter.Config;
 import twitter4j.*;
 import twitter4j.auth.AccessToken;
 import twitter4j.conf.ConfigurationBuilder;
@@ -10,7 +10,8 @@
 public class TwitterController {
     private static TwitterController instance;
     private Twitter twitter;
-    private Long userId;
+    // in a real app, this would be saved on login and come from shared preferences on startup
+    private final long userId = 1443060589;
     public static final int PAGE_LENGTH = 20;
 
 
@@ -48,10 +49,6 @@ public Status postTweet(String status) throws TwitterException {
     }
 
     public long getUserId() throws TwitterException {
-        if(userId == null) {
-            userId = twitter.getId();
-        }
         return userId;
-
     }
 }
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/entities/Tweet.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/entities/Tweet.java
similarity index 93%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/entities/Tweet.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/entities/Tweet.java
index fd2d10e..afe477c 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/entities/Tweet.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/entities/Tweet.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.entities;
+package com.birbit.android.jobqueue.examples.twitter.entities;
 
 
 
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java
similarity index 74%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java
index 890961c..e5e42ee 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/DeletedTweetEvent.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.events;
+package com.birbit.android.jobqueue.examples.twitter.events;
 
 public class DeletedTweetEvent {
     private long id;
diff --git a/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java
new file mode 100644
index 0000000..cfa0615
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java
@@ -0,0 +1,4 @@
+package com.birbit.android.jobqueue.examples.twitter.events;
+
+public class FetchedNewTweetsEvent {
+}
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostedTweetEvent.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostedTweetEvent.java
similarity index 72%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostedTweetEvent.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostedTweetEvent.java
index 3d54b84..f9d4bfc 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostedTweetEvent.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostedTweetEvent.java
@@ -1,6 +1,6 @@
-package com.path.android.jobqueue.examples.twitter.events;
+package com.birbit.android.jobqueue.examples.twitter.events;
 
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
 
 public class PostedTweetEvent {
     private Tweet tweet;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostingTweetEvent.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostingTweetEvent.java
similarity index 61%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostingTweetEvent.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostingTweetEvent.java
index 3caae75..7eaadff 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/PostingTweetEvent.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/events/PostingTweetEvent.java
@@ -1,6 +1,6 @@
-package com.path.android.jobqueue.examples.twitter.events;
+package com.birbit.android.jobqueue.examples.twitter.events;
 
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
 
 public class PostingTweetEvent {
     private Tweet tweeet;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
similarity index 61%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
index f910698..e7e1070 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
@@ -1,28 +1,27 @@
-package com.path.android.jobqueue.examples.twitter.jobs;
+package com.birbit.android.jobqueue.examples.twitter.jobs;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.RetryConstraint;
-import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
-import com.path.android.jobqueue.examples.twitter.events.FetchedNewTweetsEvent;
-import com.path.android.jobqueue.examples.twitter.models.TweetModel;
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.examples.twitter.controllers.TwitterController;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.events.FetchedNewTweetsEvent;
+import com.birbit.android.jobqueue.examples.twitter.models.TweetModel;
 import de.greenrobot.event.EventBus;
 import twitter4j.Status;
 import twitter4j.TwitterException;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
 
 
 public class FetchTweetsJob extends Job {
-    private static final AtomicInteger jobCounter = new AtomicInteger(0);
 
-    private final int id;
     public FetchTweetsJob() {
-        super(new Params(Priority.LOW).requireNetwork().groupBy("fetch-tweets"));
-        id = jobCounter.incrementAndGet();
+        //use singleWith so that if the same job has already been added and is not yet running,
+        //it will only run once.
+        super(new Params(Priority.LOW).requireNetwork().groupBy("fetch-tweets").singleInstanceBy("fetch-tweets"));
     }
 
     @Override
@@ -32,11 +31,6 @@ public void onAdded() {
 
     @Override
     public void onRun() throws Throwable {
-        if(id != jobCounter.get()) {
-            //looks like other fetch jobs has been added after me. no reason to keep fetching
-            //many times, cancel me, let the other one fetch tweets.
-            return;
-        }
         TweetModel tweetModel = TweetModel.getInstance();
         Tweet lastTweet = tweetModel.getLastTweet();
         List<Status> statusList = TwitterController.getInstance().loadTweets(lastTweet == null ? null : lastTweet.getServerId());
@@ -52,8 +46,8 @@ public void onRun() throws Throwable {
     }
 
     @Override
-    protected void onCancel() {
-        //TODO show error notification
+    protected void onCancel(@CancelReason int cancelReason) {
+
     }
 
     @Override
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
similarity index 79%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
index b4d5ae6..5fc15f6 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
@@ -1,14 +1,15 @@
-package com.path.android.jobqueue.examples.twitter.jobs;
+package com.birbit.android.jobqueue.examples.twitter.jobs;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.RetryConstraint;
-import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
-import com.path.android.jobqueue.examples.twitter.events.DeletedTweetEvent;
-import com.path.android.jobqueue.examples.twitter.events.PostedTweetEvent;
-import com.path.android.jobqueue.examples.twitter.events.PostingTweetEvent;
-import com.path.android.jobqueue.examples.twitter.models.TweetModel;
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.examples.twitter.controllers.TwitterController;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.events.DeletedTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.events.PostedTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.events.PostingTweetEvent;
+import com.birbit.android.jobqueue.examples.twitter.models.TweetModel;
 import de.greenrobot.event.EventBus;
 import twitter4j.Status;
 import twitter4j.TwitterException;
@@ -64,7 +65,7 @@ public void onRun() throws Throwable {
     }
 
     @Override
-    protected void onCancel() {
+    protected void onCancel(@CancelReason int cancelReason) {
         //delete local tweet
         Tweet localTweet = TweetModel.getInstance().getTweetByLocalId(localId);
         if(localTweet != null) {
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/Priority.java
similarity index 68%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/Priority.java
index 569aeea..b6449d1 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/jobs/Priority.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.jobs;
+package com.birbit.android.jobqueue.examples.twitter.jobs;
 
 public class Priority {
     public static int LOW = 0;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/DbHelper.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/DbHelper.java
similarity index 67%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/DbHelper.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/DbHelper.java
index 2632ed2..2463967 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/DbHelper.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/DbHelper.java
@@ -1,15 +1,10 @@
-package com.path.android.jobqueue.examples.twitter.models;
+package com.birbit.android.jobqueue.examples.twitter.models;
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
-import com.path.android.jobqueue.examples.twitter.TwitterApplication;
-import com.path.android.jobqueue.examples.twitter.dao.DaoMaster;
-import com.path.android.jobqueue.examples.twitter.dao.DaoSession;
-import com.path.android.jobqueue.persistentQueue.sqlite.DbOpenHelper;
-import de.greenrobot.dao.DbUtils;
-import de.greenrobot.dao.Query;
-
-import java.util.concurrent.atomic.AtomicBoolean;
+import com.birbit.android.jobqueue.examples.twitter.TwitterApplication;
+import com.birbit.android.jobqueue.examples.twitter.dao.DaoMaster;
+import com.birbit.android.jobqueue.examples.twitter.dao.DaoSession;
 
 public class DbHelper {
     private static DbHelper instance;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/TweetModel.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/TweetModel.java
similarity index 87%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/TweetModel.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/TweetModel.java
index 5168ee8..bd5b4a4 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/models/TweetModel.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/models/TweetModel.java
@@ -1,7 +1,7 @@
-package com.path.android.jobqueue.examples.twitter.models;
+package com.birbit.android.jobqueue.examples.twitter.models;
 
-import com.path.android.jobqueue.examples.twitter.dao.TweetDao;
-import com.path.android.jobqueue.examples.twitter.entities.Tweet;
+import com.birbit.android.jobqueue.examples.twitter.dao.TweetDao;
+import com.birbit.android.jobqueue.examples.twitter.entities.Tweet;
 import de.greenrobot.dao.LazyList;
 
 import java.util.Collection;
diff --git a/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyGcmJobService.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyGcmJobService.java
new file mode 100644
index 0000000..7a51a16
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyGcmJobService.java
@@ -0,0 +1,13 @@
+package com.birbit.android.jobqueue.examples.twitter.services;
+
+import com.birbit.android.jobqueue.examples.twitter.TwitterApplication;
+import com.birbit.android.jobqueue.scheduling.GcmJobSchedulerService;
+import com.birbit.android.jobqueue.scheduling.GcmScheduler;
+import com.google.android.gms.gcm.GcmTaskService;
+import com.google.android.gms.gcm.TaskParams;
+
+/**
+ * Created by yboyar on 3/20/16.
+ */
+public class MyGcmJobService extends GcmJobSchedulerService {
+}
diff --git a/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyJobService.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyJobService.java
new file mode 100644
index 0000000..ecb4a82
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/services/MyJobService.java
@@ -0,0 +1,8 @@
+package com.birbit.android.jobqueue.examples.twitter.services;
+
+import com.birbit.android.jobqueue.scheduling.FrameworkJobSchedulerService;
+import com.birbit.android.jobqueue.scheduling.FrameworkScheduler;
+import com.birbit.android.jobqueue.examples.twitter.TwitterApplication;
+
+public class MyJobService extends FrameworkJobSchedulerService {
+}
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java
similarity index 93%
rename from examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java
rename to examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java
index 08935c8..ec6a784 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java
+++ b/examples/twitter/TwitterClient/src/com/birbit/android/jobqueue/examples/twitter/tasks/SimpleBackgroundTask.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.examples.twitter.tasks;
+package com.birbit.android.jobqueue.examples.twitter.tasks;
 
 import android.app.Activity;
 import android.os.AsyncTask;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java
deleted file mode 100644
index e782af8..0000000
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/TwitterApplication.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package com.path.android.jobqueue.examples.twitter;
-
-import android.app.Application;
-import android.util.Log;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.log.CustomLogger;
-
-public class TwitterApplication extends Application {
-    private static TwitterApplication instance;
-    private JobManager jobManager;
-
-    public TwitterApplication() {
-        instance = this;
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        configureJobManager();
-
-    }
-
-    private void configureJobManager() {
-        Configuration configuration = new Configuration.Builder(this)
-        .customLogger(new CustomLogger() {
-            private static final String TAG = "JOBS";
-            @Override
-            public boolean isDebugEnabled() {
-                return true;
-            }
-
-            @Override
-            public void d(String text, Object... args) {
-                Log.d(TAG, String.format(text, args));
-            }
-
-            @Override
-            public void e(Throwable t, String text, Object... args) {
-                Log.e(TAG, String.format(text, args), t);
-            }
-
-            @Override
-            public void e(String text, Object... args) {
-                Log.e(TAG, String.format(text, args));
-            }
-        })
-        .minConsumerCount(1)//always keep at least one consumer alive
-        .maxConsumerCount(3)//up to 3 consumers at a time
-        .loadFactor(3)//3 jobs per consumer
-        .consumerKeepAlive(120)//wait 2 minute
-        .build();
-        jobManager = new JobManager(this, configuration);
-    }
-
-    public JobManager getJobManager() {
-        return jobManager;
-    }
-
-    public static TwitterApplication getInstance() {
-        return instance;
-    }
-}
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java
deleted file mode 100644
index b822541..0000000
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/events/FetchedNewTweetsEvent.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package com.path.android.jobqueue.examples.twitter.events;
-
-public class FetchedNewTweetsEvent {
-}
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 722ec75..f68a9b5 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Mon Sep 07 09:30:54 CST 2015
+#Mon May 16 14:50:46 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 99d1b1f..4259f0c 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -7,7 +7,8 @@ File releaseFile = new File("${projectDir}/releaseConfig.properties")
 if (releaseFile.exists()) {
     releaseConfig.load(new FileInputStream(releaseFile))
 }
-
+// for jitpack
+group='com.github.yigit'
 ext.releaseConfig = releaseConfig*/
 
 task wrapper(type: Wrapper) {
@@ -16,22 +17,25 @@ task wrapper(type: Wrapper) {
 
 apply plugin: 'maven'
 apply plugin: 'signing'
+apply plugin: 'com.github.dcendents.android-maven'
 apply plugin: 'jacoco'
 
 buildscript {
     repositories {
         jcenter()
+        mavenCentral()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
-
+        classpath 'com.android.tools.build:gradle:2.1.0'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
     }
 }
 
 repositories {
     mavenCentral()
     jcenter()
+    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
 }
 
 configurations {
@@ -47,21 +51,38 @@ dependencies {
     testCompile 'org.easytesting:fest-util:1.2.5'
     testCompile 'org.easytesting:fest-reflect:1.4.1'
     testCompile 'org.mockito:mockito-core:2.0.2-beta'
+
+    // use an old version since we only need a few util classes that were already there for a long
+    // time. If app depends on a newer one, gradle will pick it for us.
+    compile 'com.android.support:support-v4:21.0.3'
+    // build tools does not allow makingt this provided so we make it optional when pom is created
+    compile 'com.google.android.gms:play-services-gcm:8.4.0'
+
 }
 
 android {
     compileSdkVersion 23
-    buildToolsVersion "23.0.2"
+    buildToolsVersion "23.0.3"
     buildTypes {
         debug {
             testCoverageEnabled = true
         }
+        release {
+            testCoverageEnabled = false
+        }
     }
 
     defaultConfig {
         minSdkVersion 7
         targetSdkVersion 23
     }
+
+    testOptions {
+        unitTests.all {
+            // All the usual Gradle options.
+            jvmArgs '-Xmx2000m', '-XX:+HeapDumpOnOutOfMemoryError', "-XX:HeapDumpPath=${System.env.CIRCLE_ARTIFACTS == null ? "." : System.env.CIRCLE_ARTIFACTS}/oom.hprof"
+        }
+    }
 }
 
 //READ VERSION NAME
@@ -92,6 +113,7 @@ android.libraryVariants.all { variant ->
         source = variant.javaCompile.source
         ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
         classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
+        exclude 'com/google/**'
     }
 
     def javadocJarTask = project.tasks.create(name: "javadocJar${suffix}", type: Jar) {
@@ -121,8 +143,11 @@ android.libraryVariants.all { variant ->
                 pom.artifactId = 'android-priority-jobqueue'
 
 
-                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots") {
-                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
+//                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots") {
+//                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
+//                }
+                snapshotRepository(url: mavenLocal().url) {
+
                 }
 
                 repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2") {
@@ -166,6 +191,14 @@ android.libraryVariants.all { variant ->
                         }
                     }
                 }
+                pom.whenConfigured { MavenPom pom ->
+                    pom.dependencies.each {
+                        if (it.artifactId == 'play-services-gcm') {
+                            it.optional = true
+                            it.scope = "provided"
+                        }
+                    }
+                }
             }
         }
     }
@@ -175,6 +208,12 @@ android.libraryVariants.all { variant ->
         sign configurations.archives
     }
 }*/
+task testLint(type : Exec) {
+    workingDir project.projectDir
+    // SET ANDROID_LINT_JARS ENV VARIABLE
+    commandLine 'lint', '.', '--sources', 'src/test/java', '--disable', 'InlinedApi,AllowBackup,MissingApplicationIcon,LintError,NOTIFY_ON_OBJECT'
+
+}
 
 task jacocoTestReport(type:JacocoReport, dependsOn: "testDebugUnitTest") {
     group = "Reporting"
@@ -186,12 +225,13 @@ task jacocoTestReport(type:JacocoReport, dependsOn: "testDebugUnitTest") {
             excludes: ['**/R.class',
                        '**/R$*.class',
                        '**/BuildConfig.*',
-                       '**/Manifest*.*']
+                       '**/Manifest*.*',
+                        'com/google/**']
     )
 
     additionalSourceDirs = files(android.sourceSets.main.getJava().getSrcDirs())
     sourceDirectories = files(android.sourceSets.main.getJava().getSrcDirs())
-    executionData = files("$buildDir/jacoco/testDebug.exec")
+    executionData = files("$buildDir/jacoco/testDebugUnitTest.exec")
 
     reports {
         xml.enabled = true
diff --git a/jobqueue/src/main/AndroidManifest.xml b/jobqueue/src/main/AndroidManifest.xml
index 7249fc1..fac1b40 100644
--- a/jobqueue/src/main/AndroidManifest.xml
+++ b/jobqueue/src/main/AndroidManifest.xml
@@ -1,8 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.path.android.jobqueue"
-          android:versionCode="2"
-          android:versionName="1.3.5">
-    <application>
-    </application>
+          xmlns:tools="http://schemas.android.com/tools"
+          package="com.birbit.android.jobqueue"
+          android:versionCode="3"
+          android:versionName="2.0.0-alpha2">
+    <uses-sdk tools:overrideLibrary="com.google.android.gms.gcm, com.google.android.gms.base,
+    com.google.android.gms, com.google.android.gms.measurement"/>
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 </manifest>
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/AsyncAddCallback.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/AsyncAddCallback.java
similarity index 76%
rename from jobqueue/src/main/java/com/path/android/jobqueue/AsyncAddCallback.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/AsyncAddCallback.java
index 2b464e6..5dedbe7 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/AsyncAddCallback.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/AsyncAddCallback.java
@@ -1,12 +1,12 @@
-package com.path.android.jobqueue;
+package com.birbit.android.jobqueue;
 
 import android.app.Activity;
 
 /**
- * If you are adding the job via the async adder, you can provide a callback method to receive the ID.
+ * If you are adding the job via the async adder, you can provide a callback method to confirm when it was added.
  * Please keep in mind that job manager will keep a strong reference to this callback. So if the callback is an
  * anonymous class inside an {@link Activity} context, it may leak the activity until the job is added.
  */
 public interface AsyncAddCallback {
-    public void onAdded(long jobId);
+    void onAdded();
 }
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/BatchingScheduler.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/BatchingScheduler.java
new file mode 100644
index 0000000..752b58e
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/BatchingScheduler.java
@@ -0,0 +1,123 @@
+package com.birbit.android.jobqueue;
+
+import android.content.Context;
+
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * JobManager calls scheduler every time it receives some job that can use the Scheduler APIs.
+ * This may get too noisy & unnecessary.
+ * <p>
+ * This BatchingScheduler wraps a generic scheduler and avoid calling the system service if a
+ * request is made that has the same criteria as the previous one.
+ */
+public class BatchingScheduler extends Scheduler {
+    // batch by 15 min intervals
+    public static final long DEFAULT_BATCHING_PERIOD_IN_MS = TimeUnit.SECONDS.toMillis(60 * 15);
+    private long batchingDurationInMs = DEFAULT_BATCHING_PERIOD_IN_MS;
+    private long batchingDurationInNs = TimeUnit.MILLISECONDS.toNanos(batchingDurationInMs);
+    private final Scheduler delegate;
+    private final List<ConstraintWrapper> constraints = new ArrayList<>();
+    private final Timer timer;
+    public BatchingScheduler(Scheduler delegate, Timer timer) {
+        this.delegate = delegate;
+        this.timer = timer;
+    }
+
+    @Override
+    public void init(Context context, Callback callback) {
+        super.init(context, callback);
+        delegate.init(context, new Callback() {
+            @Override
+            public boolean start(SchedulerConstraint constraint) {
+                removeFromConstraints(constraint);
+                return BatchingScheduler.this.start(constraint);
+            }
+
+            @Override
+            public boolean stop(SchedulerConstraint constraint) {
+                return BatchingScheduler.this.stop(constraint);
+            }
+        });
+    }
+
+    private void removeFromConstraints(SchedulerConstraint constraint) {
+        synchronized (constraints) {
+            for (int i = constraints.size() - 1; i >= 0; i--) {
+                ConstraintWrapper existing = constraints.get(i);
+                if (existing.constraint.getUuid().equals(constraint.getUuid())) {
+                    constraints.remove(i);
+                }
+            }
+        }
+    }
+
+    protected boolean addToConstraints(SchedulerConstraint constraint) {
+        final long now = timer.nanoTime();
+        long expectedRunTime = TimeUnit.MILLISECONDS.toNanos(constraint.getDelayInMs()) + now;
+        synchronized (constraints) {
+            for (ConstraintWrapper existing : constraints) {
+                if (covers(existing, constraint, expectedRunTime)) {
+                    return false;
+                }
+            }
+            // fix the delay
+            long group = constraint.getDelayInMs() / batchingDurationInMs;
+            long newDelay = (group + 1) * batchingDurationInMs;
+            constraint.setDelayInMs(newDelay);
+            constraints.add(new ConstraintWrapper(now + TimeUnit.MILLISECONDS.toNanos(newDelay),
+                    constraint));
+            return true;
+        }
+    }
+
+    private boolean covers(ConstraintWrapper existing, SchedulerConstraint constraint,
+                           long expectedRunTime) {
+        if (existing.constraint.getNetworkStatus() != constraint.getNetworkStatus()) {
+            return false;
+        }
+        // same network status, check if time matches
+        long timeDiff = existing.delayUntilNs - expectedRunTime;
+        return timeDiff > 0 && timeDiff <= batchingDurationInNs;
+    }
+
+    @Override
+    public void request(SchedulerConstraint constraint) {
+        if (addToConstraints(constraint)) {
+            delegate.request(constraint);
+        }
+    }
+
+    @Override
+    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {
+        removeFromConstraints(constraint);
+        delegate.onFinished(constraint, false);
+        if (reschedule) {
+            request(constraint);
+        }
+    }
+
+    @Override
+    public void cancelAll() {
+        synchronized (constraints) {
+            constraints.clear();
+        }
+        delegate.cancelAll();
+    }
+
+    private static class ConstraintWrapper {
+        final long delayUntilNs;
+        final SchedulerConstraint constraint;
+
+        public ConstraintWrapper(long delayUntilNs, SchedulerConstraint constraint) {
+            this.delayUntilNs = delayUntilNs;
+            this.constraint = constraint;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/CallbackManager.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/CallbackManager.java
new file mode 100644
index 0000000..f933fec
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/CallbackManager.java
@@ -0,0 +1,221 @@
+package com.birbit.android.jobqueue;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.MessageFactory;
+import com.birbit.android.jobqueue.messaging.MessageQueueConsumer;
+import com.birbit.android.jobqueue.messaging.SafeMessageQueue;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.messaging.message.CallbackMessage;
+import com.birbit.android.jobqueue.messaging.message.CancelResultMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.PublicQueryMessage;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Handles callbacks to user code.
+ * <p>
+ * Although this costs an additional thread, it is worth for the benefit of isolation.
+ */
+public class CallbackManager {
+    final SafeMessageQueue messageQueue;
+    private final CopyOnWriteArrayList<JobManagerCallback> callbacks;
+    private final MessageFactory factory;
+    private final AtomicInteger callbacksSize = new AtomicInteger(0);
+    private final Timer timer;
+    private final AtomicBoolean started = new AtomicBoolean(false);
+    public CallbackManager(MessageFactory factory, Timer timer) {
+        this.timer = timer;
+        this.messageQueue = new SafeMessageQueue(timer, factory, "jq_callback");
+        callbacks = new CopyOnWriteArrayList<>();
+        this.factory = factory;
+    }
+
+    void addCallback(@NonNull JobManagerCallback callback) {
+        callbacks.add(callback);
+        callbacksSize.incrementAndGet();
+        startIfNeeded();
+    }
+
+    private void startIfNeeded() {
+        if (!started.getAndSet(true)) {
+            start();
+        }
+    }
+
+    boolean removeCallback(@NonNull JobManagerCallback callback) {
+        boolean removed = callbacks.remove(callback);
+        if (removed) {
+            callbacksSize.decrementAndGet();
+        }
+        return removed;
+    }
+
+    private void start() {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+
+                messageQueue.consume(new MessageQueueConsumer() {
+                    long lastDelivery = Long.MIN_VALUE;
+
+                    @Override
+                    public void onStart() {
+                    }
+
+                    @Override
+                    public void handleMessage(Message message) {
+                        if (message.type == Type.CALLBACK) {
+                            CallbackMessage cm = (CallbackMessage) message;
+                            deliverMessage(cm);
+                            lastDelivery = timer.nanoTime();
+                        } else if (message.type == Type.CANCEL_RESULT_CALLBACK) {
+                            deliverCancelResult((CancelResultMessage) message);
+                            lastDelivery = timer.nanoTime();
+                        } else if (message.type == Type.COMMAND) {
+                            CommandMessage command = (CommandMessage) message;
+                            if (command.getWhat() == CommandMessage.QUIT) {
+                                messageQueue.stop();
+                                started.set(false);
+                            }
+                        } else if (message.type == Type.PUBLIC_QUERY) {
+                            ((PublicQueryMessage) message).getCallback().onResult(0);
+                        }
+                    }
+
+                    @Override
+                    public void onIdle() {
+
+                    }
+                });
+            }
+        }, "job-manager-callbacks").start();
+    }
+
+    private void deliverCancelResult(@NonNull CancelResultMessage message) {
+        message.getCallback().onCancelled(message.getResult());
+        startIfNeeded();
+    }
+
+    private void deliverMessage(@NonNull CallbackMessage cm) {
+        switch (cm.getWhat()) {
+            case CallbackMessage.ON_ADDED:
+                notifyOnAddedListeners(cm.getJob());
+                break;
+            case CallbackMessage.ON_AFTER_RUN:
+                notifyAfterRunListeners(cm.getJob(), cm.getResultCode());
+                break;
+            case CallbackMessage.ON_CANCEL:
+                notifyOnCancelListeners(cm.getJob(), cm.isByUserRequest(), cm.getThrowable());
+                break;
+            case CallbackMessage.ON_DONE:
+                notifyOnDoneListeners(cm.getJob());
+                break;
+            case CallbackMessage.ON_RUN:
+                notifyOnRunListeners(cm.getJob(), cm.getResultCode());
+                break;
+        }
+    }
+
+    private void notifyOnCancelListeners(@NonNull Job job, boolean byCancelRequest, @Nullable Throwable throwable) {
+        for (JobManagerCallback callback : callbacks) {
+            callback.onJobCancelled(job, byCancelRequest, throwable);
+        }
+    }
+
+    private void notifyOnRunListeners(@NonNull Job job, int resultCode) {
+        for (JobManagerCallback callback : callbacks) {
+            callback.onJobRun(job, resultCode);
+        }
+    }
+
+    private void notifyAfterRunListeners(@NonNull Job job, int resultCode) {
+        for (JobManagerCallback callback : callbacks) {
+            callback.onAfterJobRun(job, resultCode);
+        }
+    }
+
+    private void notifyOnDoneListeners(@NonNull Job job) {
+        for (JobManagerCallback callback : callbacks) {
+            callback.onDone(job);
+        }
+    }
+
+    private void notifyOnAddedListeners(@NonNull Job job) {
+        for (JobManagerCallback callback : callbacks) {
+            callback.onJobAdded(job);
+        }
+    }
+
+    public void notifyOnRun(@NonNull Job job, int result) {
+        if (!hasAnyCallbacks()) {
+            return;
+        }
+        CallbackMessage callback = factory.obtain(CallbackMessage.class);
+        callback.set(job, CallbackMessage.ON_RUN, result);
+        messageQueue.post(callback);
+    }
+
+    private boolean hasAnyCallbacks() {
+        return callbacksSize.get() > 0;
+    }
+
+    public void notifyAfterRun(@NonNull Job job, int result) {
+        if (!hasAnyCallbacks()) {
+            return;
+        }
+        CallbackMessage callback = factory.obtain(CallbackMessage.class);
+        callback.set(job, CallbackMessage.ON_AFTER_RUN, result);
+        messageQueue.post(callback);
+    }
+
+    public void notifyOnCancel(@NonNull Job job, boolean byCancelRequest, @Nullable Throwable throwable) {
+        if (!hasAnyCallbacks()) {
+            return;
+        }
+        CallbackMessage callback = factory.obtain(CallbackMessage.class);
+        callback.set(job, CallbackMessage.ON_CANCEL, byCancelRequest, throwable);
+        messageQueue.post(callback);
+    }
+
+    public void notifyOnAdded(@NonNull Job job) {
+        if (!hasAnyCallbacks()) {
+            return;
+        }
+        CallbackMessage callback = factory.obtain(CallbackMessage.class);
+        callback.set(job, CallbackMessage.ON_ADDED);
+        messageQueue.post(callback);
+    }
+
+    public void notifyOnDone(@NonNull Job job) {
+        if (!hasAnyCallbacks()) {
+            return;
+        }
+        CallbackMessage callback = factory.obtain(CallbackMessage.class);
+        callback.set(job, CallbackMessage.ON_DONE);
+        messageQueue.post(callback);
+    }
+
+    public void notifyCancelResult(@NonNull CancelResult result, @NonNull CancelResult.AsyncCancelCallback callback) {
+        CancelResultMessage message = factory.obtain(CancelResultMessage.class);
+        message.set(callback, result);
+        messageQueue.post(message);
+        startIfNeeded();
+    }
+
+    public void destroy() {
+        if (!started.get()) {
+            return;
+        }
+        CommandMessage message = factory.obtain(CommandMessage.class);
+        message.set(CommandMessage.QUIT);
+        messageQueue.post(message);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelHandler.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelHandler.java
new file mode 100644
index 0000000..a049779
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelHandler.java
@@ -0,0 +1,96 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * Temporary object to keep track of cancel handling
+ */
+class CancelHandler {
+    private Set<String> running;
+    private final TagConstraint tagConstraint;
+    private final String[] tags;
+    private final Collection<JobHolder> cancelled;
+    private final Collection<JobHolder> failedToCancel;
+    private final CancelResult.AsyncCancelCallback callback;
+
+    CancelHandler(TagConstraint constraint, String[] tags, CancelResult.AsyncCancelCallback callback) {
+        this.tagConstraint = constraint;
+        this.tags = tags;
+        cancelled = new ArrayList<>();
+        failedToCancel = new ArrayList<>();
+        this.callback = callback;
+    }
+    
+    void query(JobManagerThread jobManagerThread, ConsumerManager consumerManager) {
+        running = consumerManager.markJobsCancelled(tagConstraint, tags);
+        Constraint queryConstraint = jobManagerThread.queryConstraint;
+        queryConstraint.clear();
+        queryConstraint.setNowInNs(jobManagerThread.timer.nanoTime());
+        queryConstraint.setTagConstraint(tagConstraint);
+        queryConstraint.setExcludeJobIds(running);
+        queryConstraint.setTags(tags);
+        queryConstraint.setExcludeRunning(true);
+        Set<JobHolder> nonPersistentInQueue = jobManagerThread.nonPersistentJobQueue
+                .findJobs(queryConstraint);
+        Set<JobHolder> persistentInQueue = jobManagerThread.persistentJobQueue
+                .findJobs(queryConstraint);
+        for (JobHolder nonPersistent : nonPersistentInQueue) {
+            nonPersistent.markAsCancelled();
+            cancelled.add(nonPersistent);
+            jobManagerThread.nonPersistentJobQueue.onJobCancelled(nonPersistent);
+        }
+        for (JobHolder persistent : persistentInQueue) {
+            persistent.markAsCancelled();
+            cancelled.add(persistent);
+            jobManagerThread.persistentJobQueue.onJobCancelled(persistent);
+        }
+    }
+
+    void commit(JobManagerThread jobManagerThread) {
+        for (JobHolder jobHolder : cancelled) {
+            try {
+                jobHolder.onCancel(CancelReason.CANCELLED_WHILE_RUNNING);
+            } catch (Throwable t) {
+                JqLog.e(t, "job's on cancel has thrown an exception. Ignoring...");
+            }
+            if (jobHolder.getJob().isPersistent()) {
+                jobManagerThread.nonPersistentJobQueue.remove(jobHolder);
+            }
+        }
+        if (callback != null) {
+            Collection<Job> cancelledJobs = new ArrayList<>(cancelled.size());
+            Collection<Job> failedToCancelJobs = new ArrayList<>(failedToCancel.size());
+            for (JobHolder holder : cancelled) {
+                cancelledJobs.add(holder.getJob());
+            }
+            for (JobHolder holder : failedToCancel) {
+                failedToCancelJobs.add(holder.getJob());
+            }
+            CancelResult result = new CancelResult(cancelledJobs, failedToCancelJobs);
+            jobManagerThread.callbackManager.notifyCancelResult(result, callback);
+        }
+        for (JobHolder jobHolder : cancelled) {
+            jobManagerThread.callbackManager.notifyOnCancel(jobHolder.getJob(), true, jobHolder.getThrowable());
+        }
+    }
+
+    void onJobRun(JobHolder holder, int resultCode) {
+        final boolean exists;
+        exists = running.remove(holder.getId());
+        if (exists) {
+            if (resultCode == JobHolder.RUN_RESULT_FAIL_FOR_CANCEL) {
+                cancelled.add(holder);
+            } else {
+                failedToCancel.add(holder);
+            }
+        }
+    }
+
+    boolean isDone() {
+        return running.isEmpty();
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelReason.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelReason.java
new file mode 100644
index 0000000..60fb639
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelReason.java
@@ -0,0 +1,59 @@
+package com.birbit.android.jobqueue;
+
+import android.support.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * A list of possible reasons why a Job was cancelled. A reason will be passed to {@link Job#onCancel(int, Throwable)}.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@IntDef({CancelReason.REACHED_RETRY_LIMIT,
+        CancelReason.CANCELLED_WHILE_RUNNING,
+        CancelReason.SINGLE_INSTANCE_WHILE_RUNNING,
+        CancelReason.CANCELLED_VIA_SHOULD_RE_RUN,
+        CancelReason.SINGLE_INSTANCE_ID_QUEUED})
+public @interface CancelReason {
+
+    /**
+     * Used when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it has reached its retry limit.
+     *
+     * @see Job#getRetryLimit()
+     */
+    int REACHED_RETRY_LIMIT = JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
+
+    /**
+     * Used when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it was cancelled via
+     * {@link JobManager#cancelJobs(TagConstraint, String...)} while it was running.
+     *
+     * @see JobManager#cancelJobs(TagConstraint, String...)
+     * @see JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
+     */
+    int CANCELLED_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+
+    /**
+     * Used when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because another job with the same single instance id was
+     * queued while it was running.
+     *
+     * @see Job#getSingleInstanceId()
+     */
+    int SINGLE_INSTANCE_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_SINGLE_ID;
+
+    /**
+     * Used when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it decided not to run again via
+     * {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+     */
+    int CANCELLED_VIA_SHOULD_RE_RUN = JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+
+    /**
+     * Used when a job was added while another job with the same single instance ID was already
+     * queued and not running. This job got cancelled immediately after being added and will not run.
+     */
+    int SINGLE_INSTANCE_ID_QUEUED = 1;
+
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/CancelResult.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelResult.java
old mode 100755
new mode 100644
similarity index 74%
rename from jobqueue/src/main/java/com/path/android/jobqueue/CancelResult.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/CancelResult.java
index 20fc4e2..47650a9
--- a/jobqueue/src/main/java/com/path/android/jobqueue/CancelResult.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/CancelResult.java
@@ -1,8 +1,7 @@
-package com.path.android.jobqueue;
+package com.birbit.android.jobqueue;
 
 import java.util.Collection;
 import java.util.HashSet;
-import com.path.android.jobqueue.JobManager;
 
 /**
  * This class holds the result of a cancel request via {@link JobManager#cancelJobs(TagConstraint, String...)}
@@ -20,8 +19,13 @@
     Collection<Job> failedToCancel;
 
     public CancelResult() {
-        this.cancelledJobs = new HashSet<Job>();
-        this.failedToCancel = new HashSet<Job>();
+        this.cancelledJobs = new HashSet<>();
+        this.failedToCancel = new HashSet<>();
+    }
+
+    public CancelResult(Collection<Job> cancelledJobs, Collection<Job> failedToCancel) {
+        this.cancelledJobs = cancelledJobs;
+        this.failedToCancel = failedToCancel;
     }
 
     /**
@@ -32,18 +36,18 @@ public CancelResult() {
     }
 
     /**
-     * @return The list of jobs that were running when cancel was called and finished running
+     * @return The list of jobs that were running when cancel was called and onFinished running
      * successfully before they could be cancelled.
      */
     public Collection<Job> getFailedToCancel() {
         return failedToCancel;
     }
 
-    public static interface AsyncCancelCallback {
+    public interface AsyncCancelCallback {
 
         /**
          * When job cancellation is complete, this method is called by the JobManager.
          */
-        public void onCancelled(CancelResult cancelResult);
+        void onCancelled(CancelResult cancelResult);
     }
 }
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/Constraint.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/Constraint.java
new file mode 100644
index 0000000..8d49bc5
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/Constraint.java
@@ -0,0 +1,170 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import static com.birbit.android.jobqueue.network.NetworkUtil.DISCONNECTED;
+import static com.birbit.android.jobqueue.network.NetworkUtil.UNMETERED;
+
+/**
+ * This class is used when querying JobQueues to fetch particular jobs.
+ * <p>
+ * JobQueues should not reference this class after the query method returns because Constraints are
+ * re-used by the JobManager.
+ */
+public class Constraint {
+    private boolean shouldNotRequireNetwork;
+    private boolean shouldNotRequireUnmeteredNetwork;
+    private TagConstraint tagConstraint;
+    private final Set<String> tags = new HashSet<>();
+    private final List<String> excludeGroups = new ArrayList<>();
+    private final List<String> excludeJobIds = new ArrayList<>();
+    private boolean excludeRunning;
+    private Long timeLimit;
+    private long nowInNs;
+    /**
+     * Returns true if the network is currently not available.
+     *
+     * @return True if network connection is currently unavailable, false otherwise.
+     */
+    public boolean shouldNotRequireNetwork() {
+        return shouldNotRequireNetwork;
+    }
+
+    /**
+     * Returns true if the unmetered network is currently not available.
+     *
+     * @return True if the unmetered network connection is currently unavailable, false otherwise.
+     */
+    public boolean shouldNotRequireUnmeteredNetwork() {
+        return shouldNotRequireUnmeteredNetwork;
+    }
+
+    /**
+     * The tag constraint to be used while querying with tags.
+     *
+     * @return The tag constraint to be used or null if there is no tag constraints.
+     * @see #getTags()
+     */
+    public TagConstraint getTagConstraint() {
+        return tagConstraint;
+    }
+
+    /**
+     * The set of tags. If this list is not-empty, {@link #getTagConstraint()} will have a non-null
+     * result.
+     *
+     * @return The set of tags
+     * @see #getTagConstraint()
+     */
+    public Set<String> getTags() {
+        return tags;
+    }
+
+    /**
+     * The list of groups to be excluded. It is guaranteed to be ordered in natural string sorting
+     * order.
+     *
+     * @return The set of job groups to exclude.
+     */
+    public List<String> getExcludeGroups() {
+        return excludeGroups;
+    }
+
+    /**
+     * Returns true if running jobs should be excluded from the query
+     * @return True if running jobs should be excluded
+     */
+    public boolean excludeRunning() {
+        return excludeRunning;
+    }
+
+    /**
+     * Exclude jobs whose run time is after this time. Might be null if there is no time limit.
+     * @return Time in NS which should be used to filter out delayed jobs
+     */
+    public Long getTimeLimit() {
+        return timeLimit;
+    }
+
+    /**
+     * The list of jobs ids that should be excluded from the result
+     * @return The list of job ids that should be excluded from the result
+     */
+    public List<String> getExcludeJobIds() {
+        return excludeJobIds;
+    }
+
+    void setShouldNotRequireNetwork(boolean shouldNotRequireNetwork) {
+        this.shouldNotRequireNetwork = shouldNotRequireNetwork;
+    }
+
+    void setShouldNotRequireUnmeteredNetwork(boolean shouldNotRequireUnmeteredNetwork) {
+        this.shouldNotRequireUnmeteredNetwork = shouldNotRequireUnmeteredNetwork;
+    }
+
+    void setTagConstraint(TagConstraint tagConstraint) {
+        this.tagConstraint = tagConstraint;
+    }
+
+    void setExcludeRunning(boolean excludeRunning) {
+        this.excludeRunning = excludeRunning;
+    }
+
+    void setTags(String[] tags) {
+        this.tags.clear();
+        if (tags != null) {
+            Collections.addAll(this.tags, tags);
+        }
+    }
+
+    public void setNowInNs(long nowInNs) {
+        this.nowInNs = nowInNs;
+    }
+
+    void setExcludeGroups(Collection<String> excludeGroups) {
+        this.excludeGroups.clear();
+        if (excludeGroups != null) {
+            this.excludeGroups.addAll(excludeGroups);
+        }
+    }
+
+    void setExcludeJobIds(Collection<String> jobsIds) {
+        this.excludeJobIds.clear();
+        if (jobsIds != null) {
+            this.excludeJobIds.addAll(jobsIds);
+        }
+    }
+
+    public long getNowInNs() {
+        return nowInNs;
+    }
+
+    void setTimeLimit(Long timeLimit) {
+        this.timeLimit = timeLimit;
+    }
+
+    void clear() {
+        shouldNotRequireNetwork = false;
+        shouldNotRequireUnmeteredNetwork = false;
+        tagConstraint = null;
+        tags.clear();
+        excludeGroups.clear();
+        excludeJobIds.clear();
+        excludeRunning = false;
+        timeLimit = null;
+        nowInNs = Long.MIN_VALUE;
+    }
+
+    void setNetworkStatus(@NetworkUtil.NetworkStatus int connectionStatus) {
+        setShouldNotRequireNetwork(connectionStatus == DISCONNECTED);
+        setShouldNotRequireUnmeteredNetwork(connectionStatus != UNMETERED);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/ConsumerManager.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/ConsumerManager.java
new file mode 100644
index 0000000..5b2c493
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/ConsumerManager.java
@@ -0,0 +1,414 @@
+package com.birbit.android.jobqueue;
+
+import android.support.annotation.NonNull;
+
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.MessageFactory;
+import com.birbit.android.jobqueue.messaging.MessagePredicate;
+import com.birbit.android.jobqueue.messaging.MessageQueue;
+import com.birbit.android.jobqueue.messaging.MessageQueueConsumer;
+import com.birbit.android.jobqueue.messaging.SafeMessageQueue;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.JobConsumerIdleMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobResultMessage;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * This class is responsible to communicate with the Workers(consumers) that run the jobs.
+ * It run's on {@link JobManagerThread}'s thread and directly controlled by it using its message
+ * queue.
+ */
+class ConsumerManager {
+
+    private List<Consumer> waitingConsumers = new ArrayList<>();
+
+    private final List<Consumer> consumers = new ArrayList<>();
+
+    private final int maxConsumerCount;
+
+    private final int minConsumerCount;
+
+    private final long consumerKeepAliveNs;
+
+    private final int threadPriority;
+
+    private final int loadFactor;
+
+    private final ThreadGroup threadGroup;
+
+    private final JobManagerThread jobManagerThread;
+
+    private final Timer timer;
+
+    private final MessageFactory factory;
+
+    private final Map<String, JobHolder> runningJobHolders;
+
+    final RunningJobSet runningJobGroups;
+
+    private final ThreadFactory threadFactory;
+
+    private final CopyOnWriteArrayList<Runnable> internalZeroConsumersListeners
+            = new CopyOnWriteArrayList<>();
+
+    ConsumerManager(JobManagerThread jobManagerThread, Timer timer, MessageFactory factory,
+            Configuration configuration) {
+        this.jobManagerThread = jobManagerThread;
+        this.timer = timer;
+        this.factory = factory;
+        this.loadFactor = configuration.getLoadFactor();
+        this.minConsumerCount = configuration.getMinConsumerCount();
+        this.maxConsumerCount = configuration.getMaxConsumerCount();
+        this.consumerKeepAliveNs = configuration.getConsumerKeepAlive() * 1000
+                * JobManagerThread.NS_PER_MS;
+        this.threadPriority = configuration.getThreadPriority();
+        this.threadFactory = configuration.getThreadFactory();
+        runningJobHolders = new HashMap<>();
+        runningJobGroups = new RunningJobSet(timer);
+        threadGroup = new ThreadGroup("JobConsumers");
+    }
+
+    void addNoConsumersListener(Runnable runnable) {
+        internalZeroConsumersListeners.add(runnable);
+    }
+
+    boolean removeNoConsumersListener(Runnable runnable) {
+        return internalZeroConsumersListeners.remove(runnable);
+    }
+
+    void onJobAdded() {
+        considerAddingConsumers(false);
+    }
+
+    void handleConstraintChange() {
+        considerAddingConsumers(true);
+    }
+
+    void handleStop() {
+        // poke everybody so we can kill them
+        for (Consumer consumer : consumers) {
+            SafeMessageQueue mq = consumer.messageQueue;
+            CommandMessage command = factory.obtain(CommandMessage.class);
+            command.set(CommandMessage.POKE);
+            mq.post(command);
+        }
+        if (consumers.isEmpty()) {
+            for (Runnable runnable : internalZeroConsumersListeners) {
+                runnable.run();
+            }
+        }
+    }
+
+    private void considerAddingConsumers(boolean pokeAllWaiting) {
+        JqLog.d("considering adding a new consumer. Should poke all waiting? %s isRunning? %s"
+                        + " waiting workers? %d"
+                , pokeAllWaiting, jobManagerThread.isRunning(), waitingConsumers.size());
+        if (!jobManagerThread.isRunning()) {
+            JqLog.d("jobqueue is not running, no consumers will be added");
+            return;
+        }
+        if (waitingConsumers.size() > 0) {
+            JqLog.d("there are waiting workers, will poke them instead");
+            for (int i = waitingConsumers.size() - 1; i >= 0; i--) {
+                Consumer consumer = waitingConsumers.remove(i);
+                CommandMessage command = factory.obtain(CommandMessage.class);
+                command.set(CommandMessage.POKE);
+                consumer.messageQueue.post(command);
+                if (!pokeAllWaiting) {
+                    break;
+                }
+            }
+            JqLog.d("there were waiting workers, poked them and I'm done");
+            return;
+        }
+        boolean isAboveLoadFactor = isAboveLoadFactor();
+        JqLog.d("nothing has been poked. are we above load factor? %s", isAboveLoadFactor);
+        if (isAboveLoadFactor) {
+            addWorker();
+        }
+    }
+
+    private void addWorker() {
+        JqLog.d("adding another consumer");
+        Consumer consumer = new Consumer(jobManagerThread.messageQueue,
+                new SafeMessageQueue(timer, factory, "consumer"), factory, timer);
+        final Thread thread;
+        if (threadFactory != null) {
+            thread = threadFactory.newThread(consumer);
+        } else {
+            thread = new Thread(threadGroup, consumer, "job-queue-worker-" + UUID.randomUUID());
+            thread.setPriority(threadPriority);
+        }
+        consumers.add(consumer);
+        thread.start();
+    }
+
+    private boolean isAboveLoadFactor() {
+        final int workerCount = consumers.size();
+        if (workerCount >= maxConsumerCount) {
+            JqLog.d("too many consumers, clearly above load factor %s", workerCount);
+            return false;
+        }
+        final int remainingJobs = jobManagerThread.countRemainingReadyJobs();
+        final int runningHolders = runningJobHolders.size();
+
+        boolean aboveLoadFactor = (workerCount * loadFactor < remainingJobs + runningHolders) ||
+                (workerCount < minConsumerCount && workerCount < remainingJobs + runningHolders);
+        JqLog.d("check above load factor: totalCons:%s minCons:%s maxConsCount: %s, loadFactor %s"
+                        + " remainingJobs: %s runningsHolders: %s. isAbove:%s", workerCount,
+                minConsumerCount, maxConsumerCount, loadFactor, remainingJobs, runningHolders,
+                aboveLoadFactor);
+        return aboveLoadFactor;
+    }
+
+    /**
+     * @return true if consumer received a job or busy, false otherwise
+     */
+    boolean handleIdle(@NonNull JobConsumerIdleMessage message) {
+        Consumer consumer = (Consumer) message.getWorker();
+        if (consumer.hasJob) {
+            return true;// ignore, it has a job to process.
+        }
+        JobHolder nextJob = null;
+        final boolean running = jobManagerThread.isRunning();
+        if (running) {
+            nextJob = jobManagerThread.getNextJob(runningJobGroups.getSafe());
+        }
+        if (nextJob != null) {
+            consumer.hasJob = true;
+            runningJobGroups.add(nextJob.getGroupId());
+            RunJobMessage runJobMessage = factory.obtain(RunJobMessage.class);
+            runJobMessage.setJobHolder(nextJob);
+            runningJobHolders.put(nextJob.getJob().getId(), nextJob);
+            if (nextJob.getGroupId() != null) {
+                runningJobGroups.add(nextJob.getGroupId());
+            }
+            consumer.messageQueue.post(runJobMessage);
+            return true;
+        } else {
+            long keepAliveTimeout = message.getLastJobCompleted() + consumerKeepAliveNs;
+            JqLog.d("keep alive: %s", keepAliveTimeout);
+            final boolean tooMany = consumers.size() > minConsumerCount;
+            boolean kill = !running || (tooMany && keepAliveTimeout < timer.nanoTime());
+            JqLog.d("Consumer idle, will kill? %s . isRunning: %s", kill, running);
+            if (kill) {
+                CommandMessage command = factory.obtain(CommandMessage.class);
+                command.set(CommandMessage.QUIT);
+                consumer.messageQueue.post(command);
+                waitingConsumers.remove(consumer);
+                consumers.remove(consumer);
+                JqLog.d("killed consumers. remaining consumers %d", consumers.size());
+                if (consumers.isEmpty() && internalZeroConsumersListeners != null) {
+                    for (Runnable runnable : internalZeroConsumersListeners) {
+                        runnable.run();
+                    }
+                }
+            } else {
+                if (!waitingConsumers.contains(consumer)) {
+                    waitingConsumers.add(consumer);
+                }
+                if (tooMany || !jobManagerThread.canListenToNetwork()) {
+                    CommandMessage cm = factory.obtain(CommandMessage.class);
+                    cm.set(CommandMessage.POKE);
+                    if (!tooMany) {
+                        keepAliveTimeout = timer.nanoTime() + consumerKeepAliveNs;
+                    }
+                    consumer.messageQueue.postAt(cm, keepAliveTimeout);
+                    JqLog.d("poke consumer manager at %s", keepAliveTimeout);
+                }
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Excludes cancelled jobs
+     */
+    Set<String> markJobsCancelled(TagConstraint constraint, String[] tags) {
+        return markJobsCancelled(constraint, tags, false);
+    }
+
+    Set<String> markJobsCancelledSingleId(TagConstraint constraint, String[] tags) {
+        return markJobsCancelled(constraint, tags, true);
+    }
+
+    private Set<String> markJobsCancelled(TagConstraint constraint, String[] tags, boolean singleId) {
+        Set<String> result = new HashSet<>();
+        for (JobHolder holder : runningJobHolders.values()) {
+            JqLog.d("checking job tag %s. tags of job: %s", holder.getJob(),
+                    holder.getJob().getTags());
+            if (!holder.hasTags()) {
+                continue;
+            }
+            if (holder.isCancelled()) {
+                continue;
+            }
+
+            if (constraint.matches(tags, holder.getTags())) {
+                result.add(holder.getId());
+                if (singleId) {
+                    holder.markAsCancelledSingleId();
+                } else {
+                    holder.markAsCancelled();
+                }
+            }
+        }
+        return result;
+    }
+
+    void handleRunJobResult(RunJobResultMessage message, JobHolder jobHolder,
+            RetryConstraint retryConstraint) {
+        Consumer consumer = (Consumer) message.getWorker();
+        if (!consumer.hasJob) {
+            throw new IllegalStateException("this worker should not have a job");
+        }
+        consumer.hasJob = false;
+        runningJobHolders.remove(jobHolder.getJob().getId());
+        if (jobHolder.getGroupId() != null) {
+            runningJobGroups.remove(jobHolder.getGroupId());
+            if (retryConstraint != null && retryConstraint.willApplyNewDelayToGroup()
+                    && retryConstraint.getNewDelayInMs() > 0) {
+                runningJobGroups.addGroupUntil(jobHolder.getGroupId(),
+                        timer.nanoTime()
+                                + retryConstraint.getNewDelayInMs() * JobManagerThread.NS_PER_MS);
+            }
+        }
+    }
+
+    boolean isJobRunning(String id) {
+        return runningJobHolders.get(id) != null;
+    }
+
+    public int getWorkerCount() {
+        return consumers.size();
+    }
+
+    public boolean hasJobsWithSchedulerConstraint(SchedulerConstraint constraint, long nowInNs) {
+        for (JobHolder jobHolder : runningJobHolders.values()) {
+            if (!jobHolder.getJob().isPersistent()) {
+                continue;
+            }
+            if(constraint.getNetworkStatus() == NetworkUtil.METERED
+                    && jobHolder.requiresNetwork(nowInNs)) {
+                // this will conver any unmeted job :/
+                return true;
+            }
+            if (constraint.getNetworkStatus() == NetworkUtil.UNMETERED
+                    && jobHolder.requiresUnmeteredNetwork(nowInNs)) {
+                return true;
+            }
+            // TODO we are missing delayed jobs here because we don't trigger based on it.
+        }
+        return false;
+    }
+
+    public boolean areAllConsumersIdle() {
+        return waitingConsumers.size() == consumers.size();
+    }
+
+    static class Consumer implements Runnable {
+
+        final SafeMessageQueue messageQueue;
+
+        final MessageQueue parentMessageQueue;
+
+        final MessageFactory factory;
+
+        final Timer timer;
+
+        boolean hasJob;// controlled by the consumer controller to avoid multiple idle-job loops
+
+        long lastJobCompleted;
+
+        static final MessagePredicate pokeMessagePredicate =
+                new MessagePredicate() {
+                    @Override
+                    public boolean onMessage(Message message) {
+                        return message.type == Type.COMMAND &&
+                                ((CommandMessage) message).getWhat() == CommandMessage.POKE;
+                    }
+                };
+
+        final MessageQueueConsumer queueConsumer = new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                switch (message.type) {
+                    case RUN_JOB:
+                        handleRunJob((RunJobMessage) message);
+                        lastJobCompleted = timer.nanoTime();
+                        removePokeMessages();
+                        break;
+                    case COMMAND:
+                        handleCommand((CommandMessage) message);
+                        break;
+                }
+            }
+
+            @Override
+            public void onIdle() {
+                JqLog.d("consumer manager on idle");
+                JobConsumerIdleMessage idle = factory.obtain(JobConsumerIdleMessage.class);
+                idle.setWorker(Consumer.this);
+                idle.setLastJobCompleted(lastJobCompleted);
+                parentMessageQueue.post(idle);
+            }
+        };
+
+        private void removePokeMessages() {
+            messageQueue.cancelMessages(pokeMessagePredicate);
+        }
+
+        public Consumer(MessageQueue parentMessageQueue, SafeMessageQueue messageQueue,
+                MessageFactory factory, Timer timer) {
+            this.messageQueue = messageQueue;
+            this.factory = factory;
+            this.parentMessageQueue = parentMessageQueue;
+            this.timer = timer;
+            this.lastJobCompleted = timer.nanoTime();
+        }
+
+        @Override
+        public void run() {
+            messageQueue.consume(queueConsumer);
+        }
+
+        private void handleCommand(CommandMessage message) {
+            switch (message.getWhat()) {
+                case CommandMessage.QUIT:
+                    messageQueue.stop();
+                    break;
+                case CommandMessage.POKE:
+                    // just woke me up, let idle handle
+                    JqLog.d("Consumer has been poked.");
+                    break;
+            }
+        }
+
+        private void handleRunJob(RunJobMessage message) {
+            JqLog.d("running job %s", message.getJobHolder().getClass().getSimpleName());
+            JobHolder jobHolder = message.getJobHolder();
+            int result = jobHolder.safeRun(jobHolder.getRunCount());
+            RunJobResultMessage resultMessage = factory.obtain(RunJobResultMessage.class);
+            resultMessage.setJobHolder(jobHolder);
+            resultMessage.setResult(result);
+            resultMessage.setWorker(this);
+            parentMessageQueue.post(resultMessage);
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/DefaultQueueFactory.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/DefaultQueueFactory.java
new file mode 100644
index 0000000..d2900e9
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/DefaultQueueFactory.java
@@ -0,0 +1,34 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.inMemoryQueue.SimpleInMemoryPriorityQueue;
+import com.birbit.android.jobqueue.*;
+import com.birbit.android.jobqueue.cachedQueue.CachedJobQueue;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
+
+/**
+ * Default implementation of QueueFactory that creates one {@link SqliteJobQueue} and
+ * one {@link SimpleInMemoryPriorityQueue} both are wrapped inside a {@link CachedJobQueue} to
+ * improve performance
+ */
+public class DefaultQueueFactory implements QueueFactory {
+    SqliteJobQueue.JobSerializer jobSerializer;
+
+    public DefaultQueueFactory() {
+        jobSerializer = new SqliteJobQueue.JavaSerializer();
+    }
+
+    public DefaultQueueFactory(SqliteJobQueue.JobSerializer jobSerializer) {
+        this.jobSerializer = jobSerializer;
+    }
+
+    @Override
+    public JobQueue createPersistentQueue(Configuration configuration, long sessionId) {
+        return new CachedJobQueue(new SqliteJobQueue(configuration, sessionId, jobSerializer));
+    }
+
+    @Override
+    public JobQueue createNonPersistent(Configuration configuration, long sessionId) {
+        return new CachedJobQueue(new SimpleInMemoryPriorityQueue(configuration, sessionId));
+    }
+}
\ No newline at end of file
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/IntCallback.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/IntCallback.java
new file mode 100644
index 0000000..6c8339a
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/IntCallback.java
@@ -0,0 +1,11 @@
+package com.birbit.android.jobqueue;
+
+/**
+ * Internal interface to mimic sync requests.
+ */
+public interface IntCallback {
+    void onResult(int result);
+    interface MessageWithCallback {
+        void setCallback(IntCallback intCallback);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/Job.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/Job.java
new file mode 100644
index 0000000..1e310b9
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/Job.java
@@ -0,0 +1,479 @@
+package com.birbit.android.jobqueue;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Base class for all of your jobs.
+ */
+@SuppressWarnings("deprecation")
+abstract public class Job implements Serializable {
+    private static final long serialVersionUID = 3L;
+    public static final int DEFAULT_RETRY_LIMIT = 20;
+    private static final String SINGLE_ID_TAG_PREFIX = "job-single-id:";
+    private String id = UUID.randomUUID().toString();
+    private long requiresNetworkUntilNs = Params.NEVER;
+    transient private long requiresNetworkTimeoutMs = 0;
+    private long requiresUnmeteredNetworkUntilNs = Params.NEVER;
+    transient private long requiresUnmeteredNetworkTimeoutMs = 0;
+    private String groupId;
+    private boolean persistent;
+    private Set<String> readonlyTags;
+
+    private transient int currentRunCount;
+    transient int priority;
+    private transient long delayInMs;
+    transient boolean cancelled;
+
+    private transient Context applicationContext;
+
+    /**
+     * Only set if a job fails. Will be cleared by JobManager after it is handled
+     */
+    transient RetryConstraint retryConstraint;
+    private transient boolean sealed;
+
+
+    protected Job(Params params) {
+        this.requiresNetworkTimeoutMs = params.getRequiresNetworkTimeoutMs();
+        this.requiresUnmeteredNetworkTimeoutMs = params.getRequiresUnmeteredNetworkTimeoutMs();
+        this.persistent = params.isPersistent();
+        this.groupId = params.getGroupId();
+        this.priority = params.getPriority();
+        this.delayInMs = params.getDelayMs();
+        final String singleId = params.getSingleId();
+        if (params.getTags() != null || singleId != null) {
+            final Set<String> tags = params.getTags() != null ? params.getTags() : new HashSet<String>();
+            if (singleId != null) {
+                final String tagForSingleId = createTagForSingleId(singleId);
+                tags.add(tagForSingleId);
+                if (this.groupId == null) {
+                    this.groupId = tagForSingleId;
+                }
+            }
+            this.readonlyTags = Collections.unmodifiableSet(tags);
+        }
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * used by {@link JobManager} to assign proper priority at the time job is added.
+     * @return priority (higher = better)
+     */
+    public final int getPriority() {
+        return priority;
+    }
+
+    /**
+     * used by {@link JobManager} to assign proper delay at the time job is added.
+     * This field is not persisted!
+     * @return delay in ms
+     */
+    public final long getDelayInMs() {
+        return delayInMs;
+    }
+
+    /**
+     * Returns a readonly set of tags attached to this Job.
+     * @return Set of Tags. If tags do not exists, returns null.
+     */
+    public final Set<String> getTags() {
+        return readonlyTags;
+    }
+
+    private void writeObject(ObjectOutputStream oos) throws IOException {
+        if (!sealed) {
+            throw new IllegalStateException("A job cannot be serialized w/o first being added into"
+                    + " a job manager.");
+        }
+        oos.writeLong(requiresNetworkUntilNs);
+        oos.writeLong(requiresUnmeteredNetworkUntilNs);
+        oos.writeObject(groupId);
+        oos.writeBoolean(persistent);
+        final int tagCount = readonlyTags == null ? 0 : readonlyTags.size();
+        oos.writeInt(tagCount);
+        if (tagCount > 0) {
+            for (String tag : readonlyTags) {
+                oos.writeUTF(tag);
+            }
+        }
+        oos.writeUTF(id);
+    }
+
+
+    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
+        requiresNetworkUntilNs = ois.readLong();
+        requiresUnmeteredNetworkUntilNs = ois.readLong();
+        groupId = (String) ois.readObject();
+        persistent = ois.readBoolean();
+        final int tagCount = ois.readInt();
+        if (tagCount > 0) {
+            readonlyTags = new HashSet<>(tagCount);
+            for (int i = 0; i < tagCount; i ++) {
+                readonlyTags.add(ois.readUTF());
+            }
+        }
+        id = ois.readUTF();
+        sealed = true; //  deserialized jobs are sealed
+    }
+
+    /**
+     * defines if we should add this job to disk or non-persistent queue
+     */
+    public final boolean isPersistent() {
+        return persistent;
+    }
+
+    /**
+     * Called when the job is added to disk and committed.
+     * This means job will eventually run. This is a good time to update local database and dispatch events.
+     * <p>
+     * Changes to this class will not be preserved if your job is persistent !!!
+     * <p>
+     * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
+     * <p>
+     * Note that this method is called on JobManager's thread and will block any other action so
+     * it should be fast and not make any web requests (File IO is OK).
+     */
+    abstract public void onAdded();
+
+    /**
+     * The actual method that should to the work.
+     * It should finish w/o any exception. If it throws any exception,
+     * {@link #shouldReRunOnThrowable(Throwable, int, int)} will be called to
+     * decide either to dismiss the job or re-run it.
+     * @throws Throwable
+     */
+    abstract public void onRun() throws Throwable;
+
+    /**
+     * Called when a job is cancelled.
+     * @param cancelReason It is one of:
+     *                   <ul>
+     *                   <li>{@link CancelReason#REACHED_RETRY_LIMIT}</li>
+     *                   <li>{@link CancelReason#CANCELLED_VIA_SHOULD_RE_RUN}</li>
+     *                   <li>{@link CancelReason#CANCELLED_WHILE_RUNNING}</li>
+     *                   <li>{@link CancelReason#SINGLE_INSTANCE_WHILE_RUNNING}</li>
+     *                   <li>{@link CancelReason#SINGLE_INSTANCE_ID_QUEUED}</li>
+     *                   </ul>
+     * @param throwable The exception that was thrown from the last execution of {@link #onRun()}
+     */
+    abstract protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable);
+
+    /**
+     * If {@code onRun} method throws an exception, this method is called.
+     * <p>
+     * If you simply want to return retry or cancel, you can use {@link RetryConstraint#RETRY} or
+     * {@link RetryConstraint#CANCEL}.
+     * <p>
+     * You can also use a custom {@link RetryConstraint} where you can change the Job's priority or
+     * add a delay until the next run (e.g. exponential back off).
+     * <p>
+     * Note that changing the Job's priority or adding a delay may alter the original run order of
+     * the job. So if the job was added to the queue with other jobs and their execution order is
+     * important (e.g. they use the same groupId), you should not change job's priority or add a
+     * delay unless you really want to change their execution order.
+     *
+     * @param throwable The exception that was thrown from {@link #onRun()}
+     * @param runCount The number of times this job run. Starts from 1.
+     * @param maxRunCount The max number of times this job can run. Decided by {@link #getRetryLimit()}
+     * @return A {@link RetryConstraint} to decide whether this Job should be tried again or not and
+     * if yes, whether we should add a delay or alter its priority. Returning null from this method
+     * is equal to returning {@link RetryConstraint#RETRY}. Default implementation calls
+     * {@link #shouldReRunOnThrowable(Throwable, int, int)}}.
+     */
+    abstract protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount);
+
+    /**
+     * Runs the job and catches any exception
+     * @param currentRunCount
+     * @return one of the RUN_RESULT ints
+     */
+    final int safeRun(JobHolder holder, int currentRunCount) {
+        this.currentRunCount = currentRunCount;
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("running job %s", this.getClass().getSimpleName());
+        }
+        boolean reRun = false;
+        boolean failed = false;
+        Throwable throwable = null;
+        try {
+            onRun();
+            if (JqLog.isDebugEnabled()) {
+                JqLog.d("finished job %s", this);
+            }
+        } catch (Throwable t) {
+            failed = true;
+            throwable = t;
+            JqLog.e(t, "error while executing job %s", this);
+            reRun = currentRunCount < getRetryLimit();
+            if(reRun && !cancelled) {
+                try {
+                    RetryConstraint retryConstraint = shouldReRunOnThrowable(t, currentRunCount,
+                            getRetryLimit());
+                    if (retryConstraint == null) {
+                        retryConstraint = RetryConstraint.RETRY;
+                    }
+                    this.retryConstraint = retryConstraint;
+                    reRun = retryConstraint.shouldRetry();
+                } catch (Throwable t2) {
+                    JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
+                }
+            }
+        }
+        JqLog.d("safeRunResult for %s : %s. re run:%s. cancelled: %s", this, !failed, reRun, cancelled);
+        if (!failed) {
+            return JobHolder.RUN_RESULT_SUCCESS;
+        }
+        if (holder.isCancelledSingleId()) {
+            return JobHolder.RUN_RESULT_FAIL_SINGLE_ID;
+        }
+        if (holder.isCancelled()) {
+            return JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+        }
+        if (reRun) {
+            return JobHolder.RUN_RESULT_TRY_AGAIN;
+        }
+        if (currentRunCount < getRetryLimit()) {
+            return JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+        } else {
+            // only set the Throwable if we are sure the Job is not gonna run again
+            holder.setThrowable(throwable);
+            return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
+        }
+    }
+
+    /**
+     * before each run, JobManager sets this number. Might be useful for the {@link com.birbit.android.jobqueue.Job#onRun()}
+     * method
+     */
+    protected int getCurrentRunCount() {
+        return currentRunCount;
+    }
+
+    /**
+     * if job is set to require network, it will not be called unless
+     * {@link com.birbit.android.jobqueue.network.NetworkUtil} reports that there is a network
+     * connection or the wait times out if a timeout was provided in
+     * {@link Params#requireNetworkWithTimeout(long)}.
+     *
+     * @param timer The timer used by the JobManager. Should be the timer that was used while
+     *                configuring the JobManager ({@link Configuration#getTimer()},
+     *                {@link com.birbit.android.jobqueue.config.Configuration.Builder#timer}).
+     */
+    public final boolean requiresNetwork(Timer timer) {
+        return sealed ? requiresNetworkUntilNs > timer.nanoTime()
+                : requiresNetworkTimeoutMs != Params.NEVER;
+    }
+
+    /**
+     * if job is set to require a UNMETERED network, it will not be run unless
+     * {@link com.birbit.android.jobqueue.network.NetworkUtil} reports that there is a UNMETERED network
+     * connection or the wait times out if a timeout was provided in
+     * {@link Params#requireUnmeteredNetworkWithTimeout(long)}.
+     *
+     * @param timer The timer used by the JobManager. Should be the timer that was used while
+     *                configuring the JobManager ({@link Configuration#getTimer()},
+     *                {@link com.birbit.android.jobqueue.config.Configuration.Builder#timer}).
+     */
+    public final boolean requiresUnmeteredNetwork(Timer timer) {
+        return sealed ? requiresUnmeteredNetworkUntilNs > timer.nanoTime()
+                : requiresUnmeteredNetworkTimeoutMs != Params.NEVER;
+    }
+
+    /**
+     * Returns whether job requires a network connection to be run or not, without checking the
+     * timeout. This is convenient since it does not require a reference to the Timer if you are
+     * not using Jobs with requireNetwork with a timeout.
+     *
+     * @return True if job requires a network to be run, false otherwise.
+     */
+    public final boolean requiresNetworkIgnoreTimeout() {
+        return sealed ? requiresNetworkUntilNs > 0
+                : requiresNetworkTimeoutMs > 0;
+    }
+
+    /**
+     * Returns whether job requires a unmetered network connection to be run or not, without
+     * checking the timeout. This is convenient since it does not require a reference to the Timer
+     * if you are not using Jobs with requireUnmeteredNetwork with a timeout.
+     *
+     * @return True if job requires a unmetered network to be run, false otherwise.
+     */
+    public final boolean requiresUnmeteredNetworkIgnoreTimeout() {
+        return sealed ? requiresUnmeteredNetworkUntilNs > 0
+                : requiresUnmeteredNetworkTimeoutMs > 0;
+    }
+
+    /**
+     * Returns until which timestamp this Job will require a UNMETERED network connection to be run.
+     * <p>
+     * This value can be queried only after {@link Job#onAdded()} method is called.
+     * <ul>
+     * <li>If the job does not require a UNMETERED network, it will return {@link Params#NEVER}.</li>
+     * <li>If the job should never be run without a UNMETERED network, it will return {@link Params#FOREVER}.</li>
+     * <li>Otherwise, it will return the time in ns until which the job should require a UNMETERED network
+     * to be run and after that timeout it will be run regardless of the network requirements.</li>
+     * </ul>
+     * @return The timestamp (in ns) until which the job will require a network connection to be
+     * run.
+     */
+    public long getRequiresUnmeteredNetworkUntilNs() {
+        return requiresUnmeteredNetworkUntilNs;
+    }
+
+    /**
+     * Returns until which timestamp this Job will require a network connection to be run.
+     * <p>
+     * This value can be queried only after {@link Job#onAdded()} method is called.
+     * <ul>
+     * <li>If the job does not require network, it will return {@link Params#NEVER}.</li>
+     * <li>If the job should never be run without network, it will return {@link Params#FOREVER}.</li>
+     * <li>Otherwise, it will return the time in ns until which the job should require network
+     * to be run and after that timeout it will be run regardless of the network requirements.</li>
+     * </ul>
+     * @return The timestamp (in ns) until which the job will require a network connection to be
+     * run.
+     */
+    public long getRequiresNetworkUntilNs() {
+        return requiresNetworkUntilNs;
+    }
+
+    /**
+     * Some jobs may require being run synchronously. For instance, if it is a job like sending a comment, we should
+     * never run them in parallel (unless they are being sent to different conversations).
+     * By assigning same groupId to jobs, you can ensure that that type of jobs will be run in the order they were given
+     * (if their priority is the same).
+     *
+     * @return The groupId of the job or null if it is not grouped
+     */
+    public final String getRunGroupId() {
+        return groupId;
+    }
+
+    /**
+     * Some jobs only need a single instance to be queued to run. For instance, if a user has made several changes
+     * to a resource while offline, you can save every change locally during {@link #onAdded()}, but
+     * only update the resource remotely once with the latest changes.
+     *
+     * @return The single instance id of the job or null if it is not a single instance job
+     */
+    public final String getSingleInstanceId() {
+        if (readonlyTags != null) {
+            for (String tag : readonlyTags) {
+                if (tag.startsWith(SINGLE_ID_TAG_PREFIX)) {
+                    return tag;
+                }
+            }
+        }
+        return null;
+    }
+
+    private String createTagForSingleId(String singleId) {
+        return SINGLE_ID_TAG_PREFIX + singleId;
+    }
+
+    /**
+     * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
+     * If job fails this many times, onCancel will be called w/o calling {@link #shouldReRunOnThrowable(Throwable, int, int)}
+     *
+     * @return The number of times the job should be re-tried before being cancelled automatically
+     */
+    protected int getRetryLimit() {
+        return DEFAULT_RETRY_LIMIT;
+    }
+
+    /**
+     * Returns true if job is cancelled. Note that if the job is already running when it is cancelled,
+     * this flag is still set to true but job is NOT STOPPED (e.g. JobManager does not interrupt
+     * the thread).
+     * If you have a long job that may be cancelled, you can check this field and handle it manually.
+     * <p>
+     * Note that, if your job returns successfully from {@link #onRun()} method, it will be considered
+     * as successfully completed, thus will be added to {@link CancelResult#getFailedToCancel()}
+     * list. If you want this job to be considered as cancelled, you should throw an exception.
+     * You can also use {@link #assertNotCancelled()} method to do it.
+     * <p>
+     * Calling this method outside {@link #onRun()} method has no meaning since {@link #onRun()} will not
+     * be called if the job is cancelled before it is called.
+     */
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    /**
+     * Convenience method that checks if job is cancelled and throws a RuntimeException if it is
+     * cancelled.
+     */
+    public void assertNotCancelled() {
+        if (cancelled) {
+            throw new RuntimeException("job is cancelled");
+        }
+    }
+
+    /*package*/ void setApplicationContext(Context context) {
+        this.applicationContext = context;
+    }
+
+    /**
+     * Convenience method to get the application context in a Job.
+     * <p>
+     * This context is set when job is added to a JobManager.
+     *
+     * @return The application context
+     */
+    public Context getApplicationContext() {
+        return applicationContext;
+    }
+
+    /**
+     * Internal method used by the JobManager when it is added. After this point, you cannot make
+     * any changes to this job.
+     */
+    public void seal(Timer timer) {
+        if (sealed) {
+            throw new IllegalStateException("Cannot add the same job twice");
+        }
+        if (requiresNetworkTimeoutMs == Params.NEVER) {
+            // convert it from nano
+            requiresNetworkUntilNs = Params.NEVER;
+        } else if (requiresNetworkTimeoutMs == Params.FOREVER) {
+            requiresNetworkUntilNs = Params.FOREVER;
+        } else {
+            requiresNetworkUntilNs = timer.nanoTime()
+                    + TimeUnit.MILLISECONDS.toNanos(requiresNetworkTimeoutMs);
+        }
+
+        if (requiresUnmeteredNetworkTimeoutMs == Params.NEVER) {
+            // convert it from nano
+            requiresUnmeteredNetworkUntilNs = Params.NEVER;
+        } else if (requiresUnmeteredNetworkTimeoutMs == Params.FOREVER) {
+            requiresUnmeteredNetworkUntilNs = Params.FOREVER;
+        } else {
+            requiresUnmeteredNetworkUntilNs = timer.nanoTime()
+                    + TimeUnit.MILLISECONDS.toNanos(requiresUnmeteredNetworkTimeoutMs);
+        }
+        if (requiresNetworkUntilNs < requiresUnmeteredNetworkUntilNs) {
+            requiresNetworkUntilNs = requiresUnmeteredNetworkUntilNs;
+        }
+        sealed = true;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobHolder.java
new file mode 100644
index 0000000..556ceb3
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobHolder.java
@@ -0,0 +1,343 @@
+package com.birbit.android.jobqueue;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.config.Configuration;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Container class to address Jobs inside job manager.
+ */
+public class JobHolder {
+
+    /**
+     * Internal constant. Job's onRun method completed w/o any exception.
+     */
+    public static final int RUN_RESULT_SUCCESS = 1;
+    /**
+     * Internal constant. Job's onRun method thrown an exception and either it does not want to
+     * run again or reached retry limit.
+     */
+    public static final int RUN_RESULT_FAIL_RUN_LIMIT = 2;
+
+    /**
+     * Internal constant. Job's onRun method has thrown an exception and it was cancelled after it
+     * started.
+     */
+    public static final int RUN_RESULT_FAIL_FOR_CANCEL = 3;
+    /**
+     * Internal constant. Job's onRun method failed but wants to retry.
+     */
+    public static final int RUN_RESULT_TRY_AGAIN = 4;
+
+    /**
+     * The job decided not to run in shouldReRun method.
+     */
+    public static final int RUN_RESULT_FAIL_SHOULD_RE_RUN = 5;
+    /**
+     * Internal constant. Job's onRun method has thrown an exception and another job with the
+     * same single instance id had been queued.
+     */
+    public static final int RUN_RESULT_FAIL_SINGLE_ID = 6;
+
+    protected Long insertionOrder;
+    protected String id;
+    protected int priority;
+    protected String groupId;
+    protected int runCount;
+    /**
+     * job will be delayed until this nanotime
+     */
+    protected long delayUntilNs;
+    /**
+     * When job is created, Timer.nanoTime() is assigned to {@code createdNs} value so that we know
+     * when job is created in relation to others
+     */
+    protected long createdNs;
+    protected long runningSessionId;
+    protected long requiresNetworkUntilNs;
+    protected long requiresUnmeteredNetworkUntilNs;
+    transient Job job;
+    protected final Set<String> tags;
+    private boolean cancelled;
+    private boolean cancelledSingleId;
+    private boolean successful;
+    /**
+     * Eventual exception thrown from the last execution of {@link Job#onRun}
+     */
+    @Nullable private Throwable throwable;
+
+    /**
+     * @param priority         Higher is better
+     * @param groupId          which group does this job belong to? default null
+     * @param runCount         Incremented each time job is fetched to run, initial value should be 0
+     * @param job              Actual job to run
+     * @param createdNs        System.nanotime
+     * @param delayUntilNs     System.nanotime value where job can be run the very first time
+     * @param runningSessionId
+     */
+    private JobHolder(int priority, String groupId, int runCount, Job job, long createdNs,
+            long delayUntilNs, long runningSessionId) {
+        this.id = job.getId();
+        this.priority = priority;
+        this.groupId = groupId;
+        this.runCount = runCount;
+        this.createdNs = createdNs;
+        this.delayUntilNs = delayUntilNs;
+        this.job = job;
+        job.priority = priority;
+        this.runningSessionId = runningSessionId;
+        this.requiresNetworkUntilNs = job.getRequiresNetworkUntilNs();
+        this.requiresUnmeteredNetworkUntilNs = job.getRequiresUnmeteredNetworkUntilNs();
+        this.tags = job.getTags() == null ? null : Collections.unmodifiableSet(job.getTags());
+    }
+
+    /**
+     * runs the job w/o throwing any exceptions
+     * @param currentRunCount
+     * @return RUN_RESULT*
+     */
+    public int safeRun(int currentRunCount) {
+        return job.safeRun(this, currentRunCount);
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * The time should be acquired from {@link Configuration#getTimer()}
+     *
+     * @param timeInNs The current time in ns. This should be the time used by the JobManager.
+     *
+     * @return True if the job requires network to be run right now, false otherwise.
+     */
+    public boolean requiresNetwork(long timeInNs) {
+        return requiresNetworkUntilNs > timeInNs;
+    }
+
+    public long getRequiresNetworkUntilNs() {
+        return requiresNetworkUntilNs;
+    }
+
+    /**
+     * The time should be acquired from {@link Configuration#getTimer()}
+     *
+     * @param timeInNs The current time in ns. This should be the time used by the JobManager.
+     *
+     * @return True if the job requires a UNMETERED network to be run right now, false otherwise.
+     */
+    public boolean requiresUnmeteredNetwork(long timeInNs) {
+        return requiresUnmeteredNetworkUntilNs > timeInNs;
+    }
+
+    public long getRequiresUnmeteredNetworkUntilNs() {
+        return requiresUnmeteredNetworkUntilNs;
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public void setPriority(int priority) {
+        this.priority = priority;
+        this.job.priority = this.priority;
+    }
+
+    public Long getInsertionOrder() {
+        return insertionOrder;
+    }
+
+    public void setInsertionOrder(long insertionOrder) {
+        this.insertionOrder = insertionOrder;
+    }
+
+    public void setDelayUntilNs(long delayUntilNs) {
+        this.delayUntilNs = delayUntilNs;
+    }
+
+    public int getRunCount() {
+        return runCount;
+    }
+
+    public void setRunCount(int runCount) {
+        this.runCount = runCount;
+    }
+
+    public long getCreatedNs() {
+        return createdNs;
+    }
+
+    public void setCreatedNs(long createdNs) {
+        this.createdNs = createdNs;
+    }
+
+    public long getRunningSessionId() {
+        return runningSessionId;
+    }
+
+    public void setRunningSessionId(long runningSessionId) {
+        this.runningSessionId = runningSessionId;
+    }
+
+    public long getDelayUntilNs() {
+        return delayUntilNs;
+    }
+
+    public Job getJob() {
+        return job;
+    }
+
+    public void setJob(Job job) {
+        this.job = job;
+        this.id = job.getId();
+    }
+
+    public String getGroupId() {
+        return groupId;
+    }
+
+    public Set<String> getTags() {
+        return tags;
+    }
+
+    public void markAsCancelled() {
+        cancelled = true;
+        job.cancelled = true;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void markAsCancelledSingleId() {
+        cancelledSingleId = true;
+        markAsCancelled();
+    }
+
+    public boolean isCancelledSingleId() {
+        return cancelledSingleId;
+    }
+
+    @Override
+    public int hashCode() {
+        //we don't really care about overflow.
+        return id.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(!(o instanceof JobHolder)) {
+            return false;
+        }
+        JobHolder other = (JobHolder) o;
+        return id.equals(other.id);
+    }
+
+    public boolean hasTags() {
+        return tags != null && tags.size() > 0;
+    }
+
+    public synchronized void markAsSuccessful() {
+        successful = true;
+    }
+
+    public synchronized boolean isSuccessful() {
+        return successful;
+    }
+
+    public void setApplicationContext(Context applicationContext) {
+        this.job.setApplicationContext(applicationContext);
+    }
+
+    public void onCancel(@CancelReason int cancelReason) {
+        job.onCancel(cancelReason, throwable);
+    }
+
+    public RetryConstraint getRetryConstraint() {
+        return job.retryConstraint;
+    }
+
+    void setThrowable(@Nullable Throwable throwable) {
+        this.throwable = throwable;
+    }
+
+    @Nullable
+    Throwable getThrowable() {
+        return throwable;
+    }
+
+    public static class Builder {
+        private int priority;
+        private String groupId;
+        private int runCount;
+        private Job job;
+        private long createdNs;
+        private long delayUntilNs = JobManager.NOT_DELAYED_JOB_DELAY;
+        private Long insertionOrder;
+        private long runningSessionId;
+        private int providedFlags = 0;
+        private static final int FLAG_SESSION_ID = 1;
+        private static final int FLAG_PRIORITY = 1 << 1;
+        private static final int FLAG_CREATED_AT = 1 << 2;
+
+        public Builder priority(int priority) {
+            this.priority = priority;
+            providedFlags |= FLAG_PRIORITY;
+            return this;
+        }
+        public Builder groupId(String groupId) {
+            this.groupId = groupId;
+            return this;
+        }
+        public Builder runCount(int runCount) {
+            this.runCount = runCount;
+            return this;
+        }
+        public Builder job(Job job) {
+            this.job = job;
+            return this;
+        }
+        public Builder createdNs(long createdNs) {
+            this.createdNs = createdNs;
+            providedFlags |= FLAG_CREATED_AT;
+            return this;
+        }
+        public Builder delayUntilNs(long delayUntilNs) {
+            this.delayUntilNs = delayUntilNs;
+            return this;
+        }
+        public Builder insertionOrder(long insertionOrder) {
+            this.insertionOrder = insertionOrder;
+            return this;
+        }
+        public Builder runningSessionId(long runningSessionId) {
+            this.runningSessionId = runningSessionId;
+            providedFlags |= FLAG_SESSION_ID;
+            return this;
+        }
+        public JobHolder build() {
+            if (job == null) {
+                throw new IllegalArgumentException("must provide a job");
+            }
+            if ((providedFlags & FLAG_PRIORITY) == 0) {
+                throw new IllegalArgumentException("must provide a priority");
+            }
+            if ((providedFlags & FLAG_SESSION_ID) == 0) {
+                throw new IllegalArgumentException("must provide a session id");
+            }
+            if ((providedFlags & FLAG_CREATED_AT) == 0) {
+                throw new IllegalArgumentException("must provide a created timestamp");
+            }
+            JobHolder jobHolder = new JobHolder(priority, groupId, runCount, job, createdNs,
+                    delayUntilNs, runningSessionId);
+            if (insertionOrder != null) {
+                jobHolder.setInsertionOrder(insertionOrder);
+            }
+            return jobHolder;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManager.java
new file mode 100644
index 0000000..32c8fcf
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManager.java
@@ -0,0 +1,507 @@
+package com.birbit.android.jobqueue;
+
+import android.os.Looper;
+import android.support.annotation.NonNull;
+
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.MessageFactory;
+import com.birbit.android.jobqueue.messaging.MessageQueue;
+import com.birbit.android.jobqueue.messaging.PriorityMessageQueue;
+import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
+import com.birbit.android.jobqueue.messaging.message.CancelMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.PublicQueryMessage;
+import com.birbit.android.jobqueue.messaging.message.SchedulerMessage;
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class JobManager {
+    public static final long NS_PER_MS = 1000000;
+    public static final long NOT_RUNNING_SESSION_ID = Long.MIN_VALUE;
+    public static final long NOT_DELAYED_JOB_DELAY = Long.MIN_VALUE;
+    public static final long NETWORK_CHECK_INTERVAL = TimeUnit.MILLISECONDS.toNanos(10000);
+    /**
+     * The min delay in MS which will trigger usage of JobScheduler.
+     * If a job is added with a delay in less than this value, JobManager will not use the scheduler
+     * to wake up the application.
+     */
+    public static final long MIN_DELAY_TO_USE_SCHEDULER_IN_MS = 1000 * 30;
+
+    final JobManagerThread jobManagerThread;
+    private final PriorityMessageQueue messageQueue;
+    private final MessageFactory messageFactory;
+    @SuppressWarnings("FieldCanBeLocal")
+    private Thread chefThread;
+
+    /**
+     * Creates a JobManager with the given configuration
+     *
+     * @param configuration The configuration to be used for the JobManager
+     *
+     * @see com.birbit.android.jobqueue.config.Configuration.Builder
+     */
+    public JobManager(Configuration configuration) {
+        messageFactory = new MessageFactory();
+        messageQueue = new PriorityMessageQueue(configuration.getTimer(), messageFactory);
+        jobManagerThread = new JobManagerThread(configuration, messageQueue, messageFactory);
+        chefThread = new Thread(jobManagerThread, "job-manager");
+        if (configuration.getScheduler() != null) {
+            Scheduler.Callback callback = createSchedulerCallback();
+            configuration.getScheduler().init(configuration.getAppContext(), callback);
+        }
+        chefThread.start();
+    }
+
+    private Scheduler.Callback createSchedulerCallback() {
+        return new Scheduler.Callback() {
+            @Override
+            public boolean start(SchedulerConstraint constraint) {
+                dispatchSchedulerStart(constraint);
+                return true;
+            }
+
+            @Override
+            public boolean stop(SchedulerConstraint constraint) {
+                dispatchSchedulerStop(constraint);
+                // always return false to avoid blocking the queue
+                return false;
+            }
+        };
+    }
+
+    private void dispatchSchedulerStart(SchedulerConstraint constraint) {
+        SchedulerMessage message = messageFactory.obtain(SchedulerMessage.class);
+        message.set(SchedulerMessage.START, constraint);
+        messageQueue.post(message);
+    }
+
+    private void dispatchSchedulerStop(SchedulerConstraint constraint) {
+        SchedulerMessage message = messageFactory.obtain(SchedulerMessage.class);
+        message.set(PublicQueryMessage.START, constraint);
+        messageQueue.post(message);
+    }
+
+    /**
+     * Starts the JobManager if it is not already running.
+     *
+     * @see #stop()
+     */
+    public void start() {
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.START, null);
+        messageQueue.post(message);
+    }
+
+    /**
+     * Stops the JobManager. Currently running Jobs will continue to run but no new Jobs will be
+     * run until restarted.
+     *
+     * @see #start()
+     */
+    public void stop() {
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.STOP, null);
+        messageQueue.post(message);
+    }
+
+    /**
+     * Returns the number of consumer threads that are currently running Jobs. This number includes
+     * consumer threads that are currently idle.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     * @return The number of consumer threads
+     */
+    public int getActiveConsumerCount() {
+        assertNotInMainThread();
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.ACTIVE_CONSUMER_COUNT, null);
+        return new IntQueryFuture<>(messageQueue, message).getSafe();
+    }
+
+    /**
+     * Destroys the JobManager. You cannot make any calls to this JobManager after this call.
+     * Useful to be called after your tests.
+     *
+     * @see #stopAndWaitUntilConsumersAreFinished()
+     */
+    public void destroy() {
+        JqLog.d("destroying job queue");
+        stopAndWaitUntilConsumersAreFinished();
+        CommandMessage message = messageFactory.obtain(CommandMessage.class);
+        message.set(CommandMessage.QUIT);
+        messageQueue.post(message);
+        jobManagerThread.callbackManager.destroy();
+    }
+
+    /**
+     * Stops the JobManager and waits until all currently running Jobs are complete (or failed).
+     * Useful to be called in your tests.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     *
+     * @see #destroy()
+     */
+    public void stopAndWaitUntilConsumersAreFinished() {
+        waitUntilConsumersAreFinished(true);
+    }
+
+    /**
+     * Waits until all consumers are destroyed. If min consumer count is NOT 0, this method will
+     * never return.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     */
+    public void waitUntilConsumersAreFinished() {
+        waitUntilConsumersAreFinished(false);
+    }
+
+    private void waitUntilConsumersAreFinished(boolean stop) {
+        assertNotInMainThread();
+        final CountDownLatch latch = new CountDownLatch(1);
+        jobManagerThread.consumerManager.addNoConsumersListener(new Runnable() {
+            @Override
+            public void run() {
+                latch.countDown();
+                jobManagerThread.consumerManager.removeNoConsumersListener(this);
+            }
+        });
+        if (stop) {
+            stop();
+        }
+        if(jobManagerThread.consumerManager.getWorkerCount() == 0) {
+            return;
+        }
+        try {
+            latch.await();
+        } catch (InterruptedException ignored) {
+        }
+        PublicQueryMessage pm = messageFactory.obtain(PublicQueryMessage.class);
+        pm.set(PublicQueryMessage.CLEAR, null);
+        new IntQueryFuture<>(jobManagerThread.callbackManager.messageQueue, pm).getSafe();
+    }
+
+    /**
+     * Adds a Job to the JobManager. This method instantly returns and does not wait until the Job
+     * is added. You should always prefer this method over {@link #addJob(Job)}.
+     *
+     * @param job The Job to be added
+     *
+     * @see #addJobInBackground(Job, AsyncAddCallback)
+     * @see #addJob(Job)
+     */
+    public void addJobInBackground(Job job) {
+        AddJobMessage message = messageFactory.obtain(AddJobMessage.class);
+        message.setJob(job);
+        messageQueue.post(message);
+    }
+
+    /**
+     * Cancels the Jobs that match the given criteria. If a Job that matches the criteria is
+     * currently running, JobManager waits until it finishes its {@link Job#onRun()} method before
+     * calling the callback.
+     *
+     * @param cancelCallback The callback to call once cancel is handled
+     * @param constraint The constraint to be used to match tags
+     * @param tags The list of tags
+     */
+    public void cancelJobsInBackground(final CancelResult.AsyncCancelCallback cancelCallback,
+            final TagConstraint constraint, final String... tags) {
+        if (constraint == null) {
+            throw new IllegalArgumentException("must provide a TagConstraint");
+        }
+        CancelMessage message = messageFactory.obtain(CancelMessage.class);
+        message.setCallback(cancelCallback);
+        message.setConstraint(constraint);
+        message.setTags(tags);
+        messageQueue.post(message);
+    }
+
+    /**
+     * Adds a JobManagerCallback to observe this JobManager.
+     *
+     * @param callback The callback to be added
+     */
+    public void addCallback(JobManagerCallback callback) {
+        jobManagerThread.addCallback(callback);
+    }
+
+    /**
+     * Removes the JobManagerCallback from the callbacks list. This method is safe to be called
+     * inside any method of the JobManagerCallback.
+     *
+     * @param callback The callback to be removed
+     *
+     * @return true if the callback is removed, false otherwise (if it did not exist).
+     */
+    public boolean removeCallback(JobManagerCallback callback) {
+        return jobManagerThread.removeCallback(callback);
+    }
+
+    /**
+     * Adds the Job to the JobManager and waits until the add is handled.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     *
+     * Even if you are not on the main thread, you should prefer using
+     * {@link #addJobInBackground(Job)} or {@link #addJobInBackground(Job, AsyncAddCallback)} if
+     * you don't need to block your thread until the Job is actually added.
+     *
+     * @param job The Job to be added
+     *
+     * @see #addJobInBackground(Job)
+     * @see #addJobInBackground(Job, AsyncAddCallback)
+     */
+    public void addJob(Job job) {
+        assertNotInMainThread("Cannot call this method on main thread. Use addJobInBackground "
+                + "instead.");
+        final CountDownLatch latch = new CountDownLatch(1);
+        final String uuid = job.getId();
+        addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onJobAdded(@NonNull Job job) {
+                if (uuid.equals(job.getId())) {
+                    latch.countDown();
+                    removeCallback(this);
+                }
+            }
+        });
+        addJobInBackground(job);
+        try {
+            latch.await();
+        } catch (InterruptedException ignored) {
+
+        }
+    }
+
+    /**
+     * Adds a Job in a background thread and calls the provided callback once the Job is added
+     * to the JobManager.
+     *
+     * @param job The Job to be added
+     * @param callback The callback to be invoked once Job is saved in the JobManager's queues
+     */
+    public void addJobInBackground(Job job, final AsyncAddCallback callback) {
+        if (callback == null) {
+            addJobInBackground(job);
+            return;
+        }
+        final String uuid = job.getId();
+        addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onJobAdded(@NonNull Job job) {
+                if (uuid.equals(job.getId())) {
+                    try {
+                        callback.onAdded();
+                    } finally {
+                        removeCallback(this);
+                    }
+                }
+            }
+        });
+        addJobInBackground(job);
+    }
+
+    /**
+     * Cancels jobs that match the given criteria. This method blocks until the cancellation is
+     * handled, which might be a long time if a Job that matches the given criteria is currently
+     * running. Consider using
+     * {@link #cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)}
+     * if possible.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     *
+     * @param constraint The constraints to be used for tags
+     * @param tags The list of tags
+     *
+     * @return A cancel result that has the list of cancelled and failed to cancel Jobs. A job
+     * might fail to cancel if it already started before cancel request is handled.
+     */
+    public CancelResult cancelJobs(TagConstraint constraint, String... tags) {
+        assertNotInMainThread("Cannot call this method on main thread. Use cancelJobsInBackground"
+                + " instead");
+        if (constraint == null) {
+            throw new IllegalArgumentException("must provide a TagConstraint");
+        }
+        final CountDownLatch latch = new CountDownLatch(1);
+        final CancelResult[] result = new CancelResult[1];
+        CancelResult.AsyncCancelCallback myCallback = new CancelResult.AsyncCancelCallback() {
+            @Override
+            public void onCancelled(CancelResult cancelResult) {
+                result[0] = cancelResult;
+                latch.countDown();
+            }
+        };
+        CancelMessage message = messageFactory.obtain(CancelMessage.class);
+        message.setConstraint(constraint);
+        message.setTags(tags);
+        message.setCallback(myCallback);
+        messageQueue.post(message);
+        try {
+            latch.await();
+        } catch (InterruptedException ignored) {
+        }
+        return result[0];
+    }
+
+    /**
+     * Returns the number of jobs in the JobManager. This number does not include jobs that are
+     * currently running.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     *
+     * @return The number of jobs that are waiting to be run
+     */
+    public int count() {
+        assertNotInMainThread();
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.COUNT, null);
+        return new IntQueryFuture<>(messageQueue, message).getSafe();
+    }
+
+    /**
+     * Returns the number of jobs that are ready to be executed but waiting in the queue.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     * @return The number of jobs that are ready to be executed but waiting in the queue.
+     */
+    public int countReadyJobs() {
+        assertNotInMainThread();
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.COUNT_READY, null);
+        return new IntQueryFuture<>(messageQueue, message).getSafe();
+    }
+
+    /**
+     * Returns the current status of a given job
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     * @param id The id of the job ({@link Job#getId()})
+     *
+     * @return The current status of the Job
+     */
+    public JobStatus getJobStatus(String id) {
+        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.JOB_STATUS, id, null);
+        Integer status = new IntQueryFuture<>(messageQueue, message).getSafe();
+        return JobStatus.values()[status];
+    }
+
+    /**
+     * Clears all waiting Jobs in the JobManager. Note that this won't touch any job that is
+     * currently running.
+     * <p>
+     * You cannot call this method on the main thread because it may potentially block it for a long
+     * time.
+     */
+    public void clear() {
+        final PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.CLEAR, null);
+        new IntQueryFuture<>(messageQueue, message).getSafe();
+    }
+
+    void internalRunInJobManagerThread(final Runnable runnable) throws Throwable {
+        final Throwable[] error = new Throwable[1];
+        final PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);
+        message.set(PublicQueryMessage.INTERNAL_RUNNABLE, null);
+        new IntQueryFuture<PublicQueryMessage>(messageQueue, message) {
+            @Override
+            public void onResult(int result) { // this is hacky but allright
+                try {
+                    runnable.run();
+                } catch (Throwable t) {
+                    error[0] = t;
+                }
+                super.onResult(result);
+            }
+        }.getSafe();
+        if (error[0] != null) {
+            throw error[0];
+        }
+    }
+
+    private void assertNotInMainThread() {
+        assertNotInMainThread("Cannot call this method on main thread.");
+    }
+    private void assertNotInMainThread(String message) {
+        if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
+            throw new IllegalStateException(message);
+        }
+    }
+
+    static class IntQueryFuture<T extends Message & IntCallback.MessageWithCallback>
+            implements Future<Integer>,IntCallback {
+        final MessageQueue messageQueue;
+        volatile Integer result = null;
+        final CountDownLatch latch = new CountDownLatch(1);
+        final T message;
+
+        public IntQueryFuture(MessageQueue messageQueue, T message) {
+            this.messageQueue = messageQueue;
+            this.message = message;
+            message.setCallback(this);
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return latch.getCount() == 0;
+        }
+
+        public Integer getSafe() {
+            try {
+                return get();
+            } catch (Throwable t) {
+                JqLog.e(t, "message is not complete");
+            }
+            throw new RuntimeException("cannot get the result of the JobManager query");
+        }
+
+        @Override
+        public Integer get() throws InterruptedException, ExecutionException {
+            messageQueue.post(message);
+            latch.await();
+            return result;
+        }
+
+        @Override
+        public Integer get(long timeout, @NonNull TimeUnit unit)
+                throws InterruptedException, ExecutionException, TimeoutException {
+            messageQueue.post(message);
+            latch.await(timeout, unit);
+            return result;
+        }
+
+        @Override
+        public void onResult(int result) {
+            this.result = result;
+            latch.countDown();
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManagerThread.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManagerThread.java
new file mode 100644
index 0000000..0c8932b
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobManagerThread.java
@@ -0,0 +1,655 @@
+package com.birbit.android.jobqueue;
+
+import android.content.Context;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.di.DependencyInjector;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.MessageFactory;
+import com.birbit.android.jobqueue.messaging.MessageQueueConsumer;
+import com.birbit.android.jobqueue.messaging.PriorityMessageQueue;
+import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
+import com.birbit.android.jobqueue.messaging.message.CancelMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.ConstraintChangeMessage;
+import com.birbit.android.jobqueue.messaging.message.JobConsumerIdleMessage;
+import com.birbit.android.jobqueue.messaging.message.PublicQueryMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobResultMessage;
+import com.birbit.android.jobqueue.messaging.message.SchedulerMessage;
+import com.birbit.android.jobqueue.network.NetworkEventProvider;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+
+import static com.birbit.android.jobqueue.network.NetworkUtil.DISCONNECTED;
+import static com.birbit.android.jobqueue.network.NetworkUtil.UNMETERED;
+
+class JobManagerThread implements Runnable, NetworkEventProvider.Listener {
+    public static final long NS_PER_MS = 1000000;
+    public static final long NOT_RUNNING_SESSION_ID = Long.MIN_VALUE;
+    public static final long NOT_DELAYED_JOB_DELAY = Long.MIN_VALUE;
+
+
+    final Timer timer;
+    private final Context appContext;
+    @SuppressWarnings("FieldCanBeLocal")
+    private final long sessionId;
+    final JobQueue persistentJobQueue;
+    final JobQueue nonPersistentJobQueue;
+    private final NetworkUtil networkUtil;
+    private final DependencyInjector dependencyInjector;
+    private final MessageFactory messageFactory;
+    final ConsumerManager consumerManager;
+    @Nullable private List<CancelHandler> pendingCancelHandlers;
+    @Nullable private List<SchedulerConstraint> pendingSchedulerCallbacks;
+    final Constraint queryConstraint = new Constraint();
+
+    final CallbackManager callbackManager;
+
+    private boolean running = true;
+    /**
+     * We set this to true whenever we schedule a wake up and set to false whenever we call
+     * cancelAll. It is not precise, does not cover scheduling across reboots but a fair comprimise
+     * for simplicity.
+     */
+    private boolean shouldCancelAllScheduledWhenEmpty = false;
+
+    final PriorityMessageQueue messageQueue;
+    @Nullable
+    Scheduler scheduler;
+
+    JobManagerThread(Configuration config, PriorityMessageQueue messageQueue,
+            MessageFactory messageFactory) {
+        this.messageQueue = messageQueue;
+        if(config.getCustomLogger() != null) {
+            JqLog.setCustomLogger(config.getCustomLogger());
+        }
+        this.messageFactory = messageFactory;
+        timer = config.getTimer();
+        appContext = config.getAppContext();
+        sessionId = timer.nanoTime();
+        scheduler = config.getScheduler();
+        if (scheduler != null && config.batchSchedulerRequests() &&
+                !(scheduler instanceof BatchingScheduler)) {
+            scheduler = new BatchingScheduler(scheduler, timer);
+        }
+        this.persistentJobQueue = config.getQueueFactory()
+                .createPersistentQueue(config, sessionId);
+        this.nonPersistentJobQueue = config.getQueueFactory()
+                .createNonPersistent(config, sessionId);
+        networkUtil = config.getNetworkUtil();
+        dependencyInjector = config.getDependencyInjector();
+        if(networkUtil instanceof NetworkEventProvider) {
+            ((NetworkEventProvider) networkUtil).setListener(this);
+        }
+        consumerManager = new ConsumerManager(this, timer, messageFactory, config);
+        callbackManager = new CallbackManager(messageFactory, timer);
+    }
+
+    void addCallback(JobManagerCallback callback) {
+        callbackManager.addCallback(callback);
+    }
+
+    boolean removeCallback(JobManagerCallback callback) {
+        return callbackManager.removeCallback(callback);
+    }
+
+    boolean canListenToNetwork() {
+        return networkUtil instanceof NetworkEventProvider;
+    }
+
+    private void handleAddJob(AddJobMessage message) {
+        Job job = message.getJob();
+        //noinspection deprecation
+        long delayUntilNs = job.getDelayInMs() > 0
+                ? timer.nanoTime() + job.getDelayInMs() * NS_PER_MS
+                : NOT_DELAYED_JOB_DELAY;
+        job.seal(timer);
+        JobHolder jobHolder = new JobHolder.Builder()
+                .priority(job.getPriority())
+                .job(job)
+                .groupId(job.getRunGroupId())
+                .createdNs(timer.nanoTime())
+                .delayUntilNs(delayUntilNs)
+                .runningSessionId(NOT_RUNNING_SESSION_ID).build();
+
+        JobHolder oldJob = findJobBySingleId(job.getSingleInstanceId());
+        final boolean insert = oldJob == null || consumerManager.isJobRunning(oldJob.getId());
+        if (insert) {
+            JobQueue queue = job.isPersistent() ? persistentJobQueue : nonPersistentJobQueue;
+            if (oldJob != null) { //the other job was running, will be cancelled if it fails
+                consumerManager.markJobsCancelledSingleId(TagConstraint.ANY, new String[]{job.getSingleInstanceId()});
+                queue.substitute(jobHolder, oldJob);
+            } else {
+                queue.insert(jobHolder);
+            }
+            if (JqLog.isDebugEnabled()) {
+                JqLog.d("added job class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
+                        , job.getClass().getSimpleName(), job.getPriority(), job.getDelayInMs(), job.getRunGroupId()
+                        , job.isPersistent(), job.requiresNetwork(timer));
+            }
+        } else {
+            JqLog.d("another job with same singleId: %s was already queued", job.getSingleInstanceId());
+        }
+        if(dependencyInjector != null) {
+            //inject members b4 calling onAdded
+            dependencyInjector.inject(job);
+        }
+        jobHolder.setApplicationContext(appContext);
+        try {
+            jobHolder.getJob().onAdded();
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onAdded did throw an exception, ignoring...");
+        }
+        callbackManager.notifyOnAdded(jobHolder.getJob());
+        if (insert) {
+            consumerManager.onJobAdded();
+            if (job.isPersistent()) {
+                scheduleWakeUpFor(job);
+            }
+        } else {
+            cancelSafely(jobHolder, CancelReason.SINGLE_INSTANCE_ID_QUEUED);
+            callbackManager.notifyOnDone(jobHolder.getJob());
+        }
+    }
+
+    private void scheduleWakeUpFor(Job job) {
+        if (scheduler == null) {
+            return;
+        }
+        boolean requireNetwork = job.requiresNetwork(timer);
+        boolean requireUnmeteredNetwork = job.requiresUnmeteredNetwork(timer);
+        long delayInMs = job.getDelayInMs();
+        long delay = delayInMs > 0 ? delayInMs : 0;
+        if (!requireNetwork && !requireUnmeteredNetwork
+                && delay < JobManager.MIN_DELAY_TO_USE_SCHEDULER_IN_MS) {
+            return;
+        }
+
+        SchedulerConstraint constraint = new SchedulerConstraint(UUID.randomUUID().toString());
+        constraint.setNetworkStatus(requireUnmeteredNetwork ? NetworkUtil.UNMETERED :
+                requireNetwork ? NetworkUtil.METERED : NetworkUtil.DISCONNECTED);
+        constraint.setDelayInMs(delay);
+        scheduler.request(constraint);
+        shouldCancelAllScheduledWhenEmpty = true;
+    }
+
+    /**
+     * Returns a queued job with the same single id. If any matching non-running job is found,
+     * that one is returned. Otherwise any matching running job will be returned.
+     */
+    private JobHolder findJobBySingleId(/*Nullable*/String singleIdTag) {
+        if (singleIdTag != null) {
+            queryConstraint.clear();
+            queryConstraint.setTags(new String[]{singleIdTag});
+            queryConstraint.setTagConstraint(TagConstraint.ANY);
+            Set<JobHolder> jobs = nonPersistentJobQueue.findJobs(queryConstraint);
+            jobs.addAll(persistentJobQueue.findJobs(queryConstraint));
+            if (!jobs.isEmpty()) {
+                for (JobHolder job : jobs) {
+                    if (!consumerManager.isJobRunning(job.getId())) {
+                        return job;
+                    }
+                }
+                return jobs.iterator().next();
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public void run() {
+        messageQueue.consume(new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                switch (message.type) {
+                    case ADD_JOB:
+                        handleAddJob((AddJobMessage) message);
+                        break;
+                    case JOB_CONSUMER_IDLE:
+                        boolean busy = consumerManager.handleIdle((JobConsumerIdleMessage) message);
+                        if (!busy) {
+                            invokeSchedulersIfIdle();
+                        }
+                        break;
+                    case RUN_JOB_RESULT:
+                        handleRunJobResult((RunJobResultMessage) message);
+                        break;
+                    case CONSTRAINT_CHANGE:
+                        consumerManager.handleConstraintChange();
+                        break;
+                    case CANCEL:
+                        handleCancel((CancelMessage) message);
+                        break;
+                    case PUBLIC_QUERY:
+                        handlePublicQuery((PublicQueryMessage) message);
+                        break;
+                    case COMMAND:
+                        handleCommand((CommandMessage) message);
+                        break;
+                    case SCHEDULER:
+                        handleSchedulerMessage((SchedulerMessage) message);
+                        break;
+                }
+            }
+
+            @Override
+            public void onIdle() {
+                JqLog.d("joq idle. running:? %s", running);
+                if (!running) {
+                    return;
+                }
+                Long nextJobTimeNs = getNextWakeUpNs(true);
+                // TODO check network should be another message which goes idle if network is the
+                // same as now
+                JqLog.d("Job queue idle. next job at: %s", nextJobTimeNs);
+                if (nextJobTimeNs != null) {
+                    ConstraintChangeMessage constraintMessage =
+                            messageFactory.obtain(ConstraintChangeMessage.class);
+                    messageQueue.postAt(constraintMessage, nextJobTimeNs);
+                } else if (scheduler != null) {
+                    // if we have a scheduler but the queue is empty, just clean them all.
+                    if (shouldCancelAllScheduledWhenEmpty && persistentJobQueue.count() == 0) {
+                        shouldCancelAllScheduledWhenEmpty = false;
+                        scheduler.cancelAll();
+                    }
+                }
+            }
+        });
+    }
+
+    private void invokeSchedulersIfIdle() {
+        if (scheduler == null || pendingSchedulerCallbacks == null
+                || pendingSchedulerCallbacks.isEmpty() || !consumerManager.areAllConsumersIdle()) {
+            return;
+        }
+        for (int i = pendingSchedulerCallbacks.size() - 1; i >= 0; i--) {
+            SchedulerConstraint constraint = pendingSchedulerCallbacks.remove(i);
+            boolean reschedule = hasJobsWithSchedulerConstraint(constraint);
+            scheduler.onFinished(constraint, reschedule);
+        }
+    }
+
+    private void handleSchedulerMessage(SchedulerMessage message) {
+        final int what = message.getWhat();
+        if (what == SchedulerMessage.START) {
+            handleSchedulerStart(message.getConstraint());
+        } else if (what == SchedulerMessage.STOP) {
+            handleSchedulerStop(message.getConstraint());
+        } else {
+            throw new IllegalArgumentException("Unknown scheduler message with what " + what);
+        }
+    }
+
+    private boolean hasJobsWithSchedulerConstraint(SchedulerConstraint constraint) {
+        if (consumerManager.hasJobsWithSchedulerConstraint(constraint, timer.nanoTime())) {
+            return true;
+        }
+
+        queryConstraint.clear();
+        queryConstraint.setNowInNs(timer.nanoTime());
+        queryConstraint.setNetworkStatus(constraint.getNetworkStatus());
+        return persistentJobQueue.countReadyJobs(queryConstraint) > 0;
+    }
+
+    private void handleSchedulerStop(SchedulerConstraint constraint) {
+        final List<SchedulerConstraint> pendingCallbacks = this.pendingSchedulerCallbacks;
+        if (pendingCallbacks != null) {
+            for (int i = pendingCallbacks.size() - 1; i >= 0; i--) {
+                SchedulerConstraint pendingConstraint = pendingCallbacks.get(i);
+                if (pendingConstraint.getUuid().equals(constraint.getUuid())) {
+                    pendingCallbacks.remove(i);
+                }
+            }
+        }
+        if (scheduler == null) {
+            return;//nothing to do
+        }
+        final boolean hasMatchingJobs = hasJobsWithSchedulerConstraint(constraint);
+        if (hasMatchingJobs) {
+            // reschedule
+            scheduler.request(constraint);
+        }
+    }
+
+
+    private void handleSchedulerStart(SchedulerConstraint constraint) {
+        if (!isRunning()) {
+            if (scheduler != null) {
+                scheduler.onFinished(constraint, true);
+            }
+            return;
+        }
+        boolean hasMatchingJobs = hasJobsWithSchedulerConstraint(constraint);
+        if (!hasMatchingJobs) {
+            if (scheduler != null) {
+                scheduler.onFinished(constraint, false);
+            }
+            return;
+        }
+        if (pendingSchedulerCallbacks == null) {
+            pendingSchedulerCallbacks = new ArrayList<>();
+        }
+        // add this to callbacks to be invoked when job runs
+        pendingSchedulerCallbacks.add(constraint);
+        consumerManager.handleConstraintChange();
+    }
+
+    private void handleCommand(CommandMessage message) {
+        if (message.getWhat() == CommandMessage.QUIT) {
+            messageQueue.stop();
+            messageQueue.clear();
+        }
+    }
+
+    int count() {
+        return persistentJobQueue.count() + nonPersistentJobQueue.count();
+    }
+
+    private void handlePublicQuery(PublicQueryMessage message) {
+        switch (message.getWhat()) {
+            case PublicQueryMessage.COUNT:
+                message.getCallback().onResult(count());
+                break;
+            case PublicQueryMessage.COUNT_READY:
+                message.getCallback().onResult(countReadyJobs(getNetworkStatus()));
+                break;
+            case PublicQueryMessage.START:
+                JqLog.d("handling start request...");
+                if (running) {
+                    return;
+                }
+                running = true;
+                consumerManager.handleConstraintChange();
+                break;
+            case PublicQueryMessage.STOP:
+                JqLog.d("handling stop request...");
+                running = false;
+                consumerManager.handleStop();
+                break;
+            case PublicQueryMessage.JOB_STATUS:
+                JobStatus status = getJobStatus(message.getStringArg());
+                message.getCallback().onResult(status.ordinal());
+                break;
+            case PublicQueryMessage.CLEAR:
+                clear();
+                if (message.getCallback() != null) {
+                    message.getCallback().onResult(0);
+                }
+                break;
+            case PublicQueryMessage.ACTIVE_CONSUMER_COUNT:
+                message.getCallback().onResult(consumerManager.getWorkerCount());
+                break;
+            case PublicQueryMessage.INTERNAL_RUNNABLE:
+                message.getCallback().onResult(0);
+                break;
+            default:
+                throw new IllegalArgumentException("cannot handle public query with type " +
+                message.getWhat());
+        }
+    }
+
+    private void clear() {
+        nonPersistentJobQueue.clear();
+        persistentJobQueue.clear();
+    }
+
+    private JobStatus getJobStatus(String id) {
+        if (consumerManager.isJobRunning(id)) {
+            return JobStatus.RUNNING;
+        }
+        JobHolder holder;
+        holder = nonPersistentJobQueue.findJobById(id);
+        if (holder == null) {
+            holder = persistentJobQueue.findJobById(id);
+        }
+        if(holder == null) {
+            return JobStatus.UNKNOWN;
+        }
+        final int networkStatus = getNetworkStatus();
+        long now = timer.nanoTime();
+        if(networkStatus == DISCONNECTED && holder.requiresNetwork(now)) {
+            return JobStatus.WAITING_NOT_READY;
+        }
+        if(networkStatus != UNMETERED && holder.requiresUnmeteredNetwork(now)) {
+            return JobStatus.WAITING_NOT_READY;
+        }
+        if(holder.getDelayUntilNs() > now) {
+            return JobStatus.WAITING_NOT_READY;
+        }
+        return JobStatus.WAITING_READY;
+    }
+
+    private void handleCancel(CancelMessage message) {
+        CancelHandler handler = new CancelHandler(message.getConstraint(), message.getTags(),
+                message.getCallback());
+        handler.query(this, consumerManager);
+        if (handler.isDone()) {
+            handler.commit(this);
+        } else {
+            if (pendingCancelHandlers == null) {
+                pendingCancelHandlers = new ArrayList<>();
+            }
+            pendingCancelHandlers.add(handler);
+        }
+    }
+
+    private void handleRunJobResult(RunJobResultMessage message) {
+        final int result = message.getResult();
+        final JobHolder jobHolder = message.getJobHolder();
+        callbackManager.notifyOnRun(jobHolder.getJob(), result);
+        RetryConstraint retryConstraint = null;
+        switch (result) {
+            case JobHolder.RUN_RESULT_SUCCESS:
+                jobHolder.markAsSuccessful();
+                removeJob(jobHolder);
+                break;
+            case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
+                cancelSafely(jobHolder, CancelReason.REACHED_RETRY_LIMIT);
+                removeJob(jobHolder);
+                break;
+            case JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN:
+                cancelSafely(jobHolder, CancelReason.CANCELLED_VIA_SHOULD_RE_RUN);
+                removeJob(jobHolder);
+                break;
+            case JobHolder.RUN_RESULT_FAIL_SINGLE_ID:
+                cancelSafely(jobHolder, CancelReason.SINGLE_INSTANCE_WHILE_RUNNING);
+                removeJob(jobHolder);
+                break;
+            case JobHolder.RUN_RESULT_TRY_AGAIN:
+                retryConstraint = jobHolder.getRetryConstraint();
+                insertOrReplace(jobHolder);
+                break;
+            case JobHolder.RUN_RESULT_FAIL_FOR_CANCEL:
+                JqLog.d("running job failed and cancelled, doing nothing. "
+                        + "Will be removed after it's onCancel is called by the "
+                        + "CancelHandler");
+                break;
+            default:
+                JqLog.e("unknown job holder result");
+        }
+        consumerManager.handleRunJobResult(message, jobHolder, retryConstraint);
+        callbackManager.notifyAfterRun(jobHolder.getJob(), result);
+        if (pendingCancelHandlers != null) {
+            int limit = pendingCancelHandlers.size();
+            for (int i = 0; i < limit; i ++) {
+                CancelHandler handler = pendingCancelHandlers.get(i);
+                handler.onJobRun(jobHolder, result);
+                if (handler.isDone()) {
+                    handler.commit(this);
+                    pendingCancelHandlers.remove(i);
+                    i--;
+                    limit--;
+                }
+            }
+        }
+    }
+
+    private void cancelSafely(JobHolder jobHolder, @CancelReason int cancelReason) {
+        try {
+            jobHolder.onCancel(cancelReason);
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onCancel did throw an exception, ignoring...");
+        }
+        callbackManager.notifyOnCancel(jobHolder.getJob(), false, jobHolder.getThrowable());
+    }
+
+    private void insertOrReplace(JobHolder jobHolder) {
+        RetryConstraint retryConstraint = jobHolder.getRetryConstraint();
+        if (retryConstraint == null) {
+            reAddJob(jobHolder);
+            return;
+        }
+        if (retryConstraint.getNewPriority() != null) {
+            jobHolder.setPriority(retryConstraint.getNewPriority());
+        }
+        long delay = -1;
+        if (retryConstraint.getNewDelayInMs() != null) {
+            delay = retryConstraint.getNewDelayInMs();
+        }
+        jobHolder.setDelayUntilNs(
+                delay > 0 ? timer.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY
+        );
+        reAddJob(jobHolder);
+    }
+
+    private void reAddJob(JobHolder jobHolder) {
+        if (!jobHolder.isCancelled()) {
+            if (jobHolder.getJob().isPersistent()) {
+                persistentJobQueue.insertOrReplace(jobHolder);
+            } else {
+                nonPersistentJobQueue.insertOrReplace(jobHolder);
+            }
+        } else {
+            JqLog.d("not re-adding cancelled job " + jobHolder);
+        }
+    }
+
+    private void removeJob(JobHolder jobHolder) {
+        if (jobHolder.getJob().isPersistent()) {
+            persistentJobQueue.remove(jobHolder);
+        } else {
+            nonPersistentJobQueue.remove(jobHolder);
+        }
+        callbackManager.notifyOnDone(jobHolder.getJob());
+    }
+
+    @Override
+    public void onNetworkChange(@NetworkUtil.NetworkStatus int networkStatus) {
+        ConstraintChangeMessage constraint = messageFactory.obtain(ConstraintChangeMessage.class);
+        messageQueue.post(constraint);
+    }
+
+    boolean isRunning() {
+        return running;
+    }
+
+    int countRemainingReadyJobs() {
+        return countReadyJobs(getNetworkStatus());
+    }
+
+    private int countReadyJobs(@NetworkUtil.NetworkStatus int networkStatus) {
+        final Collection<String> runningJobs = consumerManager.runningJobGroups.getSafe();
+        queryConstraint.clear();
+        queryConstraint.setNowInNs(timer.nanoTime());
+        queryConstraint.setNetworkStatus(networkStatus);
+        queryConstraint.setExcludeGroups(runningJobs);
+        queryConstraint.setExcludeRunning(true);
+        queryConstraint.setTimeLimit(timer.nanoTime());
+        //TODO we can cache this
+        int total = 0;
+        total += nonPersistentJobQueue.countReadyJobs(queryConstraint);
+        total += persistentJobQueue.countReadyJobs(queryConstraint);
+        return total;
+    }
+
+    @NetworkUtil.NetworkStatus
+    private int getNetworkStatus() {
+        return networkUtil == null ? NetworkUtil.UNMETERED : networkUtil.getNetworkStatus(appContext);
+    }
+
+    Long getNextWakeUpNs(boolean includeNetworkWatch) {
+        final Long groupDelay = consumerManager.runningJobGroups.getNextDelayForGroups();
+        final int networkStatus = getNetworkStatus();
+        final Collection<String> groups = consumerManager.runningJobGroups.getSafe();
+        queryConstraint.clear();
+        queryConstraint.setNowInNs(timer.nanoTime());
+        queryConstraint.setNetworkStatus(networkStatus);
+        queryConstraint.setExcludeGroups(groups);
+        queryConstraint.setExcludeRunning(true);
+        final Long nonPersistent = nonPersistentJobQueue.getNextJobDelayUntilNs(queryConstraint);
+        final Long persistent = persistentJobQueue.getNextJobDelayUntilNs(queryConstraint);
+        Long delay = null;
+        if (groupDelay != null) {
+            delay = groupDelay;
+        }
+        if (nonPersistent != null) {
+            delay = delay == null ? nonPersistent : Math.min(nonPersistent, delay);
+        }
+        if (persistent != null) {
+            delay = delay == null ? persistent : Math.min(persistent, delay);
+        }
+        if (includeNetworkWatch && !(networkUtil instanceof NetworkEventProvider)) {
+            // if network cannot provide events, we need to wake up :/
+            long checkNetworkAt = timer.nanoTime() + JobManager.NETWORK_CHECK_INTERVAL;
+            delay = delay == null ? checkNetworkAt : Math.min(checkNetworkAt, delay);
+        }
+        return delay;
+    }
+
+    // Used for testing
+    JobHolder getNextJobForTesting() {
+        return getNextJobForTesting(null);
+    }
+
+    // Used for testing
+    JobHolder getNextJobForTesting(Collection<String> runningJobGroups) {
+        return getNextJob(runningJobGroups, true);
+    }
+
+    JobHolder getNextJob(Collection<String> runningJobGroups) {
+        return getNextJob(runningJobGroups, false);
+    }
+
+    JobHolder getNextJob(Collection<String> runningJobGroups, boolean ignoreRunning) {
+        if (!running && !ignoreRunning) {
+            return null;
+        }
+        final int networkStatus = getNetworkStatus();
+        JobHolder jobHolder;
+        boolean persistent = false;
+        JqLog.v("looking for next job");
+        queryConstraint.clear();
+        queryConstraint.setNowInNs(timer.nanoTime());
+        queryConstraint.setNetworkStatus(networkStatus);
+        queryConstraint.setExcludeGroups(runningJobGroups);
+        queryConstraint.setExcludeRunning(true);
+        queryConstraint.setTimeLimit(timer.nanoTime());
+        jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(queryConstraint);
+        JqLog.v("non persistent result %s", jobHolder);
+        if (jobHolder == null) {
+            //go to disk, there aren't any non-persistent jobs
+            jobHolder = persistentJobQueue.nextJobAndIncRunCount(queryConstraint);
+            persistent = true;
+            JqLog.v("persistent result %s", jobHolder);
+        }
+        if(jobHolder == null) {
+            return null;
+        }
+        if(persistent && dependencyInjector != null) {
+            dependencyInjector.inject(jobHolder.getJob());
+        }
+        jobHolder.setApplicationContext(appContext);
+        return jobHolder;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/JobQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobQueue.java
new file mode 100644
index 0000000..066e8b0
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobQueue.java
@@ -0,0 +1,110 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.Constraint;
+
+import java.util.Set;
+
+/**
+ * Interface that any JobQueue should implement
+ * These job queues can be given to JobManager.
+ */
+public interface JobQueue {
+    /**
+     * Inserts the given JobHolder.
+     *
+     * @param jobHolder
+     * @return True if job is added, false otherwise
+     */
+    boolean insert(JobHolder jobHolder);
+
+    /**
+     * Does the same thing with insert but the only difference is that
+     * if job has an insertion ID, it should replace the existing one
+     *  should also reset running session id to {@link JobManager#NOT_RUNNING_SESSION_ID}
+     *  Is called when a job is re-added (due to exception during run)
+     *
+     * @param jobHolder The JobHolder to be added
+     * @return True if job is added, false otherwise
+     */
+    boolean insertOrReplace(JobHolder jobHolder);
+
+    /**
+     * Remove the old job from the queue while inserting the new one.
+     *
+     * @param newJob To be inserted
+     * @param oldJob To be removed
+     */
+    void substitute(JobHolder newJob, JobHolder oldJob);
+
+    /**
+     * Removes the job from the data store.
+     * Is called after a job is completed (or cancelled)
+     *
+     * @param jobHolder The JobHolder to be removed
+     */
+    void remove(JobHolder jobHolder);
+
+    /**
+     * Returns the # of jobs that are waiting to be run
+     * @return The number of jobs that are waiting in the queue
+     */
+    int count();
+
+    /**
+     * counts the # of jobs that can run now. if there are more jobs from the same group,
+     * they are count as 1 since they cannot be run in parallel.
+     * <p>
+     * Exclude groups are guaranteed to be ordered in natural order.
+     *
+     * @param constraint The constraint to match the jobs
+     *
+     * @return The number of jobs that are ready to run
+     */
+    int countReadyJobs(Constraint constraint);
+
+    /**
+     * Returns the next available job in the data set
+     * It should also assign the sessionId as the RunningSessionId and persist that data if necessary.
+     * It should filter out all running jobs and exclude groups are guaranteed to be ordered in natural order
+     *
+     * @param constraint The constraint to match the job.
+     */
+    JobHolder nextJobAndIncRunCount(Constraint constraint);
+
+    /**
+     * returns when the next job should run (in nanoseconds), should return null if there are no
+     * jobs to run.
+     * <p>
+     * This method should check both delayed jobs and jobs that require network with a timeout.
+     * @param constraint The constraint to match the job.
+     */
+    Long getNextJobDelayUntilNs(Constraint constraint);
+
+    /**
+     * clear all jobs in the queue. should probably be called when user logs out.
+     */
+    void clear();
+
+    /**
+     * returns the job with the given id if it exists in the queue
+     * @param id id of the job
+     * @return JobHolder with the given id or null if it does not exists
+     */
+    JobHolder findJobById(String id);
+
+    /**
+     * Returns jobs that has the given tags.
+     *
+     * @param constraint The constraint to match the job.
+     */
+    Set<JobHolder> findJobs(Constraint constraint);
+
+    /**
+     * Called when a job is cancelled by the user.
+     * <p/>
+     * It is important to not return this job from queries anymore.
+     *
+     * @param holder The JobHolder that is being cancelled
+     */
+    void onJobCancelled(JobHolder holder);
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobStatus.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobStatus.java
similarity index 96%
rename from jobqueue/src/main/java/com/path/android/jobqueue/JobStatus.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/JobStatus.java
index b687cc3..53077e9 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobStatus.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/JobStatus.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue;
+package com.birbit.android.jobqueue;
 
 /**
  * Identifies the current status of a job if it is in the queue
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/Params.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/Params.java
new file mode 100644
index 0000000..446a859
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/Params.java
@@ -0,0 +1,336 @@
+package com.birbit.android.jobqueue;
+
+import java.util.Collections;
+import java.util.HashSet;
+
+/**
+ * Job builder object to have a more readable design.
+ * Methods can be chained to have more readable code.
+ */
+public class Params {
+
+    /**
+     * Used in requireNetwork / requireUnmeteredNetwork configuration if the requirement should be
+     * kept forever.
+     */
+    public static final long FOREVER = Long.MAX_VALUE;
+
+    /**
+     * Used in requireNetwork / requireUnmeteredNetwork configuration if the constraint is disabled.
+     */
+    public static final long NEVER = Long.MIN_VALUE;
+
+    private long requiresNetworkWithTimeout = NEVER;
+    private long requiresUnmeteredNetworkWithTimeout = NEVER;
+    private String groupId = null;
+    private String singleId = null;
+    private boolean persistent = false;
+    private int priority;
+    private long delayMs;
+    private HashSet<String> tags;
+
+    /**
+     *
+     * @param priority higher = better
+     */
+    public Params(int priority) {
+        this.priority = priority;
+    }
+
+    /**
+     * Sets the Job as requiring network.
+     * @return this
+     */
+    public Params requireNetwork() {
+        return requireNetworkWithTimeout(FOREVER);
+    }
+
+    /**
+     * Sets the Job as requiring UNMETERED network.
+     * @return this
+     */
+    public Params requireUnmeteredNetwork() {
+        return requireUnmeteredNetworkWithTimeout(FOREVER);
+    }
+
+    /**
+     * Sets the Job as requiring a unmetered network connection with the given timeoutMs. The Job
+     * will not be run until a network connection is detected. If {@code timeoutMs} is not
+     * {@link #FOREVER}, the Job will be available to run without an unmetered connection if it
+     * cannot be run with unmetered network connection in the given time period.
+     * <p>
+     * If you want the job to require unmetered network for a limited time then fall back to metered
+     * network, you can do so by
+     * {@code requireUnmeteredNetworkWithTimeout(timeout).requireNetwork()}. You can even specify
+     * a timeout for the unmetered connection as well if you wish the job to be run if enough time
+     * passes and no desired network is available.
+     *
+     * @param timeoutMs The timeout in milliseconds after which the Job will be run even if there is
+     *                no unmetered connection.
+     *
+     * @return The Params
+     */
+    public Params requireUnmeteredNetworkWithTimeout(long timeoutMs) {
+        requiresUnmeteredNetworkWithTimeout = timeoutMs;
+        return this;
+    }
+
+    /**
+     * Sets the Job as requiring a network connection with the given timeoutMs. The Job will not be
+     * run until a network connection is detected. If {@code timeoutMs} is not {@link #FOREVER}, the
+     * Job will available to run without a network connection if it cannot be run in the given time
+     * period.
+     * <p>In case this timeout is set to a value smaller than
+     * {@link #requireUnmeteredNetworkWithTimeout(long)}, the unmetered network timeout will
+     * override this one.
+     *
+     * @param timeoutMs The timeout in milliseconds after which the Job will be run even if there is
+     *                no network connection.
+     *
+     * @return The Params
+     */
+    public Params requireNetworkWithTimeout(long timeoutMs) {
+        requiresNetworkWithTimeout = timeoutMs;
+        return this;
+    }
+
+    /**
+     * Sets the group id. Jobs in the same group are guaranteed to execute sequentially.
+     * @param groupId which group this job belongs (can be null of course)
+     * @return this
+     */
+    public Params groupBy(String groupId) {
+        this.groupId = groupId;
+        return this;
+    }
+
+    /**
+     * Sets the single instance id. If there is another Job with the same single id queued and
+     * not yet running, this Job will get {@link Job#onCancel(int)} called immediately after
+     * {@link Job#onAdded()} and only the previous Job will run. That is, {@link Job#onRun()}
+     * will only be called once.
+     * <p>If no group id was set, one will be set automatically.
+     * @param singleId which single instance group this job belongs to (can be null of course)
+     * @return this
+     */
+    public Params singleInstanceBy(String singleId) {
+        this.singleId = singleId;
+        return this;
+    }
+
+    /**
+     * Marks the job as persistent. Make sure your job is serializable.
+     * @return this
+     */
+    public Params persist() {
+        this.persistent = true;
+        return this;
+    }
+
+    /**
+     * Delays the job in given ms.
+     * @param delayMs .
+     * @return this
+     */
+    public Params delayInMs(long delayMs) {
+        this.delayMs = delayMs;
+        return this;
+    }
+
+    /**
+     * Convenience method to set network requirement.
+     * @param requiresNetwork true|false
+     * @return this
+     * @see #setRequiresNetwork(boolean, long)
+     * @see #requireNetwork()
+     */
+    public Params setRequiresNetwork(boolean requiresNetwork) {
+        return setRequiresNetwork(requiresNetwork, FOREVER);
+    }
+
+    /**
+     * Convenience method to set unmetered network requirement.
+     *
+     * @param requiresUnmeteredNetwork true|false
+     * @param timeout The timeout(ms) after which Job should be run without checking unmetered network
+     *                status. If {@code requiresUnmeteredNetwork} is {@code false}, this value is
+     *                ignored.
+     * @return this
+     * @see #setRequiresUnmeteredNetwork(boolean)
+     * @see #requireUnmeteredNetwork()
+     */
+    public Params setRequiresUnmeteredNetwork(boolean requiresUnmeteredNetwork, long timeout) {
+        if (!requiresUnmeteredNetwork) {
+            this.requiresUnmeteredNetworkWithTimeout = NEVER;
+        } else {
+            this.requiresUnmeteredNetworkWithTimeout = timeout;
+        }
+        return this;
+    }
+
+    /**
+     * Convenience method to set unmetered network requirement.
+     * @param requiresUnmeteredNetwork true|false
+     * @return this
+     * @see #setRequiresUnmeteredNetwork(boolean, long)
+     * @see #requireUnmeteredNetwork()
+     */
+    public Params setRequiresUnmeteredNetwork(boolean requiresUnmeteredNetwork) {
+        return setRequiresUnmeteredNetwork(requiresUnmeteredNetwork, FOREVER);
+    }
+
+    /**
+     * Returns when the Job's network requirement will timeout.
+     * <ul>
+     * <li>If the job does not require network, it will return {@link #NEVER}.</li>
+     * <li>If the job should never be run without network, it will return {@link #FOREVER}.</li>
+     * <li>Otherwise, it will return the timeout in ms until which the job should require network
+     * to be run and after that timeout it will be run regardless of the network requirements.</li>
+     * </ul>
+     *
+     * @return The network requirement constraint
+     */
+    public long getRequiresNetworkTimeoutMs() {
+        return requiresNetworkWithTimeout;
+    }
+
+    /**
+     * Returns when the Job's UNMETERED network requirement will timeout.
+     * <ul>
+     * <li>If the job does not require UNMETERED network, it will return {@link #NEVER}.</li>
+     * <li>If the job should never be run without UNMETERED network, it will return {@link #FOREVER}.</li>
+     * <li>Otherwise, it will return the timeout in ms until which the job should require network
+     * to be run and after that timeout it will be run regardless of the UNMETERED network requirements.
+     * It may still be requiring a network connection via {@link #requireNetwork()} or
+     * {@link #requireNetworkWithTimeout(long)}</li>
+     * </ul>
+     *
+     * @return The network requirement constraint
+     */
+    public long getRequiresUnmeteredNetworkTimeoutMs() {
+        return requiresUnmeteredNetworkWithTimeout;
+    }
+
+    /**
+     * Convenience method to set network requirement.
+     * <p>In case this timeout is set to a value smaller than
+     * {@link #requireUnmeteredNetworkWithTimeout(long)}, the unmetered network timeout will override
+     * this one.
+     *
+     * @param requiresNetwork True if Job should not be run without a network, false otherwise.
+     * @param timeout The timeout after which Job should be run without checking network status.
+     *                If {@code requiresNetwork} is {@code false}, this value is ignored.
+     *
+     * @return The params
+     * @see #setRequiresNetwork(boolean)
+     * @see #requireNetwork()
+     */
+    public Params setRequiresNetwork(boolean requiresNetwork, long timeout) {
+        if (requiresNetwork) {
+            requiresNetworkWithTimeout = timeout;
+        } else {
+            requiresNetworkWithTimeout = NEVER;
+        }
+        return this;
+    }
+
+    /**
+     * convenience method to set group id.
+     * @param groupId The group id for the job
+     * @return this
+     */
+    public Params setGroupId(String groupId) {
+        this.groupId = groupId;
+        return this;
+    }
+
+    /**
+     * convenience method to set single id.
+     * @param singleId The single instance run id for the job
+     * @return this
+     */
+    public Params setSingleId(String singleId) {
+        this.singleId = singleId;
+        return this;
+    }
+
+    /**
+     * convenience method to set whether {@link JobManager} should persist this job or not.
+     * @param persistent true|false
+     * @return this
+     */
+    public Params setPersistent(boolean persistent) {
+        this.persistent = persistent;
+        return this;
+    }
+
+    /**
+     * convenience method to set delay
+     * @param delayMs in ms
+     * @return this
+     */
+    public Params setDelayMs(long delayMs) {
+        this.delayMs = delayMs;
+        return this;
+    }
+
+    /**
+     * Attaches given tags to the Job.
+     * These are initially used for cancelling or querying jobs but usage will be extended
+     *
+     * @param newTags List of tags to add
+     * @return this
+     */
+    public Params addTags(String... newTags) {
+        if(tags == null) {
+            tags = new HashSet<>();
+        }
+        Collections.addAll(tags, newTags);
+        return this;
+    }
+
+    /**
+     * Removes the given tags from the Job.
+     *
+     * @param oldTags List of tags to be removed
+     * @return this
+     */
+    public Params removeTags(String... oldTags) {
+        if(tags == null) {
+            return this;
+        }
+        for(String tag : oldTags) {
+            tags.remove(tag);
+        }
+        return this;
+    }
+
+    public Params clearTags() {
+        tags = null;
+        return this;
+    }
+
+    public String getGroupId() {
+        return groupId;
+    }
+
+    public String getSingleId() {
+        return singleId;
+    }
+
+    public boolean isPersistent() {
+        return persistent;
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public long getDelayMs() {
+        return delayMs;
+    }
+
+    public HashSet<String> getTags() {
+        return tags;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/QueueFactory.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/QueueFactory.java
new file mode 100644
index 0000000..9832446
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/QueueFactory.java
@@ -0,0 +1,10 @@
+package com.birbit.android.jobqueue;
+
+
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.config.Configuration;
+
+public interface QueueFactory {
+    JobQueue createPersistentQueue(Configuration configuration, long sessionId);
+    JobQueue createNonPersistent(Configuration configuration, long sessionId);
+}
\ No newline at end of file
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/RetryConstraint.java
similarity index 97%
rename from jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/RetryConstraint.java
index f57a9c2..10f57ff 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/RetryConstraint.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/RetryConstraint.java
@@ -1,8 +1,4 @@
-package com.path.android.jobqueue;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
+package com.birbit.android.jobqueue;
 
 /**
  * Created by {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/RunningJobSet.java
similarity index 86%
rename from jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/RunningJobSet.java
index b47662d..9ed8511 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/RunningJobSet.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/RunningJobSet.java
@@ -1,4 +1,7 @@
-package com.path.android.jobqueue;
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.timer.Timer;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -16,14 +19,17 @@
     private final TreeSet<String> internalSet;
     private final Map<String, Long> groupDelays;
     private long groupDelayTimeout;
+    private final Timer timer;
 
-    public RunningJobSet() {
+    public RunningJobSet(Timer timer) {
         internalSet = new TreeSet<>();
         groupDelays = new HashMap<>();
         groupDelayTimeout = Long.MAX_VALUE;
+        this.timer = timer;
     }
 
     public synchronized void addGroupUntil(String group, long until) {
+        JqLog.d("add group delay to %s until %s", group, until);
         Long current = groupDelays.get(group);
         if (current != null) {
              if (current > until) {
@@ -36,7 +42,7 @@ public synchronized void addGroupUntil(String group, long until) {
     }
 
     public synchronized Collection<String> getSafe() {
-        final long now = now();
+        final long now = timer.nanoTime();
         if(publicClone == null || now > groupDelayTimeout) {
             if (groupDelays.isEmpty()) {
                 publicClone = new ArrayList<>(internalSet);
@@ -77,12 +83,18 @@ private long calculateNextDelayForGroups() {
     }
 
     public synchronized void add(String group) {
+        if (group == null) {
+            return;
+        }
         if(internalSet.add(group)) {
             publicClone = null;//invalidate
         }
     }
 
     public synchronized void remove(String group) {
+        if (group == null) {
+            return;
+        }
         if(internalSet.remove(group)) {
             publicClone = null;
         }
@@ -93,8 +105,4 @@ public synchronized void clear() {
         groupDelays.clear();
         publicClone = null;
     }
-
-    protected long now() {
-        return System.nanoTime();
-    }
 }
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/TagConstraint.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/TagConstraint.java
new file mode 100644
index 0000000..dc3084d
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/TagConstraint.java
@@ -0,0 +1,44 @@
+package com.birbit.android.jobqueue;
+
+import java.util.Collection;
+import java.util.Set;
+
+public enum TagConstraint {
+    ALL,
+    ANY;
+    public boolean matches(String[] constraintTags, Set<String> jobTags) {
+        if (this == TagConstraint.ANY) {
+            for (String tag : constraintTags) {
+                if (jobTags.contains(tag)) {
+                    return true;
+                }
+            }
+            return false;
+        } else {
+            for (String tag : constraintTags) {
+                if (!jobTags.contains(tag)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    public boolean matches(Collection<String> constraintTags, Set<String> jobTags) {
+        if (this == TagConstraint.ANY) {
+            for (String tag : constraintTags) {
+                if (jobTags.contains(tag)) {
+                    return true;
+                }
+            }
+            return false;
+        } else {
+            for (String tag : constraintTags) {
+                if (!jobTags.contains(tag)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/cachedQueue/CachedJobQueue.java
new file mode 100644
index 0000000..d87b968
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/cachedQueue/CachedJobQueue.java
@@ -0,0 +1,109 @@
+package com.birbit.android.jobqueue.cachedQueue;
+
+import com.birbit.android.jobqueue.Constraint;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobQueue;
+
+import java.util.Set;
+
+/**
+ * a class that implements {@link JobQueue} interface, wraps another {@link JobQueue} and caches
+ * results to avoid unnecessary queries to wrapped JobQueue.
+ * does very basic caching but should be sufficient for most of the repeated cases
+ * element
+ */
+public class CachedJobQueue implements JobQueue {
+    JobQueue delegate;
+    private Integer cachedCount;
+
+    public CachedJobQueue(JobQueue delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public boolean insert(JobHolder jobHolder) {
+        invalidateCache();
+        return delegate.insert(jobHolder);
+    }
+
+    private void invalidateCache() {
+        cachedCount = null;
+    }
+
+    @Override
+    public boolean insertOrReplace(JobHolder jobHolder) {
+        invalidateCache();
+        return delegate.insertOrReplace(jobHolder);
+    }
+
+    @Override
+    public void substitute(JobHolder newJob, JobHolder oldJob) {
+        invalidateCache();
+        delegate.substitute(newJob, oldJob);
+    }
+
+    @Override
+    public void remove(JobHolder jobHolder) {
+        invalidateCache();
+        delegate.remove(jobHolder);
+    }
+
+    @Override
+    public int count() {
+        if(cachedCount == null) {
+            cachedCount = delegate.count();
+        }
+        return cachedCount;
+    }
+
+    private boolean isEmpty() {
+        return cachedCount != null && cachedCount == 0;
+    }
+
+    @Override
+    public int countReadyJobs(Constraint constraint) {
+        if (isEmpty()) {
+            return 0;
+        }
+        return delegate.countReadyJobs(constraint);
+    }
+
+    @Override
+    public JobHolder nextJobAndIncRunCount(Constraint constraint) {
+        if(isEmpty()) {
+            return null;//we know we are empty, no need for querying
+        }
+        JobHolder holder = delegate.nextJobAndIncRunCount(constraint);
+        if (holder != null && cachedCount != null) {
+            cachedCount -= 1;
+        }
+        return holder;
+    }
+
+    @Override
+    public Long getNextJobDelayUntilNs(Constraint constraint) {
+        return delegate.getNextJobDelayUntilNs(constraint);
+    }
+
+    @Override
+    public void clear() {
+        invalidateCache();
+        delegate.clear();
+    }
+
+    @Override
+    public Set<JobHolder> findJobs(Constraint constraint) {
+        return delegate.findJobs(constraint);
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        invalidateCache();
+        delegate.onJobCancelled(holder);
+    }
+
+    @Override
+    public JobHolder findJobById(String id) {
+        return delegate.findJobById(id);
+    }
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallback.java
similarity index 53%
rename from jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallback.java
index 636b11e..cbad57b 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallback.java
@@ -1,10 +1,12 @@
-package com.path.android.jobqueue.callback;
+package com.birbit.android.jobqueue.callback;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.TagConstraint;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.TagConstraint;
 
 /**
  * A callback class that you can attach to the JobManager to get notified as Jobs change states.
@@ -24,12 +26,20 @@
     /**
      * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
      * and will be cancelled because it was cancelled via
-     * {@link JobManager#cancelJobs(TagConstraint, String...)} while it was running.
+     * {@link com.birbit.android.jobqueue.JobManager#cancelJobs(TagConstraint, String...)} while it was running.
      *
-     * @see JobManager#cancelJobs(TagConstraint, String...)
-     * @see JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
+     * @see com.birbit.android.jobqueue.JobManager#cancelJobs(TagConstraint, String...)
+     * @see com.birbit.android.jobqueue.JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
      */
     int RESULT_CANCEL_CANCELLED_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because another job with the same single instance id was
+     * queued while it was running.
+     *
+     * @see Job#getSingleInstanceId()
+     */
+    int RESULT_CANCEL_SINGLE_INSTANCE_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_SINGLE_ID;
     /**
      * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
      * and will be cancelled because it decided not to run again via
@@ -50,7 +60,7 @@
      *
      * @param job The Job that was added to the JobManager.
      */
-    void onJobAdded(Job job);
+    void onJobAdded(@NonNull Job job);
 
     /**
      * Called after a Job has been Run. Might be called multiple times if the Job runs multiple
@@ -62,18 +72,39 @@
      *                   <li>{@link #RESULT_SUCCEED}</li>
      *                   <li>{@link #RESULT_CANCEL_REACHED_RETRY_LIMIT}</li>
      *                   <li>{@link #RESULT_CANCEL_CANCELLED_WHILE_RUNNING}</li>
+     *                   <li>{@link #RESULT_CANCEL_SINGLE_INSTANCE_WHILE_RUNNING}</li>
      *                   <li>{@link #RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN}</li>
      *                   <li>{@link #RESULT_FAIL_WILL_RETRY}</li>
      *                   </ul>
      */
-    void onJobRun(Job job, int resultCode);
+    void onJobRun(@NonNull Job job, int resultCode);
 
     /**
      * Called when a job is cancelled.
      *
      * @param job              The Job that was cancelled.
      * @param byCancelRequest  If true, the Job was cancelled in response to a
-     *                         {@link JobManager#cancelJobs(TagConstraint, String...)} request.
+     *                         {@link com.birbit.android.jobqueue.JobManager#cancelJobs(TagConstraint, String...)} request.
+     * @param throwable        The exception that was thrown from the last execution of {@link Job#onRun()}
+     */
+    void onJobCancelled(@NonNull Job job, boolean byCancelRequest, @Nullable Throwable throwable);
+
+    /**
+     * Called <b>after</b> a Job is removed from the JobManager. It might be cancelled or onFinished.
+     * This call is a good place to be sure that JobManager is done with the Job.
+     *
+     * @param job The Job that was just removed from the JobManager.
+     */
+    void onDone(@NonNull Job job);
+
+    /**
+     * Called <b>after</b> a Job is run and its run result has been handled. For instance, if the
+     * Job is cancelled, this method is called after the job is removed from the queue.
+     *
+     * @param job The Job that just onFinished a run call.
+     * @param resultCode The result of the run call.
+     *
+     * @see #onJobRun(Job, int)
      */
-    void onJobCancelled(Job job, boolean byCancelRequest);
+    void onAfterJobRun(@NonNull Job job, int resultCode);
 }
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallbackAdapter.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallbackAdapter.java
new file mode 100644
index 0000000..899ac97
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/callback/JobManagerCallbackAdapter.java
@@ -0,0 +1,37 @@
+package com.birbit.android.jobqueue.callback;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.Job;
+
+/**
+ * An empty implementation of {@link JobManagerCallback}. You are advice to override this one
+ * instead so that if new methods are added to the interface, your code won't break.
+ */
+public class JobManagerCallbackAdapter implements JobManagerCallback {
+    @Override
+    public void onJobAdded(@NonNull Job job) {
+
+    }
+
+    @Override
+    public void onJobRun(@NonNull Job job, int resultCode) {
+
+    }
+
+    @Override
+    public void onJobCancelled(@NonNull Job job, boolean byCancelRequest, @Nullable Throwable throwable) {
+
+    }
+
+    @Override
+    public void onDone(@NonNull Job job) {
+
+    }
+
+    @Override
+    public void onAfterJobRun(@NonNull Job job, int resultCode) {
+
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/config/Configuration.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/config/Configuration.java
new file mode 100644
index 0000000..be9f99d
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/config/Configuration.java
@@ -0,0 +1,432 @@
+package com.birbit.android.jobqueue.config;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.DefaultQueueFactory;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.QueueFactory;
+import com.birbit.android.jobqueue.di.DependencyInjector;
+import com.birbit.android.jobqueue.log.CustomLogger;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.network.NetworkUtilImpl;
+import com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.timer.SystemTimer;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * {@link com.birbit.android.jobqueue.JobManager} configuration object
+ */
+public class Configuration {
+    /**
+     * The default id for a Job. If you have multiple JobManagers, you should set this value via
+     * {@link Builder#id(String)}
+     */
+    public static final String DEFAULT_ID = "default_job_manager";
+    /**
+     * The default timeout for an idle thread before it is destroyed
+     */
+    public static final int DEFAULT_THREAD_KEEP_ALIVE_SECONDS = 15;
+    /**
+     * The default number of jobs per thread before JobManager creates a new one
+     */
+    public static final int DEFAULT_LOAD_FACTOR_PER_CONSUMER = 3;
+    /**
+     * The default max number of consumers that will be created by the JobManager
+     */
+    public static final int MAX_CONSUMER_COUNT = 5;
+    /**
+     * The default min number of consumers that will be kept alive by the JobManager
+     */
+    public static final int MIN_CONSUMER_COUNT = 0;
+    /**
+     * The default priority for new job consumers ({@code Thread.NORM_PRIORITY}).
+     */
+    public static final int DEFAULT_THREAD_PRIORITY = Thread.NORM_PRIORITY;
+
+    String id = DEFAULT_ID;
+    int maxConsumerCount = MAX_CONSUMER_COUNT;
+    int minConsumerCount = MIN_CONSUMER_COUNT;
+    int consumerKeepAlive = DEFAULT_THREAD_KEEP_ALIVE_SECONDS;
+    int loadFactor = DEFAULT_LOAD_FACTOR_PER_CONSUMER;
+    Context appContext;
+    QueueFactory queueFactory;
+    DependencyInjector dependencyInjector;
+    NetworkUtil networkUtil;
+    CustomLogger customLogger;
+    Timer timer;
+    Scheduler scheduler;
+    boolean inTestMode = false;
+    boolean resetDelaysOnRestart = false;
+    int threadPriority = DEFAULT_THREAD_PRIORITY;
+    boolean batchSchedulerRequests = true;
+    ThreadFactory threadFactory = null;
+
+    private Configuration(){
+        //use builder instead
+    }
+
+    @NonNull
+    public Context getAppContext() {
+        return appContext;
+    }
+
+    @NonNull
+    public String getId() {
+        return id;
+    }
+
+    public boolean batchSchedulerRequests() {
+        return batchSchedulerRequests;
+    }
+
+    @NonNull
+    public QueueFactory getQueueFactory() {
+        return queueFactory;
+    }
+
+    @Nullable
+    public DependencyInjector getDependencyInjector() {
+        return dependencyInjector;
+    }
+
+    public int getConsumerKeepAlive() {
+        return consumerKeepAlive;
+    }
+
+    @NonNull
+    public NetworkUtil getNetworkUtil() {
+        return networkUtil;
+    }
+
+    public int getMaxConsumerCount() {
+        return maxConsumerCount;
+    }
+
+    public int getMinConsumerCount() {
+        return minConsumerCount;
+    }
+
+    @Nullable
+    public CustomLogger getCustomLogger() {
+        return customLogger;
+    }
+
+    public int getLoadFactor() {
+        return loadFactor;
+    }
+
+    public boolean isInTestMode() {
+        return inTestMode;
+    }
+
+    @NonNull
+    public Timer getTimer() {
+        return timer;
+    }
+
+    public boolean resetDelaysOnRestart() {
+        return resetDelaysOnRestart;
+    }
+
+    @Nullable
+    public Scheduler getScheduler() {
+        return scheduler;
+    }
+
+    public int getThreadPriority() {
+        return threadPriority;
+    }
+
+    @Nullable
+    public ThreadFactory getThreadFactory() {
+        return threadFactory;
+    }
+
+    public static final class Builder {
+        private Configuration configuration;
+
+        public Builder(@NonNull Context context) {
+            this.configuration = new Configuration();
+            this.configuration.appContext = context.getApplicationContext();
+        }
+
+        /**
+         * provide and ID for this job manager to be used while creating persistent queue. it is useful if you are going to
+         * create multiple instances of it.
+         * default id is {@link #DEFAULT_ID}
+         * @param id if you have multiple instances of job manager, you should provide an id to distinguish their persistent files.
+         */
+        @NonNull
+        public Builder id(@NonNull String id) {
+            configuration.id = id;
+            return this;
+        }
+
+        /**
+         * When JobManager runs out of `ready` jobs, it will keep consumers alive for this duration.
+         * It defaults to {@link #DEFAULT_THREAD_KEEP_ALIVE_SECONDS}
+         * @param keepAlive in seconds
+         */
+        @NonNull
+        public Builder consumerKeepAlive(int keepAlive) {
+            configuration.consumerKeepAlive = keepAlive;
+            return this;
+        }
+
+        /**
+         * JobManager 1.x versions used to clear delay for existing jobs when the application is
+         * restarted because there is no reliable way to measure time difference between device
+         * reboots (and from the app's perspective, device reboot is no different than app restart).
+         * <p>
+         * This may cause unexpected behaviors as delayed persistent jobs instantly become available
+         * when application restarts.
+         * <p>
+         * JobManager 2.x versions change this behavior and does not reset the delay of persistent
+         * jobs on restart. This may create a problem if jobs were added when the device's clock is
+         * set to some unreasonable time but for common cases, it is more desirable.
+         * <p>
+         * You can get the v1 behavior by calling this method. Note that it will also effect jobs
+         * which require network with a timeout. Their timeouts will be triggered on restart if you
+         * call this method.
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder resetDelaysOnRestart() {
+            configuration.resetDelaysOnRestart = true;
+            return this;
+        }
+
+        /**
+         * JobManager needs one persistent and one non-persistent {@link JobQueue} to function.
+         * By default, it will use {@link SqliteJobQueue} and
+         * {@link com.birbit.android.jobqueue.inMemoryQueue.SimpleInMemoryPriorityQueue}
+         * You can provide your own implementation if they don't fit your needs. Make sure it passes all tests in
+         * {@code JobQueueTestBase} to ensure it will work fine.
+         * @param queueFactory your custom queue factory.
+         */
+        @NonNull
+        public Builder queueFactory(@Nullable QueueFactory queueFactory) {
+            if(configuration.queueFactory != null && queueFactory != null) {
+                throw new RuntimeException("already set a queue factory. This might happen if"
+                        + "you've provided a custom job serializer");
+            }
+            configuration.queueFactory = queueFactory;
+            return this;
+        }
+
+        /**
+         * convenient configuration to replace job serializer while using {@link SqliteJobQueue}
+         * queue for persistence. By default, it uses a
+         * {@link com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue.JavaSerializer}
+         * which will use default Java serialization.
+         * @param jobSerializer The serializer to be used to persist jobs.
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder jobSerializer(@NonNull SqliteJobQueue.JobSerializer jobSerializer) {
+            configuration.queueFactory = new DefaultQueueFactory(jobSerializer);
+            return this;
+        }
+
+        /**
+         * By default, Job Manager comes with a simple {@link NetworkUtilImpl} that queries {@link ConnectivityManager}
+         * to check if network connection exists. You can provide your own if you need a custom logic (e.g. check your
+         * server health etc).
+         */
+        @NonNull
+        public Builder networkUtil(@Nullable NetworkUtil networkUtil) {
+            configuration.networkUtil = networkUtil;
+            return this;
+        }
+
+        /**
+         * JobManager is suitable for DependencyInjection. Just provide your DependencyInjector and it will call it
+         * before {Job#onAdded} method is called.
+         * if job is persistent, it will also be called before run method.
+         * @param injector your dependency injector interface, if using one
+         * @return The builder
+         */
+        @NonNull
+        public Builder injector(@Nullable DependencyInjector injector) {
+            configuration.dependencyInjector = injector;
+            return this;
+        }
+
+        /**
+         * # of max consumers to run concurrently. defaults to {@link #MAX_CONSUMER_COUNT}
+         * @param count The max number of threads that JobManager can create to run jobs
+         */
+        @NonNull
+        public Builder maxConsumerCount(int count) {
+            configuration.maxConsumerCount = count;
+            return this;
+        }
+
+        /**
+         * you can specify to keep minConsumers alive even if there are no ready jobs. defaults to
+         * {@link #MIN_CONSUMER_COUNT}
+         *
+         * @param count The min of of threads that JobManager will keep alive even if they are idle.
+         */
+        @NonNull
+        public Builder minConsumerCount(int count) {
+            configuration.minConsumerCount = count;
+            return this;
+        }
+
+        /**
+         * You can specify a custom timer to control task execution. Useful for testing.
+         *
+         * @param timer The timer to use
+         */
+        @NonNull
+        public Builder timer(@Nullable Timer timer) {
+            configuration.timer = timer;
+            return this;
+        }
+
+        /**
+         * you can provide a custom logger to get logs from JobManager.
+         * by default, logs will go no-where.
+         * @param logger The logger to be used by the JobManager.
+         */
+        @NonNull
+        public Builder customLogger(@Nullable CustomLogger logger) {
+            configuration.customLogger = logger;
+            return this;
+        }
+
+        /**
+         * calculated by # of jobs (running+waiting) per thread
+         * for instance, at a given time, if you have two consumers and 10 jobs in waiting queue (or running right now), load is
+         * (10/2) =5
+         * defaults to {@link #DEFAULT_LOAD_FACTOR_PER_CONSUMER}
+         *
+         * @param loadFactor Number of available jobs per thread
+         */
+        @NonNull
+        public Builder loadFactor(int loadFactor) {
+            configuration.loadFactor = loadFactor;
+            return this;
+        }
+
+        /**
+         * Sets the JobManager in test mode. This information is passed to JobQueue's.
+         * If you are using default JobQueues, calling this method will cause {@link SqliteJobQueue}
+         * to use an in-memory database.
+         */
+        @NonNull
+        public Builder inTestMode() {
+            configuration.inTestMode = true;
+            return this;
+        }
+
+        /**
+         * Assigns a scheduler that can be used to wake up the application when JobManager has jobs
+         * to execute. This is the integration point with the system
+         * {@link android.app.job.JobScheduler}.
+         * <p>
+         * <b>Batching</b>
+         * <br/>
+         * By default, JobManager batches scheduling requests so that it will not call JobScheduler
+         * too many times. For instance, if a persistent job that requires network is added, when
+         * batching is enabled, JobManager creates the JobScheduler request with
+         * {@link com.birbit.android.jobqueue.BatchingScheduler#DEFAULT_BATCHING_PERIOD_IN_MS} delay.
+         * Any subsequent job request that has the same criteria will use the previous batching
+         * request. This way, JobManager can avoid making a JobScheduler request for every job.
+         * It will still execute the Job if it becomes available without waiting for the delay but
+         * if the application is killed, the JobScheduler will wait until the delay passes before
+         * waking up the application to consume the jobs.
+         *
+         * @param scheduler The scheduler to be used
+         * @param batch     Defines whether the scheduling requests should be batched or not.
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder scheduler(@Nullable Scheduler scheduler, boolean batch) {
+            configuration.scheduler = scheduler;
+            configuration.batchSchedulerRequests = batch;
+            return this;
+        }
+
+        /**
+         * Sets the priority for the threads of this manager. By default it is
+         * {@link #DEFAULT_THREAD_PRIORITY}.<br />
+         * If a {@link ThreadFactory} is provided, this value is ignored.
+         *
+         * @param threadPriority The thread priority to be used for new jobs
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder consumerThreadPriority(int threadPriority) {
+            configuration.threadPriority = threadPriority;
+            return this;
+        }
+
+        /**
+         * Assigns a scheduler that can be used to wake up the application when JobManager has jobs
+         * to execute. This is the integration point with the system
+         * {@link android.app.job.JobScheduler}.
+         * <p>
+         * <b>Batching</b>
+         * <br/>
+         * By default, JobManager batches scheduling requests so that it will not call JobScheduler
+         * too many times. For instance, if a persistent job that requires network is added, when
+         * batching is enabled, JobManager creates the JobScheduler request with
+         * {@link com.birbit.android.jobqueue.BatchingScheduler#DEFAULT_BATCHING_PERIOD_IN_MS} delay.
+         * Any subsequent job request that has the same criteria will use the previous batching
+         * request. This way, JobManager can avoid making a JobScheduler request for every job.
+         * It will still execute the Job if it becomes available without waiting for the delay but
+         * if the application is killed, the JobScheduler will wait until the delay passes before
+         * waking up the application to consume the jobs.
+         *
+         * @param scheduler The scheduler to be used
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder scheduler(@Nullable Scheduler scheduler) {
+            return scheduler(scheduler, true);
+        }
+
+        /**
+         * Provide a factory class to create new worker instances when JobManager needs them.<br />
+         * When a factory is installed, it becomes its responsability to configure
+         * the {@link Thread} with proper group and priority. JobManager will use the {@link Thread}
+         * as is.
+         *
+         * @param threadFactory The factory to be used
+         *
+         * @return The builder
+         */
+        @NonNull
+        public Builder threadFactory(@Nullable final ThreadFactory threadFactory) {
+            configuration.threadFactory = threadFactory;
+            return this;
+        }
+
+        @NonNull
+        public Configuration build() {
+            if(configuration.queueFactory == null) {
+                configuration.queueFactory = new DefaultQueueFactory();
+            }
+            if(configuration.networkUtil == null) {
+                configuration.networkUtil = new NetworkUtilImpl(configuration.appContext);
+            }
+            if (configuration.timer == null) {
+                configuration.timer = new SystemTimer();
+            }
+            return configuration;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/di/DependencyInjector.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/di/DependencyInjector.java
new file mode 100644
index 0000000..0e093a0
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/di/DependencyInjector.java
@@ -0,0 +1,12 @@
+package com.birbit.android.jobqueue.di;
+
+import com.birbit.android.jobqueue.Job;
+
+/**
+ * interface that can be provided to {@link com.birbit.android.jobqueue.JobManager} for dependency injection
+ * it is called before the job's onAdded method is called. for persistent jobs, also run after job is brought
+ * back from disk.
+ */
+public interface DependencyInjector {
+    void inject(Job job);
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/inMemoryQueue/SimpleInMemoryPriorityQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/inMemoryQueue/SimpleInMemoryPriorityQueue.java
new file mode 100644
index 0000000..e05c7f0
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/inMemoryQueue/SimpleInMemoryPriorityQueue.java
@@ -0,0 +1,253 @@
+package com.birbit.android.jobqueue.inMemoryQueue;
+
+import com.birbit.android.jobqueue.Constraint;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * A simple implementation of in memory {@link com.birbit.android.jobqueue.JobQueue}
+ */
+public class SimpleInMemoryPriorityQueue implements JobQueue {
+    private final TreeSet<JobHolder> jobs = new TreeSet<>(new Comparator<JobHolder>() {
+        @Override
+        public int compare(JobHolder holder1, JobHolder holder2) {
+            if (holder1.getJob().getId().equals(holder2.getJob().getId())) {
+                return 0;
+            }
+            int cmp = compareInt(holder1.getPriority(), holder2.getPriority());
+            if(cmp != 0) {
+                return cmp;
+            }
+
+            cmp = -compareLong(holder1.getCreatedNs(), holder2.getCreatedNs());
+            if(cmp != 0) {
+                return cmp;
+            }
+            //if jobs were created at the same time, smaller id first
+            return -compareLong(holder1.getInsertionOrder(), holder2.getInsertionOrder());
+        }
+
+        private int compareInt(int i1, int i2) {
+            if (i1 > i2) {
+                return -1;
+            }
+            if (i2 > i1) {
+                return 1;
+            }
+            return 0;
+        }
+
+        private int compareLong(long l1, long l2) {
+            if (l1 > l2) {
+                return -1;
+            }
+            if (l2 > l1) {
+                return 1;
+            }
+            return 0;
+        }
+    });
+    private final Map<String, JobHolder> idCache = new HashMap<>();
+
+    private final AtomicLong insertionOrderCounter = new AtomicLong(0);
+    private final List<String> reusedList = new ArrayList<>();
+    private final long sessionId;
+
+    public SimpleInMemoryPriorityQueue(
+            @SuppressWarnings("UnusedParameters") Configuration configuration, long sessionId) {
+        this.sessionId = sessionId;
+    }
+    @Override
+    public boolean insert(JobHolder jobHolder) {
+        jobHolder.setInsertionOrder(insertionOrderCounter.incrementAndGet());
+        JobHolder existing = idCache.get(jobHolder.getId());
+        if (existing != null) {
+            throw new IllegalArgumentException("cannot add a job with the same id twice");
+        }
+        idCache.put(jobHolder.getId(), jobHolder);
+        jobs.add(jobHolder);
+        return true;
+    }
+
+    @Override
+    public boolean insertOrReplace(JobHolder jobHolder) {
+        if (jobHolder.getInsertionOrder() == null) {
+            return insert(jobHolder);
+        }
+        JobHolder existing = idCache.get(jobHolder.getId());
+        if (existing != null) {
+            remove(existing);
+        }
+        idCache.put(jobHolder.getId(), jobHolder);
+        jobs.add(jobHolder);
+        return true;
+    }
+
+    @Override
+    public void substitute(JobHolder newJob, JobHolder oldJob) {
+        remove(oldJob);
+        insert(newJob);
+    }
+
+    @Override
+    public void remove(JobHolder jobHolder) {
+        idCache.remove(jobHolder.getId());
+        jobs.remove(jobHolder);
+    }
+
+    @Override
+    public int count() {
+        return jobs.size();
+    }
+
+    @Override
+    public int countReadyJobs(Constraint constraint) {
+        int count = 0;
+        reusedList.clear();
+        for (JobHolder holder : jobs) {
+            String groupId = holder.getGroupId();
+            if ((groupId == null || !reusedList.contains(groupId)) && matches(holder, constraint)) {
+                count ++;
+                if (groupId != null) {
+                    reusedList.add(groupId);
+                }
+            }
+        }
+        reusedList.clear();
+        return count;
+    }
+
+    @Override
+    public JobHolder nextJobAndIncRunCount(Constraint constraint) {
+        for (JobHolder holder : jobs) {
+            if (matches(holder, constraint)) {
+                remove(holder);
+                holder.setRunCount(holder.getRunCount() + 1);
+                holder.setRunningSessionId(sessionId);
+                return holder;
+            }
+        }
+        return null;
+    }
+
+    private static Long getDelayUntil(JobHolder holder, boolean hasNetwork, boolean hasUnmetered) {
+        final long networkTimeout = holder.getRequiresNetworkUntilNs();
+        final long unmeteredTimeout = holder.getRequiresUnmeteredNetworkUntilNs();
+        long delay = holder.getDelayUntilNs();
+
+        if (!hasNetwork) {
+            if (networkTimeout == Params.FOREVER) {
+                return null; // ineligible
+            }
+            delay = Math.max(delay, networkTimeout);
+        }
+        if (!hasUnmetered) {
+            if (unmeteredTimeout == Params.FOREVER) {
+                return null; // ineligible
+            }
+            delay = Math.max(delay, unmeteredTimeout);
+        }
+        return delay;
+    }
+
+    @Override
+    public Long getNextJobDelayUntilNs(Constraint constraint) {
+        Long minDelay = null;
+        boolean hasNetwork = !constraint.shouldNotRequireNetwork();
+        boolean hasUnmetered = !constraint.shouldNotRequireUnmeteredNetwork();
+        if (!hasNetwork || !hasUnmetered) {
+            for (JobHolder holder : jobs) {
+                if (matches(holder, constraint, true)) {
+                    final Long delay = getDelayUntil(holder, hasNetwork, hasUnmetered);
+                    if (delay == null) {
+                        continue;// ineligible
+                    }
+                    if (minDelay == null || delay < minDelay) {
+                        minDelay = delay;
+                    }
+                }
+            }
+        } else {
+            for (JobHolder holder : jobs) {
+                if (matches(holder, constraint)) {
+                    if (minDelay == null || holder.getDelayUntilNs() < minDelay) {
+                        minDelay = holder.getDelayUntilNs();
+                    }
+                }
+            }
+        }
+
+        return minDelay;
+    }
+
+    @Override
+    public void clear() {
+        jobs.clear();
+        idCache.clear();
+    }
+
+    @Override
+    public JobHolder findJobById(String id) {
+        return idCache.get(id);
+    }
+
+    @Override
+    public Set<JobHolder> findJobs(Constraint constraint) {
+        Set<JobHolder> result = new HashSet<>();
+        for (JobHolder holder : jobs) {
+            if (matches(holder, constraint)) {
+                result.add(holder);
+            }
+        }
+        return result;
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        remove(holder);
+    }
+
+    private static boolean matches(JobHolder holder, Constraint constraint) {
+        return matches(holder, constraint, false);
+    }
+    @SuppressWarnings("RedundantIfStatement")
+    private static boolean matches(JobHolder holder, Constraint constraint, boolean ignoreNetwork) {
+        if (!ignoreNetwork) {
+            if (constraint.shouldNotRequireNetwork()
+                    && holder.requiresNetwork(constraint.getNowInNs())) {
+                return false;
+            }
+            if (constraint.shouldNotRequireUnmeteredNetwork()
+                    && holder.requiresUnmeteredNetwork(constraint.getNowInNs())) {
+                return false;
+            }
+        }
+        if (constraint.getTimeLimit() != null && holder.getDelayUntilNs() > constraint.getTimeLimit()) {
+            return false;
+        }
+        if (holder.getGroupId() != null && constraint.getExcludeGroups().contains(holder.getGroupId())) {
+            return false;
+        }
+        if (constraint.getExcludeJobIds().contains(holder.getId())) {
+            return false;
+        }
+        if (constraint.getTagConstraint() != null &&
+                (holder.getTags() == null || constraint.getTags().isEmpty() ||
+                !constraint.getTagConstraint().matches(constraint.getTags(), holder.getTags()))) {
+            return false;
+        }
+        return true;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/log/CustomLogger.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/log/CustomLogger.java
new file mode 100644
index 0000000..2f61ed9
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/log/CustomLogger.java
@@ -0,0 +1,17 @@
+package com.birbit.android.jobqueue.log;
+
+/**
+ * You can provide your own logger implementation to {@link com.birbit.android.jobqueue.JobManager}
+ * it is very similar to Roboguice's logger
+ */
+public interface CustomLogger {
+    /**
+     * JobManager may call this before logging something that is (relatively) expensive to calculate
+     * @return True if debug logs are enabled
+     */
+    boolean isDebugEnabled();
+    void d(String text, Object... args);
+    void e(Throwable t, String text, Object... args);
+    void e(String text, Object... args);
+    void v(String text, Object... args);
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/log/JqLog.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/log/JqLog.java
new file mode 100644
index 0000000..f031d1e
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/log/JqLog.java
@@ -0,0 +1,66 @@
+package com.birbit.android.jobqueue.log;
+
+/**
+ * Wrapper around {@link CustomLogger}. by default, logs to nowhere
+ */
+public class JqLog {
+    private static CustomLogger customLogger;
+    static {
+        clearLogger();
+    }
+
+    public static void clearLogger() {
+        setCustomLogger(new CustomLogger() {
+            @Override
+            public boolean isDebugEnabled() {
+                return false;
+            }
+
+            @Override
+            public void d(String text, Object... args) {
+                //void
+            }
+
+            @Override
+            public void e(Throwable t, String text, Object... args) {
+                //void
+            }
+
+            @Override
+            public void e(String text, Object... args) {
+                //void
+            }
+
+            @Override
+            public void v(String text, Object... args) {
+                //void
+            }
+        });
+    }
+
+    public static void setCustomLogger(CustomLogger customLogger) {
+        JqLog.customLogger = customLogger;
+    }
+
+    public static boolean isDebugEnabled() {
+        return customLogger.isDebugEnabled();
+    }
+
+    public static void d(String text, Object... args) {
+        if (isDebugEnabled()) {
+            customLogger.d(text, args);
+        }
+    }
+
+    public static void e(Throwable t, String text, Object... args) {
+        customLogger.e(t, text, args);
+    }
+
+    public static void e(String text, Object... args) {
+        customLogger.e(text, args);
+    }
+
+    public static void v(String text, Object... args) {
+        customLogger.v(text, args);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/DelayedMessageBag.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/DelayedMessageBag.java
new file mode 100644
index 0000000..381a3f1
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/DelayedMessageBag.java
@@ -0,0 +1,77 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+class DelayedMessageBag {
+    Message queue = null;
+    final MessageFactory factory;
+
+    DelayedMessageBag(MessageFactory factory) {
+        this.factory = factory;
+    }
+
+    Long flushReadyMessages(long now, MessageQueue addInto) {
+        JqLog.d("flushing messages at time %s", now);
+        while (queue != null && queue.readyNs <= now) {
+            Message msg = queue;
+            queue = msg.next;
+            msg.next = null;
+            addInto.post(msg);
+        }
+        if (queue != null) {
+            JqLog.d("returning next ready at %d ns", (queue.readyNs - now));
+            return queue.readyNs;
+        }
+        return null;
+    }
+    void add(Message message, long readyNs) {
+        JqLog.d("add delayed message %s at time %s", message, readyNs);
+        message.readyNs = readyNs;
+        if (queue == null) {
+            queue = message;
+            return;
+        }
+        Message prev = null;
+        Message curr = queue;
+        while (curr != null && curr.readyNs <= readyNs) {
+            prev = curr;
+            curr = curr.next;
+        }
+        if (prev == null) {
+            message.next = queue;
+            queue = message;
+        } else {
+            prev.next = message;
+            message.next = curr;
+        }
+    }
+
+    public void clear() {
+        while (queue != null) {
+            Message curr = queue;
+            queue = curr.next;
+            factory.release(curr);
+        }
+        queue = null;
+    }
+
+    public void removeMessages(MessagePredicate predicate) {
+        Message prev = null;
+        Message curr = queue;
+        while (curr != null) {
+            final boolean remove = predicate.onMessage(curr);
+            final Message next = curr.next;
+            if (remove) {
+                if (prev == null) {
+                    queue = curr.next;
+                } else {
+                    prev.next = curr.next;
+                }
+                factory.release(curr);
+            } else {
+                prev = curr;
+            }
+            curr = next;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Message.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Message.java
new file mode 100644
index 0000000..cc488ab
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Message.java
@@ -0,0 +1,20 @@
+package com.birbit.android.jobqueue.messaging;
+
+abstract public class Message {
+    public final Type type;
+    // used by the pool
+    Message next;
+    public long readyNs = Long.MIN_VALUE;
+
+    protected Message(Type type) {
+        this.type = type;
+    }
+
+    abstract protected void onRecycled();
+
+    final void recycle() {
+        next = null;
+        readyNs = Long.MIN_VALUE;
+        onRecycled();
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageFactory.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageFactory.java
new file mode 100644
index 0000000..19e7bd9
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageFactory.java
@@ -0,0 +1,52 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.util.Arrays;
+
+public class MessageFactory {
+    private static final int CACHE_LIMIT = 20;
+    Message[] pools = new Message[Type.values().length];
+    int[] counts = new int[pools.length];
+
+    public MessageFactory() {
+        Arrays.fill(counts, 0);
+    }
+
+    public <T extends Message> T obtain(Class<T> klass) {
+        final Type type = Type.mapping.get(klass);
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (type) {
+            Message message = pools[type.ordinal()];
+            if (message != null) {
+                pools[type.ordinal()] = message.next;
+                counts[type.ordinal()] -= 1;
+                message.next = null;
+                //noinspection unchecked
+                return (T) message;
+            }
+            try {
+                return klass.newInstance();
+            } catch (InstantiationException e) {
+                JqLog.e(e, "Cannot create an instance of " + klass + ". Make sure it has a empty" +
+                        " constructor.");
+            } catch (IllegalAccessException e) {
+                JqLog.e(e, "Cannot create an instance of " + klass + ". Make sure it has a public" +
+                        " empty constructor.");
+            }
+        }
+        return null;
+    }
+    public void release(Message message) {
+        final Type type = message.type;
+        message.recycle();
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (type) {
+            if (counts[type.ordinal()] < CACHE_LIMIT) {
+                message.next = pools[type.ordinal()];
+                pools[type.ordinal()] = message;
+                counts[type.ordinal()] += 1;
+            }
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessagePredicate.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessagePredicate.java
new file mode 100644
index 0000000..ae68053
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessagePredicate.java
@@ -0,0 +1,5 @@
+package com.birbit.android.jobqueue.messaging;
+
+public interface MessagePredicate {
+    boolean onMessage(Message message);
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueue.java
new file mode 100644
index 0000000..ca62c5c
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueue.java
@@ -0,0 +1,10 @@
+package com.birbit.android.jobqueue.messaging;
+
+public interface MessageQueue {
+    void post(Message message);
+    void postAt(Message message, long readyNs);
+    void cancelMessages(MessagePredicate predicate);
+    void stop();
+    void consume(MessageQueueConsumer consumer);
+    void clear();
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueueConsumer.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueueConsumer.java
new file mode 100644
index 0000000..b70ba76
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/MessageQueueConsumer.java
@@ -0,0 +1,9 @@
+package com.birbit.android.jobqueue.messaging;
+
+public abstract class MessageQueueConsumer {
+    abstract public void handleMessage(Message message);
+    abstract public void onIdle();
+    public void onStart() {
+
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueue.java
new file mode 100644
index 0000000..d70ebbc
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueue.java
@@ -0,0 +1,151 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * Uses multiple message queues to simulate priority.
+ */
+public class PriorityMessageQueue implements MessageQueue {
+    private final Object LOCK = new Object();
+    private final UnsafeMessageQueue[] queues;
+    private final DelayedMessageBag delayedBag;
+    private final Timer timer;
+    private final AtomicBoolean running = new AtomicBoolean(false);
+    // used when jobs are posted inside sync blocks
+    private boolean postJobTick = false;
+    private final MessageFactory factory;
+    private static final String LOG_TAG = "priority_mq";
+
+    @SuppressWarnings("unused")
+    public PriorityMessageQueue(Timer timer, MessageFactory factory) {
+        delayedBag = new DelayedMessageBag(factory);
+        this.factory = factory;
+        queues = new UnsafeMessageQueue[Type.MAX_PRIORITY + 1];
+        this.timer = timer;
+    }
+
+    @Override
+    public void consume(MessageQueueConsumer consumer) {
+        if(running.getAndSet(true)) {
+            throw new IllegalStateException("only 1 consumer per MQ");
+        }
+        while (running.get()) {
+            Message message = next(consumer);
+            if (message != null) {
+                JqLog.d("[%s] consuming message of type %s", LOG_TAG, message.type);
+                consumer.handleMessage(message);
+                factory.release(message);
+            }
+        }
+    }
+
+    @Override
+    public void clear() {
+        synchronized (LOCK) {
+            for (int i = Type.MAX_PRIORITY; i >= 0; i--) {
+                UnsafeMessageQueue mq = queues[i];
+                if (mq == null) {
+                    continue;
+                }
+                mq.clear();
+            }
+        }
+    }
+
+    @Override
+    public void stop() {
+        running.set(false);
+        synchronized (LOCK) {
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    public Message next(MessageQueueConsumer consumer) {
+        boolean calledOnIdle = false;
+        while (running.get()) {
+            final Long nextDelayedReadyAt;
+            final long now;
+            synchronized (LOCK) {
+                now = timer.nanoTime();
+                JqLog.d("[%s] looking for next message at time %s", LOG_TAG, now);
+                nextDelayedReadyAt = delayedBag.flushReadyMessages(now, this);
+                JqLog.d("[%s] next delayed job %s", LOG_TAG, nextDelayedReadyAt);
+                for (int i = Type.MAX_PRIORITY; i >= 0; i--) {
+                    UnsafeMessageQueue mq = queues[i];
+                    if (mq == null) {
+                        continue;
+                    }
+                    Message message = mq.next();
+                    if (message != null) {
+                        return message;
+                    }
+                }
+                postJobTick = false;
+            }
+            if (!calledOnIdle) {
+                consumer.onIdle();
+                calledOnIdle = true;
+            }
+            synchronized (LOCK) {
+                JqLog.d("[%s] did on idle post a message? %s", LOG_TAG, postJobTick);
+                // callback may add new messages
+                if (postJobTick) {
+                    continue; // idle posted jobs, requery
+                }
+                if (nextDelayedReadyAt != null && nextDelayedReadyAt <= now) {
+                    continue;
+                }
+                if (running.get()) {
+                    try {
+                        if (nextDelayedReadyAt == null) {
+                            timer.waitOnObject(LOCK);
+                        } else {
+                            timer.waitOnObjectUntilNs(LOCK, nextDelayedReadyAt);
+                        }
+                    } catch (InterruptedException ignored) {
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public void post(Message message) {
+        synchronized (LOCK) {
+            postJobTick = true;
+            int index = message.type.priority;
+            if (queues[index] == null) {
+                queues[index] = new UnsafeMessageQueue(factory, "queue_" + message.type.name());
+            }
+            queues[index].post(message);
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    @Override
+    public void postAt(Message message, long readyNs) {
+        synchronized (LOCK) {
+            postJobTick = true;
+            delayedBag.add(message, readyNs);
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    @Override
+    public void cancelMessages(MessagePredicate predicate) {
+        synchronized (LOCK) {
+            for (int i = 0; i <= Type.MAX_PRIORITY; i++) {
+                UnsafeMessageQueue mq = queues[i];
+                if (mq == null) {
+                    continue;
+                }
+                mq.removeMessages(predicate);
+            }
+            delayedBag.removeMessages(predicate);
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/SafeMessageQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/SafeMessageQueue.java
new file mode 100644
index 0000000..56ea0b7
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/SafeMessageQueue.java
@@ -0,0 +1,139 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class SafeMessageQueue extends UnsafeMessageQueue implements MessageQueue {
+    private final Object LOCK = new Object();
+    private final AtomicBoolean running = new AtomicBoolean(false);
+    private final Timer timer;
+    private final DelayedMessageBag delayedBag;
+    // used to check if any new message is posted inside sync block
+    private boolean postMessageTick = false;
+    private final MessageFactory factory;
+    public SafeMessageQueue(Timer timer, MessageFactory factory, String logTag) {
+        super(factory, logTag);
+        this.factory = factory;
+        this.timer = timer;
+        this.delayedBag = new DelayedMessageBag(factory);
+    }
+
+    public boolean isRunning() {
+        return running.get();
+    }
+
+    @Override
+    public void consume(MessageQueueConsumer consumer) {
+        if(running.getAndSet(true)) {
+            throw new IllegalStateException("only 1 consumer per MQ");
+        }
+        consumer.onStart();
+        while (running.get()) {
+            Message message = next(consumer);
+            if (message != null) {
+                consumer.handleMessage(message);
+                factory.release(message);
+            }
+        }
+        JqLog.d("[%s] finished queue", logTag);
+    }
+
+    @Override
+    public void stop() {
+        running.set(false);
+        synchronized (LOCK) {
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    public void clear() {
+        synchronized (LOCK) {
+            super.clear();
+        }
+    }
+
+    Message next(MessageQueueConsumer consumer) {
+        boolean calledIdle = false;
+
+        while (running.get()) {
+            final Long nextDelayedReadyAt;
+            final long now;
+            synchronized (LOCK) {
+                now = timer.nanoTime();
+                nextDelayedReadyAt = delayedBag.flushReadyMessages(now, this);
+                Message message = super.next();
+                if (message != null) {
+                    return message;
+                }
+                postMessageTick = false;
+            }
+            // call onIdle outside the lock. This risks calling onIdle after a message post but
+            // it is better than locking post messages until idle finishes.
+            if (!calledIdle) {
+                consumer.onIdle();
+                calledIdle = true;
+            }
+            synchronized (LOCK) {
+                if (postMessageTick) {
+                    continue; // callback added a message, requery
+                }
+                if (nextDelayedReadyAt != null && nextDelayedReadyAt <= now) {
+                    JqLog.d("[%s] next message is ready, requery", logTag);
+                    continue;
+                }
+                if (running.get()) {
+                    try {
+                        if (nextDelayedReadyAt == null) {
+                            JqLog.d("[%s] will wait on the lock forever", logTag);
+                            timer.waitOnObject(LOCK);
+                        } else {
+                            JqLog.d("[%s] will wait on the lock until %d", logTag,
+                                    nextDelayedReadyAt);
+                            timer.waitOnObjectUntilNs(LOCK, nextDelayedReadyAt);
+                        }
+                    } catch (InterruptedException ignored) {
+                    }
+                }
+            }
+
+        }
+        return null;
+    }
+
+    @Override
+    public void post(Message message) {
+        synchronized (LOCK) {
+            postMessageTick = true;
+            super.post(message);
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    @Override
+    public void postAt(Message message, long readyNs) {
+        synchronized (LOCK) {
+            postMessageTick = true;
+            delayedBag.add(message, readyNs);
+            timer.notifyObject(LOCK);
+        }
+    }
+
+    @Override
+    public void cancelMessages(MessagePredicate predicate) {
+        synchronized (LOCK) {
+            super.removeMessages(predicate);
+            delayedBag.removeMessages(predicate);
+        }
+    }
+
+    @Override
+    public void postAtFront(Message message) {
+        synchronized (LOCK) {
+            postMessageTick = true;
+            super.postAtFront(message);
+            timer.notifyObject(LOCK);
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Type.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Type.java
new file mode 100644
index 0000000..90b71af
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/Type.java
@@ -0,0 +1,53 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
+import com.birbit.android.jobqueue.messaging.message.CallbackMessage;
+import com.birbit.android.jobqueue.messaging.message.CancelMessage;
+import com.birbit.android.jobqueue.messaging.message.CancelResultMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.ConstraintChangeMessage;
+import com.birbit.android.jobqueue.messaging.message.PublicQueryMessage;
+import com.birbit.android.jobqueue.messaging.message.JobConsumerIdleMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobResultMessage;
+import com.birbit.android.jobqueue.messaging.message.SchedulerMessage;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * All message types
+ */
+public enum Type {
+    CALLBACK(CallbackMessage.class, 0),
+    CANCEL_RESULT_CALLBACK(CancelResultMessage.class, 0),
+    RUN_JOB(RunJobMessage.class, 0),
+    COMMAND(CommandMessage.class, 0),
+    PUBLIC_QUERY(PublicQueryMessage.class, 0),
+    JOB_CONSUMER_IDLE(JobConsumerIdleMessage.class, 0), // MUST ARRIVE AFTER JOB RESULT
+    ADD_JOB(AddJobMessage.class, 1),
+    CANCEL(CancelMessage.class, 1),
+    CONSTRAINT_CHANGE(ConstraintChangeMessage.class, 2),
+    RUN_JOB_RESULT(RunJobResultMessage.class, 3),
+    SCHEDULER(SchedulerMessage.class, 4);
+    final Class<? extends Message> klass;
+    final static Map<Class<? extends Message>, Type> mapping;
+    final int priority; // higher is better
+    final static int MAX_PRIORITY;
+
+    Type(Class<? extends Message> klass, int priority) {
+        this.klass = klass;
+        this.priority = priority;
+    }
+    static {
+        int maxPriority = 0;
+        mapping = new HashMap<>();
+        for (Type type : Type.values()) {
+            mapping.put(type.klass, type);
+            if (type.priority > maxPriority) {
+                maxPriority = type.priority;
+            }
+        }
+        MAX_PRIORITY = maxPriority;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueue.java
new file mode 100644
index 0000000..66aded5
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueue.java
@@ -0,0 +1,86 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+class UnsafeMessageQueue {
+    private Message queue = null;
+    private Message tail = null;
+    private static final AtomicInteger idCounter = new AtomicInteger(0);
+    public final String logTag;
+    private final MessageFactory factory;
+
+    public UnsafeMessageQueue(MessageFactory factory, String logTag) {
+        this.factory = factory;
+        this.logTag = logTag + "_" + idCounter.incrementAndGet();
+    }
+
+    Message next() {
+        final Message result = queue;
+        JqLog.d("[%s] remove message %s", logTag, result);
+        if (result != null) {
+            queue = result.next;
+            if (tail == result) {
+                tail = null;
+            }
+        }
+        return result;
+    }
+
+    protected void post(Message message) {
+        JqLog.d("[%s] post message %s", logTag, message);
+        if (tail == null) {
+            queue = message;
+            tail = message;
+        } else {
+            tail.next = message;
+            tail = message;
+        }
+    }
+
+    protected void postAtFront(Message message) {
+        message.next = queue;
+        if (tail == null) {
+            tail = message;
+        }
+        queue = message;
+    }
+
+    protected void removeMessages(MessagePredicate predicate) {
+        Message prev = null;
+        Message curr = queue;
+        while (curr != null) {
+            final boolean remove = predicate.onMessage(curr);
+            if (remove) {
+                final Message next = curr.next;
+                remove(prev, curr);
+                curr = next;
+            } else {
+                prev = curr;
+                curr = curr.next;
+            }
+        }
+    }
+
+    private void remove(Message prev, Message curr) {
+        if (tail == curr) {
+            tail = prev;
+        }
+        if (prev == null) {
+            queue = curr.next;
+        } else {
+            prev.next = curr.next;
+        }
+        factory.release(curr);
+    }
+
+    public void clear() {
+        while (queue != null) {
+            Message curr = queue;
+            queue = curr.next;
+            factory.release(curr);
+        }
+        tail = null;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/AddJobMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/AddJobMessage.java
new file mode 100644
index 0000000..68d928c
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/AddJobMessage.java
@@ -0,0 +1,25 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.Job;
+
+public class AddJobMessage extends Message {
+    private Job job;
+    public AddJobMessage() {
+        super(Type.ADD_JOB);
+    }
+
+    public Job getJob() {
+        return job;
+    }
+
+    public void setJob(Job job) {
+        this.job = job;
+    }
+
+    @Override
+    protected void onRecycled() {
+        job = null;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CallbackMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CallbackMessage.java
new file mode 100644
index 0000000..2ee8a40
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CallbackMessage.java
@@ -0,0 +1,73 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+
+/**
+ * Used for external callbacks to user code
+ */
+public class CallbackMessage extends Message {
+    public static final int ON_ADDED = 1;
+    public static final int ON_RUN = 2;
+    public static final int ON_CANCEL = 3;
+    public static final int ON_DONE = 4;
+    public static final int ON_AFTER_RUN = 5;
+
+    private int what;
+    private int resultCode;
+    private boolean byUserRequest;
+    private Job job;
+    @Nullable private Throwable throwable;
+
+    public CallbackMessage() {
+        super(Type.CALLBACK);
+    }
+
+    @Override
+    protected void onRecycled() {
+        job = null;
+        throwable = null;
+    }
+
+    public void set(Job job, int what) {
+        this.what = what;
+        this.job = job;
+    }
+
+    public void set(Job job, int what, int resultCode) {
+        this.what = what;
+        this.resultCode = resultCode;
+        this.job = job;
+    }
+
+    public void set(Job job, int what, boolean byUserRequest, @Nullable Throwable throwable) {
+        this.what = what;
+        this.byUserRequest = byUserRequest;
+        this.job = job;
+        this.throwable = throwable;
+    }
+
+    public int getWhat() {
+        return what;
+    }
+
+    public int getResultCode() {
+        return resultCode;
+    }
+
+    public boolean isByUserRequest() {
+        return byUserRequest;
+    }
+
+    public Job getJob() {
+        return job;
+    }
+
+    @Nullable
+    public Throwable getThrowable() {
+        return throwable;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelMessage.java
new file mode 100644
index 0000000..6134caf
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelMessage.java
@@ -0,0 +1,45 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.TagConstraint;
+
+public class CancelMessage extends Message {
+    private TagConstraint constraint;
+    private String[] tags;
+    private CancelResult.AsyncCancelCallback callback;
+
+    public CancelMessage() {
+        super(Type.CANCEL);
+    }
+
+    @Override
+    protected void onRecycled() {
+
+    }
+
+    public TagConstraint getConstraint() {
+        return constraint;
+    }
+
+    public void setConstraint(TagConstraint constraint) {
+        this.constraint = constraint;
+    }
+
+    public String[] getTags() {
+        return tags;
+    }
+
+    public void setTags(String[] tags) {
+        this.tags = tags;
+    }
+
+    public CancelResult.AsyncCancelCallback getCallback() {
+        return callback;
+    }
+
+    public void setCallback(CancelResult.AsyncCancelCallback callback) {
+        this.callback = callback;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelResultMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelResultMessage.java
new file mode 100644
index 0000000..abea7a3
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CancelResultMessage.java
@@ -0,0 +1,32 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.CancelResult;
+
+public class CancelResultMessage extends Message {
+    CancelResult.AsyncCancelCallback callback;
+    CancelResult result;
+    public CancelResultMessage() {
+        super(Type.CANCEL_RESULT_CALLBACK);
+    }
+
+    @Override
+    protected void onRecycled() {
+        result = null;
+        callback = null;
+    }
+
+    public void set(CancelResult.AsyncCancelCallback callback, CancelResult result) {
+        this.callback = callback;
+        this.result = result;
+    }
+
+    public CancelResult.AsyncCancelCallback getCallback() {
+        return callback;
+    }
+
+    public CancelResult getResult() {
+        return result;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CommandMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CommandMessage.java
new file mode 100644
index 0000000..d0660cb
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/CommandMessage.java
@@ -0,0 +1,32 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+
+public class CommandMessage extends Message {
+    public static final int QUIT = 1;
+    public static final int POKE = 2; // simple message to wake it up
+    private int what;
+
+    public CommandMessage() {
+        super(Type.COMMAND);
+    }
+
+    @Override
+    protected void onRecycled() {
+        what = -1;
+    }
+
+    public int getWhat() {
+        return what;
+    }
+
+    public void set(int what) {
+        this.what = what;
+    }
+
+    @Override
+    public String toString() {
+        return "Command[" + what + "]";
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/ConstraintChangeMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/ConstraintChangeMessage.java
new file mode 100644
index 0000000..091c8db
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/ConstraintChangeMessage.java
@@ -0,0 +1,16 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+
+public class ConstraintChangeMessage extends Message {
+    public ConstraintChangeMessage() {
+        super(Type.CONSTRAINT_CHANGE);
+    }
+
+    @Override
+    protected void onRecycled() {
+
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/JobConsumerIdleMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/JobConsumerIdleMessage.java
new file mode 100644
index 0000000..7da0c3f
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/JobConsumerIdleMessage.java
@@ -0,0 +1,34 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+
+public class JobConsumerIdleMessage extends Message {
+    private Object worker;
+    private long lastJobCompleted;
+
+    public JobConsumerIdleMessage() {
+        super(Type.JOB_CONSUMER_IDLE);
+    }
+
+    @Override
+    protected void onRecycled() {
+        worker = null;
+    }
+
+    public long getLastJobCompleted() {
+        return lastJobCompleted;
+    }
+
+    public Object getWorker() {
+        return worker;
+    }
+
+    public void setWorker(Object worker) {
+        this.worker = worker;
+    }
+
+    public void setLastJobCompleted(long lastJobCompleted) {
+        this.lastJobCompleted = lastJobCompleted;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/PublicQueryMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/PublicQueryMessage.java
new file mode 100644
index 0000000..5d8cbd9
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/PublicQueryMessage.java
@@ -0,0 +1,64 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.IntCallback;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+
+public class PublicQueryMessage extends Message implements IntCallback.MessageWithCallback {
+    public static final int COUNT = 0;
+    public static final int COUNT_READY = 1;
+    public static final int START = 2;
+    public static final int STOP = 3;
+    public static final int JOB_STATUS = 4;
+    public static final int CLEAR = 5;
+    public static final int ACTIVE_CONSUMER_COUNT = 6;
+    public static final int SCHEDULER_START = 7;
+    // used for testing
+    public static final int INTERNAL_RUNNABLE = 101;
+
+    private IntCallback callback;
+    private int what = -1;
+    private String stringArg;
+
+    public PublicQueryMessage() {
+        super(Type.PUBLIC_QUERY);
+    }
+
+    public void set(int what, IntCallback callback) {
+        this.callback = callback;
+        this.what = what;
+    }
+
+    public void set(int what, String stringArg, IntCallback callback) {
+        this.what = what;
+        this.stringArg = stringArg;
+        this.callback = callback;
+    }
+
+    public IntCallback getCallback() {
+        return callback;
+    }
+
+    public int getWhat() {
+        return what;
+    }
+
+    public String getStringArg() {
+        return stringArg;
+    }
+
+    public void setCallback(IntCallback callback) {
+        this.callback = callback;
+    }
+
+    @Override
+    protected void onRecycled() {
+        callback = null;
+        what = -1;
+    }
+
+    @Override
+    public String toString() {
+        return "PublicQuery[" + what + "]";
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobMessage.java
new file mode 100644
index 0000000..ab3d77f
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobMessage.java
@@ -0,0 +1,25 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.JobHolder;
+
+public class RunJobMessage extends Message {
+    private JobHolder jobHolder;
+    public RunJobMessage() {
+        super(Type.RUN_JOB);
+    }
+
+    public JobHolder getJobHolder() {
+        return jobHolder;
+    }
+
+    public void setJobHolder(JobHolder jobHolder) {
+        this.jobHolder = jobHolder;
+    }
+
+    @Override
+    protected void onRecycled() {
+        jobHolder = null;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobResultMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobResultMessage.java
new file mode 100644
index 0000000..fe5b94f
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/RunJobResultMessage.java
@@ -0,0 +1,44 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.JobHolder;
+
+public class RunJobResultMessage extends Message {
+    private JobHolder jobHolder;
+    private Object worker;
+    private int result;
+
+    public RunJobResultMessage() {
+        super(Type.RUN_JOB_RESULT);
+    }
+
+    public JobHolder getJobHolder() {
+        return jobHolder;
+    }
+
+    public void setJobHolder(JobHolder jobHolder) {
+        this.jobHolder = jobHolder;
+    }
+
+    @Override
+    protected void onRecycled() {
+        jobHolder = null;
+    }
+
+    public void setResult(int result) {
+        this.result = result;
+    }
+
+    public int getResult() {
+        return result;
+    }
+
+    public Object getWorker() {
+        return worker;
+    }
+
+    public void setWorker(Object worker) {
+        this.worker = worker;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/SchedulerMessage.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/SchedulerMessage.java
new file mode 100644
index 0000000..cce0d27
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/messaging/message/SchedulerMessage.java
@@ -0,0 +1,46 @@
+package com.birbit.android.jobqueue.messaging.message;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.IntCallback;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.Type;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+
+/**
+ * The messages with the scheduler
+ */
+public class SchedulerMessage extends Message {
+    public static final int START = 1;
+    public static final int STOP = 2;
+
+    private int what;
+    @SuppressWarnings("NullableProblems")
+    @NonNull
+    private SchedulerConstraint constraint;
+
+    public SchedulerMessage() {
+        super(Type.SCHEDULER);
+    }
+
+    public void set(int what, @NonNull SchedulerConstraint constraint) {
+        this.what = what;
+        this.constraint = constraint;
+    }
+
+    public int getWhat() {
+        return what;
+    }
+
+    @NonNull
+    public SchedulerConstraint getConstraint() {
+        return constraint;
+    }
+
+    @Override
+    protected void onRecycled() {
+        //noinspection ConstantConditions
+        constraint = null;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkEventProvider.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkEventProvider.java
new file mode 100644
index 0000000..ac78a2c
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkEventProvider.java
@@ -0,0 +1,16 @@
+package com.birbit.android.jobqueue.network;
+
+/**
+ * An interface that NetworkUtil can implement if it supports a callback method when network state is changed
+ * This is not mandatory but highly suggested so that {@link com.birbit.android.jobqueue.JobManager} can avoid
+ * busy loops when there is a job waiting for network and there is no network available
+ */
+public interface NetworkEventProvider {
+    void setListener(Listener listener);
+    interface Listener {
+        /**
+         * @param networkStatus {@link com.birbit.android.jobqueue.network.NetworkUtil.NetworkStatus}
+         */
+        void onNetworkChange(@NetworkUtil.NetworkStatus int networkStatus);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtil.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtil.java
new file mode 100644
index 0000000..db7c09b
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtil.java
@@ -0,0 +1,33 @@
+package com.birbit.android.jobqueue.network;
+
+import android.content.Context;
+import android.support.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Interface which you can implement if you want to provide a custom Network callback.
+ * Make sure you also implement {@link NetworkEventProvider} for best performance.
+ */
+public interface NetworkUtil {
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({DISCONNECTED, METERED, UNMETERED})
+    @interface NetworkStatus {}
+    int DISCONNECTED = 1;
+    int METERED = 2;
+    int UNMETERED = 3;
+
+    /**
+     * Returns the current connection status. If you cannot detect granular network type, return
+     * {@link #UNMETERED} if there is an internet connection or {@link #DISCONNECTED} if there is no
+     * connection.
+     *
+     * @param context The application context
+     *
+     * @return The current connection status. It should be one of {@link #DISCONNECTED},
+     * {@link #METERED} or {@link #UNMETERED}.
+     */
+    @NetworkStatus
+    int getNetworkStatus(Context context);
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtilImpl.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtilImpl.java
new file mode 100644
index 0000000..0d38ce5
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/network/NetworkUtilImpl.java
@@ -0,0 +1,119 @@
+package com.birbit.android.jobqueue.network;
+
+import android.annotation.TargetApi;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.os.Build;
+import android.os.Build.VERSION;
+import android.os.PowerManager;
+
+/**
+ * default implementation for network Utility to observe network events
+ */
+public class NetworkUtilImpl implements NetworkUtil, NetworkEventProvider {
+    private Listener listener;
+    public NetworkUtilImpl(final Context context) {
+        if (VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            if (VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                listenForIdle(context);
+            }
+            listenNetworkViaConnectivityManager(context);
+        } else {
+            context.getApplicationContext().registerReceiver(new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    dispatchNetworkChange(context);
+                }
+            }, getNetworkIntentFilter());
+        }
+    }
+
+    @TargetApi(23)
+    private void listenNetworkViaConnectivityManager(final Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.getApplicationContext()
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkRequest request = new NetworkRequest.Builder()
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
+                .build();
+        cm.registerNetworkCallback(request, new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onAvailable(Network network) {
+                dispatchNetworkChange(context);
+            }
+        });
+    }
+
+    @TargetApi(23)
+    private void listenForIdle(Context context) {
+        context.getApplicationContext().registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                dispatchNetworkChange(context);
+            }
+        }, new IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
+    }
+
+    void dispatchNetworkChange(Context context) {
+        if(listener == null) {//shall not be but just be safe
+            return;
+        }
+        //http://developer.android.com/reference/android/net/ConnectivityManager.html#EXTRA_NETWORK_INFO
+        //Since NetworkInfo can vary based on UID, applications should always obtain network information
+        // through getActiveNetworkInfo() or getAllNetworkInfo().
+        listener.onNetworkChange(getNetworkStatus(context));
+    }
+
+    @Override
+    public int getNetworkStatus(Context context) {
+        if (isDozing(context)) {
+            return NetworkUtil.DISCONNECTED;
+        }
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo netInfo = cm.getActiveNetworkInfo();
+        if (netInfo == null) {
+            return NetworkUtil.DISCONNECTED;
+        }
+        if (netInfo.getType() == ConnectivityManager.TYPE_WIFI ||
+                netInfo.getType() == ConnectivityManager.TYPE_ETHERNET) {
+            return NetworkUtil.UNMETERED;
+        }
+        return NetworkUtil.METERED;
+    }
+
+    @TargetApi(23)
+    private static IntentFilter getNetworkIntentFilter() {
+        IntentFilter networkIntentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
+        if (VERSION.SDK_INT >= 23) {
+            networkIntentFilter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
+        }
+        return networkIntentFilter;
+    }
+
+    /**
+     * Returns true if the device is in Doze/Idle mode. Should be called before checking the network connection because
+     * the ConnectionManager may report the device is connected when it isn't during Idle mode.
+     */
+    @TargetApi(23)
+    private static boolean isDozing(Context context) {
+        if (VERSION.SDK_INT >= 23) {
+            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+            return powerManager.isDeviceIdleMode() &&
+                    !powerManager.isIgnoringBatteryOptimizations(context.getPackageName());
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public void setListener(Listener listener) {
+        this.listener = listener;
+    }
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
old mode 100755
new mode 100644
similarity index 67%
rename from jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
index 0762a37..ef819fe
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/DbOpenHelper.java
@@ -1,4 +1,4 @@
-package com.path.android.jobqueue.persistentQueue.sqlite;
+package com.birbit.android.jobqueue.persistentQueue.sqlite;
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
@@ -8,23 +8,28 @@
  * Helper class for {@link SqliteJobQueue} to handle database connection
  */
 public class DbOpenHelper extends SQLiteOpenHelper {
-    private static final int DB_VERSION = 4;
+    private static final int DB_VERSION = 8;
     /*package*/ static final String JOB_HOLDER_TABLE_NAME = "job_holder";
     /*package*/ static final String JOB_TAGS_TABLE_NAME = "job_holder_tags";
-    /*package*/ static final SqlHelper.Property ID_COLUMN = new SqlHelper.Property("_id", "integer", 0);
-    /*package*/ static final SqlHelper.Property PRIORITY_COLUMN = new SqlHelper.Property("priority", "integer", 1);
-    /*package*/ static final SqlHelper.Property GROUP_ID_COLUMN = new SqlHelper.Property("group_id", "text", 2);
-    /*package*/ static final SqlHelper.Property RUN_COUNT_COLUMN = new SqlHelper.Property("run_count", "integer", 3);
-    /*package*/ static final SqlHelper.Property BASE_JOB_COLUMN = new SqlHelper.Property("base_job", "byte", 4);
-    /*package*/ static final SqlHelper.Property CREATED_NS_COLUMN = new SqlHelper.Property("created_ns", "long", 5);
-    /*package*/ static final SqlHelper.Property DELAY_UNTIL_NS_COLUMN = new SqlHelper.Property("delay_until_ns", "long", 6);
-    /*package*/ static final SqlHelper.Property RUNNING_SESSION_ID_COLUMN = new SqlHelper.Property("running_session_id", "long", 7);
-    /*package*/ static final SqlHelper.Property REQUIRES_NETWORK_COLUMN = new SqlHelper.Property("requires_network", "integer", 8);
+    /*package*/ static final SqlHelper.Property INSERTION_ORDER_COLUMN = new SqlHelper.Property("insertionOrder", "integer", 0);
+    /*package*/ static final SqlHelper.Property ID_COLUMN = new SqlHelper.Property("_id", "text", 1, null, true);
+    /*package*/ static final SqlHelper.Property PRIORITY_COLUMN = new SqlHelper.Property("priority", "integer", 2);
+    /*package*/ static final SqlHelper.Property GROUP_ID_COLUMN = new SqlHelper.Property("group_id", "text", 3);
+    /*package*/ static final SqlHelper.Property RUN_COUNT_COLUMN = new SqlHelper.Property("run_count", "integer", 4);
+    /*package*/ static final SqlHelper.Property BASE_JOB_COLUMN = new SqlHelper.Property("base_job", "byte", 5);
+    /*package*/ static final SqlHelper.Property CREATED_NS_COLUMN = new SqlHelper.Property("created_ns", "long", 6);
+    /*package*/ static final SqlHelper.Property DELAY_UNTIL_NS_COLUMN = new SqlHelper.Property("delay_until_ns", "long", 7);
+    /*package*/ static final SqlHelper.Property RUNNING_SESSION_ID_COLUMN = new SqlHelper.Property("running_session_id", "long", 8);
+    /*package*/ static final SqlHelper.Property REQUIRES_NETWORK_UNTIL_COLUMN = new SqlHelper.Property("requires_network_until", "integer", 9);
+    /*package*/ static final SqlHelper.Property REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN = new SqlHelper.Property("requires_unmetered_network_until", "integer", 10);
+
     /*package*/ static final SqlHelper.Property TAGS_ID_COLUMN = new SqlHelper.Property("_id", "integer", 0);
-    /*package*/ static final SqlHelper.Property TAGS_JOB_ID_COLUMN = new SqlHelper.Property("job_id", "integer", 1, new SqlHelper.ForeignKey(JOB_HOLDER_TABLE_NAME, ID_COLUMN.columnName));
+    /*package*/ static final SqlHelper.Property TAGS_JOB_ID_COLUMN = new SqlHelper.Property("job_id", "text", 1, new SqlHelper.ForeignKey(JOB_HOLDER_TABLE_NAME, ID_COLUMN.columnName));
     /*package*/ static final SqlHelper.Property TAGS_NAME_COLUMN = new SqlHelper.Property("tag_name", "text", 2);
 
-    /*package*/ static final int COLUMN_COUNT = 9;
+
+
+    /*package*/ static final int COLUMN_COUNT = 11;
     /*package*/ static final int TAGS_COLUMN_COUNT = 3;
 
     static final String TAG_INDEX_NAME = "TAG_NAME_INDEX";
@@ -36,6 +41,7 @@ public DbOpenHelper(Context context, String name) {
     @Override
     public void onCreate(SQLiteDatabase sqLiteDatabase) {
         String createQuery = SqlHelper.create(JOB_HOLDER_TABLE_NAME,
+                INSERTION_ORDER_COLUMN,
                 ID_COLUMN,
                 PRIORITY_COLUMN,
                 GROUP_ID_COLUMN,
@@ -44,7 +50,8 @@ public void onCreate(SQLiteDatabase sqLiteDatabase) {
                 CREATED_NS_COLUMN,
                 DELAY_UNTIL_NS_COLUMN,
                 RUNNING_SESSION_ID_COLUMN,
-                REQUIRES_NETWORK_COLUMN
+                REQUIRES_NETWORK_UNTIL_COLUMN,
+                REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN
         );
         sqLiteDatabase.execSQL(createQuery);
 
@@ -65,4 +72,9 @@ public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVers
         sqLiteDatabase.execSQL("DROP INDEX IF EXISTS " + TAG_INDEX_NAME);
         onCreate(sqLiteDatabase);
     }
+
+    @Override
+    public void onDowngrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
+        onUpgrade(sqLiteDatabase, oldVersion, newVersion);
+    }
 }
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
similarity index 51%
rename from jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
rename to jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
index 3aee2f8..c0b6551 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
@@ -1,13 +1,10 @@
-package com.path.android.jobqueue.persistentQueue.sqlite;
+package com.birbit.android.jobqueue.persistentQueue.sqlite;
+
+import com.birbit.android.jobqueue.log.JqLog;
 
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.log.JqLog;
-
-import java.util.Collection;
-
 /**
  * Helper class for {@link SqliteJobQueue} to generate sql queries and statements.
  */
@@ -20,10 +17,10 @@
     private SQLiteStatement insertTagsStatement;
     private SQLiteStatement insertOrReplaceStatement;
     private SQLiteStatement deleteStatement;
+    private SQLiteStatement deleteJobTagsStatement;
     private SQLiteStatement onJobFetchedForRunningStatement;
     private SQLiteStatement countStatement;
-    private SQLiteStatement nextJobDelayedUntilWithNetworkStatement;
-    private SQLiteStatement nextJobDelayedUntilWithoutNetworkStatement;
+    final StringBuilder reusedStringBuilder = new StringBuilder();
 
 
     final SQLiteDatabase db;
@@ -54,9 +51,12 @@ public static String create(String tableName, Property primaryKey, Property... p
         builder.append(tableName).append(" (");
         builder.append(primaryKey.columnName).append(" ");
         builder.append(primaryKey.type);
-        builder.append("  primary key autoincrement ");
+        builder.append("  primary key ");
         for (Property property : properties) {
             builder.append(", `").append(property.columnName).append("` ").append(property.type);
+            if (property.unique) {
+                builder.append(" UNIQUE");
+            }
         }
         for (Property property : properties) {
             if (property.foreignKey != null) {
@@ -71,68 +71,41 @@ public static String create(String tableName, Property primaryKey, Property... p
         return builder.toString();
     }
 
-    public String createFindByTagsQuery(TagConstraint constraint, int numberOfExcludeIds,
-            int numberOfTags) {
-        StringBuilder query = new StringBuilder();
-        String placeHolders = createPlaceholders(numberOfTags);
-        query.append("SELECT * FROM ").append(tableName).append(" WHERE ");
-        query.append(DbOpenHelper.ID_COLUMN.columnName).append(" IN ( SELECT ")
-                .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append(" FROM ")
-                .append(tagsTableName).append(" WHERE ")
-                .append(DbOpenHelper.TAGS_NAME_COLUMN.columnName).append(" IN (")
-                .append(placeHolders).append(")");
-        if (constraint == TagConstraint.ANY) {
-            query.append(")");
-        } else if (constraint == TagConstraint.ALL) {
-            query.append(" GROUP BY (`")
-                    .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append("`)")
-                    .append(" HAVING count(*) = ")
-                    .append(numberOfTags).append(")");
-        } else {
-            // have this in place in case we change number of constraints
-            throw new IllegalArgumentException("unknown constraint " + constraint);
-        }
-        if (numberOfExcludeIds > 0) {
-            String idPlaceHolders = createPlaceholders(numberOfExcludeIds);
-            query.append(" AND ").append(DbOpenHelper.ID_COLUMN.columnName)
-                    .append(" NOT IN(").append(idPlaceHolders).append(")");
-        }
-
-        return query.toString();
-    }
-
     public static String drop(String tableName) {
         return "DROP TABLE IF EXISTS " + tableName;
     }
 
     public SQLiteStatement getInsertStatement() {
         if (insertStatement == null) {
-            StringBuilder builder = new StringBuilder("INSERT INTO ").append(tableName);
-            builder.append(" VALUES (");
+            reusedStringBuilder.setLength(0);
+            reusedStringBuilder.append("INSERT INTO ").append(tableName);
+            reusedStringBuilder.append(" VALUES (");
             for (int i = 0; i < columnCount; i++) {
                 if (i != 0) {
-                    builder.append(",");
+                    reusedStringBuilder.append(",");
                 }
-                builder.append("?");
+                reusedStringBuilder.append("?");
             }
-            builder.append(")");
-            insertStatement = db.compileStatement(builder.toString());
+            reusedStringBuilder.append(")");
+            insertStatement = db.compileStatement(reusedStringBuilder.toString());
         }
         return insertStatement;
     }
 
     public SQLiteStatement getInsertTagsStatement() {
         if (insertTagsStatement == null) {
-            StringBuilder builder = new StringBuilder("INSERT INTO ").append(DbOpenHelper.JOB_TAGS_TABLE_NAME);
-            builder.append(" VALUES (");
+            reusedStringBuilder.setLength(0);
+            reusedStringBuilder.append("INSERT INTO ")
+                    .append(DbOpenHelper.JOB_TAGS_TABLE_NAME);
+            reusedStringBuilder.append(" VALUES (");
             for (int i = 0; i < tagsColumnCount; i++) {
                 if (i != 0) {
-                    builder.append(",");
+                    reusedStringBuilder.append(",");
                 }
-                builder.append("?");
+                reusedStringBuilder.append("?");
             }
-            builder.append(")");
-            insertTagsStatement = db.compileStatement(builder.toString());
+            reusedStringBuilder.append(")");
+            insertTagsStatement = db.compileStatement(reusedStringBuilder.toString());
         }
         return insertTagsStatement;
     }
@@ -147,27 +120,37 @@ public SQLiteStatement getCountStatement() {
 
     public SQLiteStatement getInsertOrReplaceStatement() {
         if (insertOrReplaceStatement == null) {
-            StringBuilder builder = new StringBuilder("INSERT OR REPLACE INTO ").append(tableName);
-            builder.append(" VALUES (");
+            reusedStringBuilder.setLength(0);
+            reusedStringBuilder.append("INSERT OR REPLACE INTO ").append(tableName);
+            reusedStringBuilder.append(" VALUES (");
             for (int i = 0; i < columnCount; i++) {
                 if (i != 0) {
-                    builder.append(",");
+                    reusedStringBuilder.append(",");
                 }
-                builder.append("?");
+                reusedStringBuilder.append("?");
             }
-            builder.append(")");
-            insertOrReplaceStatement = db.compileStatement(builder.toString());
+            reusedStringBuilder.append(")");
+            insertOrReplaceStatement = db.compileStatement(reusedStringBuilder.toString());
         }
         return insertOrReplaceStatement;
     }
 
     public SQLiteStatement getDeleteStatement() {
         if (deleteStatement == null) {
-            deleteStatement = db.compileStatement("DELETE FROM " + tableName + " WHERE " + primaryKeyColumnName + " = ?");
+            deleteStatement = db.compileStatement("DELETE FROM " + tableName + " WHERE "
+                    + primaryKeyColumnName + " = ?");
         }
         return deleteStatement;
     }
 
+    public SQLiteStatement getDeleteJobTagsStatement() {
+        if (deleteJobTagsStatement == null) {
+            deleteJobTagsStatement = db.compileStatement("DELETE FROM " + tagsTableName
+                    + " WHERE " + DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName + "= ?");
+        }
+        return deleteJobTagsStatement;
+    }
+
     public SQLiteStatement getOnJobFetchedForRunningStatement() {
         if (onJobFetchedForRunningStatement == null) {
             String sql = "UPDATE " + tableName + " SET "
@@ -179,89 +162,68 @@ public SQLiteStatement getOnJobFetchedForRunningStatement() {
         return onJobFetchedForRunningStatement;
     }
 
-    public SQLiteStatement getNextJobDelayedUntilWithNetworkStatement() {
-        if(nextJobDelayedUntilWithNetworkStatement == null) {
-            String sql = "SELECT " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName
-                    + " FROM " + tableName + " WHERE "
-                    + DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName + " != " + sessionId
-                    + " ORDER BY " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + " ASC"
-                    + " LIMIT 1";
-            nextJobDelayedUntilWithNetworkStatement = db.compileStatement(sql);
-        }
-        return nextJobDelayedUntilWithNetworkStatement;
-    }
-
-    public SQLiteStatement getNextJobDelayedUntilWithoutNetworkStatement() {
-        if(nextJobDelayedUntilWithoutNetworkStatement == null) {
-            String sql = "SELECT " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName
-                    + " FROM " + tableName + " WHERE "
-                    + DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName + " != " + sessionId
-                    + " AND " + DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnName + " != 1"
-                    + " ORDER BY " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + " ASC"
-                    + " LIMIT 1";
-            nextJobDelayedUntilWithoutNetworkStatement = db.compileStatement(sql);
+    public String createSelect(String where, Integer limit, Order... orders) {
+        reusedStringBuilder.setLength(0);
+        reusedStringBuilder.append("SELECT * FROM ");
+        reusedStringBuilder.append(tableName);
+        if (where != null) {
+            reusedStringBuilder.append(" WHERE ").append(where);
         }
-        return nextJobDelayedUntilWithoutNetworkStatement;
-    }
-
-    public String createNextJobDelayUntilQuery(boolean hasNetwork, Collection<String> excludeGroups) {
-        String sql = "SELECT " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName
-                + " FROM " + tableName + " WHERE "
-                + DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName + " != " + sessionId;
-        if (!hasNetwork) {
-            sql += " AND " + DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnName + " != 1";
+        boolean first = true;
+        for (Order order : orders) {
+            if (first) {
+                reusedStringBuilder.append(" ORDER BY ");
+            } else {
+                reusedStringBuilder.append(",");
+            }
+            first = false;
+            reusedStringBuilder.append(order.property.columnName).append(" ").append(order.type);
         }
-        if(excludeGroups != null && excludeGroups.size() > 0) {
-            sql +=  " AND (" + DbOpenHelper.GROUP_ID_COLUMN.columnName + " IS NULL OR " +
-                    DbOpenHelper.GROUP_ID_COLUMN.columnName +
-                    " NOT IN('" + joinStrings("','", excludeGroups) + "'))";
+        if (limit != null) {
+            reusedStringBuilder.append(" LIMIT ").append(limit);
         }
-        sql += " ORDER BY " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + " ASC"
-                + " LIMIT 1";
-        return sql;
+        return reusedStringBuilder.toString();
     }
 
+    public String createSelectOneField(Property property, String where, Integer limit,
+            Order... orders) {
+        reusedStringBuilder.setLength(0);
 
-    public String createSelect(String where, Integer limit, Order... orders) {
-        StringBuilder builder = new StringBuilder("SELECT * FROM ");
-        builder.append(tableName);
+        reusedStringBuilder.append("SELECT ")
+                .append(property.columnName).append(" FROM ")
+                .append(tableName);
         if (where != null) {
-            builder.append(" WHERE ").append(where);
+            reusedStringBuilder.append(" WHERE ").append(where);
         }
         boolean first = true;
         for (Order order : orders) {
             if (first) {
-                builder.append(" ORDER BY ");
+                reusedStringBuilder.append(" ORDER BY ");
             } else {
-                builder.append(",");
+                reusedStringBuilder.append(",");
             }
             first = false;
-            builder.append(order.property.columnName).append(" ").append(order.type);
+            reusedStringBuilder.append(order.property.columnName).append(" ").append(order.type);
         }
         if (limit != null) {
-            builder.append(" LIMIT ").append(limit);
+            reusedStringBuilder.append(" LIMIT ").append(limit);
         }
-        return builder.toString();
+        return reusedStringBuilder.toString();
     }
 
-    /**
-     * returns a placeholder string that contains <code>count</code> placeholders. e.g. ?,?,? for
-     * 3.
-     * @param count Number of placeholders to add.
-     */
-    private static String createPlaceholders(int count) {
+    static void addPlaceholdersInto(StringBuilder stringBuilder, int count) {
         if (count == 0) {
             throw new IllegalArgumentException("cannot create placeholders for 0 items");
         }
-        final StringBuilder builder = new StringBuilder("?");
+        stringBuilder.append("?");
         for (int i = 1; i < count; i ++) {
-            builder.append(",?");
+            stringBuilder.append(",?");
         }
-        return builder.toString();
     }
 
     public void truncate() {
         db.execSQL("DELETE FROM " + DbOpenHelper.JOB_HOLDER_TABLE_NAME);
+        db.execSQL("DELETE FROM " + DbOpenHelper.JOB_TAGS_TABLE_NAME);
         vacuum();
     }
 
@@ -271,20 +233,10 @@ public void vacuum() {
 
     public void resetDelayTimesTo(long newDelayTime) {
         db.execSQL("UPDATE " + DbOpenHelper.JOB_HOLDER_TABLE_NAME + " SET "
-                + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + "=?"
-            , new Object[]{newDelayTime});
-    }
-
-    // TODO we are using this to merge groups but not escaping :/
-    public static String joinStrings(String glue, Collection<String> strings) {
-        StringBuilder builder = new StringBuilder();
-        for(String str : strings) {
-            if(builder.length() != 0) {
-                builder.append(glue);
-            }
-            builder.append(str);
-        }
-        return builder.toString();
+                + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + "=?,"
+                + DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnName + "=?, "
+                + DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnName + "=?"
+            , new Object[]{newDelayTime, newDelayTime, newDelayTime});
     }
 
     public static class Property {
@@ -292,16 +244,23 @@ public static String joinStrings(String glue, Collection<String> strings) {
         /*package*/ final String type;
         public final int columnIndex;
         public final ForeignKey foreignKey;
+        public final boolean unique;
 
         public Property(String columnName, String type, int columnIndex) {
-            this(columnName, type, columnIndex, null);
+            this(columnName, type, columnIndex, null, false);
         }
 
         public Property(String columnName, String type, int columnIndex, ForeignKey foreignKey) {
+            this(columnName, type, columnIndex, foreignKey, false);
+        }
+
+        public Property(String columnName, String type, int columnIndex, ForeignKey foreignKey,
+                boolean unique) {
             this.columnName = columnName;
             this.type = type;
             this.columnIndex = columnIndex;
             this.foreignKey = foreignKey;
+            this.unique = unique;
         }
     }
 
@@ -324,7 +283,7 @@ public Order(Property property, Type type) {
             this.type = type;
         }
 
-        public static enum Type {
+        public enum Type {
             ASC,
             DESC
         }
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
new file mode 100755
index 0000000..97058f3
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -0,0 +1,524 @@
+package com.birbit.android.jobqueue.persistentQueue.sqlite;
+
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDoneException;
+import android.database.sqlite.SQLiteStatement;
+import android.support.annotation.VisibleForTesting;
+
+import com.birbit.android.jobqueue.Constraint;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Persistent Job Queue that keeps its data in an sqlite database.
+ */
+public class SqliteJobQueue implements JobQueue {
+    DbOpenHelper dbOpenHelper;
+    private final long sessionId;
+    SQLiteDatabase db;
+    SqlHelper sqlHelper;
+    JobSerializer jobSerializer;
+    // we keep a list of cancelled jobs in memory not to return them in subsequent find by tag
+    // queries. Set is cleaned when item is removed
+    Set<String> pendingCancelations = new HashSet<>();
+    private final StringBuilder reusedStringBuilder = new StringBuilder();
+    private final WhereQueryCache whereQueryCache;
+
+    public SqliteJobQueue(Configuration configuration, long sessionId, JobSerializer serializer) {
+        this.sessionId = sessionId;
+        whereQueryCache = new WhereQueryCache(sessionId);
+        dbOpenHelper = new DbOpenHelper(configuration.getAppContext(),
+                configuration.isInTestMode() ? null : ("db_" + configuration.getId()));
+        db = dbOpenHelper.getWritableDatabase();
+        sqlHelper = new SqlHelper(db, DbOpenHelper.JOB_HOLDER_TABLE_NAME,
+                DbOpenHelper.ID_COLUMN.columnName, DbOpenHelper.COLUMN_COUNT,
+                DbOpenHelper.JOB_TAGS_TABLE_NAME, DbOpenHelper.TAGS_COLUMN_COUNT, sessionId);
+        this.jobSerializer = serializer;
+        if (configuration.resetDelaysOnRestart()) {
+            sqlHelper.resetDelayTimesTo(JobManager.NOT_DELAYED_JOB_DELAY);
+        }
+    }
+
+    @VisibleForTesting
+    public SQLiteDatabase getDb() {
+        return db;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean insert(JobHolder jobHolder) {
+        if (jobHolder.hasTags()) {
+            return insertWithTags(jobHolder);
+        }
+        long insertId = -1;
+        db.beginTransaction();
+        try {
+            final SQLiteStatement stmt = sqlHelper.getInsertStatement();
+            stmt.clearBindings();
+            bindValues(stmt, jobHolder);
+            insertId = stmt.executeInsert();
+            db.setTransactionSuccessful();
+        } catch (Throwable t) {
+            JqLog.e(t, "called insert with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+        // insert id is a alias to row_id
+        jobHolder.setInsertionOrder(insertId);
+        return insertId != -1;
+    }
+
+    @Override
+    public void substitute(JobHolder newJob, JobHolder oldJob) {
+        db.beginTransaction();
+        try {
+            remove(oldJob);
+            insert(newJob);
+            db.setTransactionSuccessful();
+        } catch (Throwable t) {
+            JqLog.e(t, "called substitute with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+    }
+
+    private boolean insertWithTags(JobHolder jobHolder) {
+        db.beginTransaction();
+        try {
+            final SQLiteStatement stmt = sqlHelper.getInsertStatement();
+            final SQLiteStatement tagsStmt = sqlHelper.getInsertTagsStatement();
+            stmt.clearBindings();
+            bindValues(stmt, jobHolder);
+            boolean insertResult = stmt.executeInsert() != -1;
+            if (!insertResult) {
+                return false;
+            }
+            for (String tag : jobHolder.getTags()) {
+                tagsStmt.clearBindings();
+                bindTag(tagsStmt, jobHolder.getId(), tag);
+                tagsStmt.executeInsert();
+            }
+            db.setTransactionSuccessful();
+            return true;
+        } catch (Throwable t) {
+            JqLog.e(t, "error while inserting job with tags");
+            return false;
+        } finally {
+            safeEndTransaction();
+        }
+    }
+
+    private void bindTag(SQLiteStatement stmt, String jobId, String tag) {
+        stmt.bindString(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnIndex + 1, jobId);
+        stmt.bindString(DbOpenHelper.TAGS_NAME_COLUMN.columnIndex + 1, tag);
+    }
+
+    private void bindValues(SQLiteStatement stmt, JobHolder jobHolder) {
+        if (jobHolder.getInsertionOrder() != null) {
+            stmt.bindLong(DbOpenHelper.INSERTION_ORDER_COLUMN.columnIndex + 1, jobHolder.getInsertionOrder());
+        }
+
+        stmt.bindString(DbOpenHelper.ID_COLUMN.columnIndex + 1, jobHolder.getId());
+        stmt.bindLong(DbOpenHelper.PRIORITY_COLUMN.columnIndex + 1, jobHolder.getPriority());
+        if(jobHolder.getGroupId() != null) {
+            stmt.bindString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex + 1, jobHolder.getGroupId());
+        }
+        stmt.bindLong(DbOpenHelper.RUN_COUNT_COLUMN.columnIndex + 1, jobHolder.getRunCount());
+        byte[] job = getSerializeJob(jobHolder);
+        if (job != null) {
+            stmt.bindBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex + 1, job);
+        }
+        stmt.bindLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex + 1, jobHolder.getCreatedNs());
+        stmt.bindLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex + 1, jobHolder.getDelayUntilNs());
+        stmt.bindLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex + 1, jobHolder.getRunningSessionId());
+        stmt.bindLong(DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnIndex + 1,
+                jobHolder.getRequiresNetworkUntilNs());
+        stmt.bindLong(DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnIndex + 1,
+                jobHolder.getRequiresUnmeteredNetworkUntilNs());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean insertOrReplace(JobHolder jobHolder) {
+        if (jobHolder.getInsertionOrder() == null) {
+            return insert(jobHolder);
+        }
+        jobHolder.setRunningSessionId(JobManager.NOT_RUNNING_SESSION_ID);
+        boolean success = false;
+        db.beginTransaction();
+        try {
+            SQLiteStatement stmt = sqlHelper.getInsertOrReplaceStatement();
+            stmt.clearBindings();
+            bindValues(stmt, jobHolder);
+            success = stmt.executeInsert() != -1;
+            db.setTransactionSuccessful();
+        } catch (Throwable t) {
+            JqLog.e(t, "called insertOrReplace with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+        return success;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove(JobHolder jobHolder) {
+        if (jobHolder.getId() == null) {
+            JqLog.e("called remove with null job id.");
+            return;
+        }
+        delete(jobHolder.getId());
+    }
+
+    private void delete(String id) {
+        pendingCancelations.remove(id);
+        db.beginTransaction();
+        try {
+            SQLiteStatement stmt = sqlHelper.getDeleteStatement();
+            stmt.clearBindings();
+            stmt.bindString(1, id);
+            stmt.execute();
+            SQLiteStatement deleteTagsStmt = sqlHelper.getDeleteJobTagsStatement();
+            deleteTagsStmt.bindString(1, id);
+            deleteTagsStmt.execute();
+            db.setTransactionSuccessful();
+        } catch (Throwable t) {
+            JqLog.e(t, "called delete with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int count() {
+        int count = 0;
+        db.beginTransaction();
+        try {
+            SQLiteStatement stmt = sqlHelper.getCountStatement();
+            stmt.clearBindings();
+            stmt.bindLong(1, sessionId);
+            count = (int) stmt.simpleQueryForLong();
+        } catch (Throwable t) {
+            JqLog.e(t, "called count with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+        return count;
+    }
+
+    @Override
+    public int countReadyJobs(Constraint constraint) {
+        int result = 0;
+        db.beginTransaction();
+        try {
+            final Where where = createWhere(constraint);
+            result = (int) where.countReady(db, reusedStringBuilder).simpleQueryForLong();
+        } catch (Throwable t) {
+            JqLog.e(t, "called countReadyJobs with exception.");
+        } finally {
+            safeEndTransaction();
+        }
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public JobHolder findJobById(String id) {
+        Cursor cursor = db.rawQuery(sqlHelper.FIND_BY_ID_QUERY, new String[]{id});
+        try {
+            if(!cursor.moveToFirst()) {
+                return null;
+            }
+            return createJobHolderFromCursor(cursor);
+        } catch (InvalidJobException e) {
+            JqLog.e(e, "invalid job on findJobById");
+            return null;
+        } finally {
+            safeCloseCursor(cursor);
+        }
+    }
+    
+    @Override
+    public Set<JobHolder> findJobs(Constraint constraint) {
+        final Where where = createWhere(constraint);
+        String selectQuery = where.findJobs(sqlHelper);
+        Cursor cursor = db.rawQuery(selectQuery, where.args);
+        Set<JobHolder> jobs = new HashSet<>();
+        try {
+            while (cursor.moveToNext()) {
+                jobs.add(createJobHolderFromCursor(cursor));
+            }
+        } catch (InvalidJobException e) {
+            JqLog.e(e, "invalid job found by tags.");
+        } finally {
+            safeCloseCursor(cursor);
+        }
+
+        return jobs;
+    }
+
+    @Override
+    public void onJobCancelled(JobHolder holder) {
+        pendingCancelations.add(holder.getId());
+        setSessionIdOnJob(holder);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public JobHolder nextJobAndIncRunCount(Constraint constraint) {
+        final Where where = createWhere(constraint);
+        //we can even keep these prepared but not sure the cost of them in db layer
+        final String selectQuery = where.nextJob(sqlHelper);
+        while (true) {
+            Cursor cursor = db.rawQuery(selectQuery, where.args);
+            try {
+                if (!cursor.moveToNext()) {
+                    return null;
+                }
+                JobHolder holder = createJobHolderFromCursor(cursor);
+                setSessionIdOnJob(holder);
+                return holder;
+            } catch (InvalidJobException e) {
+                //delete
+                String jobId = cursor.getString(DbOpenHelper.ID_COLUMN.columnIndex);
+                if (jobId == null) {
+                    JqLog.e("cannot find job id on a retriewed job");
+                } else {
+                    delete(jobId);
+                }
+            } finally {
+                safeCloseCursor(cursor);
+            }
+        }
+    }
+
+    private Where createWhere(Constraint constraint) {
+        return whereQueryCache.build(constraint, pendingCancelations, reusedStringBuilder);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Long getNextJobDelayUntilNs(Constraint constraint) {
+        final Where where = createWhere(constraint);
+        try {
+            if (constraint.shouldNotRequireNetwork() || constraint.shouldNotRequireUnmeteredNetwork()) {
+                return where.nextJobDelayUntilWithNetworkRequirement(db, sqlHelper)
+                        .simpleQueryForLong();
+            } else {
+                return where.nextJobDelayUntil(db, sqlHelper).simpleQueryForLong();
+            }
+        } catch (SQLiteDoneException empty) {
+            return null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        sqlHelper.truncate();
+    }
+
+    /**
+     * This method is called when a job is pulled to run.
+     * It is properly marked so that it won't be returned from next job queries.
+     * <p/>
+     * Same mechanism is also used for cancelled jobs.
+     *
+     * @param jobHolder The job holder to update session id
+     */
+    private void setSessionIdOnJob(JobHolder jobHolder) {
+        SQLiteStatement stmt = sqlHelper.getOnJobFetchedForRunningStatement();
+        jobHolder.setRunCount(jobHolder.getRunCount() + 1);
+        jobHolder.setRunningSessionId(sessionId);
+        stmt.clearBindings();
+        stmt.bindLong(1, jobHolder.getRunCount());
+        stmt.bindLong(2, sessionId);
+        stmt.bindString(3, jobHolder.getId());
+        stmt.execute();
+    }
+
+    @SuppressWarnings("unused")
+    public String logJobs() {
+        StringBuilder sb =  new StringBuilder();
+        String select = sqlHelper.createSelect(
+                null,
+                100,
+                new SqlHelper.Order(DbOpenHelper.PRIORITY_COLUMN,
+                        SqlHelper.Order.Type.DESC),
+                new SqlHelper.Order(DbOpenHelper.CREATED_NS_COLUMN,
+                        SqlHelper.Order.Type.ASC),
+                new SqlHelper.Order(DbOpenHelper.INSERTION_ORDER_COLUMN, SqlHelper.Order.Type.ASC)
+        );
+        Cursor cursor = db.rawQuery(select, new String[0]);
+        try {
+            while (cursor.moveToNext()) {
+                String id = cursor.getString(DbOpenHelper.ID_COLUMN.columnIndex);
+                sb.append(cursor.getLong(DbOpenHelper.INSERTION_ORDER_COLUMN.columnIndex))
+                        .append(" ")
+                        .append(id).append(" id:")
+                        .append(cursor.getString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex))
+                        .append(" delay until:")
+                        .append(cursor.getLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex))
+                        .append(" sessionId:")
+                        .append(cursor.getLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex))
+                        .append(" reqNetworkUntil:")
+                        .append(cursor.getLong(DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnIndex))
+                        .append(" reqUnmeteredNetworkUntil:")
+                        .append(cursor.getLong(DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnIndex));
+                Cursor tags = db.rawQuery("SELECT " + DbOpenHelper.TAGS_NAME_COLUMN.columnName
+                        + " FROM " + DbOpenHelper.JOB_TAGS_TABLE_NAME + " WHERE "
+                        + DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName + " = ?", new String[]{id});
+                try {
+                    while (tags.moveToNext()) {
+                        sb.append(", ").append(tags.getString(0));
+                    }
+                } finally {
+                    safeCloseCursor(tags);
+                }
+                sb.append("\n");
+
+            }
+        } finally {
+            safeCloseCursor(cursor);
+        }
+        return sb.toString();
+    }
+
+    private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidJobException {
+        Job job = safeDeserialize(cursor.getBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex));
+        if (job == null) {
+            throw new InvalidJobException();
+        }
+        return new JobHolder.Builder()
+                .insertionOrder(cursor.getLong(DbOpenHelper.INSERTION_ORDER_COLUMN.columnIndex))
+                .priority(cursor.getInt(DbOpenHelper.PRIORITY_COLUMN.columnIndex))
+                .groupId(cursor.getString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex))
+                .runCount(cursor.getInt(DbOpenHelper.RUN_COUNT_COLUMN.columnIndex))
+                .job(job)
+                .createdNs(cursor.getLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex))
+                .delayUntilNs(cursor.getLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex))
+                .runningSessionId(cursor.getLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex))
+                .build();
+
+    }
+
+    private Job safeDeserialize(byte[] bytes) {
+        try {
+            return jobSerializer.deserialize(bytes);
+        } catch (Throwable t) {
+            JqLog.e(t, "error while deserializing job");
+        }
+        return null;
+    }
+
+    private byte[] getSerializeJob(JobHolder jobHolder) {
+        return safeSerialize(jobHolder.getJob());
+    }
+
+    private byte[] safeSerialize(Object object) {
+        try {
+            return jobSerializer.serialize(object);
+        } catch (Throwable t) {
+            JqLog.e(t, "error while serializing object %s", object.getClass().getSimpleName());
+        }
+        return null;
+    }
+    
+    private void safeCloseCursor(Cursor cursor) {
+        if (cursor != null) {
+            try {
+                cursor.close();
+            } catch (Throwable t) {
+                JqLog.e(t, "error while closing cursor.");
+            }
+        }
+    }
+    
+    private void safeEndTransaction() {
+        try {
+            db.endTransaction();
+        } catch (SQLException e) {
+            JqLog.e(e, "end transaction with sql exception.");
+        }
+    }
+
+    private static class InvalidJobException extends Exception {
+
+    }
+
+    public static class JavaSerializer implements JobSerializer {
+
+        @Override
+        public byte[] serialize(Object object) throws IOException {
+            if (object == null) {
+                return null;
+            }
+            ByteArrayOutputStream bos = null;
+            try {
+                bos = new ByteArrayOutputStream();
+                ObjectOutput out = new ObjectOutputStream(bos);
+                out.writeObject(object);
+                // Get the bytes of the serialized object
+                return bos.toByteArray();
+            } finally {
+                if (bos != null) {
+                    bos.close();
+                }
+            }
+        }
+
+        @Override
+        public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
+            if (bytes == null || bytes.length == 0) {
+                return null;
+            }
+            ObjectInputStream in = null;
+            try {
+                in = new ObjectInputStream(new ByteArrayInputStream(bytes));
+                //noinspection unchecked
+                return (T) in.readObject();
+            } finally {
+                if (in != null) {
+                    in.close();
+                }
+            }
+        }
+    }
+
+    public interface JobSerializer {
+        byte[] serialize(Object object) throws IOException;
+        <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException;
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/Where.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/Where.java
new file mode 100644
index 0000000..9530512
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/Where.java
@@ -0,0 +1,167 @@
+package com.birbit.android.jobqueue.persistentQueue.sqlite;
+
+import com.birbit.android.jobqueue.Params;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+public class Where {
+    public final long cacheKey;
+    public final String query;
+    public final String[] args;
+
+    private SQLiteStatement countReadyStmt;
+    private String findJobsQuery;
+    private SQLiteStatement nextJobDelayUntilStmt;
+    private SQLiteStatement nextJobDelayUntilViaNetworkStmt;
+    private String nextJobQuery;
+    private int networkTimeoutArgIndex = -1;
+    private int unmeteredNetworkTimeoutArgIndex = -1;
+
+    public Where(long cacheKey, String query, String[] args) {
+        this.cacheKey = cacheKey;
+        this.query = query;
+        this.args = args;
+    }
+
+    public void setNetworkTimeoutArgIndex(int index) {
+        this.networkTimeoutArgIndex = index;
+    }
+
+    public void setUnmeteredNetworkTimeoutArgIndex(int unmeteredNetworkTimeoutArgIndex) {
+        this.unmeteredNetworkTimeoutArgIndex = unmeteredNetworkTimeoutArgIndex;
+    }
+
+    public SQLiteStatement countReady(SQLiteDatabase database, StringBuilder stringBuilder) {
+        if (countReadyStmt == null) {
+            stringBuilder.setLength(0);
+            stringBuilder.append("SELECT SUM(case WHEN ")
+                    .append(DbOpenHelper.GROUP_ID_COLUMN.columnName)
+                    .append(" is null then group_cnt else 1 end) from (")
+                        .append("SELECT count(*) group_cnt, ")
+                        .append(DbOpenHelper.GROUP_ID_COLUMN.columnName)
+                        .append(" FROM ")
+                        .append(DbOpenHelper.JOB_HOLDER_TABLE_NAME)
+                        .append(" WHERE ")
+                        .append(query)
+                        .append(" GROUP BY ")
+                        .append(DbOpenHelper.GROUP_ID_COLUMN.columnName)
+                    .append(")");
+            countReadyStmt = database.compileStatement(stringBuilder.toString());
+        } else {
+            countReadyStmt.clearBindings();
+        }
+        for (int i = 1; i <= args.length; i ++) {
+            countReadyStmt.bindString(i, args[i - 1]);
+        }
+        return countReadyStmt;
+    }
+    public SQLiteStatement nextJobDelayUntilWithNetworkRequirement(SQLiteDatabase database,
+            SqlHelper sqlHelper) {
+        if (nextJobDelayUntilViaNetworkStmt == null) {
+            StringBuilder sb = sqlHelper.reusedStringBuilder;
+            sb.setLength(0);
+            sb.append("SELECT max(")
+                .append(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName);
+            if (networkTimeoutArgIndex != -1) {
+                sb.append(",")
+                        .append(DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnName);
+            }
+            if (unmeteredNetworkTimeoutArgIndex != -1) {
+                sb.append(",")
+                        .append(DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnName);
+            }
+            sb.append(") FROM ")
+                    .append(DbOpenHelper.JOB_HOLDER_TABLE_NAME)
+                    .append(" WHERE ")
+                    .append(query);
+            // below NOT constraints are safe to add because this query will only be accessed if
+            // they are set to be excluded.
+            if (networkTimeoutArgIndex != -1) {
+                sb.append(" AND ")
+                        .append(DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnName)
+                        .append(" != ").append(Params.FOREVER);
+            }
+            if (unmeteredNetworkTimeoutArgIndex != -1) {
+                sb.append(" AND ")
+                        .append(DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnName)
+                        .append(" != ").append(Params.FOREVER);
+            }
+            sb.append(" ORDER BY 1 ASC").append(" limit 1");
+            String selectQuery = sb.toString();
+            nextJobDelayUntilViaNetworkStmt = database.compileStatement(selectQuery);
+        } else {
+            nextJobDelayUntilViaNetworkStmt.clearBindings();
+        }
+        for (int i = 1; i <= args.length; i ++) {
+            nextJobDelayUntilViaNetworkStmt.bindString(i, args[i - 1]);
+        }
+        if (networkTimeoutArgIndex != -1) {
+            nextJobDelayUntilViaNetworkStmt.bindString(networkTimeoutArgIndex + 1,
+                    Long.toString(Params.FOREVER));
+        }
+        if (unmeteredNetworkTimeoutArgIndex != -1) {
+            nextJobDelayUntilViaNetworkStmt.bindString(unmeteredNetworkTimeoutArgIndex + 1,
+                    Long.toString(Params.FOREVER));
+        }
+
+        return nextJobDelayUntilViaNetworkStmt;
+    }
+
+    public SQLiteStatement nextJobDelayUntil(SQLiteDatabase database, SqlHelper sqlHelper) {
+        if (nextJobDelayUntilStmt == null) {
+            String selectQuery = sqlHelper.createSelectOneField(
+                    DbOpenHelper.DELAY_UNTIL_NS_COLUMN,
+                    query,
+                    1,
+                    new SqlHelper.Order(DbOpenHelper.DELAY_UNTIL_NS_COLUMN,
+                            SqlHelper.Order.Type.ASC)
+            );
+            nextJobDelayUntilStmt = database.compileStatement(selectQuery);
+        } else {
+            nextJobDelayUntilStmt.clearBindings();
+        }
+        for (int i = 1; i <= args.length; i ++) {
+            nextJobDelayUntilStmt.bindString(i, args[i - 1]);
+        }
+        return nextJobDelayUntilStmt;
+    }
+
+    public String nextJob(SqlHelper sqlHelper) {
+        if (nextJobQuery == null) {
+            nextJobQuery = sqlHelper.createSelect(
+                    query,
+                    1,
+                    new SqlHelper.Order(DbOpenHelper.PRIORITY_COLUMN,
+                            SqlHelper.Order.Type.DESC),
+                    new SqlHelper.Order(DbOpenHelper.CREATED_NS_COLUMN,
+                            SqlHelper.Order.Type.ASC),
+                    new SqlHelper.Order(DbOpenHelper.INSERTION_ORDER_COLUMN,
+                            SqlHelper.Order.Type.ASC)
+            );
+        }
+        return nextJobQuery;
+    }
+
+    public String findJobs(SqlHelper sqlHelper) {
+        if (findJobsQuery == null) {
+            findJobsQuery = sqlHelper.createSelect(query, null);
+        }
+        return findJobsQuery;
+    }
+
+    public void destroy() {
+        if (countReadyStmt != null) {
+            countReadyStmt.close();
+            countReadyStmt = null;
+        }
+        if (nextJobDelayUntilStmt != null) {
+            nextJobDelayUntilStmt.close();
+            nextJobDelayUntilStmt = null;
+        }
+        if (nextJobDelayUntilViaNetworkStmt != null) {
+            nextJobDelayUntilViaNetworkStmt.close();
+            nextJobDelayUntilViaNetworkStmt = null;
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/WhereQueryCache.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/WhereQueryCache.java
new file mode 100644
index 0000000..ba381c1
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/persistentQueue/sqlite/WhereQueryCache.java
@@ -0,0 +1,217 @@
+package com.birbit.android.jobqueue.persistentQueue.sqlite;
+
+import com.birbit.android.jobqueue.Constraint;
+import com.birbit.android.jobqueue.TagConstraint;
+
+import android.support.v4.util.LruCache;
+
+import java.util.Collection;
+
+/**
+ * Internal class to cache sql queries and statements.
+ */
+class WhereQueryCache {
+    private static final int INT_SIZE = 6;
+    private static final int BOOL_SIZE = 1;
+    private static final int NETWORK = 0;
+    private static final int UNMETERED_NETWORK = NETWORK + BOOL_SIZE;
+    private static final int TAG_TYPE = UNMETERED_NETWORK + BOOL_SIZE;
+    private static final int TAG_COUNT = TAG_TYPE + BOOL_SIZE + BOOL_SIZE;
+    private static final int GROUP_COUNT = TAG_COUNT + INT_SIZE;
+    private static final int JOB_COUNT = GROUP_COUNT + INT_SIZE;
+    private static final int EXCLUDE_RUNNING = JOB_COUNT + INT_SIZE;
+    private static final int TIME_LIMIT = EXCLUDE_RUNNING + BOOL_SIZE;
+    private static final int PENDING_CANCELLATIONS = TIME_LIMIT + BOOL_SIZE;
+    private static final int INT_LIMIT = 1 << INT_SIZE;
+
+    // TODO implement some query cacheable check for queries that have way too many parameters
+    private final LruCache<Long, Where> queryCache = new LruCache<Long, Where>(15) {
+        @Override
+        protected void entryRemoved(boolean evicted, Long key, Where oldValue, Where newValue) {
+            oldValue.destroy();
+        }
+    };
+
+    private final String sessionId;
+
+    public WhereQueryCache(long sessionId) {
+        this.sessionId = Long.toString(sessionId);
+    }
+
+    public Where build(Constraint constraint, Collection<String> pendingCancellations,
+            StringBuilder stringBuilder) {
+        final boolean cacheable = isCacheable(constraint);
+        final long cacheKey = cacheKey(constraint, pendingCancellations);
+        Where where = cacheable ? queryCache.get(cacheKey) : null;
+        if (where == null) {
+            // build it
+            where = createWhere(cacheKey, constraint, pendingCancellations, stringBuilder);
+            if (cacheable) {
+                queryCache.put(cacheKey, where);
+            }
+        }
+        fillWhere(constraint, where, pendingCancellations);
+        return where;
+    }
+
+    private void fillWhere(Constraint constraint, Where where,
+            Collection<String> pendingCancellations) {
+        int count = 0;
+        if (constraint.shouldNotRequireNetwork()) {
+            where.args[count++] = Long.toString(constraint.getNowInNs());
+        }
+        if (constraint.shouldNotRequireUnmeteredNetwork()) {
+            where.args[count++] = Long.toString(constraint.getNowInNs());
+        }
+        if (constraint.getTimeLimit() != null) {
+            where.args[count++] = Long.toString(constraint.getTimeLimit());
+        }
+        if (constraint.getTagConstraint() != null) {
+            for (String tag : constraint.getTags()) {
+                where.args[count++] = tag;
+            }
+        }
+        for (String group : constraint.getExcludeGroups()) {
+            where.args[count++] = group;
+        }
+        for (String jobId : constraint.getExcludeJobIds()) {
+            where.args[count++] = jobId;
+        }
+        for (String cancelled : pendingCancellations) {
+            where.args[count++] = cancelled;
+        }
+        if (constraint.excludeRunning()) {
+            where.args[count++] = sessionId;
+        }
+        if (count != where.args.length) {
+            throw new IllegalStateException("something is wrong with where query cache for "
+                    + where.query);
+        }
+    }
+
+    private Where createWhere(long cacheKey, Constraint constraint,
+            Collection<String> pendingCancellations, StringBuilder reusedStringBuilder) {
+        reusedStringBuilder.setLength(0);
+        int argCount = 0;
+        reusedStringBuilder.append("1");
+        int networkTimeoutArgIndex = -1;
+        int unmeteredTimeoutArgIndex = -1;
+        if (constraint.shouldNotRequireNetwork()) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.REQUIRES_NETWORK_UNTIL_COLUMN.columnName)
+                    .append(" <= ?");
+            networkTimeoutArgIndex = argCount;
+            argCount++;
+        }
+        if (constraint.shouldNotRequireUnmeteredNetwork()) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.REQUIRES_UNMETERED_NETWORK_UNTIL_COLUMN.columnName)
+                    .append(" <= ?");
+            unmeteredTimeoutArgIndex = argCount;
+            argCount++;
+        }
+        if (constraint.getTimeLimit() != null) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName)
+                    .append(" <= ?");
+            argCount++;
+        }
+        if (constraint.getTagConstraint() != null) {
+            if (constraint.getTags().isEmpty()) {
+                reusedStringBuilder.append(" AND 0 ");
+            } else {
+                reusedStringBuilder
+                        .append(" AND ")
+                        .append(DbOpenHelper.ID_COLUMN.columnName).append(" IN ( SELECT ")
+                        .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append(" FROM ")
+                        .append(DbOpenHelper.JOB_TAGS_TABLE_NAME).append(" WHERE ")
+                        .append(DbOpenHelper.TAGS_NAME_COLUMN.columnName).append(" IN (");
+                SqlHelper.addPlaceholdersInto(reusedStringBuilder,
+                        constraint.getTags().size());
+                reusedStringBuilder.append(")");
+                if (constraint.getTagConstraint() == TagConstraint.ANY) {
+                    reusedStringBuilder.append(")");
+                } else if (constraint.getTagConstraint() == TagConstraint.ALL) {
+                    reusedStringBuilder.append(" GROUP BY (`")
+                            .append(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnName).append("`)")
+                            .append(" HAVING count(*) = ")
+                            .append(constraint.getTags().size()).append(")");
+                } else {
+                    // have this in place in case we change number of constraints
+                    throw new IllegalArgumentException("unknown constraint " + constraint);
+                }
+                argCount += constraint.getTags().size();
+            }
+        }
+        if (!constraint.getExcludeGroups().isEmpty()) {
+            reusedStringBuilder
+                    .append(" AND (")
+                    .append(DbOpenHelper.GROUP_ID_COLUMN.columnName)
+                    .append(" IS NULL OR ")
+                    .append(DbOpenHelper.GROUP_ID_COLUMN.columnName)
+                    .append(" NOT IN(");
+            SqlHelper.addPlaceholdersInto(reusedStringBuilder,
+                    constraint.getExcludeGroups().size());
+            reusedStringBuilder.append("))");
+            argCount += constraint.getExcludeGroups().size();
+        }
+        if (!constraint.getExcludeJobIds().isEmpty()) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.ID_COLUMN.columnName)
+                    .append(" NOT IN(");
+            SqlHelper.addPlaceholdersInto(reusedStringBuilder,
+                    constraint.getExcludeJobIds().size());
+            reusedStringBuilder.append(")");
+            argCount += constraint.getExcludeJobIds().size();
+        }
+        if (!pendingCancellations.isEmpty()) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.ID_COLUMN.columnName)
+                    .append(" NOT IN(");
+            SqlHelper.addPlaceholdersInto(reusedStringBuilder,
+                    pendingCancellations.size());
+            reusedStringBuilder.append(")");
+            argCount += pendingCancellations.size();
+        }
+        if (constraint.excludeRunning()) {
+            reusedStringBuilder
+                    .append(" AND ")
+                    .append(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName)
+                    .append(" != ?");
+            argCount++;
+        }
+        String[] args = new String[argCount];
+        Where where = new Where(cacheKey, reusedStringBuilder.toString(), args);
+        where.setNetworkTimeoutArgIndex(networkTimeoutArgIndex);
+        where.setUnmeteredNetworkTimeoutArgIndex(unmeteredTimeoutArgIndex);
+        return where;
+    }
+
+    private boolean isCacheable(Constraint constraint) {
+        return constraint.getTags().size() < INT_LIMIT &&
+                constraint.getExcludeGroups().size() < INT_LIMIT &&
+                constraint.getExcludeJobIds().size() < INT_LIMIT;
+
+    }
+
+    private long cacheKey(Constraint constraint, Collection<String> pendingCancelations) {
+        long key;
+        //noinspection PointlessBitwiseExpression
+        key = (constraint.shouldNotRequireNetwork() ? 1 : 0) << NETWORK
+                | (constraint.shouldNotRequireUnmeteredNetwork() ? 1 : 0) << UNMETERED_NETWORK
+                | (constraint.getTagConstraint() == null ? 2 : constraint.getTagConstraint().ordinal()) << TAG_TYPE
+                | constraint.getTags().size() << TAG_COUNT
+                | constraint.getExcludeGroups().size() << GROUP_COUNT
+                | constraint.getExcludeJobIds().size() << JOB_COUNT
+                | (constraint.excludeRunning() ? 1 : 0) << EXCLUDE_RUNNING
+                | (constraint.getTimeLimit() == null ? 1 : 0) << TIME_LIMIT
+                | pendingCancelations.size() << PENDING_CANCELLATIONS;
+        return key;
+    }
+
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkJobSchedulerService.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkJobSchedulerService.java
new file mode 100644
index 0000000..305df92
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkJobSchedulerService.java
@@ -0,0 +1,87 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import android.annotation.TargetApi;
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.content.Context;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * The service implementation for the framework job scheduler
+ */
+@TargetApi(21)
+abstract public class FrameworkJobSchedulerService extends JobService {
+    private static final Map<Class<? extends FrameworkJobSchedulerService>, FrameworkScheduler>
+            schedulerMap = new HashMap<>();
+
+    /**
+     * Creates a scheduler for the given service.
+     * Keep in mind that there is a strict 1-1 mapping between the created scheduler and the
+     * service. You should pass the returned scheduler to the JobManager configuration.
+     *
+     * @param appContext The application context
+     * @param klass The service implementation that extends FrameworkJobSchedulerService.
+     *
+     * @return A scheduler that is associated with the given service class.
+     */
+    public static FrameworkScheduler createSchedulerFor(
+            @SuppressWarnings("UnusedParameters") Context appContext,
+            Class<? extends FrameworkJobSchedulerService> klass) {
+        if (FrameworkJobSchedulerService.class == klass) {
+            throw new IllegalArgumentException("You must create a service that extends" +
+                    " FrameworkJobSchedulerService");
+        }
+        synchronized (schedulerMap) {
+            if (schedulerMap.get(klass) != null) {
+                throw new IllegalStateException("You can create 1 scheduler per" +
+                        " FrameworkJobService. " + klass.getCanonicalName() + " already has one.");
+            }
+            FrameworkScheduler scheduler = new FrameworkScheduler(klass);
+            schedulerMap.put(klass, scheduler);
+            return scheduler;
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        FrameworkScheduler scheduler = getScheduler();
+        if (scheduler != null) {
+            scheduler.setJobService(this);
+        } else {
+            JqLog.e("FrameworkJobSchedulerService has been created but it does not have a" +
+                    " scheduler. You must initialize JobManager before the service is created.");
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        FrameworkScheduler scheduler = getScheduler();
+        if (scheduler != null) {
+            scheduler.setJobService(null);
+        } else {
+            JqLog.e("FrameworkJobSchedulerService is being destroyed but it does not have a " +
+                    "scheduler :/. You must initialize JobManager before the service is created.");
+        }
+    }
+
+    @Override
+    public boolean onStartJob(JobParameters params) {
+        return getScheduler().onStartJob(params);
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        return getScheduler().onStopJob(params);
+    }
+
+    protected FrameworkScheduler getScheduler() {
+        return schedulerMap.get(getClass());
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkScheduler.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkScheduler.java
new file mode 100644
index 0000000..6c72418
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/FrameworkScheduler.java
@@ -0,0 +1,170 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import android.annotation.TargetApi;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.PersistableBundle;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+
+import java.util.UUID;
+
+/**
+ * Scheduler implementation that uses the frameworks' scheduler API.
+ */
+@TargetApi(21)
+public class FrameworkScheduler extends Scheduler {
+    private static final String KEY_UUID = "uuid";
+    private static final String KEY_ID = "id";
+    private static final String KEY_DELAY = "delay";
+    private static final String KEY_NETWORK_STATUS = "networkStatus";
+
+    private JobScheduler jobScheduler;
+    private static SharedPreferences preferences;
+    private ComponentName componentName;
+    // set when service invokes, cleared when service dies
+    @Nullable private JobService jobService;
+    private final Class<? extends FrameworkJobSchedulerService> serviceImpl;
+
+    public FrameworkScheduler(Class< ? extends FrameworkJobSchedulerService> serviceImpl) {
+        this.serviceImpl = serviceImpl;
+    }
+
+    public void setJobService(@Nullable JobService jobService) {
+        this.jobService = jobService;
+    }
+
+    private static SharedPreferences getPreferences(Context context) {
+        synchronized (FrameworkScheduler.class) {
+            if (preferences == null) {
+                preferences = context.getSharedPreferences("jobqueue_fw_scheduler",
+                        Context.MODE_PRIVATE);
+            }
+            return preferences;
+        }
+    }
+
+    private ComponentName getComponentName() {
+        if (componentName == null) {
+            componentName = new ComponentName(getApplicationContext().getPackageName(),
+                    serviceImpl.getCanonicalName());
+        }
+        return componentName;
+    }
+
+    /**
+     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not
+     * to conflict with the rest of your application.
+     *
+     * @return A unique integer id for the next Job request to be sent to system scheduler
+     */
+    public int createId() {
+        synchronized (FrameworkScheduler.class) {
+            final SharedPreferences preferences = getPreferences(getApplicationContext());
+            final int id = preferences.getInt(KEY_ID, 0) + 1;
+            preferences.edit().putInt(KEY_ID, id).commit();
+            return id;
+        }
+    }
+
+    private JobScheduler getJobScheduler() {
+        if (jobScheduler == null) {
+            jobScheduler = (JobScheduler) getApplicationContext()
+                    .getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        }
+        return jobScheduler;
+    }
+
+    @Override
+    public void request(SchedulerConstraint constraint) {
+        JobScheduler jobScheduler = getJobScheduler();
+
+        final int id = createId();
+        JobInfo.Builder builder = new JobInfo.Builder(id, getComponentName())
+                .setExtras(toPersistentBundle(constraint))
+                .setPersisted(true);
+        switch (constraint.getNetworkStatus()) {
+            case NetworkUtil.UNMETERED:
+                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);
+                break;
+            case NetworkUtil.METERED:
+                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);
+                break;
+            default:
+                builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE);
+                builder.setRequiresDeviceIdle(true);
+                break;
+        }
+        int scheduled = jobScheduler.schedule(builder.build());
+        JqLog.d("[FW Scheduler] scheduled a framework job. Success? %s id: %d" +
+                " created id: %d", scheduled > 0, scheduled, id);
+    }
+
+    @Override
+    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("[FW Scheduler] on finished job %s. reschedule:%s", constraint, reschedule);
+        }
+        JobService service = this.jobService;
+        if (service == null) {
+            JqLog.e("[FW Scheduler] scheduler onfinished is called but i don't have a job service");
+            return;
+        }
+
+        Object data = constraint.getData();
+        if (data instanceof JobParameters) {
+            JobParameters params = (JobParameters) data;
+            service.jobFinished(params, reschedule);
+        } else {
+            JqLog.e("[FW Scheduler] cannot obtain the job parameters");
+        }
+
+    }
+
+    @Override
+    public void cancelAll() {
+        JqLog.d("[FW Scheduler] cancel all");
+        getJobScheduler().cancelAll();
+    }
+
+    private static PersistableBundle toPersistentBundle(SchedulerConstraint constraint) {
+        PersistableBundle bundle = new PersistableBundle();
+        // put boolean is api 22
+        bundle.putString(KEY_UUID, constraint.getUuid());
+        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());
+        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());
+        return bundle;
+    }
+
+    private static SchedulerConstraint fromBundle(PersistableBundle bundle) {
+        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));
+        if (constraint.getUuid() == null) {
+            // backward compatibility
+            constraint.setUuid(UUID.randomUUID().toString());
+        }
+        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));
+        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));
+        return constraint;
+    }
+
+    public boolean onStartJob(JobParameters params) {
+        SchedulerConstraint constraint = fromBundle(params.getExtras());
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("[FW Scheduler] start job %s %d", constraint, params.getJobId());
+        }
+        constraint.setData(params);
+        return start(constraint);
+    }
+
+    public boolean onStopJob(JobParameters params) {
+        SchedulerConstraint constraint = fromBundle(params.getExtras());
+        return stop(constraint);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmJobSchedulerService.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmJobSchedulerService.java
new file mode 100644
index 0000000..300510d
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmJobSchedulerService.java
@@ -0,0 +1,63 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import android.content.Context;
+
+import com.birbit.android.jobqueue.log.JqLog;
+import com.google.android.gms.gcm.GcmNetworkManager;
+import com.google.android.gms.gcm.GcmTaskService;
+import com.google.android.gms.gcm.TaskParams;
+
+import java.util.HashMap;
+import java.util.Map;
+
+abstract public class GcmJobSchedulerService extends GcmTaskService {
+    private static final Map<Class<? extends GcmJobSchedulerService>, GcmScheduler>
+            schedulerMap = new HashMap<>();
+
+    /**
+     * Creates a scheduler for the given service.
+     * Keep in mind that there is a strict 1-1 mapping between the created scheduler and the
+     * service. You should pass the returned scheduler to the JobManager configuration.
+     *
+     * @param appContext The application context
+     * @param klass The service implementation that extends GcmJobSchedulerService.
+     *
+     * @return A scheduler that is associated with the given service class.
+     */
+    public static GcmScheduler createSchedulerFor(Context appContext,
+            Class<? extends GcmJobSchedulerService> klass) {
+        if (GcmJobSchedulerService.class == klass) {
+            throw new IllegalArgumentException("You must create a service that extends" +
+                    " GcmJobSchedulerService");
+        }
+        synchronized (schedulerMap) {
+            if (schedulerMap.get(klass) != null) {
+                throw new IllegalStateException("You can create 1 scheduler per" +
+                        " GcmJobSchedulerService. " + klass.getCanonicalName() +
+                        " already has one.");
+            }
+            GcmScheduler scheduler = new GcmScheduler(appContext.getApplicationContext(), klass);
+            schedulerMap.put(klass, scheduler);
+            return scheduler;
+        }
+    }
+
+    @Override
+    public int onRunTask(TaskParams taskParams) {
+        GcmScheduler scheduler = getScheduler();
+        if (scheduler != null) {
+            return scheduler.onStartJob(taskParams);
+        } else {
+            JqLog.e("RunTask on GcmJobSchedulerService has been called but it does not have a " +
+                    "scheduler. Make sure you've initialized JobManager before the service might" +
+                    " be created.");
+            return GcmNetworkManager.RESULT_FAILURE;
+        }
+
+    }
+
+    protected GcmScheduler getScheduler() {
+        return schedulerMap.get(getClass());
+    }
+
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmScheduler.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmScheduler.java
new file mode 100644
index 0000000..1f9e133
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/GcmScheduler.java
@@ -0,0 +1,175 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+
+import com.birbit.android.jobqueue.BatchingScheduler;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.google.android.gms.gcm.GcmNetworkManager;
+import com.google.android.gms.gcm.GcmTaskService;
+import com.google.android.gms.gcm.OneoffTask;
+import com.google.android.gms.gcm.Task;
+import com.google.android.gms.gcm.TaskParams;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public class GcmScheduler extends Scheduler {
+    private static final String KEY_UUID = "uuid";
+    private static final String KEY_ID = "id";
+    private static final String KEY_DELAY = "delay";
+    private static final String KEY_NETWORK_STATUS = "networkStatus";
+    private static SharedPreferences preferences;
+    private final GcmNetworkManager gcmNetworkManager;
+    private final Class<? extends GcmJobSchedulerService> serviceClass;
+
+    public GcmScheduler(Context context, Class<? extends GcmJobSchedulerService> serviceClass) {
+        this.serviceClass = serviceClass;
+        gcmNetworkManager = GcmNetworkManager.getInstance(context.getApplicationContext());
+    }
+
+    private static SharedPreferences getPreferences(Context context) {
+        synchronized (GcmScheduler.class) {
+            if (preferences == null) {
+                preferences = context.getSharedPreferences("jobqueue_gcm_scheduler",
+                        Context.MODE_PRIVATE);
+            }
+            return preferences;
+        }
+    }
+
+    /**
+     * Creates a new ID for the job info. Can be overridden if you need to provide different ids not
+     * to conflict with the rest of your application.
+     *
+     * @return A unique integer id for the next Job request to be sent to system scheduler
+     */
+    @SuppressLint("CommitPrefEdits")
+    public int createId() {
+        synchronized (GcmScheduler.class) {
+            final SharedPreferences preferences = getPreferences(getApplicationContext());
+            final int id = preferences.getInt(KEY_ID, 0) + 1;
+            preferences.edit().putInt(KEY_ID, id).commit();
+            return id;
+        }
+    }
+
+    @Override
+    public void request(SchedulerConstraint constraint) {
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("creating gcm wake up request for %s", constraint);
+        }
+        OneoffTask oneoffTask = new OneoffTask.Builder()
+                .setExecutionWindow(constraint.getDelayInMs(), constraint.getDelayInMs()
+                        + getExecutionWindowSizeInSeconds())
+                .setRequiredNetwork(toNetworkState(constraint.getNetworkStatus()))
+                .setPersisted(true)
+                .setService(serviceClass)
+                .setTag("jobmanager-" + createId())
+                .setExtras(toBundle(constraint))
+                .build();
+        gcmNetworkManager.schedule(oneoffTask);
+    }
+
+    /**
+     * GCMNetworkManager accepts an execution window for jobs so that it can batch them together for
+     * better battery utilization. You can override this method to provide a different execution
+     * window. The default value is {@link BatchingScheduler#DEFAULT_BATCHING_PERIOD_IN_MS} (converted
+     * to seconds).
+     *
+     * @return The execution window time for the Job request
+     */
+    public long getExecutionWindowSizeInSeconds() {
+        return TimeUnit.MILLISECONDS.toSeconds(BatchingScheduler.DEFAULT_BATCHING_PERIOD_IN_MS);
+    }
+
+    @Override
+    public void cancelAll() {
+        gcmNetworkManager.cancelAllTasks(serviceClass);
+    }
+
+    private static int toNetworkState(@NetworkUtil.NetworkStatus int networkStatus) {
+        switch (networkStatus) {
+            case NetworkUtil.DISCONNECTED:
+                return Task.NETWORK_STATE_ANY;
+            case NetworkUtil.METERED:
+                return Task.NETWORK_STATE_CONNECTED;
+            case NetworkUtil.UNMETERED:
+                return Task.NETWORK_STATE_UNMETERED;
+        }
+        JqLog.e("unknown network status %d. Defaulting to CONNECTED", networkStatus);
+        return Task.NETWORK_STATE_CONNECTED;
+    }
+
+    private static Bundle toBundle(SchedulerConstraint constraint) {
+        Bundle bundle = new Bundle();
+        // put boolean is api 22
+        bundle.putString(KEY_UUID, constraint.getUuid());
+        bundle.putInt(KEY_NETWORK_STATUS, constraint.getNetworkStatus());
+        bundle.putLong(KEY_DELAY, constraint.getDelayInMs());
+        return bundle;
+    }
+
+    private static SchedulerConstraint fromBundle(Bundle bundle) {
+        SchedulerConstraint constraint = new SchedulerConstraint(bundle.getString(KEY_UUID));
+        if (constraint.getUuid() == null) {
+            // backward compatibility
+            constraint.setUuid(UUID.randomUUID().toString());
+        }
+        constraint.setNetworkStatus(bundle.getInt(KEY_NETWORK_STATUS, NetworkUtil.DISCONNECTED));
+        constraint.setDelayInMs(bundle.getLong(KEY_DELAY, 0));
+        return constraint;
+    }
+
+    public int onStartJob(TaskParams taskParams) {
+        SchedulerConstraint constraint = fromBundle(taskParams.getExtras());
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("starting job %s", constraint);
+        }
+
+        ResultCallback callback = new ResultCallback();
+        constraint.setData(callback);
+        start(constraint);
+        return callback.get() ? GcmNetworkManager.RESULT_RESCHEDULE : GcmNetworkManager.RESULT_SUCCESS;
+    }
+
+    @Override
+    public void onFinished(SchedulerConstraint constraint, boolean reschedule) {
+        Object data = constraint.getData();
+        if (JqLog.isDebugEnabled()) {
+            JqLog.d("finished job %s", constraint);
+        }
+        if (data instanceof ResultCallback) {
+            ResultCallback callback = (ResultCallback) data;
+            callback.onDone(reschedule);
+        }
+    }
+
+    private static class ResultCallback {
+        volatile boolean reschedule;
+        CountDownLatch latch;
+
+        public ResultCallback() {
+            latch = new CountDownLatch(1);
+            reschedule = false;
+        }
+
+        public boolean get() {
+            try {
+                latch.await(10 * 60, TimeUnit.SECONDS);
+            } catch (InterruptedException e) {
+                JqLog.e("job did not finish in 10 minutes :/");
+            }
+            return reschedule;
+        }
+
+        public void onDone(boolean reschedule) {
+            this.reschedule = reschedule;
+            latch.countDown();
+        }
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/Scheduler.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/Scheduler.java
new file mode 100644
index 0000000..0c3bb21
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/Scheduler.java
@@ -0,0 +1,81 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import android.content.Context;
+
+/**
+ * This class handles communication & tracking with a scheduler that can wake up the app / job
+ * manager based on external events.
+ * <p>
+ * JobManager will call attached scheduler every time it thinks that the app should be waken up for
+ * the given job. Each request comes with a {@link SchedulerConstraint} which should be reported
+ * back to the JobManager when the system service wakes it up.
+ */
+abstract public class Scheduler {
+    private Callback callback;
+    private Context context;
+
+    protected Scheduler() {
+
+    }
+
+    public void init(Context context, Callback callback) {
+        this.context = context.getApplicationContext();
+        this.callback = callback;
+    }
+
+    public Context getApplicationContext() {
+        return context;
+    }
+
+    abstract public void request(SchedulerConstraint constraint);
+
+    /**
+     * Triggers the JobManager to handle the given constraint. JobManager always call
+     * {@link #onFinished(SchedulerConstraint, boolean)} with an async callback.
+     *
+     * @param constraint The constraint
+     */
+    public final boolean start(SchedulerConstraint constraint) {
+        if (callback == null) {
+            throw new IllegalStateException("JobManager callback is not configured");
+        }
+        return callback.start(constraint);
+    }
+
+    public final boolean stop(SchedulerConstraint constraint) {
+        if (callback == null) {
+            throw new IllegalStateException("JobManager callback is not configured");
+        }
+        return callback.stop(constraint);
+    }
+
+    /**
+     * Called by the JobManager when a scheduled constraint is handled.
+     *
+     * @param constraint The original constraint
+     * @param reschedule True if the job should be rescheduled
+     */
+    abstract public void onFinished(SchedulerConstraint constraint, boolean reschedule);
+
+    /**
+     * When called, should cancel all pending jobs
+     */
+    public abstract void cancelAll();
+
+    /**
+     * Internal class that handles the communication between the JobManager and the scheduler
+     */
+    public interface Callback {
+        /**
+         * @param constraint
+         * @return True if no jobs to run, false otherwise
+         */
+        boolean start(SchedulerConstraint constraint);
+
+        /**
+         * @param constraint
+         * @return True if job should be rescheduled, false otherwise
+         */
+        boolean stop(SchedulerConstraint constraint);
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/SchedulerConstraint.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/SchedulerConstraint.java
new file mode 100644
index 0000000..03b42cd
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/scheduling/SchedulerConstraint.java
@@ -0,0 +1,73 @@
+package com.birbit.android.jobqueue.scheduling;
+
+import com.birbit.android.jobqueue.network.NetworkUtil;
+
+/**
+ * The constraints that are passed into Scheduler from JobManager
+ */
+public class SchedulerConstraint {
+    private String uuid;
+    private long delayInMs;
+    private int networkStatus;
+    // arbitrary data that can be used by the scheduler
+    private Object data;
+
+    public SchedulerConstraint(String uuid) {
+        this.uuid = uuid;
+    }
+
+    /**
+     * The unique id assigned by the job manager. This is different from the ID that is assigned
+     * by the third party scheduler.
+     * @return The unique id assigned by the job manager
+     */
+    public String getUuid() {
+        return uuid;
+    }
+
+    public void setUuid(String uuid) {
+        this.uuid = uuid;
+    }
+
+    /**
+     * The delay for the job
+     * @return The delay before running the job
+     */
+    public long getDelayInMs() {
+        return delayInMs;
+    }
+
+    public void setDelayInMs(long delayInMs) {
+        this.delayInMs = delayInMs;
+    }
+
+    /**
+     *
+     * @return The network status required to run the job.
+     */
+    @NetworkUtil.NetworkStatus
+    public int getNetworkStatus() {
+        return networkStatus;
+    }
+
+    public void setNetworkStatus(int networkStatus) {
+        this.networkStatus = networkStatus;
+    }
+
+    public Object getData() {
+        return data;
+    }
+
+    public void setData(Object data) {
+        this.data = data;
+    }
+
+    @Override
+    public String toString() {
+        return "SchedulerConstraint{" +
+                "uuid='" + uuid + '\'' +
+                ", delayInMs=" + delayInMs +
+                ", networkStatus=" + networkStatus +
+                '}';
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/SystemTimer.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/SystemTimer.java
new file mode 100644
index 0000000..3fecad6
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/SystemTimer.java
@@ -0,0 +1,46 @@
+package com.birbit.android.jobqueue.timer;
+
+import com.birbit.android.jobqueue.log.JqLog;
+
+import java.util.concurrent.TimeUnit;
+
+public class SystemTimer implements Timer {
+    final long startWallClock;
+    final long startNs;
+    public SystemTimer() {
+        JqLog.d("creating system timer");
+        //noinspection DIRECT_TIME_ACCESS
+        startWallClock = TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis());
+        //noinspection DIRECT_TIME_ACCESS
+        startNs = System.nanoTime();
+    }
+
+    @Override
+    public long nanoTime() {
+        //noinspection DIRECT_TIME_ACCESS
+        return System.nanoTime() - startNs + startWallClock;
+    }
+
+    @Override
+    public void waitOnObjectUntilNs(Object object, long untilNs) throws InterruptedException {
+        long now = nanoTime();
+        if (now > untilNs) {
+            //noinspection TIMED_WAIT
+            object.wait(1);
+        } else {
+            TimeUnit.NANOSECONDS.timedWait(object, untilNs - now);
+        }
+    }
+
+    @Override
+    public void waitOnObject(Object object) throws InterruptedException {
+        //noinspection TIMED_WAIT
+        object.wait();
+    }
+
+    @Override
+    public void notifyObject(Object object) {
+        //noinspection NOTIFY_ON_OBJECT
+        object.notifyAll();
+    }
+}
diff --git a/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/Timer.java b/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/Timer.java
new file mode 100644
index 0000000..f266f02
--- /dev/null
+++ b/jobqueue/src/main/java/com/birbit/android/jobqueue/timer/Timer.java
@@ -0,0 +1,8 @@
+package com.birbit.android.jobqueue.timer;
+
+public interface Timer {
+    long nanoTime();
+    void waitOnObjectUntilNs(Object object, long timeout) throws InterruptedException;
+    void notifyObject(Object object);
+    void waitOnObject(Object object) throws InterruptedException;
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
deleted file mode 100644
index 6fc1ab5..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
+++ /dev/null
@@ -1,306 +0,0 @@
-package com.path.android.jobqueue;
-
-import com.path.android.jobqueue.log.JqLog;
-
-import android.content.Context;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * Base class for all of your jobs.
- */
-@SuppressWarnings("deprecation")
-abstract public class Job implements Serializable {
-    private static final long serialVersionUID = 3L;
-    public static final int DEFAULT_RETRY_LIMIT = 20;
-
-    private boolean requiresNetwork;
-    private String groupId;
-    private boolean persistent;
-    private Set<String> readonlyTags;
-
-    private transient int currentRunCount;
-    transient int priority;
-    private transient long delayInMs;
-    transient boolean cancelled;
-
-    private transient Context applicationContext;
-
-    /**
-     * Only set if a job fails. Will be cleared by JobManager after it is handled
-     */
-    transient RetryConstraint retryConstraint;
-
-
-    protected Job(Params params) {
-        this.requiresNetwork = params.doesRequireNetwork();
-        this.persistent = params.isPersistent();
-        this.groupId = params.getGroupId();
-        this.priority = params.getPriority();
-        this.delayInMs = params.getDelayMs();
-        final Set<String> tags = params.getTags();
-        this.readonlyTags = tags == null ? null : Collections.unmodifiableSet(tags);
-    }
-
-    /**
-     * used by {@link JobManager} to assign proper priority at the time job is added.
-     * @return priority (higher = better)
-     */
-    public final int getPriority() {
-        return priority;
-    }
-
-    /**
-     * used by {@link JobManager} to assign proper delay at the time job is added.
-     * This field is not persisted!
-     * @return delay in ms
-     */
-    public final long getDelayInMs() {
-        return delayInMs;
-    }
-
-    /**
-     * Returns a readonly set of tags attached to this Job.
-     * @return Set of Tags. If tags do not exists, returns null.
-     */
-    public final Set<String> getTags() {
-        return readonlyTags;
-    }
-
-    private void writeObject(ObjectOutputStream oos) throws IOException {
-        oos.writeBoolean(requiresNetwork);
-        oos.writeObject(groupId);
-        oos.writeBoolean(persistent);
-        final int tagCount = readonlyTags == null ? 0 : readonlyTags.size();
-        oos.writeInt(tagCount);
-        if (tagCount > 0) {
-            for (String tag : readonlyTags) {
-                oos.writeUTF(tag);
-            }
-        }
-    }
-
-
-    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
-        requiresNetwork = ois.readBoolean();
-        groupId = (String) ois.readObject();
-        persistent = ois.readBoolean();
-        final int tagCount = ois.readInt();
-        if (tagCount > 0) {
-            readonlyTags = new HashSet<String>(tagCount);
-            for (int i = 0; i < tagCount; i ++) {
-                readonlyTags.add(ois.readUTF());
-            }
-        }
-    }
-
-    /**
-     * defines if we should add this job to disk or non-persistent queue
-     */
-    public final boolean isPersistent() {
-        return persistent;
-    }
-
-    /**
-     * Called when the job is added to disk and committed.
-     * This means job will eventually run. This is a good time to update local database and dispatch events.
-     * <p>
-     * Changes to this class will not be preserved if your job is persistent !!!
-     * <p>
-     * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
-     * <p>
-     * Note that this method is called on the thread the job is added. (e.g. {@link JobManager#addJob(Job)})
-     * is called. If job was added via {@link  JobManager#addJobInBackground(Job)} or
-     * {@link JobManager#addJobInBackground(Job, AsyncAddCallback)}, it will be run on JobManager's
-     * utility thread.
-     */
-    abstract public void onAdded();
-
-    /**
-     * The actual method that should to the work.
-     * It should finish w/o any exception. If it throws any exception,
-     * {@link #shouldReRunOnThrowable(Throwable, int, int)} will be called to
-     * decide either to dismiss the job or re-run it.
-     * @throws Throwable
-     */
-    abstract public void onRun() throws Throwable;
-
-    /**
-     * Called when a job is cancelled.
-     */
-    abstract protected void onCancel();
-
-    /**
-     * @deprecated use {@link #shouldReRunOnThrowable(Throwable, int, int)}
-     * This method will be removed in v2.0 and {@link #shouldReRunOnThrowable(Throwable, int, int)}
-     * will become abstract.
-     */
-    @Deprecated
-    protected boolean shouldReRunOnThrowable(Throwable throwable) {
-        return true;
-    }
-
-    /**
-     * If {@code onRun} method throws an exception, this method is called.
-     * <p>
-     * If you simply want to return retry or cancel, you can use {@link RetryConstraint#RETRY} or
-     * {@link RetryConstraint#CANCEL}.
-     * <p>
-     * You can also use a custom {@link RetryConstraint} where you can change the Job's priority or
-     * add a delay until the next run (e.g. exponential back off).
-     * <p>
-     * Note that changing the Job's priority or adding a delay may alter the original run order of
-     * the job. So if the job was added to the queue with other jobs and their execution order is
-     * important (e.g. they use the same groupId), you should not change job's priority or add a
-     * delay unless you really want to change their execution order.
-     *
-     * @param throwable The exception that was thrown from {@link #onRun()}
-     * @param runCount The number of times this job run. Starts from 1.
-     * @param maxRunCount The max number of times this job can run. Decided by {@link #getRetryLimit()}
-     * @return A {@link RetryConstraint} to decide whether this Job should be tried again or not and
-     * if yes, whether we should add a delay or alter its priority. Returning null from this method
-     * is equal to returning {@link RetryConstraint#RETRY}. Default implementation calls
-     * {@link #shouldReRunOnThrowable(Throwable)}.
-     */
-    protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
-        boolean reRun = shouldReRunOnThrowable(throwable);
-        return reRun ? RetryConstraint.RETRY : RetryConstraint.CANCEL;
-    }
-
-    /**
-     * Runs the job and catches any exception
-     * @param currentRunCount
-     * @return one of the RUN_RESULT ints
-     */
-    final int safeRun(JobHolder holder, int currentRunCount) {
-        this.currentRunCount = currentRunCount;
-        if (JqLog.isDebugEnabled()) {
-            JqLog.d("running job %s", this.getClass().getSimpleName());
-        }
-        boolean reRun = false;
-        boolean failed = false;
-        try {
-            onRun();
-            if (JqLog.isDebugEnabled()) {
-                JqLog.d("finished job %s", this);
-            }
-        } catch (Throwable t) {
-            failed = true;
-            JqLog.e(t, "error while executing job %s", this);
-            reRun = currentRunCount < getRetryLimit();
-            if(reRun && !cancelled) {
-                try {
-                    RetryConstraint retryConstraint = shouldReRunOnThrowable(t, currentRunCount,
-                            getRetryLimit());
-                    if (retryConstraint == null) {
-                        retryConstraint = RetryConstraint.RETRY;
-                    }
-                    this.retryConstraint = retryConstraint;
-                    reRun = retryConstraint.shouldRetry();
-                } catch (Throwable t2) {
-                    JqLog.e(t2, "shouldReRunOnThrowable did throw an exception");
-                }
-            }
-        }
-        JqLog.d("safeRunResult for %s : %s. re run:%s. cancelled: %s", this, !failed, reRun, cancelled);
-        if (!failed) {
-            return JobHolder.RUN_RESULT_SUCCESS;
-        }
-        if (holder.isCancelled()) {
-            return JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
-        }
-        if (reRun) {
-            return JobHolder.RUN_RESULT_TRY_AGAIN;
-        }
-        if (currentRunCount < getRetryLimit()) {
-            return JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
-        } else {
-            return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
-        }
-    }
-
-    /**
-     * before each run, JobManager sets this number. Might be useful for the {@link com.path.android.jobqueue.Job#onRun()}
-     * method
-     */
-    protected int getCurrentRunCount() {
-        return currentRunCount;
-    }
-
-    /**
-     * if job is set to require network, it will not be called unless {@link com.path.android.jobqueue.network.NetworkUtil}
-     * reports that there is a network connection
-     */
-    public final boolean requiresNetwork() {
-        return requiresNetwork;
-    }
-
-    /**
-     * Some jobs may require being run synchronously. For instance, if it is a job like sending a comment, we should
-     * never run them in parallel (unless they are being sent to different conversations).
-     * By assigning same groupId to jobs, you can ensure that that type of jobs will be run in the order they were given
-     * (if their priority is the same).
-     * @return
-     */
-    public final String getRunGroupId() {
-        return groupId;
-    }
-
-    /**
-     * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
-     * If job fails this many times, onCancel will be called w/o calling {@link #shouldReRunOnThrowable(Throwable, int, int)}
-     * @return
-     */
-    protected int getRetryLimit() {
-        return DEFAULT_RETRY_LIMIT;
-    }
-
-    /**
-     * Returns true if job is cancelled. Note that if the job is already running when it is cancelled,
-     * this flag is still set to true but job is NOT STOPPED (e.g. JobManager does not interrupt
-     * the thread).
-     * If you have a long job that may be cancelled, you can check this field and handle it manually.
-     * <p>
-     * Note that, if your job returns successfully from {@link #onRun()} method, it will be considered
-     * as successfully completed, thus will be added to {@link CancelResult#getFailedToCancel()}
-     * list. If you want this job to be considered as cancelled, you should throw an exception.
-     * You can also use {@link #assertNotCancelled()} method to do it.
-     * <p>
-     * Calling this method outside {@link #onRun()} method has no meaning since {@link #onRun()} will not
-     * be called if the job is cancelled before it is called.
-     */
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    /**
-     * Convenience method that checks if job is cancelled and throws a RuntimeException if it is
-     * cancelled.
-     */
-    public void assertNotCancelled() {
-        if (cancelled) {
-            throw new RuntimeException("job is cancelled");
-        }
-    }
-
-    /*package*/ void setApplicationContext(Context context) {
-        this.applicationContext = context;
-    }
-
-    /**
-     * Convenience method to get the application context in a Job.
-     * <p>
-     * This context is set when job is added to a JobManager.
-     *
-     * @return The application context
-     */
-    public Context getApplicationContext() {
-        return applicationContext;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
deleted file mode 100644
index 4e5fd19..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
+++ /dev/null
@@ -1,209 +0,0 @@
-package com.path.android.jobqueue;
-
-import com.path.android.jobqueue.log.JqLog;
-
-import java.util.Collections;
-import java.util.Set;
-
-/**
- * Container class to address Jobs inside job manager.
- */
-public class JobHolder {
-
-    /**
-     * Internal constant. Job's onRun method completed w/o any exception.
-     */
-    public static final int RUN_RESULT_SUCCESS = 1;
-    /**
-     * Internal constant. Job's onRun method thrown an exception and either it does not want to
-     * run again or reached retry limit.
-     */
-    public static final int RUN_RESULT_FAIL_RUN_LIMIT = 2;
-
-    /**
-     * Internal constant. Job's onRun method has thrown an exception and it was cancelled after it
-     * started.
-     */
-    public static final int RUN_RESULT_FAIL_FOR_CANCEL = 3;
-    /**
-     * Internal constant. Job's onRun method failed but wants to retry.
-     */
-    public static final int RUN_RESULT_TRY_AGAIN = 4;
-
-    /**
-     * The job decided not to run in shouldReRun method.
-     */
-    public static final int RUN_RESULT_FAIL_SHOULD_RE_RUN = 5;
-
-    protected Long id;
-    protected int priority;
-    protected String groupId;
-    protected int runCount;
-    /**
-     * job will be delayed until this nanotime
-     */
-    protected long delayUntilNs;
-    /**
-     * When job is created, System.nanoTime() is assigned to {@code createdNs} value so that we know when job is created
-     * in relation to others
-     */
-    protected long createdNs;
-    protected long runningSessionId;
-    protected boolean requiresNetwork;
-    transient Job job;
-    protected final Set<String> tags;
-    private boolean cancelled;
-    private boolean successful;
-
-    /**
-     * @param id               Unique ID for the job. Should be unique per queue
-     * @param priority         Higher is better
-     * @param groupId          which group does this job belong to? default null
-     * @param runCount         Incremented each time job is fetched to run, initial value should be 0
-     * @param job              Actual job to run
-     * @param createdNs        System.nanotime
-     * @param delayUntilNs     System.nanotime value where job can be run the very first time
-     * @param runningSessionId
-     */
-    public JobHolder(Long id, int priority, String groupId, int runCount, Job job, long createdNs, long delayUntilNs, long runningSessionId) {
-        this.id = id;
-        this.priority = priority;
-        this.groupId = groupId;
-        this.runCount = runCount;
-        this.createdNs = createdNs;
-        this.delayUntilNs = delayUntilNs;
-        this.job = job;
-        job.priority = priority;
-        this.runningSessionId = runningSessionId;
-        this.requiresNetwork = job.requiresNetwork();
-        this.tags = job.getTags() == null ? null : Collections.unmodifiableSet(job.getTags());
-    }
-
-    public JobHolder(int priority, Job job, long runningSessionId) {
-        this(null, priority, null, 0, job, System.nanoTime(), Long.MIN_VALUE, runningSessionId);
-    }
-
-    public JobHolder(int priority, Job job, long delayUntilNs, long runningSessionId) {
-        this(null, priority, job.getRunGroupId(), 0, job, System.nanoTime(), delayUntilNs, runningSessionId);
-    }
-
-    /**
-     * runs the job w/o throwing any exceptions
-     * @param currentRunCount
-     * @return RUN_RESULT*
-     */
-    public final int safeRun(int currentRunCount) {
-        return job.safeRun(this, currentRunCount);
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    public boolean requiresNetwork() {
-        return requiresNetwork;
-    }
-
-    public int getPriority() {
-        return priority;
-    }
-
-    public void setPriority(int priority) {
-        this.priority = priority;
-        this.job.priority = this.priority;
-    }
-
-    void setDelayUntilNs(long delayUntilNs) {
-        this.delayUntilNs = delayUntilNs;
-    }
-
-    public int getRunCount() {
-        return runCount;
-    }
-
-    public void setRunCount(int runCount) {
-        this.runCount = runCount;
-    }
-
-    public long getCreatedNs() {
-        return createdNs;
-    }
-
-    public void setCreatedNs(long createdNs) {
-        this.createdNs = createdNs;
-    }
-
-    public long getRunningSessionId() {
-        return runningSessionId;
-    }
-
-    public void setRunningSessionId(long runningSessionId) {
-        this.runningSessionId = runningSessionId;
-    }
-
-    public long getDelayUntilNs() {
-        return delayUntilNs;
-    }
-
-    public Job getJob() {
-        return job;
-    }
-
-    public void setJob(Job job) {
-        this.job = job;
-    }
-
-    public String getGroupId() {
-        return groupId;
-    }
-
-    public Set<String> getTags() {
-        return tags;
-    }
-
-    public void markAsCancelled() {
-        cancelled = true;
-        job.cancelled = true;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public int hashCode() {
-        //we don't really care about overflow.
-        if(id == null) {
-            return super.hashCode();
-        }
-        return id.intValue();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if(o instanceof JobHolder == false) {
-            return false;
-        }
-        JobHolder other = (JobHolder) o;
-        if(id == null || other.id == null) {
-            return false;
-        }
-        return id.equals(other.id);
-    }
-
-    public boolean hasTags() {
-        return tags != null && tags.size() > 0;
-    }
-
-    public synchronized void markAsSuccessful() {
-        successful = true;
-    }
-
-    public synchronized boolean isSuccessful() {
-        return successful;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
deleted file mode 100644
index 0137bcd..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ /dev/null
@@ -1,852 +0,0 @@
-package com.path.android.jobqueue;
-
-import android.content.Context;
-
-import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
-import com.path.android.jobqueue.callback.JobManagerCallback;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.di.DependencyInjector;
-import com.path.android.jobqueue.executor.JobConsumerExecutor;
-import com.path.android.jobqueue.log.JqLog;
-import com.path.android.jobqueue.network.NetworkEventProvider;
-import com.path.android.jobqueue.network.NetworkUtil;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqlHelper;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.*;
-
-/**
- * a JobManager that supports;
- * -> Persistent / Non Persistent Jobs
- * -> Job Priority
- * -> Running Jobs in Parallel
- * -> Grouping jobs so that they won't run at the same time
- * -> Stats like waiting Job Count
- */
-public class JobManager implements NetworkEventProvider.Listener {
-    public static final long NS_PER_MS = 1000000;
-    public static final long NOT_RUNNING_SESSION_ID = Long.MIN_VALUE;
-    public static final long NOT_DELAYED_JOB_DELAY = Long.MIN_VALUE;
-    @SuppressWarnings("FieldCanBeLocal")//used for testing
-    private final long sessionId;
-    private volatile boolean running;
-
-    private final Context appContext;
-    private final NetworkUtil networkUtil;
-    private final DependencyInjector dependencyInjector;
-    private final JobQueue persistentJobQueue;
-    private final JobQueue nonPersistentJobQueue;
-    private final RunningJobSet runningJobGroups;
-    private final JobConsumerExecutor jobConsumerExecutor;
-    private final Object newJobListeners = new Object();
-    private final ConcurrentHashMap<Long, CountDownLatch> persistentOnAddedLocks;
-    private final ConcurrentHashMap<Long, CountDownLatch> nonPersistentOnAddedLocks;
-    private ScheduledExecutorService timedExecutor;
-    // lazily created
-    private final Object cancelExecutorInitLock = new Object();
-    private ExecutorService cancelExecutor;
-    private final Object getNextJobLock = new Object();
-    private final CopyOnWriteArrayList<JobManagerCallback> callbacks = new CopyOnWriteArrayList<>();
-
-
-    /**
-     * Default constructor that will create a JobManager with 1 {@link SqliteJobQueue} and 1 {@link NonPersistentPriorityQueue}
-     * @param context job manager will use applicationContext.
-     */
-    public JobManager(Context context) {
-        this(context, "default");
-    }
-
-
-    /**
-     * Default constructor that will create a JobManager with a default {@link Configuration}
-     * @param context application context
-     * @param id an id that is unique to this JobManager
-     */
-    public JobManager(Context context, String id) {
-        this(context, new Configuration.Builder(context).id(id).build());
-    }
-
-    /**
-     *
-     * @param context used to acquire ApplicationContext
-     * @param config
-     */
-    public JobManager(Context context, Configuration config) {
-        if(config.getCustomLogger() != null) {
-            JqLog.setCustomLogger(config.getCustomLogger());
-        }
-        appContext = context.getApplicationContext();
-        running = true;
-        runningJobGroups = new RunningJobSet();
-        sessionId = System.nanoTime();
-        this.persistentJobQueue = config.getQueueFactory()
-                .createPersistentQueue(context, sessionId, config.getId(), config.isInTestMode());
-        this.nonPersistentJobQueue = config.getQueueFactory()
-                .createNonPersistent(context, sessionId, config.getId(), config.isInTestMode());
-        persistentOnAddedLocks = new ConcurrentHashMap<Long, CountDownLatch>();
-        nonPersistentOnAddedLocks = new ConcurrentHashMap<Long, CountDownLatch>();
-
-        networkUtil = config.getNetworkUtil();
-        dependencyInjector = config.getDependencyInjector();
-        if(networkUtil instanceof NetworkEventProvider) {
-            ((NetworkEventProvider) networkUtil).setListener(this);
-        }
-        //is important to initialize consumers last so that they can start running
-        jobConsumerExecutor = new JobConsumerExecutor(config,consumerContract);
-        timedExecutor = Executors.newSingleThreadScheduledExecutor();
-        start();
-    }
-
-
-    /**
-     * Stops consuming jobs. Currently running jobs will be finished but no new jobs will be run.
-     */
-    public void stop() {
-        running = false;
-    }
-
-    /**
-     * restarts the JobManager. Will create a new consumer if necessary.
-     */
-    public void start() {
-        if(running) {
-            return;
-        }
-        running = true;
-        notifyJobConsumer();
-    }
-
-    public void addCallback(JobManagerCallback callback) {
-        callbacks.add(callback);
-    }
-
-    public boolean removeCallback(JobManagerCallback callback) {
-        return callbacks.remove(callback);
-    }
-
-    /**
-     * returns the # of jobs that are waiting to be executed.
-     * This might be a good place to decide whether you should wake your app up on boot etc. to complete pending jobs.
-     * @return # of total jobs.
-     */
-    public int count() {
-        int cnt = 0;
-        synchronized (nonPersistentJobQueue) {
-            cnt += nonPersistentJobQueue.count();
-        }
-        synchronized (persistentJobQueue) {
-            cnt += persistentJobQueue.count();
-        }
-        return cnt;
-    }
-
-    private int countReadyJobs(boolean hasNetwork) {
-        //TODO we can cache this
-        int total = 0;
-        synchronized (nonPersistentJobQueue) {
-            total += nonPersistentJobQueue.countReadyJobs(hasNetwork, runningJobGroups.getSafe());
-        }
-        synchronized (persistentJobQueue) {
-            total += persistentJobQueue.countReadyJobs(hasNetwork, runningJobGroups.getSafe());
-        }
-        return total;
-    }
-
-    /**
-     * Adds a new Job to the list and returns an ID for it.
-     * @param job to add
-     * @return id for the job.
-     */
-    public long addJob(Job job) {
-        //noinspection deprecation
-        JobHolder jobHolder = new JobHolder(job.getPriority(), job
-                , job.getDelayInMs() > 0 ? System.nanoTime() + job.getDelayInMs() * NS_PER_MS : NOT_DELAYED_JOB_DELAY
-                , NOT_RUNNING_SESSION_ID);
-        long id;
-        if (job.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                id = persistentJobQueue.insert(jobHolder);
-                addOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                id = nonPersistentJobQueue.insert(jobHolder);
-                addOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        if(JqLog.isDebugEnabled()) {
-            JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
-                    , id, job.getClass().getSimpleName(), job.getPriority(), job.getDelayInMs(), job.getRunGroupId()
-                    , job.isPersistent(), job.requiresNetwork());
-        }
-        if(dependencyInjector != null) {
-            //inject members b4 calling onAdded
-            dependencyInjector.inject(job);
-        }
-        jobHolder.getJob().setApplicationContext(appContext);
-        callOnAddedAndNotifyListeners(jobHolder);
-
-        if(job.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                clearOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                clearOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        ensureConsumerWhenNeeded(null);
-        return id;
-    }
-
-    /**
-     * Cancels all jobs matching the list of tags.
-     * <p>
-     * Note that, if any of the matching jobs is running, this method WILL wait for them to finish
-     * or fail.
-     * <p>
-     * This method uses a separate single threaded executor pool just for cancelling jobs
-     * because it may potentially wait for a long running job (if query matches that job). This
-     * pool is lazily created when the very first cancel request arrives.
-     * <p>
-     * A job may be already running when cancelJob is called. In this case, JobManager will wait
-     * until job fails or ends before returning from this method. If jobs succeeds before
-     * JobManager can cancel it, it will be added into {@link CancelResult#getFailedToCancel()}
-     * list.
-     * <p>
-     * If you call {@link #addJob(Job)} while {@link #cancelJobs(TagConstraint, String...)} is
-     * running, the behavior of that job will be undefined. If that jobs gets added to the queue
-     * before cancel query runs, it may be cancelled before running. It is up to you to sync these
-     * two requests if such cases may happen for you.
-     * <p/>
-     * This query is not atomic. If application terminates while jobs are being cancelled, some of
-     * them may be cancelled while some remain in the queue (for persistent jobs).
-     * <p/>
-     * This method guarantees calling {@link Job#onCancel()} before job is removed
-     * from the queue. If application terminates while {@link Job#onCancel()} is running, the
-     * Job will not be removed from disk (same behavior with jobs failing due to other reasons like
-     * hitting retry limit).
-     *
-     * @param constraint The constraint to use while selecting jobs. If set to {@link TagConstraint#ANY},
-     *                   any job that has one of the given tags will be cancelled. If set to
-     *                   {@link TagConstraint#ALL}, jobs that has all of the given tags will be cancelled.
-     * @param tags The list of tags
-     */
-    public void cancelJobsInBackground(final CancelResult.AsyncCancelCallback cancelCallback,
-            final TagConstraint constraint, final String... tags) {
-        synchronized (cancelExecutorInitLock) {
-            if (cancelExecutor == null) {
-                cancelExecutor = Executors.newSingleThreadExecutor();
-            }
-            cancelExecutor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    CancelResult result = cancelJobs(constraint, tags);
-                    if (cancelCallback != null) {
-                        cancelCallback.onCancelled(result);
-                    }
-                }
-            });
-        }
-    }
-
-    /**
-     * Cancel all jobs matching the list of tags.
-     * <p>
-     * Note that, you should NOT call this method on main thread because it queries database and
-     * may also need to wait for running jobs to finish.
-     * <p>
-     * A job may be already running when cancelJob is called. In this case, JobManager will wait
-     * until job fails or ends before returning from this method. If jobs succeeds before
-     * JobManager can cancel it, it will be added into {@link CancelResult#getFailedToCancel()}
-     * list.
-     * <p>
-     * If you call {@link #addJob(Job)} while {@link #cancelJobs(TagConstraint, String...)} is
-     * running, the behavior of that job will be undefined. If that jobs gets added to the queue
-     * before cancel query runs, it may be cancelled before running. It is up to you to sync these
-     * two requests if such cases may happen for you.
-     * <p/>
-     * This query is not atomic. If application terminates while jobs are being cancelled, some of
-     * them may be cancelled while some remain in the queue (for persistent jobs).
-     * <p/>
-     * This method guarantees calling {@link Job#onCancel()} before job is removed
-     * from the queue. If application terminates while {@link Job#onCancel()} is running, the
-     * Job will not be removed from disk (same behavior with jobs failing due to other reasons like
-     * hitting retry limit).
-     *
-     * @param constraint The constraint to use while selecting jobs. If set to {@link TagConstraint#ANY},
-     *                   any job that has one of the given tags will be cancelled. If set to
-     *                   {@link TagConstraint#ALL}, jobs that has all of the given tags will be cancelled.
-     * @param tags       The list of tags
-     * @return A Cancel result containing the list of jobs.
-     * @see #cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
-     */
-    public CancelResult cancelJobs(final TagConstraint constraint, final String... tags) {
-        final List<JobHolder> jobs = new ArrayList<JobHolder>();
-        final Set<Long> persistentJobIds = new HashSet<Long>();
-        final Set<Long> nonPersistentJobIds = new HashSet<Long>();
-        final Set<Long> runningNonPersistentJobIds = new HashSet<>();
-        final Set<Long> runningPersistentJobIds = new HashSet<>();
-        synchronized (getNextJobLock) {
-            jobConsumerExecutor.inRunningJobHoldersLock(new Runnable() {
-                @Override
-                public void run() {
-                    // TODO if app terminates while cancelling, job will be removed w/o receiving an onCancel call!!!
-                    Set<JobHolder> nonPersistentRunningJobs = jobConsumerExecutor
-                            .findRunningByTags(constraint, tags, false);
-                    synchronized (nonPersistentJobQueue) {
-                        markJobsAsCancelledAndFilterAlreadyCancelled(nonPersistentRunningJobs,
-                                nonPersistentJobQueue, nonPersistentJobIds);
-                        runningNonPersistentJobIds.addAll(nonPersistentJobIds);
-                        Set<JobHolder> nonPersistentJobs = nonPersistentJobQueue
-                                .findJobsByTags(constraint, true, nonPersistentJobIds, tags);
-                        markJobsAsCancelledAndFilterAlreadyCancelled(nonPersistentJobs,
-                                nonPersistentJobQueue, nonPersistentJobIds);
-                        jobs.addAll(nonPersistentJobs);
-                    }
-                    jobs.addAll(nonPersistentRunningJobs);
-
-                    Set<JobHolder> persistentRunningJobs = jobConsumerExecutor
-                            .findRunningByTags(constraint, tags, true);
-                    synchronized (persistentJobQueue) {
-                        markJobsAsCancelledAndFilterAlreadyCancelled(persistentRunningJobs,
-                                persistentJobQueue, persistentJobIds);
-                        runningPersistentJobIds.addAll(persistentJobIds);
-                        Set<JobHolder> persistentJobs = persistentJobQueue
-                                .findJobsByTags(constraint, true, persistentJobIds, tags);
-                        markJobsAsCancelledAndFilterAlreadyCancelled(persistentJobs,
-                                persistentJobQueue, persistentJobIds);
-                        jobs.addAll(persistentJobs);
-                    }
-                    jobs.addAll(persistentRunningJobs);
-                }
-            });
-        }
-
-        try {
-            // non persistent jobs are removed from queue as soon as they are marked as cancelled
-            // persistent jobs are given a running session id upon cancellation.
-            // this ensures that these jobs won't show up in next job queries.
-            // if subsequent cancel requests come for these jobs, they won't show up again either
-            // because markJobsAsCancelledAndFilterAlreadyCancelled will filter them out
-            jobConsumerExecutor.waitUntilDone(persistentJobIds, nonPersistentJobIds);
-        } catch (InterruptedException e) {
-            JqLog.e(e, "error while waiting for jobs to finish");
-        }
-        CancelResult result = new CancelResult();
-        for (JobHolder holder : jobs) {
-            JqLog.d("checking if I could cancel %s. Result: %s", holder.getJob(), !holder.isSuccessful());
-            if (holder.isSuccessful()) {
-                result.failedToCancel.add(holder.getJob());
-            } else {
-                result.cancelledJobs.add(holder.getJob());
-                try {
-                    callOnCancelAndNotifyListeners(holder, true);
-                } catch (Throwable t) {
-                    JqLog.e(t, "cancelled job's onCancel has thrown exception");
-                }
-                // if job is removed while running, make sure we remove it from running job
-                // groups as well. JobExecutor won't remove the job.
-                if (holder.getJob().isPersistent()) {
-                    synchronized (persistentJobQueue) {
-                        persistentJobQueue.remove(holder);
-                    }
-                    if (holder.getGroupId() != null &&
-                            runningPersistentJobIds.contains(holder.getId())) {
-                        runningJobGroups.remove(holder.getGroupId());
-                    }
-                } else if (holder.getGroupId() != null &&
-                        runningNonPersistentJobIds.contains(holder.getId())) {
-                    runningJobGroups.remove(holder.getGroupId());
-                }
-            }
-        }
-        return result;
-    }
-
-    private void markJobsAsCancelledAndFilterAlreadyCancelled(Set<JobHolder> jobs, JobQueue queue,
-            Set<Long> outIds) {
-        Iterator<JobHolder> itr = jobs.iterator();
-        while (itr.hasNext()) {
-            JobHolder holder = itr.next();
-            // although cancelled is not persistent to disk, this will still work because we would
-            // receive the same job back if it was just cancelled in this session.
-            if (holder.isCancelled()) {
-                itr.remove();
-            } else {
-                holder.markAsCancelled();
-                outIds.add(holder.getId());
-                queue.onJobCancelled(holder);
-            }
-        }
-    }
-
-    /**
-     * Non-blocking convenience method to add a job in background thread.
-     * @see #addJob(Job)
-     * @param job job to add
-     *
-     */
-    public void addJobInBackground(Job job) {
-        //noinspection deprecation
-        addJobInBackground(job, null);
-    }
-
-    public void addJobInBackground(final Job job, /*nullable*/ final AsyncAddCallback callback) {
-        timedExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    long id = addJob(job);
-                    if (callback != null) {
-                        callback.onAdded(id);
-                    }
-                } catch (Throwable t) {
-                    JqLog.e(t, "addJobInBackground received an exception. job class: %s",
-                            job.getClass().getSimpleName());
-                }
-            }
-        });
-    }
-
-    //need to sync on related job queue before calling this
-    private void addOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, long id) {
-        lockMap.put(id, new CountDownLatch(1));
-    }
-
-    //need to sync on related job queue before calling this
-    private void waitForOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, long id) {
-        CountDownLatch latch = lockMap.get(id);
-        if(latch == null) {
-            return;
-        }
-        try {
-            latch.await();
-        } catch (InterruptedException e) {
-            JqLog.e(e, "could not wait for onAdded lock");
-        }
-    }
-
-    //need to sync on related job queue before calling this
-    private void clearOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, long id) {
-        CountDownLatch latch = lockMap.get(id);
-        if(latch != null) {
-            latch.countDown();
-        }
-        lockMap.remove(id);
-    }
-
-    /**
-     * checks next available job and returns when it will be available (if it will, otherwise returns {@link Long#MAX_VALUE})
-     * also creates a timer to notify listeners at that time
-     * @param hasNetwork .
-     * @return time wait until next job (in milliseconds)
-     */
-    private long ensureConsumerWhenNeeded(Boolean hasNetwork) {
-        if(hasNetwork == null) {
-            //if network util can inform us when network is recovered, we we'll check only next job that does not
-            //require network. if it does not know how to inform us, we have to keep a busy loop.
-            //noinspection SimplifiableConditionalExpression
-            hasNetwork = networkUtil instanceof NetworkEventProvider ? hasNetwork() : true;
-        }
-        //this method is called when there are jobs but job consumer was not given any
-        //this may happen in a race condition or when the latest job is a delayed job
-        Long nextRunNs = runningJobGroups.getNextDelayForGroups();
-        Collection<String> runningGroups = runningJobGroups.getSafe();
-        Long nonPersistedJobRunNs;
-        synchronized (nonPersistentJobQueue) {
-            nonPersistedJobRunNs = nonPersistentJobQueue.getNextJobDelayUntilNs(hasNetwork, runningGroups);
-        }
-        if (nextRunNs == null || (nonPersistedJobRunNs != null && nonPersistedJobRunNs < nextRunNs)) {
-            nextRunNs = nonPersistedJobRunNs;
-        }
-        if(nextRunNs != null && nextRunNs <= System.nanoTime()) {
-            notifyJobConsumer();
-            return 0L;
-        }
-        Long persistedJobRunNs;
-        synchronized (persistentJobQueue) {
-            persistedJobRunNs = persistentJobQueue.getNextJobDelayUntilNs(hasNetwork, runningGroups);
-        }
-        if(persistedJobRunNs != null) {
-            if(nextRunNs == null) {
-                nextRunNs = persistedJobRunNs;
-            } else if(persistedJobRunNs < nextRunNs) {
-                nextRunNs = persistedJobRunNs;
-            }
-        }
-        if(nextRunNs != null) {
-            //to avoid overflow, we need to check equality first
-            if(nextRunNs < System.nanoTime()) {
-                notifyJobConsumer();
-                return 0L;
-            }
-            long diff = (long)Math.ceil((double)(nextRunNs - System.nanoTime()) / NS_PER_MS);
-            ensureConsumerOnTime(diff);
-            return diff;
-        }
-        return Long.MAX_VALUE;
-    }
-
-    private void notifyJobConsumer() {
-        synchronized (newJobListeners) {
-            newJobListeners.notifyAll();
-        }
-        jobConsumerExecutor.considerAddingConsumer();
-    }
-
-    private final Runnable notifyRunnable = new Runnable() {
-        @Override
-        public void run() {
-            notifyJobConsumer();
-        }
-    };
-
-    private void ensureConsumerOnTime(long waitMs) {
-        timedExecutor.schedule(notifyRunnable, waitMs, TimeUnit.MILLISECONDS);
-    }
-
-    private boolean hasNetwork() {
-        return networkUtil == null || networkUtil.isConnected(appContext);
-    }
-
-    private JobHolder getNextJob() {
-        boolean haveNetwork = hasNetwork();
-        JobHolder jobHolder;
-        boolean persistent = false;
-        JqLog.d("looking for next job");
-        synchronized (getNextJobLock) {
-            final Collection<String> runningJobGroups = this.runningJobGroups.getSafe();
-            if (JqLog.isDebugEnabled()) {
-                JqLog.d("running groups %s", SqlHelper.joinStrings(",", runningJobGroups));
-            }
-            synchronized (nonPersistentJobQueue) {
-                jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
-            }
-            JqLog.d("non persistent result %s", jobHolder);
-            if (jobHolder == null) {
-                //go to disk, there aren't any non-persistent jobs
-                synchronized (persistentJobQueue) {
-                    jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups);
-                    persistent = true;
-                }
-                JqLog.d("persistent result %s", jobHolder);
-            }
-            if(jobHolder == null) {
-                return null;
-            }
-            if(persistent && dependencyInjector != null) {
-                dependencyInjector.inject(jobHolder.getJob());
-            }
-            if(jobHolder.getGroupId() != null) {
-                this.runningJobGroups.add(jobHolder.getGroupId());
-            }
-        }
-
-        //wait for onAdded locks. wait for locks after job is selected so that we minimize the lock
-        if(persistent) {
-            waitForOnAddedLock(persistentOnAddedLocks, jobHolder.getId());
-        } else {
-            waitForOnAddedLock(nonPersistentOnAddedLocks, jobHolder.getId());
-        }
-        jobHolder.getJob().setApplicationContext(appContext);
-        return jobHolder;
-    }
-
-    private void reAddJob(JobHolder jobHolder) {
-        JqLog.d("re-adding job %s", jobHolder.getId());
-        if (!jobHolder.isCancelled()) {
-            if (jobHolder.getJob().isPersistent()) {
-                synchronized (persistentJobQueue) {
-                    persistentJobQueue.insertOrReplace(jobHolder);
-                }
-            } else {
-                synchronized (nonPersistentJobQueue) {
-                    nonPersistentJobQueue.insertOrReplace(jobHolder);
-                }
-            }
-        } else {
-            JqLog.d("not re-adding cancelled job " + jobHolder);
-        }
-        if(jobHolder.getGroupId() != null) {
-            runningJobGroups.remove(jobHolder.getGroupId());
-        }
-    }
-
-    /**
-     * Returns the current status of a {@link Job}.
-     * <p>
-     *     You should not call this method on the UI thread because it may make a db request.
-     * </p>
-     * <p>
-     *     This is not a very fast call so try not to make it unless necessary. Consider using events if you need to be
-     *     informed about a job's lifecycle.
-     * </p>
-     * @param id the ID, returned by the addJob method
-     * @param isPersistent Jobs are added to different queues depending on if they are persistent or not. This is necessary
-     *                     because each queue has independent id sets.
-     * @return
-     */
-    public JobStatus getJobStatus(long id, boolean isPersistent) {
-        if(jobConsumerExecutor.isRunning(id, isPersistent)) {
-            return JobStatus.RUNNING;
-        }
-        JobHolder holder;
-        if(isPersistent) {
-            synchronized (persistentJobQueue) {
-                holder = persistentJobQueue.findJobById(id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                holder = nonPersistentJobQueue.findJobById(id);
-            }
-        }
-        if(holder == null) {
-            return JobStatus.UNKNOWN;
-        }
-        boolean network = hasNetwork();
-        if(holder.requiresNetwork() && !network) {
-            return JobStatus.WAITING_NOT_READY;
-        }
-        if(holder.getDelayUntilNs() > System.nanoTime()) {
-            return JobStatus.WAITING_NOT_READY;
-        }
-
-        return JobStatus.WAITING_READY;
-    }
-
-    private void removeJob(JobHolder jobHolder) {
-        if (jobHolder.getJob().isPersistent()) {
-            synchronized (persistentJobQueue) {
-                persistentJobQueue.remove(jobHolder);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                nonPersistentJobQueue.remove(jobHolder);
-            }
-        }
-        if(jobHolder.getGroupId() != null) {
-            runningJobGroups.remove(jobHolder.getGroupId());
-        }
-    }
-
-    public synchronized void stopAndWaitUntilConsumersAreFinished() throws InterruptedException {
-        synchronized (newJobListeners) {
-            newJobListeners.notifyAll();
-        }
-        stop();
-        jobConsumerExecutor.waitUntilAllConsumersAreFinished();
-        timedExecutor.shutdown();
-        timedExecutor.awaitTermination(100, TimeUnit.SECONDS);
-        timedExecutor = Executors.newSingleThreadScheduledExecutor();
-        synchronized (cancelExecutorInitLock) {
-            if (cancelExecutor != null) {
-                cancelExecutor.shutdown();
-                cancelExecutor.awaitTermination(100, TimeUnit.SECONDS);
-            }
-            cancelExecutor = Executors.newSingleThreadExecutor();
-        }
-    }
-
-    public synchronized void clear() {
-        synchronized (nonPersistentJobQueue) {
-            nonPersistentJobQueue.clear();
-            nonPersistentOnAddedLocks.clear();
-        }
-        synchronized (persistentJobQueue) {
-            persistentJobQueue.clear();
-            persistentOnAddedLocks.clear();
-        }
-        runningJobGroups.clear();
-    }
-
-    /**
-     * if {@link NetworkUtil} implements {@link NetworkEventProvider}, this method is called when network is recovered
-     * @param isConnected network connection state.
-     */
-    @Override
-    public void onNetworkChange(boolean isConnected) {
-        ensureConsumerWhenNeeded(isConnected);
-    }
-
-    private void callOnCancelAndNotifyListeners(JobHolder jobHolder, boolean byCancelRequest) {
-        try {
-            jobHolder.job.onCancel();
-        } catch (Throwable t) {
-            JqLog.e(t, "job's onCancel did throw an exception, ignoring...");
-        }
-        for (JobManagerCallback callback : callbacks) {
-            try {
-                callback.onJobCancelled(jobHolder.job, byCancelRequest);
-            } catch (Throwable t){}
-        }
-    }
-
-    private void notifyOnRunListeners(JobHolder jobHolder, int resultCode) {
-        for (JobManagerCallback callback : callbacks) {
-            try {
-                callback.onJobRun(jobHolder.job, resultCode);
-            } catch (Throwable t){}
-        }
-    }
-
-    private void callOnAddedAndNotifyListeners(JobHolder jobHolder) {
-        try {
-            jobHolder.job.onAdded();
-        } catch (Throwable t) {
-            JqLog.e(t, "job's onAdded did throw an exception, ignoring...");
-        }
-        for (JobManagerCallback callback : callbacks) {
-            try {
-                callback.onJobAdded(jobHolder.job);
-            } catch (Throwable t){}
-        }
-    }
-
-    @SuppressWarnings("FieldCanBeLocal")
-    private final JobConsumerExecutor.Contract consumerContract = new JobConsumerExecutor.Contract() {
-        @Override
-        public boolean isRunning() {
-            return running;
-        }
-
-        @Override
-        public void insertOrReplace(JobHolder jobHolder) {
-            RetryConstraint retryConstraint = jobHolder.getJob().retryConstraint;
-            if (retryConstraint == null) {
-                reAddJob(jobHolder);
-                return;
-            }
-            if (retryConstraint.getNewPriority() != null) {
-                jobHolder.setPriority(retryConstraint.getNewPriority());
-            }
-            long delay = -1;
-            if (retryConstraint.getNewDelayInMs() != null) {
-                if (retryConstraint.willApplyNewDelayToGroup() && jobHolder.getGroupId() != null) {
-                    runningJobGroups.addGroupUntil(jobHolder.getGroupId(),
-                            System.nanoTime() + retryConstraint.getNewDelayInMs() * NS_PER_MS);
-                } else {
-                    delay = retryConstraint.getNewDelayInMs();
-                }
-            }
-            jobHolder.setDelayUntilNs(
-                    delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY
-            );
-            reAddJob(jobHolder);
-        }
-
-        @Override
-        public void removeJob(JobHolder jobHolder) {
-            JobManager.this.removeJob(jobHolder);
-        }
-
-        @Override
-        public JobHolder getNextJob(int wait, TimeUnit waitDuration) {
-            //be optimistic
-            JobHolder nextJob = JobManager.this.getNextJob();
-            if(nextJob != null) {
-                return nextJob;
-            }
-            long start = System.nanoTime();
-            long remainingWait = waitDuration.toNanos(wait);
-            long waitUntil = remainingWait + start;
-            //for delayed jobs,
-            long nextJobDelay = ensureConsumerWhenNeeded(null);
-            while (nextJob == null && waitUntil > System.nanoTime() && running) {
-                //keep running inside here to avoid busy loop
-                nextJob = running ? JobManager.this.getNextJob() : null;
-                if(nextJob == null) {
-                    long remaining = waitUntil - System.nanoTime();
-                    if(remaining > 0) {
-                        //if we can't detect network changes, we won't be notified.
-                        //to avoid waiting up to give time, wait in chunks of 500 ms max
-                        long maxWait = Math.min(nextJobDelay, TimeUnit.NANOSECONDS.toMillis(remaining));
-                        if(maxWait < 1 || !running) {
-                            continue;//wait(0) will cause infinite wait.
-                        }
-                        if(networkUtil instanceof NetworkEventProvider) {
-                            //to handle delayed jobs, make sure we trigger this first
-                            //looks like there is no job available right now, wait for an event.
-                            //there is a chance that if it triggers a timer and it gets called before I enter
-                            //sync block, i am going to lose it
-                            //TODO fix above case where we may wait unnecessarily long if a job is about to become available
-                            synchronized (newJobListeners) {
-                                try {
-                                    newJobListeners.wait(maxWait);
-                                } catch (InterruptedException e) {
-                                    JqLog.e(e, "exception while waiting for a new job.");
-                                }
-                            }
-                        } else {
-                            //we cannot detect network changes. our best option is to wait for some time and try again
-                            //then trigger {@link ensureConsumerWhenNeeded)
-                            synchronized (newJobListeners) {
-                                try {
-                                    newJobListeners.wait(Math.min(500, maxWait));
-                                } catch (InterruptedException e) {
-                                    JqLog.e(e, "exception while waiting for a new job.");
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            return nextJob;
-        }
-
-        @Override
-        public int countRemainingReadyJobs() {
-            //if we can't detect network changes, assume we have network otherwise nothing will trigger a consumer
-            //noinspection SimplifiableConditionalExpression
-            return countReadyJobs(networkUtil instanceof NetworkEventProvider ? hasNetwork() : true);
-        }
-
-        @Override
-        public void callJobCancel(JobHolder jobHolder, boolean byCancelRequest) {
-            JobManager.this.callOnCancelAndNotifyListeners(jobHolder, byCancelRequest);
-        }
-
-        @Override
-        public void notifyJobRun(JobHolder jobHolder, int result) {
-            JobManager.this.notifyOnRunListeners(jobHolder, result);
-        }
-    };
-
-
-    /**
-     * Default implementation of QueueFactory that creates one {@link SqliteJobQueue} and one {@link NonPersistentPriorityQueue}
-     * both are wrapped inside a {@link CachedJobQueue} to improve performance
-     */
-    public static class DefaultQueueFactory implements QueueFactory {
-        SqliteJobQueue.JobSerializer jobSerializer;
-
-        public DefaultQueueFactory() {
-            jobSerializer = new SqliteJobQueue.JavaSerializer();
-        }
-
-        public DefaultQueueFactory(SqliteJobQueue.JobSerializer jobSerializer) {
-            this.jobSerializer = jobSerializer;
-        }
-
-        @Override
-        public JobQueue createPersistentQueue(Context context, Long sessionId, String id,
-                boolean inTestMode) {
-            return new CachedJobQueue(new SqliteJobQueue(context, sessionId, id, jobSerializer,
-                    inTestMode));
-        }
-
-        @Override
-        public JobQueue createNonPersistent(Context context, Long sessionId, String id,
-                boolean inTestMode) {
-            return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id, inTestMode));
-        }
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
deleted file mode 100755
index d3630bf..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobQueue.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package com.path.android.jobqueue;
-
-import java.util.Collection;
-import java.util.Set;
-
-/**
- * Interface that any JobQueue should implement
- * These job queues can be given to JobManager.
- */
-public interface JobQueue {
-    /**
-     * Inserts the given JobHolder,
-     *   assigns it a unique id
-     *   and returns the id back
-     *   Is called when a job is added
-     * @param jobHolder
-     * @return
-     */
-    long insert(JobHolder jobHolder);
-
-    /**
-     * Does the same thing with insert but the only difference is that
-     * if job has an ID, it should replace the existing one
-     *  should also reset running session id to {@link JobManager#NOT_RUNNING_SESSION_ID}
-     *  Is called when a job is re-added (due to exception during run)
-     * @param jobHolder
-     * @return
-     */
-    long insertOrReplace(JobHolder jobHolder);
-
-    /**
-     * Removes the job from the data store.
-     * Is called after a job is completed (or cancelled)
-     * @param jobHolder
-     */
-    void remove(JobHolder jobHolder);
-
-    /**
-     * Returns the # of jobs that are waiting to be run
-     * @return
-     */
-    int count();
-
-    /**
-     * counts the # of jobs that can run now. if there are more jobs from the same group, they are count as 1 since
-     * they cannot be run in parallel
-     * exclude groups are guaranteed to be ordered in natural order
-     * @return
-     */
-    int countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups);
-
-    /**
-     * Returns the next available job in the data set
-     * It should also assign the sessionId as the RunningSessionId and persist that data if necessary.
-     * It should filter out all running jobs and exclude groups are guaranteed to be ordered in natural order
-     *
-     * @param hasNetwork if true, should return any job, if false, should return jobs that do NOT require network
-     * @param excludeGroups if provided, jobs from these groups will NOT be returned
-     * @return
-     */
-    JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups);
-
-    /**
-     * returns when the next job should run (in nanoseconds), should return null if there are no jobs to run.
-     * @param hasNetwork if true, should return nanoseconds for any job, if false, should return nanoseconds for next
-     *                   job's delay until.
-     * @param excludeGroups if provided, jobs from these groups will NOT be considered
-     * @return
-     */
-    Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups);
-
-    /**
-     * clear all jobs in the queue. should probably be called when user logs out.
-     */
-    void clear();
-
-    /**
-     * returns the job with the given id if it exists in the queue
-     * @param id id of the job, returned by insert method
-     * @return JobHolder with the given id or null if it does not exists
-     */
-    JobHolder findJobById(long id);
-
-    /**
-     * Returns jobs that has the given tags.
-     *
-     * @param tagConstraint If set to {@link TagConstraint#ALL}, returned jobs should have all of
-     *                      the tags provided. If set to {@link TagConstraint#ANY}, returned jobs
-     *                      should have at least one of the provided tags
-     * @param excludeCancelled If true, cancelled jobs will not be returned. A job may be in cancelled
-     *                        state if a cancel request has arrived but it has not been removed from
-     *                        queue yet (e.g. still running).
-     * @param excludeIds Ids of jobs to ignore in the result
-     * @param tags The list of tags
-     */
-    Set<JobHolder> findJobsByTags(TagConstraint tagConstraint, boolean excludeCancelled,
-            Collection<Long> excludeIds, String... tags);
-
-    /**
-     * Called when a job is cancelled by the user.
-     * <p/>
-     * It is important to not return this job from queries anymore.
-     *
-     * @param holder The JobHolder that is being cancelled
-     */
-    void onJobCancelled(JobHolder holder);
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/Params.java b/jobqueue/src/main/java/com/path/android/jobqueue/Params.java
deleted file mode 100755
index f388971..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/Params.java
+++ /dev/null
@@ -1,163 +0,0 @@
-package com.path.android.jobqueue;
-
-import java.util.HashSet;
-
-/**
- * Job builder object to have a more readable design.
- * Methods can be chained to have more readable code.
- */
-public class Params {
-    private boolean requiresNetwork = false;
-    private String groupId = null;
-    private boolean persistent = false;
-    private int priority;
-    private long delayMs;
-    private HashSet<String> tags;
-
-    /**
-     *
-     * @param priority higher = better
-     */
-    public Params(int priority) {
-        this.priority = priority;
-    }
-
-    /**
-     * Sets the Job as requiring network
-     * @return this
-     */
-    public Params requireNetwork() {
-        requiresNetwork = true;
-        return this;
-    }
-
-    /**
-     * Sets the group id. Jobs in the same group are guaranteed to execute sequentially.
-     * @param groupId which group this job belongs (can be null of course)
-     * @return this
-     */
-    public Params groupBy(String groupId) {
-        this.groupId = groupId;
-        return this;
-    }
-
-    /**
-     * Marks the job as persistent. Make sure your job is serializable.
-     * @return this
-     */
-    public Params persist() {
-        this.persistent = true;
-        return this;
-    }
-
-    /**
-     * Delays the job in given ms.
-     * @param delayMs .
-     * @return this
-     */
-    public Params delayInMs(long delayMs) {
-        this.delayMs = delayMs;
-        return this;
-    }
-
-    /**
-     * convenience method to set network requirement
-     * @param requiresNetwork true|false
-     * @return this
-     */
-    public Params setRequiresNetwork(boolean requiresNetwork) {
-        this.requiresNetwork = requiresNetwork;
-        return this;
-    }
-
-    /**
-     * convenience method to set group id.
-     * @param groupId
-     * @return this
-     */
-    public Params setGroupId(String groupId) {
-        this.groupId = groupId;
-        return this;
-    }
-
-    /**
-     * convenience method to set whether {@link JobManager} should persist this job or not.
-     * @param persistent true|false
-     * @return this
-     */
-    public Params setPersistent(boolean persistent) {
-        this.persistent = persistent;
-        return this;
-    }
-
-    /**
-     * convenience method to set delay
-     * @param delayMs in ms
-     * @return this
-     */
-    public Params setDelayMs(long delayMs) {
-        this.delayMs = delayMs;
-        return this;
-    }
-
-    /**
-     * Attaches given tags to the Job.
-     * These are initially used for cancelling or querying jobs but usage will be extended
-     * @param newTags List of tags to add
-     * @return
-     */
-    public Params addTags(String... newTags) {
-        if(tags == null) {
-            tags = new HashSet<String>();
-        }
-        for(String tag : newTags) {
-            tags.add(tag);
-        }
-        return this;
-    }
-
-    /**
-     * Removes the given tags from the Job.
-     *
-     * @param oldTags List of tags to be removed
-     * @return
-     */
-    public Params removeTags(String... oldTags) {
-        if(tags == null) {
-            return this;
-        }
-        for(String tag : oldTags) {
-            tags.remove(tag);
-        }
-        return this;
-    }
-
-    public Params clearTags() {
-        tags = null;
-        return this;
-    }
-
-    public boolean doesRequireNetwork() {
-        return requiresNetwork;
-    }
-
-    public String getGroupId() {
-        return groupId;
-    }
-
-    public boolean isPersistent() {
-        return persistent;
-    }
-
-    public int getPriority() {
-        return priority;
-    }
-
-    public long getDelayMs() {
-        return delayMs;
-    }
-
-    public HashSet<String> getTags() {
-        return tags;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/QueueFactory.java b/jobqueue/src/main/java/com/path/android/jobqueue/QueueFactory.java
deleted file mode 100755
index bd6c981..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/QueueFactory.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.path.android.jobqueue;
-
-import android.content.Context;
-
-/**
- * Interface to supply custom {@link JobQueue}s for JobManager
- */
-public interface QueueFactory {
-    public JobQueue createPersistentQueue(Context context, Long sessionId, String id,
-            boolean inTestMode);
-    public JobQueue createNonPersistent(Context context, Long sessionId, String id,
-            boolean inTestMode);
-}
\ No newline at end of file
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/TagConstraint.java b/jobqueue/src/main/java/com/path/android/jobqueue/TagConstraint.java
deleted file mode 100755
index 0caa3b4..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/TagConstraint.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.path.android.jobqueue;
-
-public enum TagConstraint {
-    ALL,
-    ANY
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
deleted file mode 100644
index fcc7057..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package com.path.android.jobqueue.cachedQueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.TagConstraint;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.Set;
-
-/**
- * a class that implements {@link JobQueue} interface, wraps another {@link JobQueue} and caches
- * results to avoid unnecessary queries to wrapped JobQueue.
- * does very basic caching but should be sufficient for most of the repeated cases
- * element
- */
-public class CachedJobQueue implements JobQueue {
-    JobQueue delegate;
-    private Cache cache;
-
-    public CachedJobQueue(JobQueue delegate) {
-        this.delegate = delegate;
-        this.cache = new Cache();
-    }
-
-    @Override
-    public long insert(JobHolder jobHolder) {
-        cache.invalidateAll();
-        return delegate.insert(jobHolder);
-    }
-
-    @Override
-    public long insertOrReplace(JobHolder jobHolder) {
-        cache.invalidateAll();
-        return delegate.insertOrReplace(jobHolder);
-    }
-
-    @Override
-    public void remove(JobHolder jobHolder) {
-        cache.invalidateAll();
-        delegate.remove(jobHolder);
-    }
-
-    @Override
-    public int count() {
-        if(cache.count == null) {
-            cache.count = delegate.count();
-        }
-        return cache.count;
-    }
-
-    @Override
-    public int countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups) {
-        if(cache.count != null && cache.count < 1) {
-            //we know count is zero, why query?
-            return 0;
-        }
-        int count = delegate.countReadyJobs(hasNetwork, excludeGroups);
-        if(count == 0) {
-            //warm up cache if this is an empty queue case. if not, we are creating an unncessary query.
-            count();
-        }
-        return count;
-    }
-
-    @Override
-    public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups) {
-        if(cache.count != null && cache.count < 1) {
-            return null;//we know we are empty, no need for querying
-        }
-        JobHolder holder = delegate.nextJobAndIncRunCount(hasNetwork, excludeGroups);
-        //if holder is null, there is a good chance that there aren't any jobs in queue try to cache it by calling count
-        if(holder == null) {
-            //warm up empty state cache
-            count();
-        } else if(cache.count != null) {
-            //no need to invalidate cache for count
-            cache.count--;
-        }
-        return holder;
-    }
-
-    @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
-        if(cache.delayUntil == null) {
-            cache.delayUntil = new Cache.DelayUntil(hasNetwork,
-                    delegate.getNextJobDelayUntilNs(hasNetwork, excludeGroups), excludeGroups);
-        } else if(!cache.delayUntil.isValid(hasNetwork, excludeGroups)) {
-            cache.delayUntil.set(hasNetwork,
-                    delegate.getNextJobDelayUntilNs(hasNetwork, excludeGroups), excludeGroups);
-        }
-        return cache.delayUntil.value;
-    }
-
-    @Override
-    public void clear() {
-        cache.invalidateAll();
-        delegate.clear();
-    }
-
-    @Override
-    public Set<JobHolder> findJobsByTags(TagConstraint constraint, boolean excludeCancelled,
-            Collection<Long> exclude, String... tags) {
-        return delegate.findJobsByTags(constraint, excludeCancelled, exclude, tags);
-    }
-
-    @Override
-    public void onJobCancelled(JobHolder holder) {
-        delegate.onJobCancelled(holder);
-    }
-
-    @Override
-    public JobHolder findJobById(long id) {
-        return delegate.findJobById(id);
-    }
-
-    private static class Cache {
-        Integer count;
-        DelayUntil delayUntil;
-
-        public void invalidateAll() {
-            count = null;
-            delayUntil = null;
-        }
-
-        private static class DelayUntil {
-            //can be null, is OK
-            Long value;
-            boolean hasNetwork;
-            Collection<String> excludeGroups;
-
-            private DelayUntil(boolean hasNetwork, Long value, Collection<String> excludeGroups) {
-                this.value = value;
-                this.hasNetwork = hasNetwork;
-                this.excludeGroups = excludeGroups;
-            }
-
-            private boolean isValid(boolean hasNetwork, Collection<String> excludeGroups) {
-                return this.hasNetwork == hasNetwork && validateExcludes(excludeGroups);
-            }
-
-            private boolean validateExcludes(Collection<String> excludeGroups) {
-                if (this.excludeGroups == excludeGroups) {
-                    return true;
-                }
-                if (this.excludeGroups == null || excludeGroups == null) {
-                    return false;
-                }
-                if (this.excludeGroups.size() != excludeGroups.size()) {
-                    return false;
-                }
-                Iterator<String> itr1 = this.excludeGroups.iterator();
-                Iterator<String> itr2 = excludeGroups.iterator();
-                while (itr1.hasNext()) {
-                    if (!itr1.next().equals(itr2.next())) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-
-            public void set(boolean hasNetwork, Long value, Collection<String> excludeGroups) {
-                this.value = value;
-                this.hasNetwork = hasNetwork;
-                this.excludeGroups = excludeGroups;
-            }
-        }
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
deleted file mode 100644
index 91fef1e..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.path.android.jobqueue.callback;
-
-import com.path.android.jobqueue.Job;
-
-/**
- * An empty implementation of {@link JobManagerCallback}. You are advice to override this one
- * instead so that if new methods are added to the interface, your code won't break.
- */
-public class JobManagerCallbackAdapter implements JobManagerCallback {
-    @Override
-    public void onJobAdded(Job job) {
-
-    }
-
-    @Override
-    public void onJobRun(Job job, int resultCode) {
-
-    }
-
-    @Override
-    public void onJobCancelled(Job job, boolean byCancelRequest) {
-
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/config/Configuration.java b/jobqueue/src/main/java/com/path/android/jobqueue/config/Configuration.java
deleted file mode 100755
index d877ea0..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/config/Configuration.java
+++ /dev/null
@@ -1,217 +0,0 @@
-package com.path.android.jobqueue.config;
-
-import android.content.Context;
-import android.net.ConnectivityManager;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.QueueFactory;
-import com.path.android.jobqueue.di.DependencyInjector;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.network.NetworkUtil;
-import com.path.android.jobqueue.network.NetworkUtilImpl;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-
-/**
- * {@link com.path.android.jobqueue.JobManager} configuration object
- */
-public class Configuration {
-    public static final String DEFAULT_ID = "default_job_manager";
-    public static final int DEFAULT_THREAD_KEEP_ALIVE_SECONDS = 15;
-    public static final int DEFAULT_LOAD_FACTOR_PER_CONSUMER = 3;
-    public static final int MAX_CONSUMER_COUNT = 5;
-    public static final int MIN_CONSUMER_COUNT = 0;
-
-    private String id = DEFAULT_ID;
-    private int maxConsumerCount = MAX_CONSUMER_COUNT;
-    private int minConsumerCount = MIN_CONSUMER_COUNT;
-    private int consumerKeepAlive = DEFAULT_THREAD_KEEP_ALIVE_SECONDS;
-    private int loadFactor = DEFAULT_LOAD_FACTOR_PER_CONSUMER;
-    private QueueFactory queueFactory;
-    private DependencyInjector dependencyInjector;
-    private NetworkUtil networkUtil;
-    private CustomLogger customLogger;
-    private boolean inTestMode = false;
-
-    private Configuration(){
-        //use builder instead
-    }
-
-    public String getId() {
-        return id;
-    }
-
-    public QueueFactory getQueueFactory() {
-        return queueFactory;
-    }
-
-    public DependencyInjector getDependencyInjector() {
-        return dependencyInjector;
-    }
-
-    public int getConsumerKeepAlive() {
-        return consumerKeepAlive;
-    }
-
-    public NetworkUtil getNetworkUtil() {
-        return networkUtil;
-    }
-
-    public int getMaxConsumerCount() {
-        return maxConsumerCount;
-    }
-
-    public int getMinConsumerCount() {
-        return minConsumerCount;
-    }
-
-    public CustomLogger getCustomLogger() {
-        return customLogger;
-    }
-
-    public int getLoadFactor() {
-        return loadFactor;
-    }
-
-    public boolean isInTestMode() {
-        return inTestMode;
-    }
-
-    public static final class Builder {
-        private Configuration configuration;
-        private Context appContext;
-        public Builder(Context context) {
-            this.configuration = new Configuration();
-            appContext = context.getApplicationContext();
-        }
-
-        /**
-         * provide and ID for this job manager to be used while creating persistent queue. it is useful if you are going to
-         * create multiple instances of it.
-         * default id is {@value #DEFAULT_ID}
-         * @param id if you have multiple instances of job manager, you should provide an id to distinguish their persistent files.
-         */
-        public Builder id(String id) {
-            configuration.id = id;
-            return this;
-        }
-
-        /**
-         * When JobManager runs out of `ready` jobs, it will keep consumers alive for this duration. it defaults to {@value #DEFAULT_THREAD_KEEP_ALIVE_SECONDS}
-         * @param keepAlive in seconds
-         */
-        public Builder consumerKeepAlive(int keepAlive) {
-            configuration.consumerKeepAlive = keepAlive;
-            return this;
-        }
-
-        /**
-         * JobManager needs one persistent and one non-persistent {@link JobQueue} to function.
-         * By default, it will use {@link SqliteJobQueue} and {@link NonPersistentPriorityQueue}
-         * You can provide your own implementation if they don't fit your needs. Make sure it passes all tests in
-         * {@link JobQueueTestBase} to ensure it will work fine.
-         * @param queueFactory your custom queue factory.
-         */
-        public Builder queueFactory(QueueFactory queueFactory) {
-            if(configuration.queueFactory != null) {
-                throw new RuntimeException("already set a queue factory. This might happen if you've provided a custom " +
-                        "job serializer");
-            }
-            configuration.queueFactory = queueFactory;
-            return this;
-        }
-
-        /**
-         * convenient configuration to replace job serializer while using {@link SqliteJobQueue} queue for persistence.
-         * by default, it uses a {@link SqliteJobQueue.JavaSerializer} which will use default Java serialization.
-         * @param JobSerializer
-         * @return
-         */
-        public Builder jobSerializer(SqliteJobQueue.JobSerializer jobSerializer) {
-            configuration.queueFactory = new JobManager.DefaultQueueFactory(jobSerializer);
-            return this;
-        }
-
-        /**
-         * By default, Job Manager comes with a simple {@link NetworkUtilImpl} that queries {@link ConnectivityManager}
-         * to check if network connection exists. You can provide your own if you need a custom logic (e.g. check your
-         * server health etc).
-         */
-        public Builder networkUtil(NetworkUtil networkUtil) {
-            configuration.networkUtil = networkUtil;
-            return this;
-        }
-
-        /**
-         * JobManager is suitable for DependencyInjection. Just provide your DependencyInjector and it will call it
-         * before {Job#onAdded} method is called.
-         * if job is persistent, it will also be called before run method.
-         * @param injector your dependency injector interface, if using one
-         * @return
-         */
-        public Builder injector(DependencyInjector injector) {
-            configuration.dependencyInjector = injector;
-            return this;
-        }
-
-        /**
-         * # of max consumers to run concurrently. defaults to {@value #MAX_CONSUMER_COUNT}
-         * @param count
-         */
-        public Builder maxConsumerCount(int count) {
-            configuration.maxConsumerCount = count;
-            return this;
-        }
-
-        /**
-         * you can specify to keep minConsumers alive even if there are no ready jobs. defaults to {@value #MIN_CONSUMER_COUNT}
-         * @param count
-         */
-        public Builder minConsumerCount(int count) {
-            configuration.minConsumerCount = count;
-            return this;
-        }
-
-        /**
-         * you can provide a custom logger to get logs from JobManager.
-         * by default, logs will go no-where.
-         * @param logger
-         */
-        public Builder customLogger(CustomLogger logger) {
-            configuration.customLogger = logger;
-            return this;
-        }
-
-        /**
-         * calculated by # of jobs (running+waiting) per thread
-         * for instance, at a given time, if you have two consumers and 10 jobs in waiting queue (or running right now), load is
-         * (10/2) =5
-         * defaults to {@value #DEFAULT_LOAD_FACTOR_PER_CONSUMER}
-         * @param loadFactor
-         */
-        public Builder loadFactor(int loadFactor) {
-            configuration.loadFactor = loadFactor;
-            return this;
-        }
-
-        /**
-         * Sets the JobManager in test mode. This information is passed to JobQueue's.
-         * If you are using default JobQueues, calling this method will cause {@link SqliteJobQueue}
-         * to use an in-memory database.
-         */
-        public Builder inTestMode() {
-            configuration.inTestMode = true;
-            return this;
-        }
-
-        public Configuration build() {
-            if(configuration.queueFactory == null) {
-                configuration.queueFactory = new JobManager.DefaultQueueFactory();
-            }
-            if(configuration.networkUtil == null) {
-                configuration.networkUtil = new NetworkUtilImpl(appContext);
-            }
-            return configuration;
-        }
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/di/DependencyInjector.java b/jobqueue/src/main/java/com/path/android/jobqueue/di/DependencyInjector.java
deleted file mode 100755
index 75d1d72..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/di/DependencyInjector.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.path.android.jobqueue.di;
-
-import com.path.android.jobqueue.Job;
-
-/**
- * interface that can be provided to {@link com.path.android.jobqueue.JobManager} for dependency injection
- * it is called before the job's onAdded method is called. for persistent jobs, also run after job is brought
- * back from disk.
- */
-public interface DependencyInjector {
-    public void inject(Job job);
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
deleted file mode 100644
index 84a105f..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
+++ /dev/null
@@ -1,359 +0,0 @@
-package com.path.android.jobqueue.executor;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.callback.JobManagerCallback;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.log.JqLog;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * An executor class that takes care of spinning consumer threads and making sure enough is alive.
- * works deeply coupled with {@link JobManager}
- */
-public class JobConsumerExecutor {
-    private int maxConsumerSize;
-    private int minConsumerSize;
-    private int loadFactor;
-    private final ThreadGroup threadGroup;
-    private final Contract contract;
-    private final int keepAliveSeconds;
-    private final AtomicInteger activeConsumerCount = new AtomicInteger(0);
-    // key : id + (isPersistent)
-    private final ConcurrentHashMap<String, JobHolder> runningJobHolders;
-
-
-    public JobConsumerExecutor(Configuration config, Contract contract) {
-        this.loadFactor = config.getLoadFactor();
-        this.maxConsumerSize = config.getMaxConsumerCount();
-        this.minConsumerSize = config.getMinConsumerCount();
-        this.keepAliveSeconds = config.getConsumerKeepAlive();
-        this.contract = contract;
-        threadGroup = new ThreadGroup("JobConsumers");
-        runningJobHolders = new ConcurrentHashMap<String, JobHolder>();
-    }
-
-    /**
-     * creates a new consumer thread if needed.
-     */
-    public void considerAddingConsumer() {
-        doINeedANewThread(false, true);
-    }
-
-    private boolean canIDie() {
-        if(doINeedANewThread(true, false) == false) {
-            return true;
-        }
-        return false;
-    }
-
-    private boolean doINeedANewThread(boolean inConsumerThread, boolean addIfNeeded) {
-        //if network provider cannot notify us, we have to busy wait
-        if(contract.isRunning() == false) {
-            if(inConsumerThread) {
-                activeConsumerCount.decrementAndGet();
-            }
-            return false;
-        }
-
-        synchronized (threadGroup) {
-            if(isAboveLoadFactor(inConsumerThread) && canAddMoreConsumers()) {
-                if(addIfNeeded) {
-                    addConsumer();
-                }
-                return true;
-            }
-        }
-        if(inConsumerThread) {
-            activeConsumerCount.decrementAndGet();
-        }
-        return false;
-    }
-
-    private void addConsumer() {
-        JqLog.d("adding another consumer");
-        synchronized (threadGroup) {
-            Thread thread = new Thread(threadGroup, new JobConsumer(contract, this));
-            activeConsumerCount.incrementAndGet();
-            thread.start();
-        }
-    }
-
-    private boolean canAddMoreConsumers() {
-        synchronized (threadGroup) {
-            //there is a race condition for the time thread if about to finish
-            return activeConsumerCount.intValue() < maxConsumerSize;
-        }
-    }
-
-    private boolean isAboveLoadFactor(boolean inConsumerThread) {
-        synchronized (threadGroup) {
-            //if i am called from a consumer thread, don't count me
-            int consumerCnt = activeConsumerCount.intValue() - (inConsumerThread ? 1 : 0);
-            boolean res =
-                    consumerCnt < minConsumerSize ||
-                    consumerCnt * loadFactor < contract.countRemainingReadyJobs() + runningJobHolders.size();
-            if(JqLog.isDebugEnabled()) {
-                JqLog.d("%s: load factor check. %s = (%d < %d)|| (%d * %d < %d + %d). consumer thread: %s", Thread.currentThread().getName(), res,
-                        consumerCnt, minConsumerSize,
-                        consumerCnt, loadFactor, contract.countRemainingReadyJobs(), runningJobHolders.size(), inConsumerThread);
-            }
-            return res;
-        }
-
-    }
-
-    private void onBeforeRun(JobHolder jobHolder) {
-        synchronized (runningJobHolders) {
-            runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);
-        }
-    }
-
-    private void onAfterRun(JobHolder jobHolder) {
-        synchronized (runningJobHolders) {
-            runningJobHolders.remove(createRunningJobHolderKey(jobHolder));
-            runningJobHolders.notifyAll();
-        }
-    }
-
-    private String createRunningJobHolderKey(JobHolder jobHolder) {
-        return createRunningJobHolderKey(jobHolder.getId(), jobHolder.getJob().isPersistent());
-    }
-
-    private String createRunningJobHolderKey(long id, boolean isPersistent) {
-        return id + "_" + (isPersistent ? "t" : "f");
-    }
-
-    /**
-     * returns true if job is currently handled by one of the executor threads
-     * @param id id of the job
-     * @param persistent boolean flag to distinguish id conflicts
-     * @return true if job is currently handled here
-     */
-    public boolean isRunning(long id, boolean persistent) {
-        synchronized (runningJobHolders) {
-            return runningJobHolders.containsKey(createRunningJobHolderKey(id, persistent));
-        }
-    }
-
-    public void waitUntilDone(Set<Long> persistentJobIds, Set<Long> nonPersistentJobIds)
-            throws InterruptedException {
-        List<String> ids = new ArrayList<String>();
-        for (Long id : persistentJobIds) {
-            ids.add(createRunningJobHolderKey(id, true));
-        }
-        for (Long id : nonPersistentJobIds) {
-            ids.add(createRunningJobHolderKey(id, false));
-        }
-        synchronized (runningJobHolders) {
-            while (containsAny(ids)) {
-                runningJobHolders.wait();
-            }
-        }
-    }
-
-    private boolean containsAny(List<String> ids) {
-        for (String id : ids) {
-            if (runningJobHolders.containsKey(id)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public void inRunningJobHoldersLock(Runnable runnable) {
-        synchronized (runningJobHolders) {
-            runnable.run();
-        }
-    }
-
-    /**
-     * Excludes cancelled jobs
-     */
-    public Set<JobHolder> findRunningByTags(TagConstraint constraint, String[] tags,
-            boolean persistent) {
-        Set<JobHolder> result = new HashSet<JobHolder>();
-        synchronized (runningJobHolders) {
-            for (JobHolder holder : runningJobHolders.values()) {
-                JqLog.d("checking job tag %s. tags of job: %s", holder.getJob(), holder.getJob().getTags());
-                if (!holder.hasTags() || persistent != holder.getJob().isPersistent()) {
-                    continue;
-                }
-                if (holder.isCancelled()) {
-                    continue;
-                }
-                if (doesHolderMatchTags(holder, constraint, tags)) {
-                    result.add(holder);
-                }
-            }
-        }
-        return result;
-    }
-
-    private boolean doesHolderMatchTags(JobHolder holder, TagConstraint constraint, String[] tags) {
-        if (constraint == TagConstraint.ANY) {
-            for (String tag : holder.getTags()) {
-                if (contains(tags, tag)) {
-                    return true;
-                }
-            }
-            return false;
-        } else {
-            final Set<String> holderTags = holder.getTags();
-            for (String tag : tags) {
-                if (!holderTags.contains(tag)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-    }
-
-    private boolean contains(String[] arr, String val) {
-        for (int i = 0; i < arr.length; i ++) {
-            if (val.equals(arr[i])) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public void waitUntilAllConsumersAreFinished() throws InterruptedException {
-        Thread[] threads = new Thread[threadGroup.activeCount() * 3];
-        threadGroup.enumerate(threads);
-        for (Thread thread : threads) {
-            if (thread != null) {
-                thread.join();
-            }
-        }
-    }
-
-    /**
-     * contract between the {@link JobManager} and {@link JobConsumerExecutor}
-     */
-    public static interface Contract {
-        /**
-         * @return if {@link JobManager} is currently running.
-         */
-        public boolean isRunning();
-
-        /**
-         * should insert the given {@link JobHolder} to related {@link JobQueue}. if it already exists, should replace the
-         * existing one.
-         * @param jobHolder
-         */
-        public void insertOrReplace(JobHolder jobHolder);
-
-        /**
-         * should remove the job from the related {@link JobQueue}
-         * @param jobHolder
-         */
-        public void removeJob(JobHolder jobHolder);
-
-        /**
-         * should return the next job which is available to be run.
-         * @param wait
-         * @param waitUnit
-         * @return next job to execute or null if no jobs are available
-         */
-        public JobHolder getNextJob(int wait, TimeUnit waitUnit);
-
-        /**
-         * @return the number of Jobs that are ready to be run
-         */
-        public int countRemainingReadyJobs();
-
-        /**
-         * Calls onCancel on the job, notifies listeners
-         * @param nextJob
-         * @param byCancelRequest
-         */
-        void callJobCancel(JobHolder nextJob, boolean byCancelRequest);
-
-        /**
-         * Calls the listeners about job state.
-         * @param nextJob
-         * @param result
-         */
-        void notifyJobRun(JobHolder nextJob, int result);
-    }
-
-    /**
-     * a simple {@link Runnable} that can take jobs from the {@link Contract} and execute them
-     */
-    private static class JobConsumer implements Runnable {
-        private final Contract contract;
-        private final JobConsumerExecutor executor;
-        private boolean didRunOnce = false;
-        public JobConsumer(Contract contract, JobConsumerExecutor executor) {
-            this.executor = executor;
-            this.contract = contract;
-        }
-
-        @Override
-        public void run() {
-            boolean canDie;
-            do {
-                try {
-                    if(JqLog.isDebugEnabled()) {
-                        if(didRunOnce == false) {
-                            JqLog.d("starting consumer %s", Thread.currentThread().getName());
-                            didRunOnce = true;
-                        } else {
-                            JqLog.d("re-running consumer %s", Thread.currentThread().getName());
-                        }
-                    }
-                    JobHolder nextJob;
-                    do {
-                        nextJob = contract.isRunning() ? contract.getNextJob(executor.keepAliveSeconds, TimeUnit.SECONDS) : null;
-                        if (nextJob != null) {
-                            executor.onBeforeRun(nextJob);
-                            int result = nextJob.safeRun(nextJob.getRunCount());
-                            contract.notifyJobRun(nextJob, result);
-                            switch (result) {
-                                case JobHolder.RUN_RESULT_SUCCESS:
-                                    nextJob.markAsSuccessful();
-                                    contract.removeJob(nextJob);
-                                    break;
-                                case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
-                                case JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN:
-                                    contract.callJobCancel(nextJob, false);
-                                    contract.removeJob(nextJob);
-                                    break;
-                                case JobHolder.RUN_RESULT_TRY_AGAIN:
-                                    contract.insertOrReplace(nextJob);
-                                    break;
-                                case JobHolder.RUN_RESULT_FAIL_FOR_CANCEL:
-                                    JqLog.d("running job failed and cancelled, doing nothing. "
-                                            + "Will be removed after it's onCancel is called by the "
-                                            + "JobManager");
-                                    break;
-                            }
-                            executor.onAfterRun(nextJob);
-                        }
-                    } while (nextJob != null);
-                } finally {
-                    //to avoid creating a new thread for no reason, consider not killing this one first
-                    canDie = executor.canIDie();
-                    if(JqLog.isDebugEnabled()) {
-                        if(canDie) {
-                            JqLog.d("finishing consumer %s", Thread.currentThread().getName());
-                        } else {
-                            JqLog.d("didn't allow me to die, re-running %s", Thread.currentThread().getName());
-                        }
-                    }
-                }
-            } while (!canDie);
-        }
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/log/CustomLogger.java b/jobqueue/src/main/java/com/path/android/jobqueue/log/CustomLogger.java
deleted file mode 100644
index 9e889ba..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/log/CustomLogger.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package com.path.android.jobqueue.log;
-
-/**
- * You can provide your own logger implementation to {@link com.path.android.jobqueue.JobManager}
- * it is very similar to Roboguice's logger
- */
-public interface CustomLogger {
-    /**
-     * JobManager may call this before logging sth that is (relatively) expensive to calculate
-     * @return
-     */
-    public boolean isDebugEnabled();
-    public void d(String text, Object... args);
-    public void e(Throwable t, String text, Object... args);
-    public void e(String text, Object... args);
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/log/JqLog.java b/jobqueue/src/main/java/com/path/android/jobqueue/log/JqLog.java
deleted file mode 100644
index d100e83..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/log/JqLog.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package com.path.android.jobqueue.log;
-
-/**
- * Wrapper around {@link CustomLogger}. by default, logs to nowhere
- */
-public class JqLog {
-    private static CustomLogger customLogger = new CustomLogger() {
-        @Override
-        public boolean isDebugEnabled() {
-            return false;
-        }
-
-        @Override
-        public void d(String text, Object... args) {
-            //void
-        }
-
-        @Override
-        public void e(Throwable t, String text, Object... args) {
-            //void
-        }
-
-        @Override
-        public void e(String text, Object... args) {
-            //void
-        }
-    };
-
-    public static void setCustomLogger(CustomLogger customLogger) {
-        JqLog.customLogger = customLogger;
-    }
-
-    public static boolean isDebugEnabled() {
-        return customLogger.isDebugEnabled();
-    }
-
-    public static void d(String text, Object... args) {
-        if (isDebugEnabled()) {
-            customLogger.d(text, args);
-        }
-    }
-
-    public static void e(Throwable t, String text, Object... args) {
-        customLogger.e(t, text, args);
-    }
-
-    public static void e(String text, Object... args) {
-        customLogger.e(text, args);
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkEventProvider.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkEventProvider.java
deleted file mode 100644
index 732664b..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkEventProvider.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package com.path.android.jobqueue.network;
-
-/**
- * An interface that NetworkUtil can implement if it supports a callback method when network state is changed
- * This is not mandatory but highly suggested so that {@link com.path.android.jobqueue.JobManager} can avoid
- * busy loops when there is a job waiting for network and there is no network available
- */
-public interface NetworkEventProvider {
-    public void setListener(Listener listener);
-    public static interface Listener {
-        /**
-         * @param isConnected can be as simple as having an internet connect or can also be customized. (e.g. if your servers are down)
-         */
-        public void onNetworkChange(boolean isConnected);
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtil.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtil.java
deleted file mode 100644
index 0b58e38..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtil.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.path.android.jobqueue.network;
-
-import android.content.Context;
-
-/**
- * Interface which you can implement if you want to provide a custom Network callback.
- * Make sure you also implement {@link NetworkEventProvider} for best performance.
- */
-public interface NetworkUtil {
-    public boolean isConnected(Context context);
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
deleted file mode 100644
index e0ed303..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.path.android.jobqueue.network;
-
-import android.annotation.TargetApi;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Build.VERSION;
-import android.os.PowerManager;
-
-/**
- * default implementation for network Utility to observe network events
- */
-public class NetworkUtilImpl implements NetworkUtil, NetworkEventProvider {
-    private Listener listener;
-    public NetworkUtilImpl(Context context) {
-        context.getApplicationContext().registerReceiver(new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                if(listener == null) {//shall not be but just be safe
-                    return;
-                }
-                //http://developer.android.com/reference/android/net/ConnectivityManager.html#EXTRA_NETWORK_INFO
-                //Since NetworkInfo can vary based on UID, applications should always obtain network information
-                // through getActiveNetworkInfo() or getAllNetworkInfo().
-                listener.onNetworkChange(isConnected(context));
-            }
-        }, getNetworkIntentFilter());
-    }
-
-    @Override
-    public boolean isConnected(Context context) {
-        if (isDozing(context)) {
-            return false;
-        }
-
-        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-        NetworkInfo netInfo = cm.getActiveNetworkInfo();
-        return netInfo != null && netInfo.isConnectedOrConnecting();
-    }
-
-    @TargetApi(23)
-    private static IntentFilter getNetworkIntentFilter() {
-        IntentFilter networkIntentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
-        if (VERSION.SDK_INT >= 23) {
-            networkIntentFilter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
-        }
-        return networkIntentFilter;
-    }
-
-    /**
-     * Returns true if the device is in Doze/Idle mode. Should be called before checking the network connection because
-     * the ConnectionManager may report the device is connected when it isn't during Idle mode.
-     */
-    @TargetApi(23)
-    private static boolean isDozing(Context context) {
-        if (VERSION.SDK_INT >= 23) {
-            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-            return powerManager.isDeviceIdleMode() &&
-                    !powerManager.isIgnoringBatteryOptimizations(context.getPackageName());
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    public void setListener(Listener listener) {
-        this.listener = listener;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java
deleted file mode 100644
index 5316ae6..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/ConsistentTimedComparator.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-
-import java.util.Comparator;
-
-/**
- * A job holder comparator that checks time before checking anything else
- */
-public class ConsistentTimedComparator implements Comparator<JobHolder> {
-    final Comparator<JobHolder> baseComparator;
-
-    public ConsistentTimedComparator(Comparator<JobHolder> baseComparator) {
-        this.baseComparator = baseComparator;
-    }
-
-    @Override
-    public int compare(JobHolder jobHolder, JobHolder jobHolder2) {
-        if(jobHolder.getDelayUntilNs() < jobHolder2.getDelayUntilNs()) {
-            return -1;
-        } else if(jobHolder.getDelayUntilNs() > jobHolder2.getDelayUntilNs()) {
-            return 1;
-        }
-        return baseComparator.compare(jobHolder, jobHolder2);
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java
deleted file mode 100644
index 1d5bb35..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/CountWithGroupIdsResult.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import java.util.Set;
-
-public class CountWithGroupIdsResult {
-    private int count;
-    private Set<String> groupIds;
-
-    public CountWithGroupIdsResult(int count, Set<String> groupIds) {
-        this.count = count;
-        this.groupIds = groupIds;
-    }
-
-    public int getCount() {
-        return count;
-    }
-
-    //nullable
-    public Set<String> getGroupIds() {
-        return groupIds;
-    }
-
-    public CountWithGroupIdsResult mergeWith(CountWithGroupIdsResult other) {
-        if(groupIds == null || other.groupIds == null) {
-            this.count += other.count;
-            if(groupIds == null) {
-                groupIds = other.groupIds;
-            }
-            return this;
-        }
-        //there are some groups, we need to find if any group is in both lists
-        int sharedGroups = 0;
-        for(String groupId : other.groupIds) {
-            if(groupIds.add(groupId) == false) {
-                sharedGroups ++;
-            }
-        }
-        count = count + other.count - sharedGroups;
-        return this;
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/JobSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
deleted file mode 100755
index fec848f..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.TagConstraint;
-
-import java.util.Collection;
-import java.util.Set;
-
-/**
- * An interface for Job Containers
- * It is very similar to SortedSet
- */
-public interface JobSet {
-    JobHolder peek(Collection<String> excludeGroupIds);
-    JobHolder poll(Collection<String> excludeGroupIds);
-    JobHolder findById(long id);
-    Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
-            String... tags);
-    boolean offer(JobHolder holder);
-    boolean remove(JobHolder holder);
-    void clear();
-    int size();
-    CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups);
-    CountWithGroupIdsResult countReadyJobs(Collection<String> excludeGroups);
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
deleted file mode 100755
index 9c56589..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
+++ /dev/null
@@ -1,232 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.TagConstraint;
-
-import java.util.*;
-
-/**
- * A queue implementation that utilize two queues depending on one or multiple properties of the {@link JobHolder}
- * While retrieving items, it uses a different comparison method to handle dynamic comparisons (e.g. time)
- * between two queues
- */
-abstract public class MergedQueue implements JobSet {
-    JobSet queue0;
-    JobSet queue1;
-
-    final Comparator<JobHolder> comparator;
-    final Comparator<JobHolder> retrieveComparator;
-
-    /**
-     *
-     * @param initialCapacity passed to {@link MergedQueue#createQueue(com.path.android.jobqueue.nonPersistentQueue.MergedQueue.SetId, int, java.util.Comparator)}
-     * @param comparator passed to {@link MergedQueue#createQueue(com.path.android.jobqueue.nonPersistentQueue.MergedQueue.SetId, int, java.util.Comparator)}
-     * @param retrieveComparator upon retrieval, if both queues return items, this comparator is used to decide which
-     *                           one should be returned
-     */
-    public MergedQueue(int initialCapacity, Comparator<JobHolder> comparator, Comparator<JobHolder> retrieveComparator) {
-        this.comparator = comparator;
-        this.retrieveComparator = retrieveComparator;
-        queue0 = createQueue(SetId.S0, initialCapacity, comparator);
-        queue1 = createQueue(SetId.S1, initialCapacity, comparator);
-    }
-
-    /**
-     * used to poll from one of the queues
-     * @param queueId
-     * @return
-     */
-    protected JobHolder pollFromQueue(SetId queueId, Collection<String> excludeGroupIds) {
-        if(queueId == SetId.S0) {
-            return queue0.poll(excludeGroupIds);
-        }
-        return queue1.poll(excludeGroupIds);
-    }
-
-    /**
-     * used to peek from one of the queues
-     * @param queueId
-     * @return
-     */
-    protected JobHolder peekFromQueue(SetId queueId, Collection<String> excludeGroupIds) {
-        if(queueId == SetId.S0) {
-            return queue0.peek(excludeGroupIds);
-        }
-        return queue1.peek(excludeGroupIds);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean offer(JobHolder jobHolder) {
-        SetId queueId = decideQueue(jobHolder);
-        if(queueId == SetId.S0) {
-            return queue0.offer(jobHolder);
-
-        }
-        return queue1.offer(jobHolder);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder poll(Collection<String> excludeGroupIds) {
-        JobHolder delayed = queue0.peek(excludeGroupIds);
-        if(delayed == null) {
-            return queue1.poll(excludeGroupIds);
-        }
-        //if queue for this job has changed, re-add it and try poll from scratch
-        if(decideQueue(delayed) != SetId.S0) {
-            //should be moved to the other queue
-            queue0.remove(delayed);
-            queue1.offer(delayed);
-            return poll(excludeGroupIds);
-        }
-        JobHolder nonDelayed = queue1.peek(excludeGroupIds);
-        if(nonDelayed == null) {
-            queue0.remove(delayed);
-            return delayed;
-        }
-        //if queue for this job has changed, re-add it and try poll from scratch
-        if(decideQueue(nonDelayed) != SetId.S1) {
-            queue0.offer(nonDelayed);
-            queue1.remove(nonDelayed);
-            return poll(excludeGroupIds);
-        }
-        //both are not null, need to compare and return the better
-        int cmp = retrieveComparator.compare(delayed, nonDelayed);
-        if(cmp == -1) {
-            queue0.remove(delayed);
-            return delayed;
-        } else {
-            queue1.remove(nonDelayed);
-            return nonDelayed;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder peek(Collection<String> excludeGroupIds) {
-        while (true) {
-            JobHolder delayed = queue0.peek(excludeGroupIds);
-            //if queue for this job has changed, re-add it and try peek from scratch
-            if(delayed != null && decideQueue(delayed) != SetId.S0) {
-                queue1.offer(delayed);
-                queue0.remove(delayed);
-                continue;//retry
-            }
-            JobHolder nonDelayed = queue1.peek(excludeGroupIds);
-            //if queue for this job has changed, re-add it and try peek from scratch
-            if(nonDelayed != null && decideQueue(nonDelayed) != SetId.S1) {
-                queue0.offer(nonDelayed);
-                queue1.remove(nonDelayed);
-                continue;//retry
-            }
-            if(delayed == null) {
-                return nonDelayed;
-            }
-            if(nonDelayed == null) {
-                return delayed;
-            }
-            int cmp = retrieveComparator.compare(delayed, nonDelayed);
-            if(cmp == -1) {
-                return delayed;
-            }
-            return nonDelayed;
-        }
-    }
-
-
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void clear() {
-        queue1.clear();
-        queue0.clear();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean remove(JobHolder holder) {
-        //we cannot check queue here, might be dynamic
-        return queue1.remove(holder) || queue0.remove(holder);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int size() {
-        return queue0.size() + queue1.size();
-    }
-
-    /**
-     * decides which queue should the job holder go
-     * if first queue, should return 0
-     * if second queue, should return 1
-     * is only called when an item is inserted. methods like remove always call both queues.
-     * @param jobHolder
-     * @return
-     */
-    abstract protected SetId decideQueue(JobHolder jobHolder);
-
-    /**
-     * called when we want to create the subsequent queues
-     * @param initialCapacity
-     * @param comparator
-     * @return
-     */
-    abstract protected JobSet createQueue(SetId setId, int initialCapacity, Comparator<JobHolder> comparator);
-
-    public CountWithGroupIdsResult countReadyJobs(SetId setId, long now, Collection<String> excludeGroups) {
-        if(setId == SetId.S0) {
-            return queue0.countReadyJobs(now, excludeGroups);
-        } else {
-            return queue1.countReadyJobs(now, excludeGroups);
-        }
-    }
-
-    public CountWithGroupIdsResult countReadyJobs(SetId setId, Collection<String> excludeGroups) {
-        if(setId == SetId.S0) {
-            return queue0.countReadyJobs(excludeGroups);
-        } else {
-            return queue1.countReadyJobs(excludeGroups);
-        }
-    }
-
-    /**
-     * Returns the JobHolder that has the given id
-     * @param id id job the job
-     * @return
-     */
-    @Override
-    public JobHolder findById(long id) {
-        JobHolder q0 = queue0.findById(id);
-        return q0 == null ? queue1.findById(id) : q0;
-    }
-
-    @Override
-    public Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
-            String... tags) {
-        Set<JobHolder> jobs = new HashSet<JobHolder>();
-        jobs.addAll(queue0.findByTags(constraint, exclude, tags));
-        jobs.addAll(queue1.findByTags(constraint, exclude, tags));
-        return jobs;
-    }
-
-    /**
-     * simple enum to identify queues
-     */
-    protected static enum SetId {
-        S0,
-        S1
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java
deleted file mode 100644
index 24f20b7..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NetworkAwarePriorityQueue.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Queue;
-
-/**
- * A {@link MergedQueue} class that can separate jobs based on their network requirement
- */
-public class NetworkAwarePriorityQueue extends MergedQueue {
-
-    /**
-     * create a network aware priority queue with given initial capacity * 2 and comparator
-     * @param initialCapacity
-     * @param comparator
-     */
-    public NetworkAwarePriorityQueue(int initialCapacity, Comparator<JobHolder> comparator) {
-        super(initialCapacity, comparator, new TimeAwareComparator(comparator));
-    }
-
-    /**
-     * {@link java.util.Queue#peek()} implementation with network requirement filter
-     * @param canUseNetwork if {@code true}, does not check network requirement if {@code false}, returns only from
-     *                      no network queue
-     * @return
-     */
-    public JobHolder peek(boolean canUseNetwork, Collection<String> excludeGroupIds) {
-        if(canUseNetwork) {
-            return super.peek(excludeGroupIds);
-        } else {
-            return super.peekFromQueue(SetId.S1, excludeGroupIds);
-        }
-    }
-
-    /**
-     * {@link java.util.Queue#poll()} implementation with network requirement filter
-     * @param canUseNetwork if {@code true}, does not check network requirement if {@code false}, returns only from
-     *                      no network queue
-     * @return
-     */
-    public JobHolder poll(boolean canUseNetwork, Collection<String> excludeGroupIds) {
-        if(canUseNetwork) {
-            return super.peek(excludeGroupIds);
-        } else {
-            return super.peekFromQueue(SetId.S1, excludeGroupIds);
-        }
-    }
-
-    @Override
-    protected SetId decideQueue(JobHolder jobHolder) {
-        return jobHolder.requiresNetwork() ? SetId.S0 : SetId.S1;
-    }
-
-    /**
-     * create a {@link TimeAwarePriorityQueue}
-     * @param ignoredQueueId
-     * @param initialCapacity
-     * @param comparator
-     * @return
-     */
-    @Override
-    protected JobSet createQueue(SetId ignoredQueueId, int initialCapacity, Comparator<JobHolder> comparator) {
-        return new TimeAwarePriorityQueue(initialCapacity, comparator);
-    }
-
-
-    public CountWithGroupIdsResult countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups) {
-        long now = System.nanoTime();
-        if(hasNetwork) {
-            return super.countReadyJobs(SetId.S0, now, excludeGroups).mergeWith(super.countReadyJobs(SetId.S1, now, excludeGroups));
-        } else {
-            return super.countReadyJobs(SetId.S1, now, excludeGroups);
-        }
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups) {
-        throw new UnsupportedOperationException("cannot call network aware priority queue count w/o providing network status");
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(Collection<String> excludeGroups) {
-        throw new UnsupportedOperationException("cannot call network aware priority queue count w/o providing network status");
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
deleted file mode 100755
index fe5a800..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
+++ /dev/null
@@ -1,309 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.log.JqLog;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-
-/**
- * This is the default implementation of JobSet.
- * It uses TreeSet as the underlying data structure. Is currently inefficient, should be replaced w/ a more efficient
- * version
- */
-public class NonPersistentJobSet implements JobSet {
-    private final TreeSet<JobHolder> set;
-    //groupId -> # of jobs in that group
-    private final Map<String, Integer> existingGroups;
-    private final Map<Long, JobHolder> idCache;
-    private final Map<String, List<JobHolder>> tagCache;
-
-    public NonPersistentJobSet(Comparator<JobHolder> comparator) {
-        this.set = new TreeSet<JobHolder>(comparator);
-        this.existingGroups = new HashMap<String, Integer>();
-        this.idCache = new HashMap<Long, JobHolder>();
-        this.tagCache = new HashMap<String, List<JobHolder>>();
-    }
-
-    private JobHolder safeFirst() {
-        if(set.size() < 1) {
-            return null;
-        }
-        return set.first();
-    }
-
-    @Override
-    public JobHolder peek(Collection<String> excludeGroupIds) {
-        if(excludeGroupIds == null || excludeGroupIds.size() == 0) {
-            return safeFirst();
-        }
-        //there is an exclude list, we have to itereate :/
-        for (JobHolder holder : set) {
-            if (holder.getGroupId() == null) {
-                return holder;
-            }
-            //we have to check if it is excluded
-            if (excludeGroupIds.contains(holder.getGroupId())) {
-                continue;
-            }
-            return holder;
-        }
-        return null;
-    }
-
-    private JobHolder safePeek() {
-        if(set.size() == 0) {
-            return null;
-        }
-        return safeFirst();
-    }
-
-    @Override
-    public JobHolder poll(Collection<String> excludeGroupIds) {
-        JobHolder peek = peek(excludeGroupIds);
-        if(peek != null) {
-            remove(peek);
-        }
-        return peek;
-    }
-
-    @Override
-    public JobHolder findById(long id) {
-        return idCache.get(id);
-    }
-
-    @Override
-    public Set<JobHolder> findByTags(TagConstraint constraint, Collection<Long> exclude,
-            String... tags) {
-        if(tags == null) {
-            return Collections.emptySet();
-        }
-        Set<JobHolder> jobs = new HashSet<JobHolder>();
-        boolean first = true;
-        for(String tag : tags) {
-            List<JobHolder> found = tagCache.get(tag);
-            if(found == null || found.size() == 0) {
-                if (constraint == TagConstraint.ALL) {
-                    return Collections.emptySet();
-                } else {
-                    continue;
-                }
-            }
-            if (constraint == TagConstraint.ALL) {
-                jobs.addAll(found);
-            } else if (first) {
-                jobs.addAll(found);
-            } else {
-                removeIfNotExists(jobs, found);
-                if (jobs.size() == 0) {
-                    return Collections.emptySet();
-                }
-            }
-            first = false;
-        }
-        if (exclude != null) {
-            removeIds(jobs, exclude);
-        }
-        return jobs;
-    }
-
-    private void removeIds(Set<JobHolder> mainSet, Collection<Long> ids) {
-        final Iterator<JobHolder> itr = mainSet.iterator();
-        while (itr.hasNext()) {
-            JobHolder holder = itr.next();
-            if (ids.contains(holder.getId())) {
-                itr.remove();
-            }
-        }
-    }
-    private void removeIfNotExists(Set<JobHolder> mainSet, List<JobHolder> items) {
-        final Iterator<JobHolder> itr = mainSet.iterator();
-        while (itr.hasNext()) {
-            JobHolder holder = itr.next();
-            if (!items.contains(holder)) {
-                itr.remove();
-            }
-        }
-    }
-
-    @Override
-    public boolean offer(JobHolder holder) {
-        if(holder.getId() == null) {
-            throw new RuntimeException("cannot add job holder w/o an ID");
-        }
-        boolean result = set.add(holder);
-        if(result == false) {
-            //remove the existing element and add new one
-            remove(holder);
-            result = set.add(holder);
-        }
-        if(result) {
-            idCache.put(holder.getId(), holder);
-            addToTagCache(holder);
-            if(holder.getGroupId() != null) {
-                incGroupCount(holder.getGroupId());
-            }
-        }
-
-        return result;
-    }
-
-    private void addToTagCache(JobHolder holder) {
-        final Set<String> tags = holder.getTags();
-        if(tags == null || tags.size() == 0) {
-            return;
-        }
-        for(String tag : tags) {
-            List<JobHolder> jobs = tagCache.get(tag);
-            if(jobs == null) {
-                jobs = new LinkedList<JobHolder>();
-                tagCache.put(tag, jobs);
-            }
-            jobs.add(holder);
-        }
-    }
-
-    private void removeFromTagCache(JobHolder holder) {
-        final Set<String> tags = holder.getTags();
-        if(tags == null || tags.size() == 0) {
-            return;
-        }
-        for(String tag : tags) {
-            List<JobHolder> jobs = tagCache.get(tag);
-            if(jobs == null) {
-                JqLog.e("trying to remove job from tag cache but cannot find the tag cache");
-                return;
-            }
-            if(jobs.remove(holder) == false) {
-                JqLog.e("trying to remove job from tag cache but cannot find it in the cache");
-            } else if(jobs.size() == 0) {
-                tagCache.remove(tag); // TODO pool?
-            }
-
-        }
-    }
-
-
-    private void incGroupCount(String groupId) {
-        if(existingGroups.containsKey(groupId) == false) {
-            existingGroups.put(groupId, 1);
-        } else {
-            existingGroups.put(groupId, existingGroups.get(groupId) + 1);
-        }
-    }
-
-    private void decGroupCount(String groupId) {
-        Integer val = existingGroups.get(groupId);
-        if(val == null || val <= 0) {
-            //TODO should we crash?
-            JqLog.e("detected inconsistency in NonPersistentJobSet's group id hash. Please report " +
-                    "a bug");
-            existingGroups.remove(groupId);
-            return;
-        }
-        val -= 1;
-        if(val == 0) {
-            existingGroups.remove(groupId);
-        } else {
-            existingGroups.put(groupId, val);
-        }
-    }
-
-    @Override
-    public boolean remove(JobHolder holder) {
-        boolean removed = set.remove(holder);
-        if(removed) {
-            idCache.remove(holder.getId());
-            removeFromTagCache(holder);
-            if(holder.getGroupId() != null) {
-                decGroupCount(holder.getGroupId());
-            }
-        }
-        return removed;
-    }
-
-
-
-    @Override
-    public void clear() {
-        set.clear();
-        existingGroups.clear();
-        idCache.clear();
-        tagCache.clear();
-    }
-
-    @Override
-    public int size() {
-        return set.size();
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups) {
-        //TODO we can cache most of this
-        int total = 0;
-        int groupCnt = existingGroups.keySet().size();
-        Set<String> groupIdSet = null;
-        if(groupCnt > 0) {
-            groupIdSet = new HashSet<String>();//we have to track :/
-        }
-        for(JobHolder holder : set) {
-            if(holder.getDelayUntilNs() < now) {
-                //we should not need to check groupCnt but what if sth is wrong in hashmap, be defensive till
-                //we write unit tests around NonPersistentJobSet
-                if(holder.getGroupId() != null) {
-                    if(excludeGroups != null && excludeGroups.contains(holder.getGroupId())) {
-                        continue;
-                    }
-                    //we should not need to check groupCnt but what if sth is wrong in hashmap, be defensive till
-                    //we write unit tests around NonPersistentJobSet
-                    if(groupCnt > 0) {
-                        if(groupIdSet.add(holder.getGroupId())) {
-                            total++;
-                        }
-                    }
-                    //else skip, we already counted this group
-                } else {
-                    total ++;
-                }
-            }
-        }
-        return new CountWithGroupIdsResult(total, groupIdSet);
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(Collection <String> excludeGroups) {
-        if(existingGroups.size() == 0) {
-            return new CountWithGroupIdsResult(set.size(), null);
-        } else {
-            //todo we can actually count from existingGroups set if we start counting numbers there as well
-            int total = 0;
-            Set<String> existingGroupIds = null;
-            for(JobHolder holder : set) {
-                if(holder.getGroupId() != null) {
-                    if(excludeGroups != null && excludeGroups.contains(holder.getGroupId())) {
-                        continue;
-                    } else if(existingGroupIds == null) {
-                        existingGroupIds = new HashSet<String>();
-                        existingGroupIds.add(holder.getGroupId());
-                    } else if(existingGroupIds.add(holder.getGroupId()) == false) {
-                        continue;
-                    }
-
-                }
-                total ++;
-            }
-            return new CountWithGroupIdsResult(total, existingGroupIds);
-        }
-
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
deleted file mode 100644
index c0a6e52..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.TagConstraint;
-
-import java.util.*;
-
-public class NonPersistentPriorityQueue implements JobQueue {
-    private long nonPersistentJobIdGenerator = Integer.MIN_VALUE;
-    //TODO implement a more efficient priority queue where we can mark jobs as removed but don't remove for real
-    private NetworkAwarePriorityQueue jobs;
-    private final String id;
-    private final long sessionId;
-
-    public NonPersistentPriorityQueue(long sessionId, String id, boolean inTestMode) {
-        this.id = id;
-        this.sessionId = sessionId;
-        jobs = new NetworkAwarePriorityQueue(5, jobComparator);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public synchronized long insert(JobHolder jobHolder) {
-        nonPersistentJobIdGenerator++;
-        jobHolder.setId(nonPersistentJobIdGenerator);
-        jobs.offer(jobHolder);
-        return jobHolder.getId();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long insertOrReplace(JobHolder jobHolder) {
-        remove(jobHolder);
-        jobHolder.setRunningSessionId(JobManager.NOT_RUNNING_SESSION_ID);
-        jobs.offer(jobHolder);
-        return jobHolder.getId();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void remove(JobHolder jobHolder) {
-        jobs.remove(jobHolder);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int count() {
-        return jobs.size();
-    }
-
-    @Override
-    public int countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups) {
-        return jobs.countReadyJobs(hasNetwork, excludeGroups).getCount();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups) {
-        JobHolder jobHolder = jobs.peek(hasNetwork, excludeGroups);
-
-        if (jobHolder != null) {
-            //check if job can run
-            if(jobHolder.getDelayUntilNs() > System.nanoTime()) {
-                jobHolder = null;
-            } else {
-                jobHolder.setRunningSessionId(sessionId);
-                jobHolder.setRunCount(jobHolder.getRunCount() + 1);
-                jobs.remove(jobHolder);
-            }
-        }
-        return jobHolder;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
-        JobHolder next = jobs.peek(hasNetwork, excludeGroups);
-        return next == null ? null : next.getDelayUntilNs();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void clear() {
-        jobs.clear();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder findJobById(long id) {
-        return jobs.findById(id);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Set<JobHolder> findJobsByTags(TagConstraint constraint, boolean excludeCancelled,
-            Collection<Long> exclude, String... tags) {
-        //we ignore excludeCancelled because we remove them as soon as they are cancelled
-        return jobs.findByTags(constraint, exclude, tags);
-    }
-
-    @Override
-    public void onJobCancelled(JobHolder holder) {
-        // we can remove instantly.
-        remove(holder);
-    }
-
-    public final Comparator<JobHolder> jobComparator = new Comparator<JobHolder>() {
-        @Override
-        public int compare(JobHolder holder1, JobHolder holder2) {
-            //we should not check delay here. TimeAwarePriorityQueue does it for us.
-            //high priority first
-            int cmp = compareInt(holder1.getPriority(), holder2.getPriority());
-            if(cmp != 0) {
-                return cmp;
-            }
-
-            //if run counts are also equal, older job first
-            cmp = -compareLong(holder1.getCreatedNs(), holder2.getCreatedNs());
-            if(cmp != 0) {
-                return cmp;
-            }
-
-            //if jobs were created at the same time, smaller id first
-            return -compareLong(holder1.getId(), holder2.getId());
-        }
-    };
-
-    private static int compareInt(int i1, int i2) {
-        if (i1 > i2) {
-            return -1;
-        }
-        if (i2 > i1) {
-            return 1;
-        }
-        return 0;
-    }
-
-    private static int compareLong(long l1, long l2) {
-        if (l1 > l2) {
-            return -1;
-        }
-        if (l2 > l1) {
-            return 1;
-        }
-        return 0;
-    }
-
-
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java
deleted file mode 100644
index 252b4ab..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwareComparator.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-
-import java.util.Comparator;
-
-/**
- * A real-time comparator class that checks current time to decide of both jobs are valid or not.
- * Return values from this comparator are inconsistent as time may change.
- */
-public class TimeAwareComparator implements Comparator<JobHolder> {
-    final Comparator<JobHolder> baseComparator;
-
-    public TimeAwareComparator(Comparator<JobHolder> baseComparator) {
-        this.baseComparator = baseComparator;
-    }
-
-    @Override
-    public int compare(JobHolder jobHolder, JobHolder jobHolder2) {
-        long now = System.nanoTime();
-        boolean job1Valid = jobHolder.getDelayUntilNs() <= now;
-        boolean job2Valid = jobHolder2.getDelayUntilNs() <= now;
-        if(job1Valid) {
-            return job2Valid ? baseComparator.compare(jobHolder, jobHolder2) : -1;
-        }
-        if(job2Valid) {
-            return job1Valid ? baseComparator.compare(jobHolder, jobHolder2) : 1;
-        }
-        //if both jobs are invalid, return the job that can run earlier. if the want to run at the same time, use base
-        //comparison
-        if(jobHolder.getDelayUntilNs() < jobHolder2.getDelayUntilNs()) {
-            return -1;
-        } else if(jobHolder.getDelayUntilNs() > jobHolder2.getDelayUntilNs()) {
-            return 1;
-        }
-        return baseComparator.compare(jobHolder, jobHolder2);
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java
deleted file mode 100644
index 5d8863a..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/nonPersistentQueue/TimeAwarePriorityQueue.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.path.android.jobqueue.nonPersistentQueue;
-
-import com.path.android.jobqueue.JobHolder;
-
-import java.util.*;
-
-/**
- * This is a {@link MergedQueue} class that can handle queue updates based on time.
- * It uses two queues, one for jobs that can run now and the other for jobs that should wait.
- * Upon retrieval, if it detects a job in delayed queue that can run now, it removes it from there, adds it to S0
- * and re-runs the operation. This is not very efficient but provides proper ordering for delayed jobs.
- */
-public class TimeAwarePriorityQueue extends MergedQueue {
-
-    /**
-     * When retrieving jobs, considers current system nanotime to check if jobs are valid. if both jobs are valid
-     * or both jobs are invalid, returns based on regular comparison
-     * @param initialCapacity
-     * @param comparator
-     */
-    public TimeAwarePriorityQueue(int initialCapacity, Comparator<JobHolder> comparator) {
-        super(initialCapacity, comparator, new TimeAwareComparator(comparator));
-    }
-
-    @Override
-    protected SetId decideQueue(JobHolder jobHolder) {
-        return jobHolder.getDelayUntilNs() <= System.nanoTime() ? SetId.S0 : SetId.S1;
-    }
-
-    /**
-     * create a {@link PriorityQueue} with given comparator
-     * @param setId
-     * @param initialCapacity
-     * @param comparator
-     * @return
-     */
-    @Override
-    protected JobSet createQueue(SetId setId, int initialCapacity, Comparator<JobHolder> comparator) {
-        if(setId == SetId.S0) {
-            return new NonPersistentJobSet(comparator);
-        } else {
-            return new NonPersistentJobSet(new ConsistentTimedComparator(comparator));
-        }
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(long now, Collection<String> excludeGroups) {
-        return super.countReadyJobs(SetId.S0, excludeGroups).mergeWith(super.countReadyJobs(SetId.S1, now, excludeGroups));
-    }
-
-    @Override
-    public CountWithGroupIdsResult countReadyJobs(Collection<String> excludeGroups) {
-        throw new UnsupportedOperationException("cannot call time aware priority queue's count ready jobs w/o providing a time");
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java
deleted file mode 100644
index 43eba4e..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/QueryCache.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package com.path.android.jobqueue.persistentQueue.sqlite;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * a class to cache ready jobs queries so that we can avoid unnecessary memory allocations for them
- */
-public class QueryCache {
-    private static final String KEY_EMPTY_WITH_NETWORK = "w_n";
-    private static final String KEY_EMPTY_WITHOUT_NETWORK = "wo_n";
-    //never reach this outside sync block
-    private final StringBuilder reusedBuilder;
-    private final Map<String, String> cache;
-
-    public QueryCache() {
-        reusedBuilder = new StringBuilder();
-        cache = new HashMap<String, String>();
-    }
-
-    public synchronized String get(boolean hasNetwork, Collection<String> excludeGroups) {
-        String key = cacheKey(hasNetwork, excludeGroups);
-        return cache.get(key);
-    }
-
-    public synchronized void set(String query, boolean hasNetwork, Collection<String> excludeGroups) {
-        String key = cacheKey(hasNetwork, excludeGroups);
-        cache.put(key, query);
-        return;
-    }
-
-    /**
-     * create a cache key for an exclude group set. exclude groups are guaranteed to be ordered so we rely on that
-     * @param hasNetwork
-     * @param excludeGroups
-     * @return
-     */
-    private String cacheKey(boolean hasNetwork, Collection<String> excludeGroups) {
-        if(excludeGroups == null || excludeGroups.size() == 0) {
-            return hasNetwork ? KEY_EMPTY_WITH_NETWORK : KEY_EMPTY_WITHOUT_NETWORK;
-        }
-        reusedBuilder.setLength(0);
-        reusedBuilder.append(hasNetwork ? "X" : "Y");
-        for(String group : excludeGroups) {
-            reusedBuilder.append("-").append(group);
-        }
-        return reusedBuilder.toString();
-    }
-
-    public synchronized void clear() {
-        cache.clear();
-    }
-}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
deleted file mode 100755
index 59dac8a..0000000
--- a/jobqueue/src/main/java/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ /dev/null
@@ -1,547 +0,0 @@
-package com.path.android.jobqueue.persistentQueue.sqlite;
-
-import android.content.Context;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDoneException;
-import android.database.sqlite.SQLiteStatement;
-
-import com.path.android.jobqueue.*;
-import com.path.android.jobqueue.log.JqLog;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutput;
-import java.io.ObjectOutputStream;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * Persistent Job Queue that keeps its data in an sqlite database.
- */
-public class SqliteJobQueue implements JobQueue {
-    DbOpenHelper dbOpenHelper;
-    private final long sessionId;
-    SQLiteDatabase db;
-    SqlHelper sqlHelper;
-    JobSerializer jobSerializer;
-    QueryCache readyJobsQueryCache;
-    QueryCache nextJobsQueryCache;
-    QueryCache nextJobDelayUntilQueryCache;
-    // we keep a list of cancelled jobs in memory not to return them in subsequent find by tag
-    // queries. Set is cleaned when item is removed
-    Set<Long> pendingCancelations = new HashSet<Long>();
-    
-    /**
-     * @param context       application context
-     * @param sessionId     session id should match {@link JobManager}
-     * @param id            uses this value to construct database name {@code "db_" + id}
-     * @param jobSerializer The serializer to use while persisting jobs to database
-     * @param inTestMode    If true, creates a memory only database
-     */
-    public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer jobSerializer,
-            boolean inTestMode) {
-        this.sessionId = sessionId;
-        dbOpenHelper = new DbOpenHelper(context, inTestMode ? null : ("db_" + id));
-        db = dbOpenHelper.getWritableDatabase();
-        sqlHelper = new SqlHelper(db, DbOpenHelper.JOB_HOLDER_TABLE_NAME, DbOpenHelper.ID_COLUMN.columnName, DbOpenHelper.COLUMN_COUNT,
-                DbOpenHelper.JOB_TAGS_TABLE_NAME, DbOpenHelper.TAGS_COLUMN_COUNT, sessionId);
-        this.jobSerializer = jobSerializer;
-        readyJobsQueryCache = new QueryCache();
-        nextJobsQueryCache = new QueryCache();
-        nextJobDelayUntilQueryCache = new QueryCache();
-        sqlHelper.resetDelayTimesTo(JobManager.NOT_DELAYED_JOB_DELAY);
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long insert(JobHolder jobHolder) {
-        if (jobHolder.hasTags()) {
-            return insertWithTags(jobHolder);
-        }
-        final SQLiteStatement stmt = sqlHelper.getInsertStatement();
-        long id = -1;
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                stmt.clearBindings();
-                bindValues(stmt, jobHolder);
-                id = stmt.executeInsert();
-                db.setTransactionSuccessful();
-            } catch (SQLException e) {
-                JqLog.e(e, "called insert with sql exception.");
-            } finally {
-                safeEndTransaction();
-            }
-        }
-        jobHolder.setId(id);
-        return id;
-    }
-    
-    private long insertWithTags(JobHolder jobHolder) {
-        final SQLiteStatement stmt = sqlHelper.getInsertStatement();
-        final SQLiteStatement tagsStmt = sqlHelper.getInsertTagsStatement();
-        long id = -1;
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                stmt.clearBindings();
-                bindValues(stmt, jobHolder);
-                id = stmt.executeInsert();
-                for (String tag : jobHolder.getTags()) {
-                    tagsStmt.clearBindings();
-                    bindTag(tagsStmt, id, tag);
-                    tagsStmt.executeInsert();
-                }
-                db.setTransactionSuccessful();
-            } catch (SQLException e) {
-                JqLog.e(e, "called insertWithTags with sql exception.");
-            } finally {
-                safeEndTransaction();
-            }
-        }
-        jobHolder.setId(id);
-        return id;
-    }
-    
-    private void bindTag(SQLiteStatement stmt, long jobId, String tag) {
-        stmt.bindLong(DbOpenHelper.TAGS_JOB_ID_COLUMN.columnIndex + 1, jobId);
-        stmt.bindString(DbOpenHelper.TAGS_NAME_COLUMN.columnIndex + 1, tag);
-    }
-    
-    private void bindValues(SQLiteStatement stmt, JobHolder jobHolder) {
-        if (jobHolder.getId() != null) {
-            stmt.bindLong(DbOpenHelper.ID_COLUMN.columnIndex + 1, jobHolder.getId());
-        }
-        stmt.bindLong(DbOpenHelper.PRIORITY_COLUMN.columnIndex + 1, jobHolder.getPriority());
-        if (jobHolder.getGroupId() != null) {
-            stmt.bindString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex + 1, jobHolder.getGroupId());
-        }
-        stmt.bindLong(DbOpenHelper.RUN_COUNT_COLUMN.columnIndex + 1, jobHolder.getRunCount());
-        byte[] job = getSerializeJob(jobHolder);
-        if (job != null) {
-            stmt.bindBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex + 1, job);
-        }
-        stmt.bindLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex + 1, jobHolder.getCreatedNs());
-        stmt.bindLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex + 1, jobHolder.getDelayUntilNs());
-        stmt.bindLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex + 1, jobHolder.getRunningSessionId());
-        stmt.bindLong(DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnIndex + 1,
-                jobHolder.requiresNetwork() ? 1L : 0L);
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long insertOrReplace(JobHolder jobHolder) {
-        if (jobHolder.getId() == null) {
-            return insert(jobHolder);
-        }
-        jobHolder.setRunningSessionId(JobManager.NOT_RUNNING_SESSION_ID);
-        SQLiteStatement stmt = sqlHelper.getInsertOrReplaceStatement();
-        long id = -1;
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                stmt.clearBindings();
-                bindValues(stmt, jobHolder);
-                id = stmt.executeInsert();
-                db.setTransactionSuccessful();
-            } catch (SQLException e) {
-                JqLog.e(e, "called insertOrReplace with sql exception.");
-            } finally {
-                safeEndTransaction();
-            }
-        }
-        jobHolder.setId(id);
-        return id;
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void remove(JobHolder jobHolder) {
-        if (jobHolder.getId() == null) {
-            JqLog.e("called remove with null job id.");
-            return;
-        }
-        delete(jobHolder.getId());
-    }
-    
-    private void delete(Long id) {
-        pendingCancelations.remove(id);
-        SQLiteStatement stmt = sqlHelper.getDeleteStatement();
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                stmt.clearBindings();
-                stmt.bindLong(1, id);
-                stmt.execute();
-                db.setTransactionSuccessful();
-            } catch (SQLException e) {
-                JqLog.e(e, "called delete with sql exception.");
-            } finally {
-                safeEndTransaction();
-            }
-        }
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int count() {
-        SQLiteStatement stmt = sqlHelper.getCountStatement();
-        synchronized (stmt) {
-            stmt.clearBindings();
-            stmt.bindLong(1, sessionId);
-            return (int) stmt.simpleQueryForLong();
-        }
-    }
-    
-    @Override
-    public int countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups) {
-        String sql = readyJobsQueryCache.get(hasNetwork, excludeGroups);
-        if (sql == null) {
-            String where = createReadyJobWhereSql(hasNetwork, excludeGroups, true);
-            String subSelect = "SELECT count(*) group_cnt, " + DbOpenHelper.GROUP_ID_COLUMN.columnName
-                    + " FROM " + DbOpenHelper.JOB_HOLDER_TABLE_NAME
-                    + " WHERE " + where;
-            sql = "SELECT SUM(case WHEN " + DbOpenHelper.GROUP_ID_COLUMN.columnName
-                    + " is null then group_cnt else 1 end) from (" + subSelect + ")";
-            readyJobsQueryCache.set(sql, hasNetwork, excludeGroups);
-        }
-        Cursor cursor = db.rawQuery(sql, new String[]{Long.toString(sessionId), Long.toString(System.nanoTime())});
-        try {
-            if (!cursor.moveToFirst()) {
-                return 0;
-            }
-            return cursor.getInt(0);
-        } catch (Throwable e) {
-            JqLog.e(e, "count ready jobs with exception.");
-            return 0;
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder findJobById(long id) {
-        Cursor cursor = db.rawQuery(sqlHelper.FIND_BY_ID_QUERY, new String[]{Long.toString(id)});
-        try {
-            if (!cursor.moveToFirst()) {
-                return null;
-            }
-            return createJobHolderFromCursor(cursor);
-        } catch (InvalidJobException e) {
-            JqLog.e(e, "invalid job on findJobById");
-            return null;
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    @Override
-    public Set<JobHolder> findJobsByTags(TagConstraint tagConstraint, boolean excludeCancelled,
-            Collection<Long> exclude, String... tags) {
-        if (tags == null || tags.length == 0) {
-            return Collections.emptySet();
-        }
-        Set<JobHolder> jobs = new HashSet<JobHolder>();
-        int excludeCount = exclude == null ? 0 : exclude.size();
-        if (excludeCancelled) {
-            excludeCount += pendingCancelations.size();
-        }
-        final String query = sqlHelper.createFindByTagsQuery(tagConstraint,
-                excludeCount, tags.length);
-        JqLog.d(query);
-        final String[] args;
-        if (excludeCount == 0) {
-            args = tags;
-        } else {
-            args = new String[excludeCount + tags.length];
-            System.arraycopy(tags, 0, args, 0, tags.length);
-            int i = tags.length;
-            for (Long ex : exclude) {
-                args[i++] = ex.toString();
-            }
-            if (excludeCancelled) {
-                for (Long ex : pendingCancelations) {
-                    args[i++] = ex.toString();
-                }
-            }
-        }
-        Cursor cursor = db.rawQuery(query, args);
-        try {
-            while (cursor.moveToNext()) {
-                jobs.add(createJobHolderFromCursor(cursor));
-            }
-        } catch (InvalidJobException e) {
-            JqLog.e(e, "invalid job found by tags.");
-        } finally {
-            cursor.close();
-        }
-        return jobs;
-    }
-    
-    @Override
-    public void onJobCancelled(JobHolder holder) {
-        pendingCancelations.add(holder.getId());
-        setSessionIdOnJob(holder);
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public JobHolder nextJobAndIncRunCount(boolean hasNetwork, Collection<String> excludeGroups) {
-        //we can even keep these prepared but not sure the cost of them in db layer
-        String selectQuery = nextJobsQueryCache.get(hasNetwork, excludeGroups);
-        if (selectQuery == null) {
-            String where = createReadyJobWhereSql(hasNetwork, excludeGroups, false);
-            selectQuery = sqlHelper.createSelect(
-                    where,
-                    1,
-                    new SqlHelper.Order(DbOpenHelper.PRIORITY_COLUMN,
-                            SqlHelper.Order.Type.DESC),
-                    new SqlHelper.Order(DbOpenHelper.CREATED_NS_COLUMN,
-                            SqlHelper.Order.Type.ASC),
-                    new SqlHelper.Order(DbOpenHelper.ID_COLUMN, SqlHelper.Order.Type.ASC)
-            );
-            nextJobsQueryCache.set(selectQuery, hasNetwork, excludeGroups);
-        }
-        while (true) {
-            Cursor cursor = db.rawQuery(selectQuery,
-                    new String[]{Long.toString(sessionId), Long.toString(System.nanoTime())});
-            try {
-                if (!cursor.moveToFirst()) {
-                    return null;
-                }
-                JobHolder holder = createJobHolderFromCursor(cursor);
-                setSessionIdOnJob(holder);
-                return holder;
-            } catch (InvalidJobException e) {
-                //delete
-                Long jobId = cursor.getLong(0);
-                delete(jobId);
-                return nextJobAndIncRunCount(true, null);
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-    
-    private String createReadyJobWhereSql(boolean hasNetwork, Collection<String> excludeGroups, boolean groupByRunningGroup) {
-        String where = DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnName + " != ? "
-                + " AND " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + " <= ? ";
-        if (hasNetwork == false) {
-            where += " AND " + DbOpenHelper.REQUIRES_NETWORK_COLUMN.columnName + " != 1 ";
-        }
-        String groupConstraint = null;
-        if (excludeGroups != null && excludeGroups.size() > 0) {
-            groupConstraint = DbOpenHelper.GROUP_ID_COLUMN.columnName + " IS NULL OR " +
-                    DbOpenHelper.GROUP_ID_COLUMN.columnName + " NOT IN('" +
-                    SqlHelper.joinStrings("','", excludeGroups) + "')";
-        }
-        if (groupByRunningGroup) {
-            where += " GROUP BY " + DbOpenHelper.GROUP_ID_COLUMN.columnName;
-            if (groupConstraint != null) {
-                where += " HAVING " + groupConstraint;
-            }
-        } else if (groupConstraint != null) {
-            where += " AND ( " + groupConstraint + " )";
-        }
-        return where;
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Long getNextJobDelayUntilNs(boolean hasNetwork, Collection<String> excludeGroups) {
-        boolean hasExcludes = excludeGroups != null && !excludeGroups.isEmpty();
-        if (!hasExcludes) {
-            SQLiteStatement stmt =
-                    hasNetwork ? sqlHelper.getNextJobDelayedUntilWithNetworkStatement()
-                            : sqlHelper.getNextJobDelayedUntilWithoutNetworkStatement();
-            synchronized (stmt) {
-                try {
-                    stmt.clearBindings();
-                    return stmt.simpleQueryForLong();
-                } catch (SQLiteDoneException e) {
-                    return null;
-                }
-            }
-        } else {
-            String sql = nextJobDelayUntilQueryCache.get(hasNetwork, excludeGroups);
-            if (sql == null) {
-                sql = sqlHelper.createNextJobDelayUntilQuery(hasNetwork, excludeGroups);
-                nextJobDelayUntilQueryCache.set(sql, hasNetwork, excludeGroups);
-            }
-            Cursor cursor = db.rawQuery(sql, new String[0]);
-            try {
-                if (!cursor.moveToNext()) {
-                    return null;
-                }
-                return cursor.getLong(0);
-            } finally {
-                cursor.close();
-            }
-        }
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void clear() {
-        db.beginTransaction();
-        try {
-            sqlHelper.truncate();
-            db.setTransactionSuccessful();
-        } catch (SQLException e) {
-            JqLog.e(e, "called clear with sql exception.");
-        } finally {
-            safeEndTransaction();
-        }
-        readyJobsQueryCache.clear();
-        nextJobsQueryCache.clear();
-    }
-    
-    /**
-     * This method is called when a job is pulled to run.
-     * It is properly marked so that it won't be returned from next job queries.
-     * <p/>
-     * Same mechanism is also used for cancelled jobs.
-     *
-     * @param jobHolder
-     */
-    private void setSessionIdOnJob(JobHolder jobHolder) {
-        SQLiteStatement stmt = sqlHelper.getOnJobFetchedForRunningStatement();
-        jobHolder.setRunCount(jobHolder.getRunCount() + 1);
-        jobHolder.setRunningSessionId(sessionId);
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                stmt.clearBindings();
-                stmt.bindLong(1, jobHolder.getRunCount());
-                stmt.bindLong(2, sessionId);
-                stmt.bindLong(3, jobHolder.getId());
-                stmt.execute();
-                db.setTransactionSuccessful();
-            } catch (SQLException e) {
-                JqLog.e(e, "called setSessionIdOnJob with sql exception.");
-            } finally {
-                safeEndTransaction();
-            }
-        }
-    }
-    
-    private JobHolder createJobHolderFromCursor(Cursor cursor) throws InvalidJobException {
-        Job job = safeDeserialize(cursor.getBlob(DbOpenHelper.BASE_JOB_COLUMN.columnIndex));
-        if (job == null) {
-            throw new InvalidJobException();
-        }
-        return new JobHolder(
-                cursor.getLong(DbOpenHelper.ID_COLUMN.columnIndex),
-                cursor.getInt(DbOpenHelper.PRIORITY_COLUMN.columnIndex),
-                cursor.getString(DbOpenHelper.GROUP_ID_COLUMN.columnIndex),
-                cursor.getInt(DbOpenHelper.RUN_COUNT_COLUMN.columnIndex),
-                job,
-                cursor.getLong(DbOpenHelper.CREATED_NS_COLUMN.columnIndex),
-                cursor.getLong(DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnIndex),
-                cursor.getLong(DbOpenHelper.RUNNING_SESSION_ID_COLUMN.columnIndex)
-        );
-        
-    }
-    
-    private void safeEndTransaction() {
-        try {
-            db.endTransaction();
-        } catch (SQLException e) {
-            JqLog.e(e, "end transaction with sql exception.");
-        }
-    }
-    
-    private Job safeDeserialize(byte[] bytes) {
-        try {
-            return jobSerializer.deserialize(bytes);
-        } catch (Throwable t) {
-            JqLog.e(t, "error while deserializing job");
-        }
-        return null;
-    }
-    
-    private byte[] getSerializeJob(JobHolder jobHolder) {
-        return safeSerialize(jobHolder.getJob());
-    }
-    
-    private byte[] safeSerialize(Object object) {
-        try {
-            return jobSerializer.serialize(object);
-        } catch (Throwable t) {
-            JqLog.e(t, "error while serializing object %s", object.getClass().getSimpleName());
-        }
-        return null;
-    }
-    
-    private static class InvalidJobException extends Exception {
-        
-    }
-    
-    public static class JavaSerializer implements JobSerializer {
-        
-        @Override
-        public byte[] serialize(Object object) throws IOException {
-            if (object == null) {
-                return null;
-            }
-            ByteArrayOutputStream bos = null;
-            try {
-                ObjectOutput out = null;
-                bos = new ByteArrayOutputStream();
-                out = new ObjectOutputStream(bos);
-                out.writeObject(object);
-                // Get the bytes of the serialized object
-                return bos.toByteArray();
-            } finally {
-                if (bos != null) {
-                    bos.close();
-                }
-            }
-        }
-        
-        @Override
-        public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
-            if (bytes == null || bytes.length == 0) {
-                return null;
-            }
-            ObjectInputStream in = null;
-            try {
-                in = new ObjectInputStream(new ByteArrayInputStream(bytes));
-                return (T) in.readObject();
-            } finally {
-                if (in != null) {
-                    in.close();
-                }
-            }
-        }
-    }
-    
-    public static interface JobSerializer {
-        public byte[] serialize(Object object) throws IOException;
-        
-        public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException;
-    }
-}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/BatchingSchedulerTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/BatchingSchedulerTest.java
new file mode 100644
index 0000000..6f8404e
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/BatchingSchedulerTest.java
@@ -0,0 +1,118 @@
+package com.birbit.android.jobqueue;
+
+import android.content.Context;
+
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.mockito.Mockito.*;
+import static com.birbit.android.jobqueue.BatchingScheduler.DEFAULT_BATCHING_PERIOD_IN_MS;
+@RunWith(JUnit4.class)
+public class BatchingSchedulerTest {
+    BatchingScheduler bs;
+    Scheduler scheduler;
+    @Before
+    public void init() {
+        scheduler = mock(Scheduler.class);
+        MockTimer timer = new MockTimer();
+        bs = new BatchingScheduler(scheduler, timer);
+        Context context = mock(Context.class);
+        when(context.getApplicationContext()).thenReturn(mock(Context.class));
+        bs.init(context, mock(Scheduler.Callback.class));
+    }
+
+    @Test
+    public void testAddOne() {
+        SchedulerConstraint constraint = new SchedulerConstraint("abc");
+        constraint.setDelayInMs(0);
+        constraint.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        bs.request(constraint);
+        verify(scheduler, times(1)).request(constraint);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+    }
+
+    @Test
+    public void testAddTwoOfTheSame() {
+        SchedulerConstraint constraint = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint);
+        SchedulerConstraint constraint2 = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint2);
+        verify(scheduler, times(1)).request(constraint);
+        verify(scheduler, times(0)).request(constraint2);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+    }
+
+    @Test
+    public void testAddTwoOfTheSameWithDelay() {
+        SchedulerConstraint constraint = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint);
+        SchedulerConstraint constraint2 = createConstraint(NetworkUtil.METERED, 100);
+        bs.request(constraint2);
+        verify(scheduler, times(1)).request(constraint);
+        verify(scheduler, times(0)).request(constraint2);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+    }
+
+    @Test
+    public void testAddTwoOfTheSameWithEnoughDelay() {
+        SchedulerConstraint constraint = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint);
+        SchedulerConstraint constraint2 = createConstraint(NetworkUtil.METERED,
+                BatchingScheduler.DEFAULT_BATCHING_PERIOD_IN_MS);
+        bs.request(constraint2);
+        verify(scheduler, times(1)).request(constraint);
+        verify(scheduler, times(1)).request(constraint2);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+        MatcherAssert.assertThat(constraint2.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS * 2));
+    }
+
+    @Test
+    public void testAddTwoWithDifferentNetwork() {
+        SchedulerConstraint constraint = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint);
+        SchedulerConstraint constraint2 = createConstraint(NetworkUtil.UNMETERED, 0);
+        bs.request(constraint2);
+        verify(scheduler, times(1)).request(constraint);
+        verify(scheduler, times(1)).request(constraint2);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+        MatcherAssert.assertThat(constraint2.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+    }
+
+    @Test
+    public void testAddRemoveThenAddAgainOfTheSame() {
+        SchedulerConstraint constraint = createConstraint(NetworkUtil.METERED, 0);
+        bs.request(constraint);
+        verify(scheduler, times(1)).request(constraint);
+        MatcherAssert.assertThat(constraint.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+        bs.onFinished(constraint, false);
+        SchedulerConstraint constraint2 = createConstraint(NetworkUtil.METERED, 2);
+        bs.request(constraint2);
+
+        verify(scheduler, times(1)).request(constraint2);
+        MatcherAssert.assertThat(constraint2.getDelayInMs(),
+                CoreMatchers.is(DEFAULT_BATCHING_PERIOD_IN_MS));
+    }
+
+    private static SchedulerConstraint createConstraint(int networkStatus, long delay) {
+        SchedulerConstraint constraint = new SchedulerConstraint("abc");
+        constraint.setDelayInMs(delay);
+        constraint.setNetworkStatus(networkStatus);
+        return constraint;
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerControllerTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerControllerTest.java
new file mode 100644
index 0000000..314cdd3
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerControllerTest.java
@@ -0,0 +1,5 @@
+package com.birbit.android.jobqueue;
+
+public class ConsumerControllerTest {
+
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerTest.java
new file mode 100644
index 0000000..764f0a5
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/ConsumerTest.java
@@ -0,0 +1,132 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.ConsumerManager.Consumer;
+import com.birbit.android.jobqueue.messaging.Message;
+import com.birbit.android.jobqueue.messaging.MessageFactory;
+import com.birbit.android.jobqueue.messaging.MessageQueue;
+import com.birbit.android.jobqueue.messaging.MessageQueueConsumer;
+import com.birbit.android.jobqueue.messaging.PriorityMessageQueue;
+import com.birbit.android.jobqueue.messaging.SafeMessageQueue;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.messaging.message.JobConsumerIdleMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobMessage;
+import com.birbit.android.jobqueue.messaging.message.RunJobResultMessage;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+
+import org.fest.reflect.core.Reflection;
+import org.hamcrest.CoreMatchers;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public class ConsumerTest {
+    MessageFactory factory = new MessageFactory();
+    MockTimer timer = new MockTimer();
+
+    private MessageQueueConsumer dummyConsumer = new MessageQueueConsumer() {
+        @Override
+        public void handleMessage(Message message) {
+
+        }
+
+        @Override
+        public void onIdle() {
+
+        }
+    };
+
+    @Test
+    public void init() {
+        PriorityMessageQueue pmq = mock(PriorityMessageQueue.class);
+        SafeMessageQueue mq = mock(SafeMessageQueue.class);
+        Consumer consumer = new Consumer(
+                pmq, mq, factory, timer);
+        consumer.run();
+        verify(mq).consume(any(MessageQueueConsumer.class));
+    }
+
+    private void setRunning(MessageQueue mq) {
+        Reflection.field("running").ofType(AtomicBoolean.class).in(mq).get().set(true);
+    }
+
+    @Test
+    public void idleMessage() {
+        MessageFactory factory = new MessageFactory();
+        PriorityMessageQueue pmq = new PriorityMessageQueue(timer, factory);
+        SafeMessageQueue mq = new SafeMessageQueue(timer, factory, "test");
+        setRunning(pmq);
+        setRunning(mq);
+        timer.setNow(2001);
+        Consumer consumer = new Consumer(pmq, mq, factory, timer);
+        consumer.queueConsumer.onIdle();
+        Message message = pmq.next(dummyConsumer);
+        assertThat(message, CoreMatchers.instanceOf(JobConsumerIdleMessage.class));
+        assertThat(((JobConsumerIdleMessage) message).getLastJobCompleted(), CoreMatchers.is(2001L));
+    }
+
+    @Test
+    public void runJobMessage() {
+        MessageFactory factory = new MessageFactory();
+        PriorityMessageQueue pmq = new PriorityMessageQueue(timer, factory);
+        setRunning(pmq);
+        SafeMessageQueue mq = new SafeMessageQueue(timer, factory, "test");
+        setRunning(mq);
+        timer.setNow(2001);
+        Consumer consumer = new Consumer(pmq, mq, factory, timer);
+        RunJobMessage rjm = factory.obtain(RunJobMessage.class);
+        JobHolder mockHolder = mock(JobHolder.class);
+        when(mockHolder.safeRun(0)).thenReturn(JobHolder.RUN_RESULT_SUCCESS);
+        rjm.setJobHolder(mockHolder);
+        timer.setNow(3001);
+        consumer.queueConsumer.handleMessage(rjm);
+
+        Message message = pmq.next(dummyConsumer);
+        assertThat(message, CoreMatchers.instanceOf(RunJobResultMessage.class));
+        RunJobResultMessage result = (RunJobResultMessage) message;
+        assertThat(result.getResult(), CoreMatchers.is(JobHolder.RUN_RESULT_SUCCESS));
+        assertThat(result.getJobHolder(), CoreMatchers.is(mockHolder));
+        assertThat(consumer.lastJobCompleted, CoreMatchers.is(3001L));
+    }
+
+    @Test
+    public void removePokesAfterJobTest() {
+        MessageFactory factory = new MessageFactory();
+        PriorityMessageQueue pmq = new PriorityMessageQueue(timer, factory);
+        setRunning(pmq);
+        SafeMessageQueue mq = spy(new SafeMessageQueue(timer, factory, "test"));
+        setRunning(mq);
+        timer.setNow(2001);
+        Consumer consumer = new Consumer(pmq, mq, factory, timer);
+        RunJobMessage rjm = factory.obtain(RunJobMessage.class);
+        JobHolder mockHolder = mock(JobHolder.class);
+        when(mockHolder.safeRun(0)).thenReturn(JobHolder.RUN_RESULT_SUCCESS);
+        rjm.setJobHolder(mockHolder);
+        timer.setNow(3001);
+        verify(mq, times(0)).cancelMessages(Consumer.pokeMessagePredicate);
+        consumer.queueConsumer.handleMessage(rjm);
+        verify(mq, times(1)).cancelMessages(Consumer.pokeMessagePredicate);
+    }
+
+    @Test
+    public void pokePredicateTest() {
+        CommandMessage cm = new CommandMessage();
+        cm.set(CommandMessage.POKE);
+        assertThat(Consumer.pokeMessagePredicate.onMessage(cm), CoreMatchers.is(true));
+        cm.set(CommandMessage.QUIT);
+        assertThat(Consumer.pokeMessagePredicate.onMessage(cm), CoreMatchers.is(false));
+        assertThat(Consumer.pokeMessagePredicate.onMessage(new RunJobMessage()),
+                CoreMatchers.is(false));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/JobManagerThreadRunnable.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/JobManagerThreadRunnable.java
new file mode 100644
index 0000000..305313b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/JobManagerThreadRunnable.java
@@ -0,0 +1,64 @@
+package com.birbit.android.jobqueue;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public abstract class JobManagerThreadRunnable<T> {
+    JobManager jobManager;
+    AtomicBoolean running = new AtomicBoolean(false);
+    public JobManagerThreadRunnable(JobManager jobManager) {
+        this.jobManager = jobManager;
+    }
+
+    private void assertRunning() {
+        MatcherAssert.assertThat("can call this method only inside #onRun", running.get(),
+                CoreMatchers.is(true));
+    }
+
+    protected JobHolder getNextJob() {
+        assertRunning();
+        return jobManager.jobManagerThread.getNextJobForTesting();
+    }
+
+    protected JobHolder getNextJob(Collection<String> exclude) {
+        assertRunning();
+        return jobManager.jobManagerThread.getNextJobForTesting(exclude);
+    }
+
+    protected void removeJob(JobHolder jobHolder) {
+        assertRunning();
+        jobManager.jobManagerThread.nonPersistentJobQueue.remove(jobHolder);
+        jobManager.jobManagerThread.persistentJobQueue.remove(jobHolder);
+    }
+
+    protected JobHolder findJobFromQueues(String id) {
+        assertRunning();
+        JobHolder holder = jobManager.jobManagerThread.nonPersistentJobQueue.findJobById(id);
+        if (holder != null) {
+            return holder;
+        }
+        return jobManager.jobManagerThread.persistentJobQueue.findJobById(id);
+    }
+
+    public T run() throws Throwable {
+        final Object[] result = new Object[1];
+        jobManager.internalRunInJobManagerThread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    running.set(true);
+                    result[0] = onRun();
+                } finally {
+                    running.set(false);
+                }
+            }
+        });
+        //noinspection unchecked
+        return (T) result[0];
+    }
+
+    public abstract T onRun();
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/SystemTimerTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/SystemTimerTest.java
new file mode 100644
index 0000000..58e1cee
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/SystemTimerTest.java
@@ -0,0 +1,80 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.timer.SystemTimer;
+
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import android.annotation.SuppressLint;
+
+import java.util.concurrent.TimeUnit;
+
+@RunWith(JUnit4.class)
+public class SystemTimerTest {
+    @SuppressLint({"DIRECT_TIME_ACCESS","SLEEP_IN_CODE"})
+    @Test
+    public void testNow() throws Throwable {
+        SystemTimer timer = new SystemTimer();
+        //noinspection DIRECT_TIME_ACCESS
+        long startNs = System.nanoTime();
+        //noinspection DIRECT_TIME_ACCESS
+        long start = TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis());
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(3000);
+        assertReasonable(timer.nanoTime(), System.nanoTime() - startNs + start);
+        SystemTimer timer2 = new SystemTimer();
+        assertReasonable(timer2.nanoTime(), System.nanoTime() - startNs + start);
+    }
+
+    @SuppressLint("DIRECT_TIME_ACCESS")
+    @Test
+    public void testWaitOnObject() throws Throwable {
+        SystemTimer timer = new SystemTimer();
+        //noinspection DIRECT_TIME_ACCESS
+        long startRealTime = System.nanoTime();
+        long startNs = timer.nanoTime();
+        long waitNs = JobManager.NS_PER_MS * 3000;
+        long waitUntil = startNs + waitNs;
+        final Object object = new Object();
+        synchronized (object) {
+            timer.waitOnObjectUntilNs(object, waitUntil);
+        }
+        assertBetween(System.nanoTime() - startRealTime, waitNs, waitNs + 2000 * JobManager.NS_PER_MS);
+    }
+
+    public void assertBetween(long value, long min, long max) {
+        MatcherAssert.assertThat("expected value should be in range", value,
+                new Range(min, max));
+    }
+
+
+    public void assertReasonable(long value, long expected) {
+        long deviation = JobManager.NS_PER_MS * 1500;
+        assertBetween(value, expected - deviation, expected + deviation);
+    }
+
+    static class Range extends BaseMatcher<Long> {
+        final long min, max;
+        public Range(long min, long max) {
+            this.min = min;
+            this.max = max;
+        }
+
+        @Override
+        public boolean matches(Object item) {
+            long value = (long) item;
+            return value >= min && value <= max;
+        }
+
+        @Override
+        public void describeTo(Description description) {
+            description.appendText("should be between").appendValue(min).appendText(" and ")
+                    .appendValue(max);
+        }
+    }
+
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/TestConstraint.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/TestConstraint.java
new file mode 100644
index 0000000..00eb1e4
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/TestConstraint.java
@@ -0,0 +1,72 @@
+package com.birbit.android.jobqueue;
+
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.Collection;
+
+public class TestConstraint extends Constraint {
+    Timer timer;
+    public TestConstraint(Timer timer) {
+        this.timer = timer;
+    }
+
+    @Override
+    public void setShouldNotRequireNetwork(boolean shouldNotRequireNetwork) {
+        super.setShouldNotRequireNetwork(shouldNotRequireNetwork);
+    }
+
+    @Override
+    public void setTagConstraint(TagConstraint tagConstraint) {
+        super.setTagConstraint(tagConstraint);
+    }
+
+    @Override
+    public void setExcludeRunning(boolean excludeRunning) {
+        super.setExcludeRunning(excludeRunning);
+    }
+
+    @Override
+    public void setShouldNotRequireUnmeteredNetwork(boolean shouldNotRequireUnmeteredNetwork) {
+        super.setShouldNotRequireUnmeteredNetwork(shouldNotRequireUnmeteredNetwork);
+    }
+
+    @Override
+    public void setTags(String[] tags) {
+        super.setTags(tags);
+    }
+
+    @Override
+    public void setExcludeGroups(Collection<String> excludeGroups) {
+        super.setExcludeGroups(excludeGroups);
+    }
+
+    @Override
+    public void setExcludeJobIds(Collection<String> jobsIds) {
+        super.setExcludeJobIds(jobsIds);
+    }
+
+    @Override
+    public void clear() {
+        super.clear();
+    }
+
+    @Override
+    public long getNowInNs() {
+        return timer.nanoTime();
+    }
+
+    @Override
+    public void setTimeLimit(Long timeLimit) {
+        super.setTimeLimit(timeLimit);
+    }
+
+    public static TestConstraint forTags(Timer timer, TagConstraint tagConstraint,
+            Collection<String> excludeIds, String... tags) {
+        TestConstraint constraint = new TestConstraint(timer);
+        constraint.setTagConstraint(tagConstraint);
+        constraint.setExcludeJobIds(excludeIds);
+        constraint.setTags(tags);
+        return constraint;
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagAddTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagAddTest.java
new file mode 100644
index 0000000..e35d7c6
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagAddTest.java
@@ -0,0 +1,88 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@RunWith(Parameterized.class)
+public class DelayedMessageBagAddTest {
+    MessageFactory factory = new MessageFactory();
+    DelayedMessageBag bag = new DelayedMessageBag(factory);
+
+    List<Long> ordered;
+    Map<Long, Message> added = new HashMap<>();
+
+    public DelayedMessageBagAddTest(List<Long> ordered) {
+        this.ordered = ordered;
+    }
+
+    @Parameterized.Parameters(name = "{0}")
+    static public List<List<Long>> params() {
+        List<List<Long>> result = new ArrayList<>();
+        for (int a = 0; a < 3; a++) {
+
+            for (int b = 0; b < 3; b ++) {
+                if (b == a) {
+                    continue;
+                }
+                for (int c = 0; c < 3; c ++) {
+                    if (c == a || c == b) {
+                        continue;
+                    }
+                    Long[] items = new Long[3];
+                    items[a] = 1000L;
+                    items[b] = 2000L;
+                    items[c] = 3000L;
+                    result.add(Arrays.asList(items));
+                }
+            }
+        }
+        return result;
+    }
+
+    @Test
+    public void testAddOrdered() {
+        for (Long readyNs : ordered) {
+            add(readyNs);
+        }
+        Message m1 = added.get(1000L);
+        Message m2 = added.get(2000L);
+        Message m3 = added.get(3000L);
+        assertThat(m1, CoreMatchers.notNullValue());
+        assertThat(m2, CoreMatchers.notNullValue());
+        assertThat(m3, CoreMatchers.notNullValue());
+        MessageQueue mq = mock(MessageQueue.class);
+        long t1 = bag.flushReadyMessages(500, mq);
+        assertThat(t1, CoreMatchers.is(1000L));
+        verify(mq, times(0)).post(any(Message.class));
+        long t2 = bag.flushReadyMessages(1000, mq);
+        assertThat(t2, CoreMatchers.is(2000L));
+        verify(mq).post(m1);
+        Long t3 = bag.flushReadyMessages(3001, mq);
+        assertThat(t3, CoreMatchers.nullValue());
+        verify(mq).post(m2);
+        verify(mq).post(m3);
+    }
+
+    private Message add(long readyNs) {
+        CommandMessage msg = factory.obtain(CommandMessage.class);
+        bag.add(msg, readyNs);
+        added.put(readyNs, msg);
+        return msg;
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRecycleTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRecycleTest.java
new file mode 100644
index 0000000..86780c6
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRecycleTest.java
@@ -0,0 +1,41 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.mockito.Mockito.*;
+@RunWith(JUnit4.class)
+public class DelayedMessageBagRecycleTest {
+    MessageFactory factory = spy(new MessageFactory());
+    DelayedMessageBag bag = new DelayedMessageBag(factory);
+
+    @Test
+    public void recycleOnClear() {
+        CommandMessage cm = factory.obtain(CommandMessage.class);
+        cm.set(CommandMessage.POKE);
+        bag.add(cm, 1000);
+        bag.clear();
+        verify(factory).release(cm);
+    }
+
+    @Test
+    public void recycleOnCancel() {
+        final CommandMessage cm = factory.obtain(CommandMessage.class);
+        cm.set(CommandMessage.POKE);
+        bag.add(cm, 1000);
+
+        final CommandMessage cm2 = factory.obtain(CommandMessage.class);
+        cm2.set(CommandMessage.POKE);
+        bag.add(cm2, 1000);
+        bag.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return message == cm;
+            }
+        });
+        verify(factory).release(cm);
+        verify(factory, times(0)).release(cm2);
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRemoveTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRemoveTest.java
new file mode 100644
index 0000000..149adfd
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/DelayedMessageBagRemoveTest.java
@@ -0,0 +1,108 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Matchers.same;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@RunWith(JUnit4.class)
+public class DelayedMessageBagRemoveTest {
+    MessageFactory factory = new MessageFactory();
+    DelayedMessageBag bag = new DelayedMessageBag(factory);
+    List<Long> items = Arrays.asList(1000L, 2000L, 3000L);
+    Map<Long, Message> added = new HashMap<>();
+
+    @Test
+    public void testRemoveAll() {
+        for (Long readyNs : items) {
+            add(readyNs);
+        }
+        bag.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return true;
+            }
+        });
+        MessageQueue mq = mock(MessageQueue.class);
+        Long t1 = bag.flushReadyMessages(500, mq);
+        assertThat(t1, CoreMatchers.nullValue());
+        bag.flushReadyMessages(4000, mq);
+        verify(mq, times(0)).post(any(Message.class));
+    }
+
+    @Test
+    public void testRemoveNothing() {
+        for (Long readyNs : items) {
+            add(readyNs);
+        }
+        bag.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return false;
+            }
+        });
+        MessageQueue mq = mock(MessageQueue.class);
+        long t1 = bag.flushReadyMessages(500, mq);
+        assertThat(t1, CoreMatchers.is(1000L));
+        bag.flushReadyMessages(4000, mq);
+        verify(mq, times(3)).post(any(Message.class));
+    }
+
+    @Test
+    public void testRemoveUnmatch() {
+        testRemove(0, 1000, 2000, 3000);
+    }
+
+    @Test
+    public void testRemove1000() {
+        testRemove(1000, 2000, 3000);
+    }
+
+    @Test
+    public void testRemove2000() {
+        testRemove(2000, 1000, 3000);
+    }
+
+    @Test
+    public void testRemove3000() {
+        testRemove(3000, 1000, 2000);
+    }
+
+    public void testRemove(final long itemToRemove, long... toBeReceived) {
+        for (Long readyNs : items) {
+            add(readyNs);
+        }
+        bag.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return message.readyNs == itemToRemove;
+            }
+        });
+        MessageQueue mq = mock(MessageQueue.class);
+        bag.flushReadyMessages(4000, mq);
+        for (long item : toBeReceived) {
+            verify(mq).post(same(added.get(item)));
+        }
+    }
+
+    private Message add(long readyNs) {
+        CommandMessage msg = factory.obtain(CommandMessage.class);
+        bag.add(msg, readyNs);
+        added.put(readyNs, msg);
+        return msg;
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageFactoryTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageFactoryTest.java
new file mode 100644
index 0000000..c9a353b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageFactoryTest.java
@@ -0,0 +1,30 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+@RunWith(JUnit4.class)
+public class MessageFactoryTest {
+    MessageFactory factory = new MessageFactory();
+    @Test
+    public void test() {
+        AddJobMessage aj1 = factory.obtain(AddJobMessage.class);
+        assertThat(aj1, isA(AddJobMessage.class));
+        CommandMessage cm1 = factory.obtain(CommandMessage.class);
+        assertThat(cm1, isA(CommandMessage.class));
+        assertThat(factory.obtain(AddJobMessage.class), not(sameInstance(aj1)));
+        assertThat(factory.obtain(CommandMessage.class), not(sameInstance(cm1)));
+        factory.release(aj1);
+        factory.release(cm1);
+        assertThat(factory.obtain(AddJobMessage.class), sameInstance(aj1));
+        assertThat(factory.obtain(CommandMessage.class), sameInstance(cm1));
+        assertThat(factory.obtain(AddJobMessage.class), not(sameInstance(aj1)));
+        assertThat(factory.obtain(CommandMessage.class), not(sameInstance(cm1)));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageQueueTestBase.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageQueueTestBase.java
new file mode 100644
index 0000000..49762ef
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/MessageQueueTestBase.java
@@ -0,0 +1,273 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.testing.CleanupRule;
+import com.birbit.android.jobqueue.testing.ThreadDumpRule;
+import com.birbit.android.jobqueue.test.TestBase;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import junit.framework.Assert;
+import junit.framework.AssertionFailedError;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Factory;
+import org.hamcrest.MatcherAssert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import static org.mockito.Mockito.*;
+import static org.hamcrest.MatcherAssert.*;
+
+
+import static org.hamcrest.MatcherAssert.assertThat;
+
+abstract public class MessageQueueTestBase<T extends MessageQueue> {
+    @Rule public Timeout timeout = Timeout.seconds(60);
+    @Rule public ThreadDumpRule threadDump = new ThreadDumpRule();
+    abstract T createMessageQueue(Timer timer, MessageFactory factory);
+    @Test
+    public void postDelayed() throws InterruptedException {
+
+        MockTimer timer = new MockTimer();
+        final T mq = createMessageQueue(timer, new MessageFactory());
+        final CountDownLatch idleLatch = new CountDownLatch(1);
+        final Throwable[] exception = new Throwable[1];
+        final MessageQueueConsumer mqConsumer = new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+
+            }
+
+            @Override
+            public void onIdle() {
+                try {
+                    assertThat(idleLatch.getCount(), CoreMatchers.is(1L));
+                } catch (Throwable t) {
+                    exception[0] = t;
+                } finally {
+                    idleLatch.countDown();
+                }
+
+            }
+        };
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                mq.consume(mqConsumer);
+            }
+        });
+        thread.start();
+        assertThat(idleLatch.await(10, TimeUnit.SECONDS), CoreMatchers.is(true));
+        timer.incrementMs(1000000);
+        Thread.sleep(1000);
+        mq.stop();
+        thread.join(5000);
+        assertThat(exception[0], CoreMatchers.nullValue());
+        assertThat(thread.isAlive(), CoreMatchers.is(false));
+    }
+
+    @Test
+    public void recycleOnClear() {
+        MessageFactory factory = spy(new MessageFactory());
+        MockTimer mockTimer = new MockTimer();
+        T mq = createMessageQueue(mockTimer, factory);
+        CommandMessage cm = factory.obtain(CommandMessage.class);
+        cm.set(CommandMessage.POKE);
+        mq.post(cm);
+        mq.clear();
+        verify(factory).release(cm);
+    }
+
+    @Test
+    public void recycleOnConsume() {
+        MessageFactory factory = spy(new MessageFactory());
+        MockTimer mockTimer = new MockTimer();
+        final T mq = createMessageQueue(mockTimer, factory);
+        CommandMessage cm = factory.obtain(CommandMessage.class);
+        cm.set(CommandMessage.POKE);
+        mq.post(cm);
+        mq.consume(new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                mq.stop();
+            }
+
+            @Override
+            public void onIdle() {
+
+            }
+        });
+        verify(factory).release(cm);
+    }
+
+    @Test
+    public void recycleOnCancel() {
+        MessageFactory factory = spy(new MessageFactory());
+        MockTimer mockTimer = new MockTimer();
+        final T mq = createMessageQueue(mockTimer, factory);
+        final CommandMessage cm = factory.obtain(CommandMessage.class);
+        cm.set(CommandMessage.POKE);
+        mq.post(cm);
+
+        final CommandMessage cm2 = factory.obtain(CommandMessage.class);
+        cm2.set(CommandMessage.POKE);
+        mq.post(cm2);
+        mq.cancelMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return message == cm;
+            }
+        });
+        verify(factory).release(cm);
+        verify(factory, times(0)).release(cm2);
+    }
+
+    @Test
+    public void addMessageOnIdle() throws InterruptedException {
+        addMessageOnIdle(false);
+    }
+
+    @Test
+    public void addDelayedMessageOnIdle() throws InterruptedException {
+        addMessageOnIdle(true);
+    }
+
+    private void addMessageOnIdle(final boolean delayed) throws InterruptedException {
+        final MockTimer timer = new MockTimer();
+        final MessageQueue mq = createMessageQueue(timer, new MessageFactory());
+        final CountDownLatch idleLatch = new CountDownLatch(1);
+        final CountDownLatch runLatch = new CountDownLatch(1);
+        final MessageQueueConsumer mqConsumer = new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                if (message.type == Type.COMMAND && ((CommandMessage) message).getWhat() == CommandMessage.POKE) {
+                    runLatch.countDown();
+                }
+            }
+
+            @Override
+            public void onIdle() {
+                if (idleLatch.getCount() == 1) {
+                    CommandMessage cm = new CommandMessage();
+                    cm.set(CommandMessage.POKE);
+                    if (delayed) {
+                        mq.postAt(cm, timer.nanoTime() + 100000);
+                    } else {
+                        mq.post(cm);
+                    }
+
+                    idleLatch.countDown();
+                }
+            }
+        };
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                mq.consume(mqConsumer);
+            }
+        });
+        thread.start();
+        assertThat(idleLatch.await(10, TimeUnit.SECONDS), CoreMatchers.is(true));
+        timer.incrementMs(1000000);
+        assertThat(runLatch.await(10, TimeUnit.SECONDS), CoreMatchers.is(true));
+        mq.stop();
+        thread.join(5000);
+        if (thread.isAlive()) {
+            threadDump.failed(new AssertionFailedError("thread did not die"), null);
+        }
+        assertThat(thread.isAlive(), CoreMatchers.is(false));
+    }
+
+    @Test
+    public void postAtNoIdleCall() throws InterruptedException {
+        final MockTimer timer = new MockTimer();
+        final MessageQueue mq = createMessageQueue(timer, new MessageFactory());
+        final CountDownLatch idleLatch = new CountDownLatch(1);
+        final CountDownLatch firstIdleLatch = new CountDownLatch(1);
+        final CountDownLatch runLatch = new CountDownLatch(1);
+        final MessageQueueConsumer mqConsumer = new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                if (message.type == Type.COMMAND &&
+                        ((CommandMessage) message).getWhat() == CommandMessage.POKE) {
+                    runLatch.countDown();
+                }
+            }
+
+            @Override
+            public void onIdle() {
+                if (firstIdleLatch.getCount() == 1) {
+                    firstIdleLatch.countDown();
+                } else {
+                    idleLatch.countDown();
+                }
+            }
+        };
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                mq.consume(mqConsumer);
+            }
+        });
+        thread.start();
+        firstIdleLatch.await();
+        CommandMessage cm = new CommandMessage();
+        cm.set(CommandMessage.POKE);
+        mq.postAt(cm, 100);
+        assertThat(idleLatch.await(3, TimeUnit.SECONDS), CoreMatchers.is(false));
+        timer.incrementNs(100);
+        assertThat(idleLatch.await(3, TimeUnit.SECONDS), CoreMatchers.is(true));
+        mq.stop();
+        thread.join();
+    }
+
+    @Test
+    public void postWhileIdle() throws InterruptedException {
+        final MockTimer timer = new MockTimer();
+        final MessageQueue mq = createMessageQueue(timer, new MessageFactory());
+        final CountDownLatch idleEnterLatch = new CountDownLatch(1);
+        final CountDownLatch idleExitLatch = new CountDownLatch(1);
+        final CountDownLatch handleMessage = new CountDownLatch(1);
+        final CommandMessage cm = new CommandMessage();
+        cm.set(CommandMessage.POKE);
+        final MessageQueueConsumer consumer = new MessageQueueConsumer() {
+            @Override
+            public void handleMessage(Message message) {
+                if (message == cm) {
+                    handleMessage.countDown();
+                }
+            }
+
+            @Override
+            public void onIdle() {
+                idleEnterLatch.countDown();
+                try {
+                    idleExitLatch.await();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        };
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                mq.consume(consumer);
+            }
+        });
+        thread.start();
+        MatcherAssert.assertThat(idleEnterLatch.await(30, TimeUnit.SECONDS), CoreMatchers.is(true));
+        mq.post(cm);
+        idleExitLatch.countDown();
+        MatcherAssert.assertThat(handleMessage.await(30, TimeUnit.SECONDS), CoreMatchers.is(true));
+        mq.stop();
+        thread.join(5000);
+        assertThat(thread.isAlive(), CoreMatchers.is(false));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueueTest.java
new file mode 100644
index 0000000..abf1592
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/PriorityMessageQueueTest.java
@@ -0,0 +1,54 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+@RunWith(JUnit4.class)
+public class PriorityMessageQueueTest extends MessageQueueTestBase<PriorityMessageQueue> {
+    PriorityMessageQueue mq = new PriorityMessageQueue(new MockTimer(), new MessageFactory());
+
+    @Test
+    public void test1() {
+        CommandMessage mC1 = new CommandMessage();
+        CommandMessage mC2 = new CommandMessage();
+        AddJobMessage aj1 = new AddJobMessage();
+        AddJobMessage aj2 = new AddJobMessage();
+        mq.post(mC1);
+        mq.post(mC2);
+        mq.post(aj1);
+        mq.post(aj2);
+        final List<Message> expectedOrder = Arrays.asList(aj1, aj2, mC1, mC2);
+        mq.consume(new MessageQueueConsumer() {
+            int index;
+            @Override
+            public void handleMessage(Message message) {
+                assertThat(message, is (expectedOrder.get(index++)));
+                if (index == expectedOrder.size()) {
+                    mq.stop();
+                }
+            }
+
+            @Override
+            public void onIdle() {
+
+            }
+        });
+    }
+
+    @Override
+    PriorityMessageQueue createMessageQueue(Timer timer, MessageFactory factory) {
+        return new PriorityMessageQueue(timer, factory);
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/SafeMessageQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/SafeMessageQueueTest.java
new file mode 100644
index 0000000..d792649
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/SafeMessageQueueTest.java
@@ -0,0 +1,11 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.timer.Timer;
+
+public class SafeMessageQueueTest extends MessageQueueTestBase<SafeMessageQueue> {
+
+    @Override
+    SafeMessageQueue createMessageQueue(Timer timer, MessageFactory factory) {
+        return new SafeMessageQueue(timer, factory, "test");
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueueTest.java
new file mode 100644
index 0000000..a938c63
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/messaging/UnsafeMessageQueueTest.java
@@ -0,0 +1,128 @@
+package com.birbit.android.jobqueue.messaging;
+
+import com.birbit.android.jobqueue.messaging.message.CommandMessage;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.isNull;
+import static org.mockito.Matchers.same;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@RunWith(JUnit4.class)
+public class UnsafeMessageQueueTest {
+    UnsafeMessageQueue mq = new UnsafeMessageQueue(new MessageFactory(), "test");
+    List<Long> items = Arrays.asList(1000L, 2000L, 3000L);
+    Map<Long, Message> added = new HashMap<>();
+    
+    @Test
+    public void simplePost() {
+        Message m = new CommandMessage();
+        Message m2 = new CommandMessage();
+        Message m3 = new CommandMessage();
+        mq.post(m);
+        mq.post(m2);
+        mq.post(m3);
+        assertThat(mq.next(), is(m));
+        assertThat(mq.next(), is(m2));
+        assertThat(mq.next(), is(m3));
+    }
+
+    @Test
+    public void simplePostAtFront() {
+        Message m = new CommandMessage();
+        Message m2 = new CommandMessage();
+        Message m3 = new CommandMessage();
+        mq.postAtFront(m);
+        mq.postAtFront(m2);
+        mq.postAtFront(m3);
+        assertThat(mq.next(), is(m3));
+        assertThat(mq.next(), is(m2));
+        assertThat(mq.next(), is(m));
+    }
+
+    @Test
+    public void testRemoveAll() {
+        for (Long readyNs : items) {
+            add(readyNs);
+        }
+        mq.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return true;
+            }
+        });
+        assertThat(mq.next(), nullValue());
+    }
+
+    @Test
+    public void testRemoveNothing() {
+        for (Long readyNs : items) {
+            add(readyNs);
+        }
+        mq.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return false;
+            }
+        });
+        assertThat(mq.next(), sameInstance(added.get(1000L)));
+        assertThat(mq.next(), sameInstance(added.get(2000L)));
+        assertThat(mq.next(), sameInstance(added.get(3000L)));
+    }
+
+    @Test
+    public void testRemoveUnmatch() {
+        testRemove(0, 1000, 2000, 3000);
+    }
+
+    @Test
+    public void testRemove1000() {
+        testRemove(1000, 2000, 3000);
+    }
+
+    @Test
+    public void testRemove2000() {
+        testRemove(2000, 1000, 3000);
+    }
+
+    @Test
+    public void testRemove3000() {
+        testRemove(3000, 1000, 2000);
+    }
+
+    public void testRemove(final long itemToRemove, long... toBeReceived) {
+        for (Long id : items) {
+            add(id);
+        }
+        mq.removeMessages(new MessagePredicate() {
+            @Override
+            public boolean onMessage(Message message) {
+                return message == added.get(itemToRemove);
+            }
+        });
+        for (long item : toBeReceived) {
+            assertThat(mq.next(), is(added.get(item)));
+        }
+        assertThat(mq.next(), nullValue());
+    }
+
+    private Message add(long id) {
+        CommandMessage msg = new CommandMessage();
+        mq.post(msg);
+        added.put(id, msg);
+        return msg;
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/TestBase.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/TestBase.java
new file mode 100644
index 0000000..fd998b9
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/TestBase.java
@@ -0,0 +1,101 @@
+package com.birbit.android.jobqueue.test;
+
+import android.util.Log;
+
+import com.birbit.android.jobqueue.testing.StackTraceRule;
+import com.birbit.android.jobqueue.log.CustomLogger;
+import com.birbit.android.jobqueue.log.JqLog;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.robolectric.shadows.ShadowLog;
+
+public class TestBase {
+    protected static boolean ENABLE_DEBUG = false;
+    @Rule
+    public StackTraceRule stackTraceRule = new StackTraceRule();
+    @Before
+    public void setUp() throws Exception {
+        if(ENABLE_DEBUG) {
+            enableDebug();
+        }
+    }
+
+    @After
+    public void clearDebugger() {
+        JqLog.clearLogger();
+    }
+
+    protected void enableDebug() {
+        ShadowLog.stream = System.out;
+        JqLog.setCustomLogger(new CustomLogger() {
+            private String TAG = "test_logger";
+
+            @Override
+            public boolean isDebugEnabled() {
+                return true;
+            }
+
+            @Override
+            public void d(String text, Object... args) {
+                Log.d(TAG, prefix() + String.format(text, args));
+            }
+
+            @Override
+            public void e(Throwable t, String text, Object... args) {
+                Log.e(TAG, prefix() + String.format(text, args), t);
+            }
+
+            @Override
+            public void e(String text, Object... args) {
+                Log.e(TAG, prefix() + String.format(text, args));
+            }
+
+            @Override
+            public void v(String text, Object... args) {
+                Log.v(TAG, prefix() + String.format(text, args));
+            }
+
+            private String prefix() {
+                return Thread.currentThread().getName() + "[" + System.currentTimeMillis() + "]";
+            }
+        });
+    }
+
+    protected void enableCollectingDebug() {
+        ShadowLog.stream = System.out;
+        JqLog.setCustomLogger(new CustomLogger() {
+            private String TAG = "test_logger";
+            private StringBuffer logs = new StringBuffer();
+            @Override
+            public boolean isDebugEnabled() {
+                return true;
+            }
+
+            @Override
+            public void d(String text, Object... args) {
+                logs.append(Thread.currentThread().getName()).append("[d]:");
+                logs.append(String.format(text, args)).append("\n");
+            }
+
+            @Override
+            public void e(Throwable t, String text, Object... args) {
+                logs.append(Thread.currentThread().getName()).append("[e]:");
+                logs.append(String.format(text, args)).append("\n");
+            }
+
+            @Override
+            public void e(String text, Object... args) {
+                logs.append(Thread.currentThread().getName()).append("[e]:");
+                logs.append(String.format(text, args)).append("\n");
+            }
+
+            @Override
+            public void v(String text, Object... args) {
+                logs.append(Thread.currentThread().getName()).append("[v]:");
+                logs.append(String.format(text, args)).append("\n");
+            }
+        });
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddInBackgroundTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
new file mode 100644
index 0000000..73b157b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
@@ -0,0 +1,89 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobManagerThreadRunnable;
+import com.birbit.android.jobqueue.AsyncAddCallback;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicLong;
+
+@RunWith(ParameterizedRobolectricTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class AddInBackgroundTest extends JobManagerTestBase {
+
+    public AddInBackgroundTest(boolean delay, boolean useCallback) {
+        this.delayed = delay;
+        this.useCallback = useCallback;
+    }
+
+    final boolean delayed;
+    final boolean useCallback;
+
+    @ParameterizedRobolectricTestRunner.Parameters(name = "delay:{0} useCallback:{1}")
+    public static List<Object[]> getParameters() {
+        return Arrays.asList(
+                new Object[]{false, false},
+                new Object[]{false, true},
+                new Object[]{true, false},
+                new Object[]{true, true}
+        );
+    }
+
+    @Test
+    public void addInBackground() throws Throwable {
+        long currentThreadId = Thread.currentThread().getId();
+        final AtomicLong onAddedThreadId = new AtomicLong();
+        final CountDownLatch addedLatch = new CountDownLatch(2);
+
+        final Job dummyJob = new DummyJob(new Params(1).setDelayMs(delayed ? 1000 : 0)) {
+            @Override
+            public void onAdded() {
+                super.onAdded();
+                onAddedThreadId.set(Thread.currentThread().getId());
+                addedLatch.countDown();
+            }
+        };
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        if(useCallback) {
+            jobManager.addJobInBackground(dummyJob, new AsyncAddCallback() {
+                @Override
+                public void onAdded() {
+                    addedLatch.countDown();
+                }
+            });
+        } else {
+            addedLatch.countDown();
+            jobManager.addJobInBackground(dummyJob);
+        }
+        addedLatch.await();
+        MatcherAssert.assertThat("thread ids should be different. delayed:" + delayed,
+                currentThreadId, CoreMatchers.not(onAddedThreadId.get()));
+        if(useCallback) {
+            JobHolder holder = new JobManagerThreadRunnable<JobHolder>(jobManager) {
+
+                @Override
+                public JobHolder onRun() {
+                    return findJobFromQueues(dummyJob.getId());
+                }
+            }.run();
+            MatcherAssert.assertThat("there should be a job in the holder. id:" + dummyJob.getId()
+                    +", delayed:" + delayed, holder, CoreMatchers.notNullValue());
+            MatcherAssert.assertThat("id callback should have the proper id:", holder.getJob(),
+                    CoreMatchers.is(dummyJob));
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddedCountTest.java
similarity index 70%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddedCountTest.java
index 356b829..c2de901 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/AddedCountTest.java
@@ -1,8 +1,8 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -12,15 +12,19 @@
 import static org.hamcrest.CoreMatchers.equalTo;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class AddedCountTest extends JobManagerTestBase {
     @Test
     public void testAddedCount() throws Exception {
         testAddedCount(new DummyJob(new Params(0)));
-        testAddedCount(new DummyJob(new Params(0).persist()));
 
     }
 
+    @Test
+    public void testAddedCountPersistent() {
+        testAddedCount(new DummyJob(new Params(0).persist()));
+    }
+
     private void testAddedCount(DummyJob dummyJob) {
         JobManager jobManager = createJobManager();
         jobManager.stop();
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ApplicationContextTests.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ApplicationContextTests.java
new file mode 100644
index 0000000..4589ad8
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ApplicationContextTests.java
@@ -0,0 +1,108 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.model.MultipleFailureException;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.hamcrest.CoreMatchers.sameInstance;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class ApplicationContextTests extends JobManagerTestBase {
+    static int retryCount = 0;
+    static List<Throwable> errors = new ArrayList<>();
+    @Before
+    public void clear() {
+        retryCount = 0;
+        errors.clear();
+    }
+
+    @Test
+    public void getContextNonPersistent() throws InterruptedException, MultipleFailureException {
+        getContextTest(false);
+    }
+
+    @Test
+    public void getContextPersistent() throws InterruptedException, MultipleFailureException {
+        getContextTest(true);
+    }
+
+    public void getContextTest(boolean persistent)
+            throws InterruptedException, MultipleFailureException {
+        final ContextCheckJob addedJob = new ContextCheckJob(new Params(1).setPersistent(persistent));
+        final JobManager jobManager = createJobManager();
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(addedJob);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+        if (!errors.isEmpty()) {
+            throw new MultipleFailureException(errors);
+        }
+    }
+
+    public static class ContextCheckJob extends Job {
+        protected ContextCheckJob(Params params) {
+            super(params);
+        }
+
+        private void assertContext(String method) {
+            Context applicationContext = getApplicationContext();
+            try {
+                assertThat("Context should be application context in " + method,
+                        applicationContext, sameInstance((Context) RuntimeEnvironment.application));
+            } catch (Throwable t) {
+                errors.add(t);
+            }
+        }
+
+        @Override
+        public void onAdded() {
+            assertContext("onAdded");
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            assertContext("onRun");
+            if (retryCount < 2) {
+                retryCount ++;
+                throw new RuntimeException("failure on purpose");
+            }
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+            assertContext("onCancel");
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            assertContext("shouldReRunOnThrowable");
+            return retryCount < 2 ? RetryConstraint.RETRY : RetryConstraint.CANCEL;
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CallbackTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CallbackTest.java
new file mode 100644
index 0000000..64e500e
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CallbackTest.java
@@ -0,0 +1,259 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobStatus;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.doCallRealMethod;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class CallbackTest extends JobManagerTestBase {
+    @Test
+    public void successNonPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final Job job = mock(Job.class);
+        doReturn("a").when(job).getId();
+        doNothing().when(job).onAdded();
+        doNothing().when(job).onRun();
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+        verify(job).onAdded();
+        verify(job).onRun();
+        verify(callback).onJobAdded(job);
+        verify(callback).onJobRun(job, JobManagerCallback.RESULT_SUCCEED);
+    }
+
+    @Test
+    public void cancelViaRetryLimit() throws Throwable {
+        final Throwable error = new Exception();
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final PublicJob job = mock(PublicJob.class);
+        doNothing().when(job).onAdded();
+        doReturn("a").when(job).getId();
+        doThrow(error).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.RETRY).when(job)
+                .shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+
+
+        verify(callback).onJobAdded(job);
+        verify(callback, times(2)).onJobRun(job, JobManagerCallback.RESULT_FAIL_WILL_RETRY);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_REACHED_RETRY_LIMIT);
+        verify(callback).onJobCancelled(job, false, error);
+    }
+
+    @Test
+    public void cancelViaShouldReRun() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final PublicJob job = mock(PublicJob.class);
+        doReturn("a").when(job).getId();
+        doNothing().when(job).onAdded();
+        doThrow(new Exception()).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.CANCEL).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN);
+        verify(callback).onJobCancelled(job, false, null);
+    }
+
+    @Test
+    public void cancelViaCancelCall() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final CountDownLatch startLatch = new CountDownLatch(1);
+        final CountDownLatch endLatch = new CountDownLatch(1);
+        final Throwable[] jobError = new Throwable[1];
+        PublicJob job = spy(new PublicJob(new Params(1).addTags("tag1")) {
+            @Override
+            public void onRun() throws Throwable {
+                startLatch.countDown();
+                try {
+                    Assert.assertThat(endLatch.await(30, TimeUnit.SECONDS), CoreMatchers.is(true));
+                } catch (Throwable t) {
+                    jobError[0] = t;
+                }
+                throw new Exception("blah");
+            }
+        });
+        doCallRealMethod().when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+
+        jobManager.addJob(job);
+        Assert.assertThat(startLatch.await(30, TimeUnit.SECONDS), CoreMatchers.is(true));
+
+        jobManager.cancelJobsInBackground(null, TagConstraint.ANY, "tag1");
+        //noinspection StatementWithEmptyBody
+        while (!job.isCancelled()) {
+            // busy wait until cancel arrives
+            //noinspection SLEEP_IN_CODE
+            Thread.sleep(100);
+        }
+        endLatch.countDown();
+
+        while (jobManager.getJobStatus(job.getId()) != JobStatus.UNKNOWN) {
+            // busy wait until job cancel is handled
+            //noinspection SLEEP_IN_CODE
+            Thread.sleep(100);
+        }
+        MatcherAssert.assertThat(jobError[0], CoreMatchers.nullValue());
+        verify(job, times(0)).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        jobManager.stopAndWaitUntilConsumersAreFinished();
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_WHILE_RUNNING);
+        verify(callback).onJobCancelled(job, true, null);
+    }
+
+    @Test
+    public void successPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final Job job = new PersistentDummyJob();
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+        verify(callback).onJobAdded(any(PersistentDummyJob.class));
+        verify(callback).onJobRun(any(PersistentDummyJob.class), eq(JobManagerCallback.RESULT_SUCCEED));
+    }
+
+    public static class PersistentDummyJob extends Job {
+        public PersistentDummyJob() {
+            super(new Params(1).persist());
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            throw new RuntimeException("not expected to arrive here");
+        }
+    }
+
+    public static class PublicJob extends Job {
+
+        protected PublicJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public int getCurrentRunCount() {
+            return super.getCurrentRunCount();
+        }
+
+        @Override
+        public int getRetryLimit() {
+            return super.getRetryLimit();
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            throw new UnsupportedOperationException("should not be called directly");
+        }
+
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
similarity index 90%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
index bd54746..0fddaff 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelBeforeRunningTest.java
@@ -1,11 +1,11 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;
@@ -18,7 +18,7 @@
 import java.util.concurrent.TimeUnit;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class CancelBeforeRunningTest extends JobManagerTestBase {
     @Test
     public void testCancelBeforeRunning() {
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
similarity index 83%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
index 177d5bd..f95fb7e 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
@@ -1,15 +1,15 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -21,7 +21,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class CancelFailingJobsTest extends JobManagerTestBase {
     static DummyNetworkUtilWithConnectivityEventSupport networkUtil = new
             DummyNetworkUtilWithConnectivityEventSupport();
@@ -50,10 +50,10 @@ public void testCancelAllSyncWithoutNetwork() throws InterruptedException {
     public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
             throws InterruptedException {
         final int jobCount = 30;
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .minConsumerCount(5)
-                .networkUtil(networkUtil));
-        networkUtil.setHasNetwork(false, true);
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                    .minConsumerCount(5).networkUtil(networkUtil).timer(mockTimer));
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
         for (int i = 0; i < jobCount; i ++) {
             jobManager.addJob(new FailingJob(new Params(i).groupBy("group").addTags("tag")));
         }
@@ -83,7 +83,7 @@ public void onRun() throws Throwable {
                 runLatch.countDown();
             }
         });
-        networkUtil.setHasNetwork(true, true);
+        networkUtil.setNetworkStatus(NetworkUtil.UNMETERED, true);
         assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
     }
 
@@ -116,7 +116,7 @@ public void testCancelWithoutNetworkPersistent(boolean async, TagConstraint cons
         JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5)
                 .networkUtil(networkUtil));
-        networkUtil.setHasNetwork(false, true);
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
         jobManager.addJob(new DummyJob(new Params(1).persist().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(2).persist().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(3).persist().groupBy("group").addTags("tag")));
@@ -139,7 +139,7 @@ public void onCancelled(CancelResult cancelResult) {
         assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
         final CountDownLatch runLatch = persistentLatches[latchCounter ++];
         jobManager.addJob(new PersistentDummyJob(new Params(3).persist().groupBy("group").addTags("tag"), latchCounter - 1));
-        networkUtil.setHasNetwork(true, true);
+        networkUtil.setNetworkStatus(NetworkUtil.METERED, true);
         assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
     }
 
@@ -156,7 +156,8 @@ public int getShouldReRunOnThrowableCnt() {
         @Override
         public void onRun() throws Throwable {
             super.onRun();
-            if (!networkUtil.isConnected()) {
+            if (networkUtil.getNetworkStatus(RuntimeEnvironment.application) == NetworkUtil.DISCONNECTED) {
+                //noinspection SLEEP_IN_CODE
                 Thread.sleep(getCurrentRunCount() * 200);
                 throw new RuntimeException("I'm bad, i crash!");
             }
@@ -173,7 +174,8 @@ public PersistentDummyJob(Params params, int latch) {
         @Override
         public void onRun() throws Throwable {
             super.onRun();
-            if (!networkUtil.isConnected()) {
+            if (networkUtil.getNetworkStatus(RuntimeEnvironment.application) == NetworkUtil.DISCONNECTED) {
+                //noinspection SLEEP_IN_CODE
                 Thread.sleep(getCurrentRunCount() * 200);
                 throw new RuntimeException("I'm bad, i crash!");
             }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
similarity index 78%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
index 9adc156..c2d9df2 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningTest.java
@@ -1,17 +1,16 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.log.JqLog;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -23,11 +22,14 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class CancelWhileRunningTest extends JobManagerTestBase {
     @Test
     public void testCancelBeforeRunning() throws InterruptedException {
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).minConsumerCount(5));
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .minConsumerCount(5)
+                        .timer(mockTimer));
         JobWithEndLatch nonPersistent1 = new JobWithEndLatch(new Params(0).addTags("dummyTag"), true);
         JobWithEndLatch nonPersistent2 = new JobWithEndLatch(new Params(0).addTags("dummyTag"), false);
         DummyJob persistentJob1 = new PersistentJobWithEndLatch(new Params(0).addTags("dummyTag"), false);
@@ -41,7 +43,7 @@ public void testCancelBeforeRunning() throws InterruptedException {
         onStartLatch.await();
         nonPersistent1.onStartLatch.await();
         nonPersistent2.onStartLatch.await();
-        final CancelResult[] resultHolder = new CancelResult[1];
+        final CancelResult[] resultHolder = new CancelResult[2];
         final CountDownLatch cancelLatch = new CountDownLatch(1);
         jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
             @Override
@@ -51,14 +53,20 @@ public void onCancelled(CancelResult cancelResult) {
             }
         }, TagConstraint.ANY, "dummyTag");
 
+        jobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {
+            @Override
+            public void onCancelled(CancelResult cancelResult) {
+                resultHolder[1] = cancelResult;
+            }
+        }, TagConstraint.ANY, "dummyTag");
+
         assertThat("result should not arrive until existing jobs finish",
                 cancelLatch.await(4, TimeUnit.SECONDS), is(false));
-
         onEndLatch.countDown();
         nonPersistent1.onEndLatch.countDown();
         nonPersistent2.onEndLatch.countDown();
         assertThat("when jobs in question are finished, cancel callback should be triggered",
-                cancelLatch.await(1, TimeUnit.SECONDS), is(true));
+                cancelLatch.await(10, TimeUnit.SECONDS), is(true));
         final CancelResult result = resultHolder[0];
         JqLog.d("cancelled jobs %s", result.getCancelledJobs());
         JqLog.d("failed to cancel %s", result.getFailedToCancel());
@@ -88,6 +96,11 @@ public void onCancelled(CancelResult cancelResult) {
                 assertThat("job could not be cancelled", job.getOnCancelCnt(), is(0));
             }
         }
+
+        assertThat("second cancel should not cancel anything",
+                resultHolder[1].getCancelledJobs().size(), is(0));
+        assertThat("second cancel should not cancel anything",
+                resultHolder[1].getFailedToCancel().size(), is(0));
     }
 
     public static CountDownLatch onStartLatch = new CountDownLatch(2);
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
similarity index 72%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
index 1dfb76b..b4fdeae 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWhileRunningWithGroupsTest.java
@@ -1,15 +1,14 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -21,15 +20,19 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class CancelWhileRunningWithGroupsTest extends JobManagerTestBase {
     public static CountDownLatch[] endLatches = new CountDownLatch[]{new CountDownLatch(2), new CountDownLatch(2)};
     public static CountDownLatch[] startLatches = new CountDownLatch[]{new CountDownLatch(2), new CountDownLatch(2)};
     @Test
     public void testCancelBeforeRunning() throws InterruptedException {
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).minConsumerCount(5));
-        jobManager.addJob(new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group1")));
-        jobManager.addJob(new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group2").persist()));
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .minConsumerCount(5).timer(mockTimer));
+        DummyJobWithLatches nonPersistentJob = new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group1"));
+        jobManager.addJob(nonPersistentJob);
+        DummyJobWithLatches persistentJob = new DummyJobWithLatches(0, new Params(1).addTags("dummyTag").groupBy("group2").persist());
+        jobManager.addJob(persistentJob);
         assertThat("both jobs should start", startLatches[0].await(2, TimeUnit.SECONDS), is(true));
         final CancelResult[] cancelResults = new CancelResult[1];
         final CountDownLatch resultLatch = new CountDownLatch(1);
@@ -41,8 +44,9 @@ public void onCancelled(CancelResult cancelResult) {
                 resultLatch.countDown();
             }
         }, TagConstraint.ANY, "dummyTag");
-        // give time to cancel request to be processed
-        Thread.sleep(1000);
+        while (!nonPersistentJob.isCancelled()) {
+            // wait
+        }
         endLatches[0].countDown();
         endLatches[0].countDown();
 
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
similarity index 85%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
index 666a705..2a39e31 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CancelWithNetworkToggleTest.java
@@ -1,18 +1,18 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
@@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class CancelWithNetworkToggleTest extends JobManagerTestBase {
 
     @Test
@@ -49,10 +49,12 @@ public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
             throws InterruptedException {
         DummyNetworkUtilWithConnectivityEventSupport networkUtil = new
                 DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .minConsumerCount(5)
-                .networkUtil(networkUtil));
-        networkUtil.setHasNetwork(false, true);
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .minConsumerCount(5)
+                        .networkUtil(networkUtil)
+                        .timer(mockTimer));
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
         jobManager.addJob(new DummyJob(new Params(1).requireNetwork().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(2).requireNetwork().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(3).requireNetwork().groupBy("group").addTags("tag")));
@@ -81,7 +83,7 @@ public void onRun() throws Throwable {
                 runLatch.countDown();
             }
         });
-        networkUtil.setHasNetwork(true, true);
+        networkUtil.setNetworkStatus(NetworkUtil.METERED, true);
         assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
     }
 
@@ -116,7 +118,7 @@ public void testCancelWithoutNetworkPersistent(boolean async, TagConstraint cons
         JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5)
                 .networkUtil(networkUtil));
-        networkUtil.setHasNetwork(false, true);
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
         jobManager.addJob(new DummyJob(new Params(1).persist().requireNetwork().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(2).persist().requireNetwork().groupBy("group").addTags("tag")));
         jobManager.addJob(new DummyJob(new Params(3).persist().requireNetwork().groupBy("group").addTags("tag")));
@@ -139,7 +141,7 @@ public void onCancelled(CancelResult cancelResult) {
         assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
         final CountDownLatch runLatch = persistentLatches[latchCounter ++];
         jobManager.addJob(new PersistentDummyJob(new Params(3).persist().requireNetwork().groupBy("group").addTags("tag"), latchCounter - 1));
-        networkUtil.setHasNetwork(true, true);
+        networkUtil.setNetworkStatus(NetworkUtil.METERED, true);
         assertThat("new job should run w/o any issues", runLatch.await(2, TimeUnit.SECONDS), is(true));
     }
 
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ClearTest.java
similarity index 72%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ClearTest.java
index 4bea355..c3695c9 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ClearTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ClearTest.java
@@ -1,8 +1,8 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -11,7 +11,7 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class ClearTest extends JobManagerTestBase {
     @Test
     public void testClear() throws Exception {
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ConsumerCountTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ConsumerCountTest.java
new file mode 100644
index 0000000..e07992b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ConsumerCountTest.java
@@ -0,0 +1,72 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.timer.SystemTimer;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class ConsumerCountTest extends JobManagerTestBase {
+    final CountDownLatch runLock = new CountDownLatch(1);
+    @Test
+    public void testMaxConsumerCount() throws Exception {
+        int maxConsumerCount = 2;
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .maxConsumerCount(maxConsumerCount)
+                        .loadFactor(maxConsumerCount)
+                        .timer(mockTimer));
+
+        Semaphore semaphore = new Semaphore(maxConsumerCount);
+        int totalJobCount = maxConsumerCount * 3;
+        List<NeverEndingDummyJob> runningJobs = new ArrayList<>(totalJobCount);
+        for(int i = 0; i < totalJobCount; i ++) {
+            NeverEndingDummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
+            runningJobs.add(job);
+            jobManager.addJob(job);
+        }
+        Timer timer = new SystemTimer();
+        //wait till enough jobs start
+        long start = timer.nanoTime();
+        long tenSeconds = TimeUnit.SECONDS.toNanos(10);
+        while (timer.nanoTime() - start < tenSeconds && semaphore.tryAcquire()) {
+            semaphore.release();
+            //noinspection SLEEP_IN_CODE
+            Thread.sleep(100);
+        }
+        MatcherAssert.assertThat("all consumers should start in 10 seconds",
+                timer.nanoTime() - start > tenSeconds, is(false));
+        //wait some more to ensure no more jobs are started
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(TimeUnit.SECONDS.toMillis(3));
+        int totalRunningCount = 0;
+        for(DummyJob job : runningJobs) {
+            totalRunningCount += job.getOnRunCnt();
+        }
+        MatcherAssert.assertThat("only maxConsumerCount jobs should start", totalRunningCount,
+                equalTo(maxConsumerCount));
+        waitUntilJobsAreDone(jobManager, runningJobs, new Runnable() {
+            @Override
+            public void run() {
+                runLock.countDown();
+            }
+        });
+        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CountTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CountTest.java
new file mode 100644
index 0000000..825a5a6
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/CountTest.java
@@ -0,0 +1,51 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class CountTest extends JobManagerTestBase {
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+    @Test
+    public void testCount() throws Exception {
+        enableDebug();
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        for (int i = 0; i < 10; i++) {
+            jobManager.addJob(new DummyJob(new Params(0).persist()));
+            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 1));
+            jobManager.addJob(new DummyJob(new Params(0).persist()));
+            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 2));
+        }
+        final CountDownLatch jobsToRun = new CountDownLatch(20);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                if (resultCode == JobManagerCallback.RESULT_SUCCEED) {
+                    jobsToRun.countDown();
+                }
+            }
+        });
+        jobManager.start();
+        MatcherAssert.assertThat("test sanity", jobsToRun.await(1, TimeUnit.MINUTES), is(true));
+        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayTest.java
similarity index 56%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayTest.java
index e5f06f0..7004d5a 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayTest.java
@@ -1,11 +1,11 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
 
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.*;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -14,40 +14,41 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class DelayTest extends JobManagerTestBase {
     @Test
-    public void testDelay() throws Exception {
+    public void testDelay() throws Throwable {
         testDelay(false);
+    }
+
+    @Test
+    public void testDelayPersistent() throws Throwable {
         testDelay(true);
     }
 
-    public void testDelay(boolean persist) throws Exception {
+    public void testDelay(boolean persist) throws Throwable {
         JobManager jobManager = createJobManager();
         jobManager.stop();
         DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(1000).setPersistent(persist));
         DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
-        long jobId = jobManager.addJob(delayedJob);
-        long nonDelayedJobId = jobManager.addJob(nonDelayedJob);
-
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
+        jobManager.addJob(delayedJob);
+        jobManager.addJob(nonDelayedJob);
 
-        JobHolder receivedJob = nextJobMethod.invoke();
+        JobHolder receivedJob = nextJob(jobManager);
         MatcherAssert.assertThat("non-delayed job should be served", receivedJob, notNullValue());
-        MatcherAssert.assertThat("non-delayed job should id should match",  receivedJob.getId(), equalTo(nonDelayedJobId));
-        removeJobMethod.invoke(receivedJob);
-        MatcherAssert.assertThat("delayed job should not be served",  nextJobMethod.invoke(), nullValue());
+        MatcherAssert.assertThat("non-delayed job should id should match",  receivedJob.getId(), equalTo(nonDelayedJob.getId()));
+        removeJob(jobManager, receivedJob);
+        MatcherAssert.assertThat("delayed job should not be served", nextJob(jobManager), nullValue());
         MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        Thread.sleep(500);
-        MatcherAssert.assertThat("delayed job should not be served",  nextJobMethod.invoke(), nullValue());
+        mockTimer.incrementMs(500);
+        MatcherAssert.assertThat("delayed job should not be served", nextJob(jobManager), nullValue());
         MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        Thread.sleep(2000);
+        mockTimer.incrementMs(2000);
         MatcherAssert.assertThat("job count should still be 1",  jobManager.count(), equalTo(1));
-        receivedJob = nextJobMethod.invoke();
+        receivedJob = nextJob(jobManager);
         MatcherAssert.assertThat("now should be able to receive the delayed job.", receivedJob, notNullValue());
         if(receivedJob != null) {
-            MatcherAssert.assertThat("received job should be the delayed job", receivedJob.getId(), equalTo(jobId));
+            MatcherAssert.assertThat("received job should be the delayed job", receivedJob.getId(), equalTo(delayedJob.getId()));
         }
     }
 }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayedRunTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayedRunTest.java
new file mode 100644
index 0000000..89b9e4d
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/DelayedRunTest.java
@@ -0,0 +1,145 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.support.annotation.NonNull;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.hamcrest.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class DelayedRunTest extends JobManagerTestBase {
+    @Test
+    public void testDelayedRun() throws Exception {
+        delayedRunTest(false, false);
+    }
+
+    @Test
+    public void testDelayedRunPersist() throws Exception {
+        delayedRunTest(true, false);
+    }
+
+    @Test
+    public void testDelayedRunTryToStop() throws Exception {
+        delayedRunTest(false, true);
+    }
+
+    @Test
+    public void testDelayedRunPersistAndTryToStop() throws Exception {
+        delayedRunTest(true, true);
+    }
+
+    @Test
+    public void testDelayWith0Consumers() throws InterruptedException {
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .minConsumerCount(0)
+                        .maxConsumerCount(3)
+                        .timer(mockTimer));
+        final CountDownLatch latch = new CountDownLatch(1);
+        final DummyJob dummyJob = new DummyJob(new Params(0).delayInMs(2000)) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                latch.countDown();
+            }
+        };
+        jobManager.addJob(dummyJob);
+        mockTimer.incrementMs(1999);
+        assertThat("there should not be any ready jobs", jobManager.countReadyJobs(), is(0));
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                mockTimer.incrementMs(1002);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+                assertThat("should be the dummy job", job, is((Job) dummyJob));
+            }
+        });
+        assertThat("job should run in 3 seconds", latch.await(3, TimeUnit.NANOSECONDS),
+                is(true));
+    }
+
+    public void delayedRunTest(boolean persist, boolean tryToStop) throws Exception {
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onJobRun(@NonNull Job job, int resultCode) {
+                super.onJobRun(job, resultCode);
+                System.out.println("CB job run " + job.getTags().toArray()[0] + ", " + mockTimer.nanoTime());
+            }
+
+            @Override
+            public void onDone(@NonNull Job job) {
+                System.out.println("CB job done " + job.getTags().toArray()[0] + ", " + mockTimer.nanoTime());
+            }
+
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                System.out.println("CB job after run " + job.getTags().toArray()[0] + ", " + mockTimer.nanoTime());
+            }
+        });
+        final DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(2000).setPersistent(persist).addTags("delayed"));
+        final DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist).addTags("notDelayed"));
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(delayedJob);
+                jobManager.addJob(nonDelayedJob);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+                assertThat("correct job should run first", (String) job.getTags().toArray()[0],
+                        is("notDelayed"));
+            }
+        });
+        MatcherAssert.assertThat("there should be 1 delayed job waiting to be run", jobManager.count(), equalTo(1));
+        if(tryToStop) {//see issue #11
+            jobManager.stopAndWaitUntilConsumersAreFinished();
+            mockTimer.incrementMs(3000);
+            MatcherAssert.assertThat("there should still be 1 delayed job waiting to be run when job manager is stopped",
+                    jobManager.count(), equalTo(1));
+
+            waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+                @Override
+                public void run() {
+                    jobManager.start();
+                }
+
+                @Override
+                public void assertJob(Job job) {
+                    assertThat("correct job should run first", (String) job.getTags().toArray()[0], is("delayed"));
+                }
+            });
+        } else {
+            waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+                @Override
+                public void run() {
+                    mockTimer.incrementMs(3000);
+                }
+
+                @Override
+                public void assertJob(Job job) {
+                    assertThat("correct job should run first", (String) job.getTags().toArray()[0], is("delayed"));
+                }
+            });
+        }
+        MatcherAssert.assertThat("all jobs should be completed", jobManager.count(), equalTo(0));
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/GroupingTest.java
similarity index 56%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/GroupingTest.java
index b2e10da..8c6820b 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/GroupingTest.java
@@ -1,11 +1,14 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.*;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -13,42 +16,55 @@
 import org.robolectric.*;
 import org.robolectric.annotation.Config;
 
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class GroupingTest extends JobManagerTestBase {
+    private String addJob(JobManager jobManager, Job job) {
+        jobManager.addJob(job);
+        return job.getId();
+    }
     @Test
-    public void testGrouping() throws Exception {
+    public void testGrouping() throws Throwable {
         JobManager jobManager = createJobManager();
         jobManager.stop();
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
-
-        long jobId1 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
-        long jobId2 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
-        long jobId3 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group2")));
-        long jobId4 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group1")));
-        JobHolder nextJob = nextJobMethod.invoke();
+        String jobId1 = addJob(jobManager, new DummyJob(new Params(0).groupBy("group1")));
+        String jobId2 = addJob(jobManager, new DummyJob(new Params(0).groupBy("group1")));
+        String jobId3 = addJob(jobManager, new DummyJob(new Params(0).persist().groupBy("group2")));
+        String jobId4 = addJob(jobManager, new DummyJob(new Params(0).persist().groupBy("group1")));
+        JobHolder nextJob = nextJob(jobManager);
         MatcherAssert.assertThat("next job should be the first job from group1", nextJob.getId(), equalTo(jobId1));
-        JobHolder group2Job = nextJobMethod.invoke();
+        JobHolder group2Job = nextJob(jobManager, Collections.singletonList("group1"));
         MatcherAssert.assertThat("since group 1 is running now, next job should be from group 2", group2Job.getId(), equalTo(jobId3));
-        removeJobMethod.invoke(nextJob);
-        JobHolder group1NextJob =nextJobMethod.invoke();
+        removeJob(jobManager, nextJob);
+        JobHolder group1NextJob = nextJob(jobManager, Arrays.asList("group2"));
         MatcherAssert.assertThat("after removing job from group 1, another job from group1 should be returned", group1NextJob.getId(), equalTo(jobId2));
-        MatcherAssert.assertThat("when jobs from both groups are running, no job should be returned from next job", nextJobMethod.invoke(), is(nullValue()));
-        removeJobMethod.invoke(group2Job);
-        MatcherAssert.assertThat("even after group2 job is complete, no jobs should be returned since we only have group1 jobs left", nextJobMethod.invoke(), is(nullValue()));
+        MatcherAssert.assertThat("when jobs from both groups are running, no job should be returned from next job",
+                nextJob(jobManager, Arrays.asList("group1", "group2")), is(nullValue()));
+        removeJob(jobManager, group2Job);
+        MatcherAssert.assertThat("even after group2 job is complete, no jobs should be returned"
+                + "since we only have group1 jobs left",
+                nextJob(jobManager, Arrays.asList("group1")), is(nullValue()));
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     @Test
     public void testGroupingRaceCondition() throws Exception {
         DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
         JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5).maxConsumerCount(10)
-                .networkUtil(dummyNetworkUtil));
-        dummyNetworkUtil.setHasNetwork(false, true);
+                .networkUtil(dummyNetworkUtil)
+                .timer(mockTimer));
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
         //add a bunch of network requring jobs
         final String GROUP_ID = "shared_group_id";
         final int AFTER_ADDED_JOBS_COUNT = 5;
@@ -57,18 +73,18 @@ public void testGroupingRaceCondition() throws Exception {
         final int FIRST_JOB_ID = -10;
         final CountDownLatch onAddedCalled = new CountDownLatch(1);
         final CountDownLatch remainingJobsOnAddedCalled = new CountDownLatch(AFTER_ADDED_JOBS_COUNT);
+        final CountDownLatch aJobRun = new CountDownLatch(1);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onJobRun(@NonNull Job job, int resultCode) {
+                aJobRun.countDown();
+            }
+        });
         jobManager.addJobInBackground(new DummyJob(new Params(10).requireNetwork().groupBy(GROUP_ID)) {
             @Override
             public void onAdded() {
                 super.onAdded();
                 onAddedCalled.countDown();
-                try {
-                    //wait until all other jobs are added
-                    remainingJobsOnAddedCalled.await();
-                    //wait a bit after all are added,
-                    Thread.sleep(1000);
-                } catch (InterruptedException e) {
-                }
             }
 
             @Override
@@ -97,11 +113,9 @@ public void onRun() throws Throwable {
                 }
             });
         }
-        dummyNetworkUtil.setHasNetwork(true, true);
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED, true);
         //wait until all jobs are completed
-        while(firstRunJob.get() == NOT_SET_JOB_ID) {
-            Thread.sleep(100);
-        }
+        aJobRun.await(1, TimeUnit.MINUTES);
         MatcherAssert.assertThat("highest priority job should run if it is added before others", firstRunJob.get(), is(FIRST_JOB_ID));
 
     }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/InjectorTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/InjectorTest.java
new file mode 100644
index 0000000..f926782
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/InjectorTest.java
@@ -0,0 +1,49 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.di.DependencyInjector;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class InjectorTest extends JobManagerTestBase {
+    @Test
+    public void testInjector() throws Throwable {
+        Configuration.Builder builder = new Configuration.Builder(RuntimeEnvironment.application);
+        final JobManagerTestBase.ObjectReference injectedJobReference = new JobManagerTestBase.ObjectReference();
+        final AtomicInteger injectionCallCount = new AtomicInteger(0);
+        DependencyInjector dependencyInjector = new DependencyInjector() {
+            @Override
+            public void inject(Job job) {
+                injectedJobReference.setObject(job);
+                injectionCallCount.incrementAndGet();
+            }
+        };
+        builder.injector(dependencyInjector);
+        builder.timer(mockTimer);
+        JobManager jobManager = createJobManager(builder);
+        jobManager.stop();
+        jobManager.addJob(new DummyJob(new Params(4)));
+        MatcherAssert.assertThat("injection should be called after adding a non-persistent job", injectionCallCount.get(), equalTo(1));
+        jobManager.addJob(new DummyJob(new Params(1).persist()));
+        MatcherAssert.assertThat("injection should be called after adding a persistent job", injectionCallCount.get(), equalTo(2));
+        JobHolder holder = nextJob(jobManager);
+        MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getJob(), not(injectedJobReference.getObject()));
+        MatcherAssert.assertThat("injection should be called once for non persistent job", injectionCallCount.get(), equalTo(2));
+        holder = nextJob(jobManager);
+        MatcherAssert.assertThat("injection should be called for persistent job", holder.getJob(), equalTo(injectedJobReference.getObject()));
+        MatcherAssert.assertThat("injection should be called two times for persistent job", injectionCallCount.get(), equalTo(3));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobManagerTestBase.java
new file mode 100644
index 0000000..156478a
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobManagerTestBase.java
@@ -0,0 +1,326 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobManagerThreadRunnable;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.testing.CleanupRule;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkEventProvider;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.TestBase;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+
+import static org.hamcrest.CoreMatchers.*;
+
+import org.hamcrest.*;
+import org.junit.Rule;
+import org.junit.rules.Timeout;
+import org.robolectric.*;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+
+public class JobManagerTestBase extends TestBase {
+    List<JobManager> createdJobManagers = new ArrayList<JobManager>();
+    final MockTimer mockTimer = new MockTimer();
+    @Rule public CleanupRule cleanup = new CleanupRule(this);
+    @Rule public Timeout timeout = Timeout.seconds(getTimeout());
+
+    protected int getActiveConsumerCount(JobManager jobManager) {
+        return jobManager.getActiveConsumerCount();
+    }
+
+    protected long getTimeout() {
+        return 60;
+    }
+
+    protected JobManager createJobManager() {
+        if(createdJobManagers.size() > 0) {
+            throw new AssertionError("only 1 job manager per test");
+        }
+        final JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+            .timer(mockTimer)
+            .inTestMode());
+        createdJobManagers.add(jobManager);
+        return jobManager;
+    }
+
+    protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
+        if(createdJobManagers.size() > 0) {
+            throw new AssertionError("only 1 job manager per test");
+        }
+        Configuration config = configurationBuilder.inTestMode().id(UUID.randomUUID().toString())
+                .build();
+        if (config.getTimer() != mockTimer && !canUseRealTimer()) {
+            throw new IllegalArgumentException("must use mock timer");
+        }
+        final JobManager jobManager = new JobManager(config);
+        createdJobManagers.add(jobManager);
+
+        return jobManager;
+    }
+
+    public List<JobManager> getCreatedJobManagers() {
+        return createdJobManagers;
+    }
+
+    public MockTimer getMockTimer() {
+        return mockTimer;
+    }
+
+    protected static class DummyTwoLatchJob extends DummyJob {
+        private final CountDownLatch waitFor;
+        private final CountDownLatch trigger;
+        private final CountDownLatch onRunLatch;
+
+        protected DummyTwoLatchJob(Params params, CountDownLatch waitFor, CountDownLatch trigger) {
+            super(params);
+            this.waitFor = waitFor;
+            this.trigger = trigger;
+            onRunLatch = new CountDownLatch(1);
+        }
+
+        public void waitTillOnRun() throws InterruptedException {
+            onRunLatch.await();
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            onRunLatch.countDown();
+            waitFor.await();
+            super.onRun();
+            trigger.countDown();
+        }
+    }
+
+    protected JobHolder nextJob(JobManager jobManager) throws Throwable {
+        return new JobManagerThreadRunnable<JobHolder>(jobManager) {
+            @Override
+            public JobHolder onRun() {
+                return getNextJob();
+            }
+        }.run();
+    }
+
+    protected JobHolder nextJob(JobManager jobManager, final Collection<String> exclude) throws Throwable {
+        return new JobManagerThreadRunnable<JobHolder>(jobManager) {
+            @Override
+            public JobHolder onRun() {
+                return getNextJob(exclude);
+            }
+        }.run();
+    }
+
+    protected void removeJob(final JobManager jobManager, final JobHolder holder) throws Throwable {
+        new JobManagerThreadRunnable<Void>(jobManager) {
+            @Override
+            public Void onRun() {
+                removeJob(holder);
+                return null;
+            }
+        }.run();
+    }
+
+    protected static class DummyLatchJob extends DummyJob {
+        private final CountDownLatch latch;
+
+        protected DummyLatchJob(Params params, CountDownLatch latch) {
+            super(params);
+            this.latch = latch;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            latch.countDown();
+        }
+    }
+
+
+    protected static class DummyJobWithRunCount extends DummyJob {
+        public static int runCount;
+        protected DummyJobWithRunCount(boolean persistent) {
+            super(new Params(0).setPersistent(persistent));
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            runCount++;
+            super.onRun();
+            throw new RuntimeException("i am dummy, i throw exception when running " + runCount);
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            return RetryConstraint.RETRY;
+        }
+
+        @Override
+        protected int getRetryLimit() {
+            return 5;
+        }
+    }
+
+    protected static class DummyNetworkUtil implements NetworkUtil {
+        private int networkStatus;
+
+        protected void setNetworkStatus(int networkStatus) {
+            this.networkStatus = networkStatus;
+        }
+
+        @Override
+        public int getNetworkStatus(Context context) {
+            return networkStatus;
+        }
+    }
+
+    protected static class DummyNetworkUtilWithConnectivityEventSupport extends DummyNetworkUtil
+            implements NetworkUtil, NetworkEventProvider {
+        private int networkStatus;
+        private Listener listener;
+
+        protected void setNetworkStatus(int networkStatus, boolean notifyListener) {
+            this.networkStatus = networkStatus;
+            if(notifyListener && listener != null) {
+                listener.onNetworkChange(networkStatus);
+            }
+        }
+
+        @Override
+        protected void setNetworkStatus(int networkStatus) {
+            setNetworkStatus(networkStatus, true);
+        }
+
+        @Override
+        public int getNetworkStatus(Context context) {
+            return networkStatus;
+        }
+
+        public boolean isDisconnected() {
+            return networkStatus == DISCONNECTED;
+        }
+
+        @Override
+        public void setListener(Listener listener) {
+            this.listener = listener;
+        }
+    }
+
+    protected static class ObjectReference {
+        Object object;
+
+        Object getObject() {
+            return object;
+        }
+
+        void setObject(Object object) {
+            this.object = object;
+        }
+    }
+
+    public static class NeverEndingDummyJob extends DummyJob {
+        // used for cleanup
+        static List<NeverEndingDummyJob> createdJobs = new ArrayList<>();
+        final CountDownLatch lock;
+        final Semaphore semaphore;
+        public NeverEndingDummyJob(Params params, CountDownLatch lock, Semaphore semaphore) {
+            super(params);
+            this.lock = lock;
+            this.semaphore = semaphore;
+            createdJobs.add(this);
+        }
+
+        @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            MatcherAssert.assertThat("job should be able to acquire a semaphore",
+                    semaphore.tryAcquire(), equalTo(true));
+            lock.await(1, TimeUnit.MINUTES);
+            semaphore.release();
+        }
+
+        public static void unlockAll() {
+            for (NeverEndingDummyJob job : createdJobs) {
+                job.lock.countDown();
+            }
+        }
+    }
+
+    protected boolean canUseRealTimer() {
+        return false;
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+    protected void waitUntilJobsAreDone(final JobManager jobManager, List<? extends Job> jobs, Runnable action)
+            throws InterruptedException {
+        final Set<String> uuids = new HashSet<>();
+        for (Job job : jobs) {
+            uuids.add(job.getId());
+        }
+        final CountDownLatch latch = new CountDownLatch(uuids.size());
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onDone(@NonNull Job job) {
+                if (uuids.remove(job.getId())) {
+                    latch.countDown();
+                }
+            }
+        });
+        if (action != null) {
+            action.run();
+        }
+        MatcherAssert.assertThat("Jobs should be done", latch.await(1, TimeUnit.MINUTES), is(true));
+    }
+
+    @SuppressLint("NewApi")
+    protected void waitUntilAJobIsDone(final JobManager jobManager, final WaitUntilCallback callback) throws InterruptedException {
+        final CountDownLatch runJob = new CountDownLatch(1);
+        final Throwable[] throwable = new Throwable[1];
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onDone(@NonNull Job job) {
+                synchronized (this) {
+                    super.onDone(job);
+                    if (callback != null) {
+                        try {
+                            callback.assertJob(job);
+                        } catch (Throwable t) {
+                            throwable[0] = t;
+                        }
+                    }
+                    runJob.countDown();
+                    jobManager.removeCallback(this);
+                }
+            }
+        });
+        if (callback != null) {
+            callback.run();
+        }
+        MatcherAssert.assertThat("The job should be done", runJob.await(1, TimeUnit.MINUTES), is(true));
+        MatcherAssert.assertThat("Job assertion failed", throwable[0], CoreMatchers.nullValue());
+    }
+    protected interface WaitUntilCallback {
+        void run();
+        void assertJob(Job job);
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobStatusTest.java
new file mode 100644
index 0000000..351fb3c
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/JobStatusTest.java
@@ -0,0 +1,161 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobStatus;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class JobStatusTest extends JobManagerTestBase {
+    private static final String REQ_NETWORK_TAG = "reqNetwork";
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+    @Test
+    public void testJobStatus() throws InterruptedException {
+        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application).networkUtil(networkUtil)
+                        .timer(mockTimer));
+        jobManager.stop();
+        List<Integer> networkRequiringJobIndices = new ArrayList<Integer>();
+        Job[] jobs = new Job[] {
+                new DummyJob(new Params(0)),
+                new DummyJob(new Params(0).persist()),
+                new DummyJob(new Params(0).persist().requireNetwork().addTags(REQ_NETWORK_TAG))
+        };
+        String[] ids = new String[jobs.length];
+        for(int i = 0; i < jobs.length; i ++) {
+            jobManager.addJob(jobs[i]);
+            ids[i] = jobs[i].getId();
+            if(jobs[i].requiresNetwork(mockTimer)) {
+                networkRequiringJobIndices.add(i);
+            }
+            JobStatus expectedStatus = (!networkUtil.isDisconnected() || !jobs[i].requiresNetwork(mockTimer)) ? JobStatus.WAITING_READY :
+                    JobStatus.WAITING_NOT_READY;
+            assertThat("job should have correct status after being added",
+                    jobManager.getJobStatus(ids[i]), is(expectedStatus));
+        }
+
+        //create an unknown id, ensure status for that
+
+        boolean exists;
+        String unknownId;
+        do {
+            unknownId = UUID.randomUUID().toString();
+            exists = false;
+            for(String id : ids) {
+                if(unknownId.equals(id)) {
+                    exists = true;
+                }
+            }
+        } while (exists);
+        for(boolean persistent : new boolean[]{true, false}) {
+            assertThat("job with unknown id should return as expected",
+                    jobManager.getJobStatus(unknownId), is(JobStatus.UNKNOWN));
+        }
+
+        final CountDownLatch startLatch = new CountDownLatch(1), endLatch = new CountDownLatch(1);
+        final DummyTwoLatchJob twoLatchJob = new DummyTwoLatchJob(new Params(0), startLatch, endLatch);
+        jobManager.start();
+        jobManager.addJob(twoLatchJob);
+        final String jobId = twoLatchJob.getId();
+        twoLatchJob.waitTillOnRun();
+        final CountDownLatch twoLatchJobDone = new CountDownLatch(1);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                if (job == twoLatchJob && resultCode == RESULT_SUCCEED) {
+                    jobManager.removeCallback(this);
+                    twoLatchJobDone.countDown();
+                }
+            }
+        });
+        assertThat("job should be in running state", jobManager.getJobStatus(jobId), is(JobStatus.RUNNING));
+        startLatch.countDown();//let it run
+        try {
+            endLatch.await();//wait till it finishes
+        } catch (InterruptedException ignored) {
+
+        }
+        twoLatchJobDone.await(1, TimeUnit.MINUTES);
+        assertThat("finished job should go to unknown state. id: " + jobId, jobManager.getJobStatus(jobId), is(JobStatus.UNKNOWN));
+
+        //network requiring job should not be ready
+        for(Integer i : networkRequiringJobIndices) {
+            assertThat("network requiring job should still be not-ready",
+                    jobManager.getJobStatus(ids[i]), is(JobStatus.WAITING_NOT_READY));
+        }
+        jobManager.stop();
+        networkUtil.setNetworkStatus(NetworkUtil.METERED, true);
+        for(Integer i : networkRequiringJobIndices) {
+            assertThat("network requiring job should still be ready after network is there",
+                    jobManager.getJobStatus(ids[i]), is(JobStatus.WAITING_READY));
+        }
+        final CountDownLatch networkRequiredLatch = new CountDownLatch(networkRequiringJobIndices.size());
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onDone(@NonNull Job job) {
+                if (job.getTags().contains(REQ_NETWORK_TAG)) {
+                    networkRequiredLatch.countDown();
+                }
+            }
+        });
+        jobManager.start();
+        networkRequiredLatch.await(1, TimeUnit.MINUTES);
+        assertThat("jobs should finish", jobManager.count(), is(0));
+        for(int i = 0; i < jobs.length; i ++) {
+            //after all jobs finish, state should be unknown
+            assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i]), is(JobStatus.UNKNOWN));
+        }
+        final long SHORT_SLEEP = 2000;
+        Job[] delayedJobs = new Job[]{
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
+        String[] delayedIds = new String[delayedJobs.length];
+        long start = mockTimer.nanoTime();
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            jobManager.addJob(delayedJobs[i]);
+            delayedIds[i] = delayedJobs[i].getId();
+        }
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            assertThat("delayed job(" + i + ") should receive not ready status. startMs:" + start,
+                    jobManager.getJobStatus(delayedIds[i]), is(JobStatus.WAITING_NOT_READY));
+        }
+        jobManager.stop();
+        //sleep
+        mockTimer.incrementMs(SHORT_SLEEP * 2);
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
+                assertThat("when enough time passes, delayed jobs should move to ready state",
+                        jobManager.getJobStatus(delayedIds[i]),is(JobStatus.WAITING_READY));
+            } else {
+                assertThat("delayed job should receive not ready status until their time comes",
+                        jobManager.getJobStatus(delayedIds[i]), is(JobStatus.WAITING_NOT_READY));
+            }
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/KeepAliveTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/KeepAliveTest.java
new file mode 100644
index 0000000..bc5332a
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/KeepAliveTest.java
@@ -0,0 +1,92 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class KeepAliveTest extends JobManagerTestBase {
+    @Test
+    public void testKeepAlive() throws Exception {
+        testKeepAlive(new DummyNetworkUtilWithConnectivityEventSupport());
+    }
+
+    @Test
+    public void testKeepAliveWithoutNetworkEvents() throws Exception {
+        testKeepAlive(new DummyNetworkUtil());
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+    public void testKeepAlive(final DummyNetworkUtil networkUtil) throws Exception {
+        int keepAlive = 3 + (int)(Math.random() * 5);
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .consumerKeepAlive(keepAlive).networkUtil(networkUtil).timer(mockTimer));
+        //give it a little time to create first consumer
+        final CountDownLatch jobDone = new CountDownLatch(1);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onDone(@NonNull Job job) {
+                jobDone.countDown();
+            }
+        });
+        jobManager.addJob(new DummyJob(new Params(0)));
+
+        // Sync on job manager to ensure it handled add requests
+        jobManager.count();
+        MatcherAssert.assertThat("there should be 1 thread  actively waiting for jobs",
+                jobManager.getActiveConsumerCount(), equalTo(1));
+        jobDone.await(1, TimeUnit.MINUTES);
+        //sleep till it dies
+        mockTimer.incrementNs((long) (JobManager.NETWORK_CHECK_INTERVAL + TimeUnit.SECONDS.toNanos(keepAlive) * 1.33));
+        // give threads time to stop
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(3000);
+
+        MatcherAssert.assertThat("after keep alive timeout, there should NOT be any threads waiting",
+                jobManager.getActiveConsumerCount(), equalTo(0));
+
+        //disable network and add a network bound job
+        networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        final DummyJob dj1 = new DummyJob(new Params(0).requireNetwork());
+        jobManager.addJob(dj1);
+
+        mockTimer.incrementNs(JobManager.NETWORK_CHECK_INTERVAL +
+                TimeUnit.SECONDS.toNanos(keepAlive) * 2);
+
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                networkUtil.setNetworkStatus(NetworkUtil.METERED);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+                Assert.assertThat("it should be dj1", job, is((Job) dj1));
+            }
+        });
+        MatcherAssert.assertThat("when network is recovered, job should be handled",
+                jobManager.count(), equalTo(0));
+
+
+    }
+
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/LoadFactorTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/LoadFactorTest.java
new file mode 100644
index 0000000..8484fd8
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/LoadFactorTest.java
@@ -0,0 +1,78 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class LoadFactorTest extends JobManagerTestBase {
+    @Test
+    public void testLoadFactor() throws Exception {
+        //test adding zillions of jobs from the same group and ensure no more than 1 thread is created
+        int maxConsumerCount = 5;
+        int minConsumerCount = 2;
+        int loadFactor = 5;
+        enableDebug();
+        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
+                .maxConsumerCount(maxConsumerCount)
+                .minConsumerCount(minConsumerCount)
+                .loadFactor(loadFactor)
+                .timer(mockTimer));
+        final CountDownLatch runLock = new CountDownLatch(1);
+        Semaphore semaphore = new Semaphore(maxConsumerCount);
+        int totalJobCount = loadFactor * maxConsumerCount * 5;
+        List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
+        int prevConsumerCount = 0;
+        final Semaphore onRunCount = new Semaphore(totalJobCount);
+        onRunCount.acquire(totalJobCount);
+        for(int i = 0; i < totalJobCount; i ++) {
+
+            DummyJob job =
+                    new NeverEndingDummyJob(new Params((int)(Math.random() * 3)),runLock, semaphore) {
+                        @Override
+                        public void onRun() throws Throwable {
+                            onRunCount.release();
+                            super.onRun();
+                        }
+                    };
+            runningJobs.add(job);
+            jobManager.addJob(job);
+            final int wantedConsumers = (int) Math.ceil((i + 1f) / loadFactor);
+            final int expectedConsumerCount = Math.max(Math.min(i+1, minConsumerCount),
+                    Math.min(maxConsumerCount, wantedConsumers));
+
+            if (prevConsumerCount != expectedConsumerCount) {
+                MatcherAssert.assertThat("waiting for another job to start",
+                        onRunCount.tryAcquire(1, 10, TimeUnit.SECONDS), is(true));
+            }
+            MatcherAssert.assertThat("Consumer count should match expected value at " + (i+1) + " jobs",
+                    jobManager.getActiveConsumerCount(), equalTo(expectedConsumerCount));
+            prevConsumerCount = expectedConsumerCount;
+        }
+
+        //finish all jobs
+        waitUntilJobsAreDone(jobManager, runningJobs, new Runnable() {
+            @Override
+            public void run() {
+                runLock.countDown();
+            }
+        });
+        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
+
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/MultiThreadTest.java
similarity index 72%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/MultiThreadTest.java
index 1adfd56..49fc16d 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/MultiThreadTest.java
@@ -1,13 +1,15 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
+import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.path.android.jobqueue.CancelResult;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.CancelResult;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -25,9 +27,15 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class MultiThreadTest extends JobManagerTestBase {
     private static AtomicInteger multiThreadedJobCounter;
+
+    @Override
+    protected long getTimeout() {
+        return 60 * 5;
+    }
+
     @Test
     public void testMultiThreaded() throws Exception {
         multiThreadedJobCounter = new AtomicInteger(0);
@@ -56,6 +64,7 @@ public void run() {
             }));
         }
         // wait for some jobs to start
+        //noinspection SLEEP_IN_CODE
         Thread.sleep(1000);
         CancelResult cancelResult = jobManager.cancelJobs(TagConstraint.ALL, cancelTag);
         for (int  i = 0; i < cancelResult.getCancelledJobs().size(); i++) {
@@ -66,18 +75,19 @@ public void run() {
         }
         Log.d("TAG", "added all jobs");
         //wait until all jobs are added
+        //noinspection DIRECT_TIME_ACCESS
         long start = System.nanoTime();
-        long timeLimit = JobManager.NS_PER_MS * 20000;//20 seconds
+        long timeLimit = JobManager.NS_PER_MS * 60000 * 20;//20 minutes
+        //noinspection DIRECT_TIME_ACCESS
         while(System.nanoTime() - start < timeLimit && multiThreadedJobCounter.get() != 0) {
+            //noinspection SLEEP_IN_CODE
             Thread.sleep(1000);
         }
-        Log.d("TAG", "did we reach timeout? " + (System.nanoTime() - start >= timeLimit));
-
-        MatcherAssert.assertThat("jobmanager count should be 0",
-                jobManager.count(), equalTo(0));
 
+        MatcherAssert.assertThat("jobmanager count should be 0", jobManager.count(), equalTo(0));
+        jobManager.stopAndWaitUntilConsumersAreFinished();
         MatcherAssert.assertThat("multiThreadedJobCounter should be 0",
-                multiThreadedJobCounter.get(), equalTo(0));
+                multiThreadedJobCounter.get(), CoreMatchers.is(0));
 
     }
     public static class DummyJobForMultiThread extends DummyJob {
@@ -90,20 +100,29 @@ private DummyJobForMultiThread(int id, Params params) {
         @Override
         public void onRun() throws Throwable {
             super.onRun();
-            int remaining = multiThreadedJobCounter.decrementAndGet();
             //take some time
+            //noinspection SLEEP_IN_CODE
             Thread.sleep((long) (Math.random() * 1000));
             //throw exception w/ small chance
             if(Math.random() < .1) {
-                multiThreadedJobCounter.incrementAndGet();
                 throw new Exception("decided to die, will retry");
             }
-            Log.d("DummyJobForMultiThread", "persistent:" + isPersistent() + ", requires network:" + requiresNetwork() + ", running " + id + ", remaining: " + remaining);
+            int remaining = multiThreadedJobCounter.decrementAndGet();
         }
 
         @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return true;
+        protected int getRetryLimit() {
+            return 1000;
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            return RetryConstraint.RETRY;
         }
     };
+
+    @Override
+    protected boolean canUseRealTimer() {
+        return true;
+    }
 }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobTest.java
new file mode 100644
index 0000000..7f4bd7b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobTest.java
@@ -0,0 +1,208 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.callback.JobManagerCallback;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.MatcherAssert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.is;
+
+@RunWith(ParameterizedRobolectricTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class NetworkJobTest extends JobManagerTestBase {
+    final boolean unmetered;
+    static CountDownLatch persistentDummyJobRunLatch;
+
+    public NetworkJobTest(boolean unmetered) {
+        this.unmetered = unmetered;
+    }
+
+    @Before
+    public void cleanup() {
+        persistentDummyJobRunLatch = new CountDownLatch(1);
+    }
+
+    @ParameterizedRobolectricTestRunner.Parameters(name = "unmetered:{0}")
+    public static List<Object[]> getParams() {
+        return Arrays.asList(new Object[]{true}, new Object[]{false});
+    }
+
+    private Params addRequirement(Params params) {
+        if (unmetered) {
+            return params.requireUnmeteredNetwork();
+        } else {
+            return params.requireNetwork();
+        }
+    }
+
+    private Params addRequirement(Params params, long timeoutMs) {
+        if (unmetered) {
+            return params.requireUnmeteredNetworkWithTimeout(timeoutMs);
+        } else {
+            return params.requireNetworkWithTimeout(timeoutMs);
+        }
+    }
+
+    @Test
+    public void testNetworkJobWithTimeout() throws InterruptedException {
+        JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .networkUtil(dummyNetworkUtil)
+                        .timer(mockTimer));
+        final CountDownLatch runLatch = new CountDownLatch(1);
+        DummyJob networkDummyJob = new DummyJob(addRequirement(new Params(1), 4)){
+            @Override
+            public void onRun() throws Throwable {
+                runLatch.countDown();
+                super.onRun();
+            }
+        };
+        jobManager.addJob(networkDummyJob);
+        MatcherAssert.assertThat("job should not run", runLatch.await(3, TimeUnit.SECONDS),
+                is(false));
+        mockTimer.incrementMs(4);
+        MatcherAssert.assertThat("job should run because network wait timed out",
+                runLatch.await(3, TimeUnit.SECONDS), is(true));
+    }
+
+    @Test
+    public void testPersistentNetworkJobWithTimeout() throws InterruptedException {
+        JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .networkUtil(dummyNetworkUtil)
+                        .timer(mockTimer));
+        PersistentDummyJob networkDummyJob = new PersistentDummyJob(addRequirement(new Params(1),
+                4));
+        jobManager.addJob(networkDummyJob);
+        MatcherAssert.assertThat("job should not run",
+                persistentDummyJobRunLatch.await(3, TimeUnit.SECONDS), is(false));
+        mockTimer.incrementMs(4);
+        MatcherAssert.assertThat("job should run because network wait timed out",
+                persistentDummyJobRunLatch.await(3, TimeUnit.SECONDS), is(true));
+    }
+
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+    @Test
+    public void testNetworkJob() throws Exception {
+        enableDebug();
+        JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .networkUtil(dummyNetworkUtil)
+                        .timer(mockTimer));
+        jobManager.stop();
+
+        DummyJob networkDummyJob = new DummyJob(addRequirement(new Params(5)));
+        jobManager.addJob(networkDummyJob);
+
+        DummyJob noNetworkDummyJob = new DummyJob(new Params(2));
+        jobManager.addJob(noNetworkDummyJob);
+
+        DummyJob networkPersistentJob = new DummyJob(addRequirement(new Params(6).persist()));
+        jobManager.addJob(networkPersistentJob);
+
+        DummyJob noNetworkPersistentJob = new DummyJob(new Params(1).persist());
+        jobManager.addJob(noNetworkPersistentJob);
+
+        MatcherAssert.assertThat("count should be correct if there are network and non-network jobs w/o network", jobManager.count(), equalTo(4));
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED);
+        MatcherAssert.assertThat("count should be correct if there is network and non-network jobs w/o network", jobManager.count(), equalTo(4));
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        final CountDownLatch noNetworkLatch = new CountDownLatch(2);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                if (resultCode == JobManagerCallback.RESULT_SUCCEED) {
+                    MatcherAssert.assertThat("should be a no network job", job.requiresNetwork(mockTimer), is(false));
+                    noNetworkLatch.countDown();
+                    if (noNetworkLatch.getCount() == 0) {
+                        jobManager.removeCallback(this);
+                    }
+                }
+            }
+        });
+        jobManager.start();
+        MatcherAssert.assertThat(noNetworkLatch.await(1, TimeUnit.MINUTES), is(true));
+        MatcherAssert.assertThat("no network jobs should be executed even if there is no network", jobManager.count(), equalTo(2));
+        final CountDownLatch networkLatch = new CountDownLatch(2);
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                if (resultCode == JobManagerCallback.RESULT_SUCCEED) {
+                    MatcherAssert.assertThat("should be a network job", job.requiresNetwork(mockTimer), is(true));
+                    networkLatch.countDown();
+                    if (networkLatch.getCount() == 0) {
+                        jobManager.removeCallback(this);
+                    }
+                }
+            }
+        });
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED);
+        mockTimer.incrementMs(10000); // network check delay, make public?
+        if (unmetered) {
+            MatcherAssert.assertThat("if jobs require unmetered, they should not be run",
+                    networkLatch.await(10, TimeUnit.SECONDS), is(false));
+            MatcherAssert.assertThat(networkLatch.getCount(), is(2L));
+            dummyNetworkUtil.setNetworkStatus(NetworkUtil.UNMETERED);
+            mockTimer.incrementMs(10000); // network check delay
+        }
+        MatcherAssert.assertThat(networkLatch.await(1, TimeUnit.MINUTES), is(true));
+        MatcherAssert.assertThat("when network is recovered, all network jobs should be automatically consumed", jobManager.count(), equalTo(0));
+    }
+
+    public static class PersistentDummyJob extends Job {
+
+        public PersistentDummyJob(Params params) {
+            super(params.persist());
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            persistentDummyJobRunLatch.countDown();
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            throw new RuntimeException("not expected arrive here");
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
new file mode 100644
index 0000000..8394617
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
@@ -0,0 +1,61 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class NetworkJobWithConnectivityListenerTest extends JobManagerTestBase {
+    @Test
+    public void testNetworkJobWithConnectivityListener() throws Exception {
+        final DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .networkUtil(dummyNetworkUtil)
+                        .timer(mockTimer));
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED, true);
+        final DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
+        jobManager.addJob(dummyJob);
+        // no job to run so consumers should finish
+        jobManager.waitUntilConsumersAreFinished();
+        MatcherAssert.assertThat("count should be 1 as no jobs should be consumed w/o network", jobManager.count(), equalTo(1));
+        // JobManager may wake up as idle right here and see the new network value. sleep to avoid it
+        // count will trigger the queue and will result in another IDLE call. We need to wait until
+        // it is handled.
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(2000);
+
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED, false);
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(5000); //wait a little bit more to let consumer run
+        MatcherAssert.assertThat("even though network is recovered, job manager should not consume any job because it " +
+                "does not know (we did not inform)", jobManager.count(), equalTo(1));
+
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED, true);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+                MatcherAssert.assertThat("should be the added job", job, CoreMatchers.is((Job) dummyJob));
+            }
+        });
+        MatcherAssert.assertThat("job manager should consume network job after it is informed that network is recovered"
+                , jobManager.count(), equalTo(0));
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithFallbackTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithFallbackTest.java
new file mode 100644
index 0000000..fe16098
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkJobWithFallbackTest.java
@@ -0,0 +1,63 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.JobStatus;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.ParameterizedRobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.Arrays;
+import java.util.List;
+
+@RunWith(ParameterizedRobolectricTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class NetworkJobWithFallbackTest extends JobManagerTestBase {
+    private final boolean persistent;
+
+    public NetworkJobWithFallbackTest(boolean persistent) {
+        this.persistent = persistent;
+    }
+
+    @ParameterizedRobolectricTestRunner.Parameters(name = "persistent:{0}")
+    public static List<Object[]> getParams() {
+        return Arrays.asList(new Object[]{true}, new Object[]{false});
+    }
+
+    @Test
+    public void testFallbackFromUnmeteredToMobile() throws InterruptedException {
+        final DummyNetworkUtilWithConnectivityEventSupport networkUtil =
+                new DummyNetworkUtilWithConnectivityEventSupport();
+        networkUtil.setNetworkStatus(NetworkUtil.METERED);
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application).networkUtil(networkUtil)
+                .timer(mockTimer));
+        DummyJob dummyJob = new DummyJob(new Params(1).setPersistent(persistent)
+                .requireUnmeteredNetworkWithTimeout(2)
+                .requireNetworkWithTimeout(10));
+        jobManager.addJob(dummyJob);
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(2000);
+        MatcherAssert.assertThat(jobManager.getJobStatus(dummyJob.getId()), CoreMatchers.is(
+                JobStatus.WAITING_NOT_READY));
+        mockTimer.incrementMs(1);
+        //noinspection SLEEP_IN_CODE
+        Thread.sleep(2000);
+        MatcherAssert.assertThat(jobManager.getJobStatus(dummyJob.getId()), CoreMatchers.is(
+                JobStatus.WAITING_NOT_READY));
+        waitUntilJobsAreDone(jobManager, Arrays.asList(dummyJob), new Runnable() {
+            @Override
+            public void run() {
+                mockTimer.incrementMs(2);
+            }
+        });
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkNextJobTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
new file mode 100644
index 0000000..d4f86ba
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
@@ -0,0 +1,47 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.notNullValue;
+import static org.hamcrest.CoreMatchers.nullValue;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class NetworkNextJobTest extends JobManagerTestBase {
+
+    @Test
+    public void testNetworkNextJob() throws Throwable {
+        DummyNetworkUtil dummyNetworkUtil = new DummyNetworkUtil();
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .networkUtil(dummyNetworkUtil)
+                        .timer(mockTimer));
+        jobManager.stop();
+        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
+        jobManager.addJob(dummyJob);
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        MatcherAssert.assertThat("when there isn't any network, next job should return null",
+                nextJob(jobManager), nullValue());
+        MatcherAssert
+                .assertThat("even if there is network, job manager should return correct count",
+                        jobManager.count(), equalTo(1));
+        dummyNetworkUtil.setNetworkStatus(NetworkUtil.METERED);
+        JobHolder retrieved = nextJob(jobManager);
+        MatcherAssert
+                .assertThat("when network is recovered, next job should be retrieved", retrieved,
+                        notNullValue());
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PersistentJobTest.java
similarity index 80%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PersistentJobTest.java
index dae3514..5b69017 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PersistentJobTest.java
@@ -1,8 +1,8 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -14,7 +14,7 @@
 import java.util.concurrent.TimeUnit;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class PersistentJobTest extends JobManagerTestBase {
     //TEST parallel running
     public static CountDownLatch persistentRunLatch = new CountDownLatch(1);
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PriorityTest.java
similarity index 57%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PriorityTest.java
index 982d8fd..00a656b 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/PriorityTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/PriorityTest.java
@@ -1,31 +1,46 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+
+import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.*;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.is;
+
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class PriorityTest extends JobManagerTestBase {
     private static CountDownLatch priorityRunLatch;
 
     @Test
     public void testPriority() throws Exception {
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).maxConsumerCount(1));
+        JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .maxConsumerCount(1)
+                        .timer(mockTimer));
         testPriority(jobManager, false);
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public void testPriority(JobManager jobManager, boolean persist) throws Exception {
         priorityRunLatch = new CountDownLatch(2);
         DummyJobWithRunOrderAssert.globalRunCount = new AtomicInteger(0);
@@ -35,7 +50,7 @@ public void testPriority(JobManager jobManager, boolean persist) throws Exceptio
         jobManager.addJob(job1);
         jobManager.addJob(job2);
         jobManager.start();
-        priorityRunLatch.await(4, TimeUnit.SECONDS);
+        MatcherAssert.assertThat(priorityRunLatch.await(1, TimeUnit.MINUTES), is(true));
         //ensure both jobs did run
         MatcherAssert.assertThat((int) priorityRunLatch.getCount(), equalTo(0));
     }
@@ -61,13 +76,13 @@ public void onRun() throws Throwable {
         }
 
         @Override
-        protected void onCancel() {
-
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            return RetryConstraint.CANCEL;
         }
 
         @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return false;
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+
         }
     }
 }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
new file mode 100644
index 0000000..349a9ab
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
@@ -0,0 +1,48 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class ReRunWithLimitTest extends JobManagerTestBase {
+    @Test
+    public void testReRunWithLimit() throws Exception {
+        JobManager jobManager = createJobManager();
+        testReRun(jobManager, false);
+    }
+
+    @Test
+    public void testReRunWithLimitPersist() throws Exception {
+        JobManager jobManager = createJobManager();
+        testReRun(jobManager, true);
+    }
+
+    private void testReRun(final JobManager jobManager, boolean persist) throws InterruptedException {
+        DummyJobWithRunCount.runCount = 0;//reset
+        final DummyJobWithRunCount job = new DummyJobWithRunCount(persist);
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {
+
+            }
+        });
+
+
+        MatcherAssert.assertThat(DummyJobWithRunCount.runCount, equalTo(job.getRetryLimit()));
+        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RetryLogicTest.java
similarity index 71%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RetryLogicTest.java
index 87f2a42..bbf6b73 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RetryLogicTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RetryLogicTest.java
@@ -1,13 +1,20 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.RetryConstraint;
-import com.path.android.jobqueue.log.JqLog;
-import com.path.android.jobqueue.test.jobs.DummyJob;
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
 
-import org.hamcrest.CoreMatchers;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -15,23 +22,22 @@
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
 
-import android.util.Pair;
-
-import static org.hamcrest.MatcherAssert.*;
-import static org.hamcrest.CoreMatchers.*;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.MatcherAssert.assertThat;
+
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class RetryLogicTest extends JobManagerTestBase {
 
     static RetryProvider retryProvider;
@@ -71,7 +77,7 @@ public void testExponential() {
         assertThat("exp 3",RetryConstraint.createExponentialBackoff(3, 10).getNewDelayInMs(),
                 is(40L));
 
-        assertThat("exp 1",RetryConstraint.createExponentialBackoff(1, 5).getNewDelayInMs(),
+        assertThat("exp 1", RetryConstraint.createExponentialBackoff(1, 5).getNewDelayInMs(),
                 is(5L));
         assertThat("exp 2",RetryConstraint.createExponentialBackoff(2, 5).getNewDelayInMs(),
                 is(10L));
@@ -128,10 +134,11 @@ public void testChangeDelayOfTheGroupNonPersistent() throws InterruptedException
         testChangeDelayOfTheGroup(false);
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public void testChangeDelayOfTheGroup(Boolean persistent) throws InterruptedException {
+        final JobManager jobManager = createJobManager();
         canRun = true;
-        enableDebug();
-        RetryJob job1 = new RetryJob(new Params(2).setPersistent(Boolean.TRUE.equals(persistent)).groupBy("g1"));
+        final RetryJob job1 = new RetryJob(new Params(2).setPersistent(Boolean.TRUE.equals(persistent)).groupBy("g1"));
         job1.identifier = "job 1 id";
         RetryJob job2 = new RetryJob(new Params(2).setPersistent(!Boolean.FALSE.equals(persistent)).groupBy("g1"));
         job2.identifier = "job 2 id";
@@ -141,23 +148,31 @@ public void testChangeDelayOfTheGroup(Boolean persistent) throws InterruptedExce
         final String job2Id = job2.identifier;
         final PersistableDummyJob postTestJob = new PersistableDummyJob(new Params(1)
         .groupBy("g1").setPersistent(Boolean.TRUE.equals(persistent)));
+        final Semaphore jobsCanRun = new Semaphore(4);
+        jobsCanRun.acquire(3);
+        final Job[] unexpectedRun = new Job[1];
         retryProvider = new RetryProvider() {
             @Override
             public RetryConstraint build(Job job, Throwable throwable, int runCount,
                     int maxRunCount) {
                 RetryConstraint constraint = new RetryConstraint(true);
                 constraint.setNewDelayInMs(2000L);
+                JqLog.d("setting new delay in mS to %s. now is %s. job is %s", 2000, mockTimer.nanoTime(), ((RetryJob)job).identifier);
                 constraint.setApplyNewDelayToGroup(true);
                 return constraint;
             }
         };
         final List<Pair<String, Long>> runTimes = new ArrayList<>();
         final Map<String, Long> cancelTimes = new HashMap<>();
+        final Throwable[] lastJobRunOrder = new Throwable[1];
         onRunCallback = new Callback() {
             @Override
             public void on(Job job) {
                 RetryJob retryJob = (RetryJob) job;
-                runTimes.add(new Pair<>(retryJob.identifier, System.nanoTime()));
+                if (!jobsCanRun.tryAcquire() && unexpectedRun[0] == null) {
+                    unexpectedRun[0] = job;
+                }
+                runTimes.add(new Pair<>(retryJob.identifier, mockTimer.nanoTime()));
             }
         };
         onCancelCallback = new Callback() {
@@ -167,21 +182,71 @@ public void on(Job job) {
                 RetryJob retryJob = (RetryJob) job;
                 assertThat("Job should cancel only once",
                         cancelTimes.containsKey(retryJob.identifier), is(false));
-                cancelTimes.put(retryJob.identifier, System.nanoTime());
+                cancelTimes.put(retryJob.identifier, mockTimer.nanoTime());
                 if (!job.isPersistent() || postTestJob.isPersistent()) {
-                    assertThat("the 3rd job should not run until others cancel fully",
-                            dummyJobRunLatch.getCount(), is(1L));
+                    if (dummyJobRunLatch.getCount() != 1) {
+                        lastJobRunOrder[0] = new Exception("the 3rd job should not run until others cancel fully");
+                    }
                 }
             }
         };
         cancelLatch = new CountDownLatch(2);
+        final CountDownLatch jobRunLatch = new CountDownLatch(5);
+        final Throwable[] afterJobError = new Throwable[1];
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onJobRun(@NonNull Job job, int resultCode) {
+                synchronized (this) {
+                    try {
+                        if (job instanceof RetryJob) {
+                            RetryJob retryJob = (RetryJob) job;
+                            if (retryJob.identifier.equals(job1Id) &&
+                                    retryJob.getCurrentRunCount() == retryJob.getRetryLimit()) {
+                                jobsCanRun.release();
+                            }
+                        }
+                    } catch (Throwable t) {
+                        afterJobError[0] = t;
+                    }
+                }
+            }
 
-        JobManager jobManager = createJobManager();
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                synchronized (this) {
+                    try {
+                        if (job instanceof RetryJob) {
+                            assertThat("no job should have run unexpectedly " + jobRunLatch.getCount(),
+                                    unexpectedRun[0], nullValue());
+                            RetryJob retryJob = (RetryJob) job;
+                            if (retryJob.getCurrentRunCount() == 2) {
+                                // next job should be ready, asserted in onRun
+                            } else {
+                                mockTimer.incrementMs(1999);
+                                assertThat("no jobs should be ready", jobManager.countReadyJobs(), is(0));
+                                jobsCanRun.release();
+                                mockTimer.incrementMs(2);
+                            }
+                        }
+                    } catch (Throwable t) {
+                        afterJobError[0] = t;
+                        jobRunLatch.countDown();
+                        jobRunLatch.countDown();
+                        jobRunLatch.countDown();
+                        jobRunLatch.countDown();
+                        jobRunLatch.countDown();
+                    } finally {
+                        jobRunLatch.countDown();
+                    }
+                }
+            }
+        });
         jobManager.addJob(job1);
         jobManager.addJob(job2);
         jobManager.addJob(postTestJob);
-
-        assertThat("jobs should be canceled", cancelLatch.await(7, TimeUnit.SECONDS), is(true));
+        assertThat("all expected jobs should run", jobRunLatch.await(5, TimeUnit.MINUTES), is(true));
+        assertThat("on run assertions should all pass", afterJobError[0], nullValue());
+        assertThat("jobs should be canceled", cancelLatch.await(1, TimeUnit.MILLISECONDS), is(true));
         assertThat("should run 4 times", runTimes.size(), is(4));
         for (int i = 0; i < 4; i ++) {
             assertThat("first two runs should be job1, last two jobs should be job 2. checking " + i,
@@ -201,7 +266,10 @@ public void on(Job job) {
         dummyJobRunLatch = new CountDownLatch(1);
         jobManager.addJob(new PersistableDummyJob(new Params(1).groupBy("g1")));
         assertThat("a newly added job should just run quickly", dummyJobRunLatch.await(500,
-                TimeUnit.MILLISECONDS), is(true));
+                TimeUnit.MILLISECONDS),is
+
+            (true));
+        assertThat(lastJobRunOrder[0], nullValue());
     }
 
     @Test
@@ -214,6 +282,7 @@ public void testChangeDelayNonPersistent() throws InterruptedException {
         testChangeDelay(false);
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public void testChangeDelay(boolean persistent) throws InterruptedException {
         canRun = true;
         RetryJob job = new RetryJob(new Params(1).setPersistent(persistent));
@@ -231,11 +300,30 @@ public RetryConstraint build(Job job, Throwable throwable, int runCount,
         onRunCallback = new Callback() {
             @Override
             public void on(Job job) {
-                runTimes.add(System.nanoTime());
+                runTimes.add(mockTimer.nanoTime());
             }
         };
-        createJobManager().addJob(job);
-        assertThat("job should be canceled", cancelLatch.await(4, TimeUnit.SECONDS), is(true));
+        final Throwable[] callbackError = new Throwable[1];
+        final CountDownLatch runLatch = new CountDownLatch(2);
+        final JobManager jobManager = createJobManager();
+        jobManager.addCallback(new JobManagerCallbackAdapter() {
+            @Override
+            public void onAfterJobRun(@NonNull Job job, int resultCode) {
+                try {
+                    mockTimer.incrementMs(1999);
+                    assertThat("no jobs should be ready", jobManager.countReadyJobs(), is(0));
+                    mockTimer.incrementMs(2);
+                } catch (Throwable t) {
+                    callbackError[0] = t;
+                } finally {
+                    runLatch.countDown();
+                }
+            }
+        });
+        jobManager.addJob(job);
+        assertThat("on run callbacks should arrive", runLatch.await(100, TimeUnit.MINUTES), is(true));
+        assertThat("run callback should not have any errors", callbackError[0], nullValue());
+        assertThat("job should be canceled", cancelLatch.await(1, TimeUnit.SECONDS), is(true));
         assertThat("should run 2 times", runCount, is(2));
         long timeInBetween = TimeUnit.NANOSECONDS.toSeconds(runTimes.get(1) - runTimes.get(0));
         assertThat("time between two runs should be at least 2 seconds. " + timeInBetween,
@@ -253,6 +341,7 @@ public void testChangePriorityAndObserveExecutionOrderNonPersistent()
         testChangePriorityAndObserveExecutionOrder(false);
     }
 
+    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public void testChangePriorityAndObserveExecutionOrder(boolean persistent)
             throws InterruptedException {
         cancelLatch = new CountDownLatch(2);
@@ -426,7 +515,12 @@ public void onRun() throws Throwable {
             if (onRunLatch != null) {
                 onRunLatch.countDown();
             }
-            throw new RuntimeException("i like to fail please");
+            throw new RuntimeException("i like to fail please " + identifier);
+        }
+
+        @Override
+        public String toString() {
+            return "RETRY_JOB[" + identifier + "]";
         }
 
         @Override
@@ -435,7 +529,7 @@ protected int getRetryLimit() {
         }
 
         @Override
-        protected void onCancel() {
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
             if (onCancelCallback != null) {
                 onCancelCallback.on(this);
             }
@@ -443,8 +537,8 @@ protected void onCancel() {
         }
 
         @Override
-        protected RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount,
-                int maxRunCount) {
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount,
+                                                         int maxRunCount) {
             if (retryProvider != null) {
                 return retryProvider.build(this, throwable, runCount, maxRunCount);
             }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunFailingJobTest.java
similarity index 53%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunFailingJobTest.java
index 3c30f03..8e66dd9 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunFailingJobTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunFailingJobTest.java
@@ -1,21 +1,27 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import static org.hamcrest.CoreMatchers.*;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
-import com.path.android.jobqueue.Params;
-import org.hamcrest.*;
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+
+import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.*;
+import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
+import static org.hamcrest.CoreMatchers.equalTo;
+
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class RunFailingJobTest extends JobManagerTestBase {
     @Test
     public void runFailingJob() throws Exception {
@@ -33,13 +39,13 @@ public void onRun() throws Throwable {
             }
 
             @Override
-            protected void onCancel() {
+            protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
                 latch.countDown();
             }
 
             @Override
-            protected boolean shouldReRunOnThrowable(Throwable throwable) {
-                return false;
+            protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+                return RetryConstraint.CANCEL;
             }
         });
         latch.await(10, TimeUnit.SECONDS);
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
similarity index 81%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
index 6a74541..7df2808 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
@@ -1,7 +1,7 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -13,7 +13,7 @@
 import java.util.concurrent.TimeUnit;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class RunManyNonPersistentTest extends JobManagerTestBase {
     @Test
     public void runManyNonPersistentJobs() throws Exception {
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SchedulerSimpleTestCase.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SchedulerSimpleTestCase.java
new file mode 100644
index 0000000..9e459dd
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SchedulerSimpleTestCase.java
@@ -0,0 +1,138 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.network.NetworkUtil;
+import com.birbit.android.jobqueue.scheduling.Scheduler;
+import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mockito;
+import org.robolectric.ParameterizedRobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+@RunWith(ParameterizedRobolectricTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class SchedulerSimpleTestCase extends JobManagerTestBase {
+    final boolean persistent;
+    final boolean requireNetwork;
+    final boolean requireUnmeteredNetwork;
+    final long delayInMs;
+
+    public SchedulerSimpleTestCase(boolean persistent, boolean requireNetwork,
+                                   boolean requireUnmeteredNetwork, long delayInMs) {
+        this.persistent = persistent;
+        this.requireNetwork = requireNetwork;
+        this.requireUnmeteredNetwork = requireUnmeteredNetwork;
+        this.delayInMs = delayInMs;
+    }
+
+    @ParameterizedRobolectricTestRunner.Parameters(name =
+            "persistent: {0} reqNetwork: {1} reqUnmetered: {2} delay: {3}")
+    public static List<Object[]> getParams() {
+        List<Object[]> params = new ArrayList<>();
+        for (long delay : new long[]{0, 1000, JobManager.MIN_DELAY_TO_USE_SCHEDULER_IN_MS}) {
+            for (int i = 0; i < 8; i++) {
+                params.add(new Object[] {
+                        (i & 1) == 1,
+                        (i & 2) == 2,
+                        (i & 4) == 4,
+                        delay
+                });
+            }
+        }
+        return params;
+    }
+
+    @Test
+    public void testScheduleWhenJobAdded() throws InterruptedException {
+        Scheduler scheduler = Mockito.mock(Scheduler.class);
+        ArgumentCaptor<SchedulerConstraint> captor =
+                ArgumentCaptor.forClass(SchedulerConstraint.class);
+        DummyNetworkUtilWithConnectivityEventSupport networkUtil =
+                new DummyNetworkUtilWithConnectivityEventSupport();
+        Configuration.Builder builder = new Configuration.Builder(RuntimeEnvironment.application)
+                .timer(mockTimer)
+                .networkUtil(networkUtil)
+                .inTestMode()
+                .scheduler(scheduler, false);
+        if (requireUnmeteredNetwork) {
+            networkUtil.setNetworkStatus(NetworkUtil.UNMETERED);
+        } else if (requireNetwork) {
+            networkUtil.setNetworkStatus(NetworkUtil.METERED);
+        } else {
+            networkUtil.setNetworkStatus(NetworkUtil.DISCONNECTED);
+        }
+
+        final JobManager jobManager = createJobManager(builder);
+        Params params = new Params(1);
+        params.setPersistent(persistent);
+        params.setRequiresNetwork(requireNetwork);
+        params.setRequiresUnmeteredNetwork(requireUnmeteredNetwork);
+        params.setDelayMs(delayInMs);
+        final SchedulerJob job = new SchedulerJob(params);
+        waitUntilJobsAreDone(jobManager, Collections.singletonList(job), new Runnable() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+                mockTimer.incrementMs(delayInMs);
+            }
+        });
+        if (persistent && (requireNetwork || requireUnmeteredNetwork ||
+                delayInMs >= JobManager.MIN_DELAY_TO_USE_SCHEDULER_IN_MS)) {
+            Mockito.verify(scheduler).request(captor.capture());
+            SchedulerConstraint constraint = captor.getValue();
+            MatcherAssert.assertThat(constraint.getNetworkStatus(),
+                    CoreMatchers.is(requireUnmeteredNetwork ? NetworkUtil.UNMETERED :
+                    requireNetwork ? NetworkUtil.METERED : NetworkUtil.DISCONNECTED));
+            MatcherAssert.assertThat(constraint.getDelayInMs(), CoreMatchers.is(delayInMs));
+            Mockito.verify(scheduler).cancelAll();
+        } else {
+            Mockito.verify(scheduler, Mockito.never())
+                    .request(Mockito.any(SchedulerConstraint.class));
+        }
+    }
+
+    public static class SchedulerJob extends Job {
+
+        protected SchedulerJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
+
+        }
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            throw new UnsupportedOperationException("not expected to arrive here");
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SessionIdTest.java
similarity index 52%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SessionIdTest.java
index f145a6e..8b5a589 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SessionIdTest.java
@@ -1,13 +1,12 @@
-package com.path.android.jobqueue.test.jobmanager;
+package com.birbit.android.jobqueue.test.jobmanager;
 
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.fest.reflect.method.*;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
@@ -16,22 +15,20 @@
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class SessionIdTest extends JobManagerTestBase {
     @Test
-    public void testSessionId() throws Exception {
+    public void testSessionId() throws Throwable {
         JobManager jobManager = createJobManager();
-        Long sessionId = Reflection.field("sessionId").ofType(long.class)
-                .in(jobManager).get();
+        Long sessionId = mockTimer.nanoTime(); //we know job manager uses this value :/
         jobManager.stop();
         Job[] jobs = new Job[]{new DummyJob(new Params(0)), new DummyJob(new Params(0).persist())};
         for (Job job : jobs) {
             jobManager.addJob(job);
         }
 
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
         for (int i = 0; i < jobs.length; i++) {
-            JobHolder jobHolder = nextJobMethod.invoke();
+            JobHolder jobHolder = nextJob(jobManager);
             MatcherAssert.assertThat("session id should be correct for job " + i, jobHolder.getRunningSessionId(), equalTo(sessionId));
         }
     }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SingleIdTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SingleIdTest.java
new file mode 100644
index 0000000..e07692f
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SingleIdTest.java
@@ -0,0 +1,148 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class SingleIdTest extends JobManagerTestBase {
+
+    private String addJob(JobManager jobManager, Job job) {
+        jobManager.addJob(job);
+        return job.getId();
+    }
+
+    @Test
+    public void testSingleIdPersistent() throws Throwable {
+        testSingleId(true);
+    }
+
+    @Test
+    public void testSingleIdNonPersistent() throws Throwable {
+        testSingleId(false);
+    }
+
+    private void testSingleId(boolean persistent) throws Throwable {
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        String singleId = "forks";
+
+        DummyJob dummyJob1 = new DummyJob(new Params(0).setPersistent(persistent).setSingleId(singleId));
+        String jobId1 = addJob(jobManager, dummyJob1);
+
+        DummyJob dummyJob2 = new DummyJob(new Params(0).setPersistent(persistent));
+        String jobId2 = addJob(jobManager, dummyJob2);
+        assertThat("should add job if doesn't have singleId", jobManager.countReadyJobs(), is(2));
+
+        DummyJob dummyJob3 = new DummyJob(new Params(0).setPersistent(persistent).setSingleId("otherId"));
+        String jobId3 = addJob(jobManager, dummyJob3);
+        assertThat("should add job if different singleId", jobManager.countReadyJobs(), is(3));
+
+        DummyJob dummyJob4 = new DummyJob(new Params(0).setPersistent(persistent).setSingleId(singleId));
+        addJob(jobManager, dummyJob4);
+        assertThat("should not add job with same singleId", jobManager.countReadyJobs(), is(3));
+
+        assertThat("should return the same id", nextJob(jobManager).getId(), is(jobId1));
+        assertThat("should return the same id", nextJob(jobManager).getId(), is(jobId2));
+        assertThat("should return the same id", nextJob(jobManager).getId(), is(jobId3));
+        assertThat("should return the same id", nextJob(jobManager), is(nullValue()));
+    }
+
+    @Test
+    public void testSingleIdRunningPersistent() throws Exception {
+        testSingleIdRunning(true);
+    }
+
+    @Test
+    public void testSingleIdRunningNonPersistent() throws Exception {
+        testSingleIdRunning(false);
+    }
+
+    private void testSingleIdRunning(boolean persistent) throws InterruptedException {
+        JobManager jobManager = createJobManager();
+        String singleId = "dorks";
+        CountDownLatch latchWait = new CountDownLatch(1);
+        CountDownLatch latchRunning = new CountDownLatch(1);
+
+        DummyJob dummyJob1 = new SerializableDummyTwoLatchJob(
+                new Params(0).setPersistent(persistent).setSingleId(singleId).setGroupId(singleId), latchWait, latchRunning);
+        addJob(jobManager, dummyJob1);
+        jobManager.start();
+        latchRunning.await(5, TimeUnit.SECONDS); //let job1 start running
+        jobManager.stop();
+        assertThat("should not be marked ready", jobManager.count(), is(0));
+
+        CountDownLatch latchRunning2 = new CountDownLatch(1);
+        DummyJob dummyJob2 = new SerializableDummyLatchJob(new Params(0).setPersistent(persistent).setSingleId(singleId).setGroupId(singleId), latchRunning2);
+        addJob(jobManager, dummyJob2);
+        assertThat("should add new job if first job was running", jobManager.count(), is(1));
+        DummyJob dummyJob3 = new DummyJob(new Params(0).setPersistent(persistent).setSingleId(singleId).setGroupId(singleId));
+        addJob(jobManager, dummyJob3);
+        assertThat("should not add new job if already queued", jobManager.count(), is(1));
+
+        latchWait.countDown();//let job1 finish
+        jobManager.start();
+        assertThat("job should have run", latchRunning2.await(5, TimeUnit.SECONDS), is(true)); //wait until job2 runs
+        jobManager.stopAndWaitUntilConsumersAreFinished();
+        assertThat("job should not have run", dummyJob3.getOnRunCnt(), is(0));
+        assertThat("should have called onCancel", dummyJob3.getOnCancelCnt(), is(1));
+
+        DummyJob dummyJob4 = new DummyJob(new Params(0).setPersistent(persistent).setSingleId(singleId).setGroupId(singleId));
+        addJob(jobManager, dummyJob4);
+        assertThat("should be added if all others have run", jobManager.count(), is(1));
+    }
+
+    private static class SerializableDummyTwoLatchJob extends DummyJob {
+
+        static CountDownLatch sLatchWait;
+        static CountDownLatch sLatchRunning;
+
+        public SerializableDummyTwoLatchJob(Params params, CountDownLatch latchWait, CountDownLatch latchRunning) {
+            super(params);
+            sLatchWait = latchWait;
+            sLatchRunning = latchRunning;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            sLatchRunning.countDown();
+            sLatchWait.await();
+            sLatchRunning = null;
+            sLatchWait = null;
+        }
+    }
+
+    private static class SerializableDummyLatchJob extends DummyJob {
+
+        static CountDownLatch sLatchRunning;
+        int onRunCnt = 0;
+
+        public SerializableDummyLatchJob(Params params, CountDownLatch latchRunning) {
+            super(params);
+            sLatchRunning = latchRunning;
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            super.onRun();
+            sLatchRunning.countDown();
+            sLatchRunning = null;
+        }
+    }
+
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
similarity index 73%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
index e39a844..473d5e5 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
@@ -1,20 +1,27 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.*;
+import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
 
 import java.util.concurrent.CountDownLatch;
 
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.MatcherAssert.assertThat;
+
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class SlowOnAddedTest extends JobManagerTestBase {
     @Test
     public void testNonPersistent() throws InterruptedException {
@@ -54,6 +61,7 @@ protected MyDummyPersistentJob(int priority) {
         @Override
         public void onAdded() {
             try {
+                //noinspection SLEEP_IN_CODE
                 Thread.sleep(2000);
             } catch (InterruptedException e) {
                 //
@@ -68,13 +76,13 @@ public void onRun() throws Throwable {
         }
 
         @Override
-        protected void onCancel() {
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
 
         }
 
         @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return true;
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            return RetryConstraint.RETRY;
         }
     }
 
@@ -88,6 +96,7 @@ protected MyDummyJob(Params params, CountDownLatch latch) {
         @Override
         public void onAdded() {
             try {
+                //noinspection SLEEP_IN_CODE
                 Thread.sleep(2000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ThreadFactoryTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ThreadFactoryTest.java
new file mode 100644
index 0000000..e38d657
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobmanager/ThreadFactoryTest.java
@@ -0,0 +1,92 @@
+package com.birbit.android.jobqueue.test.jobmanager;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
+import com.birbit.android.jobqueue.config.Configuration;
+
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.util.UUID;
+import java.util.concurrent.ThreadFactory;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class ThreadFactoryTest extends JobManagerTestBase {
+
+    private Throwable error;
+
+    @Test
+    public void testThreadFactory() throws Throwable {
+        final JobManager jobManager = createJobManager(
+                new Configuration.Builder(RuntimeEnvironment.application)
+                        .timer(mockTimer)
+                        .threadFactory(new ThreadFactory() {
+                            @Override
+                            public Thread newThread(@NonNull Runnable r) {
+                                return new DummyThread(r);
+                            }
+                        })
+        );
+        final Job job = new CheckWorkerJob();
+        waitUntilAJobIsDone(jobManager, new WaitUntilCallback() {
+            @Override
+            public void run() {
+                jobManager.addJob(job);
+            }
+
+            @Override
+            public void assertJob(Job job) {}
+        });
+        if (error != null) {
+            throw error;
+        }
+    }
+
+    static class DummyThread extends Thread {
+
+        public DummyThread(Runnable runnable) {
+            super(runnable, "dummy-worker-" + UUID.randomUUID().toString());
+        }
+
+    }
+
+    class CheckWorkerJob extends Job {
+
+        protected CheckWorkerJob() {
+            super(new Params(1));
+        }
+
+        @Override
+        public void onAdded() {}
+
+        @Override
+        public void onRun() throws Throwable {
+            try {
+                MatcherAssert.assertThat("Worker thread should be an instance of DummyThread",
+                                         Thread.currentThread() instanceof DummyThread);
+            } catch (Throwable e) {
+                error = e;
+            }
+        }
+
+        @Override
+        protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {}
+
+        @Override
+        protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
+            return RetryConstraint.CANCEL;
+        }
+    }
+
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
new file mode 100644
index 0000000..68bdedc
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
@@ -0,0 +1,28 @@
+package com.birbit.android.jobqueue.test.jobqueue;
+
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
+import com.birbit.android.jobqueue.test.util.JobQueueFactory;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class CachedPersistentJobQueueTest extends JobQueueTestBase {
+    public CachedPersistentJobQueueTest() {
+        super(new JobQueueFactory() {
+            @Override
+            public JobQueue createNew(long sessionId, String id, Timer timer) {
+                SqliteJobQueue.JavaSerializer jobSerializer = new SqliteJobQueue.JavaSerializer();
+                return new SqliteJobQueue(
+                        new Configuration.Builder(RuntimeEnvironment.application)
+                        .id(id).jobSerializer(jobSerializer).inTestMode()
+                        .timer(timer).build(), sessionId, jobSerializer);
+            }
+        });
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobParamsTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobParamsTest.java
new file mode 100644
index 0000000..108f0ed
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobParamsTest.java
@@ -0,0 +1,93 @@
+package com.birbit.android.jobqueue.test.jobqueue;
+
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.test.TestBase;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class JobParamsTest extends TestBase {
+    @Test
+    public void assertParamsUnderstood() {
+        DummyJob j1 = new DummyJob(new Params(1).requireNetwork());
+        MockTimer mockTimer = new MockTimer();
+        assertThat("require network param should be understood properly", j1.requiresNetwork(
+                mockTimer), equalTo(true));
+        j1.seal(mockTimer);
+        assertThat("require network param should be understood properly",
+                j1.getRequiresNetworkUntilNs(), equalTo(Params.FOREVER));
+        assertThat("require unmetered network param should be understood properly",
+                j1.getRequiresUnmeteredNetworkUntilNs(), equalTo(Params.NEVER));
+        DummyJob j2 = new DummyJob(new Params(1).groupBy("blah"));
+        assertThat("group param should be understood properly", j2.getRunGroupId(), equalTo("blah"));
+        j2.seal(mockTimer);
+        assertThat("require network param should be understood properly",
+                j2.getRequiresNetworkUntilNs(), equalTo(Params.NEVER));
+        assertThat("require unmetered network param should be understood properly",
+                j2.getRequiresUnmeteredNetworkUntilNs(), equalTo(Params.NEVER));
+        DummyJob j3 = new DummyJob(new Params(1).persist());
+        assertThat("persist param should be understood properly", j3.isPersistent(), equalTo(true));
+        DummyJob j4 = new DummyJob(new Params(1).setPersistent(false).setRequiresNetwork(false).setGroupId(null).setSingleId(null));
+        assertThat("persist param should be understood properly", j4.isPersistent(), equalTo(false));
+        assertThat("require network param should be understood properly", j4.requiresNetwork(
+                mockTimer), equalTo(false));
+        assertThat("require unmetered network param should be understood properly",
+                j4.requiresUnmeteredNetwork(mockTimer), equalTo(false));
+        assertThat("group param should be understood properly", j4.getRunGroupId(), nullValue());
+        assertThat("single param should be understood properly", j4.getSingleInstanceId(), nullValue());
+
+        DummyJob j5 = new DummyJob(new Params(1).requireNetworkWithTimeout(15));
+        mockTimer.incrementMs(2);
+        j5.seal(mockTimer);
+        assertThat("network requirement with timeout should be understood properly",
+                j5.getRequiresNetworkUntilNs(), is(17000000L));
+        assertThat("network unmetered requirement with timeout should be understood properly",
+                j5.getRequiresNetworkUntilNs(), is(17000000L));
+
+        DummyJob j6 = new DummyJob(new Params(1).requireUnmeteredNetworkWithTimeout(15));
+        mockTimer.incrementMs(2);
+        j6.seal(mockTimer);
+        assertThat("requireNetwork should be set from UNMETERED if it is not specified",
+                j6.getRequiresNetworkUntilNs(), is(19000000L));
+        assertThat("network unmetered requirement with timeout should be understood properly",
+                j6.getRequiresUnmeteredNetworkUntilNs(), is(19000000L));
+
+        DummyJob j7 = new DummyJob(new Params(1).requireUnmeteredNetworkWithTimeout(15)
+                .requireNetworkWithTimeout(20));
+        mockTimer.incrementMs(2);
+        j7.seal(mockTimer);
+        assertThat("requireNetwork should be kept when both are specified",
+                j7.getRequiresNetworkUntilNs(), is(26000000L));
+        assertThat("network unmetered requirement with timeout should be understood properly",
+                j7.getRequiresUnmeteredNetworkUntilNs(), is(21000000L));
+
+        DummyJob j8 = new DummyJob(new Params(1).requireUnmeteredNetworkWithTimeout(15)
+                .requireNetwork());
+        j8.seal(mockTimer);
+        assertThat("requireNetwork should be kept when both are specified",
+                j8.getRequiresNetworkUntilNs(), is(Params.FOREVER));
+        assertThat("network unmetered requirement with timeout should be understood properly",
+                j8.getRequiresUnmeteredNetworkUntilNs(), is(21000000L));
+
+        DummyJob j9 = new DummyJob(new Params(1).requireUnmeteredNetworkWithTimeout(15)
+                .requireNetworkWithTimeout(10));
+        mockTimer.setNow(10000000);
+        j9.seal(mockTimer);
+        assertThat("if requireNetwork is less than require unmetered, it should be overridden.",
+                j9.getRequiresNetworkUntilNs(), is(25000000L));
+        assertThat("network unmetered requirement with timeout should be understood properly",
+                j9.getRequiresUnmeteredNetworkUntilNs(), is(25000000L));
+
+        DummyJob j10 = new DummyJob(new Params(1).singleInstanceBy("bloop"));
+        assertThat("single param should be understood properly", j10.getSingleInstanceId(), endsWith("bloop"));
+        assertThat("group param should be automatically set if single instance", j10.getRunGroupId(), notNullValue());
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobQueueTestBase.java
similarity index 52%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobQueueTestBase.java
index c9c8343..786205d 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/JobQueueTestBase.java
@@ -1,21 +1,23 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
+package com.birbit.android.jobqueue.test.jobqueue;
+
+import com.birbit.android.jobqueue.Constraint;
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.TestConstraint;
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.TagConstraint;
+import com.birbit.android.jobqueue.test.TestBase;
+import com.birbit.android.jobqueue.test.jobs.DummyJob;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+import com.birbit.android.jobqueue.test.util.JobQueueFactory;
+
 import org.fest.reflect.core.*;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;
 
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
-import org.hamcrest.MatcherAssert;
-import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -28,42 +30,40 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
-import static com.path.android.jobqueue.TagConstraint.ALL;
-import static com.path.android.jobqueue.TagConstraint.ANY;
+import static com.birbit.android.jobqueue.TagConstraint.ALL;
+import static com.birbit.android.jobqueue.TagConstraint.ANY;
+import static com.birbit.android.jobqueue.TestConstraint.forTags;
 
 @Ignore
 public abstract class JobQueueTestBase extends TestBase {
     JobQueueFactory currentFactory;
-
+    MockTimer mockTimer = new MockTimer();
     public JobQueueTestBase(JobQueueFactory factory) {
         currentFactory = factory;
     }
 
-    @Before
-    public void setup() {
-        enableDebug();
-    }
-
     @Test
     public void testBasicAddRemoveCount() throws Exception {
         final int ADD_COUNT = 6;
         JobQueue jobQueue = createNewJobQueue();
         assertThat((int) jobQueue.count(), equalTo(0));
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setExcludeRunning(true);
+        assertThat(jobQueue.nextJobAndIncRunCount(constraint), nullValue());
         for (int i = 0; i < ADD_COUNT; i++) {
             JobHolder holder = createNewJobHolder();
             jobQueue.insert(holder);
             assertThat((int) jobQueue.count(), equalTo(i + 1));
-            assertThat(holder.getId(), notNullValue());
+            assertThat(holder.getInsertionOrder(), equalTo(i + 1L));
             jobQueue.insertOrReplace(holder);
             assertThat((int) jobQueue.count(), equalTo(i + 1));
         }
-        JobHolder firstHolder = jobQueue.nextJobAndIncRunCount(true, null);
+        JobHolder firstHolder = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat(firstHolder.getRunCount(), equalTo(1));
         //size should be down 1
         assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 1));
         //should return another job
-        JobHolder secondHolder = jobQueue.nextJobAndIncRunCount(true, null);
+        JobHolder secondHolder = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat(secondHolder.getRunCount(), equalTo(1));
         //size should be down 2
         assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
@@ -88,24 +88,25 @@ public void testPriority() throws Exception {
         }
         //ensure we get jobs in correct priority order
         int minPriority = Integer.MAX_VALUE;
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setExcludeRunning(true);
         for (int i = 0; i < JOB_LIMIT; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
+            JobHolder holder = jobQueue.nextJobAndIncRunCount(constraint);
             assertThat(holder.getPriority() <= minPriority, is(true));
         }
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
+        assertThat(jobQueue.nextJobAndIncRunCount(constraint), nullValue());
     }
 
 
     @Test
     public void testDelayUntilWithPriority() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
-        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5), now + 10000 * JobManager.NS_PER_MS);
-        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now + 20000 * JobManager.NS_PER_MS);
+        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5), 1);
+        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), 2);
         jobQueue.insert(lowPriorityHolder);
         jobQueue.insert(highPriorityHolder);
         assertThat("when asked, if lower priority job has less delay until, we should return it",
-                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(
+                jobQueue.getNextJobDelayUntilNs(new TestConstraint(mockTimer)), equalTo(
                 lowPriorityHolder.getDelayUntilNs()));
 
     }
@@ -113,106 +114,121 @@ public void testDelayUntilWithPriority() throws Exception {
     @Test
     public void testGroupId() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long jobId1 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        long jobId2 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        long jobId3 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
-        long jobId4 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
-        long jobId5 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
-        JobHolder holder1 = jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group2"}));
-        assertThat("first jobs should be from group group2 if group1 is excluded",
-                holder1.getJob().getRunGroupId(), equalTo("group1"));
+        JobHolder jobHolder1 = createNewJobHolder(new Params(0).groupBy("group1"));
+        JobHolder jobHolder2 = createNewJobHolder(new Params(0).groupBy("group1"));
+        JobHolder jobHolder3 = createNewJobHolder(new Params(0).groupBy("group2"));
+        JobHolder jobHolder4 = createNewJobHolder(new Params(0).groupBy("group2"));
+        JobHolder jobHolder5 = createNewJobHolder(new Params(0).groupBy("group1"));
+        jobQueue.insert(jobHolder1);
+        jobQueue.insert(jobHolder2);
+        jobQueue.insert(jobHolder3);
+        jobQueue.insert(jobHolder4);
+        jobQueue.insert(jobHolder5);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setExcludeRunning(true);
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group2"}));
+        JobHolder received = jobQueue.nextJobAndIncRunCount(constraint);
+        assertThat("first jobs should be from group group1 if group2 is excluded",
+                received.getJob().getRunGroupId(), equalTo("group1"));
         assertThat("correct job should be returned if groupId is provided",
-                holder1.getId(), equalTo(jobId1));
+                received.getId(), equalTo(jobHolder1.getId()));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1", "group2"}));
         assertThat("no jobs should be returned if all groups are excluded",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})),
-                is(nullValue()));
-        long jobId6 = jobQueue.insert(createNewJobHolder(new Params(0)));
+                jobQueue.nextJobAndIncRunCount(constraint), is(nullValue()));
+        JobHolder jobHolder6 = createNewJobHolder(new Params(0));
+        jobQueue.insert(jobHolder6);
+        JobHolder tmpReceived = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("both groups are disabled, null group job should be returned",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})).getId(),
-                is(jobId6));
+                tmpReceived.getId(),
+                is(jobHolder6.getId()));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1"}));
         assertThat("if group1 is excluded, next job should be from group2",
-                jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group1"})).getJob().getRunGroupId()
+                jobQueue.nextJobAndIncRunCount(constraint).getJob().getRunGroupId()
                 , equalTo("group2"));
 
         //to test re-run case, add the job back in
-        jobQueue.insertOrReplace(holder1);
+        assertThat(jobQueue.insertOrReplace(received), is(true));
         //ask for it again, should return the same holder because it is grouped
-        JobHolder holder2 = jobQueue.nextJobAndIncRunCount(true, null);
+        constraint.clear();
+        constraint.setExcludeRunning(true);
+        JobHolder received2 = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("for grouped jobs, re-fetching job should work fine",
-                holder2.getId(), equalTo(holder1.getId()));
-
-        JobHolder holder3 = jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1"}));
-        assertThat("if a group it excluded, next available from another group should be returned",
-                holder3.getId(), equalTo(jobId4));
+                received2.getId(), equalTo(received.getId()));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1"}));
+        JobHolder received3 = jobQueue.nextJobAndIncRunCount(constraint);
+        assertThat("if a group is excluded, next available from another group should be returned",
+                received3.getId(), equalTo(jobHolder4.getId()));
 
         //add two more non-grouped jobs
-        long jobId7 = jobQueue.insert(createNewJobHolder(new Params(0)));
-        long jobId8 = jobQueue.insert(createNewJobHolder(new Params(0)));
-        JobHolder holder4 = jobQueue.nextJobAndIncRunCount(true,
-                Arrays.asList(new String[]{"group1", "group2"}));
-        assertThat("if all grouped jobs are excluded, non-grouped jobs should be returned",
+        JobHolder jobHolder7 = createNewJobHolder(new Params(0));
+        jobQueue.insert(jobHolder7);
+        JobHolder jobHolder8 = createNewJobHolder(new Params(0));
+        jobQueue.insert(jobHolder8);
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1", "group2"}));
+        JobHolder holder4 = jobQueue.nextJobAndIncRunCount(constraint);
+        assertThat("if all grouped jobs are excluded, next non-grouped job should be returned",
                 holder4.getId(),
-                equalTo(jobId7));
+                equalTo(jobHolder7.getId()));
         jobQueue.insertOrReplace(holder4);
         //for non-grouped jobs, run counts should be respected
         assertThat("if all grouped jobs are excluded, re-inserted highest priority job should still be returned",
-                jobQueue.nextJobAndIncRunCount(true,
-                        Arrays.asList(new String[]{"group1", "group2"})).getId(),
-                equalTo(jobId7));
+                jobQueue.nextJobAndIncRunCount(constraint).getId(),
+                equalTo(jobHolder7.getId()));
     }
 
     @Test
     public void testDueDelayUntilWithPriority() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
+        mockTimer.setNow(2000);
+        long now = mockTimer.nanoTime();
         JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5),now - 1000 * JobManager.NS_PER_MS);
         JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now - 10000 * JobManager.NS_PER_MS);
         jobQueue.insert(lowPriorityHolder);
         jobQueue.insert(highPriorityHolder);
         long soonJobDelay = 2000;
         JobHolder highestPriorityDelayedJob = createNewJobHolderWithDelayUntil(new Params(12), now + soonJobDelay * JobManager.NS_PER_MS);
-        long highestPriorityDelayedJobId = jobQueue.insert(highestPriorityDelayedJob);
+        jobQueue.insert(highestPriorityDelayedJob);
+        Constraint constraint = new Constraint();
+        constraint.setNowInNs(mockTimer.nanoTime());
         assertThat("when asked, if job's due has passed, highest priority jobs's delay until should be " +
                 "returned",
-                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(highPriorityHolder.getDelayUntilNs()));
+                jobQueue.getNextJobDelayUntilNs(constraint), equalTo(highPriorityHolder.getDelayUntilNs()));
         //make sure soon job is valid now
-        Thread.sleep(soonJobDelay);
+        mockTimer.incrementMs(soonJobDelay + 1);
 
         assertThat("when a job's time come, it should be returned",
-                jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(highestPriorityDelayedJobId));
+                jobQueue.nextJobAndIncRunCount(constraint).getId(), equalTo(highestPriorityDelayedJob.getId()));
     }
 
     @Test
     public void testDelayUntil() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
-        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork(), now + 200000 * JobManager.NS_PER_MS);
+        long now = mockTimer.nanoTime();
+        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork(), now + 2);
 
-        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(new Params(0), now + 500000 * JobManager.NS_PER_MS);
+        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(new Params(0), now + 5);
 
         jobQueue.insert(networkJobHolder);
         jobQueue.insert(noNetworkJobHolder);
-
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
         assertThat("if there is no network, delay until should be provided for no network job",
-            jobQueue.getNextJobDelayUntilNs(false, null), equalTo(noNetworkJobHolder.getDelayUntilNs()));
-
+            jobQueue.getNextJobDelayUntilNs(constraint), equalTo(noNetworkJobHolder.getDelayUntilNs()));
+        constraint.clear();
         assertThat("if there is network, delay until should be provided for network job because it is " +
-                "sooner", jobQueue.getNextJobDelayUntilNs(true, null), equalTo(networkJobHolder.getDelayUntilNs()));
+                "sooner", jobQueue.getNextJobDelayUntilNs(constraint), equalTo(networkJobHolder.getDelayUntilNs()));
 
-        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0), now + 100000 * JobManager.NS_PER_MS);
+        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0), now + 1);
 
         jobQueue.insert(noNetworkJobHolder2);
         assertThat("if there is network, any job's delay until should be returned",
-                jobQueue.getNextJobDelayUntilNs(true, null), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
+                jobQueue.getNextJobDelayUntilNs(constraint), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
     }
 
     @Test
     public void testDelayUntilWithExcludeGroups() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long now = System.nanoTime();
+        long now = mockTimer.nanoTime();
         JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork()
                 .groupBy("group1"), now + 200000 * JobManager.NS_PER_MS);
 
@@ -221,34 +237,42 @@ public void testDelayUntilWithExcludeGroups() throws Exception {
 
         jobQueue.insert(networkJobHolder);
         jobQueue.insert(noNetworkJobHolder);
-
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        constraint.setExcludeRunning(true);
         assertThat("if there is no network, delay until should be provided for no network job",
-                jobQueue.getNextJobDelayUntilNs(false, null),
+                jobQueue.getNextJobDelayUntilNs(constraint),
                 equalTo(noNetworkJobHolder.getDelayUntilNs()));
         assertThat("if there is no network, delay until should be provided for no network job",
-                jobQueue.getNextJobDelayUntilNs(false, new ArrayList<String>()),
+                jobQueue.getNextJobDelayUntilNs(constraint),
                 equalTo(noNetworkJobHolder.getDelayUntilNs()));
-
+        constraint.setExcludeGroups(Arrays.asList("group2"));
+        constraint.setShouldNotRequireNetwork(true);
         assertThat("if there is no network, but the group is disabled, delay until should be null",
-                jobQueue.getNextJobDelayUntilNs(false, Arrays.asList("group2")), nullValue());
-
+                jobQueue.getNextJobDelayUntilNs(constraint), nullValue());
+        constraint.setShouldNotRequireNetwork(false);
+        constraint.setExcludeGroups(Arrays.asList("group1", "group2"));
         assertThat("if there is network, but both groups are disabled, delay until should be null"
-                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1", "group2")),
+                , jobQueue.getNextJobDelayUntilNs(constraint),
                 nullValue());
+        constraint.setShouldNotRequireNetwork(false);
+        constraint.setExcludeGroups(Arrays.asList("group1"));
         assertThat("if there is network, but group1 is disabled, delay should come from group2"
-                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1")),
+                , jobQueue.getNextJobDelayUntilNs(constraint),
                 equalTo(noNetworkJobHolder.getDelayUntilNs()));
+        constraint.setExcludeGroups(Arrays.asList("group2"));
         assertThat("if there is network, but group2 is disabled, delay should come from group1"
-                , jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group2")),
+                , jobQueue.getNextJobDelayUntilNs(constraint),
                 equalTo(networkJobHolder.getDelayUntilNs()));
 
         JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0),
                 now + 100000 * JobManager.NS_PER_MS);
-
+        constraint.setExcludeGroups(Arrays.asList("group1", "group2"));
+        constraint.setShouldNotRequireNetwork(false);
         jobQueue.insert(noNetworkJobHolder2);
         assertThat("if there is a 3rd job and other gorups are disabled. 3rd job's delay should be "
                         + "returned",
-                jobQueue.getNextJobDelayUntilNs(true, Arrays.asList("group1", "group2")),
+                jobQueue.getNextJobDelayUntilNs(constraint),
                 equalTo(noNetworkJobHolder2.getDelayUntilNs()));
     }
 
@@ -273,11 +297,11 @@ public void testPriorityWithDelayedJobs() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         JobHolder delayedPriority_5 = createNewJobHolder(new Params(5));
         org.fest.reflect.field.Invoker<Long> delayUntilField = getDelayUntilNsField(delayedPriority_5);
-        delayUntilField.set(System.nanoTime() - 1000);
+        delayUntilField.set(mockTimer.nanoTime() - 1000);
 
         JobHolder delayedPriority_2 = createNewJobHolder(new Params(2));
         delayUntilField = getDelayUntilNsField(delayedPriority_2);
-        delayUntilField.set(System.nanoTime() - 500);
+        delayUntilField.set(mockTimer.nanoTime() - 500);
 
 
 
@@ -291,10 +315,10 @@ public void testPriorityWithDelayedJobs() throws Exception {
         jobQueue.insert(nonDelayedPriority_6);
         jobQueue.insert(nonDelayedPriority_2);
         jobQueue.insert(nonDelayedPriority_3);
-
+        TestConstraint constraint = new TestConstraint(mockTimer);
         int lastPriority = Integer.MAX_VALUE;
         for(int i = 0; i < 5; i++) {
-            JobHolder next = jobQueue.nextJobAndIncRunCount(true, null);
+            JobHolder next = jobQueue.nextJobAndIncRunCount(constraint);
             assertThat("next job should not be null", next, notNullValue());
             assertThat("next job's priority should be lower then previous for job " + i, next.getPriority() <= lastPriority, is(true));
             lastPriority = next.getPriority();
@@ -324,7 +348,7 @@ public void testSessionId() throws Exception {
         JobQueue jobQueue = createNewJobQueueWithSessionId(sessionId);
         JobHolder jobHolder = createNewJobHolder();
         jobQueue.insert(jobHolder);
-        jobHolder = jobQueue.nextJobAndIncRunCount(true, null);
+        jobHolder = jobQueue.nextJobAndIncRunCount(new TestConstraint(mockTimer));
         assertThat("session id should be attached to next job",
                 jobHolder.getRunningSessionId(), equalTo(sessionId));
     }
@@ -340,11 +364,11 @@ public void testPriorityWithReAdd() throws Exception {
         //ensure we get jobs in correct priority order
         int minPriority = Integer.MAX_VALUE;
         for (int i = 0; i < JOB_LIMIT; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
+            JobHolder holder = jobQueue.nextJobAndIncRunCount(new TestConstraint(mockTimer));
             assertThat(holder.getPriority() <= minPriority, is(true));
             jobQueue.insertOrReplace(holder);
         }
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), notNullValue());
+        assertThat(jobQueue.nextJobAndIncRunCount(new TestConstraint(mockTimer)), notNullValue());
     }
 
     @Test
@@ -352,11 +376,12 @@ public void testRemove() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         JobHolder holder = createNewJobHolder();
         jobQueue.insert(holder);
-        Long jobId = holder.getId();
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(jobId));
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setExcludeRunning(true);
+        assertThat(jobQueue.nextJobAndIncRunCount(constraint).getId(), equalTo(holder.getId()));
+        assertThat(jobQueue.nextJobAndIncRunCount(constraint), is(nullValue()));
         jobQueue.remove(holder);
-        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
+        assertThat(jobQueue.nextJobAndIncRunCount(constraint), is(nullValue()));
     }
 
     @Test
@@ -364,54 +389,58 @@ public void testNetwork() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         JobHolder jobHolder = createNewJobHolder(new Params(0));
         jobQueue.insert(jobHolder);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
         assertThat("no network job should be returned even if there is no netowrk",
-                jobQueue.nextJobAndIncRunCount(false, null), notNullValue());
+                jobQueue.nextJobAndIncRunCount(constraint), notNullValue());
         jobQueue.remove(jobHolder);
 
         jobHolder = createNewJobHolder(new Params(0).requireNetwork());
         assertThat("if there isn't any network, job with network requirement should not return",
-                jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-
+                jobQueue.nextJobAndIncRunCount(constraint), nullValue());
+        constraint.setShouldNotRequireNetwork(false);
         assertThat("if there is network, job with network requirement should be returned",
-                jobQueue.nextJobAndIncRunCount(true, null), nullValue());
+                jobQueue.nextJobAndIncRunCount(constraint), nullValue());
 
         jobQueue.remove(jobHolder);
 
         jobHolder = createNewJobHolder(new Params(1));
         JobHolder jobHolder2 = createNewJobHolder(new Params(5).requireNetwork());
-        long firstJobId = jobQueue.insert(jobHolder);
-        long secondJobId = jobQueue.insert(jobHolder2);
-        JobHolder retrieved = jobQueue.nextJobAndIncRunCount(false, null);
+        jobQueue.insert(jobHolder);
+        jobQueue.insert(jobHolder2);
+        constraint.setShouldNotRequireNetwork(true);
+        constraint.setExcludeRunning(true);
+        JobHolder retrieved = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("one job should be returned w/o network", retrieved, notNullValue());
         if(retrieved != null) {
-            assertThat("no network job should be returned although it has lower priority", retrieved.getId(), equalTo(firstJobId));
+            assertThat("no network job should be returned although it has lower priority", retrieved.getId(), equalTo(jobHolder.getId()));
         }
 
-        assertThat("no other job should be returned w/o network", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
+        assertThat("no other job should be returned w/o network", jobQueue.nextJobAndIncRunCount(constraint), nullValue());
+        constraint.setShouldNotRequireNetwork(false);
+        retrieved = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("if network is back, network requiring job should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            assertThat("when there is network, network job should be returned", retrieved.getId(), equalTo(secondJobId));
+            assertThat("when there is network, network job should be returned", retrieved.getId(), equalTo(jobHolder2.getId()));
         }
         //add first job back
         jobQueue.insertOrReplace(jobHolder);
         //add second job back
         jobQueue.insertOrReplace(jobHolder2);
 
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
+        retrieved = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("if network is back, job w/ higher priority should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            assertThat("if network is back, job w/ higher priority should be returned", retrieved.getId(), equalTo(secondJobId));
+            assertThat("if network is back, job w/ higher priority should be returned", retrieved.getId(), equalTo(jobHolder2.getId()));
         }
         jobQueue.insertOrReplace(jobHolder2);
 
         JobHolder highestPriorityJob = createNewJobHolder(new Params(10));
-        long highestPriorityJobId = jobQueue.insert(highestPriorityJob);
-        retrieved = jobQueue.nextJobAndIncRunCount(true, null);
+        jobQueue.insert(highestPriorityJob);
+        retrieved = jobQueue.nextJobAndIncRunCount(constraint);
         assertThat("w/ or w/o network, highest priority should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            assertThat("w/ or w/o network, highest priority should be returned", retrieved.getId(), equalTo(highestPriorityJobId));
+            assertThat("w/ or w/o network, highest priority should be returned", retrieved.getId(), equalTo(highestPriorityJob.getId()));
         }
 
         //TODO test delay until
@@ -420,54 +449,75 @@ public void testNetwork() throws Exception {
     @Test
     public void testCountReadyJobs() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        assertThat("initial count should be 0 for ready jobs", jobQueue.countReadyJobs(true, null), equalTo(0));
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        assertThat("initial count should be 0 for ready jobs", jobQueue.countReadyJobs(constraint), equalTo(0));
         //add some jobs
         jobQueue.insert(createNewJobHolder());
         jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork()));
-        long now = System.nanoTime();
+        long now = mockTimer.nanoTime();
         long delay = 1000;
+        constraint.setTimeLimit(now);
+        constraint.setShouldNotRequireNetwork(true);
+        constraint.setExcludeRunning(true);
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0), now + TimeUnit.MILLISECONDS.toNanos(delay)));
-        assertThat("ready count should be 1 if there is no network", jobQueue.countReadyJobs(false, null), equalTo(1));
-        assertThat("ready count should be 2 if there is network", jobQueue.countReadyJobs(true, null), equalTo(2));
-        Thread.sleep(delay);
-        assertThat("when needed delay time passes, ready count should be 3", jobQueue.countReadyJobs(true, null), equalTo(3));
-        assertThat("when needed delay time passes but no network, ready count should be 2", jobQueue.countReadyJobs(false, null), equalTo(2));
+        assertThat("ready count should be 1 if there is no network", jobQueue.countReadyJobs(constraint), equalTo(1));
+        constraint.setShouldNotRequireNetwork(false);
+        assertThat("ready count should be 2 if there is network", jobQueue.countReadyJobs(constraint), equalTo(2));
+        mockTimer.incrementMs(delay + 1);
+        constraint.setTimeLimit(mockTimer.nanoTime());
+        assertThat("when needed delay time passes, ready count should be 3", jobQueue.countReadyJobs(constraint), equalTo(3));
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat("when needed delay time passes but no network, ready count should be 2", jobQueue.countReadyJobs(constraint), equalTo(2));
         jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
         jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
+        constraint.setShouldNotRequireNetwork(false);
         assertThat("when more than 1 job from same group is created, ready jobs should increment only by 1",
-                jobQueue.countReadyJobs(true, null), equalTo(4));
+                jobQueue.countReadyJobs(constraint), equalTo(4));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1"}));
         assertThat("excluding groups should work",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1"})), equalTo(3));
+                jobQueue.countReadyJobs(constraint), equalTo(3));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group3423"}));
         assertThat("giving a non-existing group should not fool the count",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group3423"})), equalTo(4));
+                jobQueue.countReadyJobs(constraint), equalTo(4));
         jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group2")));
+        constraint.clear();
+        constraint.setTimeLimit(mockTimer.nanoTime());
+        constraint.setExcludeRunning(true);
         assertThat("when a job from another group is added, ready job count should inc",
-                jobQueue.countReadyJobs(true, null), equalTo(5));
-        now = System.nanoTime();
+                jobQueue.countReadyJobs(constraint), equalTo(5));
+        now = mockTimer.nanoTime();
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(3).groupBy("group3"), now + TimeUnit.MILLISECONDS.toNanos(delay)));
         assertThat("when a delayed job from another group is added, ready count should not change",
-                jobQueue.countReadyJobs(true, null), equalTo(5));
+                jobQueue.countReadyJobs(constraint), equalTo(5));
         jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group3")));
         assertThat("when another job from delayed group is added, ready job count should inc",
-                jobQueue.countReadyJobs(true, null), equalTo(6));
-        Thread.sleep(delay);
+                jobQueue.countReadyJobs(constraint), equalTo(6));
+        mockTimer.incrementMs(delay);
+        constraint.setTimeLimit(mockTimer.nanoTime());
         assertThat("when delay passes and a job from existing group becomes available, ready job count should not change",
-                jobQueue.countReadyJobs(true, null), equalTo(6));
+                jobQueue.countReadyJobs(constraint), equalTo(6));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1", "group3"}));
         assertThat("when some groups are excluded, count should be correct",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
+                jobQueue.countReadyJobs(constraint), equalTo(4));
 
         //jobs w/ same group id but with different persistence constraints should not fool the count
-        now = System.nanoTime();
+        now = mockTimer.nanoTime();
+        constraint.setTimeLimit(mockTimer.nanoTime());
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now + 1000));
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now + 1000));
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now - 1000));
         jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now - 1000));
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1", "group3"}));
         assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(5));
+                jobQueue.countReadyJobs(constraint), equalTo(5));
+        constraint.clear();
+        constraint.setExcludeRunning(true);
         assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(true, null), equalTo(7));
+                jobQueue.countReadyJobs(constraint), equalTo(7));
+        constraint.setShouldNotRequireNetwork(true);
+        constraint.setExcludeGroups(Arrays.asList(new String[]{"group1", "group3"}));
         assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
-                jobQueue.countReadyJobs(false, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
+                jobQueue.countReadyJobs(constraint), equalTo(4));
     }
 
     @Test
@@ -480,16 +530,17 @@ public void testJobFields() throws Exception {
         int priority = (int) (Math.random() * 1000);
         jobHolder.setPriority(priority);
         DummyJob dummyJob = new DummyJob(new Params(0));
+        dummyJob.seal(mockTimer);
         jobHolder.setJob(dummyJob);
         int runCount = (int) (Math.random() * 10);
         jobHolder.setRunCount(runCount);
 
-        long id = jobQueue.insert(jobHolder);
+        jobQueue.insert(jobHolder);
 
 
         for (int i = 0; i < 2; i++) {
-            JobHolder received = jobQueue.nextJobAndIncRunCount(true, null);
-            assertThat("job id should be preserved", received.getId(), equalTo(id));
+            JobHolder received = jobQueue.nextJobAndIncRunCount(new TestConstraint(mockTimer));
+            assertThat("job id should be preserved", received.getId(), equalTo(jobHolder.getId()));
             assertThat("job priority should be preserved", received.getPriority(), equalTo(priority));
             assertThat("job session id should be assigned", received.getRunningSessionId(), equalTo(sessionId));
             assertThat("job run count should be incremented", received.getRunCount(), equalTo(runCount + i + 1));
@@ -497,7 +548,7 @@ public void testJobFields() throws Exception {
         }
     }
 
-    private void assertJob(JobQueue jobQueue, String msg, long id, /*nullable*/ JobHolder holder) {
+    private void assertJob(JobQueue jobQueue, String msg, String id, /*nullable*/ JobHolder holder) {
         if(holder == null) {
             assertThat(msg, jobQueue.findJobById(id), nullValue());
             return;
@@ -509,14 +560,14 @@ private void assertJob(JobQueue jobQueue, String msg, long id, /*nullable*/ JobH
     @Test
     public void testFindJobHolderById() {
         JobQueue jobQueue = createNewJobQueue();
-        assertJob(jobQueue, "non existing job (negative id)", -4, null);
-        assertJob(jobQueue, "non existing job (positive id)", +4, null);
+        assertJob(jobQueue, "non existing job", UUID.randomUUID().toString(), null);
         final int LIMIT = 100;
         JobHolder[] holders = new JobHolder[LIMIT];
-        long[] ids = new long[LIMIT];
+        String[] ids = new String[LIMIT];
         for(int i =  0; i < LIMIT; i++) {
             holders[i] = createNewJobHolder(new Params((int) (Math.random() * 50)).setPersistent(Math.random() < .5).setRequiresNetwork(Math.random() < .5));
-            ids[i] = jobQueue.insert(holders[i]);
+            ids[i] = holders[i].getId();
+            jobQueue.insert(holders[i]);
             assertJob(jobQueue, "job by id should work for inserted job", ids[i], holders[i]);
         }
         final int REMOVE_CNT = LIMIT / 2;
@@ -564,13 +615,13 @@ public void testTagsWithMultipleHolders() {
         JobHolder holder2 = createNewJobHolder(new Params(0).addTags(tag1, tag3));
         jobQueue.insert(holder1);
         jobQueue.insert(holder2);
-        Set<JobHolder> twoJobs = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1);
-        Set<Long> resultIds = ids(twoJobs);
+        Set<JobHolder> twoJobs = jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag1));
+        Set<String> resultIds = ids(twoJobs);
 
         assertThat("two jobs should be returned", twoJobs.size(), is(2));
         assertThat("should have job id 1", resultIds, hasItems(holder1.getId(), holder2.getId()));
         for (String tag : new String[]{tag2, tag3}) {
-            Set<JobHolder> oneJob = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag);
+            Set<JobHolder> oneJob = jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag));
             resultIds = ids(oneJob);
             assertThat("one job should be returned", oneJob.size(), is(1));
             if (tag.equals(tag2)) {
@@ -583,8 +634,8 @@ public void testTagsWithMultipleHolders() {
         assertTags("after one of the jobs is removed", jobQueue, holder2);
     }
 
-    private Set<Long> ids(Collection<JobHolder> result) {
-        HashSet<Long> ids = new HashSet<Long>();
+    private Set<String> ids(Collection<JobHolder> result) {
+        HashSet<String> ids = new HashSet<>();
         for (JobHolder holder : result) {
             ids.add(holder.getId());
         }
@@ -607,17 +658,17 @@ public void testFindByMultipleTags() {
         assertTags("job with two tags, reinserted", jobQueue, holder);
         jobQueue.remove(holder);
         assertThat("when job is removed, it should return none",
-                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1).size(), is(0));
+                jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag1)).size(), is(0));
         assertThat("when job is removed, it should return none",
-                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag2).size(), is(0));
+                jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag2)).size(), is(0));
     }
 
     @Test
     public void testFindByTags() {
         JobQueue jobQueue = createNewJobQueue();
-        assertThat("empty queue should return 0",jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), "abc").size(), is(0));
+        assertThat("empty queue should return 0",jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), "abc")).size(), is(0));
         jobQueue.insert(createNewJobHolder());
-        Set<JobHolder> result = jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), "blah");
+        Set<JobHolder> result = jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), "blah"));
         assertThat("if job does not have a tag, it should return 0", result.size(), is(0));
 
         final String tag1 = UUID.randomUUID().toString();
@@ -627,21 +678,254 @@ public void testFindByTags() {
         jobQueue.insertOrReplace(holder);
         assertTags("holder with 1 tag reinserted", jobQueue, holder);
         jobQueue.remove(holder);
-        assertThat("when job is removed, it should return none", jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), tag1).size(), is(0));
+        assertThat("when job is removed, it should return none",
+                jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag1)).size(), is(0));
 
         JobHolder holder2 = createNewJobHolder(new Params(0).addTags(tag1));
         jobQueue.insert(holder2);
-        assertThat("it should return the job", jobQueue.findJobsByTags(ANY, false, Collections.<Long>emptyList(), tag1).size(), is(1));
+        assertThat("it should return the job",
+                jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag1)).size(), is(1));
         jobQueue.onJobCancelled(holder2);
         assertThat("when queried w/ exclude cancelled, it should not return the job",
-                jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), tag1).size(), is(0));
+                jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), tag1)).size(), is(0));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirement() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(1000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirement2() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(1000)
+        .delayInMs(2000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirement3() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(2000)
+                .delayInMs(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirement4() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(1000)
+                .delayInMs(2000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(false);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirement5() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(2000)
+                .delayInMs(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(false);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(1000000000L));
+    }
+
+
+    @Test
+    public void testDelayUntilWithNetworkRequirementAndRegularDelayedJob() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(1000));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(500));
+        jobQueue.insert(holder1);
+        jobQueue.insert(holder2);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirementAndRegularDelayedJob2() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(1000));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(500));
+        jobQueue.insert(holder2);
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirementAndRegularDelayedJob3() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(500));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(1000));
+        jobQueue.insert(holder1);
+        jobQueue.insert(holder2);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithNetworkRequirementAndRegularDelayedJob4() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireNetworkWithTimeout(500));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(1000));
+        jobQueue.insert(holder2);
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirement() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(1000000000L));
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(1000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirement2() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(1000)
+                .delayInMs(2000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirement3() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(2000)
+                .delayInMs(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirement4() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(1000)
+                .delayInMs(2000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(false);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(2000000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirement5() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(2000)
+                .delayInMs(1000));
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(false);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(1000000000L));
+    }
 
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirementAndRegularDelayedJob() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(1000));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(500));
+        jobQueue.insert(holder1);
+        jobQueue.insert(holder2);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirementAndRegularDelayedJob2() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(1000));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(500));
+        jobQueue.insert(holder2);
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirementAndRegularDelayedJob3() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(500));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(1000));
+        jobQueue.insert(holder1);
+        jobQueue.insert(holder2);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredNetworkRequirementAndRegularDelayedJob4() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder1 = createNewJobHolder(new Params(2).requireUnmeteredNetworkWithTimeout(500));
+        JobHolder holder2 = createNewJobHolder(new Params(2).delayInMs(1000));
+        jobQueue.insert(holder2);
+        jobQueue.insert(holder1);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredAndNetworkRequirements() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder = createNewJobHolder(
+                new Params(2).requireUnmeteredNetworkWithTimeout(500).requireNetworkWithTimeout(700));
+        jobQueue.insert(holder);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        constraint.setShouldNotRequireNetwork(true);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(700000000L));
+    }
+
+    @Test
+    public void testDelayUntilWithUnmeteredAndNetworkRequirements2() {
+        JobQueue jobQueue = createNewJobQueue();
+        JobHolder holder = createNewJobHolder(
+                new Params(2).requireUnmeteredNetworkWithTimeout(500).requireNetworkWithTimeout(700));
+        jobQueue.insert(holder);
+        TestConstraint constraint = new TestConstraint(mockTimer);
+        constraint.setShouldNotRequireUnmeteredNetwork(true);
+        constraint.setShouldNotRequireNetwork(false);
+        assertThat(jobQueue.getNextJobDelayUntilNs(constraint), is(500000000L));
     }
 
     private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
         Set<JobHolder> result;
         String wrongTag;
-        final long id = holder.getId();
+        final String id = holder.getId();
         boolean found;
         Matcher allTagsMatcher = CoreMatchers.hasItems(holder.getTags().toArray(new String[holder.getTags().size()]));
         do {
@@ -656,7 +940,7 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
                 }
             }
         } while (found);
-        result = jobQueue.findJobsByTags(ANY, true, Collections.<Long>emptyList(), wrongTag);
+        result = jobQueue.findJobs(forTags(mockTimer, ANY, Collections.<String>emptyList(), wrongTag));
         found = false;
         for(JobHolder received : result) {
             if(received.getId().equals(holder.getId())) {
@@ -668,9 +952,9 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
         if(holder.getTags() == null) {
             return;// done
         }
-        Collection<Long> exclude = Arrays.asList(holder.getId());
+        Collection<String> exclude = Arrays.asList(holder.getId());
         for(String[] tags : combinations(holder.getTags())) {
-            result = jobQueue.findJobsByTags(TagConstraint.ANY, true, Collections.<Long>emptyList(), tags);
+            result = jobQueue.findJobs(forTags(mockTimer, TagConstraint.ANY, Collections.<String>emptyList(), tags));
             if (tags.length == 0) {
                 assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
             } else {
@@ -678,14 +962,14 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
                 assertThat(msg + " any combinations: returned job should be the correct one", result.iterator().next().getId(), is(id));
                 assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
             }
-            result = jobQueue.findJobsByTags(TagConstraint.ANY,true,  exclude, tags);
+            result = jobQueue.findJobs(forTags(mockTimer, TagConstraint.ANY, exclude, tags));
             assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(
                     0));
 
         }
 
         for(String[] tags : combinations(holder.getTags())) {
-            result = jobQueue.findJobsByTags(ALL, true, Collections.<Long>emptyList(), tags);
+            result = jobQueue.findJobs(forTags(mockTimer, ALL, Collections.<String>emptyList(), tags));
             if (tags.length == 0) {
                 assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
             } else {
@@ -695,7 +979,7 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
                         result.iterator().next().getId(), is(id));
                 assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
             }
-            result = jobQueue.findJobsByTags(ALL, true, exclude, tags);
+            result = jobQueue.findJobs(forTags(mockTimer, ALL, exclude, tags));
             assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(0));
         }
 
@@ -703,7 +987,7 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
             String[] tagsWithAdditional = new String[tags.length + 1];
             System.arraycopy(tags, 0, tagsWithAdditional, 0, tags.length);
             tagsWithAdditional[tags.length] = wrongTag;
-            result = jobQueue.findJobsByTags(TagConstraint.ANY, true, Collections.<Long>emptyList(), tagsWithAdditional);
+            result = jobQueue.findJobs(forTags(mockTimer, TagConstraint.ANY, Collections.<String>emptyList(), tagsWithAdditional));
             if (tags.length == 0) {
                 assertThat(msg + " empty tag list, should return 0 jobs", result.size(), is(0));
             } else {
@@ -714,10 +998,10 @@ private void assertTags(String msg, JobQueue jobQueue, JobHolder holder) {
                 assertThat(msg + " returned holder should have all tags:", result.iterator().next().getTags(), allTagsMatcher);
             }
 
-            result = jobQueue.findJobsByTags(ALL, true, Collections.<Long>emptyList(), tagsWithAdditional);
+            result = jobQueue.findJobs(forTags(mockTimer, ALL, Collections.<String>emptyList(), tagsWithAdditional));
             assertThat(msg + " all combinations with wrong tag: when an additional wrong tag is given, it should return 0", result.size(), is(0));
 
-            result = jobQueue.findJobsByTags(ALL, true, exclude, tagsWithAdditional);
+            result = jobQueue.findJobs(forTags(mockTimer, ALL, exclude, tagsWithAdditional));
             assertThat(msg + " when excluded, holder should not show up in results", result.size(), is(0));
         }
     }
@@ -759,8 +1043,16 @@ protected JobHolder createNewJobHolder() {
 
     protected JobHolder createNewJobHolder(Params params) {
         long delay = getDelayMsField(params).get();
-        return new JobHolder(null, getPriorityField(params).get(), getGroupIdField(params).get(), 0, new DummyJob(params), System.nanoTime(),
-                delay > 0 ? System.nanoTime() +  delay * JobManager.NS_PER_MS : JobManager.NOT_DELAYED_JOB_DELAY, JobManager.NOT_RUNNING_SESSION_ID);
+        DummyJob job = new DummyJob(params);
+        job.seal(mockTimer);
+        return new JobHolder.Builder()
+                .priority(getPriorityField(params).get())
+                .groupId(getGroupIdField(params).get())
+                .runCount(0)
+                .job(job)
+                .createdNs(mockTimer.nanoTime())
+                .delayUntilNs(delay > 0 ? mockTimer.nanoTime() + delay * JobManager.NS_PER_MS : JobManager.NOT_DELAYED_JOB_DELAY)
+                .runningSessionId(JobManager.NOT_RUNNING_SESSION_ID).build();
     }
 
     private JobHolder createNewJobHolderWithDelayUntil(Params params, long delayUntil) {
@@ -770,10 +1062,10 @@ private JobHolder createNewJobHolderWithDelayUntil(Params params, long delayUnti
     }
 
     protected JobQueue createNewJobQueue() {
-        return createNewJobQueueWithSessionId(System.nanoTime());
+        return createNewJobQueueWithSessionId(123L);
     }
 
     private JobQueue createNewJobQueueWithSessionId(Long sessionId) {
-        return currentFactory.createNew(sessionId, "id_" + sessionId);
+        return currentFactory.createNew(sessionId, "id_" + sessionId, mockTimer);
     }
 }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SimpleInMemoryJobQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SimpleInMemoryJobQueueTest.java
new file mode 100644
index 0000000..f2da20b
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SimpleInMemoryJobQueueTest.java
@@ -0,0 +1,23 @@
+package com.birbit.android.jobqueue.test.jobqueue;
+
+import com.birbit.android.jobqueue.inMemoryQueue.SimpleInMemoryPriorityQueue;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.test.util.JobQueueFactory;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class SimpleInMemoryJobQueueTest extends JobQueueTestBase {
+    public SimpleInMemoryJobQueueTest() {
+        super(new JobQueueFactory() {
+            @Override
+            public JobQueue createNew(long sessionId, String id, Timer timer) {
+                return new SimpleInMemoryPriorityQueue(null, sessionId);
+            }
+        });
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
new file mode 100644
index 0000000..1be2ecc
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
@@ -0,0 +1,151 @@
+package com.birbit.android.jobqueue.test.jobqueue;
+
+import android.database.Cursor;
+import android.support.v4.util.Pair;
+
+import com.birbit.android.jobqueue.JobHolder;
+import com.birbit.android.jobqueue.TestConstraint;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.config.Configuration;
+import com.birbit.android.jobqueue.persistentQueue.sqlite.DbOpenHelper;
+import com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
+import com.birbit.android.jobqueue.test.util.JobQueueFactory;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
+public class SqliteJobQueueTest extends JobQueueTestBase {
+    public SqliteJobQueueTest() {
+        super(new JobQueueFactory() {
+            @Override
+            public JobQueue createNew(long sessionId, String id, Timer timer) {
+                SqliteJobQueue.JavaSerializer serializer = new SqliteJobQueue.JavaSerializer();
+                return new SqliteJobQueue(
+                        new Configuration.Builder(RuntimeEnvironment.application)
+                                .id(id).jobSerializer(serializer).inTestMode()
+                                .timer(timer).build(), sessionId, serializer);
+            }
+        });
+    }
+
+    @Test
+    public void testClearTags() throws Throwable {
+        SqliteJobQueue queue = (SqliteJobQueue) createNewJobQueue();
+        JobHolder vh1 = createNewJobHolder(new Params(1).addTags("a", "b", "c"));
+        JobHolder vh2 = createNewJobHolder(new Params(1).addTags("a", "b", "x"));
+        queue.insert(vh1);
+        queue.insert(vh2);
+        assertTags(queue, new TagInfo(0, vh1.getId(), "a"),
+                new TagInfo(0, vh1.getId(), "b"),
+                new TagInfo(0, vh1.getId(), "c"),
+                new TagInfo(0, vh2.getId(), "a"),
+                new TagInfo(0, vh2.getId(), "b"),
+                new TagInfo(0, vh2.getId(), "x"));
+        queue.remove(vh2);
+        assertTags(queue, new TagInfo(0, vh1.getId(), "a"),
+                new TagInfo(0, vh1.getId(), "b"),
+                new TagInfo(0, vh1.getId(), "c"));
+        queue.clear();
+        assertTags(queue);
+    }
+
+    private void assertTags(SqliteJobQueue queue, TagInfo... expected) {
+        List<TagInfo> tags = loadAllTags(queue);
+        assertThat(tags, hasItems(expected));
+        assertThat(tags.size(), is(expected.length));
+    }
+
+    private List<TagInfo> loadAllTags(SqliteJobQueue queue) {
+        Cursor cursor = queue.getDb().rawQuery("select * from job_holder_tags", new String[0]);
+        List<TagInfo> result = new ArrayList<>();
+        while (cursor.moveToNext()) {
+            result.add(new TagInfo(
+                    cursor.getInt(cursor.getColumnIndex("_id")),
+                    cursor.getString(cursor.getColumnIndex("job_id")),
+                    cursor.getString(cursor.getColumnIndex("tag_name"))
+            ));
+        }
+        return result;
+    }
+
+    @Test
+    public void testCustomSerializer() throws Exception {
+        final CountDownLatch calledForSerialize = new CountDownLatch(1);
+        final CountDownLatch calledForDeserialize = new CountDownLatch(1);
+        SqliteJobQueue.JobSerializer jobSerializer = new SqliteJobQueue.JavaSerializer() {
+            @Override
+            public byte[] serialize(Object object) throws IOException {
+                calledForSerialize.countDown();
+                return super.serialize(object);
+            }
+
+            @Override
+            public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
+                calledForDeserialize.countDown();
+                return super.deserialize(bytes);
+            }
+        };
+
+        SqliteJobQueue jobQueue = new SqliteJobQueue(new Configuration.Builder(RuntimeEnvironment.application)
+                .id("__" + mockTimer.nanoTime()).jobSerializer(jobSerializer).inTestMode()
+                .timer(mockTimer).build(), mockTimer.nanoTime(), jobSerializer);
+        jobQueue.insert(createNewJobHolder(new Params(0)));
+        calledForSerialize.await(1, TimeUnit.SECONDS);
+        MatcherAssert.assertThat("custom serializer should be called for serialize", (int) calledForSerialize.getCount(), CoreMatchers.equalTo(0));
+        MatcherAssert.assertThat("custom serializer should NOT be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(1));
+        jobQueue.nextJobAndIncRunCount(new TestConstraint(mockTimer));
+        MatcherAssert.assertThat("custom serializer should be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(0));
+
+    }
+
+    private static class TagInfo {
+        final int tagId;
+        final String jobId;
+        final String tagNme;
+
+        public TagInfo(int tagId, String jobId, String tagNme) {
+            this.tagId = tagId;
+            this.jobId = jobId;
+            this.tagNme = tagNme;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            TagInfo tagInfo = (TagInfo) o;
+
+            if (!jobId.equals(tagInfo.jobId)) return false;
+            return tagNme.equals(tagInfo.tagNme);
+
+        }
+
+        @Override
+        public int hashCode() {
+            int result = jobId.hashCode();
+            result = 31 * result + tagNme.hashCode();
+            return result;
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobs/DummyJob.java
similarity index 57%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobs/DummyJob.java
index d931e1e..1d7a259 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobs/DummyJob.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/jobs/DummyJob.java
@@ -1,7 +1,12 @@
-package com.path.android.jobqueue.test.jobs;
+package com.birbit.android.jobqueue.test.jobs;
 
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.Params;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.birbit.android.jobqueue.CancelReason;
+import com.birbit.android.jobqueue.Job;
+import com.birbit.android.jobqueue.Params;
+import com.birbit.android.jobqueue.RetryConstraint;
 
 public class DummyJob extends Job {
     int onAddedCnt = 0;
@@ -24,14 +29,14 @@ public void onRun() throws Throwable {
     }
 
     @Override
-    protected void onCancel() {
+    protected void onCancel(@CancelReason int cancelReason, @Nullable Throwable throwable) {
         onCancelCnt++;
     }
 
     @Override
-    protected boolean shouldReRunOnThrowable(Throwable throwable) {
+    protected RetryConstraint shouldReRunOnThrowable(@NonNull Throwable throwable, int runCount, int maxRunCount) {
         shouldReRunOnThrowableCnt++;
-        return false;
+        return RetryConstraint.CANCEL;
     }
 
     public int getOnAddedCnt() {
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/timer/MockTimer.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/timer/MockTimer.java
new file mode 100644
index 0000000..69171e8
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/timer/MockTimer.java
@@ -0,0 +1,110 @@
+package com.birbit.android.jobqueue.test.timer;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.log.JqLog;
+import com.birbit.android.jobqueue.timer.Timer;
+
+import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+public class MockTimer implements Timer {
+    private long now;
+    private CopyOnWriteArrayList<ObjectWait> waitingList = new CopyOnWriteArrayList<>();
+    // MockTimer introduces a potential race condition in waits which may prevent it from stopping
+    // properly. To avoid this, it keeps a track of all objects it should notify and notify them
+    // multiple times when stopped.
+    private Map<Object, Boolean> anyObjectToNotify = new WeakHashMap<>();
+    private volatile boolean stopped = false;
+
+    @Override
+    public synchronized long nanoTime() {
+        return now;
+    }
+
+    public synchronized void incrementMs(long time) {
+        setNow(now + time * JobManager.NS_PER_MS);
+    }
+
+    public synchronized void incrementNs(long time) {
+        setNow(now + time);
+    }
+
+    public synchronized void setNow(long now) {
+        this.now = now;
+        JqLog.d("set time to %s", now);
+        notifyObjectWaits(now);
+    }
+
+    private synchronized void notifyObjectWaits(long now) {
+        JqLog.d("notify object waits by time %s", now);
+        for (ObjectWait objectWait : waitingList) {
+            JqLog.d("checking %s : %s for time %s",objectWait, objectWait.target,
+                    objectWait.timeUntil);
+            if (objectWait.timeUntil <= now) {
+                final ObjectWait toWait = objectWait;
+                waitingList.remove(objectWait);
+                new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        synchronized (toWait.target) {
+                            JqLog.d("notifying %s", toWait);
+                            toWait.target.notifyAll();
+                        }
+                    }
+                }).start();
+            }
+        }
+        JqLog.d("done notifying by time");
+    }
+
+    @Override
+    public void waitOnObjectUntilNs(Object object, long untilNs) throws InterruptedException {
+        synchronized (this) {
+            // all waits are w/o a timeout because time is controlled by the mock timer
+            JqLog.d("wait on object request for %s timeout %s stopped: %s", object, untilNs,
+                    stopped);
+            if (stopped) {
+                return;
+            }
+            if(untilNs < now) {
+                return;
+            }
+            anyObjectToNotify.put(object, true);
+            ObjectWait objectWait = new ObjectWait(object, untilNs);
+            waitingList.add(objectWait);
+            JqLog.d("will wait on object %s: %s for time %s forever:%s", objectWait,
+                    objectWait.target,
+                    objectWait.timeUntil, objectWait.timeUntil == ObjectWait.FOREVER);
+        }
+        object.wait();
+    }
+
+    @Override
+    public void notifyObject(Object object) {
+        JqLog.d("notify request for %s", object);
+        for (ObjectWait objectWait : waitingList) {
+            if (objectWait.target == object) {
+                JqLog.d("notifying object %s", objectWait);
+                waitingList.remove(objectWait);
+                object.notifyAll();
+            }
+        }
+        JqLog.d("done notifying objects");
+    }
+
+    @Override
+    public void waitOnObject(Object object) throws InterruptedException {
+        waitOnObjectUntilNs(object, ObjectWait.FOREVER);
+    }
+
+    static class ObjectWait {
+        static final long FOREVER = Long.MAX_VALUE;
+        final long timeUntil;
+        final Object target;
+        public ObjectWait(Object target, long time) {
+            timeUntil = time;
+            this.target = target;
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/JobQueueFactory.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/JobQueueFactory.java
new file mode 100644
index 0000000..960d707
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/JobQueueFactory.java
@@ -0,0 +1,8 @@
+package com.birbit.android.jobqueue.test.util;
+
+import com.birbit.android.jobqueue.JobQueue;
+import com.birbit.android.jobqueue.timer.Timer;
+
+public interface JobQueueFactory {
+    public JobQueue createNew(long sessionId, String id, Timer timer);
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/RunningJobSetTest.java
similarity index 68%
rename from jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java
rename to jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/RunningJobSetTest.java
index 67f025c..93d7b34 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/RunningJobSetTest.java
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/test/util/RunningJobSetTest.java
@@ -1,6 +1,9 @@
-package com.path.android.jobqueue.test.util;
+package com.birbit.android.jobqueue.test.util;
 
-import com.path.android.jobqueue.RunningJobSet;
+import com.birbit.android.jobqueue.RunningJobSet;
+import com.birbit.android.jobqueue.test.timer.MockTimer;
+import com.birbit.android.jobqueue.timer.SystemTimer;
+import com.birbit.android.jobqueue.timer.Timer;
 
 import static org.hamcrest.MatcherAssert.*;
 import static org.hamcrest.CoreMatchers.*;
@@ -16,12 +19,12 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 @RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+@Config(constants = com.birbit.android.jobqueue.BuildConfig.class)
 public class RunningJobSetTest {
     RunningJobSet set;
     @Before
     public void setUp() {
-        set = new RunningJobSet();
+        set = new RunningJobSet(new SystemTimer());
     }
 
     @Test
@@ -68,57 +71,42 @@ private void assertList(String... items) {
 
     @Test
     public void testAddWithTimeout() {
-        final AtomicLong time = new AtomicLong();
-        set = new RunningJobSet() {
-            @Override
-            protected long now() {
-                return time.get();
-            }
-        };
+        MockTimer timer = new MockTimer();
+        set = new RunningJobSet(timer);
         set.addGroupUntil("g1", 10L);
-        time.set(5);
+        timer.setNow(5);
         assertList("g1");
-        time.set(11);
+        timer.setNow(11);
         assertList();
-        time.set(3);
+        timer.setNow(3);
         assertList(); // should've pruned the list
     }
 
     @Test
     public void testAddSameGroupTwiceWithTimeout() {
-        final AtomicLong time = new AtomicLong();
-        set = new RunningJobSet() {
-            @Override
-            protected long now() {
-                return time.get();
-            }
-        };
+        MockTimer timer = new MockTimer();
+        set = new RunningJobSet(timer);
         set.addGroupUntil("g1", 10L);
         set.addGroupUntil("g1", 12L);
-        time.set(5);
+        timer.setNow(5);
         assertList("g1");
-        time.set(11);
+        timer.setNow(11);
         assertList("g1");
-        time.set(13);
+        timer.setNow(13);
         assertList();
     }
 
     @Test
     public void testAddMultipleGroupTimeouts() {
-        final AtomicLong time = new AtomicLong();
-        set = new RunningJobSet() {
-            @Override
-            protected long now() {
-                return time.get();
-            }
-        };
+        MockTimer timer = new MockTimer();
+        set = new RunningJobSet(timer);
         set.addGroupUntil("g1", 10L);
         set.addGroupUntil("g2", 20L);
-        time.set(5);
+        timer.setNow(5);
         assertList("g1", "g2");
-        time.set(11);
+        timer.setNow(11);
         assertList("g2");
-        time.set(21);
+        timer.setNow(21);
         assertList();
     }
 }
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/CleanupRule.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/CleanupRule.java
new file mode 100644
index 0000000..b92f292
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/CleanupRule.java
@@ -0,0 +1,35 @@
+package com.birbit.android.jobqueue.testing;
+
+import com.birbit.android.jobqueue.JobManager;
+import com.birbit.android.jobqueue.test.jobmanager.JobManagerTestBase;
+
+import org.junit.runner.Description;
+
+public class CleanupRule extends ThreadDumpRule {
+    final JobManagerTestBase test;
+
+    public CleanupRule(JobManagerTestBase test) {
+        this.test = test;
+    }
+
+    @Override
+    protected void starting(Description description) {
+        super.starting(description);
+        System.out.println("started test " + getId(description));
+    }
+
+    @Override
+    protected void finished(Description description) {
+        String id = getId(description);
+        System.out.println("tear down " + id);
+        for (JobManager jobManager : test.getCreatedJobManagers()) {
+            JobManagerTestBase.NeverEndingDummyJob.unlockAll();
+            jobManager.destroy();
+        }
+        System.out.println("finished tear down of " + id);
+    }
+
+    private String getId(Description description) {
+        return description.getMethodName() + "/" + description.getClassName();
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/StackTraceRule.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/StackTraceRule.java
new file mode 100644
index 0000000..14ddbe6
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/StackTraceRule.java
@@ -0,0 +1,19 @@
+package com.birbit.android.jobqueue.testing;
+
+import org.junit.Rule;
+import org.junit.rules.TestRule;
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.lang.annotation.Annotation;
+import java.util.Map;
+
+public class StackTraceRule extends TestWatcher {
+
+    @Override
+    protected void failed(Throwable e, Description description) {
+        System.out.println("stack trace detected failed test");
+        super.failed(e, description);
+    }
+}
diff --git a/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/ThreadDumpRule.java b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/ThreadDumpRule.java
new file mode 100644
index 0000000..77e3b77
--- /dev/null
+++ b/jobqueue/src/test/java/com/birbit/android/jobqueue/testing/ThreadDumpRule.java
@@ -0,0 +1,29 @@
+package com.birbit.android.jobqueue.testing;
+
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+
+import java.util.Map;
+
+/**
+ * Throws a new assertion with thread dump
+ */
+public class ThreadDumpRule extends TestWatcher {
+    @Override
+    public void failed(Throwable e, Description description) {
+        Map<Thread, StackTraceElement[]> stackTraces = Thread.getAllStackTraces();
+        // add stack traces to the errors
+        StringBuilder sb = new StringBuilder("Thread dump:");
+        for (Map.Entry<Thread, StackTraceElement[]> entry : stackTraces.entrySet()) {
+            sb.append(entry.getKey().getName()).append("\n");
+            for (StackTraceElement element : entry.getValue()) {
+                sb.append("  ").append(element.getClassName())
+                        .append("#").append(element.getMethodName())
+                        .append("#").append(element.getLineNumber())
+                        .append("\n");
+            }
+            sb.append("\n----------\n");
+        }
+        throw new AssertionError(sb.toString());
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
deleted file mode 100644
index e358846..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/TestBase.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.path.android.jobqueue.test;
-
-import android.util.Log;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.log.JqLog;
-import org.junit.Before;
-import org.robolectric.shadows.ShadowLog;
-
-public class TestBase {
-    protected static boolean ENABLE_DEBUG = false;
-    @Before
-    public void setUp() throws Exception {
-        if(ENABLE_DEBUG) {
-            enableDebug();
-        }
-    }
-
-    protected void enableDebug() {
-        ShadowLog.stream = System.out;
-        JqLog.setCustomLogger(new CustomLogger() {
-            private String TAG = "test_logger";
-
-            @Override
-            public boolean isDebugEnabled() {
-                return true;
-            }
-
-            @Override
-            public void d(String text, Object... args) {
-                Log.d(TAG, String.format(text, args));
-            }
-
-            @Override
-            public void e(Throwable t, String text, Object... args) {
-                Log.e(TAG, String.format(text, args), t);
-            }
-
-            @Override
-            public void e(String text, Object... args) {
-                Log.e(TAG, String.format(text, args));
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
deleted file mode 100644
index 59f9ed2..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.AsyncAddCallback;
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.hamcrest.*;
-import org.junit.After;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicLong;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class AddInBackgroundTest extends JobManagerTestBase {
-    @Test
-    public void testAddInBackground() throws InterruptedException {
-        for(boolean delay : new boolean[]{true, false}) {
-            for(boolean useCallback : new boolean[]{true, false}) {
-                addInBackground(delay, useCallback);
-            }
-        }
-    }
-
-    public void addInBackground(boolean delayed, boolean useCallback) throws InterruptedException {
-        long currentThreadId = Thread.currentThread().getId();
-        final AtomicLong onAddedThreadId = new AtomicLong();
-        final CountDownLatch addedLatch = new CountDownLatch(2);
-
-        Job dummyJob = new DummyJob(new Params(1).setDelayMs(delayed ? 1000 : 0)) {
-            @Override
-            public void onAdded() {
-                super.onAdded();
-                onAddedThreadId.set(Thread.currentThread().getId());
-                addedLatch.countDown();
-            }
-        };
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        final AtomicLong jobId = new AtomicLong(0);
-        if(useCallback) {
-            jobManager.addJobInBackground(dummyJob, new AsyncAddCallback() {
-                @Override
-                public void onAdded(long id) {
-                    jobId.set(id);
-                    addedLatch.countDown();
-                }
-            });
-        } else {
-            addedLatch.countDown();
-            jobManager.addJobInBackground(dummyJob);
-        }
-        addedLatch.await();
-        MatcherAssert.assertThat("thread ids should be different. delayed:" + delayed, currentThreadId, CoreMatchers.not(onAddedThreadId.get()));
-        if(useCallback) {
-            JobQueue queue = getNonPersistentQueue(jobManager);
-            JobHolder holder = queue.findJobById(jobId.longValue());
-            MatcherAssert.assertThat("there should be a job in the holder. id:" + jobId.longValue() +", delayed:" + delayed + ", use cb:" + useCallback
-                    , holder, CoreMatchers.notNullValue());
-            MatcherAssert.assertThat("id callback should have the proper id:", holder.getJob(), CoreMatchers.is((Job)dummyJob));
-        }
-    }
-
-    protected JobQueue getNonPersistentQueue(JobManager jobManager) {
-        return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java
deleted file mode 100644
index a85fa16..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ApplicationContextTests.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.Matcher;
-import org.hamcrest.MatcherAssert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricGradleTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import android.content.Context;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class ApplicationContextTests extends JobManagerTestBase {
-    static int retryCount = 0;
-    static CountDownLatch doneLatch;
-    @Before
-    public void clear() {
-        retryCount = 0;
-        doneLatch = new CountDownLatch(1);
-    }
-
-    @Test
-    public void getContextNonPersistent() throws InterruptedException {
-        getContextTest(false);
-    }
-
-    @Test
-    public void getContextPersistent() throws InterruptedException {
-        getContextTest(true);
-    }
-
-    public void getContextTest(boolean persistent) throws InterruptedException {
-        ContextCheckJob job = new ContextCheckJob(new Params(1).setPersistent(persistent));
-        JobManager jobManager = createJobManager();
-        jobManager.addJob(job);
-        doneLatch.await(2, TimeUnit.SECONDS);
-    }
-
-    public static class ContextCheckJob extends Job {
-        protected ContextCheckJob(Params params) {
-            super(params);
-        }
-
-        private void assertContext(String method) {
-            Context applicationContext = getApplicationContext();
-            assertThat("Context should be application context in " + method,
-                    applicationContext, sameInstance((Context)RuntimeEnvironment.application));
-        }
-
-        @Override
-        public void onAdded() {
-            assertContext("onAdded");
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            assertContext("onRun");
-            if (retryCount < 2) {
-                retryCount ++;
-                throw new RuntimeException("failure on purpose");
-            }
-        }
-
-        @Override
-        protected void onCancel() {
-            assertContext("onCancel");
-            doneLatch.countDown();
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            assertContext("shouldReRunOnThrowable");
-            return retryCount < 2;
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
deleted file mode 100644
index a804a42..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
+++ /dev/null
@@ -1,178 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.RetryConstraint;
-import com.path.android.jobqueue.TagConstraint;
-import com.path.android.jobqueue.callback.JobManagerCallback;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-
-import org.hamcrest.CoreMatchers;
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import static org.mockito.Mockito.*;
-
-import org.mockito.ArgumentCaptor;
-import org.robolectric.RobolectricGradleTestRunner;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class CallbackTest extends JobManagerTestBase {
-    @Test
-    public void successNonPersistent() throws Throwable {
-        JobManagerCallback callback = mock(JobManagerCallback.class);
-        Job job = mock(Job.class);
-        doNothing().when(job).onAdded();
-        doNothing().when(job).onRun();
-        JobManager jobManager = createJobManager();
-        jobManager.addCallback(callback);
-        jobManager.addJob(job);
-        busyDrain(jobManager, 2);
-        verify(job).onAdded();
-        verify(job).onRun();
-        verify(callback).onJobAdded(job);
-        verify(callback).onJobRun(job, JobManagerCallback.RESULT_SUCCEED);
-    }
-
-    @Test
-    public void cancelViaRetryLimit() throws Throwable {
-        JobManagerCallback callback = mock(JobManagerCallback.class);
-        PublicJob job = mock(PublicJob.class);
-        doNothing().when(job).onAdded();
-        doThrow(new Exception()).when(job).onRun();
-        doReturn(3).when(job).getRetryLimit();
-        doReturn(RetryConstraint.RETRY).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
-        JobManager jobManager = createJobManager();
-        jobManager.addCallback(callback);
-        jobManager.addJob(job);
-        busyDrain(jobManager, 2);
-        verify(callback).onJobAdded(job);
-        verify(callback, times(2)).onJobRun(job, JobManagerCallback.RESULT_FAIL_WILL_RETRY);
-        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_REACHED_RETRY_LIMIT);
-        verify(callback).onJobCancelled(job, false);
-    }
-
-    @Test
-    public void cancelViaShouldReRun() throws Throwable {
-        JobManagerCallback callback = mock(JobManagerCallback.class);
-        PublicJob job = mock(PublicJob.class);
-        doNothing().when(job).onAdded();
-        doThrow(new Exception()).when(job).onRun();
-        doReturn(3).when(job).getRetryLimit();
-        doReturn(RetryConstraint.CANCEL).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
-        JobManager jobManager = createJobManager();
-        jobManager.addCallback(callback);
-        jobManager.addJob(job);
-        busyDrain(jobManager, 2);
-        verify(callback).onJobAdded(job);
-        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN);
-        verify(callback).onJobCancelled(job, false);
-    }
-
-    @Test
-    public void cancelViaCancelCall() throws Throwable {
-        JobManagerCallback callback = mock(JobManagerCallback.class);
-        final CountDownLatch startLatch = new CountDownLatch(1);
-        final CountDownLatch endLatch = new CountDownLatch(1);
-        PublicJob job = spy(new PublicJob(new Params(1).addTags("tag1")) {
-            @Override
-            public void onRun() throws Throwable {
-                startLatch.countDown();
-                Assert.assertThat(endLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
-                throw new Exception("blah");
-            }
-        });
-        doCallRealMethod().when(job).onRun();
-        doReturn(3).when(job).getRetryLimit();
-        verify(job, times(0)).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
-        JobManager jobManager = createJobManager();
-        jobManager.addCallback(callback);
-        jobManager.addJob(job);
-        Assert.assertThat(startLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
-        jobManager.cancelJobsInBackground(null, TagConstraint.ANY, "tag1");
-        Thread.sleep(500); // to ensure cancel request has reached
-        endLatch.countDown();
-        busyDrain(jobManager, 2);
-        Thread.sleep(500); // wait until cancel finishes
-        verify(callback).onJobAdded(job);
-        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_WHILE_RUNNING);
-        verify(callback).onJobCancelled(job, true);
-    }
-
-    @Test
-    public void successPersistent() throws Throwable {
-        JobManagerCallback callback = mock(JobManagerCallback.class);
-        Job job = new PersistentDummyJob();
-        JobManager jobManager = createJobManager();
-        jobManager.addCallback(callback);
-        jobManager.addJob(job);
-        busyDrain(jobManager, 2);
-        verify(callback).onJobAdded(any(PersistentDummyJob.class));
-        verify(callback).onJobRun(any(PersistentDummyJob.class), eq(JobManagerCallback.RESULT_SUCCEED));
-    }
-
-    public static class PersistentDummyJob extends Job {
-        public PersistentDummyJob() {
-            super(new Params(1).persist());
-        }
-
-        @Override
-        public void onAdded() {
-
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-
-        }
-
-        @Override
-        protected void onCancel() {
-
-        }
-    }
-
-    public static class PublicJob extends Job {
-
-        protected PublicJob(Params params) {
-            super(params);
-        }
-
-        @Override
-        public RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
-            return super.shouldReRunOnThrowable(throwable, runCount, maxRunCount);
-        }
-
-        @Override
-        public int getCurrentRunCount() {
-            return super.getCurrentRunCount();
-        }
-
-        @Override
-        public int getRetryLimit() {
-            return super.getRetryLimit();
-        }
-
-        @Override
-        public void onAdded() {
-
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-
-        }
-
-        @Override
-        protected void onCancel() {
-
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
deleted file mode 100644
index ecc2606..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class ConsumerCountTest extends JobManagerTestBase {
-    @Test
-    public void testMaxConsumerCount() throws Exception {
-        int maxConsumerCount = 2;
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .maxConsumerCount(maxConsumerCount)
-                .loadFactor(maxConsumerCount));
-        Object runLock = new Object();
-        Semaphore semaphore = new Semaphore(maxConsumerCount);
-        int totalJobCount = maxConsumerCount * 3;
-        List<NeverEndingDummyJob> runningJobs = new ArrayList<NeverEndingDummyJob>(totalJobCount);
-        for(int i = 0; i < totalJobCount; i ++) {
-            NeverEndingDummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
-            runningJobs.add(job);
-            jobManager.addJob(job);
-        }
-        //wait till enough jobs start
-        long now = System.nanoTime();
-        long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            if(semaphore.availablePermits() == 0) {
-                //enough # of jobs started
-                break;
-            }
-        }
-        //wait some more to ensure no more jobs are started
-        Thread.sleep(TimeUnit.SECONDS.toMillis(3));
-        int totalRunningCount = 0;
-        for(DummyJob job : runningJobs) {
-            totalRunningCount += job.getOnRunCnt();
-        }
-        MatcherAssert.assertThat("only maxConsumerCount jobs should start", totalRunningCount, equalTo(maxConsumerCount));
-        //try to finish all jobs
-        //wait till enough jobs start
-        now = System.nanoTime();
-        waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            synchronized (runLock) {
-                runLock.notifyAll();
-            }
-            totalRunningCount = 0;
-            for(DummyJob job : runningJobs) {
-                totalRunningCount += job.getOnRunCnt();
-            }
-            if(totalJobCount == totalRunningCount) {
-                //cool!
-                break;
-            }
-        }
-        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
deleted file mode 100644
index 9579181..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CountTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class CountTest extends JobManagerTestBase {
-    @Test
-    public void testCount() throws Exception {
-        JobManager jobManager = createJobManager();
-        jobManager.stop();
-        for (int i = 0; i < 10; i++) {
-            jobManager.addJob(new DummyJob(new Params(0).persist()));
-            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 1));
-            jobManager.addJob(new DummyJob(new Params(0).persist()));
-            MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 2));
-        }
-        jobManager.start();
-        Thread.sleep(2000);
-        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
deleted file mode 100644
index f13de6d..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.hamcrest.*;
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class DelayedRunTest extends JobManagerTestBase {
-    @Test
-    public void testDelayedRun() throws Exception {
-        testDelayedRun(false, false);
-        testDelayedRun(true, false);
-        testDelayedRun(false, true);
-        testDelayedRun(true, true);
-    }
-
-    @Test
-    public void testDelayWith0Consumers() throws InterruptedException {
-        JobManager jobManager = createJobManager(
-                new Configuration.Builder(RuntimeEnvironment.application)
-                        .minConsumerCount(0)
-                        .maxConsumerCount(3));
-        final CountDownLatch latch = new CountDownLatch(1);
-        DummyJob dummyJob = new DummyJob(new Params(0).delayInMs(2000)) {
-            @Override
-            public void onRun() throws Throwable {
-                super.onRun();
-                latch.countDown();
-            }
-        };
-        jobManager.addJob(dummyJob);
-        assertThat("job should run in 3 seconds", latch.await(3, TimeUnit.DAYS),
-                is(true));
-    }
-
-    public void testDelayedRun(boolean persist, boolean tryToStop) throws Exception {
-        JobManager jobManager = createJobManager();
-        DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(2000).setPersistent(persist));
-        DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
-        jobManager.addJob(delayedJob);
-        jobManager.addJob(nonDelayedJob);
-        Thread.sleep(500);
-        MatcherAssert.assertThat("there should be 1 delayed job waiting to be run", jobManager.count(), equalTo(1));
-        if(tryToStop) {//see issue #11
-            jobManager.stop();
-            Thread.sleep(3000);
-            MatcherAssert.assertThat("there should still be 1 delayed job waiting to be run when job manager is stopped",
-                    jobManager.count(), equalTo(1));
-            jobManager.start();
-        }
-        Thread.sleep(3000);
-        MatcherAssert.assertThat("all jobs should be completed", jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
deleted file mode 100644
index d14868a..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.di.DependencyInjector;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class InjectorTest extends JobManagerTestBase {
-    @Test
-    public void testInjector() throws Exception {
-        Configuration.Builder builder = new Configuration.Builder(RuntimeEnvironment.application);
-        final JobManagerTestBase.ObjectReference injectedJobReference = new JobManagerTestBase.ObjectReference();
-        final AtomicInteger injectionCallCount = new AtomicInteger(0);
-        DependencyInjector dependencyInjector = new DependencyInjector() {
-            @Override
-            public void inject(Job job) {
-                injectedJobReference.setObject(job);
-                injectionCallCount.incrementAndGet();
-            }
-        };
-        builder.injector(dependencyInjector);
-        JobManager jobManager = createJobManager(builder);
-        jobManager.stop();
-        jobManager.addJob(new DummyJob(new Params(4)));
-        MatcherAssert.assertThat("injection should be called after adding a non-persistent job", injectionCallCount.get(), equalTo(1));
-        jobManager.addJob(new DummyJob(new Params(1).persist()));
-        MatcherAssert.assertThat("injection should be called after adding a persistent job", injectionCallCount.get(), equalTo(2));
-        JobHolder holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getJob(), not(injectedJobReference.getObject()));
-        MatcherAssert.assertThat("injection should be called once for non persistent job", injectionCallCount.get(), equalTo(2));
-        holder = getNextJobMethod(jobManager).invoke();
-        MatcherAssert.assertThat("injection should be called for persistent job", holder.getJob(), equalTo(injectedJobReference.getObject()));
-        MatcherAssert.assertThat("injection should be called two times for persistent job", injectionCallCount.get(), equalTo(3));
-    }
-
-    @Test
-    public void testInjectorCrash() throws Exception {
-        final String EXCEPTION_MESSAGE = "could not inject for whatever reason :)";
-        DependencyInjector dummyDependencyInjector = new DependencyInjector() {
-            @Override
-            public void inject(Job job) {
-                throw new RuntimeException(EXCEPTION_MESSAGE);
-            }
-        };
-
-        final ObjectReference objectReference = new ObjectReference();
-        final CountDownLatch exceptionLatch = new CountDownLatch(1);
-        CustomLogger customLogger = new CustomLogger() {
-            @Override
-            public boolean isDebugEnabled() {
-                return false;
-            }
-
-            @Override
-            public void d(String s, Object... objects) {
-
-            }
-
-            @Override
-            public void e(Throwable throwable, String s, Object... objects) {
-                objectReference.setObject(throwable);
-                exceptionLatch.countDown();
-            }
-
-            @Override
-            public void e(String s, Object... objects) {
-                //
-            }
-        };
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).injector(dummyDependencyInjector).customLogger(customLogger));
-        Throwable addException = null;
-        try {
-            jobManager.addJob(new DummyJob(new Params(0)));
-        } catch (Throwable t) {
-            addException = t;
-        }
-        MatcherAssert.assertThat("addJob should throw exception if dependency injector throws exception", addException, notNullValue());
-        jobManager.addJobInBackground(new DummyJob(new Params(0)));
-        exceptionLatch.await(2, TimeUnit.SECONDS);
-        MatcherAssert.assertThat("there should be a received exception", objectReference.getObject(), notNullValue());
-        MatcherAssert.assertThat("logged exception should be a runtime exception", objectReference.getObject(), instanceOf(RuntimeException.class));
-        MatcherAssert.assertThat("logged exception should have expected message", ((Throwable)objectReference.getObject()).getMessage(), is(EXCEPTION_MESSAGE));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
deleted file mode 100644
index 0f41871..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ /dev/null
@@ -1,227 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import android.content.Context;
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.executor.JobConsumerExecutor;
-import com.path.android.jobqueue.network.NetworkEventProvider;
-import com.path.android.jobqueue.network.NetworkUtil;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.core.*;
-import org.fest.reflect.method.*;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.After;
-import org.junit.Assert;
-import org.robolectric.*;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.atomic.AtomicInteger;
-
-
-public class JobManagerTestBase extends TestBase {
-    List<JobManager> createdJobManagers = new ArrayList<JobManager>();
-    protected JobManager createJobManager() {
-        final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
-                UUID.randomUUID().toString());
-        createdJobManagers.add(jobManager);
-        return jobManager;
-    }
-
-    public void busyDrain(JobManager jobManager, int limitInSeconds) throws InterruptedException {
-        int totalSleep = 0;
-        while (jobManager.count() > 0 && limitInSeconds * 1000 > totalSleep) {
-            Thread.sleep(100);
-            totalSleep += 100;
-        }
-        jobManager.stopAndWaitUntilConsumersAreFinished();
-        Assert.assertThat(limitInSeconds * 1000 > totalSleep, is(true));
-    }
-
-    protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
-        final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
-                configurationBuilder.id(UUID.randomUUID().toString()).build());
-        createdJobManagers.add(jobManager);
-        return jobManager;
-    }
-
-    @After
-    public void tearDown() throws InterruptedException {
-        for (JobManager jobManager : createdJobManagers) {
-            NeverEndingDummyJob.unlockAll();
-            jobManager.stopAndWaitUntilConsumersAreFinished();
-            jobManager.clear();
-        }
-    }
-
-    protected static class DummyTwoLatchJob extends DummyJob {
-        private final CountDownLatch waitFor;
-        private final CountDownLatch trigger;
-        private final CountDownLatch onRunLatch;
-
-        protected DummyTwoLatchJob(Params params, CountDownLatch waitFor, CountDownLatch trigger) {
-            super(params);
-            this.waitFor = waitFor;
-            this.trigger = trigger;
-            onRunLatch = new CountDownLatch(1);
-        }
-
-        public void waitTillOnRun() throws InterruptedException {
-            onRunLatch.await();
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            onRunLatch.countDown();
-            waitFor.await();
-            super.onRun();
-            trigger.countDown();
-        }
-    }
-
-    protected static class DummyLatchJob extends DummyJob {
-        private final CountDownLatch latch;
-
-        protected DummyLatchJob(Params params, CountDownLatch latch) {
-            super(params);
-            this.latch = latch;
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            super.onRun();
-            latch.countDown();
-        }
-    }
-
-
-    protected static class DummyJobWithRunCount extends DummyJob {
-        public static int runCount;
-        protected DummyJobWithRunCount(boolean persistent) {
-            super(new Params(0).setPersistent(persistent));
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            runCount++;
-            super.onRun();
-            throw new RuntimeException("i am dummy, i throw exception when running " + runCount);
-        }
-
-        @Override
-        protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            return true;
-        }
-
-        @Override
-        protected int getRetryLimit() {
-            return 5;
-        }
-    }
-
-    protected static class DummyNetworkUtil implements NetworkUtil {
-        private boolean hasNetwork;
-
-        protected void setHasNetwork(boolean hasNetwork) {
-            this.hasNetwork = hasNetwork;
-        }
-
-        @Override
-        public boolean isConnected(Context context) {
-            return hasNetwork;
-        }
-    }
-
-    protected static class DummyNetworkUtilWithConnectivityEventSupport implements NetworkUtil, NetworkEventProvider {
-        private boolean hasNetwork;
-        private Listener listener;
-
-        protected void setHasNetwork(boolean hasNetwork, boolean notifyListener) {
-            this.hasNetwork = hasNetwork;
-            if(notifyListener && listener != null) {
-                listener.onNetworkChange(hasNetwork);
-            }
-        }
-
-        @Override
-        public boolean isConnected(Context context) {
-            return hasNetwork;
-        }
-
-        @Override
-        public void setListener(Listener listener) {
-            this.listener = listener;
-        }
-
-        public boolean isConnected() {
-            return hasNetwork;
-        }
-    }
-
-    protected static class ObjectReference {
-        Object object;
-
-        Object getObject() {
-            return object;
-        }
-
-        void setObject(Object object) {
-            this.object = object;
-        }
-    }
-
-    protected Invoker<JobHolder> getNextJobMethod(JobManager jobManager) {
-        return Reflection.method("getNextJob").withReturnType(JobHolder.class).in(jobManager);
-    }
-
-    protected Invoker<Void> getRemoveJobMethod(JobManager jobManager) {
-        return Reflection.method("removeJob").withParameterTypes(JobHolder.class).in(jobManager);
-    }
-
-    protected JobConsumerExecutor getConsumerExecutor(JobManager jobManager) {
-        return Reflection.field("jobConsumerExecutor").ofType(JobConsumerExecutor.class).in(jobManager).get();
-    }
-
-    protected org.fest.reflect.field.Invoker<AtomicInteger> getActiveConsumerCount(JobConsumerExecutor jobConsumerExecutor) {
-        return Reflection.field("activeConsumerCount").ofType(AtomicInteger.class).in(jobConsumerExecutor);
-    }
-
-    public static class NeverEndingDummyJob extends DummyJob {
-        // used for cleanup
-        static List<NeverEndingDummyJob> createdJobs = new ArrayList<NeverEndingDummyJob>();
-        final Object lock;
-        final Semaphore semaphore;
-        public NeverEndingDummyJob(Params params, Object lock, Semaphore semaphore) {
-            super(params);
-            this.lock = lock;
-            this.semaphore = semaphore;
-            createdJobs.add(this);
-        }
-
-        @Override
-        public void onRun() throws Throwable {
-            super.onRun();
-            MatcherAssert.assertThat("job should be able to acquire a semaphore",
-                    semaphore.tryAcquire(), equalTo(true));
-            synchronized (lock) {
-                lock.wait();
-            }
-            semaphore.release();
-        }
-
-        static void unlockAll() {
-            for (NeverEndingDummyJob job : createdJobs) {
-                synchronized (job.lock) {
-                    job.lock.notifyAll();
-                }
-            }
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
deleted file mode 100644
index 95ba3a0..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobStatus;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class JobStatusTest extends JobManagerTestBase {
-    @Test
-    public void testJobStatus() throws InterruptedException {
-        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        networkUtil.setHasNetwork(false, true);
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(networkUtil));
-        jobManager.stop();
-        List<Integer> networkRequiringJobIndices = new ArrayList<Integer>();
-        Job[] jobs = new Job[] {
-                new DummyJob(new Params(0)),
-                new DummyJob(new Params(0).persist()),
-                new DummyJob(new Params(0).persist().requireNetwork())
-        };
-        long[] ids = new long[jobs.length];
-        for(int i = 0; i < jobs.length; i ++) {
-            ids[i] = jobManager.addJob(jobs[i]);
-            if(jobs[i].requiresNetwork()) {
-                networkRequiringJobIndices.add(i);
-            }
-            JobStatus expectedStatus = (networkUtil.isConnected() || jobs[i].requiresNetwork() == false) ? JobStatus.WAITING_READY :
-                    JobStatus.WAITING_NOT_READY;
-            assertThat("job should have correct status after being added",
-                    jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(expectedStatus));
-        }
-
-        //create an unknown id, ensure status for that
-
-        boolean exists;
-        long unknownId;
-        do {
-            unknownId = (long) (Math.random() * 10000 - 5000);
-            exists = false;
-            for(long id : ids) {
-                if(id == unknownId) {
-                    exists = true;
-                    continue;
-                }
-            }
-        } while (exists);
-        for(boolean persistent : new boolean[]{true, false}) {
-            assertThat("job with unknown id should return as expected", jobManager.getJobStatus(unknownId, persistent), is(JobStatus.UNKNOWN));
-        }
-
-        CountDownLatch startLatch = new CountDownLatch(1), endLatch = new CountDownLatch(1);
-        DummyTwoLatchJob twoLatchJob = new DummyTwoLatchJob(new Params(0), startLatch, endLatch);
-        jobManager.start();
-        long jobId = jobManager.addJob(twoLatchJob);
-        twoLatchJob.waitTillOnRun();
-        assertThat("job should be in running state", jobManager.getJobStatus(jobId, false), is(JobStatus.RUNNING));
-        startLatch.countDown();//let it run
-        endLatch.await();//wait till it finishes
-        Thread.sleep(500);//give some time to job manager to clear the job
-        assertThat("finished job should go to unknown state", jobManager.getJobStatus(jobId, false), is(JobStatus.UNKNOWN));
-
-        //network requiring job should not be ready
-        for(Integer i : networkRequiringJobIndices) {
-            assertThat("network requiring job should still be not-ready", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-        }
-        jobManager.stop();
-        networkUtil.setHasNetwork(true, true);
-        for(Integer i : networkRequiringJobIndices) {
-            assertThat("network requiring job should still be ready after network is there", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_READY));
-        }
-
-        jobManager.start();
-        int limit = 10;
-        while (jobManager.count() > 0 && limit--  > 0) {
-            Thread.sleep(1000);
-        }
-        //we need a better api callback to do this
-        Thread.sleep(500);
-        assertThat("jobs should finish", jobManager.count(), is(0));
-        for(int i = 0; i < jobs.length; i ++) {
-            //after all jobs finish, state should be unknown
-            assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.UNKNOWN));
-        }
-        final long SHORT_SLEEP = 2000;
-        Job[] delayedJobs = new Job[]{
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
-                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
-        long[] delayedIds = new long[delayedJobs.length];
-        long start = System.currentTimeMillis();
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            delayedIds[i] = jobManager.addJob(delayedJobs[i]);
-        }
-        assertThat("test sanity.", System.currentTimeMillis() - start < SHORT_SLEEP, is(true));
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            assertThat("delayed job(" + i + ") should receive not ready status. startMs:" + start
-                            + ", now:" + System.currentTimeMillis() + ", limit:" + SHORT_SLEEP,
-                    jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-        }
-        jobManager.stop();
-        //sleep
-        Thread.sleep(SHORT_SLEEP * 2);
-        for(int i = 0; i < delayedJobs.length; i ++) {
-            if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
-                assertThat("when enough time passes, delayed jobs should move to ready state",
-                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()),is(JobStatus.WAITING_READY));
-            } else {
-                assertThat("delayed job should receive not ready status until their time comes",
-                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
-            }
-        }
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
deleted file mode 100644
index fc283c3..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class KeepAliveTest extends JobManagerTestBase {
-    @Test
-    public void testKeepAlive() throws Exception {
-        int keepAlive = 3 + (int)(Math.random() * 5);
-        DummyNetworkUtil networkUtilWithoutEventSupport = new DummyNetworkUtil();
-        DummyNetworkUtilWithConnectivityEventSupport networkUtilWithEventSupport = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager1 = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .consumerKeepAlive(keepAlive).networkUtil(networkUtilWithoutEventSupport));
-        JobManager jobManager2 = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .consumerKeepAlive(keepAlive)
-                .networkUtil(networkUtilWithEventSupport));
-        //give it a little time to create first consumer
-        jobManager1.addJob(new DummyJob(new Params(0)));
-        jobManager2.addJob(new DummyJob(new Params(0)));
-        AtomicInteger activeThreadCount1 = getActiveConsumerCount(getConsumerExecutor(jobManager1)).get();
-        AtomicInteger activeThreadCount2 = getActiveConsumerCount(getConsumerExecutor(jobManager2)).get();
-
-        Thread.sleep(1000);
-        MatcherAssert.assertThat("there should be 1 thread  actively waiting for jobs",
-                activeThreadCount1.get(), equalTo(1));
-        MatcherAssert.assertThat("there should be one thread actively waiting for jobs",
-                activeThreadCount2.get(), equalTo(1));
-        //sleep till it dies
-        Thread.sleep((long) (TimeUnit.SECONDS.toMillis(keepAlive) * 1.33));
-        MatcherAssert.assertThat("after keep alive timeout, there should NOT be any threads waiting",
-                activeThreadCount1.get(), equalTo(0));
-        MatcherAssert.assertThat("after keep alive timeout, there should NOT be any threads waiting",
-                activeThreadCount2.get(), equalTo(0));
-
-
-        //disable network and add a network bound job
-        networkUtilWithoutEventSupport.setHasNetwork(false);
-        networkUtilWithEventSupport.setHasNetwork(false, true);
-        jobManager1.addJob(new DummyJob(new Params(0).requireNetwork()));
-        jobManager2.addJob(new DummyJob(new Params(0).requireNetwork()));
-        Thread.sleep(1000 + (long) (TimeUnit.SECONDS.toMillis(keepAlive) * 2));
-        MatcherAssert.assertThat("when network changes cannot be detected, there should be a consumer waiting alive",
-                activeThreadCount1.get(), equalTo(1));
-        MatcherAssert.assertThat("when network changes can be detected, there should not be a consumer waiting alive",
-                activeThreadCount2.get(), equalTo(0));
-        networkUtilWithEventSupport.setHasNetwork(true, true);
-        networkUtilWithoutEventSupport.setHasNetwork(true);
-        Thread.sleep(500);
-        MatcherAssert.assertThat("when network is recovered, job should be handled",
-                jobManager2.count(), equalTo(0));
-        Thread.sleep(1000);
-        MatcherAssert.assertThat("when network is recovered, job should be handled",
-                jobManager1.count(), equalTo(0));
-
-
-    }
-
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
deleted file mode 100644
index 212b64f..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.executor.JobConsumerExecutor;
-import com.path.android.jobqueue.log.CustomLogger;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class LoadFactorTest extends JobManagerTestBase {
-    @Test
-    public void testLoadFactor() throws Exception {
-        //test adding zillions of jobs from the same group and ensure no more than 1 thread is created
-        int maxConsumerCount = 5;
-        int minConsumerCount = 2;
-        int loadFactor = 5;
-        com.path.android.jobqueue.JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
-                .maxConsumerCount(maxConsumerCount)
-                .minConsumerCount(minConsumerCount)
-                .customLogger(new CustomLogger() {
-                    public boolean isDebugEnabled() {return true;}
-                    public void d(String text, Object... args) {System.out.println(String.format(text, args));}
-                    public void e(Throwable t, String text, Object... args) {t.printStackTrace(); System.out.println(String.format(text, args));}
-                    public void e(String text, Object... args) {System.out.println(String.format(text, args));}
-                })
-                .loadFactor(loadFactor));
-        JobConsumerExecutor consumerExecutor = getConsumerExecutor(jobManager);
-        org.fest.reflect.field.Invoker<AtomicInteger> activeConsumerCnt = getActiveConsumerCount(consumerExecutor);
-        Object runLock = new Object();
-        Semaphore semaphore = new Semaphore(maxConsumerCount);
-        int totalJobCount = loadFactor * maxConsumerCount * 5;
-        List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
-        for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
-            runningJobs.add(job);
-            jobManager.addJob(job);
-
-            int expectedConsumerCount = Math.min(maxConsumerCount, (int)Math.ceil((float)(i+1) / loadFactor));
-            if(i >= minConsumerCount) {
-                expectedConsumerCount = Math.max(minConsumerCount, expectedConsumerCount);
-            }
-            //wait till enough jobs start
-            long now = System.nanoTime();
-            long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-            while(System.nanoTime() < waitTill) {
-                if(semaphore.availablePermits() == maxConsumerCount - expectedConsumerCount) {
-                    //enough # of jobs started
-                    break;
-                }
-            }
-            if(i < loadFactor) {
-                //make sure there is only min job running
-                MatcherAssert.assertThat("while below load factor, active consumer count should be = min",
-                        activeConsumerCnt.get().get(), equalTo(Math.min(i + 1, minConsumerCount)));
-            }
-            if(i > loadFactor) {
-                //make sure there is only 1 job running
-                MatcherAssert.assertThat("while above load factor. there should be more job consumers. i=" + i,
-                        activeConsumerCnt.get().get(), equalTo(expectedConsumerCount));
-            }
-        }
-
-        //finish all jobs
-        long now = System.nanoTime();
-        long waitTill = now + TimeUnit.SECONDS.toNanos(10);
-        while(System.nanoTime() < waitTill) {
-            synchronized (runLock) {
-                runLock.notifyAll();
-            }
-            long totalRunningCount = 0;
-            for(DummyJob job : runningJobs) {
-                totalRunningCount += job.getOnRunCnt();
-            }
-            if(totalJobCount == totalRunningCount) {
-                //cool!
-                break;
-            }
-        }
-        MatcherAssert.assertThat("no jobs should remain", jobManager.count(), equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
deleted file mode 100644
index dfed6da..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class NetworkJobTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkJob() throws Exception {
-        JobManagerTestBase.DummyNetworkUtil dummyNetworkUtil = new JobManagerTestBase.DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
-        jobManager.stop();
-
-        DummyJob networkDummyJob = new DummyJob(new Params(5).requireNetwork());
-        jobManager.addJob(networkDummyJob);
-
-        DummyJob noNetworkDummyJob = new DummyJob(new Params(2));
-        jobManager.addJob(noNetworkDummyJob);
-
-        DummyJob networkPersistentJob = new DummyJob(new Params(6).persist().requireNetwork());
-        jobManager.addJob(networkPersistentJob);
-
-        DummyJob noNetworkPersistentJob = new DummyJob(new Params(1).persist());
-        jobManager.addJob(noNetworkPersistentJob);
-
-        MatcherAssert.assertThat("count should be correct if there are network and non-network jobs w/o network", jobManager.count(), equalTo(4));
-        dummyNetworkUtil.setHasNetwork(true);
-        MatcherAssert.assertThat("count should be correct if there is network and non-network jobs w/o network", jobManager.count(), equalTo(4));
-        dummyNetworkUtil.setHasNetwork(false);
-        jobManager.start();
-        Thread.sleep(1000);//this should be enough to consume dummy jobs
-        MatcherAssert.assertThat("no network jobs should be executed even if there is no network", jobManager.count(), equalTo(2));
-        dummyNetworkUtil.setHasNetwork(true);
-        Thread.sleep(1000);//this should be enough to consume dummy jobs
-        MatcherAssert.assertThat("when network is recovered, all network jobs should be automatically consumed", jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
deleted file mode 100644
index 3446739..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class NetworkJobWithConnectivityListenerTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkJobWithConnectivityListener() throws Exception {
-        DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
-        dummyNetworkUtil.setHasNetwork(false, true);
-        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
-        long dummyJobId = jobManager.addJob(dummyJob);
-        Thread.sleep(2000);//sleep a while so that consumers die. they should die since we are using a network util
-        //with event support
-        MatcherAssert.assertThat("count should be 1 as no jobs should be consumed w/o network", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true, false);
-        Thread.sleep(1000); //wait a little bit more to consumer will run
-        MatcherAssert.assertThat("even though network is recovered, job manager should not consume any job because it " +
-                "does not know (we did not inform)", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true, true);
-        Thread.sleep(1000); //wait a little bit more to consumer will run
-        MatcherAssert.assertThat("job manager should consume network job after it is informed that network is recovered"
-                , jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
deleted file mode 100644
index 56c34a8..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.config.Configuration;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import org.fest.reflect.method.Invoker;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.notNullValue;
-import static org.hamcrest.CoreMatchers.nullValue;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class NetworkNextJobTest extends JobManagerTestBase {
-    @Test
-    public void testNetworkNextJob() throws Exception {
-        DummyNetworkUtil dummyNetworkUtil = new DummyNetworkUtil();
-        JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application).networkUtil(dummyNetworkUtil));
-        jobManager.stop();
-        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
-        long dummyJobId = jobManager.addJob(dummyJob);
-        dummyNetworkUtil.setHasNetwork(false);
-        Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
-        MatcherAssert.assertThat("when there isn't any network, next job should return null", nextJobMethod.invoke(), nullValue());
-        MatcherAssert.assertThat("even if there is network, job manager should return correct count", jobManager.count(), equalTo(1));
-        dummyNetworkUtil.setHasNetwork(true);
-        JobHolder retrieved = nextJobMethod.invoke();
-        MatcherAssert.assertThat("when network is recovered, next job should be retrieved", retrieved, notNullValue());
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
deleted file mode 100644
index 2c128c5..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/ReRunWithLimitTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.path.android.jobqueue.test.jobmanager;
-
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.Params;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricGradleTestRunner;
-import org.robolectric.annotation.Config;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class ReRunWithLimitTest extends JobManagerTestBase {
-    @Test
-    public void testReRunWithLimit() throws Exception {
-        JobManager jobManager = createJobManager();
-        testReRun(jobManager, false);
-        testReRun(jobManager, true);
-    }
-
-    private void testReRun(JobManager jobManager, boolean persist) throws InterruptedException {
-        enableDebug();
-        DummyJobWithRunCount.runCount = 0;//reset
-        DummyJobWithRunCount job = new DummyJobWithRunCount(persist);
-        jobManager.addJob(job);
-        int limit = 25;
-        while (limit-- > 0 && DummyJobWithRunCount.runCount != job.getRetryLimit()) {
-            Thread.sleep(100);
-        }
-        MatcherAssert.assertThat(DummyJobWithRunCount.runCount, equalTo(job.getRetryLimit()));
-        MatcherAssert.assertThat((int) jobManager.count(), equalTo(0));
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
deleted file mode 100644
index a6d3873..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedNonPersistentJobQueueTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class CachedNonPersistentJobQueueTest extends JobQueueTestBase {
-    public CachedNonPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new CachedJobQueue(new NonPersistentPriorityQueue(sessionId, id, true));
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
deleted file mode 100644
index 473cb4a..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/CachedPersistentJobQueueTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class CachedPersistentJobQueueTest extends JobQueueTestBase {
-    public CachedPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(RuntimeEnvironment.application, sessionId, id, new SqliteJobQueue.JavaSerializer(), true);
-            }
-        });
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
deleted file mode 100644
index b3458e0..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.test.TestBase;
-import com.path.android.jobqueue.test.jobs.DummyJob;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class JobParamsTest extends TestBase {
-    @Test
-    public void assertParamsUnderstood() {
-        DummyJob j1 = new DummyJob(new Params(1).requireNetwork());
-        assertThat("require network param should be understood properly", j1.requiresNetwork(), equalTo(true));
-        DummyJob j2 = new DummyJob(new Params(1).groupBy("blah"));
-        assertThat("group param should be understood properly", j2.getRunGroupId(), equalTo("blah"));
-        DummyJob j3 = new DummyJob(new Params(1).persist());
-        assertThat("group param should be understood properly", j3.isPersistent(), equalTo(true));
-        DummyJob j4 = new DummyJob(new Params(1).setPersistent(false).setRequiresNetwork(false).setGroupId(null));
-        assertThat("persist param should be understood properly", j4.isPersistent(), equalTo(false));
-        assertThat("require network param should be understood properly", j4.requiresNetwork(), equalTo(false));
-        assertThat("group param should be understood properly", j4.getRunGroupId(), nullValue());
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
deleted file mode 100644
index 08164be..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.JobHolder;
-import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.assertThat;
-import org.hamcrest.*;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.*;
-import org.robolectric.annotation.Config;
-
-import java.util.Collections;
-
-import static com.path.android.jobqueue.TagConstraint.ANY;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class NonPersistentJobQueueTest extends JobQueueTestBase {
-    public NonPersistentJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new NonPersistentPriorityQueue(sessionId, id, true);
-            }
-        });
-    }
-
-    /**
-     * issue #21 https://github.com/path/android-priority-jobqueue/issues/21
-     */
-    @Test
-    public void testTooManyQueueChanges() throws InterruptedException {
-        JobQueue jobQueue = createNewJobQueue();
-        int limit = 10000;
-        long delayMs = 2000;
-        long then = System.nanoTime() + delayMs * JobManager.NS_PER_MS;
-        for(int i = 0; i < limit; i++) {
-            jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork().delayInMs(delayMs)));
-        }
-
-        MatcherAssert.assertThat("all jobs require network, should return null", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
-        long sleep = then - System.nanoTime();
-        sleep += JobManager.NS_PER_MS * 1000;
-        if (sleep > 0) {
-            Thread.sleep(sleep / JobManager.NS_PER_MS);
-        }
-        //should be able to get it w/o an overflow
-        for(int i = 0; i < limit; i++) {
-            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat("should get a next job", holder, notNullValue());
-            jobQueue.remove(holder);
-        }
-    }
-
-    @Test
-    public void testFindByTags() {
-        JobQueue jobQueue = createNewJobQueue();
-        assertThat("empty queue should return 0",jobQueue.findJobsByTags(ANY,
-                false, Collections.<Long>emptyList(), "abc").size(), is(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
deleted file mode 100644
index a38ba87..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.path.android.jobqueue.test.jobqueue;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.JobQueue;
-import com.path.android.jobqueue.Params;
-import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
-import com.path.android.jobqueue.test.util.JobQueueFactory;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.MatcherAssert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricGradleTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(RobolectricGradleTestRunner.class)
-@Config(constants = com.path.android.jobqueue.BuildConfig.class)
-public class SqliteJobQueueTest extends JobQueueTestBase {
-    public SqliteJobQueueTest() {
-        super(new JobQueueFactory() {
-            @Override
-            public JobQueue createNew(long sessionId, String id) {
-                return new SqliteJobQueue(RuntimeEnvironment.application, sessionId, id, new SqliteJobQueue.JavaSerializer(), true);
-            }
-        });
-    }
-
-    @Test
-    public void testCustomSerializer() throws Exception {
-        final CountDownLatch calledForSerialize = new CountDownLatch(1);
-        final CountDownLatch calledForDeserialize = new CountDownLatch(1);
-        SqliteJobQueue.JobSerializer jobSerializer = new SqliteJobQueue.JavaSerializer() {
-            @Override
-            public byte[] serialize(Object object) throws IOException {
-                calledForSerialize.countDown();
-                return super.serialize(object);
-            }
-
-            @Override
-            public <T extends Job> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {
-                calledForDeserialize.countDown();
-                return super.deserialize(bytes);
-            }
-        };
-        SqliteJobQueue jobQueue = new SqliteJobQueue(RuntimeEnvironment.application, System.nanoTime(), "__" + System.nanoTime(),
-                jobSerializer, true);
-        jobQueue.insert(createNewJobHolder(new Params(0)));
-        calledForSerialize.await(1, TimeUnit.SECONDS);
-        MatcherAssert.assertThat("custom serializer should be called for serialize", (int) calledForSerialize.getCount(), CoreMatchers.equalTo(0));
-        MatcherAssert.assertThat("custom serializer should NOT be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(1));
-        jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("custom serializer should be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(0));
-
-    }
-}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
deleted file mode 100644
index 8cb46ef..0000000
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/util/JobQueueFactory.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.path.android.jobqueue.test.util;
-
-import com.path.android.jobqueue.JobQueue;
-
-public interface JobQueueFactory {
-    public JobQueue createNew(long sessionId, String id);
-}
diff --git a/lint/src/main/java/com/birbit/android/jobqueue/lint/JobQueueDevelopmentLintRegistery.java b/lint/src/main/java/com/birbit/android/jobqueue/lint/JobQueueDevelopmentLintRegistery.java
new file mode 100644
index 0000000..a79feeb
--- /dev/null
+++ b/lint/src/main/java/com/birbit/android/jobqueue/lint/JobQueueDevelopmentLintRegistery.java
@@ -0,0 +1,15 @@
+package com.birbit.android.jobqueue.lint;
+
+import com.android.tools.lint.client.api.IssueRegistry;
+import com.android.tools.lint.detector.api.Issue;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class JobQueueDevelopmentLintRegistery extends IssueRegistry {
+    @Override
+    public List<Issue> getIssues() {
+        return Arrays.asList(SystemTimeDetector.ISSUE, SleepDetector.ISSUE, WaitOnObjectWithTimeDetector.ISSUE,
+                NotifyOnObjectDetector.ISSUE);
+    }
+}
diff --git a/lint/src/main/java/com/birbit/android/jobqueue/lint/NotifyOnObjectDetector.java b/lint/src/main/java/com/birbit/android/jobqueue/lint/NotifyOnObjectDetector.java
new file mode 100644
index 0000000..bf7975d
--- /dev/null
+++ b/lint/src/main/java/com/birbit/android/jobqueue/lint/NotifyOnObjectDetector.java
@@ -0,0 +1,48 @@
+package com.birbit.android.jobqueue.lint;
+
+import com.android.annotations.NonNull;
+import com.android.tools.lint.detector.api.*;
+import lombok.ast.AstVisitor;
+import lombok.ast.Expression;
+import lombok.ast.ForwardingAstVisitor;
+import lombok.ast.MethodInvocation;
+
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Set;
+
+public class NotifyOnObjectDetector extends Detector implements Detector.JavaScanner {
+    public static final Issue ISSUE = Issue.create(
+            "NOTIFY_ON_OBJECT",
+            "Code should not notify on objects directly",
+            "Use Timer instead so that mock notifications can work as expected",
+            Category.CORRECTNESS,
+            6,
+            Severity.ERROR,
+            new Implementation(NotifyOnObjectDetector.class, EnumSet.of(Scope.JAVA_FILE))
+    );
+
+    private static final Set<String> BAD_METHODS = new HashSet<String>();
+    static  {
+        BAD_METHODS.add("notify");
+        BAD_METHODS.add("notifyAll");
+    }
+
+    @Override
+    public AstVisitor createJavaVisitor(@NonNull final JavaContext context) {
+        return new ForwardingAstVisitor() {
+
+            @Override
+            public boolean visitMethodInvocation(MethodInvocation node) {
+                Expression operand = node.astOperand();
+                String methodName = node.astName().toString();
+                if (BAD_METHODS.contains(methodName) && !context.isSuppressedWithComment(node, ISSUE)) {
+                    context.report(ISSUE, context.getLocation(node), "Don't call " + methodName + " directly. Use" +
+                            " Timer instead.");
+                }
+                return super.visitMethodInvocation(node);
+            }
+        };
+    }
+}
+
diff --git a/lint/src/main/java/com/birbit/android/jobqueue/lint/SleepDetector.java b/lint/src/main/java/com/birbit/android/jobqueue/lint/SleepDetector.java
new file mode 100644
index 0000000..e7f55ee
--- /dev/null
+++ b/lint/src/main/java/com/birbit/android/jobqueue/lint/SleepDetector.java
@@ -0,0 +1,36 @@
+package com.birbit.android.jobqueue.lint;
+
+import com.android.annotations.NonNull;
+import com.android.tools.lint.detector.api.*;
+import lombok.ast.*;
+
+import java.util.EnumSet;
+
+/**
+ * Detects sleep calls in tests.
+ */
+public class SleepDetector extends Detector implements Detector.JavaScanner {
+    public static final Issue ISSUE = Issue.create(
+            "SLEEP_IN_CODE",
+            "Tests should not use sleep.",
+            "Tests should not use sleep. Instead, use mock timer",
+            Category.CORRECTNESS,
+            6,
+            Severity.ERROR,
+            new Implementation(SleepDetector.class, EnumSet.of(Scope.JAVA_FILE, Scope.TEST_SOURCES))
+    );
+
+    @Override
+    public AstVisitor createJavaVisitor(@NonNull final JavaContext context) {
+        return new ForwardingAstVisitor() {
+            @Override
+            public boolean visitMethodInvocation(MethodInvocation node) {
+                Expression operand = node.astOperand();
+                if (node.astName().toString().equals("sleep") && operand.toString().equals("Thread") && !context.isSuppressedWithComment(node, ISSUE)) {
+                    context.report(ISSUE, node, context.getLocation(node), "Don't call sleep. Use MockTimer instead.");
+                }
+                return super.visitMethodInvocation(node);
+            }
+        };
+    }
+}
diff --git a/lint/src/main/java/com/birbit/android/jobqueue/lint/SystemTimeDetector.java b/lint/src/main/java/com/birbit/android/jobqueue/lint/SystemTimeDetector.java
new file mode 100644
index 0000000..4f300e3
--- /dev/null
+++ b/lint/src/main/java/com/birbit/android/jobqueue/lint/SystemTimeDetector.java
@@ -0,0 +1,48 @@
+package com.birbit.android.jobqueue.lint;
+
+import com.android.annotations.NonNull;
+import com.android.tools.lint.detector.api.*;
+import lombok.ast.AstVisitor;
+import lombok.ast.Expression;
+import lombok.ast.ForwardingAstVisitor;
+import lombok.ast.MethodInvocation;
+
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Set;
+
+public class SystemTimeDetector extends Detector implements Detector.JavaScanner {
+    public static final Issue ISSUE = Issue.create(
+            "DIRECT_TIME_ACCESS",
+            "Code should not access time directly",
+            "Code should not access System time. Use Timer instead.",
+            Category.CORRECTNESS,
+            6,
+            Severity.ERROR,
+            new Implementation(SystemTimeDetector.class, EnumSet.of(Scope.JAVA_FILE))
+    );
+
+    private static final Set<String> BAD_METHODS = new HashSet<String>();
+    static  {
+        BAD_METHODS.add("nanoTime");
+        BAD_METHODS.add("currentTimeMillis");
+    }
+
+    @Override
+    public AstVisitor createJavaVisitor(@NonNull final JavaContext context) {
+        return new ForwardingAstVisitor() {
+
+            @Override
+            public boolean visitMethodInvocation(MethodInvocation node) {
+                Expression operand = node.astOperand();
+                String methodName = node.astName().toString();
+                if (BAD_METHODS.contains(methodName) && operand.toString().equals("System") && !context.isSuppressedWithComment(node, ISSUE)) {
+                    context.report(ISSUE, context.getLocation(node), "Don't call " + methodName + " on system. Use" +
+                            " Timer instead.");
+                }
+                return super.visitMethodInvocation(node);
+            }
+        };
+    }
+}
+
diff --git a/lint/src/main/java/com/birbit/android/jobqueue/lint/WaitOnObjectWithTimeDetector.java b/lint/src/main/java/com/birbit/android/jobqueue/lint/WaitOnObjectWithTimeDetector.java
new file mode 100644
index 0000000..8793e3f
--- /dev/null
+++ b/lint/src/main/java/com/birbit/android/jobqueue/lint/WaitOnObjectWithTimeDetector.java
@@ -0,0 +1,40 @@
+package com.birbit.android.jobqueue.lint;
+
+import com.android.annotations.NonNull;
+import com.android.tools.lint.detector.api.*;
+import lombok.ast.AstVisitor;
+import lombok.ast.Expression;
+import lombok.ast.ForwardingAstVisitor;
+import lombok.ast.MethodInvocation;
+
+import java.util.EnumSet;
+
+/**
+ * Detects sleep calls in tests.
+ */
+public class WaitOnObjectWithTimeDetector extends Detector implements Detector.JavaScanner {
+    public static final Issue ISSUE = Issue.create(
+            "TIMED_WAIT",
+            "Code should not use object locked waits.",
+            "Code should not use timed waits directly. Instead, used the timer's utility method.",
+            Category.CORRECTNESS,
+            6,
+            Severity.ERROR,
+            new Implementation(WaitOnObjectWithTimeDetector.class, EnumSet.of(Scope.JAVA_FILE))
+    );
+
+    @Override
+    public AstVisitor createJavaVisitor(@NonNull final JavaContext context) {
+        return new ForwardingAstVisitor() {
+            @Override
+            public boolean visitMethodInvocation(MethodInvocation node) {
+                Expression operand = node.astOperand();
+                if (node.astName().toString().equals("wait")
+                        && !context.isSuppressedWithComment(node, ISSUE)) {
+                    context.report(ISSUE, context.getLocation(node), "Don't wait on object. Use Timer's wait instead.");
+                }
+                return super.visitMethodInvocation(node);
+            }
+        };
+    }
+}
