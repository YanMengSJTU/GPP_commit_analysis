diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/AsyncCancelCallback.java b/jobqueue/src/main/java/com/path/android/jobqueue/AsyncCancelCallback.java
new file mode 100644
index 0000000..fd84d1f
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/AsyncCancelCallback.java
@@ -0,0 +1,10 @@
+package com.path.android.jobqueue;
+
+/**
+ * If you are canceling the job via the async canceler, you can provide a callback method to receive result.
+ * Please keep in mind that job manager will keep a strong reference to this callback. So if the callback is an
+ * anonymous class inside an {@link android.app.Activity} context, it may leak the activity until the job is canceled.
+ */
+public interface AsyncCancelCallback {
+    public void onCancel(long jobId, boolean isCanceled);
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index 1ac6968..0a7c6b4 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -189,6 +189,71 @@ private void clearOnAddedLock(ConcurrentHashMap<Long, CountDownLatch> lockMap, l
         lockMap.remove(id);
     }
 
+    /**
+     * Cancels job which is waiting to be run.
+     * @param id the ID, returned by the addJob method
+     * @param isPersistent Jobs are added to different queues depending on if they are persistent or not. This is necessary
+     *                     because each queue has independent id sets.
+     * @return true when job is actually canceled, otherwise false (such like already running or not exists).
+     */
+    public boolean cancelJob(long id, boolean isPersistent) {
+        JobHolder holder;
+        synchronized (getNextJobLock) { // to keep from the job state to be changed to running
+            if (jobConsumerExecutor.isRunning(id, isPersistent))
+                return false;
+            if (isPersistent) {
+                synchronized (persistentJobQueue) {
+                    holder = persistentJobQueue.findJobById(id);
+                    if (holder == null)
+                        return false;
+                    persistentJobQueue.remove(holder);
+                }
+            } else {
+                synchronized (nonPersistentJobQueue) {
+                    holder = nonPersistentJobQueue.findJobById(id);
+                    if (holder == null)
+                        return false;
+                    nonPersistentJobQueue.remove(holder);
+                }
+            }
+        }
+        BaseJob baseJob = holder.getBaseJob();
+        if(dependencyInjector != null) {
+            //inject members b4 calling onCancel
+            dependencyInjector.inject(baseJob);
+        }
+        baseJob.onCancel();
+        return true;
+    }
+
+    /**
+     * Non-blocking convenience method to cancel a job in background thread.
+     *
+     * @see #cancelJob(long, boolean)
+     * @param id the ID, returned by the addJob method
+     * @param isPersistent Jobs are added to different queues depending on if they are persistent or not. This is necessary
+     *                     because each queue has independent id sets.
+     */
+    public void cancelJobInBackground(long id, boolean isPersistent) {
+        cancelJobInBackground(id, isPersistent, null);
+    }
+
+    public void cancelJobInBackground(final long id, final boolean isPersistent, /*nullable*/ final AsyncCancelCallback callback) {
+        timedExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    boolean isCanceled = cancelJob(id, isPersistent);
+                    if(callback != null) {
+                        callback.onCancel(id, isCanceled);
+                    }
+                } catch (Throwable t) {
+                    JqLog.e(t, "cancelJobInBackground received an exception. job id: %ld", id);
+                }
+            }
+        });
+    }
+
     /**
      * checks next available job and returns when it will be available (if it will, otherwise returns {@link Long#MAX_VALUE})
      * also creates a timer to notify listeners at that time
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java
new file mode 100644
index 0000000..a8a107e
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelInBackgroundTest.java
@@ -0,0 +1,77 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.AsyncCancelCallback;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.fest.reflect.core.Reflection;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricTestRunner.class)
+public class CancelInBackgroundTest extends JobManagerTestBase {
+    @Test
+    public void testCancelInBackground() throws Exception {
+        cancelInBackground(true);
+        cancelInBackground(false);
+    }
+
+    public void cancelInBackground(final boolean useCallback) throws Exception {
+        long currentThreadId = Thread.currentThread().getId();
+        final AtomicLong onCancelThreadId = new AtomicLong();
+        final CountDownLatch cancelLatch = new CountDownLatch(2);
+
+        Job dummyJob = new DummyJob(new Params(1)) {
+            @Override
+            public void onCancel() {
+                super.onCancel();
+                onCancelThreadId.set(Thread.currentThread().getId());
+                cancelLatch.countDown();
+            }
+        };
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        final long jobId = jobManager.addJob(dummyJob);
+        final JobQueue queue = getNonPersistentQueue(jobManager);
+        assertNotNull(queue.findJobById(jobId));
+        if (useCallback) {
+            jobManager.cancelJobInBackground(jobId, false, new AsyncCancelCallback() {
+                @Override
+                public void onCancel(long callbackJobId, boolean isCanceled) {
+                    assertEquals("jobId should be passsed to callback. id:" + jobId + ", use cb: true"
+                            , jobId, callbackJobId);
+                    assertTrue("isCanceled should be true" , isCanceled);
+                    cancelLatch.countDown();
+                }
+            });
+        } else {
+            cancelLatch.countDown();
+            jobManager.cancelJobInBackground(jobId, false);
+        }
+        cancelLatch.await();
+        MatcherAssert.assertThat("thread ids should be different." , currentThreadId, CoreMatchers.not(onCancelThreadId.get()));
+        if (useCallback) {
+            JobHolder holder = queue.findJobById(jobId);
+            MatcherAssert.assertThat("there should not be a job in the holder. id:" + jobId + ", use cb: true"
+                    , holder, CoreMatchers.nullValue());
+        }
+    }
+
+    protected JobQueue getNonPersistentQueue(JobManager jobManager) {
+        return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java
new file mode 100644
index 0000000..027a57f
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelJobTest.java
@@ -0,0 +1,91 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.fest.reflect.core.Reflection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+import java.util.concurrent.CountDownLatch;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricTestRunner.class)
+public class CancelJobTest extends JobManagerTestBase {
+    @Test
+    public void testCancelJob() throws Exception {
+        testCancelJob(false);
+        testCancelJob(true);
+    }
+
+    private void testCancelJob(boolean isPersistent) {
+        DummyJob dummyJob = new DummyJob(new Params(0).setPersistent(isPersistent));
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        long jobId = jobManager.addJob(dummyJob);
+        JobQueue queue = getQueue(jobManager, isPersistent);
+        assertNotNull("there should be a job in the holder. id:" + jobId + ", isPersistent:" + isPersistent
+                , queue.findJobById(jobId));
+        boolean isCanceled = jobManager.cancelJob(jobId, isPersistent);
+        assertTrue("cancelJob() should return true. id: " + jobId + ", isPersistent:" + isPersistent
+                , isCanceled);
+        assertNull("there should not be a job exists in queue. id:" + jobId + ", isPersistent:" + isPersistent
+                , queue.findJobById(jobId));
+        // the job handled in manager and the one here are different instance if persistent.
+        if (!isPersistent) {
+            assertEquals("job.onCancel() should be called once. id:" + jobId + ", isPersistent: false"
+                    , 1, dummyJob.getOnCancelCnt());
+        }
+    }
+
+    @Test
+    public void testCancelRunningJob() throws Exception {
+        final CountDownLatch runWaitLatch = new CountDownLatch(1);
+        final CountDownLatch runEndLatch = new CountDownLatch(1);
+        DummyJob dummyJob = new DummyJob(new Params(0)) {
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                runWaitLatch.countDown();
+                runEndLatch.await();
+            }
+        };
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        long jobId = jobManager.addJob(dummyJob);
+        JobQueue queue = getQueue(jobManager, false);
+        assertNotNull("there should be a job in the holder. id:" + jobId
+                , queue.findJobById(jobId));
+        jobManager.start();
+        runWaitLatch.await();
+        boolean isCanceled = jobManager.cancelJob(jobId, false);
+        assertFalse("cancelJob() should return false. id: " + jobId, isCanceled);
+        runEndLatch.countDown();
+        jobManager.stop();
+    }
+
+    @Test
+    public void testCancelNotExistJob() throws Exception {
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        long jobId = 0xDEADBEEF;
+        boolean isCanceled = jobManager.cancelJob(jobId, false);
+        assertFalse("cancelJob() should return false. id: " + jobId, isCanceled);
+    }
+
+    private JobQueue getQueue(JobManager jobManager, boolean isPersistent) {
+        if (isPersistent) {
+            return Reflection.field("persistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
+        } else {
+            return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
+        }
+    }
+}
