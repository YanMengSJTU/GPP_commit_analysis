diff --git a/README.md b/README.md
index 02dc59a..c3be0e8 100644
--- a/README.md
+++ b/README.md
@@ -8,12 +8,13 @@ Priority Job Queue is an implementation of a [Job Queue](http://en.wikipedia.org
 It is written primarily with [flexibility][10] & [functionality][11] in mind. This is an ongoing project, which we will continue to add stability and performance improvements.
 
   - [Why ?](#why-)
-   - [The Problem](#the-problem) 
+   - [The Problem](#the-problem)
    - [Our Solution](#our-solution)
   - [Show me the code](#show-me-the-code)
   - [What's happening under the hood?](#under-the-hood)
   - [Advantages](#advantages)
   - [Getting Started](#getting-started)
+  - [Version History](#version-history)
   - [Building](#building)
    - [Running Tests](#running-tests)
   - [wiki][9]
@@ -24,7 +25,7 @@ It is written primarily with [flexibility][10] & [functionality][11] in mind. Th
 ### Why ?
 #### The Problem
 Almost every application does work in a background thread. These "background tasks" are expected to keep the application responsive and robust, especially during unfavorable situations (e.g. limited network connectivity). In Android applications, there are several ways to implement background work:
- 
+
  * **Async Task:** Using an async task is the simplest approach, but it is tightly coupled with the activity lifecycle. If the activity dies (or is re-created), any ongoing async task will become wasted cycles or otherwise create unexpected behavior upon returning to the main thread. In addition, it is a terrible idea to drop a response from a network request just because a user rotated his/her phone.
  * **Loaders:** Loaders are a better option, as they recover themselves after a configuration change. On the other hand, they are designed to load data from disk and are not well suited for long-running network requests.
  * **Service with a Thread Pool:** Using a service is a much better solution, as it de-couples business logic from your UI. However, you will need a thread pool (e.g. ThreadPoolExecutor) to process requests in parallel, broadcast events to update the UI, and write additional code to persist queued requests to disk. As your application grows, the number of background operations grows, which force you to consider task prioritization and often-complicated concurrency problems.
@@ -38,17 +39,18 @@ Although not required, it is most useful when used with an event bus. It also su
 
 ### Show me the code
 
-Since a code example is worth thousands of documentation pages, here it is. ([full version](https://github.com/path/android-priority-jobqueue/wiki/complete-job-example))
+Since a code example is worth thousands of documentation pages, here it is.
 
-File: SendTweetJob.java
+File: [PostTweetJob.java](https://github.com/path/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java)
 ``` java
 // A job to send a tweet
-public class PostTweetJob extends BaseJob implements Serializeable {
+public class PostTweetJob extends Job {
+    public static final int PRIORITY = 1;
     private String text;
     public PostTweetJob(String text) {
         // This job requires network connectivity,
         // and should be persisted in case the application exits before job is completed.
-        super(true, true);
+        super(new Params(PRIORITY).requireNetwork().persist());
     }
     @Override
     public void onAdded() {
@@ -75,13 +77,15 @@ public class PostTweetJob extends BaseJob implements Serializeable {
 
 ```
 
-File: TweetActivity.java
+File: [TweetActivity.java](https://github.com/path/android-priority-jobqueue/blob/master/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java#L53)
 ``` java
 //...
 public void onSendClick() {
-    final String status = editText.getText();
-    jobManager.addJobInBackground(1, new PostTweetJob(status));
-    editText.setText("");
+    final String status = editText.getText().toString();
+    if(status.trim().length() > 0) {
+      jobManager.addJobInBackground(new PostTweetJob(status));
+      editText.setText("");
+    }
 }
 ...
 ```
@@ -97,13 +101,13 @@ That's it. :) Job Manager allows you to enjoy:
 * When user clicked the send button, `onSendClick()` was called, which creates a `PostTweetJob` and adds it to Job Queue for execution.
 It runs on a background thread because Job Queue will make a disk access to persist the job.
 
-* Right after `PostTweetJob` is synchronized to disk, Job Queue calls `DependencyInjector` (if provided) which will [inject fields](http://en.wikipedia.org/wiki/Dependency_injection) into our job instance. 
+* Right after `PostTweetJob` is synchronized to disk, Job Queue calls `DependencyInjector` (if provided) which will [inject fields](http://en.wikipedia.org/wiki/Dependency_injection) into our job instance.
 At `PostTweetJob.onAdded()` callback, we saved `PostTweetJob` to disk. Since there has been no network access up to this point, the time between clicking the send button and reaching `onAdded()` is within fracions of a second. This allows the implementation of `onAdded()` to inform UI to display the newly sent tweet almost instantly, creating a "fast" user experience. Beware, `onAdded()` is called on the thread job was added.
 
-* When it's time for `PostTweetJob` to run, Job Queue will call `onRun()` (and it will only be called if there is an active network connection, as dictated at the job's constructor). 
+* When it's time for `PostTweetJob` to run, Job Queue will call `onRun()` (and it will only be called if there is an active network connection, as dictated at the job's constructor).
 By default, Job Queue uses a simple connection utility that checks `ConnectivityManager` (ensure you have `ACCESS_NETWORK_STATE` permission in your manifest). You can provide a [custom implementation][1] which can
 add additional checks (e.g. your server stability). You should also provide a [`NetworkUtil`][1] which can notify Job Queue when network
-is recovered so that Job Queue will avoid a busy loop and decrease # of consumers(default configuration does it for you). 
+is recovered so that Job Queue will avoid a busy loop and decrease # of consumers(default configuration does it for you).
 
 * Job Queue will keep calling `onRun()` until it succeeds (or reaches a retry limit). If `onRun()` throws an exception,
 Job Queue will call `shouldReRunOnThrowable()` to allow you to handle the exception and decide whether to retry job execution or abort.
@@ -123,9 +127,9 @@ At Path, we use [greenrobot's EventBus](https://github.com/greenrobot/EventBus);
 
 
 ### Getting Started
-We distribute artifacts through maven central repository. 
+We distribute artifacts through maven central repository.
 
-Gradle: `compile 'com.path:android-priority-jobqueue:0.9.9'`
+Gradle: `compile 'com.path:android-priority-jobqueue:1.1.2'`
 
 Maven:
 
@@ -133,7 +137,7 @@ Maven:
 <dependency>
     <groupId>com.path</groupId>
     <artifactId>android-priority-jobqueue</artifactId>
-    <version>0.9.9</version>
+    <version>1.1.2</version>
 </dependency>
 ```
 
@@ -145,6 +149,21 @@ We highly recommend checking how you can configure job manager and individual jo
 * [Review sample app][6]
 * [Review sample configuration][7]
 
+### Version History
+  - 1.1.2 (Feb 18, 2014)
+   - Report exceptions to logger if addInBackground fails. (#31)
+  - 1.1.1 (Feb 8, 2014)
+   - Fixed an important bug (#35) where jobs in the same group may run in parallel if many of them become available at the same time while multiple consumer threads are waiting for a new job. 
+  - 1.1 (Jan 30, 2014)
+   - Job Status query API (#18)
+   - Fixed a stackoverflow bug when network status changes after a long time. (#21) 
+  - 1.0 (Jan 14, 2014):
+   - Added [parameterized][12] constructor for Job for more readable code.
+   - Deprecated `BaseJob` in favor of a more complete `Job` class.
+  - 0.9.9 (Dec 16, 2013):
+   - First public release.
+
+
 ### [Wiki][9]
 
 ### Dependencies
@@ -167,7 +186,7 @@ We are in the process of moving build system from ant to gradle. Right now, you
 * Clone the repo
 * `> cd jobqueue`
 * `> ant clean build-jar`
-* 
+*
 This will create a jar file under _release_ folder.
 
 #### Running Tests
@@ -215,3 +234,4 @@ THE SOFTWARE.
 [9]: https://github.com/path/android-priority-jobqueue/wiki
 [10]: https://github.com/path/android-priority-jobqueue/wiki/Job-Manager-Configuration
 [11]: https://github.com/path/android-priority-jobqueue/wiki/Job-Configuration
+[12]: https://github.com/path/android-priority-jobqueue/blob/master/jobqueue/src/com/path/android/jobqueue/Params.java
diff --git a/examples/twitter/TwitterClient/build.gradle b/examples/twitter/TwitterClient/build.gradle
index 9240443..7171435 100644
--- a/examples/twitter/TwitterClient/build.gradle
+++ b/examples/twitter/TwitterClient/build.gradle
@@ -1,10 +1,15 @@
+task wrapper(type: Wrapper) {
+    gradleVersion = '1.10'
+}
+
+
 buildscript {
     repositories {
         mavenCentral()
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.7.+'
+        classpath 'com.android.tools.build:gradle:0.9.+'
     }
 }
 
@@ -13,6 +18,9 @@ apply plugin: 'android'
 repositories {
     mavenLocal()
     mavenCentral()
+    maven {
+        url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
 }
 
 class RunApk extends DefaultTask {
@@ -42,7 +50,7 @@ tasks.create(name: "runTwitter", type: RunApk){
 
 android {
     compileSdkVersion 17
-    buildToolsVersion "18.1.0"
+    buildToolsVersion "19.0.3"
     defaultConfig {
         minSdkVersion 15
         targetSdkVersion 17
@@ -50,8 +58,8 @@ android {
 
     dependencies {
         compile 'de.greenrobot:eventbus:2.1.0-beta-1'
-        compile 'org.twitter4j:twitter4j-core:3.0.3'
-        compile 'com.path:android-priority-jobqueue:0.9.9'
+        compile 'org.twitter4j:twitter4j-core:3.0.5'
+        compile 'com.path:android-priority-jobqueue:1.1-SNAPSHOT'
         compile files('external-libs/greenDAO.jar')
     }
 
diff --git a/examples/twitter/TwitterClient/gradlew b/examples/twitter/TwitterClient/gradlew
new file mode 100755
index 0000000..91a7e26
--- /dev/null
+++ b/examples/twitter/TwitterClient/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/examples/twitter/TwitterClient/gradlew.bat b/examples/twitter/TwitterClient/gradlew.bat
new file mode 100644
index 0000000..aec9973
--- /dev/null
+++ b/examples/twitter/TwitterClient/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java
index 0d60b42..7c2e6a7 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/Config.java
@@ -1,11 +1,11 @@
 package com.path.android.jobqueue.examples.twitter;
 
 public class Config {
-    public static final String CONSUMER_KEY = "W1aPoCdw3QjdKpRm4NdTQ";
-    public static final String CONSUMER_SECRET = "fCvy2QV2uSmaaPHRkYQqFA4dZHrusjvQR5lNmEeHI";
+    public static final String CONSUMER_KEY = "APEGHy66BMYzvgEktDfc1Q";
+    public static final String CONSUMER_SECRET = "wf8XXYwivxHQtiIqPSD3lpq6po9JGRyYBIX0lT0";
 
-    public static final String ACCESS_TOKEN = "1443060589-h6JU83NsHMYx5M47Is2RzlVZmvHPbxQND9xT6KQ";
-    public static final String ACCESS_TOKEN_SECRET = "QLut9Mgwge5WptlVnCz9wxmbJrqBFNazkEYrGDZKYE";
+    public static final String ACCESS_TOKEN = "1443060589-ZW0lPmcN0NOwy2AchLjZjixHLhPXClYOPQ0IhWG";
+    public static final String ACCESS_TOKEN_SECRET = "Tq8aVvT1PA6PXtKHgI5v1EL5UQj3JcGlFzXla2zethjYO";
 
     public static final String REQUEST_TOKEN_URL = "https://api.twitter.com/oauth/request_token";
     public static final String AUTHORIZE_URL = "https://api.twitter.com/oauth/authorize";
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java
index 05ea0d2..7584732 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/SampleTwitterClient.java
@@ -51,7 +51,7 @@ public void onClick(View view) {
     }
 
     private void sendTweet(final String text) {
-        jobManager.addJobInBackground(1, new PostTweetJob(text));
+        jobManager.addJobInBackground(new PostTweetJob(text));
     }
 
     @Override
@@ -99,7 +99,7 @@ private void onUpdateEvent() {
     @Override
     protected void onResume() {
         super.onResume();
-        jobManager.addJobInBackground(0, new FetchTweetsJob());
+        jobManager.addJobInBackground(new FetchTweetsJob());
         if(dataDirty) {
             refreshList();
             dataDirty = false;
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java
index 18e9200..abd4635 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/controllers/TwitterController.java
@@ -3,6 +3,7 @@
 import com.path.android.jobqueue.examples.twitter.Config;
 import twitter4j.*;
 import twitter4j.auth.AccessToken;
+import twitter4j.conf.ConfigurationBuilder;
 
 import java.util.List;
 
@@ -21,7 +22,13 @@ public synchronized static TwitterController getInstance() {
     }
 
     public TwitterController() {
-        twitter = TwitterFactory.getSingleton();
+        twitter = new TwitterFactory(new ConfigurationBuilder()
+        .setOAuthAccessToken(Config.ACCESS_TOKEN)
+        .setOAuthAccessTokenSecret(Config.ACCESS_TOKEN_SECRET)
+        .setDebugEnabled(true)
+        .setOAuthConsumerKey(Config.CONSUMER_KEY)
+        .setOAuthConsumerKey(Config.CONSUMER_SECRET)
+        .build()).getSingleton();
         AccessToken accessToken = new AccessToken(Config.ACCESS_TOKEN, Config.ACCESS_TOKEN_SECRET);
         twitter.setOAuthConsumer(Config.CONSUMER_KEY, Config.CONSUMER_SECRET);
         twitter.setOAuthAccessToken(accessToken);
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
index 2fb6943..2276788 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/FetchTweetsJob.java
@@ -1,6 +1,8 @@
 package com.path.android.jobqueue.examples.twitter.jobs;
 
 import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
 import com.path.android.jobqueue.examples.twitter.entities.Tweet;
 import com.path.android.jobqueue.examples.twitter.events.FetchedNewTweetsEvent;
@@ -14,12 +16,12 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 
-public class FetchTweetsJob extends BaseJob {
+public class FetchTweetsJob extends Job {
     private static final AtomicInteger jobCounter = new AtomicInteger(0);
 
     private final int id;
     public FetchTweetsJob() {
-        super(true, false, "fetch-tweets");
+        super(new Params(Priority.LOW).requireNetwork().groupBy("fetch-tweets"));
         id = jobCounter.incrementAndGet();
     }
 
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
index 63e59cc..a83ef66 100644
--- a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/PostTweetJob.java
@@ -1,6 +1,8 @@
 package com.path.android.jobqueue.examples.twitter.jobs;
 
 import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.examples.twitter.controllers.TwitterController;
 import com.path.android.jobqueue.examples.twitter.entities.Tweet;
 import com.path.android.jobqueue.examples.twitter.events.DeletedTweetEvent;
@@ -13,11 +15,11 @@
 
 import java.util.Date;
 
-public class PostTweetJob extends BaseJob {
+public class PostTweetJob extends Job {
     private long localId;
     private String text;
     public PostTweetJob(String text) {
-        super(true, true, "post_tweet");//order of tweets matter, we don't want to send two in parallel
+        super(new Params(Priority.MID).requireNetwork().persist().groupBy("post_tweet"));//order of tweets matter, we don't want to send two in parallel
         //use a negative id so that it cannot collide w/ twitter ids
         //we have to set local id here so it gets serialized into job (to find tweet later on)
         localId = -System.currentTimeMillis();
diff --git a/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java
new file mode 100644
index 0000000..569aeea
--- /dev/null
+++ b/examples/twitter/TwitterClient/src/com/path/android/jobqueue/examples/twitter/jobs/Priority.java
@@ -0,0 +1,7 @@
+package com.path.android.jobqueue.examples.twitter.jobs;
+
+public class Priority {
+    public static int LOW = 0;
+    public static int MID = 500;
+    public static int HIGH = 1000;
+}
diff --git a/jobqueue/AndroidManifest.xml b/jobqueue/AndroidManifest.xml
index 5ffa6d2..7e37c4b 100644
--- a/jobqueue/AndroidManifest.xml
+++ b/jobqueue/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.path.android.jobqueue"
-          android:versionCode="1"
-          android:versionName="0.9.9">
+          android:versionCode="2"
+          android:versionName="1.1.2">
     <application android:label="">
     </application>
 </manifest>
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 0f95899..e6d5fbf 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -1,4 +1,8 @@
 import java.util.regex.Pattern
+task wrapper(type: Wrapper) {
+    gradleVersion = '1.10'
+}
+
 apply plugin: 'maven'
 apply plugin: 'signing'
 
@@ -8,7 +12,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.6.+'
+        classpath 'com.android.tools.build:gradle:0.8.+'
     }
 }
 
@@ -22,7 +26,7 @@ apply plugin: 'android-library'
 
 android {
     compileSdkVersion 19
-    buildToolsVersion "18.1.0"
+    buildToolsVersion "19.0.1"
     sourceSets {
         main {
             manifest.srcFile 'AndroidManifest.xml'
@@ -34,11 +38,12 @@ android {
 
 //READ VERSION NAME
 def manifestFile = file("AndroidManifest.xml")
-def pattern = Pattern.compile("versionName=\"([\\d\\.]+)\"")
+def pattern = Pattern.compile("versionName=\"([\\d\\.\\w\\-]+)\"")
 def manifestText = manifestFile.getText()
 def matcher = pattern.matcher(manifestText)
 matcher.find()
 def manifestVersionName = matcher.group(1)
+println "version name:${manifestVersionName}"
 
 //create jar tasks
 android.libraryVariants.all { variant ->
diff --git a/jobqueue/build.xml b/jobqueue/build.xml
index a11dd7e..279be48 100644
--- a/jobqueue/build.xml
+++ b/jobqueue/build.xml
@@ -193,7 +193,7 @@
 
 
         <mkdir dir="${basedir}/out/reports/tests"/>
-        <junit showoutput="true" fork="yes" haltonfailure="yes" failureproperty="junit.failure" printsummary="yes" logfailedtests="true">
+        <junit showoutput="true" fork="no" haltonfailure="yes" failureproperty="junit.failure" printsummary="yes" logfailedtests="true">
             <jvmarg value="-Xmx2g"/>
             <formatter type="plain" usefile="false"/>
             <formatter type="plain"/>
diff --git a/jobqueue/gradle/wrapper/gradle-wrapper.jar b/jobqueue/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..5838598
Binary files /dev/null and b/jobqueue/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/jobqueue/gradle/wrapper/gradle-wrapper.properties b/jobqueue/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..59739c3
--- /dev/null
+++ b/jobqueue/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Thu Jan 30 14:19:18 PST 2014
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip
diff --git a/jobqueue/gradlew b/jobqueue/gradlew
new file mode 100755
index 0000000..91a7e26
--- /dev/null
+++ b/jobqueue/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/jobqueue/gradlew.bat b/jobqueue/gradlew.bat
new file mode 100644
index 0000000..aec9973
--- /dev/null
+++ b/jobqueue/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/jobqueue/src/com/path/android/jobqueue/AsyncAddCallback.java b/jobqueue/src/com/path/android/jobqueue/AsyncAddCallback.java
new file mode 100644
index 0000000..2b464e6
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/AsyncAddCallback.java
@@ -0,0 +1,12 @@
+package com.path.android.jobqueue;
+
+import android.app.Activity;
+
+/**
+ * If you are adding the job via the async adder, you can provide a callback method to receive the ID.
+ * Please keep in mind that job manager will keep a strong reference to this callback. So if the callback is an
+ * anonymous class inside an {@link Activity} context, it may leak the activity until the job is added.
+ */
+public interface AsyncAddCallback {
+    public void onAdded(long jobId);
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/BaseJob.java b/jobqueue/src/com/path/android/jobqueue/BaseJob.java
index 912390c..0343605 100644
--- a/jobqueue/src/com/path/android/jobqueue/BaseJob.java
+++ b/jobqueue/src/com/path/android/jobqueue/BaseJob.java
@@ -8,9 +8,11 @@
 import java.io.Serializable;
 
 /**
- * base class for any job to extend from.
- *
+ * This class has been deprecated and will soon be removed from public api.
+ * Please use {@link Job} instead which provider a cleaner constructor API.
+ * Deprecated. Use {@link Job}
  */
+@Deprecated
 abstract public class BaseJob implements Serializable {
     public static final int DEFAULT_RETRY_LIMIT = 20;
     private boolean requiresNetwork;
diff --git a/jobqueue/src/com/path/android/jobqueue/Job.java b/jobqueue/src/com/path/android/jobqueue/Job.java
new file mode 100644
index 0000000..15011dc
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/Job.java
@@ -0,0 +1,38 @@
+package com.path.android.jobqueue;
+
+import java.io.Serializable;
+
+/**
+ * Base class for all of your jobs.
+ * If you were using {@link BaseJob}, please move to this instance since BaseJob will be removed from the public api.
+ */
+@SuppressWarnings("deprecation")
+abstract public class Job extends BaseJob implements Serializable {
+    private static final long serialVersionUID = 1L;
+    private transient int priority;
+    private transient long delayInMs;
+
+    protected Job(Params params) {
+        super(params.doesRequireNetwork(), params.isPersistent(), params.getGroupId());
+        this.priority = params.getPriority();
+        this.delayInMs = params.getDelayMs();
+    }
+
+    /**
+     * used by {@link JobManager} to assign proper priority at the time job is added.
+     * This field is not preserved!
+     * @return priority (higher = better)
+     */
+    public final int getPriority() {
+        return priority;
+    }
+
+    /**
+     * used by {@link JobManager} to assign proper delay at the time job is added.
+     * This field is not preserved!
+     * @return delay in ms
+     */
+    public final long getDelayInMs() {
+        return delayInMs;
+    }
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/JobManager.java b/jobqueue/src/com/path/android/jobqueue/JobManager.java
index 056d950..1ac6968 100644
--- a/jobqueue/src/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/com/path/android/jobqueue/JobManager.java
@@ -11,6 +11,7 @@
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
 
+import java.util.Collection;
 import java.util.concurrent.*;
 
 /**
@@ -40,6 +41,7 @@
     private final ConcurrentHashMap<Long, CountDownLatch> persistentOnAddedLocks;
     private final ConcurrentHashMap<Long, CountDownLatch> nonPersistentOnAddedLocks;
     private final ScheduledExecutorService timedExecutor;
+    private final Object getNextJobLock = new Object();
 
     /**
      * Default constructor that will create a JobManager with 1 {@link SqliteJobQueue} and 1 {@link NonPersistentPriorityQueue}
@@ -136,87 +138,28 @@ private int countReadyJobs(boolean hasNetwork) {
     }
 
     /**
-     * Adds a job with given priority and returns the JobId.
-     * @param priority Higher runs first
-     * @param baseJob The actual job to run
-     * @return job id
+     * Adds a new Job to the list and returns an ID for it.
+     * @param job to add
+     * @return id for the job.
      */
-    public long addJob(int priority, BaseJob baseJob) {
-        return addJob(priority, 0, baseJob);
-    }
-
-    /**
-     * Adds a job with given priority and returns the JobId.
-     * @param priority Higher runs first
-     * @param delay number of milliseconds that this job should be delayed
-     * @param baseJob The actual job to run
-     * @return a job id. is useless for now but we'll use this to cancel jobs in the future.
-     */
-    public long addJob(int priority, long delay, BaseJob baseJob) {
-        JobHolder jobHolder = new JobHolder(priority, baseJob, delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY, NOT_RUNNING_SESSION_ID);
-        long id;
-        if (baseJob.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                id = persistentJobQueue.insert(jobHolder);
-                addOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                id = nonPersistentJobQueue.insert(jobHolder);
-                addOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        if(JqLog.isDebugEnabled()) {
-            JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
-                    , id, baseJob.getClass().getSimpleName(), priority, delay, baseJob.getRunGroupId()
-                    , baseJob.isPersistent(), baseJob.requiresNetwork());
-        }
-        if(dependencyInjector != null) {
-            //inject members b4 calling onAdded
-            dependencyInjector.inject(baseJob);
-        }
-        jobHolder.getBaseJob().onAdded();
-        if(baseJob.isPersistent()) {
-            synchronized (persistentJobQueue) {
-                clearOnAddedLock(persistentOnAddedLocks, id);
-            }
-        } else {
-            synchronized (nonPersistentJobQueue) {
-                clearOnAddedLock(nonPersistentOnAddedLocks, id);
-            }
-        }
-        notifyJobConsumer();
-        return id;
+    public long addJob(Job job) {
+        //noinspection deprecation
+        return addJob(job.getPriority(), job.getDelayInMs(), job);
     }
 
     /**
      * Non-blocking convenience method to add a job in background thread.
+     * @see #addJob(Job)
+     * @param job job to add
      *
-     * @see #addJob(int, BaseJob) addJob(priority, job).
      */
-    public void addJobInBackground(final int priority, final BaseJob baseJob) {
-        timedExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                addJob(priority, baseJob);
-            }
-        });
+    public void addJobInBackground(Job job) {
+        //noinspection deprecation
+        addJobInBackground(job.getPriority(), job.getDelayInMs(), job);
     }
 
-    /**
-     * Non-blocking convenience method to add a job in background thread.
-     *
-     * @see #addJob(int, long, BaseJob) addJob(priority, delay, job).
-     */
-    public void addJobInBackground(final int priority, final long delay, final BaseJob baseJob) {
-        final long callTime = System.nanoTime();
-        timedExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-                final long runDelay = (System.nanoTime() - callTime) / NS_PER_MS;
-                addJob(priority, Math.max(0, delay - runDelay), baseJob);
-            }
-        });
+    public void addJobInBackground(Job job, /*nullable*/ AsyncAddCallback callback) {
+        addJobInBackground(job.getPriority(), job.getDelayInMs(), job, callback);
     }
 
     //need to sync on related job queue before calling this
@@ -319,30 +262,36 @@ private JobHolder getNextJob() {
         boolean haveNetwork = hasNetwork();
         JobHolder jobHolder;
         boolean persistent = false;
-        synchronized (nonPersistentJobQueue) {
-            jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups.getSafe());
-        }
-        if (jobHolder == null) {
-            //go to disk, there aren't any non-persistent jobs
-            synchronized (persistentJobQueue) {
-                jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobGroups.getSafe());
-                persistent = true;
+        synchronized (getNextJobLock) {
+            final Collection<String> runningJobIds = runningJobGroups.getSafe();
+            synchronized (nonPersistentJobQueue) {
+                jobHolder = nonPersistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobIds);
             }
-        }
-        if(jobHolder != null) {
-            //wait for onAdded locks
-            if(persistent) {
-                waitForOnAddedLock(persistentOnAddedLocks, jobHolder.getId());
-            } else {
-                waitForOnAddedLock(nonPersistentOnAddedLocks, jobHolder.getId());
+            if (jobHolder == null) {
+                //go to disk, there aren't any non-persistent jobs
+                synchronized (persistentJobQueue) {
+                    jobHolder = persistentJobQueue.nextJobAndIncRunCount(haveNetwork, runningJobIds);
+                    persistent = true;
+                }
+            }
+            if(jobHolder == null) {
+                return null;
+            }
+            if(persistent && dependencyInjector != null) {
+                dependencyInjector.inject(jobHolder.getBaseJob());
+            }
+            if(jobHolder.getGroupId() != null) {
+                runningJobGroups.add(jobHolder.getGroupId());
             }
         }
-        if(persistent && jobHolder != null && dependencyInjector != null) {
-            dependencyInjector.inject(jobHolder.getBaseJob());
-        }
-        if(jobHolder != null && jobHolder.getGroupId() != null) {
-            runningJobGroups.add(jobHolder.getGroupId());
+
+        //wait for onAdded locks. wait for locks after job is selected so that we minimize the lock
+        if(persistent) {
+            waitForOnAddedLock(persistentOnAddedLocks, jobHolder.getId());
+        } else {
+            waitForOnAddedLock(nonPersistentOnAddedLocks, jobHolder.getId());
         }
+
         return jobHolder;
     }
 
@@ -362,6 +311,48 @@ private void reAddJob(JobHolder jobHolder) {
         }
     }
 
+    /**
+     * Returns the current status of a {@link Job}.
+     * <p>
+     *     You should not call this method on the UI thread because it may make a db request.
+     * </p>
+     * <p>
+     *     This is not a very fast call so try not to make it unless necessary. Consider using events if you need to be
+     *     informed about a job's lifecycle.
+     * </p>
+     * @param id the ID, returned by the addJob method
+     * @param isPersistent Jobs are added to different queues depending on if they are persistent or not. This is necessary
+     *                     because each queue has independent id sets.
+     * @return
+     */
+    public JobStatus getJobStatus(long id, boolean isPersistent) {
+        if(jobConsumerExecutor.isRunning(id, isPersistent)) {
+            return JobStatus.RUNNING;
+        }
+        JobHolder holder;
+        if(isPersistent) {
+            synchronized (persistentJobQueue) {
+                holder = persistentJobQueue.findJobById(id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                holder = nonPersistentJobQueue.findJobById(id);
+            }
+        }
+        if(holder == null) {
+            return JobStatus.UNKNOWN;
+        }
+        boolean network = hasNetwork();
+        if(holder.requiresNetwork() && !network) {
+            return JobStatus.WAITING_NOT_READY;
+        }
+        if(holder.getDelayUntilNs() > System.nanoTime()) {
+            return JobStatus.WAITING_NOT_READY;
+        }
+
+        return JobStatus.WAITING_READY;
+    }
+
     private void removeJob(JobHolder jobHolder) {
         if (jobHolder.getBaseJob().isPersistent()) {
             synchronized (persistentJobQueue) {
@@ -477,6 +468,112 @@ public int countRemainingReadyJobs() {
         }
     };
 
+    /**
+     * Deprecated, please use {@link #addJob(Job)}.
+     *
+     * <p>Adds a job with given priority and returns the JobId.</p>
+     * @param priority Higher runs first
+     * @param baseJob The actual job to run
+     * @return job id
+     */
+    @Deprecated
+    public long addJob(int priority, BaseJob baseJob) {
+        return addJob(priority, 0, baseJob);
+    }
+
+    /**
+     * Deprecated, please use {@link #addJob(Job)}.
+     *
+     * <p>Adds a job with given priority and returns the JobId.</p>
+     * @param priority Higher runs first
+     * @param delay number of milliseconds that this job should be delayed
+     * @param baseJob The actual job to run
+     * @return a job id. is useless for now but we'll use this to cancel jobs in the future.
+     */
+    @Deprecated
+    public long addJob(int priority, long delay, BaseJob baseJob) {
+        JobHolder jobHolder = new JobHolder(priority, baseJob, delay > 0 ? System.nanoTime() + delay * NS_PER_MS : NOT_DELAYED_JOB_DELAY, NOT_RUNNING_SESSION_ID);
+        long id;
+        if (baseJob.isPersistent()) {
+            synchronized (persistentJobQueue) {
+                id = persistentJobQueue.insert(jobHolder);
+                addOnAddedLock(persistentOnAddedLocks, id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                id = nonPersistentJobQueue.insert(jobHolder);
+                addOnAddedLock(nonPersistentOnAddedLocks, id);
+            }
+        }
+        if(JqLog.isDebugEnabled()) {
+            JqLog.d("added job id: %d class: %s priority: %d delay: %d group : %s persistent: %s requires network: %s"
+                    , id, baseJob.getClass().getSimpleName(), priority, delay, baseJob.getRunGroupId()
+                    , baseJob.isPersistent(), baseJob.requiresNetwork());
+        }
+        if(dependencyInjector != null) {
+            //inject members b4 calling onAdded
+            dependencyInjector.inject(baseJob);
+        }
+        jobHolder.getBaseJob().onAdded();
+        if(baseJob.isPersistent()) {
+            synchronized (persistentJobQueue) {
+                clearOnAddedLock(persistentOnAddedLocks, id);
+            }
+        } else {
+            synchronized (nonPersistentJobQueue) {
+                clearOnAddedLock(nonPersistentOnAddedLocks, id);
+            }
+        }
+        notifyJobConsumer();
+        return id;
+    }
+
+    /**
+     * Please use {@link #addJobInBackground(Job)}.
+     * <p>Non-blocking convenience method to add a job in background thread.</p>
+     *
+     * @see #addJob(int, BaseJob) addJob(priority, job).
+     */
+    @Deprecated
+    public void addJobInBackground(final int priority, final BaseJob baseJob) {
+        timedExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                addJob(priority, baseJob);
+            }
+        });
+    }
+
+    /**
+     * Deprecated, please use {@link #addJobInBackground(Job)}.
+     * <p></p>Non-blocking convenience method to add a job in background thread.</p>
+     * @see #addJob(int, long, BaseJob) addJob(priority, delay, job).
+     */
+    @Deprecated
+    public void addJobInBackground(final int priority, final long delay, final BaseJob baseJob) {
+        addJobInBackground(priority, delay, baseJob, null);
+    }
+
+    protected void addJobInBackground(final int priority, final long delay, final BaseJob baseJob,
+        /*nullable*/final AsyncAddCallback callback) {
+        final long callTime = System.nanoTime();
+        timedExecutor.execute(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    final long runDelay = (System.nanoTime() - callTime) / NS_PER_MS;
+                    long id = addJob(priority, Math.max(0, delay - runDelay), baseJob);
+                    if(callback != null) {
+                        callback.onAdded(id);
+                    }
+                } catch (Throwable t) {
+                    JqLog.e(t, "addJobInBackground received an exception. job class: %s", baseJob.getClass().getSimpleName() );
+                }
+            }
+        });
+    }
+
+
     /**
      * Default implementation of QueueFactory that creates one {@link SqliteJobQueue} and one {@link NonPersistentPriorityQueue}
      * both are wrapped inside a {@link CachedJobQueue} to improve performance
diff --git a/jobqueue/src/com/path/android/jobqueue/JobQueue.java b/jobqueue/src/com/path/android/jobqueue/JobQueue.java
index 0755505..a149a00 100644
--- a/jobqueue/src/com/path/android/jobqueue/JobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/JobQueue.java
@@ -72,4 +72,11 @@
      */
     void clear();
 
+    /**
+     * returns the job with the given id if it exists in the queue
+     * @param id id of the job, returned by insert method
+     * @return JobHolder with the given id or null if it does not exists
+     */
+    JobHolder findJobById(long id);
+
 }
diff --git a/jobqueue/src/com/path/android/jobqueue/JobStatus.java b/jobqueue/src/com/path/android/jobqueue/JobStatus.java
new file mode 100644
index 0000000..b687cc3
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/JobStatus.java
@@ -0,0 +1,36 @@
+package com.path.android.jobqueue;
+
+/**
+ * Identifies the current status of a job if it is in the queue
+ */
+public enum JobStatus {
+    /**
+     * Job is in the queue but cannot run yet.
+     * As of v 1.1, this might be:
+     * <ul>
+     *     <li>Job requires network but there is no available network connection</li>
+     *     <li>Job is delayed. We are waiting for the time to pass</li>
+     * </ul>
+     */
+    WAITING_NOT_READY,
+    /**
+     * Job is in the queue, ready to be run. Waiting for an available consumer.
+     */
+    WAITING_READY,
+    /**
+     * Job is being executed by one of the runners.
+     */
+    RUNNING,
+    /**
+     * Job is not known by job queue.
+     * <p>This might be:
+     * <ul>
+     *     <li>Invalid ID</li>
+     *     <li>Job has been completed</li>
+     *     <li>Job has failed</li>
+     *     <li>Job has just been added, about to be delivered into a queue</li>
+     * </ul>
+     * </p>
+     */
+    UNKNOWN
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/Params.java b/jobqueue/src/com/path/android/jobqueue/Params.java
new file mode 100644
index 0000000..1695d94
--- /dev/null
+++ b/jobqueue/src/com/path/android/jobqueue/Params.java
@@ -0,0 +1,119 @@
+package com.path.android.jobqueue;
+
+/**
+ * BaseJob builder object to have a more readable design.
+ * Methods can be chained to have more readable code.
+ */
+public class Params {
+    private boolean requiresNetwork = false;
+    private String groupId = null;
+    private boolean persistent = false;
+    private int priority;
+    private long delayMs;
+
+    /**
+     *
+     * @param priority higher = better
+     */
+    public Params(int priority) {
+        this.priority = priority;
+    }
+
+    /**
+     * Sets the Job as requiring network
+     * @return this
+     */
+    public Params requireNetwork() {
+        requiresNetwork = true;
+        return this;
+    }
+
+    /**
+     * Sets the group id. Jobs in the same group are guaranteed to execute sequentially.
+     * @param groupId which group this job belongs (can be null of course)
+     * @return this
+     */
+    public Params groupBy(String groupId) {
+        this.groupId = groupId;
+        return this;
+    }
+
+    /**
+     * Marks the job as persistent. Make sure your job is serializable.
+     * @return this
+     */
+    public Params persist() {
+        this.persistent = true;
+        return this;
+    }
+
+    /**
+     * Delays the job in given ms.
+     * @param delayMs .
+     * @return this
+     */
+    public Params delayInMs(long delayMs) {
+        this.delayMs = delayMs;
+        return this;
+    }
+
+    /**
+     * convenience method to set network requirement
+     * @param requiresNetwork true|false
+     * @return this
+     */
+    public Params setRequiresNetwork(boolean requiresNetwork) {
+        this.requiresNetwork = requiresNetwork;
+        return this;
+    }
+
+    /**
+     * convenience method to set group id.
+     * @param groupId
+     * @return this
+     */
+    public Params setGroupId(String groupId) {
+        this.groupId = groupId;
+        return this;
+    }
+
+    /**
+     * convenience method to set whether {@link JobManager} should persist this job or not.
+     * @param persistent true|false
+     * @return this
+     */
+    public Params setPersistent(boolean persistent) {
+        this.persistent = persistent;
+        return this;
+    }
+
+    /**
+     * convenience method to set delay
+     * @param delayMs in ms
+     * @return this
+     */
+    public Params setDelayMs(long delayMs) {
+        this.delayMs = delayMs;
+        return this;
+    }
+
+    public boolean doesRequireNetwork() {
+        return requiresNetwork;
+    }
+
+    public String getGroupId() {
+        return groupId;
+    }
+
+    public boolean isPersistent() {
+        return persistent;
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public long getDelayMs() {
+        return delayMs;
+    }
+}
diff --git a/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java b/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
index be3279a..c373c99 100644
--- a/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/cachedQueue/CachedJobQueue.java
@@ -93,6 +93,11 @@ public void clear() {
         delegate.clear();
     }
 
+    @Override
+    public JobHolder findJobById(long id) {
+        return delegate.findJobById(id);
+    }
+
     private static class Cache {
         Integer count;
         DelayUntil delayUntil;
diff --git a/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
index 2334f62..139d92c 100644
--- a/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
+++ b/jobqueue/src/com/path/android/jobqueue/executor/JobConsumerExecutor.java
@@ -6,6 +6,7 @@
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.log.JqLog;
 
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -21,7 +22,8 @@
     private final Contract contract;
     private final int keepAliveSeconds;
     private final AtomicInteger activeConsumerCount = new AtomicInteger(0);
-    private final AtomicInteger runningJobCount = new AtomicInteger(0);
+    // key : id + (isPersistent)
+    private final ConcurrentHashMap<String, JobHolder> runningJobHolders;
 
 
     public JobConsumerExecutor(Configuration config, Contract contract) {
@@ -31,6 +33,7 @@ public JobConsumerExecutor(Configuration config, Contract contract) {
         this.keepAliveSeconds = config.getConsumerKeepAlive();
         this.contract = contract;
         threadGroup = new ThreadGroup("JobConsumers");
+        runningJobHolders = new ConcurrentHashMap<String, JobHolder>();
     }
 
     /**
@@ -92,17 +95,43 @@ private boolean isAboveLoadFactor(boolean inConsumerThread) {
             int consumerCnt = activeConsumerCount.intValue() - (inConsumerThread ? 1 : 0);
             boolean res =
                     consumerCnt < minConsumerSize ||
-                    consumerCnt * loadFactor < contract.countRemainingReadyJobs() + runningJobCount.get();
+                    consumerCnt * loadFactor < contract.countRemainingReadyJobs() + runningJobHolders.size();
             if(JqLog.isDebugEnabled()) {
                 JqLog.d("%s: load factor check. %s = (%d < %d)|| (%d * %d < %d + %d). consumer thread: %s", Thread.currentThread().getName(), res,
                         consumerCnt, minConsumerSize,
-                        consumerCnt, loadFactor, contract.countRemainingReadyJobs(), runningJobCount.get(), inConsumerThread);
+                        consumerCnt, loadFactor, contract.countRemainingReadyJobs(), runningJobHolders.size(), inConsumerThread);
             }
             return res;
         }
 
     }
 
+    private void onBeforeRun(JobHolder jobHolder) {
+        runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);
+    }
+
+    private void onAfterRun(JobHolder jobHolder) {
+        runningJobHolders.remove(createRunningJobHolderKey(jobHolder));
+    }
+
+    private String createRunningJobHolderKey(JobHolder jobHolder) {
+        return createRunningJobHolderKey(jobHolder.getId(), jobHolder.getBaseJob().isPersistent());
+    }
+
+    private String createRunningJobHolderKey(long id, boolean isPersistent) {
+        return id + "_" + (isPersistent ? "t" : "f");
+    }
+
+    /**
+     * returns true if job is currently handled by one of the executor threads
+     * @param id id of the job
+     * @param persistent boolean flag to distinguish id conflicts
+     * @return true if job is currently handled here
+     */
+    public boolean isRunning(long id, boolean persistent) {
+        return runningJobHolders.containsKey(createRunningJobHolderKey(id, persistent));
+    }
+
     /**
      * contract between the {@link JobManager} and {@link JobConsumerExecutor}
      */
@@ -168,13 +197,13 @@ public void run() {
                     do {
                         nextJob = contract.isRunning() ? contract.getNextJob(executor.keepAliveSeconds, TimeUnit.SECONDS) : null;
                         if (nextJob != null) {
-                            executor.runningJobCount.incrementAndGet();
+                            executor.onBeforeRun(nextJob);
                             if (nextJob.safeRun(nextJob.getRunCount())) {
                                 contract.removeJob(nextJob);
                             } else {
                                 contract.insertOrReplace(nextJob);
                             }
-                            executor.runningJobCount.decrementAndGet();
+                            executor.onAfterRun(nextJob);
                         }
                     } while (nextJob != null);
                 } finally {
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
index 2613245..b084a0e 100644
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/JobSet.java
@@ -11,6 +11,7 @@
 public interface JobSet {
     public JobHolder peek(Collection<String> excludeGroupIds);
     public JobHolder poll(Collection<String> excludeGroupIds);
+    public JobHolder findById(long id);
     public boolean offer(JobHolder holder);
     public boolean remove(JobHolder holder);
     public void clear();
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
index f845afd..f32fd7c 100644
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/MergedQueue.java
@@ -110,31 +110,33 @@ public JobHolder poll(Collection<String> excludeGroupIds) {
      */
     @Override
     public JobHolder peek(Collection<String> excludeGroupIds) {
-        JobHolder delayed = queue0.peek(excludeGroupIds);
-        //if queue for this job has changed, re-add it and try peek from scratch
-        if(delayed != null && decideQueue(delayed) != SetId.S0) {
-            queue1.offer(delayed);
-            queue0.remove(delayed);
-            return peek(excludeGroupIds);
-        }
-        JobHolder nonDelayed = queue1.peek(excludeGroupIds);
-        //if queue for this job has changed, re-add it and try peek from scratch
-        if(nonDelayed != null && decideQueue(nonDelayed) != SetId.S1) {
-            queue0.offer(nonDelayed);
-            queue1.remove(nonDelayed);
-            return peek(excludeGroupIds);
-        }
-        if(delayed == null) {
+        while (true) {
+            JobHolder delayed = queue0.peek(excludeGroupIds);
+            //if queue for this job has changed, re-add it and try peek from scratch
+            if(delayed != null && decideQueue(delayed) != SetId.S0) {
+                queue1.offer(delayed);
+                queue0.remove(delayed);
+                continue;//retry
+            }
+            JobHolder nonDelayed = queue1.peek(excludeGroupIds);
+            //if queue for this job has changed, re-add it and try peek from scratch
+            if(nonDelayed != null && decideQueue(nonDelayed) != SetId.S1) {
+                queue0.offer(nonDelayed);
+                queue1.remove(nonDelayed);
+                continue;//retry
+            }
+            if(delayed == null) {
+                return nonDelayed;
+            }
+            if(nonDelayed == null) {
+                return delayed;
+            }
+            int cmp = retrieveComparator.compare(delayed, nonDelayed);
+            if(cmp == -1) {
+                return delayed;
+            }
             return nonDelayed;
         }
-        if(nonDelayed == null) {
-            return delayed;
-        }
-        int cmp = retrieveComparator.compare(delayed, nonDelayed);
-        if(cmp == -1) {
-            return delayed;
-        }
-        return nonDelayed;
     }
 
 
@@ -199,6 +201,19 @@ public CountWithGroupIdsResult countReadyJobs(SetId setId, Collection<String> ex
         }
     }
 
+
+
+    /**
+     * Returns the JobHolder that has the given id
+     * @param id id job the job
+     * @return
+     */
+    @Override
+    public JobHolder findById(long id) {
+        JobHolder q0 = queue0.findById(id);
+        return q0 == null ? queue1.findById(id) : q0;
+    }
+
     /**
      * simple enum to identify queues
      */
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
index c178453..aec9272 100644
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentJobSet.java
@@ -3,7 +3,13 @@
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.log.JqLog;
 
-import java.util.*;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 
 /**
  * This is the default implementation of JobSet.
@@ -11,13 +17,15 @@
  * version
  */
 public class NonPersistentJobSet implements JobSet {
-    TreeSet<JobHolder> set;
+    private final TreeSet<JobHolder> set;
     //groupId -> # of jobs in that group
-    Map<String, Integer> existingGroups;
+    private final Map<String, Integer> existingGroups;
+    private final Map<Long, JobHolder> idCache;
 
     public NonPersistentJobSet(Comparator<JobHolder> comparator) {
         this.set = new TreeSet<JobHolder>(comparator);
         this.existingGroups = new HashMap<String, Integer>();
+        this.idCache = new HashMap<Long, JobHolder>();
     }
 
     private JobHolder safeFirst() {
@@ -62,6 +70,11 @@ public JobHolder poll(Collection<String> excludeGroupIds) {
         return peek;
     }
 
+    @Override
+    public JobHolder findById(long id) {
+        return idCache.get(id);
+    }
+
     @Override
     public boolean offer(JobHolder holder) {
         if(holder.getId() == null) {
@@ -73,9 +86,13 @@ public boolean offer(JobHolder holder) {
             remove(holder);
             result = set.add(holder);
         }
-        if(result && holder.getGroupId() != null) {
-            incGroupCount(holder.getGroupId());
+        if(result) {
+            idCache.put(holder.getId(), holder);
+            if(holder.getGroupId() != null) {
+                incGroupCount(holder.getGroupId());
+            }
         }
+
         return result;
     }
 
@@ -103,8 +120,11 @@ private void decGroupCount(String groupId) {
     @Override
     public boolean remove(JobHolder holder) {
         boolean removed = set.remove(holder);
-        if(removed && holder.getGroupId() != null) {
-            decGroupCount(holder.getGroupId());
+        if(removed) {
+            idCache.remove(holder.getId());
+            if(holder.getGroupId() != null) {
+                decGroupCount(holder.getGroupId());
+            }
         }
         return removed;
     }
@@ -115,6 +135,7 @@ public boolean remove(JobHolder holder) {
     public void clear() {
         set.clear();
         existingGroups.clear();
+        idCache.clear();
     }
 
     @Override
diff --git a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
index 618d4da..627d09b 100644
--- a/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/nonPersistentQueue/NonPersistentPriorityQueue.java
@@ -91,11 +91,22 @@ public Long getNextJobDelayUntilNs(boolean hasNetwork) {
         return next == null ? null : next.getDelayUntilNs();
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public void clear() {
         jobs.clear();
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public JobHolder findJobById(long id) {
+        return jobs.findById(id);
+    }
+
     public final Comparator<JobHolder> jobComparator = new Comparator<JobHolder>() {
         @Override
         public int compare(JobHolder holder1, JobHolder holder2) {
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
index 8190d01..50e3ad7 100644
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
+++ b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqlHelper.java
@@ -8,6 +8,9 @@
  * Helper class for {@link SqliteJobQueue} to generate sql queries and statements.
  */
 public class SqlHelper {
+
+    /**package**/ String FIND_BY_ID_QUERY;
+
     private SQLiteStatement insertStatement;
     private SQLiteStatement insertOrReplaceStatement;
     private SQLiteStatement deleteStatement;
@@ -16,6 +19,7 @@
     private SQLiteStatement nextJobDelayedUntilWithNetworkStatement;
     private SQLiteStatement nextJobDelayedUntilWithoutNetworkStatement;
 
+
     final SQLiteDatabase db;
     final String tableName;
     final String primaryKeyColumnName;
@@ -28,6 +32,7 @@ public SqlHelper(SQLiteDatabase db, String tableName, String primaryKeyColumnNam
         this.columnCount = columnCount;
         this.primaryKeyColumnName = primaryKeyColumnName;
         this.sessionId = sessionId;
+        FIND_BY_ID_QUERY = "SELECT * FROM " + tableName + " WHERE " + DbOpenHelper.ID_COLUMN.columnName + " = ?";
     }
 
     public static String create(String tableName, Property primaryKey, Property... properties) {
@@ -162,6 +167,11 @@ public void vacuum() {
         db.execSQL("VACUUM");
     }
 
+    public void resetDelayTimesTo(long newDelayTime) {
+        db.execSQL("UPDATE " + DbOpenHelper.JOB_HOLDER_TABLE_NAME + " SET " + DbOpenHelper.DELAY_UNTIL_NS_COLUMN.columnName + "=?"
+            , new Object[]{newDelayTime});
+    }
+
     public static class Property {
         /*package*/ final String columnName;
         /*package*/ final String type;
diff --git a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
index 4c65420..eefc667 100644
--- a/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
+++ b/jobqueue/src/com/path/android/jobqueue/persistentQueue/sqlite/SqliteJobQueue.java
@@ -44,6 +44,7 @@ public SqliteJobQueue(Context context, long sessionId, String id, JobSerializer
         this.jobSerializer = jobSerializer;
         readyJobsQueryCache = new QueryCache();
         nextJobsQueryCache = new QueryCache();
+        sqlHelper.resetDelayTimesTo(JobManager.NOT_DELAYED_JOB_DELAY);
     }
 
     /**
@@ -158,6 +159,25 @@ public int countReadyJobs(boolean hasNetwork, Collection<String> excludeGroups)
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public JobHolder findJobById(long id) {
+        Cursor cursor = db.rawQuery(sqlHelper.FIND_BY_ID_QUERY, new String[]{Long.toString(id)});
+        try {
+            if(!cursor.moveToFirst()) {
+                return null;
+            }
+            return createJobHolderFromCursor(cursor);
+        } catch (InvalidBaseJobException e) {
+            JqLog.e(e, "invalid job on findJobById");
+            return null;
+        } finally {
+            cursor.close();
+        }
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -245,6 +265,9 @@ public Long getNextJobDelayUntilNs(boolean hasNetwork) {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public void clear() {
         sqlHelper.truncate();
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
index f9419e0..454d3c5 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddInBackgroundTest.java
@@ -1,7 +1,14 @@
 package com.path.android.jobqueue.test.jobmanager;
 
+import com.path.android.jobqueue.AsyncAddCallback;
 import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
+import org.fest.reflect.core.*;
 import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -13,16 +20,20 @@
 @RunWith(RobolectricTestRunner.class)
 public class AddInBackgroundTest extends JobManagerTestBase {
     @Test
-    public void testAddInBackground() {
-        addInBackground(false);
-        addInBackground(true);
-
+    public void testAddInBackground() throws InterruptedException {
+        for(boolean delay : new boolean[]{true, false}) {
+            for(boolean useCallback : new boolean[]{true, false}) {
+                addInBackground(delay, useCallback);
+            }
+        }
     }
-    public void addInBackground(boolean delayed) {
+
+    public void addInBackground(boolean delayed, boolean useCallback) throws InterruptedException {
         long currentThreadId = Thread.currentThread().getId();
         final AtomicLong onAddedThreadId = new AtomicLong();
         final CountDownLatch addedLatch = new CountDownLatch(2);
-        BaseJob dummyJob = new DummyJob() {
+
+        Job dummyJob = new DummyJob(new Params(1).setDelayMs(delayed ? 1000 : 0)) {
             @Override
             public void onAdded() {
                 super.onAdded();
@@ -30,13 +41,33 @@ public void onAdded() {
                 addedLatch.countDown();
             }
         };
-        if(delayed) {
-            createJobManager().addJobInBackground(1, 1000, dummyJob);
+        JobManager jobManager = createJobManager();
+        jobManager.stop();
+        final AtomicLong jobId = new AtomicLong(0);
+        if(useCallback) {
+            jobManager.addJobInBackground(dummyJob, new AsyncAddCallback() {
+                @Override
+                public void onAdded(long id) {
+                    jobId.set(id);
+                    addedLatch.countDown();
+                }
+            });
         } else {
-            createJobManager().addJobInBackground(1, dummyJob);
+            addedLatch.countDown();
+            jobManager.addJobInBackground(dummyJob);
         }
-
-        addedLatch.countDown();
+        addedLatch.await();
         MatcherAssert.assertThat("thread ids should be different. delayed:" + delayed, currentThreadId, CoreMatchers.not(onAddedThreadId.get()));
+        if(useCallback) {
+            JobQueue queue = getNonPersistentQueue(jobManager);
+            JobHolder holder = queue.findJobById(jobId.longValue());
+            MatcherAssert.assertThat("there should be a job in the holder. id:" + jobId.longValue() +", delayed:" + delayed + ", use cb:" + useCallback
+                    , holder, CoreMatchers.notNullValue());
+            MatcherAssert.assertThat("id callback should have the proper id:", holder.getBaseJob(), CoreMatchers.is((BaseJob) dummyJob));
+        }
+    }
+
+    protected JobQueue getNonPersistentQueue(JobManager jobManager) {
+        return Reflection.field("nonPersistentJobQueue").ofType(JobQueue.class).in(jobManager).get();
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
index 8a68b6b..327ea69 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/AddedCountTest.java
@@ -1,8 +1,8 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
 import org.hamcrest.MatcherAssert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,15 +14,15 @@
 public class AddedCountTest extends JobManagerTestBase {
     @Test
     public void testAddedCount() throws Exception {
-        testAddedCount(new DummyJob());
-        testAddedCount(new PersistentDummyJob());
+        testAddedCount(new DummyJob(new Params(0)));
+        testAddedCount(new DummyJob(new Params(0).persist()));
 
     }
 
     private void testAddedCount(DummyJob dummyJob) {
         JobManager jobManager = createJobManager();
         jobManager.stop();
-        jobManager.addJob(0, dummyJob);
+        jobManager.addJob(dummyJob);
         MatcherAssert.assertThat(1, equalTo(dummyJob.getOnAddedCnt()));
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java
index 9bbdfc4..89f2e81 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ClearTest.java
@@ -1,14 +1,13 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.hamcrest.MatcherAssert;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class ClearTest extends JobManagerTestBase {
@@ -17,11 +16,7 @@ public void testClear() throws Exception {
         JobManager jobManager = createJobManager();
         final int LIMIT = 20;
         for(int i = 0; i < LIMIT; i++) {
-            if(i % 2 == 0) {
-                jobManager.addJob(0, new DummyJob());
-            } else {
-                jobManager.addJob(0, new PersistentDummyJob());
-            }
+            jobManager.addJob(new DummyJob(new Params(0).setPersistent(i % 2 == 1)));
         }
         jobManager.clear();
         MatcherAssert.assertThat("after clear, count should be 0", jobManager.count(), equalTo(0));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
index a7f59aa..5fb1537 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/ConsumerCountTest.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
@@ -27,9 +28,9 @@ public void testMaxConsumerCount() throws Exception {
         int totalJobCount = maxConsumerCount * 3;
         List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
         for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(runLock, semaphore);
+            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
             runningJobs.add(job);
-            jobManager.addJob((int)(Math.random() * 3), job);
+            jobManager.addJob(job);
         }
         //wait till enough jobs start
         long now = System.nanoTime();
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java
index 744ae4e..26a2604 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/CountTest.java
@@ -1,14 +1,13 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.hamcrest.MatcherAssert;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class CountTest extends JobManagerTestBase {
@@ -17,9 +16,9 @@ public void testCount() throws Exception {
         JobManager jobManager = createJobManager();
         jobManager.stop();
         for (int i = 0; i < 10; i++) {
-            jobManager.addJob(0, new PersistentDummyJob());
+            jobManager.addJob(new DummyJob(new Params(0).persist()));
             MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 1));
-            jobManager.addJob(0, new PersistentDummyJob());
+            jobManager.addJob(new DummyJob(new Params(0).persist()));
             MatcherAssert.assertThat((int) jobManager.count(), equalTo(i * 2 + 2));
         }
         jobManager.start();
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java
index 4868986..6d0139e 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayTest.java
@@ -3,17 +3,14 @@
 
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.fest.reflect.method.Invoker;
-import org.hamcrest.MatcherAssert;
+import org.fest.reflect.method.*;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.notNullValue;
-import static org.hamcrest.CoreMatchers.nullValue;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class DelayTest extends JobManagerTestBase {
@@ -26,10 +23,10 @@ public void testDelay() throws Exception {
     public void testDelay(boolean persist) throws Exception {
         JobManager jobManager = createJobManager();
         jobManager.stop();
-        DummyJob delayedJob = persist ? new PersistentDummyJob() : new DummyJob();
-        DummyJob nonDelayedJob = persist ? new PersistentDummyJob() : new DummyJob();
-        long jobId = jobManager.addJob(10, 1000, delayedJob);
-        long nonDelayedJobId = jobManager.addJob(0, 0, nonDelayedJob);
+        DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(1000).setPersistent(persist));
+        DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
+        long jobId = jobManager.addJob(delayedJob);
+        long nonDelayedJobId = jobManager.addJob(nonDelayedJob);
 
         Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
         Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
index c1f4d4c..f2d93e4 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/DelayedRunTest.java
@@ -1,14 +1,13 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.hamcrest.MatcherAssert;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class DelayedRunTest extends JobManagerTestBase {
@@ -21,10 +20,10 @@ public void testDelayedRun() throws Exception {
     }
     public void testDelayedRun(boolean persist, boolean tryToStop) throws Exception {
         JobManager jobManager = createJobManager();
-        DummyJob delayedJob = persist ? new PersistentDummyJob() : new DummyJob();
-        DummyJob nonDelayedJob = persist ? new PersistentDummyJob() : new DummyJob();
-        jobManager.addJob(10, 2000, delayedJob);
-        jobManager.addJob(0, 0, nonDelayedJob);
+        DummyJob delayedJob = new DummyJob(new Params(10).delayInMs(2000).setPersistent(persist));
+        DummyJob nonDelayedJob = new DummyJob(new Params(0).setPersistent(persist));
+        jobManager.addJob(delayedJob);
+        jobManager.addJob(nonDelayedJob);
         Thread.sleep(500);
         MatcherAssert.assertThat("there should be 1 delayed job waiting to be run", jobManager.count(), equalTo(1));
         if(tryToStop) {//see issue #11
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
index 8b2c94d..0739d3c 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/GroupingTest.java
@@ -2,17 +2,18 @@
 
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.fest.reflect.method.Invoker;
-import org.hamcrest.MatcherAssert;
+import org.fest.reflect.method.*;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.*;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.nullValue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
 @RunWith(RobolectricTestRunner.class)
 public class GroupingTest extends JobManagerTestBase {
@@ -23,10 +24,10 @@ public void testGrouping() throws Exception {
         Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
         Invoker<Void> removeJobMethod = getRemoveJobMethod(jobManager);
 
-        long jobId1 = jobManager.addJob(0, new DummyJob("group1"));
-        long jobId2 = jobManager.addJob(0, new DummyJob("group1"));
-        long jobId3 = jobManager.addJob(0, new PersistentDummyJob("group2"));
-        long jobId4 = jobManager.addJob(0, new PersistentDummyJob("group1"));
+        long jobId1 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
+        long jobId2 = jobManager.addJob(new DummyJob(new Params(0).groupBy("group1")));
+        long jobId3 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group2")));
+        long jobId4 = jobManager.addJob(new DummyJob(new Params(0).persist().groupBy("group1")));
         JobHolder nextJob = nextJobMethod.invoke();
         MatcherAssert.assertThat("next job should be the first job from group1", nextJob.getId(), equalTo(jobId1));
         JobHolder group2Job = nextJobMethod.invoke();
@@ -38,4 +39,68 @@ public void testGrouping() throws Exception {
         removeJobMethod.invoke(group2Job);
         MatcherAssert.assertThat("even after group2 job is complete, no jobs should be returned since we only have group1 jobs left", nextJobMethod.invoke(), is(nullValue()));
     }
+
+    @Test
+    public void testGroupingRaceCondition() throws Exception {
+        DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
+        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application)
+                .minConsumerCount(5).maxConsumerCount(10)
+                .networkUtil(dummyNetworkUtil));
+        dummyNetworkUtil.setHasNetwork(false, true);
+        //add a bunch of network requring jobs
+        final String GROUP_ID = "shared_group_id";
+        final int AFTER_ADDED_JOBS_COUNT = 5;
+        final int NOT_SET_JOB_ID = -1;
+        final AtomicInteger firstRunJob = new AtomicInteger(NOT_SET_JOB_ID);
+        final int FIRST_JOB_ID = -10;
+        final CountDownLatch onAddedCalled = new CountDownLatch(1);
+        final CountDownLatch remainingJobsOnAddedCalled = new CountDownLatch(AFTER_ADDED_JOBS_COUNT);
+        jobManager.addJobInBackground(new DummyJob(new Params(10).requireNetwork().groupBy(GROUP_ID)) {
+            @Override
+            public void onAdded() {
+                super.onAdded();
+                onAddedCalled.countDown();
+                try {
+                    //wait until all other jobs are added
+                    remainingJobsOnAddedCalled.await();
+                    //wait a bit after all are added,
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                }
+            }
+
+            @Override
+            public void onRun() throws Throwable {
+                super.onRun();
+                firstRunJob.compareAndSet(NOT_SET_JOB_ID, FIRST_JOB_ID);
+            }
+        });
+        //ensure first jobs on added is called
+        onAddedCalled.await();
+        for(int i = 0; i < AFTER_ADDED_JOBS_COUNT; i ++) {
+            final int finalI = i;
+            jobManager.addJob(new DummyJob(new Params(5).groupBy(GROUP_ID).requireNetwork()) {
+                final int id = finalI + 1;
+
+                @Override
+                public void onAdded() {
+                    super.onAdded();
+                    remainingJobsOnAddedCalled.countDown();
+                }
+
+                @Override
+                public void onRun() throws Throwable {
+                    super.onRun();
+                    firstRunJob.compareAndSet(NOT_SET_JOB_ID, id);
+                }
+            });
+        }
+        dummyNetworkUtil.setHasNetwork(true, true);
+        //wait until all jobs are completed
+        while(firstRunJob.get() == NOT_SET_JOB_ID) {
+            Thread.sleep(100);
+        }
+        MatcherAssert.assertThat("highest priority job should run if it is added before others", firstRunJob.get(), is(FIRST_JOB_ID));
+
+    }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
index ee3c529..7129710 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/InjectorTest.java
@@ -3,16 +3,19 @@
 import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.di.DependencyInjector;
+import com.path.android.jobqueue.log.CustomLogger;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
 
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 @RunWith(RobolectricTestRunner.class)
@@ -32,9 +35,9 @@ public void inject(BaseJob job) {
         builder.injector(dependencyInjector);
         JobManager jobManager = createJobManager(builder);
         jobManager.stop();
-        jobManager.addJob(4, new DummyJob());
+        jobManager.addJob(new DummyJob(new Params(4)));
         MatcherAssert.assertThat("injection should be called after adding a non-persistent job", injectionCallCount.get(), equalTo(1));
-        jobManager.addJob(1, new PersistentDummyJob());
+        jobManager.addJob(new DummyJob(new Params(1).persist()));
         MatcherAssert.assertThat("injection should be called after adding a persistent job", injectionCallCount.get(), equalTo(2));
         JobHolder holder = getNextJobMethod(jobManager).invoke();
         MatcherAssert.assertThat("injection should NOT be called for non persistent job", holder.getBaseJob(), not(injectedJobReference.getObject()));
@@ -42,6 +45,55 @@ public void inject(BaseJob job) {
         holder = getNextJobMethod(jobManager).invoke();
         MatcherAssert.assertThat("injection should be called for persistent job", holder.getBaseJob(), equalTo(injectedJobReference.getObject()));
         MatcherAssert.assertThat("injection should be called two times for persistent job", injectionCallCount.get(), equalTo(3));
+    }
+
+    @Test
+    public void testInjectorCrash() throws Exception {
+        final String EXCEPTION_MESSAGE = "could not inject for whatever reason :)";
+        DependencyInjector dummyDependencyInjector = new DependencyInjector() {
+            @Override
+            public void inject(BaseJob baseJob) {
+                throw new RuntimeException(EXCEPTION_MESSAGE);
+            }
+        };
+
+        final ObjectReference objectReference = new ObjectReference();
+        final CountDownLatch exceptionLatch = new CountDownLatch(1);
+        CustomLogger customLogger = new CustomLogger() {
+            @Override
+            public boolean isDebugEnabled() {
+                return false;
+            }
+
+            @Override
+            public void d(String s, Object... objects) {
+
+            }
+
+            @Override
+            public void e(Throwable throwable, String s, Object... objects) {
+                objectReference.setObject(throwable);
+                exceptionLatch.countDown();
+            }
+
+            @Override
+            public void e(String s, Object... objects) {
+                //
+            }
+        };
+        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).injector(dummyDependencyInjector).customLogger(customLogger));
+        Throwable addException = null;
+        try {
+            jobManager.addJob(new DummyJob(new Params(0)));
+        } catch (Throwable t) {
+            addException = t;
+        }
+        MatcherAssert.assertThat("addJob should throw exception if dependency injector throws exception", addException, notNullValue());
+        jobManager.addJobInBackground(new DummyJob(new Params(0)));
+        exceptionLatch.await(2, TimeUnit.SECONDS);
+        MatcherAssert.assertThat("there should be a received exception", objectReference.getObject(), notNullValue());
+        MatcherAssert.assertThat("logged exception should be a runtime exception", objectReference.getObject(), instanceOf(RuntimeException.class));
+        MatcherAssert.assertThat("logged exception should have expected message", ((Throwable)objectReference.getObject()).getMessage(), is(EXCEPTION_MESSAGE));
 
     }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
index 144c267..d416b76 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.executor.JobConsumerExecutor;
 import com.path.android.jobqueue.network.NetworkEventProvider;
@@ -31,10 +32,36 @@ protected JobManager createJobManager(Configuration.Builder configurationBuilder
 
 
 
+    protected static class DummyTwoLatchJob extends DummyJob {
+        private final CountDownLatch waitFor;
+        private final CountDownLatch trigger;
+        private final CountDownLatch onRunLatch;
+
+        protected DummyTwoLatchJob(Params params, CountDownLatch waitFor, CountDownLatch trigger) {
+            super(params);
+            this.waitFor = waitFor;
+            this.trigger = trigger;
+            onRunLatch = new CountDownLatch(1);
+        }
+
+        public void waitTillOnRun() throws InterruptedException {
+            onRunLatch.await();
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+            onRunLatch.countDown();
+            waitFor.await();
+            super.onRun();
+            trigger.countDown();
+        }
+    }
+
     protected static class DummyLatchJob extends DummyJob {
         private final CountDownLatch latch;
 
-        protected DummyLatchJob(CountDownLatch latch) {
+        protected DummyLatchJob(Params params, CountDownLatch latch) {
+            super(params);
             this.latch = latch;
         }
 
@@ -49,7 +76,7 @@ public void onRun() throws Throwable {
     protected static class DummyJobWithRunCount extends DummyJob {
         public static int runCount;
         protected DummyJobWithRunCount(boolean persistent) {
-            super(false, persistent);
+            super(new Params(0).setPersistent(persistent));
         }
 
         @Override
@@ -106,6 +133,10 @@ public boolean isConnected(Context context) {
         public void setListener(Listener listener) {
             this.listener = listener;
         }
+
+        public boolean isConnected() {
+            return hasNetwork;
+        }
     }
 
     protected static class ObjectReference {
@@ -139,7 +170,8 @@ protected JobConsumerExecutor getConsumerExecutor(JobManager jobManager) {
     public static class NeverEndingDummyJob extends DummyJob {
         final Object lock;
         final Semaphore semaphore;
-        public NeverEndingDummyJob(Object lock, Semaphore semaphore) {
+        public NeverEndingDummyJob(Params params, Object lock, Semaphore semaphore) {
+            super(params);
             this.lock = lock;
             this.semaphore = semaphore;
         }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
new file mode 100644
index 0000000..28656ba
--- /dev/null
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
@@ -0,0 +1,119 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.JobStatus;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.config.Configuration;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+@RunWith(RobolectricTestRunner.class)
+public class JobStatusTest extends JobManagerTestBase {
+    @Test
+    public void testJobStatus() throws InterruptedException {
+        DummyNetworkUtilWithConnectivityEventSupport networkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
+        networkUtil.setHasNetwork(false, true);
+        JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(networkUtil));
+        jobManager.stop();
+        List<Integer> networkRequiringJobIndices = new ArrayList<Integer>();
+        Job[] jobs = new Job[] {
+                new DummyJob(new Params(0)),
+                new DummyJob(new Params(0).persist()),
+                new DummyJob(new Params(0).persist().requireNetwork())
+        };
+        long[] ids = new long[jobs.length];
+        for(int i = 0; i < jobs.length; i ++) {
+            ids[i] = jobManager.addJob(jobs[i]);
+            if(jobs[i].requiresNetwork()) {
+                networkRequiringJobIndices.add(i);
+            }
+            JobStatus expectedStatus = (networkUtil.isConnected() || jobs[i].requiresNetwork() == false) ? JobStatus.WAITING_READY :
+                    JobStatus.WAITING_NOT_READY;
+            assertThat("job should have correct status after being added",
+                    jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(expectedStatus));
+        }
+
+        //create an unknown id, ensure status for that
+
+        boolean exists;
+        long unknownId;
+        do {
+            unknownId = (long) (Math.random() * 10000 - 5000);
+            exists = false;
+            for(long id : ids) {
+                if(id == unknownId) {
+                    exists = true;
+                    continue;
+                }
+            }
+        } while (exists);
+        for(boolean persistent : new boolean[]{true, false}) {
+            assertThat("job with unknown id should return as expected", jobManager.getJobStatus(unknownId, persistent), is(JobStatus.UNKNOWN));
+        }
+
+        CountDownLatch startLatch = new CountDownLatch(1), endLatch = new CountDownLatch(1);
+        DummyTwoLatchJob twoLatchJob = new DummyTwoLatchJob(new Params(0), startLatch, endLatch);
+        jobManager.start();
+        long jobId = jobManager.addJob(twoLatchJob);
+        twoLatchJob.waitTillOnRun();
+        assertThat("job should be in running state", jobManager.getJobStatus(jobId, false), is(JobStatus.RUNNING));
+        startLatch.countDown();//let it run
+        endLatch.await();//wait till it finishes
+        Thread.sleep(500);//give some time to job manager to clear the job
+        assertThat("finished job should go to unknown state", jobManager.getJobStatus(jobId, false), is(JobStatus.UNKNOWN));
+
+        //network requiring job should not be ready
+        for(Integer i : networkRequiringJobIndices) {
+            assertThat("network requiring job should still be not-ready", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+        }
+        jobManager.stop();
+        networkUtil.setHasNetwork(true, true);
+        for(Integer i : networkRequiringJobIndices) {
+            assertThat("network requiring job should still be ready after network is there", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.WAITING_READY));
+        }
+
+        jobManager.start();
+        int limit = 10;
+        while (jobManager.count() > 0 && limit--  > 0) {
+            Thread.sleep(1000);
+        }
+        assertThat("jobs should finish", jobManager.count(), is(0));
+        for(int i = 0; i < jobs.length; i ++) {
+            //after all jobs finish, state should be unknown
+            assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.UNKNOWN));
+        }
+        final long SHORT_SLEEP = 1000;
+        Job[] delayedJobs = new Job[]{
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
+                new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
+        long[] delayedIds = new long[delayedJobs.length];
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            delayedIds[i] = jobManager.addJob(delayedJobs[i]);
+        }
+
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            assertThat("delayed job(" + i + ") should receive not ready status", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+        }
+        jobManager.stop();
+        //sleep
+        Thread.sleep(SHORT_SLEEP * 2);
+        for(int i = 0; i < delayedJobs.length; i ++) {
+            if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
+                assertThat("when enough time passes, delayed jobs should move to ready state", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_READY));
+            } else {
+                assertThat("delayed job should receive not ready status until their time comes", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+            }
+        }
+    }
+}
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
index 26f2637..fcdc80d 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/KeepAliveTest.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
@@ -25,8 +26,8 @@ public void testKeepAlive() throws Exception {
                 .consumerKeepAlive(keepAlive)
                 .networkUtil(networkUtilWithEventSupport));
         //give it a little time to create first consumer
-        jobManager1.addJob(0, new DummyJob());
-        jobManager2.addJob(0, new DummyJob());
+        jobManager1.addJob(new DummyJob(new Params(0)));
+        jobManager2.addJob(new DummyJob(new Params(0)));
         AtomicInteger activeThreadCount1 = getActiveConsumerCount(getConsumerExecutor(jobManager1)).get();
         AtomicInteger activeThreadCount2 = getActiveConsumerCount(getConsumerExecutor(jobManager2)).get();
 
@@ -46,8 +47,8 @@ public void testKeepAlive() throws Exception {
         //disable network and add a network bound job
         networkUtilWithoutEventSupport.setHasNetwork(false);
         networkUtilWithEventSupport.setHasNetwork(false, true);
-        jobManager1.addJob(0, new DummyJob(true, false));
-        jobManager2.addJob(0, new DummyJob(true, false));
+        jobManager1.addJob(new DummyJob(new Params(0).requireNetwork()));
+        jobManager2.addJob(new DummyJob(new Params(0).requireNetwork()));
         Thread.sleep(1000 + (long) (TimeUnit.SECONDS.toMillis(keepAlive) * 2));
         MatcherAssert.assertThat("when network changes cannot be detected, there should be a consumer waiting alive",
                 activeThreadCount1.get(), equalTo(1));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
index 7e2d933..f713c47 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/LoadFactorTest.java
@@ -1,5 +1,6 @@
 package com.path.android.jobqueue.test.jobmanager;
 
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.executor.JobConsumerExecutor;
 import com.path.android.jobqueue.log.CustomLogger;
@@ -41,9 +42,9 @@ public void testLoadFactor() throws Exception {
         int totalJobCount = loadFactor * maxConsumerCount * 5;
         List<DummyJob> runningJobs = new ArrayList<DummyJob>(totalJobCount);
         for(int i = 0; i < totalJobCount; i ++) {
-            DummyJob job = new NeverEndingDummyJob(runLock, semaphore);
+            DummyJob job = new NeverEndingDummyJob(new Params((int)(Math.random() * 3)), runLock, semaphore);
             runningJobs.add(job);
-            jobManager.addJob((int)(Math.random() * 3), job);
+            jobManager.addJob(job);
 
             int expectedConsumerCount = Math.min(maxConsumerCount, (int)Math.ceil((float)(i+1) / loadFactor));
             if(i >= minConsumerCount) {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
index 7cd476f..bbfcbed 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
@@ -2,6 +2,7 @@
 
 import android.util.Log;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import static org.hamcrest.CoreMatchers.*;
@@ -39,7 +40,7 @@ public void run() {
                     boolean requiresNetwork = Math.round(Math.random()) % 2 == 0;
                     int priority = (int) (Math.round(Math.random()) % 10);
                     multiThreadedJobCounter.incrementAndGet();
-                    jobManager.addJob(priority, new DummyJobForMultiThread(id, requiresNetwork, persistent));
+                    jobManager.addJob(new DummyJobForMultiThread(id, new Params(priority).setRequiresNetwork(requiresNetwork).setPersistent(persistent)));
                 }
             }));
         }
@@ -64,8 +65,8 @@ public void run() {
     }
     public static class DummyJobForMultiThread extends DummyJob {
         private int id;
-        private DummyJobForMultiThread(int id, boolean requiresNetwork, boolean persist) {
-            super(requiresNetwork, persist);
+        private DummyJobForMultiThread(int id, Params params) {
+            super(params);
             this.id = id;
         }
 
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
index e9a1630..15e9819 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobTest.java
@@ -1,16 +1,15 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.hamcrest.MatcherAssert;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.*;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-
 @RunWith(RobolectricTestRunner.class)
 public class NetworkJobTest extends JobManagerTestBase {
     @Test
@@ -19,17 +18,17 @@ public void testNetworkJob() throws Exception {
         JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
         jobManager.stop();
 
-        DummyJob networkDummyJob = new DummyJob(true, false);
-        jobManager.addJob(5, networkDummyJob);
+        DummyJob networkDummyJob = new DummyJob(new Params(5).requireNetwork());
+        jobManager.addJob(networkDummyJob);
 
-        DummyJob noNetworkDummyJob = new DummyJob(false, false);
-        jobManager.addJob(2, noNetworkDummyJob);
+        DummyJob noNetworkDummyJob = new DummyJob(new Params(2));
+        jobManager.addJob(noNetworkDummyJob);
 
-        PersistentDummyJob networkPersistentJob = new PersistentDummyJob(true);
-        jobManager.addJob(6, networkPersistentJob);
+        DummyJob networkPersistentJob = new DummyJob(new Params(6).persist().requireNetwork());
+        jobManager.addJob(networkPersistentJob);
 
-        PersistentDummyJob noNetworkPersistentJob = new PersistentDummyJob(false);
-        jobManager.addJob(1, noNetworkPersistentJob);
+        DummyJob noNetworkPersistentJob = new DummyJob(new Params(1).persist());
+        jobManager.addJob(noNetworkPersistentJob);
 
         MatcherAssert.assertThat("count should be correct if there are network and non-network jobs w/o network", jobManager.count(), equalTo(4));
         dummyNetworkUtil.setHasNetwork(true);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
index e703db8..d275718 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkJobWithConnectivityListenerTest.java
@@ -1,6 +1,7 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import org.hamcrest.MatcherAssert;
@@ -17,8 +18,8 @@ public void testNetworkJobWithConnectivityListener() throws Exception {
         DummyNetworkUtilWithConnectivityEventSupport dummyNetworkUtil = new DummyNetworkUtilWithConnectivityEventSupport();
         JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
         dummyNetworkUtil.setHasNetwork(false, true);
-        DummyJob dummyJob = new DummyJob(true, false);
-        long dummyJobId = jobManager.addJob(0, dummyJob);
+        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
+        long dummyJobId = jobManager.addJob(dummyJob);
         Thread.sleep(2000);//sleep a while so that consumers die. they should die since we are using a network util
         //with event support
         MatcherAssert.assertThat("count should be 1 as no jobs should be consumed w/o network", jobManager.count(), equalTo(1));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
index d366597..f07f629 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/NetworkNextJobTest.java
@@ -2,6 +2,7 @@
 
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.test.jobs.DummyJob;
 import org.fest.reflect.method.Invoker;
@@ -21,8 +22,8 @@ public void testNetworkNextJob() throws Exception {
         DummyNetworkUtil dummyNetworkUtil = new DummyNetworkUtil();
         JobManager jobManager = createJobManager(new Configuration.Builder(Robolectric.application).networkUtil(dummyNetworkUtil));
         jobManager.stop();
-        DummyJob dummyJob = new DummyJob(true, false);
-        long dummyJobId = jobManager.addJob(0, dummyJob);
+        DummyJob dummyJob = new DummyJob(new Params(0).requireNetwork());
+        long dummyJobId = jobManager.addJob(dummyJob);
         dummyNetworkUtil.setHasNetwork(false);
         Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
         MatcherAssert.assertThat("when there isn't any network, next job should return null", nextJobMethod.invoke(), nullValue());
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
index a5e6b2e..2e1b721 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/PersistentJobTest.java
@@ -1,17 +1,17 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.hamcrest.MatcherAssert;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.*;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-
 @RunWith(RobolectricTestRunner.class)
 public class PersistentJobTest extends JobManagerTestBase {
     //TEST parallel running
@@ -25,7 +25,11 @@ public void testPersistentJob() throws Exception {
         MatcherAssert.assertThat((int) persistentRunLatch.getCount(), equalTo(0));
     }
 
-    protected static class DummyPersistentLatchJob extends PersistentDummyJob {
+    protected static class DummyPersistentLatchJob extends DummyJob {
+
+        public DummyPersistentLatchJob() {
+            super(new Params(0).persist());
+        }
 
         @Override
         public void onRun() throws Throwable {
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
index eda7644..0828286 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/RunManyNonPersistentTest.java
@@ -1,16 +1,16 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 import com.path.android.jobqueue.JobManager;
-import org.hamcrest.MatcherAssert;
+import com.path.android.jobqueue.Params;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.*;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-
 @RunWith(RobolectricTestRunner.class)
 public class RunManyNonPersistentTest extends JobManagerTestBase {
     @Test
@@ -20,7 +20,7 @@ public void runManyNonPersistentJobs() throws Exception {
         int limit = 2;
         final CountDownLatch latch = new CountDownLatch(limit);
         for (int i = 0; i < limit; i++) {
-            jobManager.addJob(i, new DummyLatchJob(latch));
+            jobManager.addJob(new DummyLatchJob(new Params(i), latch));
         }
         jobManager.start();
         latch.await(10, TimeUnit.SECONDS);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
index 02caf07..35e9aae 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SessionIdTest.java
@@ -1,19 +1,18 @@
 package com.path.android.jobqueue.test.jobmanager;
 
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
-import org.fest.reflect.core.Reflection;
-import org.fest.reflect.method.Invoker;
-import org.hamcrest.MatcherAssert;
+import org.fest.reflect.core.*;
+import org.fest.reflect.method.*;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-
-import static org.hamcrest.CoreMatchers.equalTo;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class SessionIdTest extends JobManagerTestBase {
@@ -23,9 +22,9 @@ public void testSessionId() throws Exception {
         Long sessionId = Reflection.field("sessionId").ofType(long.class)
                 .in(jobManager).get();
         jobManager.stop();
-        BaseJob[] jobs = new BaseJob[]{new DummyJob(), new PersistentDummyJob()};
-        for (BaseJob job : jobs) {
-            jobManager.addJob(0, job);
+        Job[] jobs = new Job[]{new DummyJob(new Params(0)), new DummyJob(new Params(0).persist())};
+        for (Job job : jobs) {
+            jobManager.addJob(job);
         }
 
         Invoker<JobHolder> nextJobMethod = getNextJobMethod(jobManager);
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
index 26e62ca..fda6e29 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobmanager/SlowOnAddedTest.java
@@ -1,9 +1,9 @@
 package com.path.android.jobqueue.test.jobmanager;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
 import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
 import static org.hamcrest.CoreMatchers.*;
 import static org.hamcrest.MatcherAssert.*;
 import org.junit.Test;
@@ -18,11 +18,11 @@
     public void testNonPersistent() throws InterruptedException {
         JobManager jobManager = createJobManager();
         CountDownLatch runLatch = new CountDownLatch(1);
-        MyDummyJob job = new MyDummyJob(runLatch);
+        MyDummyJob job = new MyDummyJob(new Params(2), runLatch);
         for(int i = 0; i < 50; i++) {
-            jobManager.addJob(1, new DummyJob());
+            jobManager.addJob(new DummyJob(new Params(1)));
         }
-        jobManager.addJob(2, job);
+        jobManager.addJob(job);
         runLatch.await();
         assertThat("on added should be called before on run", job.onAddedCntWhenRun, equalTo(1));
     }
@@ -32,21 +32,21 @@ public void testPersistent() throws InterruptedException {
         JobManager jobManager = createJobManager();
         MyDummyPersistentJob.persistentJobLatch = new CountDownLatch(1);
         for(int i = 0; i < 50; i++) {
-            jobManager.addJob(1, new PersistentDummyJob());
+            jobManager.addJob(new DummyJob(new Params(1).persist()));
         }
-        jobManager.addJob(2, new MyDummyPersistentJob());
+        jobManager.addJob(new MyDummyPersistentJob(2));
         MyDummyPersistentJob.persistentJobLatch.await();
         assertThat("even if job is persistent, onAdded should be called b4 onRun",
                 MyDummyPersistentJob.onAddedCountWhenOnRun, equalTo(1));
     }
 
-    public static class MyDummyPersistentJob extends BaseJob {
+    public static class MyDummyPersistentJob extends Job {
         private static CountDownLatch persistentJobLatch;
         private static int persistentOnAdded = 0;
         private static int onAddedCountWhenOnRun = -1;
 
-        protected MyDummyPersistentJob() {
-            super(false, true);
+        protected MyDummyPersistentJob(int priority) {
+            super(new Params(priority).persist());
         }
 
         @Override
@@ -79,8 +79,8 @@ protected boolean shouldReRunOnThrowable(Throwable throwable) {
     private static class MyDummyJob extends DummyLatchJob {
         int onAddedCntWhenRun = -1;
 
-        protected MyDummyJob(CountDownLatch latch) {
-            super(latch);
+        protected MyDummyJob(Params params, CountDownLatch latch) {
+            super(params, latch);
         }
 
         @Override
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
new file mode 100644
index 0000000..fb60538
--- /dev/null
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobParamsTest.java
@@ -0,0 +1,27 @@
+package com.path.android.jobqueue.test.jobqueue;
+
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.test.TestBase;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.*;
+
+@RunWith(RobolectricTestRunner.class)
+public class JobParamsTest extends TestBase {
+    @Test
+    public void assertParamsUnderstood() {
+        DummyJob j1 = new DummyJob(new Params(1).requireNetwork());
+        assertThat("require network param should be understood properly", j1.requiresNetwork(), equalTo(true));
+        DummyJob j2 = new DummyJob(new Params(1).groupBy("blah"));
+        assertThat("group param should be understood properly", j2.getRunGroupId(), equalTo("blah"));
+        DummyJob j3 = new DummyJob(new Params(1).persist());
+        assertThat("group param should be understood properly", j3.isPersistent(), equalTo(true));
+        DummyJob j4 = new DummyJob(new Params(1).setPersistent(false).setRequiresNetwork(false).setGroupId(null));
+        assertThat("persist param should be understood properly", j4.isPersistent(), equalTo(false));
+        assertThat("require network param should be understood properly", j4.requiresNetwork(), equalTo(false));
+        assertThat("group param should be understood properly", j4.getRunGroupId(), nullValue());
+    }
+}
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
index 0a1059c..2805e54 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/JobQueueTestBase.java
@@ -3,13 +3,13 @@
 import com.path.android.jobqueue.JobHolder;
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.test.TestBase;
 import com.path.android.jobqueue.test.jobs.DummyJob;
-import com.path.android.jobqueue.test.jobs.PersistentDummyJob;
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import org.fest.reflect.core.*;
 import static org.hamcrest.CoreMatchers.*;
-import org.hamcrest.*;
+import static org.hamcrest.MatcherAssert.*;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -28,34 +28,34 @@ public JobQueueTestBase(JobQueueFactory factory) {
     public void testBasicAddRemoveCount() throws Exception {
         final int ADD_COUNT = 6;
         JobQueue jobQueue = createNewJobQueue();
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(0));
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
+        assertThat((int) jobQueue.count(), equalTo(0));
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
         for (int i = 0; i < ADD_COUNT; i++) {
             JobHolder holder = createNewJobHolder();
             jobQueue.insert(holder);
-            MatcherAssert.assertThat((int) jobQueue.count(), equalTo(i + 1));
-            MatcherAssert.assertThat(holder.getId(), notNullValue());
+            assertThat((int) jobQueue.count(), equalTo(i + 1));
+            assertThat(holder.getId(), notNullValue());
             jobQueue.insertOrReplace(holder);
-            MatcherAssert.assertThat((int) jobQueue.count(), equalTo(i + 1));
+            assertThat((int) jobQueue.count(), equalTo(i + 1));
         }
         JobHolder firstHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat(firstHolder.getRunCount(), equalTo(1));
+        assertThat(firstHolder.getRunCount(), equalTo(1));
         //size should be down 1
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 1));
+        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 1));
         //should return another job
         JobHolder secondHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat(secondHolder.getRunCount(), equalTo(1));
+        assertThat(secondHolder.getRunCount(), equalTo(1));
         //size should be down 2
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
+        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
         //second holder and first holder should have different ids
-        MatcherAssert.assertThat(firstHolder.getId(), not(secondHolder.getId()));
+        assertThat(firstHolder.getId(), not(secondHolder.getId()));
         jobQueue.remove(secondHolder);
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
+        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
         jobQueue.remove(secondHolder);
         //non existed job removed, count should be the same
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
+        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
         jobQueue.remove(firstHolder);
-        MatcherAssert.assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
+        assertThat((int) jobQueue.count(), equalTo(ADD_COUNT - 2));
     }
 
     @Test
@@ -64,26 +64,27 @@ public void testPriority() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         //create and add JOB_LIMIT jobs with random priority
         for (int i = 0; i < JOB_LIMIT; i++) {
-            jobQueue.insert(createNewJobHolderWithPriority((int) (Math.random() * 10)));
+            jobQueue.insert(createNewJobHolder(new Params((int) (Math.random() * 10))));
         }
         //ensure we get jobs in correct priority order
         int minPriority = Integer.MAX_VALUE;
         for (int i = 0; i < JOB_LIMIT; i++) {
             JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat(holder.getPriority() <= minPriority, is(true));
+            assertThat(holder.getPriority() <= minPriority, is(true));
         }
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null), nullValue());
     }
 
+
     @Test
     public void testDelayUntilWithPriority() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         long now = System.nanoTime();
-        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(false, 5, now + 10000 * JobManager.NS_PER_MS);
-        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(false, 10, now + 20000 * JobManager.NS_PER_MS);
+        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5), now + 10000 * JobManager.NS_PER_MS);
+        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now + 20000 * JobManager.NS_PER_MS);
         jobQueue.insert(lowPriorityHolder);
         jobQueue.insert(highPriorityHolder);
-        MatcherAssert.assertThat("when asked, if lower priority job has less delay until, we should return it",
+        assertThat("when asked, if lower priority job has less delay until, we should return it",
                 jobQueue.getNextJobDelayUntilNs(true), equalTo(lowPriorityHolder.getDelayUntilNs()));
 
     }
@@ -91,26 +92,26 @@ public void testDelayUntilWithPriority() throws Exception {
     @Test
     public void testGroupId() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        long jobId1 = jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(0, "group1"));
-        long jobId2 = jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(0, "group1"));
-        long jobId3 = jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(0, "group2"));
-        long jobId4 = jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(0, "group2"));
-        long jobId5 = jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(0, "group1"));
+        long jobId1 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
+        long jobId2 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
+        long jobId3 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
+        long jobId4 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group2")));
+        long jobId5 = jobQueue.insert(createNewJobHolder(new Params(0).groupBy("group1")));
         JobHolder holder1 = jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group2"}));
-        MatcherAssert.assertThat("first jobs should be from group group2 if group1 is excluded",
+        assertThat("first jobs should be from group group2 if group1 is excluded",
                 holder1.getBaseJob().getRunGroupId(), equalTo("group1"));
-        MatcherAssert.assertThat("correct job should be returned if groupId is provided",
+        assertThat("correct job should be returned if groupId is provided",
                 holder1.getId(), equalTo(jobId1));
-        MatcherAssert.assertThat("no jobs should be returned if all groups are excluded",
+        assertThat("no jobs should be returned if all groups are excluded",
                 jobQueue.nextJobAndIncRunCount(true,
                         Arrays.asList(new String[]{"group1", "group2"})),
                 is(nullValue()));
-        long jobId6 = jobQueue.insert(createNewJobHolderWithPriority(0));
-        MatcherAssert.assertThat("both groups are disabled, null group job should be returned",
+        long jobId6 = jobQueue.insert(createNewJobHolder(new Params(0)));
+        assertThat("both groups are disabled, null group job should be returned",
                 jobQueue.nextJobAndIncRunCount(true,
                         Arrays.asList(new String[]{"group1", "group2"})).getId(),
                 is(jobId6));
-        MatcherAssert.assertThat("if group1 is excluded, next job should be from group2",
+        assertThat("if group1 is excluded, next job should be from group2",
                 jobQueue.nextJobAndIncRunCount(true, Arrays.asList(new String[]{"group1"})).getBaseJob().getRunGroupId()
                 , equalTo("group2"));
 
@@ -118,25 +119,25 @@ public void testGroupId() throws Exception {
         jobQueue.insertOrReplace(holder1);
         //ask for it again, should return the same holder because it is grouped
         JobHolder holder2 = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("for grouped jobs, re-fetching job should work fine",
+        assertThat("for grouped jobs, re-fetching job should work fine",
                 holder2.getId(), equalTo(holder1.getId()));
 
         JobHolder holder3 = jobQueue.nextJobAndIncRunCount(true,
                         Arrays.asList(new String[]{"group1"}));
-        MatcherAssert.assertThat("if a group it excluded, next available from another group should be returned",
+        assertThat("if a group it excluded, next available from another group should be returned",
                 holder3.getId(), equalTo(jobId4));
 
         //add two more non-grouped jobs
-        long jobId7 = jobQueue.insert(createNewJobHolderWithPriority(0));
-        long jobId8 = jobQueue.insert(createNewJobHolderWithPriority(0));
+        long jobId7 = jobQueue.insert(createNewJobHolder(new Params(0)));
+        long jobId8 = jobQueue.insert(createNewJobHolder(new Params(0)));
         JobHolder holder4 = jobQueue.nextJobAndIncRunCount(true,
                 Arrays.asList(new String[]{"group1", "group2"}));
-        MatcherAssert.assertThat("if all grouped jobs are excluded, non-grouped jobs should be returned",
+        assertThat("if all grouped jobs are excluded, non-grouped jobs should be returned",
                 holder4.getId(),
                 equalTo(jobId7));
         jobQueue.insertOrReplace(holder4);
         //for non-grouped jobs, run counts should be respected
-        MatcherAssert.assertThat("if all grouped jobs are excluded, re-inserted highest priority job should still be returned",
+        assertThat("if all grouped jobs are excluded, re-inserted highest priority job should still be returned",
                 jobQueue.nextJobAndIncRunCount(true,
                         Arrays.asList(new String[]{"group1", "group2"})).getId(),
                 equalTo(jobId7));
@@ -146,20 +147,20 @@ public void testGroupId() throws Exception {
     public void testDueDelayUntilWithPriority() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         long now = System.nanoTime();
-        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(false, 5, now - 1000 * JobManager.NS_PER_MS);
-        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(false, 10, now - 10000 * JobManager.NS_PER_MS);
+        JobHolder lowPriorityHolder = createNewJobHolderWithDelayUntil(new Params(5),now - 1000 * JobManager.NS_PER_MS);
+        JobHolder highPriorityHolder = createNewJobHolderWithDelayUntil(new Params(10), now - 10000 * JobManager.NS_PER_MS);
         jobQueue.insert(lowPriorityHolder);
         jobQueue.insert(highPriorityHolder);
         long soonJobDelay = 2000;
-        JobHolder highestPriorityDelayedJob = createNewJobHolderWithDelayUntil(false, 12, now + soonJobDelay * JobManager.NS_PER_MS);
+        JobHolder highestPriorityDelayedJob = createNewJobHolderWithDelayUntil(new Params(12), now + soonJobDelay * JobManager.NS_PER_MS);
         long highestPriorityDelayedJobId = jobQueue.insert(highestPriorityDelayedJob);
-        MatcherAssert.assertThat("when asked, if job's due has passed, highest priority jobs's delay until should be " +
+        assertThat("when asked, if job's due has passed, highest priority jobs's delay until should be " +
                 "returned",
                 jobQueue.getNextJobDelayUntilNs(true), equalTo(highPriorityHolder.getDelayUntilNs()));
         //make sure soon job is valid now
         Thread.sleep(soonJobDelay);
 
-        MatcherAssert.assertThat("when a job's time come, it should be returned",
+        assertThat("when a job's time come, it should be returned",
                 jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(highestPriorityDelayedJobId));
     }
 
@@ -167,23 +168,23 @@ public void testDueDelayUntilWithPriority() throws Exception {
     public void testDelayUntil() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         long now = System.nanoTime();
-        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(true, 0, now + 200000 * JobManager.NS_PER_MS);
+        JobHolder networkJobHolder = createNewJobHolderWithDelayUntil(new Params(0).requireNetwork(), now + 200000 * JobManager.NS_PER_MS);
 
-        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(false, 0, now + 500000 * JobManager.NS_PER_MS);
+        JobHolder noNetworkJobHolder = createNewJobHolderWithDelayUntil(new Params(0), now + 500000 * JobManager.NS_PER_MS);
 
         jobQueue.insert(networkJobHolder);
         jobQueue.insert(noNetworkJobHolder);
 
-        MatcherAssert.assertThat("if there is no network, delay until should be provided for no network job",
+        assertThat("if there is no network, delay until should be provided for no network job",
             jobQueue.getNextJobDelayUntilNs(false), equalTo(noNetworkJobHolder.getDelayUntilNs()));
 
-        MatcherAssert.assertThat("if there is network, delay until should be provided for network job because it is " +
+        assertThat("if there is network, delay until should be provided for network job because it is " +
                 "sooner", jobQueue.getNextJobDelayUntilNs(true), equalTo(networkJobHolder.getDelayUntilNs()));
 
-        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(false, 0, now + 100000 * JobManager.NS_PER_MS);
+        JobHolder noNetworkJobHolder2 = createNewJobHolderWithDelayUntil(new Params(0), now + 100000 * JobManager.NS_PER_MS);
 
         jobQueue.insert(noNetworkJobHolder2);
-        MatcherAssert.assertThat("if there is network, any job's delay until should be returned",
+        assertThat("if there is network, any job's delay until should be returned",
                 jobQueue.getNextJobDelayUntilNs(true), equalTo(noNetworkJobHolder2.getDelayUntilNs()));
     }
 
@@ -194,31 +195,31 @@ public void testTruncate() throws Exception {
         for(int i = 0; i < LIMIT; i ++) {
             jobQueue.insert(createNewJobHolder());
         }
-        MatcherAssert.assertThat("queue should have all jobs", jobQueue.count(), equalTo(LIMIT));
+        assertThat("queue should have all jobs", jobQueue.count(), equalTo(LIMIT));
         jobQueue.clear();
-        MatcherAssert.assertThat("after clear, queue should be empty", jobQueue.count(), equalTo(0));
+        assertThat("after clear, queue should be empty", jobQueue.count(), equalTo(0));
         for(int i = 0; i < LIMIT; i ++) {
             jobQueue.insert(createNewJobHolder());
         }
-        MatcherAssert.assertThat("if we add jobs again, count should match", jobQueue.count(), equalTo(LIMIT));
+        assertThat("if we add jobs again, count should match", jobQueue.count(), equalTo(LIMIT));
     }
 
     @Test
     public void testPriorityWithDelayedJobs() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        JobHolder delayedPriority_5 = createNewJobHolderWithPriority(5);
+        JobHolder delayedPriority_5 = createNewJobHolder(new Params(5));
         org.fest.reflect.field.Invoker<Long> delayUntilField = getDelayUntilNsField(delayedPriority_5);
         delayUntilField.set(System.nanoTime() - 1000);
 
-        JobHolder delayedPriority_2 = createNewJobHolderWithPriority(2);
+        JobHolder delayedPriority_2 = createNewJobHolder(new Params(2));
         delayUntilField = getDelayUntilNsField(delayedPriority_2);
         delayUntilField.set(System.nanoTime() - 500);
 
 
 
-        JobHolder nonDelayedPriority_6 = createNewJobHolderWithPriority(6);
-        JobHolder nonDelayedPriority_3 = createNewJobHolderWithPriority(3);
-        JobHolder nonDelayedPriority_2 = createNewJobHolderWithPriority(2);
+        JobHolder nonDelayedPriority_6 = createNewJobHolder(new Params(6));
+        JobHolder nonDelayedPriority_3 = createNewJobHolder(new Params(3));
+        JobHolder nonDelayedPriority_2 = createNewJobHolder(new Params(2));
 
 
         jobQueue.insert(delayedPriority_5);
@@ -230,8 +231,8 @@ public void testPriorityWithDelayedJobs() throws Exception {
         int lastPriority = Integer.MAX_VALUE;
         for(int i = 0; i < 5; i++) {
             JobHolder next = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat("next job should not be null", next, notNullValue());
-            MatcherAssert.assertThat("next job's priority should be lower then previous for job " + i, next.getPriority() <= lastPriority, is(true));
+            assertThat("next job should not be null", next, notNullValue());
+            assertThat("next job's priority should be lower then previous for job " + i, next.getPriority() <= lastPriority, is(true));
             lastPriority = next.getPriority();
         }
 
@@ -241,6 +242,18 @@ public void testPriorityWithDelayedJobs() throws Exception {
         return Reflection.field("delayUntilNs").ofType(long.class).in(jobHolder);
     }
 
+    private org.fest.reflect.field.Invoker<Integer> getPriorityField(Params params) {
+        return Reflection.field("priority").ofType(int.class).in(params);
+    }
+
+    private org.fest.reflect.field.Invoker<Long> getDelayMsField(Params params) {
+        return Reflection.field("delayMs").ofType(long.class).in(params);
+    }
+
+    private org.fest.reflect.field.Invoker<String> getGroupIdField(Params params) {
+        return Reflection.field("groupId").ofType(String.class).in(params);
+    }
+
     @Test
     public void testSessionId() throws Exception {
         long sessionId = (long) (Math.random() * 100000);
@@ -248,7 +261,7 @@ public void testSessionId() throws Exception {
         JobHolder jobHolder = createNewJobHolder();
         jobQueue.insert(jobHolder);
         jobHolder = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("session id should be attached to next job",
+        assertThat("session id should be attached to next job",
                 jobHolder.getRunningSessionId(), equalTo(sessionId));
     }
 
@@ -258,16 +271,16 @@ public void testPriorityWithReAdd() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
         //create and add JOB_LIMIT jobs with random priority
         for (int i = 0; i < JOB_LIMIT; i++) {
-            jobQueue.insert(createNewJobHolderWithPriority((int) (Math.random() * 10)));
+            jobQueue.insert(createNewJobHolder(new Params((int) (Math.random() * 10))));
         }
         //ensure we get jobs in correct priority order
         int minPriority = Integer.MAX_VALUE;
         for (int i = 0; i < JOB_LIMIT; i++) {
             JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat(holder.getPriority() <= minPriority, is(true));
+            assertThat(holder.getPriority() <= minPriority, is(true));
             jobQueue.insertOrReplace(holder);
         }
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null), notNullValue());
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null), notNullValue());
     }
 
     @Test
@@ -276,46 +289,46 @@ public void testRemove() throws Exception {
         JobHolder holder = createNewJobHolder();
         jobQueue.insert(holder);
         Long jobId = holder.getId();
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(jobId));
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null).getId(), equalTo(jobId));
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
         jobQueue.remove(holder);
-        MatcherAssert.assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
+        assertThat(jobQueue.nextJobAndIncRunCount(true, null), is(nullValue()));
     }
 
     @Test
     public void testNetwork() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        JobHolder jobHolder = createNewJobHolderWithRequiresNetwork(false);
+        JobHolder jobHolder = createNewJobHolder(new Params(0));
         jobQueue.insert(jobHolder);
-        MatcherAssert.assertThat("no network job should be returned even if there is no netowrk",
+        assertThat("no network job should be returned even if there is no netowrk",
                 jobQueue.nextJobAndIncRunCount(false, null), notNullValue());
         jobQueue.remove(jobHolder);
 
-        jobHolder = createNewJobHolderWithRequiresNetwork(true);
-        MatcherAssert.assertThat("if there isn't any network, job with network requirement should not return",
+        jobHolder = createNewJobHolder(new Params(0).requireNetwork());
+        assertThat("if there isn't any network, job with network requirement should not return",
                 jobQueue.nextJobAndIncRunCount(false, null), nullValue());
 
-        MatcherAssert.assertThat("if there is network, job with network requirement should be returned",
+        assertThat("if there is network, job with network requirement should be returned",
                 jobQueue.nextJobAndIncRunCount(true, null), nullValue());
 
         jobQueue.remove(jobHolder);
 
-        jobHolder = createNewJobHolderWithRequiresNetworkAndPriority(false, 1);
-        JobHolder jobHolder2 = createNewJobHolderWithRequiresNetworkAndPriority(true, 5);
+        jobHolder = createNewJobHolder(new Params(1));
+        JobHolder jobHolder2 = createNewJobHolder(new Params(5).requireNetwork());
         long firstJobId = jobQueue.insert(jobHolder);
         long secondJobId = jobQueue.insert(jobHolder2);
         JobHolder retrieved = jobQueue.nextJobAndIncRunCount(false, null);
-        MatcherAssert.assertThat("one job should be returned w/o network", retrieved, notNullValue());
+        assertThat("one job should be returned w/o network", retrieved, notNullValue());
         if(retrieved != null) {
-            MatcherAssert.assertThat("no network job should be returned although it has lower priority", retrieved.getId(), equalTo(firstJobId));
+            assertThat("no network job should be returned although it has lower priority", retrieved.getId(), equalTo(firstJobId));
         }
 
-        MatcherAssert.assertThat("no other job should be returned w/o network", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
+        assertThat("no other job should be returned w/o network", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
 
         retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("if network is back, network requiring job should be returned", retrieved, notNullValue());
+        assertThat("if network is back, network requiring job should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            MatcherAssert.assertThat("when there is network, network job should be returned", retrieved.getId(), equalTo(secondJobId));
+            assertThat("when there is network, network job should be returned", retrieved.getId(), equalTo(secondJobId));
         }
         //add first job back
         jobQueue.insertOrReplace(jobHolder);
@@ -323,18 +336,18 @@ public void testNetwork() throws Exception {
         jobQueue.insertOrReplace(jobHolder2);
 
         retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("if network is back, job w/ higher priority should be returned", retrieved, notNullValue());
+        assertThat("if network is back, job w/ higher priority should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            MatcherAssert.assertThat("if network is back, job w/ higher priority should be returned", retrieved.getId(), equalTo(secondJobId));
+            assertThat("if network is back, job w/ higher priority should be returned", retrieved.getId(), equalTo(secondJobId));
         }
         jobQueue.insertOrReplace(jobHolder2);
 
-        JobHolder highestPriorityJob = createNewJobHolderWithRequiresNetworkAndPriority(false, 10);
+        JobHolder highestPriorityJob = createNewJobHolder(new Params(10));
         long highestPriorityJobId = jobQueue.insert(highestPriorityJob);
         retrieved = jobQueue.nextJobAndIncRunCount(true, null);
-        MatcherAssert.assertThat("w/ or w/o network, highest priority should be returned", retrieved, notNullValue());
+        assertThat("w/ or w/o network, highest priority should be returned", retrieved, notNullValue());
         if(retrieved != null) {
-            MatcherAssert.assertThat("w/ or w/o network, highest priority should be returned", retrieved.getId(), equalTo(highestPriorityJobId));
+            assertThat("w/ or w/o network, highest priority should be returned", retrieved.getId(), equalTo(highestPriorityJobId));
         }
 
         //TODO test delay until
@@ -343,53 +356,53 @@ public void testNetwork() throws Exception {
     @Test
     public void testCountReadyJobs() throws Exception {
         JobQueue jobQueue = createNewJobQueue();
-        MatcherAssert.assertThat("initial count should be 0 for ready jobs", jobQueue.countReadyJobs(true, null), equalTo(0));
+        assertThat("initial count should be 0 for ready jobs", jobQueue.countReadyJobs(true, null), equalTo(0));
         //add some jobs
         jobQueue.insert(createNewJobHolder());
-        jobQueue.insert(createNewJobHolderWithRequiresNetwork(true));
+        jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork()));
         long now = System.nanoTime();
         long delay = 1000;
-        jobQueue.insert(createNewJobHolderWithDelayUntil(false, 0, now + TimeUnit.MILLISECONDS.toNanos(delay)));
-        MatcherAssert.assertThat("ready count should be 1 if there is no network", jobQueue.countReadyJobs(false, null), equalTo(1));
-        MatcherAssert.assertThat("ready count should be 2 if there is network", jobQueue.countReadyJobs(true, null), equalTo(2));
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0), now + TimeUnit.MILLISECONDS.toNanos(delay)));
+        assertThat("ready count should be 1 if there is no network", jobQueue.countReadyJobs(false, null), equalTo(1));
+        assertThat("ready count should be 2 if there is network", jobQueue.countReadyJobs(true, null), equalTo(2));
         Thread.sleep(delay);
-        MatcherAssert.assertThat("when needed delay time passes, ready count should be 3", jobQueue.countReadyJobs(true, null), equalTo(3));
-        MatcherAssert.assertThat("when needed delay time passes but no network, ready count should be 2", jobQueue.countReadyJobs(false, null), equalTo(2));
-        jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(5, "group1"));
-        jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(5, "group1"));
-        MatcherAssert.assertThat("when more than 1 job from same group is created, ready jobs should increment only by 1",
+        assertThat("when needed delay time passes, ready count should be 3", jobQueue.countReadyJobs(true, null), equalTo(3));
+        assertThat("when needed delay time passes but no network, ready count should be 2", jobQueue.countReadyJobs(false, null), equalTo(2));
+        jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
+        jobQueue.insert(createNewJobHolder(new Params(5).groupBy("group1")));
+        assertThat("when more than 1 job from same group is created, ready jobs should increment only by 1",
                 jobQueue.countReadyJobs(true, null), equalTo(4));
-        MatcherAssert.assertThat("excluding groups should work",
+        assertThat("excluding groups should work",
                 jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1"})), equalTo(3));
-        MatcherAssert.assertThat("giving a non-existing group should not fool the count",
+        assertThat("giving a non-existing group should not fool the count",
                 jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group3423"})), equalTo(4));
-        jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(3, "group2"));
-        MatcherAssert.assertThat("when a job from another group is added, ready job count should inc",
+        jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group2")));
+        assertThat("when a job from another group is added, ready job count should inc",
                 jobQueue.countReadyJobs(true, null), equalTo(5));
         now = System.nanoTime();
-        jobQueue.insert(createNewJobHolderWithPriorityAndGroupIdAndDelayUntil(3, "group3", now + TimeUnit.MILLISECONDS.toNanos(delay)));
-        MatcherAssert.assertThat("when a delayed job from another group is added, ready count should not change",
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(3).groupBy("group3"), now + TimeUnit.MILLISECONDS.toNanos(delay)));
+        assertThat("when a delayed job from another group is added, ready count should not change",
                 jobQueue.countReadyJobs(true, null), equalTo(5));
-        jobQueue.insert(createNewJobHolderWithPriorityAndGroupId(3, "group3"));
-        MatcherAssert.assertThat("when another job from delayed group is added, ready job count should inc",
+        jobQueue.insert(createNewJobHolder(new Params(3).groupBy("group3")));
+        assertThat("when another job from delayed group is added, ready job count should inc",
                 jobQueue.countReadyJobs(true, null), equalTo(6));
         Thread.sleep(delay);
-        MatcherAssert.assertThat("when delay passes and a job from existing group becomes available, ready job count should not change",
+        assertThat("when delay passes and a job from existing group becomes available, ready job count should not change",
                 jobQueue.countReadyJobs(true, null), equalTo(6));
-        MatcherAssert.assertThat("when some groups are excluded, count should be correct",
+        assertThat("when some groups are excluded, count should be correct",
                 jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
 
         //jobs w/ same group id but with different persistence constraints should not fool the count
         now = System.nanoTime();
-        jobQueue.insert(createNewJobHolderWithGroupIdAndDelayUntil(true, "group10", now + 1000));
-        jobQueue.insert(createNewJobHolderWithGroupIdAndDelayUntil(false, "group10", now + 1000));
-        jobQueue.insert(createNewJobHolderWithGroupIdAndDelayUntil(true, "group10", now - 1000));
-        jobQueue.insert(createNewJobHolderWithGroupIdAndDelayUntil(false, "group10", now - 1000));
-        MatcherAssert.assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now + 1000));
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now + 1000));
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).persist().groupBy("group10"), now - 1000));
+        jobQueue.insert(createNewJobHolderWithDelayUntil(new Params(0).groupBy("group10"), now - 1000));
+        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
                 jobQueue.countReadyJobs(true, Arrays.asList(new String[]{"group1", "group3"})), equalTo(5));
-        MatcherAssert.assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
+        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
                 jobQueue.countReadyJobs(true, null), equalTo(7));
-        MatcherAssert.assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
+        assertThat("when many jobs are added w/ different constraints but same group id, ready count should not be fooled",
                 jobQueue.countReadyJobs(false, Arrays.asList(new String[]{"group1", "group3"})), equalTo(4));
     }
 
@@ -402,7 +415,7 @@ public void testJobFields() throws Exception {
 
         int priority = (int) (Math.random() * 1000);
         jobHolder.setPriority(priority);
-        DummyJob dummyJob = new DummyJob();
+        DummyJob dummyJob = new DummyJob(new Params(0));
         jobHolder.setBaseJob(dummyJob);
         int runCount = (int) (Math.random() * 10);
         jobHolder.setRunCount(runCount);
@@ -412,49 +425,81 @@ public void testJobFields() throws Exception {
 
         for (int i = 0; i < 2; i++) {
             JobHolder received = jobQueue.nextJobAndIncRunCount(true, null);
-            MatcherAssert.assertThat("job id should be preserved", received.getId(), equalTo(id));
-            MatcherAssert.assertThat("job priority should be preserved", received.getPriority(), equalTo(priority));
-            MatcherAssert.assertThat("job session id should be assigned", received.getRunningSessionId(), equalTo(sessionId));
-            MatcherAssert.assertThat("job run count should be incremented", received.getRunCount(), equalTo(runCount + i + 1));
+            assertThat("job id should be preserved", received.getId(), equalTo(id));
+            assertThat("job priority should be preserved", received.getPriority(), equalTo(priority));
+            assertThat("job session id should be assigned", received.getRunningSessionId(), equalTo(sessionId));
+            assertThat("job run count should be incremented", received.getRunCount(), equalTo(runCount + i + 1));
             jobQueue.insertOrReplace(received);
         }
     }
 
-    protected JobHolder createNewJobHolder() {
-        return new JobHolder(null, 0, null, 0, new DummyJob(), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
-    }
-
-    private JobHolder createNewJobHolderWithRequiresNetwork(boolean requiresNetwork) {
-        return new JobHolder(null, 0, null, 0, new DummyJob(requiresNetwork, false), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
-    }
-
-    private JobHolder createNewJobHolderWithDelayUntil(boolean requiresNetwork, int priority, long delayUntil) {
-        JobHolder jobHolder = new JobHolder(null, priority, null, 0, new DummyJob(requiresNetwork, false), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
-        getDelayUntilNsField(jobHolder).set(delayUntil);
-        return jobHolder;
-    }
-
-    private JobHolder createNewJobHolderWithRequiresNetworkAndPriority(boolean requiresNetwork, int priority) {
-        return new JobHolder(null, priority, null, 0, new DummyJob(requiresNetwork, false), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
+    private void assertJob(JobQueue jobQueue, String msg, long id, /*nullable*/ JobHolder holder) {
+        if(holder == null) {
+            assertThat(msg, jobQueue.findJobById(id), nullValue());
+            return;
+        }
+        assertThat(msg + "(existence check)", jobQueue.findJobById(id), notNullValue());
+        assertThat(msg + "(id check)", jobQueue.findJobById(id).getId(), is(holder.getId()));
     }
 
-    private JobHolder createNewJobHolderWithPriority(int priority) {
-        return new JobHolder(null, priority, null, 0, new DummyJob(), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
+    @Test
+    public void testFindJobHolderById() {
+        JobQueue jobQueue = createNewJobQueue();
+        assertJob(jobQueue, "non existing job (negative id)", -4, null);
+        assertJob(jobQueue, "non existing job (positive id)", +4, null);
+        final int LIMIT = 100;
+        JobHolder[] holders = new JobHolder[LIMIT];
+        long[] ids = new long[LIMIT];
+        for(int i =  0; i < LIMIT; i++) {
+            holders[i] = createNewJobHolder(new Params((int) (Math.random() * 50)).setPersistent(Math.random() < .5).setRequiresNetwork(Math.random() < .5));
+            ids[i] = jobQueue.insert(holders[i]);
+            assertJob(jobQueue, "job by id should work for inserted job", ids[i], holders[i]);
+        }
+        final int REMOVE_CNT = LIMIT / 2;
+        for(int i = 0; i < REMOVE_CNT; i++) {
+            int ind = (int) (Math.random() * LIMIT);
+            if(holders[ind] == null) {
+                continue;
+            }
+            //remove some randomly, up to half
+            jobQueue.remove(holders[ind]);
+            holders[ind] = null;
+        }
+        //re-query all, ensure we can still find non-removed jobs and not find removed jobs
+        for(int i =  0; i < LIMIT; i++) {
+            if(holders[i] != null) {
+                assertJob(jobQueue, "if job is still in the Q, it should be returned", ids[i], holders[i]);
+                //re add job
+                jobQueue.insertOrReplace(holders[i]);
+                //re-test after re-add
+                assertJob(jobQueue, "after re-insert, if job is still in the Q, it should be returned", ids[i], holders[i]);
+            } else {
+                assertJob(jobQueue, "removed job should not be returned in id query", ids[i], null);
+            }
+        }
+        jobQueue.clear();
+        for(int i = 0; i < LIMIT; i++) {
+            assertJob(jobQueue, "after clear, find by id should return null", ids[i], null);
+        }
     }
 
-    private JobHolder createNewJobHolderWithPriorityAndGroupId(int priority, String groupId) {
-        return new JobHolder(null, priority, groupId, 0, new DummyJob(groupId), System.nanoTime(), Long.MIN_VALUE, JobManager.NOT_RUNNING_SESSION_ID);
+    protected JobHolder createNewJobHolder() {
+        return createNewJobHolder(new Params(0));
     }
 
-    private JobHolder createNewJobHolderWithGroupIdAndDelayUntil(boolean persistent, String groupId, long delayUntil) {
-        return new JobHolder(null, 0, groupId, 0, persistent ? new PersistentDummyJob(groupId) : new DummyJob(groupId), System.nanoTime(), delayUntil, JobManager.NOT_RUNNING_SESSION_ID);
+    protected JobHolder createNewJobHolder(Params params) {
+        long delay = getDelayMsField(params).get();
+        return new JobHolder(null, getPriorityField(params).get(), getGroupIdField(params).get(), 0, new DummyJob(params), System.nanoTime(),
+                delay > 0 ? System.nanoTime() +  delay * JobManager.NS_PER_MS : JobManager.NOT_DELAYED_JOB_DELAY, JobManager.NOT_RUNNING_SESSION_ID);
     }
 
-    private JobHolder createNewJobHolderWithPriorityAndGroupIdAndDelayUntil(int priority, String groupId, long delayUntilNs) {
-        return new JobHolder(null, priority, groupId, 0, new DummyJob(groupId), System.nanoTime(), delayUntilNs, JobManager.NOT_RUNNING_SESSION_ID);
+    private JobHolder createNewJobHolderWithDelayUntil(Params params, long delayUntil) {
+        JobHolder jobHolder = createNewJobHolder(params);
+        getDelayUntilNsField(jobHolder).set(delayUntil);
+        return jobHolder;
     }
 
-    private JobQueue createNewJobQueue() {
+    protected JobQueue createNewJobQueue() {
         return createNewJobQueueWithSessionId(System.nanoTime());
     }
 
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
index 32ca824..aec3924 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/NonPersistentJobQueueTest.java
@@ -1,10 +1,16 @@
 package com.path.android.jobqueue.test.jobqueue;
 
+import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.nonPersistentQueue.NonPersistentPriorityQueue;
 import com.path.android.jobqueue.test.util.JobQueueFactory;
+import static org.hamcrest.CoreMatchers.*;
+import org.hamcrest.*;
+import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
+import org.robolectric.*;
 
 @RunWith(RobolectricTestRunner.class)
 public class NonPersistentJobQueueTest extends JobQueueTestBase {
@@ -16,4 +22,32 @@ public JobQueue createNew(long sessionId, String id) {
             }
         });
     }
+
+    /**
+     * issue #21 https://github.com/path/android-priority-jobqueue/issues/21
+     */
+    @Test
+    public void testTooManyQueueChanges() throws InterruptedException {
+        JobQueue jobQueue = createNewJobQueue();
+        int limit = 10000;
+        long delayMs = 2000;
+        long then = System.nanoTime() + delayMs * JobManager.NS_PER_MS;
+        for(int i = 0; i < limit; i++) {
+            jobQueue.insert(createNewJobHolder(new Params(0).requireNetwork().delayInMs(delayMs)));
+        }
+
+        MatcherAssert.assertThat("all jobs require network, should return null", jobQueue.nextJobAndIncRunCount(false, null), nullValue());
+        long sleep = then - System.nanoTime();
+        sleep += JobManager.NS_PER_MS * 1000;
+        if (sleep > 0) {
+            Thread.sleep(sleep / JobManager.NS_PER_MS);
+        }
+        //should be able to get it w/o an overflow
+        for(int i = 0; i < limit; i++) {
+            JobHolder holder = jobQueue.nextJobAndIncRunCount(true, null);
+            MatcherAssert.assertThat("should get a next job", holder, notNullValue());
+            jobQueue.remove(holder);
+        }
+
+    }
 }
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
index 3791bda..7325e3d 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobqueue/SqliteJobQueueTest.java
@@ -2,6 +2,7 @@
 
 import com.path.android.jobqueue.BaseJob;
 import com.path.android.jobqueue.JobQueue;
+import com.path.android.jobqueue.Params;
 import com.path.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
 import com.path.android.jobqueue.test.util.JobQueueFactory;
 import org.hamcrest.CoreMatchers;
@@ -45,7 +46,7 @@ public void testCustomSerializer() throws Exception {
         };
         SqliteJobQueue jobQueue = new SqliteJobQueue(Robolectric.application, System.nanoTime(), "__" + System.nanoTime(),
                 jobSerializer);
-        jobQueue.insert(createNewJobHolder());
+        jobQueue.insert(createNewJobHolder(new Params(0)));
         calledForSerialize.await(1, TimeUnit.SECONDS);
         MatcherAssert.assertThat("custom serializer should be called for serialize", (int) calledForSerialize.getCount(), CoreMatchers.equalTo(0));
         MatcherAssert.assertThat("custom serializer should NOT be called for deserialize", (int) calledForDeserialize.getCount(), CoreMatchers.equalTo(1));
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java b/jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java
index 9b0d3ce..d931e1e 100644
--- a/jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java
+++ b/jobqueue/test/com/path/android/jobqueue/test/jobs/DummyJob.java
@@ -1,23 +1,16 @@
 package com.path.android.jobqueue.test.jobs;
 
-import com.path.android.jobqueue.BaseJob;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
 
-public class DummyJob extends BaseJob {
+public class DummyJob extends Job {
     int onAddedCnt = 0;
     int onRunCnt = 0;
     int onCancelCnt = 0;
     int shouldReRunOnThrowableCnt = 0;
 
-    public DummyJob() {
-        super(false, false);
-    }
-
-    public DummyJob(boolean requiresNetwork, boolean persistent) {
-        super(requiresNetwork, persistent);
-    }
-
-    public DummyJob(String groupId) {
-        super(false, groupId);
+    public DummyJob(Params params) {
+        super(params);
     }
 
     @Override
diff --git a/jobqueue/test/com/path/android/jobqueue/test/jobs/PersistentDummyJob.java b/jobqueue/test/com/path/android/jobqueue/test/jobs/PersistentDummyJob.java
deleted file mode 100644
index aa0296e..0000000
--- a/jobqueue/test/com/path/android/jobqueue/test/jobs/PersistentDummyJob.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.path.android.jobqueue.test.jobs;
-
-
-public class PersistentDummyJob extends DummyJob {
-    public PersistentDummyJob() {
-        super(false, true);
-    }
-
-    public PersistentDummyJob(boolean requiresNetwork) {
-        super(requiresNetwork, true);
-    }
-
-    public PersistentDummyJob(String groupId) {
-        super(groupId);
-    }
-
-}
