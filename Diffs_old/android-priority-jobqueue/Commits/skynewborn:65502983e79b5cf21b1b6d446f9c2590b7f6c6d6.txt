diff --git a/.travis.yml b/.travis.yml
index 66290b2..6338045 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,11 @@
 language: android
 android:
   components:
-    - build-tools-23.0.1
+    - tools
+    - platform-tools
+    - platform-tools-23.1
+    - tools-24.4.1
+    - build-tools-23.0.2
     - android-23
 script:
   gradle jarRelease
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 11b395d..722ec75 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.6-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/jobqueue/build.gradle b/jobqueue/build.gradle
index 69f568f..99d1b1f 100644
--- a/jobqueue/build.gradle
+++ b/jobqueue/build.gradle
@@ -3,16 +3,37 @@ import java.util.regex.Pattern
 apply plugin: 'com.android.library'
 
 /*Properties releaseConfig = new Properties()
-releaseConfig.load(new FileInputStream("${projectDir}/releaseConfig.properties"))
+File releaseFile = new File("${projectDir}/releaseConfig.properties")
+if (releaseFile.exists()) {
+    releaseConfig.load(new FileInputStream(releaseFile))
+}
+
 ext.releaseConfig = releaseConfig*/
+
 task wrapper(type: Wrapper) {
-    gradleVersion = '2.6'
+    gradleVersion = '2.10'
 }
 
 apply plugin: 'maven'
 apply plugin: 'signing'
 apply plugin: 'jacoco'
 
+buildscript {
+    repositories {
+        jcenter()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.5.0'
+
+    }
+}
+
+repositories {
+    mavenCentral()
+    jcenter()
+}
+
 configurations {
     archives {
         extendsFrom configurations.default
@@ -25,14 +46,12 @@ dependencies {
     testCompile 'org.hamcrest:hamcrest-core:1.3'
     testCompile 'org.easytesting:fest-util:1.2.5'
     testCompile 'org.easytesting:fest-reflect:1.4.1'
-
+    testCompile 'org.mockito:mockito-core:2.0.2-beta'
 }
 
-
-
 android {
     compileSdkVersion 23
-    buildToolsVersion "23.0.1"
+    buildToolsVersion "23.0.2"
     buildTypes {
         debug {
             testCoverageEnabled = true
@@ -55,10 +74,11 @@ def manifestVersionName = matcher.group(1)
 println "version name:${manifestVersionName}"
 
 //create jar tasks
+
 android.libraryVariants.all { variant ->
     def name = variant.buildType.name
     println "checking variant ${name}"
-    if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
+    if (variant.buildType.isDebuggable()) {
         return; // Skip debug builds.
     }
     def suffix = name.capitalize()
@@ -156,7 +176,7 @@ android.libraryVariants.all { variant ->
     }
 }*/
 
-task jacocoTestReport(type:JacocoReport, dependsOn: "testDebug") {
+task jacocoTestReport(type:JacocoReport, dependsOn: "testDebugUnitTest") {
     group = "Reporting"
 
     description = "Generate Jacoco coverage reports"
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
index 3cda44a..6fc1ab5 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/Job.java
@@ -218,13 +218,11 @@ final int safeRun(JobHolder holder, int currentRunCount) {
         if (reRun) {
             return JobHolder.RUN_RESULT_TRY_AGAIN;
         }
-        // failed.
-        try {
-            onCancel();
-        } catch (Throwable ignored) {
+        if (currentRunCount < getRetryLimit()) {
+            return JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+        } else {
+            return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
         }
-        return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
-
     }
 
     /**
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
index ba73f4d..4e5fd19 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobHolder.java
@@ -30,6 +30,11 @@
      */
     public static final int RUN_RESULT_TRY_AGAIN = 4;
 
+    /**
+     * The job decided not to run in shouldReRun method.
+     */
+    public static final int RUN_RESULT_FAIL_SHOULD_RE_RUN = 5;
+
     protected Long id;
     protected int priority;
     protected String groupId;
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
index 2169e50..0137bcd 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/JobManager.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import com.path.android.jobqueue.cachedQueue.CachedJobQueue;
+import com.path.android.jobqueue.callback.JobManagerCallback;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.di.DependencyInjector;
 import com.path.android.jobqueue.executor.JobConsumerExecutor;
@@ -50,8 +51,9 @@
     private ScheduledExecutorService timedExecutor;
     // lazily created
     private final Object cancelExecutorInitLock = new Object();
-    private Executor cancelExecutor;
+    private ExecutorService cancelExecutor;
     private final Object getNextJobLock = new Object();
+    private final CopyOnWriteArrayList<JobManagerCallback> callbacks = new CopyOnWriteArrayList<>();
 
 
     /**
@@ -122,6 +124,14 @@ public void start() {
         notifyJobConsumer();
     }
 
+    public void addCallback(JobManagerCallback callback) {
+        callbacks.add(callback);
+    }
+
+    public boolean removeCallback(JobManagerCallback callback) {
+        return callbacks.remove(callback);
+    }
+
     /**
      * returns the # of jobs that are waiting to be executed.
      * This might be a good place to decide whether you should wake your app up on boot etc. to complete pending jobs.
@@ -182,7 +192,8 @@ public long addJob(Job job) {
             dependencyInjector.inject(job);
         }
         jobHolder.getJob().setApplicationContext(appContext);
-        jobHolder.getJob().onAdded();
+        callOnAddedAndNotifyListeners(jobHolder);
+
         if(job.isPersistent()) {
             synchronized (persistentJobQueue) {
                 clearOnAddedLock(persistentOnAddedLocks, id);
@@ -338,7 +349,7 @@ public void run() {
             } else {
                 result.cancelledJobs.add(holder.getJob());
                 try {
-                    holder.getJob().onCancel();
+                    callOnCancelAndNotifyListeners(holder, true);
                 } catch (Throwable t) {
                     JqLog.e(t, "cancelled job's onCancel has thrown exception");
                 }
@@ -628,13 +639,21 @@ private void removeJob(JobHolder jobHolder) {
     }
 
     public synchronized void stopAndWaitUntilConsumersAreFinished() throws InterruptedException {
-        stop();
-        timedExecutor.shutdownNow();
         synchronized (newJobListeners) {
             newJobListeners.notifyAll();
         }
+        stop();
         jobConsumerExecutor.waitUntilAllConsumersAreFinished();
+        timedExecutor.shutdown();
+        timedExecutor.awaitTermination(100, TimeUnit.SECONDS);
         timedExecutor = Executors.newSingleThreadScheduledExecutor();
+        synchronized (cancelExecutorInitLock) {
+            if (cancelExecutor != null) {
+                cancelExecutor.shutdown();
+                cancelExecutor.awaitTermination(100, TimeUnit.SECONDS);
+            }
+            cancelExecutor = Executors.newSingleThreadExecutor();
+        }
     }
 
     public synchronized void clear() {
@@ -658,6 +677,40 @@ public void onNetworkChange(boolean isConnected) {
         ensureConsumerWhenNeeded(isConnected);
     }
 
+    private void callOnCancelAndNotifyListeners(JobHolder jobHolder, boolean byCancelRequest) {
+        try {
+            jobHolder.job.onCancel();
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onCancel did throw an exception, ignoring...");
+        }
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobCancelled(jobHolder.job, byCancelRequest);
+            } catch (Throwable t){}
+        }
+    }
+
+    private void notifyOnRunListeners(JobHolder jobHolder, int resultCode) {
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobRun(jobHolder.job, resultCode);
+            } catch (Throwable t){}
+        }
+    }
+
+    private void callOnAddedAndNotifyListeners(JobHolder jobHolder) {
+        try {
+            jobHolder.job.onAdded();
+        } catch (Throwable t) {
+            JqLog.e(t, "job's onAdded did throw an exception, ignoring...");
+        }
+        for (JobManagerCallback callback : callbacks) {
+            try {
+                callback.onJobAdded(jobHolder.job);
+            } catch (Throwable t){}
+        }
+    }
+
     @SuppressWarnings("FieldCanBeLocal")
     private final JobConsumerExecutor.Contract consumerContract = new JobConsumerExecutor.Contract() {
         @Override
@@ -755,6 +808,16 @@ public int countRemainingReadyJobs() {
             //noinspection SimplifiableConditionalExpression
             return countReadyJobs(networkUtil instanceof NetworkEventProvider ? hasNetwork() : true);
         }
+
+        @Override
+        public void callJobCancel(JobHolder jobHolder, boolean byCancelRequest) {
+            JobManager.this.callOnCancelAndNotifyListeners(jobHolder, byCancelRequest);
+        }
+
+        @Override
+        public void notifyJobRun(JobHolder jobHolder, int result) {
+            JobManager.this.notifyOnRunListeners(jobHolder, result);
+        }
     };
 
 
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
new file mode 100644
index 0000000..636b11e
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallback.java
@@ -0,0 +1,79 @@
+package com.path.android.jobqueue.callback;
+
+import com.path.android.jobqueue.CancelResult;
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobHolder;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.TagConstraint;
+
+/**
+ * A callback class that you can attach to the JobManager to get notified as Jobs change states.
+ */
+public interface JobManagerCallback {
+    /**
+     * Used in {@link #onJobRun(Job, int)} when properly completes {@link Job#onRun()}.
+     */
+    int RESULT_SUCCEED = JobHolder.RUN_RESULT_SUCCESS;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it has reached its retry limit.
+     *
+     * @see Job#getRetryLimit()
+     */
+    int RESULT_CANCEL_REACHED_RETRY_LIMIT = JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it was cancelled via
+     * {@link JobManager#cancelJobs(TagConstraint, String...)} while it was running.
+     *
+     * @see JobManager#cancelJobs(TagConstraint, String...)
+     * @see JobManager#cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)
+     */
+    int RESULT_CANCEL_CANCELLED_WHILE_RUNNING = JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and will be cancelled because it decided not to run again via
+     * {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+     */
+    int RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN = JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN;
+    /**
+     * Used in {@link #onJobRun(Job, int)} when job throws an exception in {@link Job#onRun()}
+     * and wanted to retry via {@link Job#shouldReRunOnThrowable(Throwable, int, int)}.
+     *
+     * @see Job#getRetryLimit()
+     */
+    int RESULT_FAIL_WILL_RETRY = JobHolder.RUN_RESULT_TRY_AGAIN;
+
+    /**
+     * Called when a Job is added to the JobManager. This method is called <b>after</b> Job's
+     * onAdded method is called.
+     *
+     * @param job The Job that was added to the JobManager.
+     */
+    void onJobAdded(Job job);
+
+    /**
+     * Called after a Job has been Run. Might be called multiple times if the Job runs multiple
+     * times (due to failures).
+     *
+     * @param job        The Job that did just run.
+     * @param resultCode The result of the {@link Job#onRun()}. It is one of:
+     *                   <ul>
+     *                   <li>{@link #RESULT_SUCCEED}</li>
+     *                   <li>{@link #RESULT_CANCEL_REACHED_RETRY_LIMIT}</li>
+     *                   <li>{@link #RESULT_CANCEL_CANCELLED_WHILE_RUNNING}</li>
+     *                   <li>{@link #RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN}</li>
+     *                   <li>{@link #RESULT_FAIL_WILL_RETRY}</li>
+     *                   </ul>
+     */
+    void onJobRun(Job job, int resultCode);
+
+    /**
+     * Called when a job is cancelled.
+     *
+     * @param job              The Job that was cancelled.
+     * @param byCancelRequest  If true, the Job was cancelled in response to a
+     *                         {@link JobManager#cancelJobs(TagConstraint, String...)} request.
+     */
+    void onJobCancelled(Job job, boolean byCancelRequest);
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
new file mode 100644
index 0000000..91fef1e
--- /dev/null
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/callback/JobManagerCallbackAdapter.java
@@ -0,0 +1,24 @@
+package com.path.android.jobqueue.callback;
+
+import com.path.android.jobqueue.Job;
+
+/**
+ * An empty implementation of {@link JobManagerCallback}. You are advice to override this one
+ * instead so that if new methods are added to the interface, your code won't break.
+ */
+public class JobManagerCallbackAdapter implements JobManagerCallback {
+    @Override
+    public void onJobAdded(Job job) {
+
+    }
+
+    @Override
+    public void onJobRun(Job job, int resultCode) {
+
+    }
+
+    @Override
+    public void onJobCancelled(Job job, boolean byCancelRequest) {
+
+    }
+}
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
old mode 100755
new mode 100644
index 723c1f7..84a105f
--- a/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/executor/JobConsumerExecutor.java
@@ -5,6 +5,7 @@
 import com.path.android.jobqueue.JobManager;
 import com.path.android.jobqueue.JobQueue;
 import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.callback.JobManagerCallback;
 import com.path.android.jobqueue.config.Configuration;
 import com.path.android.jobqueue.log.JqLog;
 
@@ -171,8 +172,8 @@ private boolean containsAny(List<String> ids) {
     }
 
     public void inRunningJobHoldersLock(Runnable runnable) {
-        synchronized (runnable) {
-            runnable.run();;
+        synchronized (runningJobHolders) {
+            runnable.run();
         }
     }
 
@@ -271,6 +272,20 @@ public void waitUntilAllConsumersAreFinished() throws InterruptedException {
          * @return the number of Jobs that are ready to be run
          */
         public int countRemainingReadyJobs();
+
+        /**
+         * Calls onCancel on the job, notifies listeners
+         * @param nextJob
+         * @param byCancelRequest
+         */
+        void callJobCancel(JobHolder nextJob, boolean byCancelRequest);
+
+        /**
+         * Calls the listeners about job state.
+         * @param nextJob
+         * @param result
+         */
+        void notifyJobRun(JobHolder nextJob, int result);
     }
 
     /**
@@ -304,12 +319,15 @@ public void run() {
                         if (nextJob != null) {
                             executor.onBeforeRun(nextJob);
                             int result = nextJob.safeRun(nextJob.getRunCount());
+                            contract.notifyJobRun(nextJob, result);
                             switch (result) {
                                 case JobHolder.RUN_RESULT_SUCCESS:
                                     nextJob.markAsSuccessful();
                                     contract.removeJob(nextJob);
                                     break;
                                 case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
+                                case JobHolder.RUN_RESULT_FAIL_SHOULD_RE_RUN:
+                                    contract.callJobCancel(nextJob, false);
                                     contract.removeJob(nextJob);
                                     break;
                                 case JobHolder.RUN_RESULT_TRY_AGAIN:
diff --git a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
index a56c072..e0ed303 100644
--- a/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
+++ b/jobqueue/src/main/java/com/path/android/jobqueue/network/NetworkUtilImpl.java
@@ -58,7 +58,8 @@ private static IntentFilter getNetworkIntentFilter() {
     private static boolean isDozing(Context context) {
         if (VERSION.SDK_INT >= 23) {
             PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-            return powerManager.isDeviceIdleMode();
+            return powerManager.isDeviceIdleMode() &&
+                    !powerManager.isIgnoringBatteryOptimizations(context.getPackageName());
         } else {
             return false;
         }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
new file mode 100644
index 0000000..a804a42
--- /dev/null
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CallbackTest.java
@@ -0,0 +1,178 @@
+package com.path.android.jobqueue.test.jobmanager;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+import com.path.android.jobqueue.RetryConstraint;
+import com.path.android.jobqueue.TagConstraint;
+import com.path.android.jobqueue.callback.JobManagerCallback;
+import com.path.android.jobqueue.test.jobs.DummyJob;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.mockito.Mockito.*;
+
+import org.mockito.ArgumentCaptor;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = com.path.android.jobqueue.BuildConfig.class)
+public class CallbackTest extends JobManagerTestBase {
+    @Test
+    public void successNonPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        Job job = mock(Job.class);
+        doNothing().when(job).onAdded();
+        doNothing().when(job).onRun();
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(job).onAdded();
+        verify(job).onRun();
+        verify(callback).onJobAdded(job);
+        verify(callback).onJobRun(job, JobManagerCallback.RESULT_SUCCEED);
+    }
+
+    @Test
+    public void cancelViaRetryLimit() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        PublicJob job = mock(PublicJob.class);
+        doNothing().when(job).onAdded();
+        doThrow(new Exception()).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.RETRY).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(job);
+        verify(callback, times(2)).onJobRun(job, JobManagerCallback.RESULT_FAIL_WILL_RETRY);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_REACHED_RETRY_LIMIT);
+        verify(callback).onJobCancelled(job, false);
+    }
+
+    @Test
+    public void cancelViaShouldReRun() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        PublicJob job = mock(PublicJob.class);
+        doNothing().when(job).onAdded();
+        doThrow(new Exception()).when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        doReturn(RetryConstraint.CANCEL).when(job).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_VIA_SHOULD_RE_RUN);
+        verify(callback).onJobCancelled(job, false);
+    }
+
+    @Test
+    public void cancelViaCancelCall() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        final CountDownLatch startLatch = new CountDownLatch(1);
+        final CountDownLatch endLatch = new CountDownLatch(1);
+        PublicJob job = spy(new PublicJob(new Params(1).addTags("tag1")) {
+            @Override
+            public void onRun() throws Throwable {
+                startLatch.countDown();
+                Assert.assertThat(endLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
+                throw new Exception("blah");
+            }
+        });
+        doCallRealMethod().when(job).onRun();
+        doReturn(3).when(job).getRetryLimit();
+        verify(job, times(0)).shouldReRunOnThrowable(any(Throwable.class), anyInt(), anyInt());
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        Assert.assertThat(startLatch.await(2, TimeUnit.SECONDS), CoreMatchers.is(true));
+        jobManager.cancelJobsInBackground(null, TagConstraint.ANY, "tag1");
+        Thread.sleep(500); // to ensure cancel request has reached
+        endLatch.countDown();
+        busyDrain(jobManager, 2);
+        Thread.sleep(500); // wait until cancel finishes
+        verify(callback).onJobAdded(job);
+        verify(callback, times(1)).onJobRun(job, JobManagerCallback.RESULT_CANCEL_CANCELLED_WHILE_RUNNING);
+        verify(callback).onJobCancelled(job, true);
+    }
+
+    @Test
+    public void successPersistent() throws Throwable {
+        JobManagerCallback callback = mock(JobManagerCallback.class);
+        Job job = new PersistentDummyJob();
+        JobManager jobManager = createJobManager();
+        jobManager.addCallback(callback);
+        jobManager.addJob(job);
+        busyDrain(jobManager, 2);
+        verify(callback).onJobAdded(any(PersistentDummyJob.class));
+        verify(callback).onJobRun(any(PersistentDummyJob.class), eq(JobManagerCallback.RESULT_SUCCEED));
+    }
+
+    public static class PersistentDummyJob extends Job {
+        public PersistentDummyJob() {
+            super(new Params(1).persist());
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel() {
+
+        }
+    }
+
+    public static class PublicJob extends Job {
+
+        protected PublicJob(Params params) {
+            super(params);
+        }
+
+        @Override
+        public RetryConstraint shouldReRunOnThrowable(Throwable throwable, int runCount, int maxRunCount) {
+            return super.shouldReRunOnThrowable(throwable, runCount, maxRunCount);
+        }
+
+        @Override
+        public int getCurrentRunCount() {
+            return super.getCurrentRunCount();
+        }
+
+        @Override
+        public int getRetryLimit() {
+            return super.getRetryLimit();
+        }
+
+        @Override
+        public void onAdded() {
+
+        }
+
+        @Override
+        public void onRun() throws Throwable {
+
+        }
+
+        @Override
+        protected void onCancel() {
+
+        }
+    }
+}
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
index a94edea..177d5bd 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/CancelFailingJobsTest.java
@@ -49,13 +49,15 @@ public void testCancelAllSyncWithoutNetwork() throws InterruptedException {
 
     public void testCancelWithoutNetwork(boolean async, TagConstraint constraint)
             throws InterruptedException {
+        final int jobCount = 30;
         JobManager jobManager = createJobManager(new Configuration.Builder(RuntimeEnvironment.application)
                 .minConsumerCount(5)
                 .networkUtil(networkUtil));
         networkUtil.setHasNetwork(false, true);
-        jobManager.addJob(new FailingJob(new Params(1).groupBy("group").addTags("tag")));
-        jobManager.addJob(new FailingJob(new Params(2).groupBy("group").addTags("tag")));
-        jobManager.addJob(new FailingJob(new Params(3).groupBy("group").addTags("tag")));
+        for (int i = 0; i < jobCount; i ++) {
+            jobManager.addJob(new FailingJob(new Params(i).groupBy("group").addTags("tag")));
+        }
+
         final CancelResult[] result = new CancelResult[1];
         if (async) {
             final CountDownLatch cancelLatch = new CountDownLatch(1);
@@ -66,12 +68,12 @@ public void onCancelled(CancelResult cancelResult) {
                     cancelLatch.countDown();
                 }
             }, constraint, "tag");
-            cancelLatch.await(2, TimeUnit.SECONDS);
+            assertThat(cancelLatch.await(jobCount, TimeUnit.SECONDS), is(true));
         } else {
             result[0] = jobManager.cancelJobs(TagConstraint.ANY, "tag");
         }
 
-        assertThat("all jobs should be cancelled", result[0].getCancelledJobs().size(), is(3));
+        assertThat("all jobs should be cancelled", result[0].getCancelledJobs().size(), is(jobCount));
         assertThat("no jobs should fail to cancel", result[0].getFailedToCancel().size(), is(0));
         final CountDownLatch runLatch = new CountDownLatch(1);
         jobManager.addJob(new DummyJob(new Params(1).groupBy("group").addTags("tag")) {
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
index 8bf9eb9..0f41871 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobManagerTestBase.java
@@ -15,6 +15,7 @@
 import static org.hamcrest.CoreMatchers.*;
 import org.hamcrest.*;
 import org.junit.After;
+import org.junit.Assert;
 import org.robolectric.*;
 
 import java.util.ArrayList;
@@ -34,6 +35,16 @@ protected JobManager createJobManager() {
         return jobManager;
     }
 
+    public void busyDrain(JobManager jobManager, int limitInSeconds) throws InterruptedException {
+        int totalSleep = 0;
+        while (jobManager.count() > 0 && limitInSeconds * 1000 > totalSleep) {
+            Thread.sleep(100);
+            totalSleep += 100;
+        }
+        jobManager.stopAndWaitUntilConsumersAreFinished();
+        Assert.assertThat(limitInSeconds * 1000 > totalSleep, is(true));
+    }
+
     protected JobManager createJobManager(Configuration.Builder configurationBuilder) {
         final JobManager jobManager = new JobManager(RuntimeEnvironment.application,
                 configurationBuilder.id(UUID.randomUUID().toString()).build());
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
index d6d0c27..95ba3a0 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/JobStatusTest.java
@@ -95,28 +95,33 @@ public void testJobStatus() throws InterruptedException {
             //after all jobs finish, state should be unknown
             assertThat("all jobs finished, states should be unknown", jobManager.getJobStatus(ids[i], jobs[i].isPersistent()), is(JobStatus.UNKNOWN));
         }
-        final long SHORT_SLEEP = 1000;
+        final long SHORT_SLEEP = 2000;
         Job[] delayedJobs = new Job[]{
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP)),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP).persist()),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10)),
                 new DummyJob(new Params(0).delayInMs(SHORT_SLEEP * 10).persist())};
         long[] delayedIds = new long[delayedJobs.length];
+        long start = System.currentTimeMillis();
         for(int i = 0; i < delayedJobs.length; i ++) {
             delayedIds[i] = jobManager.addJob(delayedJobs[i]);
         }
-
+        assertThat("test sanity.", System.currentTimeMillis() - start < SHORT_SLEEP, is(true));
         for(int i = 0; i < delayedJobs.length; i ++) {
-            assertThat("delayed job(" + i + ") should receive not ready status", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+            assertThat("delayed job(" + i + ") should receive not ready status. startMs:" + start
+                            + ", now:" + System.currentTimeMillis() + ", limit:" + SHORT_SLEEP,
+                    jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
         }
         jobManager.stop();
         //sleep
         Thread.sleep(SHORT_SLEEP * 2);
         for(int i = 0; i < delayedJobs.length; i ++) {
             if(delayedJobs[i].getDelayInMs() == SHORT_SLEEP) {
-                assertThat("when enough time passes, delayed jobs should move to ready state", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_READY));
+                assertThat("when enough time passes, delayed jobs should move to ready state",
+                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()),is(JobStatus.WAITING_READY));
             } else {
-                assertThat("delayed job should receive not ready status until their time comes", jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
+                assertThat("delayed job should receive not ready status until their time comes",
+                        jobManager.getJobStatus(delayedIds[i], delayedJobs[i].isPersistent()), is(JobStatus.WAITING_NOT_READY));
             }
         }
     }
diff --git a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
index 981a489..1adfd56 100644
--- a/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
+++ b/jobqueue/src/test/java/com/path/android/jobqueue/test/jobmanager/MultiThreadTest.java
@@ -95,6 +95,7 @@ public void onRun() throws Throwable {
             Thread.sleep((long) (Math.random() * 1000));
             //throw exception w/ small chance
             if(Math.random() < .1) {
+                multiThreadedJobCounter.incrementAndGet();
                 throw new Exception("decided to die, will retry");
             }
             Log.d("DummyJobForMultiThread", "persistent:" + isPersistent() + ", requires network:" + requiresNetwork() + ", running " + id + ", remaining: " + remaining);
@@ -102,7 +103,6 @@ public void onRun() throws Throwable {
 
         @Override
         protected boolean shouldReRunOnThrowable(Throwable throwable) {
-            multiThreadedJobCounter.incrementAndGet();
             return true;
         }
     };
