diff --git a/pom.xml b/pom.xml
index 1fc37b999..ccf1b8604 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,17 +9,17 @@
     <groupId>com.ning</groupId>
     <artifactId>async-http-client</artifactId>
     <name>async-http-client</name>
-    <version>1.6.2-SNAPSHOT</version>
+    <version>1.6.3-SNAPSHOT</version>
     <packaging>jar</packaging>
     <description>
         Async Http Client library purpose is to allow Java applications to easily execute HTTP requests and
         asynchronously process the HTTP responses.
     </description>
-    <url>http://github.com/AsyncHttpClient/async-http-client</url>
+    <url>http://github.com/sonatype/async-http-client</url>
     <scm>
-        <connection>scm:git:git@github.com:AsynHttpClient/async-http-client.git</connection>
-        <url>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</url>
-        <developerConnection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git</developerConnection>
+        <connection>scm:git:git@github.com:sonatype/async-http-client.git</connection>
+        <url>scm:git:git@github.com:sonatype/async-http-client.git</url>
+        <developerConnection>scm:git:git@github.com:sonatype/async-http-client.git</developerConnection>
     </scm>
     <prerequisites>
         <maven>2.0.9</maven>
diff --git a/src/main/java/com/ning/http/client/filter/FilterContext.java b/src/main/java/com/ning/http/client/filter/FilterContext.java
index e8781388a..87e815d75 100644
--- a/src/main/java/com/ning/http/client/filter/FilterContext.java
+++ b/src/main/java/com/ning/http/client/filter/FilterContext.java
@@ -35,7 +35,7 @@
     private final AsyncHandler<T> asyncHandler;
     private final Request request;
     private final HttpResponseStatus responseStatus;
-    private final boolean replayRequest;
+    private final boolean replayRequest ;
     private final IOException ioException;
 
     /**
diff --git a/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java b/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java
index 530844f30..080b80f9a 100644
--- a/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java
+++ b/src/main/java/com/ning/http/client/generators/InputStreamBodyGenerator.java
@@ -75,7 +75,9 @@ public long read(ByteBuffer buffer) throws IOException {
                     buffer.put("\n".getBytes("UTF-8"));
                     return buffer.position();
                 } else {
-                    inputStream.reset();                    
+                    if (inputStream.markSupported()) {
+	                    inputStream.reset();                    
+                    }
                     eof = false;
                 }
                 return -1;
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index a2ea35157..07772e955 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -485,10 +485,15 @@ private static HttpRequest construct(AsyncHttpClientConfig config,
             }
             nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path.toString());
         }
-        if (uri.getPort() == -1) {
-            nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+
+        if (host != null) {
+            if (uri.getPort() == -1) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+            }
         } else {
-            nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+            log.warn("Host for Uri {} was null", uri.getHost());
         }
 
         if (!m.equals(HttpMethod.CONNECT)) {
@@ -865,6 +870,8 @@ private void closeChannel(final ChannelHandlerContext ctx) {
     }
 
     private void finishChannel(final ChannelHandlerContext ctx) {
+        log.debug("Closing Channel {} ", ctx.getChannel());
+        
         ctx.setAttachment(new DiscardEvent());
 
         // The channel may have already been removed if a timeout occurred, and this method may be called just after.
@@ -1224,8 +1231,9 @@ private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc
         final Request newRequest = fc.getRequest();
         future.setAsyncHandler(fc.getAsyncHandler());
         future.setState(NettyResponseFuture.STATE.NEW);
+        future.touch();
 
-        log.debug("\n\nReplayed Request {}\n", newRequest);
+        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
 
         // We must consume the body first in order to re-use the connection.
         if (response != null && response.isChunked()) {
@@ -1265,7 +1273,7 @@ private void abort(NettyResponseFuture<?> future, Throwable t) {
             openChannels.remove(future.channel());
         }
 
-        log.debug("aborting Future {}", future);
+        log.debug("Aborting Future {}\n", future);
         log.debug(t.getMessage(), t);
 
         future.abort(t);
@@ -1317,13 +1325,14 @@ public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws
 
         if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
             NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+            future.touch();
 
             if (config.getIOExceptionFilters().size() > 0) {
                 FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
                         .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
                 fc = handleIoException(fc, future);
 
-                if (fc.replayRequest()) {
+                if (fc.replayRequest() && !future.cannotBeReplay()) {
                     replayRequest(future, fc, null, ctx);
                     return;
                 }
@@ -1355,7 +1364,7 @@ protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future)
         }
 
         if (future == null || future.cannotBeReplay()) {
-            log.debug("Unable to recover request {}\n associated with future {}\n", future == null ? "null" : future.getNettyRequest(), future);
+            log.debug("Unable to recover future {}\n", future);
             return false;
         }
 
@@ -1445,10 +1454,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
         NettyResponseFuture<?> future = null;
 
         if (log.isDebugEnabled()) {
-            log.debug("Exception Caught: {} Attachment was {}",
-                    cause != null ? cause.getMessage() : "unavailable cause",
-                    ctx.getAttachment());
-            log.debug(cause.getMessage(), cause);
+            log.debug("exceptionCaught", cause);
         }
 
         try {
@@ -1460,14 +1466,26 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
             if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
                 future = (NettyResponseFuture<?>) ctx.getAttachment();
                 future.attachChannel(null, false);
+                future.touch();
 
-                if (IOException.class.isAssignableFrom(cause.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                            .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                    fc = handleIoException(fc, future);
+                if (IOException.class.isAssignableFrom(cause.getClass())){
 
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, null, ctx);
+                    if (config.getIOExceptionFilters().size() > 0) {
+                        FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
+                                .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                        fc = handleIoException(fc, future);
+
+                        if (fc.replayRequest()) {
+                            replayRequest(future, fc, null, ctx);
+                            return;
+                        }
+                    } else {
+                        // Close the channel so the recovering can occurs.
+                        try {
+                            ctx.getChannel().close();
+                        } catch (Throwable t) {
+                            ; // Swallow.
+                        }
                         return;
                     }
                 }
@@ -1485,6 +1503,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
 
         if (future != null) {
             try {
+                log.debug("Was unable to recover Future: {}", future);
                 abort(future, cause);
             } catch (Throwable t) {
                 log.error(t.getMessage(), t);
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
index 292642bfa..5db122704 100755
--- a/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyResponseFuture.java
@@ -422,21 +422,21 @@ public boolean cannotBeReplay() {
     public String toString() {
         return "NettyResponseFuture{" +
                 "currentRetry=" + currentRetry +
-                ",\nisDone=" + isDone +
-                ",\nisCancelled=" + isCancelled +
-                ",\nasyncHandler=" + asyncHandler +
-                ",\nresponseTimeoutInMs=" + responseTimeoutInMs +
-                ",\nnettyRequest=" + nettyRequest +
-                ",\ncontent=" + content +
-                ",\nuri=" + uri +
-                ",\nkeepAlive=" + keepAlive +
-                ",\nhttpResponse=" + httpResponse +
-                ",\nexEx=" + exEx +
-                ",\nredirectCount=" + redirectCount +
-                ",\nreaperFuture=" + reaperFuture +
-                ",\ninAuth=" + inAuth +
-                ",\nstatusReceived=" + statusReceived +
-                ",\ntouch=" + touch +
+                ",\n\tisDone=" + isDone +
+                ",\n\tisCancelled=" + isCancelled +
+                ",\n\tasyncHandler=" + asyncHandler +
+                ",\n\tresponseTimeoutInMs=" + responseTimeoutInMs +
+                ",\n\tnettyRequest=" + nettyRequest +
+                ",\n\tcontent=" + content +
+                ",\n\turi=" + uri +
+                ",\n\tkeepAlive=" + keepAlive +
+                ",\n\thttpResponse=" + httpResponse +
+                ",\n\texEx=" + exEx +
+                ",\n\tredirectCount=" + redirectCount +
+                ",\n\treaperFuture=" + reaperFuture +
+                ",\n\tinAuth=" + inAuth +
+                ",\n\tstatusReceived=" + statusReceived +
+                ",\n\ttouch=" + touch +
                 '}';
     }
 
