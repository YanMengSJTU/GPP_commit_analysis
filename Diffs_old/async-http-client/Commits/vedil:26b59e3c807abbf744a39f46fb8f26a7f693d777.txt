diff --git a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
index 0ec44f4f3..6a8d5947c 100644
--- a/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ b/providers/grizzly/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -13,44 +13,34 @@
 
 package com.ning.http.client.providers.grizzly;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.FluentStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.Part;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.UpgradeHandler;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.websocket.WebSocket;
-import com.ning.http.client.websocket.WebSocketByteListener;
-import com.ning.http.client.websocket.WebSocketCloseCodeReasonListener;
-import com.ning.http.client.websocket.WebSocketListener;
-import com.ning.http.client.websocket.WebSocketPingListener;
-import com.ning.http.client.websocket.WebSocketPongListener;
-import com.ning.http.client.websocket.WebSocketTextListener;
-import com.ning.http.client.websocket.WebSocketUpgradeHandler;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
+import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
+import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.InetSocketAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URLEncoder;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+import javax.net.ssl.SSLContext;
 
 import org.glassfish.grizzly.Buffer;
 import org.glassfish.grizzly.CompletionHandler;
@@ -77,13 +67,12 @@
 import org.glassfish.grizzly.http.HttpResponsePacket;
 import org.glassfish.grizzly.http.Method;
 import org.glassfish.grizzly.http.Protocol;
-import org.glassfish.grizzly.impl.FutureImpl;
-import org.glassfish.grizzly.utils.Charsets;
 import org.glassfish.grizzly.http.util.CookieSerializerUtils;
 import org.glassfish.grizzly.http.util.DataChunk;
 import org.glassfish.grizzly.http.util.Header;
 import org.glassfish.grizzly.http.util.HttpStatus;
 import org.glassfish.grizzly.http.util.MimeHeaders;
+import org.glassfish.grizzly.impl.FutureImpl;
 import org.glassfish.grizzly.impl.SafeFutureImpl;
 import org.glassfish.grizzly.memory.Buffers;
 import org.glassfish.grizzly.memory.MemoryManager;
@@ -95,6 +84,7 @@
 import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
 import org.glassfish.grizzly.strategies.WorkerThreadIOStrategy;
 import org.glassfish.grizzly.utils.BufferOutputStream;
+import org.glassfish.grizzly.utils.Charsets;
 import org.glassfish.grizzly.utils.DelayedExecutor;
 import org.glassfish.grizzly.utils.Futures;
 import org.glassfish.grizzly.utils.IdleTimeoutFilter;
@@ -110,33 +100,46 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.net.ssl.SSLContext;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.InetSocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URLEncoder;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.FluentStringsMap;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.MaxRedirectException;
+import com.ning.http.client.Part;
+import com.ning.http.client.PerRequestConfig;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.Realm;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.UpgradeHandler;
+import com.ning.http.client.filter.FilterContext;
+import com.ning.http.client.filter.ResponseFilter;
+import com.ning.http.client.listener.TransferCompletionHandler;
+import com.ning.http.client.ntlm.NTLMEngine;
+import com.ning.http.client.ntlm.NTLMEngineException;
+import com.ning.http.client.websocket.WebSocket;
+import com.ning.http.client.websocket.WebSocketByteListener;
+import com.ning.http.client.websocket.WebSocketCloseCodeReasonListener;
+import com.ning.http.client.websocket.WebSocketListener;
+import com.ning.http.client.websocket.WebSocketPingListener;
+import com.ning.http.client.websocket.WebSocketPongListener;
+import com.ning.http.client.websocket.WebSocketTextListener;
+import com.ning.http.client.websocket.WebSocketUpgradeHandler;
+import com.ning.http.multipart.MultipartRequestEntity;
+import com.ning.http.util.AsyncHttpProviderUtils;
+import com.ning.http.util.AuthenticatorUtils;
+import com.ning.http.util.ProxyUtils;
+import com.ning.http.util.SslUtils;
 
 /**
  * A Grizzly 2.0-based implementation of {@link AsyncHttpProvider}.
@@ -164,7 +167,7 @@
     DelayedExecutor.Resolver<Connection> resolver;
     private DelayedExecutor timeoutExecutor;
 
-
+    private final static NTLMEngine ntlmEngine = new NTLMEngine();
 
 
     // ------------------------------------------------------------ Constructors
@@ -549,7 +552,7 @@ boolean sendRequest(final FilterChainContext ctx,
     throws IOException {
 
         boolean isWriteComplete = true;
-        
+        LOGGER.debug("@@@@@@@@@@@@@@@@@@@@@  sendRequest sending message .... context = "+ctx + " connection is "+ctx.getConnection());
         if (requestHasEntityBody(request)) {
             final HttpTransactionContext context = getHttpTransactionContext(ctx.getConnection());
             BodyHandler handler = bodyHandlerFactory.getBodyHandler(request);
@@ -837,6 +840,8 @@ private boolean sendAsGrizzlyRequest(final Request request,
                                           final FilterChainContext ctx)
         throws IOException {
 
+        	//LOGGER.debug("@@@@@@@@@@@@@@@@@@@@@  sendAsGrizzlyRequest sending message .... context = "+ctx + " connection is "+ctx.getConnection());
+        	
             final HttpTransactionContext httpCtx = getHttpTransactionContext(ctx.getConnection());
             if (isUpgradeRequest(httpCtx.handler) && isWSRequest(httpCtx.requestUrl)) {
                 httpCtx.isWSRequest = true;
@@ -911,15 +916,22 @@ private boolean sendAsGrizzlyRequest(final Request request,
                 boolean avoidProxy = ProxyUtils.avoidProxy(proxy, request);
                 if (!avoidProxy) {
                     if (!requestPacket.getHeaders().contains(Header.ProxyConnection)) {
-                        requestPacket.setHeader(Header.ProxyConnection, "keep-alive");
+                        requestPacket.setHeader(Header.ProxyConnection, "Keep-Alive");
                     }
 
-                    if (proxy.getPrincipal() != null && proxy.isBasic()) {
+                    if(proxy.getNtlmDomain() != null && proxy.getNtlmDomain().length() > 0)
+                    {
+                    	LOGGER.debug("probably ntlm.. not adding header..");
+                    }else if (proxy.getPrincipal() != null && proxy.isBasic()) {
                     	requestPacket.setHeader(Header.ProxyAuthorization, AuthenticatorUtils.computeBasicAuthentication(proxy));
                     }
                     
                 }
             }
+            
+            String userAgent = "Apache-HttpClient/4.2.2 (java 1.5)";
+            requestPacket.setHeader(Header.UserAgent,  userAgent);
+            
             final AsyncHandler h = httpCtx.handler;
             if (h != null) {
                 if (TransferCompletionHandler.class.isAssignableFrom(h.getClass())) {
@@ -928,7 +940,15 @@ private boolean sendAsGrizzlyRequest(final Request request,
                     TransferCompletionHandler.class.cast(h).transferAdapter(new GrizzlyTransferAdapter(map));
                 }
             }
-            return sendRequest(ctx, request, requestPacket);
+            
+            boolean returnVal = false;
+            try{
+            	returnVal = sendRequest(ctx, request, requestPacket); 
+            }catch(RuntimeException e)
+            {
+            	e.printStackTrace();
+            }
+            return returnVal;
 
         }
 
@@ -985,7 +1005,7 @@ private void addHeaders(final Request request,
 
             final MimeHeaders headers = requestPacket.getHeaders();
             if (!headers.contains(Header.Connection)) {
-                requestPacket.addHeader(Header.Connection, "keep-alive");
+                requestPacket.addHeader(Header.Connection, "Keep-Alive");
             }
 
             if (!headers.contains(Header.Accept)) {
@@ -1166,7 +1186,10 @@ protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx)
         protected void onInitialLineParsed(HttpHeader httpHeader,
                                            FilterChainContext ctx) {
 
+        	
             super.onInitialLineParsed(httpHeader, ctx);
+            
+            LOGGER.debug("printing ..... RESPONSE: {}", httpHeader);
             if (httpHeader.isSkipRemainder()) {
                 return;
             }
@@ -1220,7 +1243,10 @@ protected void onInitialLineParsed(HttpHeader httpHeader,
                                                   getURI(context.requestUrl),
                                                   provider);
             context.responseStatus = responseStatus;
+            LOGGER.debug("auth header "+httpHeader.getHeader(Header.ProxyAuthenticate));
+            LOGGER.debug("############### status handler is not null....so returning here "+context.statusHandler);
             if (context.statusHandler != null) {
+            	
                 return;
             }
             if (context.currentState != AsyncHandler.STATE.ABORT) {
@@ -1270,6 +1296,7 @@ protected void onHttpHeadersParsed(HttpHeader httpHeader,
             final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
             
             if (httpHeader.isSkipRemainder() || (context.establishingTunnel && context.statusHandler==null)) {
+            	LOGGER.debug("returning skipping remainder");
                 return;
             }
 
@@ -1385,10 +1412,33 @@ protected void onHttpHeadersParsed(HttpHeader httpHeader,
         protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
 
             boolean result;
-            if (httpHeader.isSkipRemainder()) {
-                clearResponse(ctx.getConnection());
-                cleanup(ctx, provider);
-                return false;
+            LOGGER.debug("onHttpPacketParsed "+ctx + " http header = "+httpHeader);
+            final String proxy_auth = httpHeader.getHeader(Header.ProxyAuthenticate);
+            
+            if (httpHeader.isSkipRemainder() ) {
+            	if(!ProxyAuthorizationHandler.isSecondHandShake(proxy_auth))
+            	{
+	                clearResponse(ctx.getConnection());
+	                cleanup(ctx, provider);
+	                return false;
+            	}else{
+            		LOGGER.debug("!!!!!! onHttpPacketParsed this is second handshake so not cleaning up");
+            		super.onHttpPacketParsed(httpHeader, ctx);
+            		httpHeader.getProcessingState().setKeepAlive(true);
+            		/*final HttpTransactionContext context = provider.getHttpTransactionContext(ctx.getConnection());
+            		final AsyncHandler handler = context.handler;
+                    if (handler != null) {
+                        try {
+                            context.result(handler.onCompleted());
+                        } catch (Exception e) {
+                            context.abort(e);
+                        }
+                    } else {
+                        context.done(null);
+                    }*/
+                    LOGGER.debug("!!!!!! onHttpPacketParsed this is second handshake so not cleaning up ctx = "+ctx);
+            		return false;
+            	}
             }
 
             result = super.onHttpPacketParsed(httpHeader, ctx);
@@ -1498,6 +1548,7 @@ private static boolean isRedirect(final int status) {
 
 
             public boolean handlesStatus(int statusCode) {
+            	LOGGER.debug("inside handle status returning  = "+HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
                 return (HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
             }
 
@@ -1505,7 +1556,8 @@ public boolean handlesStatus(int statusCode) {
             public boolean handleStatus(final HttpResponsePacket responsePacket,
                                      final HttpTransactionContext httpTransactionContext,
                                      final FilterChainContext ctx) {
-
+            	
+            	LOGGER.debug("inside handle status returning context = "+ctx);
                 final String auth = responsePacket.getHeader(Header.WWWAuthenticate);
                 if (auth == null) {
                     throw new IllegalStateException("401 response received, but no WWW-Authenticate header was present");
@@ -1588,6 +1640,7 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
 
 
             public boolean handlesStatus(int statusCode) {
+            	LOGGER.debug("inside proxy handle status returning  "+HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.statusMatches(statusCode));
                 return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.statusMatches(statusCode));
             }
 
@@ -1595,7 +1648,8 @@ public boolean handlesStatus(int statusCode) {
             public boolean handleStatus(final HttpResponsePacket responsePacket,
                                      final HttpTransactionContext httpTransactionContext,
                                      final FilterChainContext ctx) {
-
+            	
+            	LOGGER.debug("inside proxy handle status returning  context = "+ctx);
                 final String proxy_auth = responsePacket.getHeader(Header.ProxyAuthenticate);
                 if (proxy_auth == null) {
                     throw new IllegalStateException("407 response received, but no Proxy Authenticate header was present");
@@ -1631,36 +1685,133 @@ public boolean handleStatus(final HttpResponsePacket responsePacket,
                     } catch (UnsupportedEncodingException e) {
                         throw new IllegalStateException("Unsupported encoding.", e);
                     }
-                } else {
+                }else if (proxy_auth.toLowerCase().startsWith("ntlm")) {
+                    
+                    req.getHeaders().remove(Header.ProxyAuthenticate.toString());
+                    req.getHeaders().remove(Header.ProxyAuthorization.toString());
+                    req.getHeaders().remove(Header.Accept.toString());
+                    req.getHeaders().remove("CLIENT_ID");
+                    String msg = null;
+					try {
+						
+						if(proxy_auth.toLowerCase().equals("ntlm"))
+						{
+							
+							msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(), "");
+							//msg = ApacheNTLMWrapper.generateType1Msg(proxyServer.getNtlmDomain(), "");
+
+						}else {
+							String serverChallenge = proxy_auth.trim().substring("NTLM ".length());
+							//String serverChallenge1 = "TlRMTVNTUAACAAAAEgASADAAAAA1AokgNc3mBXra8i8AAAAAAAAAAIgAiABCAAAAUwBGAEQAQwBQAFIATwBYAFkAAgASAFMARgBEAEMAUABSAE8AWABZAAEAEgBJAFAAQQBTAEUAUgBWAEUAUgAEAB4AcwBmAGQAYwBwAHIAbwB4AHkALgBsAG8AYwBhAGwAAwAyAGkAcABhAHMAZQByAHYAZQByAC4AcwBmAGQAYwBwAHIAbwB4AHkALgBsAG8AYwBhAGwAAAAAAA==";
+							//System.out.println("Server Challenge  :: " + serverChallenge);
+							//System.out.println("Server Challenge1 :: " + serverChallenge1);
+							
+							
+							msg = ntlmEngine.generateType3Msg(principal, password, proxyServer.getNtlmDomain(), proxyServer.getHost(), serverChallenge);
+							//msg = ApacheNTLMWrapper.generateType3Msg(principal, password, proxyServer.getNtlmDomain(), "", serverChallenge);
+							//msg = "TlRMTVNTUAADAAAAGAAYAEAAAAC0ALQAWAAAABIAEgAMAQAACgAKAB4BAAAAAAAAKAEAAAAAAAAoAQAANQIIIGYSPmcl/CPV8YAkN+5e1A1MmwI0Ekz0aS41p9y413TiBLJA82wTL4UBAQAAAAAAAJD+rq/r8s0BTJsCNBJM9GkAAAAAAgASAFMARgBEAEMAUABSAE8AWABZAAEAEgBJAFAAQQBTAEUAUgBWAEUAUgAEAB4AcwBmAGQAYwBwAHIAbwB4AHkALgBsAG8AYwBhAGwAAwAyAGkAcABhAHMAZQByAHYAZQByAC4AcwBmAGQAYwBwAHIAbwB4AHkALgBsAG8AYwBhAGwAAAAAAFMARgBEAEMAUABSAE8AWABZAHUAcwBlAHIANQA=";
+						}
+						
+						req.getHeaders().add(Header.ProxyAuthorization.toString(), "NTLM " + msg);
+					} catch (Exception e1) {
+						e1.printStackTrace();
+					}
+                }  else {
                     throw new IllegalStateException("Unsupported authorization method: " + proxy_auth);
                 }
 
                 final ConnectionManager m = httpTransactionContext.provider.connectionManager;
+                InvocationStatus tempInvocationStatus = InvocationStatus.STOP;
+                
                 try {
-                    final Connection c = m.obtainConnection(req,
-                                                            httpTransactionContext.future);
-                    final HttpTransactionContext newContext =
-                            httpTransactionContext.copy();
-                    httpTransactionContext.future = null;
-                    httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
-                    newContext.invocationStatus = InvocationStatus.STOP;
-                    try {
-                        httpTransactionContext.provider.execute(c,
-                                                                req,
-                                                                httpTransactionContext.handler,
-                                                                httpTransactionContext.future);
-                        return false;
-                    } catch (IOException ioe) {
-                        newContext.abort(ioe);
-                        return false;
+                    
+                	/*if(proxy_auth.toLowerCase().startsWith("ntlm") && !isSecondHandShake(proxy_auth))
+                	{
+                		httpTransactionContext.done(null);
+                	}*/
+                	
+                    if(proxy_auth.toLowerCase().startsWith("ntlm"))
+                    //if(isSecondHandShake(proxy_auth))
+                    {
+                    	tempInvocationStatus = InvocationStatus.CONTINUE;
+                    	
+                    }
+                    
+                    if(isSecondHandShake(proxy_auth))
+                    {
+                    	final Connection c = ctx.getConnection();
+                        final HttpTransactionContext newContext = httpTransactionContext.copy(); //httpTransactionContext.copy();
+                     
+                        tempInvocationStatus = InvocationStatus.STOP;
+                        
+                        LOGGER.debug("is connection cacheable "+m.isConnectionCacheable(c));
+                        httpTransactionContext.future = null;
+                        httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
+                        
+                        newContext.invocationStatus = tempInvocationStatus;
+                        httpTransactionContext.establishingTunnel = true;
+                        
+                    	try {
+	                        httpTransactionContext.provider.execute(c,
+	                                                                req,
+	                                                                httpTransactionContext.handler,
+	                                                                httpTransactionContext.future);
+	                        return false;
+	                    } catch (IOException ioe) {
+	                    	ioe.printStackTrace();
+	                        newContext.abort(ioe);
+	                        return false;
+	                    }
+                    	
+                    	/*final Connection c = m.obtainConnection(req, httpTransactionContext.future);
+                        final HttpTransactionContext newContext = httpTransactionContext.copy();
+                        httpTransactionContext.future = null;
+                        httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
+                        
+                        newContext.invocationStatus = tempInvocationStatus;
+                        
+	                    try {
+	                        httpTransactionContext.provider.execute(c,
+	                                                                req,
+	                                                                httpTransactionContext.handler,
+	                                                                httpTransactionContext.future);
+	                        return false;
+	                    } catch (IOException ioe) {
+	                        newContext.abort(ioe);
+	                        return false;
+	                    }*/
+                    }
+                    else{
+                    	final Connection c = m.obtainConnection(req, httpTransactionContext.future);
+                        final HttpTransactionContext newContext = httpTransactionContext.copy();
+                        httpTransactionContext.future = null;
+                        httpTransactionContext.provider.setHttpTransactionContext(c, newContext);
+                        
+                        newContext.invocationStatus = tempInvocationStatus;
+                        
+	                    try {
+	                        httpTransactionContext.provider.execute(c,
+	                                                                req,
+	                                                                httpTransactionContext.handler,
+	                                                                httpTransactionContext.future);
+	                        return false;
+	                    } catch (IOException ioe) {
+	                        newContext.abort(ioe);
+	                        return false;
+	                    }
                     }
                 } catch (Exception e) {
                     httpTransactionContext.abort(e);
                 }
-                httpTransactionContext.invocationStatus = InvocationStatus.STOP;
+                httpTransactionContext.invocationStatus = tempInvocationStatus;
                 return false;
             }
 
+			public static boolean isSecondHandShake(final String proxy_auth) {
+				return (proxy_auth.toLowerCase().startsWith("ntlm") && !proxy_auth.equalsIgnoreCase("ntlm"));
+				//return proxy_auth.toLowerCase().startsWith("ntlm");
+			}
+
         } // END AuthorizationHandler
 
 
@@ -2589,6 +2740,7 @@ public boolean acquire() {
             @Override
             public void onClosed(Connection connection, Connection.CloseType closeType) throws IOException {
 
+            	LOGGER.debug("!!!!!!!!!!!!!!!! close getting invoked..... connection = "+connection+" closetype "+closeType);
                 if (connections != null) {
                     connections.release();
                 }
