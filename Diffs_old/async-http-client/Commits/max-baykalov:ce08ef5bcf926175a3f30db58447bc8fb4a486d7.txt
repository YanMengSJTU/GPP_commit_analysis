diff --git a/client/pom.xml b/client/pom.xml
index 41c9c747d..c8a75a235 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -16,8 +16,8 @@
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>3.6.1</version>
                 <configuration>
-                    <source>1.8</source>
-                    <target>1.8</target>
+                    <source>1.7</source>
+                    <target>1.7</target>
                 </configuration>
             </plugin>
         </plugins>
diff --git a/client/src/main/java/Main.java b/client/src/main/java/Main.java
new file mode 100644
index 000000000..fef4451fe
--- /dev/null
+++ b/client/src/main/java/Main.java
@@ -0,0 +1,30 @@
+import java.util.concurrent.Future;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.Response;
+
+public class Main {
+
+	public static void main(String[] args) {
+		System.out.println(performHttpGet("", "").getStatusCode());
+		
+	}
+	
+	private static Response performHttpGet(String sni, String fullUrl) {
+
+        AsyncHttpClient c = new DefaultAsyncHttpClient();
+
+        try {
+            Future<Response> f = c.prepareGet("https://www.google.com.ua/")
+            		.setVirtualHost("asd")
+                    .execute();
+
+            return f.get();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+}
diff --git a/client/src/main/java/javatest/added/BiConsumer.java b/client/src/main/java/javatest/added/BiConsumer.java
new file mode 100644
index 000000000..ac1f401c4
--- /dev/null
+++ b/client/src/main/java/javatest/added/BiConsumer.java
@@ -0,0 +1,16 @@
+package javatest.added;
+/**
+ * A functional interface (callback) that accepts two values (of possibly different types).
+ * @param <T1> the first value type
+ * @param <T2> the second value type
+ */
+public interface BiConsumer<T1, T2> {
+
+    /**
+     * Performs an operation on the given values.
+     * @param t1 the first value
+     * @param t2 the second value
+     * @throws Exception on error
+     */
+    void accept(T1 t1, T2 t2) throws Exception;
+}
\ No newline at end of file
diff --git a/client/src/main/java/javatest/added/CompletableFuture.java b/client/src/main/java/javatest/added/CompletableFuture.java
index 44808f508..7ab794302 100644
--- a/client/src/main/java/javatest/added/CompletableFuture.java
+++ b/client/src/main/java/javatest/added/CompletableFuture.java
@@ -15,7 +15,7 @@
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-import io.reactivex.functions.BiConsumer;
+
 
 public class CompletableFuture<T> implements Future<T>, CompletionStage<T> {
 
@@ -194,15 +194,16 @@ final boolean completeRelay(Object r) {
     public static interface AsynchronousCompletionTask {
     }
 
-    private static final boolean useCommonPool =
-        (ForkJoinPool.getCommonPoolParallelism() > 1);
+    private static final boolean useCommonPool = true;
+        //(ForkJoinPool.getCommonPoolParallelism() > 1);////////////////////////////
 
     /**
      * Default executor -- ForkJoinPool.commonPool() unless it cannot
      * support parallelism.
      */
-    private static final Executor asyncPool = useCommonPool ?
-        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();
+    private static final Executor asyncPool = 
+    		//useCommonPool ? ForkJoinPool.commonPool() :
+        	new ThreadPerTaskExecutor();
 
     /** Fallback if ForkJoinPool.commonPool() cannot support parallelism */
     static final class ThreadPerTaskExecutor implements Executor {
@@ -214,7 +215,8 @@ final boolean completeRelay(Object r) {
      * commonPool to asyncPool in case parallelism disabled.
      */
     static Executor screenExecutor(Executor e) {
-        if (!useCommonPool && e == ForkJoinPool.commonPool())
+        if (!useCommonPool// && e == ForkJoinPool.commonPool()
+        		)
             return asyncPool;
         if (e == null) throw new NullPointerException();
         return e;
@@ -326,7 +328,8 @@ else if (p == null) {
          */
         final boolean claim() {
             Executor e = executor;
-            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) {
+            if (true //compareAndSetForkJoinTaskTag((short)0, (short)1)
+            		) {
                 if (e == null)
                     return true;
                 executor = null; // disable
@@ -586,7 +589,7 @@ final boolean uniWhenComplete(CompletableFuture<T> a,
         }
         return d;
     }
-//
+
 //    @SuppressWarnings("serial")
 //    static final class UniHandle<T,V> extends UniCompletion<T,V> {
 //        BiFunction<? super T, Throwable, ? extends V> fn;
@@ -1012,53 +1015,54 @@ final void bipush(CompletableFuture<?> b, BiCompletion<?,?,?> c) {
         }
         final CompletableFuture<Void> tryFire(int mode) {
             CompletableFuture<Void> d;
-            CompletableFuture<T> a;
-            CompletableFuture<U> b;
-            if ((d = dep) == null ||
-                !d.biRun(a = src, b = snd, fn, mode > 0 ? null : this))
+            CompletableFuture<T> a = src;
+            CompletableFuture<U> b = snd;
+            if ((d = dep) == null //||
+                //!d.biRun(a = src, b = snd, fn, mode > 0 ? null : this)
+            		)
                 return null;
             dep = null; src = null; snd = null; fn = null;
             return d.postFire(a, b, mode);
         }
     }
 
-    final boolean biRun(CompletableFuture<?> a, CompletableFuture<?> b,
-                        Runnable f, BiRun<?,?> c) {
-        Object r, s; Throwable x;
-        if (a == null || (r = a.result) == null ||
-            b == null || (s = b.result) == null || f == null)
-            return false;
-        if (result == null) {
-            if (r instanceof AltResult && (x = ((AltResult)r).ex) != null)
-                completeThrowable(x, r);
-            else if (s instanceof AltResult && (x = ((AltResult)s).ex) != null)
-                completeThrowable(x, s);
-            else
-                try {
-                    if (c != null && !c.claim())
-                        return false;
-                    f.run();
-                    completeNull();
-                } catch (Throwable ex) {
-                    completeThrowable(ex);
-                }
-        }
-        return true;
-    }
-
-    private CompletableFuture<Void> biRunStage(Executor e, CompletionStage<?> o,
-                                               Runnable f) {
-        CompletableFuture<?> b;
-        if (f == null || (b = o.toCompletableFuture()) == null)
-            throw new NullPointerException();
-        CompletableFuture<Void> d = new CompletableFuture<Void>();
-        if (e != null || !d.biRun(this, b, f, null)) {
-            BiRun<T,?> c = new BiRun<>(e, d, this, b, f);
-            bipush(b, c);
-            c.tryFire(SYNC);
-        }
-        return d;
-    }
+//    final boolean biRun(CompletableFuture<?> a, CompletableFuture<?> b,
+//                        Runnable f, BiRun<?,?> c) {
+//        Object r, s; Throwable x;
+//        if (a == null || (r = a.result) == null ||
+//            b == null || (s = b.result) == null || f == null)
+//            return false;
+//        if (result == null) {
+//            if (r instanceof AltResult && (x = ((AltResult)r).ex) != null)
+//                completeThrowable(x, r);
+//            else if (s instanceof AltResult && (x = ((AltResult)s).ex) != null)
+//                completeThrowable(x, s);
+//            else
+//                try {
+//                    if (c != null && !c.claim())
+//                        return false;
+//                    f.run();
+//                    completeNull();
+//                } catch (Throwable ex) {
+//                    completeThrowable(ex);
+//                }
+//        }
+//        return true;
+//    }
+//
+//    private CompletableFuture<Void> biRunStage(Executor e, CompletionStage<?> o,
+//                                               Runnable f) {
+//        CompletableFuture<?> b;
+//        if (f == null || (b = o.toCompletableFuture()) == null)
+//            throw new NullPointerException();
+//        CompletableFuture<Void> d = new CompletableFuture<Void>();
+//        if (e != null || !d.biRun(this, b, f, null)) {
+//            BiRun<T,?> c = new BiRun<>(e, d, this, b, f);
+//            bipush(b, c);
+//            c.tryFire(SYNC);
+//        }
+//        return d;
+//    }
 
     @SuppressWarnings("serial")
     static final class BiRelay<T,U> extends BiCompletion<T,U,Void> { // for And
@@ -1264,64 +1268,64 @@ final void orpush(CompletableFuture<?> b, BiCompletion<?,?,?> c) {
 //        }
 //        return d;
 //    }
-
-    @SuppressWarnings("serial")
-    static final class OrRun<T,U> extends BiCompletion<T,U,Void> {
-        Runnable fn;
-        OrRun(Executor executor, CompletableFuture<Void> dep,
-              CompletableFuture<T> src,
-              CompletableFuture<U> snd,
-              Runnable fn) {
-            super(executor, dep, src, snd); this.fn = fn;
-        }
-        final CompletableFuture<Void> tryFire(int mode) {
-            CompletableFuture<Void> d;
-            CompletableFuture<T> a;
-            CompletableFuture<U> b;
-            if ((d = dep) == null ||
-                !d.orRun(a = src, b = snd, fn, mode > 0 ? null : this))
-                return null;
-            dep = null; src = null; snd = null; fn = null;
-            return d.postFire(a, b, mode);
-        }
-    }
-
-    final boolean orRun(CompletableFuture<?> a, CompletableFuture<?> b,
-                        Runnable f, OrRun<?,?> c) {
-        Object r; Throwable x;
-        if (a == null || b == null ||
-            ((r = a.result) == null && (r = b.result) == null) || f == null)
-            return false;
-        if (result == null) {
-            try {
-                if (c != null && !c.claim())
-                    return false;
-                if (r instanceof AltResult && (x = ((AltResult)r).ex) != null)
-                    completeThrowable(x, r);
-                else {
-                    f.run();
-                    completeNull();
-                }
-            } catch (Throwable ex) {
-                completeThrowable(ex);
-            }
-        }
-        return true;
-    }
-
-    private CompletableFuture<Void> orRunStage(Executor e, CompletionStage<?> o,
-                                               Runnable f) {
-        CompletableFuture<?> b;
-        if (f == null || (b = o.toCompletableFuture()) == null)
-            throw new NullPointerException();
-        CompletableFuture<Void> d = new CompletableFuture<Void>();
-        if (e != null || !d.orRun(this, b, f, null)) {
-            OrRun<T,?> c = new OrRun<>(e, d, this, b, f);
-            orpush(b, c);
-            c.tryFire(SYNC);
-        }
-        return d;
-    }
+//
+//    @SuppressWarnings("serial")
+//    static final class OrRun<T,U> extends BiCompletion<T,U,Void> {
+//        Runnable fn;
+//        OrRun(Executor executor, CompletableFuture<Void> dep,
+//              CompletableFuture<T> src,
+//              CompletableFuture<U> snd,
+//              Runnable fn) {
+//            super(executor, dep, src, snd); this.fn = fn;
+//        }
+//        final CompletableFuture<Void> tryFire(int mode) {
+//            CompletableFuture<Void> d;
+//            CompletableFuture<T> a;
+//            CompletableFuture<U> b;
+//            if ((d = dep) == null ||
+//                !d.orRun(a = src, b = snd, fn, mode > 0 ? null : this))
+//                return null;
+//            dep = null; src = null; snd = null; fn = null;
+//            return d.postFire(a, b, mode);
+//        }
+//    }
+//
+//    final boolean orRun(CompletableFuture<?> a, CompletableFuture<?> b,
+//                        Runnable f, OrRun<?,?> c) {
+//        Object r; Throwable x;
+//        if (a == null || b == null ||
+//            ((r = a.result) == null && (r = b.result) == null) || f == null)
+//            return false;
+//        if (result == null) {
+//            try {
+//                if (c != null && !c.claim())
+//                    return false;
+//                if (r instanceof AltResult && (x = ((AltResult)r).ex) != null)
+//                    completeThrowable(x, r);
+//                else {
+//                    f.run();
+//                    completeNull();
+//                }
+//            } catch (Throwable ex) {
+//                completeThrowable(ex);
+//            }
+//        }
+//        return true;
+//    }
+//
+//    private CompletableFuture<Void> orRunStage(Executor e, CompletionStage<?> o,
+//                                               Runnable f) {
+//        CompletableFuture<?> b;
+//        if (f == null || (b = o.toCompletableFuture()) == null)
+//            throw new NullPointerException();
+//        CompletableFuture<Void> d = new CompletableFuture<Void>();
+//        if (e != null || !d.orRun(this, b, f, null)) {
+//            OrRun<T,?> c = new OrRun<>(e, d, this, b, f);
+//            orpush(b, c);
+//            c.tryFire(SYNC);
+//        }
+//        return d;
+//    }
 
     @SuppressWarnings("serial")
     static final class OrRelay<T,U> extends BiCompletion<T,U,Object> { // for Or
@@ -1643,9 +1647,9 @@ private CompletableFuture(Object r) {
      * returned CompletableFuture
      * @return the new CompletableFuture
      */
-    public static CompletableFuture<Void> runAsync(Runnable runnable) {
-        return asyncRunStage(asyncPool, runnable);
-    }
+//    public static CompletableFuture<Void> runAsync(Runnable runnable) {
+//        return asyncRunStage(asyncPool, runnable);
+//    }
 
     /**
      * Returns a new CompletableFuture that is asynchronously completed
@@ -1657,10 +1661,10 @@ private CompletableFuture(Object r) {
      * @param executor the executor to use for asynchronous execution
      * @return the new CompletableFuture
      */
-    public static CompletableFuture<Void> runAsync(Runnable runnable,
-                                                   Executor executor) {
-        return asyncRunStage(screenExecutor(executor), runnable);
-    }
+//    public static CompletableFuture<Void> runAsync(Runnable runnable,
+//                                                   Executor executor) {
+//        return asyncRunStage(screenExecutor(executor), runnable);
+//    }
 
     /**
      * Returns a new CompletableFuture that is already completed with
@@ -1942,7 +1946,7 @@ public boolean completeExceptionally(Throwable ex) {
         BiConsumer<? super T, ? super Throwable> action, Executor executor) {
         return uniWhenCompleteStage(screenExecutor(executor), action);
     }
-//
+
 //    public <U> CompletableFuture<U> handle(
 //        BiFunction<? super T, Throwable, ? extends U> fn) {
 //        return uniHandleStage(null, fn);
diff --git a/client/src/main/java/javatest/added/ThreadLocalRandom.java b/client/src/main/java/javatest/added/ThreadLocalRandom.java
index 7a895e00a..68da69ca2 100644
--- a/client/src/main/java/javatest/added/ThreadLocalRandom.java
+++ b/client/src/main/java/javatest/added/ThreadLocalRandom.java
@@ -1038,8 +1038,8 @@ private Object readResolve() {
         }
     }
     
-    @SuppressWarnings("restriction")
-    private static Unsafe getUnsafe() {
+
+    static Unsafe getUnsafe() {
         try {
 
             Field singleoneInstanceField = Unsafe.class.getDeclaredField("theUnsafe");
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 3d0015268..86e0f6d0b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -17,7 +17,7 @@
 import io.netty.channel.Channel;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-import io.reactivex.functions.BiConsumer;
+import javatest.added.BiConsumer;
 import javatest.added.CompletableFuture;
 
 import java.io.IOException;
