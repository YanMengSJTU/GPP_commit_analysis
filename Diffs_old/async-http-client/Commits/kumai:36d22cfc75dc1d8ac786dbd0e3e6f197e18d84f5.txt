diff --git a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
index cce848102..068cf267c 100644
--- a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyAsyncHttpProvider.java
@@ -18,6 +18,7 @@
 import com.ning.http.client.AsyncHttpProvider;
 import com.ning.http.client.Body;
 import com.ning.http.client.BodyGenerator;
+import com.ning.http.client.ConnectionPoolKeyStrategy;
 import com.ning.http.client.ConnectionsPool;
 import com.ning.http.client.Cookie;
 import com.ning.http.client.FluentCaseInsensitiveStringsMap;
@@ -1430,7 +1431,7 @@ private static HttpTransactionContext cleanup(final FilterChainContext ctx,
             if (!context.provider.connectionManager.canReturnConnection(c)) {
                 context.abort(new IOException("Maximum pooled connections exceeded"));
             } else {
-                if (!context.provider.connectionManager.returnConnection(context.requestUrl, c)) {
+                if (!context.provider.connectionManager.returnConnection(context.request, c)) {
                     ctx.getConnection().close();
                 }
             }
@@ -2305,7 +2306,7 @@ void doAsyncTrackedConnection(final Request request,
                                       final CompletionHandler<Connection> connectHandler)
         throws IOException, ExecutionException, InterruptedException {
             final String url = request.getUrl();
-            Connection c = pool.poll(AsyncHttpProviderUtils.getBaseUrl(url));
+            Connection c = pool.poll(getPoolKey(request));
             if (c == null) {
                 if (!connectionMonitor.acquire()) {
                     throw new IOException("Max connections exceeded");
@@ -2390,9 +2391,9 @@ private ProxyServer getProxyServer(Request request) {
 
         }
 
-        boolean returnConnection(final String url, final Connection c) {
+        boolean returnConnection(final Request request, final Connection c) {
             final boolean result = (DO_NOT_CACHE.get(c) == null
-                                       && pool.offer(AsyncHttpProviderUtils.getBaseUrl(url), c));
+                                       && pool.offer(getPoolKey(request), c));
             if (result) {
                 if (provider.resolver != null) {
                     provider.resolver.setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
@@ -2453,6 +2454,11 @@ public void updated(Connection result) {
             };
         }
 
+        private static String getPoolKey(final Request request) {
+            final ConnectionPoolKeyStrategy keyStrategy = request.getConnectionPoolKeyStrategy();
+            return keyStrategy.getKey(AsyncHttpProviderUtils.createUri(AsyncHttpProviderUtils.getBaseUrl(request.getUrl())));
+        }
+
         // ------------------------------------------------------ Nested Classes
 
         private static class ConnectionMonitor implements Connection.CloseListener {
