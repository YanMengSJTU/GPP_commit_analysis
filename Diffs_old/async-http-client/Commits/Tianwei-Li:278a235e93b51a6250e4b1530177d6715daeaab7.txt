diff --git a/client/src/main/java/org/asynchttpclient/AdvancedConfig.java b/client/src/main/java/org/asynchttpclient/AdvancedConfig.java
deleted file mode 100644
index b804df474..000000000
--- a/client/src/main/java/org/asynchttpclient/AdvancedConfig.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.Timer;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.asynchttpclient.channel.pool.ConnectionStrategy;
-import org.asynchttpclient.netty.EagerNettyResponseBodyPart;
-import org.asynchttpclient.netty.LazyNettyResponseBodyPart;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.netty.handler.DefaultConnectionStrategy;
-import org.asynchttpclient.netty.ws.NettyWebSocket;
-
-public class AdvancedConfig {
-
-    private final Map<ChannelOption<Object>, Object> channelOptions;
-    private final EventLoopGroup eventLoopGroup;
-    private final boolean preferNative;
-    private final AdditionalPipelineInitializer httpAdditionalPipelineInitializer;
-    private final AdditionalPipelineInitializer wsAdditionalPipelineInitializer;
-    private final ResponseBodyPartFactory responseBodyPartFactory;
-    private final ChannelPool channelPool;
-    private final Timer nettyTimer;
-    private final NettyWebSocketFactory nettyWebSocketFactory;
-    private final ConnectionStrategy connectionStrategy;
-
-    public AdvancedConfig(//
-            Map<ChannelOption<Object>, Object> channelOptions,//
-            EventLoopGroup eventLoopGroup,//
-            boolean preferNative,//
-            AdditionalPipelineInitializer httpAdditionalPipelineInitializer,//
-            AdditionalPipelineInitializer wsAdditionalPipelineInitializer,//
-            ResponseBodyPartFactory responseBodyPartFactory,//
-            ChannelPool channelPool,//
-            Timer nettyTimer,//
-            NettyWebSocketFactory nettyWebSocketFactory,//
-            ConnectionStrategy connectionStrategy) {
-
-        if (responseBodyPartFactory == null)
-            throw new NullPointerException("responseBodyPartFactory");
-        if (nettyWebSocketFactory == null)
-            throw new NullPointerException("nettyWebSocketFactory");
-        if (connectionStrategy == null)
-            throw new NullPointerException("connectionStrategy");
-
-        this.channelOptions = channelOptions;
-        this.eventLoopGroup = eventLoopGroup;
-        this.preferNative = preferNative;
-        this.httpAdditionalPipelineInitializer = httpAdditionalPipelineInitializer;
-        this.wsAdditionalPipelineInitializer = wsAdditionalPipelineInitializer;
-        this.responseBodyPartFactory = responseBodyPartFactory;
-        this.channelPool = channelPool;
-        this.nettyTimer = nettyTimer;
-        this.nettyWebSocketFactory = nettyWebSocketFactory;
-        this.connectionStrategy = connectionStrategy;
-    }
-
-    public Map<ChannelOption<Object>, Object> getChannelOptions() {
-        return channelOptions;
-    }
-
-    public EventLoopGroup getEventLoopGroup() {
-        return eventLoopGroup;
-    }
-
-    public boolean isPreferNative() {
-        return preferNative;
-    }
-
-    public AdditionalPipelineInitializer getHttpAdditionalPipelineInitializer() {
-        return httpAdditionalPipelineInitializer;
-    }
-
-    public AdditionalPipelineInitializer getWsAdditionalPipelineInitializer() {
-        return wsAdditionalPipelineInitializer;
-    }
-
-    public ResponseBodyPartFactory getResponseBodyPartFactory() {
-        return responseBodyPartFactory;
-    }
-
-    public ChannelPool getChannelPool() {
-        return channelPool;
-    }
-
-    public Timer getNettyTimer() {
-        return nettyTimer;
-    }
-
-    public NettyWebSocketFactory getNettyWebSocketFactory() {
-        return nettyWebSocketFactory;
-    }
-
-    public ConnectionStrategy getConnectionStrategy() {
-        return connectionStrategy;
-    }
-
-    public static class Builder {
-
-        private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
-        private EventLoopGroup eventLoopGroup;
-        private boolean preferNative;
-        private AdditionalPipelineInitializer httpAdditionalPipelineInitializer;
-        private AdditionalPipelineInitializer wsAdditionalPipelineInitializer;
-        private ResponseBodyPartFactory responseBodyPartFactory = new EagerResponseBodyPartFactory();
-        private ChannelPool channelPool;
-        private Timer nettyTimer;
-        private NettyWebSocketFactory nettyWebSocketFactory = new DefaultNettyWebSocketFactory();
-        private ConnectionStrategy connectionStrategy = new DefaultConnectionStrategy();
-
-        /**
-         * @param name the name of the ChannelOption
-         * @param value the value of the ChannelOption
-         * @param <T> the type of value
-         * @return this instance of AdvancedConfig
-         */
-        @SuppressWarnings("unchecked")
-        public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
-            channelOptions.put((ChannelOption<Object>) name, value);
-            return this;
-        }
-
-        public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
-            this.eventLoopGroup = eventLoopGroup;
-            return this;
-        }
-
-        public Builder setPreferNative(boolean preferNative) {
-            this.preferNative = preferNative;
-            return this;
-        }
-
-        public Builder setHttpAdditionalPipelineInitializer(AdditionalPipelineInitializer httpAdditionalPipelineInitializer) {
-            this.httpAdditionalPipelineInitializer = httpAdditionalPipelineInitializer;
-            return this;
-        }
-
-        public Builder setWsAdditionalPipelineInitializer(AdditionalPipelineInitializer wsAdditionalPipelineInitializer) {
-            this.wsAdditionalPipelineInitializer = wsAdditionalPipelineInitializer;
-            return this;
-        }
-
-        public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
-            this.responseBodyPartFactory = responseBodyPartFactory;
-            return this;
-        }
-
-        public Builder setChannelPool(ChannelPool channelPool) {
-            this.channelPool = channelPool;
-            return this;
-        }
-
-        public Builder setNettyTimer(Timer nettyTimer) {
-            this.nettyTimer = nettyTimer;
-            return this;
-        }
-
-        public Builder setNettyWebSocketFactory(NettyWebSocketFactory nettyWebSocketFactory) {
-            this.nettyWebSocketFactory = nettyWebSocketFactory;
-            return this;
-        }
-
-        public Builder setConnectionStrategy(ConnectionStrategy connectionStrategy) {
-            this.connectionStrategy = connectionStrategy;
-            return this;
-        }
-
-        public AdvancedConfig build() {
-            return new AdvancedConfig(//
-                    channelOptions,//
-                    eventLoopGroup,//
-                    preferNative,//
-                    httpAdditionalPipelineInitializer,//
-                    wsAdditionalPipelineInitializer,//
-                    responseBodyPartFactory,//
-                    channelPool,//
-                    nettyTimer,//
-                    nettyWebSocketFactory,//
-                    connectionStrategy);
-        }
-    }
-
-    public static interface AdditionalPipelineInitializer {
-
-        void initPipeline(ChannelPipeline pipeline) throws Exception;
-    }
-
-    public static interface ResponseBodyPartFactory {
-
-        NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
-    }
-
-    public static class EagerResponseBodyPartFactory implements ResponseBodyPartFactory {
-
-        @Override
-        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-            return new EagerNettyResponseBodyPart(buf, last);
-        }
-    }
-
-    public static class LazyResponseBodyPartFactory implements ResponseBodyPartFactory {
-
-        @Override
-        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-            return new LazyNettyResponseBodyPart(buf, last);
-        }
-    }
-
-    public static interface NettyWebSocketFactory {
-        NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config);
-    }
-
-    public static class DefaultNettyWebSocketFactory implements NettyWebSocketFactory {
-
-        @Override
-        public NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config) {
-            return new NettyWebSocket(channel, config);
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHandler.java b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
index 352e363c6..26d9ae685 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -74,7 +74,7 @@
      * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
      *
      * @param bodyPart response's body part.
-     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing. Aborting will also close the connection.
      * @throws Exception if something wrong happens
      */
     State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index 6a92878f1..b778070f7 100755
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -222,6 +222,14 @@
      * @return {@link RequestBuilder}
      */
     BoundRequestBuilder prepareRequest(Request request);
+    
+    /**
+     * Construct a {@link RequestBuilder} using a {@link RequestBuilder}
+     *
+     * @param requestBuilder a {@link RequestBuilder}
+     * @return {@link RequestBuilder}
+     */
+    BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder);
 
     /**
      * Execute an HTTP request.
@@ -232,6 +240,16 @@
      * @return a {@link Future} of type T
      */
     <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
+    
+    /**
+     * Execute an HTTP request.
+     *
+     * @param requestBuilder {@link RequestBuilder}
+     * @param handler an instance of {@link AsyncHandler}
+     * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
+     * @return a {@link Future} of type T
+     */
+    <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler);
 
     /**
      * Execute an HTTP request.
@@ -240,4 +258,12 @@
      * @return a {@link Future} of type Response
      */
     ListenableFuture<Response> executeRequest(Request request);
+    
+    /**
+     * Execute an HTTP request.
+     *
+     * @param requestBuilder {@link RequestBuilder}
+     * @return a {@link Future} of type Response
+     */
+    ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder);
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index cf766a19e..ad85a6189 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -1,14 +1,23 @@
 package org.asynchttpclient;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.ssl.SslContext;
+import io.netty.util.Timer;
+
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ThreadFactory;
 
-import javax.net.ssl.SSLContext;
-
-import org.asynchttpclient.channel.SSLEngineFactory;
+import org.asynchttpclient.channel.pool.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.netty.EagerNettyResponseBodyPart;
+import org.asynchttpclient.netty.LazyNettyResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
@@ -21,20 +30,13 @@
     String getAhcVersion();
 
     /**
-     * Return the name of {@link AsyncHttpClient}, which is used for thread naming
-     * and debugging.
+     * Return the name of {@link AsyncHttpClient}, which is used for thread
+     * naming and debugging.
      *
      * @return the name.
      */
     String getThreadPoolName();
 
-    /**
-     * Return the name of {@link AsyncHttpClient}, or default string if name is null or empty.
-     *
-     * @return the name.
-     */
-    String getThreadPoolNameOrDefault();
-
     /**
      * Return the maximum number of connections an {@link AsyncHttpClient} can
      * handle.
@@ -62,17 +64,6 @@
      */
     int getConnectTimeout();
 
-    /**
-     * Return the maximum time, in milliseconds, a
-     * {@link org.asynchttpclient.ws.WebSocket} may be idle before being timed
-     * out.
-     * 
-     * @return the maximum time, in milliseconds, a
-     *         {@link org.asynchttpclient.ws.WebSocket} may be idle before being
-     *         timed out.
-     */
-    int getWebSocketTimeout();
-
     /**
      * Return the maximum time in millisecond an {@link AsyncHttpClient} can
      * stay idle.
@@ -119,7 +110,7 @@
      *
      * @return true if keep-alive is enabled
      */
-    boolean isAllowPoolingConnections();
+    boolean isKeepAlive();
 
     /**
      * Return the USER_AGENT header value
@@ -154,18 +145,11 @@
     ProxyServerSelector getProxyServerSelector();
 
     /**
-     * Return an instance of {@link SSLContext} used for SSL connection.
+     * Return an instance of {@link SslContext} used for SSL connection.
      *
-     * @return an instance of {@link SSLContext} used for SSL connection.
+     * @return an instance of {@link SslContext} used for SSL connection.
      */
-    SSLContext getSSLContext();
-
-    /**
-     * Return the {@link AdvancedConfig}
-     *
-     * @return the {@link AdvancedConfig}
-     */
-    AdvancedConfig getAdvancedConfig();
+    SslContext getSslContext();
 
     /**
      * Return the current {@link Realm}
@@ -193,7 +177,7 @@
      *
      * @return Unmodifiable list of {@link java.io.IOException}
      */
-    List<IOExceptionFilter> getIOExceptionFilters();
+    List<IOExceptionFilter> getIoExceptionFilters();
 
     /**
      * Return the number of time the library will retry when an
@@ -230,6 +214,8 @@
      */
     int getConnectionTtl();
 
+    boolean isUseOpenSsl();
+    
     boolean isAcceptAnyCertificate();
 
     /**
@@ -243,14 +229,14 @@
     String[] getEnabledCipherSuites();
 
     /**
-     * @return the size of the SSL session cache
+     * @return the size of the SSL session cache, 0 means using the default value
      */
-    Integer getSslSessionCacheSize();
+    int getSslSessionCacheSize();
 
     /**
-     * @return the SSL session timeout in seconds (optional)
+     * @return the SSL session timeout in seconds, 0 means using the default value
      */
-    Integer getSslSessionTimeout();
+    int getSslSessionTimeout();
 
     int getHttpClientCodecMaxInitialLineLength();
 
@@ -260,9 +246,9 @@
 
     boolean isDisableZeroCopy();
 
-    long getHandshakeTimeout();
+    int getHandshakeTimeout();
 
-    SSLEngineFactory getSslEngineFactory();
+    SslEngineFactory getSslEngineFactory();
 
     int getChunkedFileChunkSize();
 
@@ -275,4 +261,47 @@
     int getShutdownQuietPeriod();
 
     int getShutdownTimeout();
+
+    Map<ChannelOption<Object>, Object> getChannelOptions();
+
+    EventLoopGroup getEventLoopGroup();
+
+    boolean isUseNativeTransport();
+
+    AdditionalChannelInitializer getHttpAdditionalChannelInitializer();
+
+    AdditionalChannelInitializer getWsAdditionalChannelInitializer();
+
+    ResponseBodyPartFactory getResponseBodyPartFactory();
+
+    ChannelPool getChannelPool();
+
+    Timer getNettyTimer();
+
+    KeepAliveStrategy getKeepAliveStrategy();
+
+    interface AdditionalChannelInitializer {
+
+        void initChannel(Channel channel) throws Exception;
+    }
+
+    enum ResponseBodyPartFactory {
+
+        EAGER {
+            @Override
+            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new EagerNettyResponseBodyPart(buf, last);
+            }
+        },
+
+        LAZY {
+
+            @Override
+            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new LazyNettyResponseBodyPart(buf, last);
+            }
+        };
+
+        public abstract NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 1f8494a55..9e12bf695 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -16,12 +16,12 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.asynchttpclient.AdvancedConfig.Builder;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
@@ -43,39 +43,42 @@
     private final Timer nettyTimer;
 
     /**
-     * Default signature calculator to use for all requests constructed by this client instance.
+     * Default signature calculator to use for all requests constructed by this
+     * client instance.
      *
      * @since 1.1
      */
     protected SignatureCalculator signatureCalculator;
 
     /**
-     * Create a new HTTP Asynchronous Client using the default {@link DefaultAsyncHttpClientConfig} configuration. The
-     * default {@link AsyncHttpClient} that will be used will be based on the classpath configuration.
+     * Create a new HTTP Asynchronous Client using the default
+     * {@link DefaultAsyncHttpClientConfig} configuration. The default
+     * {@link AsyncHttpClient} that will be used will be based on the classpath
+     * configuration.
      *
-     * If none of those providers are found, then the engine will throw an IllegalStateException.
+     * If none of those providers are found, then the engine will throw an
+     * IllegalStateException.
      */
     public DefaultAsyncHttpClient() {
         this(new DefaultAsyncHttpClientConfig.Builder().build());
     }
 
     /**
-     * Create a new HTTP Asynchronous Client using the specified {@link DefaultAsyncHttpClientConfig} configuration.
-     * This configuration will be passed to the default {@link AsyncHttpClient} that will be selected based on
-     * the classpath configuration.
+     * Create a new HTTP Asynchronous Client using the specified
+     * {@link DefaultAsyncHttpClientConfig} configuration. This configuration
+     * will be passed to the default {@link AsyncHttpClient} that will be
+     * selected based on the classpath configuration.
      *
      * @param config a {@link DefaultAsyncHttpClientConfig}
      */
     public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
-        
+
         this.config = config;
-        
-        AdvancedConfig advancedConfig = config.getAdvancedConfig() != null ? config.getAdvancedConfig() : new Builder().build();
 
-        allowStopNettyTimer = advancedConfig.getNettyTimer() == null;
-        nettyTimer = allowStopNettyTimer ? newNettyTimer() : advancedConfig.getNettyTimer();
+        allowStopNettyTimer = config.getNettyTimer() == null;
+        nettyTimer = allowStopNettyTimer ? newNettyTimer() : config.getNettyTimer();
 
-        channelManager = new ChannelManager(config, advancedConfig, nettyTimer);
+        channelManager = new ChannelManager(config, nettyTimer);
         requestSender = new NettyRequestSender(config, channelManager, nettyTimer, closed);
         channelManager.configureBootstraps(requestSender);
     }
@@ -85,8 +88,7 @@ private Timer newNettyTimer() {
         timer.start();
         return timer;
     }
-    
-    
+
     @Override
     public void close() {
         if (closed.compareAndSet(false, true)) {
@@ -174,6 +176,11 @@ public BoundRequestBuilder prepareRequest(Request request) {
         return requestBuilder(request);
     }
 
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return prepareRequest(requestBuilder.build());
+    }
+
     @Override
     public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
 
@@ -193,11 +200,21 @@ public BoundRequestBuilder prepareRequest(Request request) {
         }
     }
 
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return executeRequest(requestBuilder.build(), handler);
+    }
+
     @Override
     public ListenableFuture<Response> executeRequest(Request request) {
         return executeRequest(request, new AsyncCompletionHandlerBase());
     }
 
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return executeRequest(requestBuilder.build());
+    }
+
     private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
         try {
             return requestSender.sendRequest(request, asyncHandler, null, false);
@@ -206,9 +223,10 @@ public BoundRequestBuilder prepareRequest(Request request) {
             return new ListenableFuture.CompletedFailure<>(e);
         }
     }
-    
+
     /**
-     * Configure and execute the associated {@link RequestFilter}. This class may decorate the {@link Request} and {@link AsyncHandler}
+     * Configure and execute the associated {@link RequestFilter}. This class
+     * may decorate the {@link Request} and {@link AsyncHandler}
      *
      * @param fc {@link FilterContext}
      * @return {@link FilterContext}
@@ -216,9 +234,7 @@ public BoundRequestBuilder prepareRequest(Request request) {
     private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
         for (RequestFilter asyncFilter : config.getRequestFilters()) {
             fc = asyncFilter.filter(fc);
-            if (fc == null) {
-                throw new NullPointerException("FilterContext is null");
-            }
+            assertNotNull(fc, "filterContext");
         }
 
         Request request = fc.getRequest();
@@ -238,7 +254,7 @@ public BoundRequestBuilder prepareRequest(Request request) {
     public ChannelPool getChannelPool() {
         return channelManager.getChannelPool();
     }
-    
+
     protected BoundRequestBuilder requestBuilder(String method, String url) {
         return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
     }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 6511afa84..787d0b1e6 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -16,21 +16,26 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.ssl.SslContext;
+import io.netty.util.Timer;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.ThreadFactory;
 
-import javax.net.ssl.SSLContext;
-
-import org.asynchttpclient.channel.SSLEngineFactory;
+import org.asynchttpclient.channel.pool.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
@@ -47,160 +52,201 @@
     private static final String AHC_VERSION;
 
     static {
-        InputStream is = null;
-        Properties prop = new Properties();
-        try {
-            is = DefaultAsyncHttpClientConfig.class.getResourceAsStream("/ahc-version.properties");
+        try (InputStream is = DefaultAsyncHttpClientConfig.class.getResourceAsStream("/ahc-version.properties")) {
+            Properties prop = new Properties();
             prop.load(is);
+            AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
         } catch (IOException e) {
             throw new ExceptionInInitializerError(e);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException ignored) {
-                }
-            }
         }
-        AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
     }
 
-    private final int connectTimeout;
-
-    private final int maxConnections;
-    private final int maxConnectionsPerHost;
+    // http
+    private final boolean followRedirect;
+    private final int maxRedirects;
+    private final boolean strict302Handling;
+    private final boolean compressionEnforced;
+    private final String userAgent;
+    private final Realm realm;
+    private final int maxRequestRetry;
+    private final boolean disableUrlEncodingForBoundRequests;
+    private final boolean disableZeroCopy;
+    private final boolean keepEncodingHeader;
+    private final ProxyServerSelector proxyServerSelector;
 
+    // timeouts
+    private final int connectTimeout;
     private final int requestTimeout;
     private final int readTimeout;
-    private final int webSocketTimeout;
+    private final int shutdownQuietPeriod;
+    private final int shutdownTimeout;
 
-    private final boolean allowPoolingConnections;
+    // keep-alive
+    private final boolean keepAlive;
     private final int pooledConnectionIdleTimeout;
     private final int connectionTtl;
+    private final int maxConnections;
+    private final int maxConnectionsPerHost;
+    private final ChannelPool channelPool;
+    private final KeepAliveStrategy keepAliveStrategy;
 
-    private final SSLContext sslContext;
+    // ssl
+    private final boolean useOpenSsl;
     private final boolean acceptAnyCertificate;
+    private final int handshakeTimeout;
+    private final String[] enabledProtocols;
+    private final String[] enabledCipherSuites;
+    private final int sslSessionCacheSize;
+    private final int sslSessionTimeout;
+    private final SslContext sslContext;
+    private final SslEngineFactory sslEngineFactory;
 
-    private final boolean followRedirect;
-    private final int maxRedirects;
-    private final boolean strict302Handling;
-
-    private final ProxyServerSelector proxyServerSelector;
-
-    private final boolean compressionEnforced;
-    private final String userAgent;
-    private final String threadPoolName;
-    private final ThreadFactory threadFactory;
-    private final Realm realm;
+    // filters
     private final List<RequestFilter> requestFilters;
     private final List<ResponseFilter> responseFilters;
     private final List<IOExceptionFilter> ioExceptionFilters;
-    private final int maxRequestRetry;
-    private final boolean disableUrlEncodingForBoundRequests;
-    private final String[] enabledProtocols;
-    private final String[] enabledCipherSuites;
-    private final Integer sslSessionCacheSize;
-    private final Integer sslSessionTimeout;
+
+    // internals
+    private final String threadPoolName;
     private final int httpClientCodecMaxInitialLineLength;
     private final int httpClientCodecMaxHeaderSize;
     private final int httpClientCodecMaxChunkSize;
-    private final boolean disableZeroCopy;
-    private final long handshakeTimeout;
-    private final SSLEngineFactory sslEngineFactory;
     private final int chunkedFileChunkSize;
     private final int webSocketMaxBufferSize;
     private final int webSocketMaxFrameSize;
-    private final boolean keepEncodingHeader;
-    private final int shutdownQuietPeriod;
-    private final int shutdownTimeout;
-    private final AdvancedConfig advancedConfig;
+    private final Map<ChannelOption<Object>, Object> channelOptions;
+    private final EventLoopGroup eventLoopGroup;
+    private final boolean useNativeTransport;
+    private final Timer nettyTimer;
+    private final ThreadFactory threadFactory;
+    private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
+    private final AdditionalChannelInitializer wsAdditionalChannelInitializer;
+    private final ResponseBodyPartFactory responseBodyPartFactory;
+
+    private DefaultAsyncHttpClientConfig(//
+            // http
+            boolean followRedirect,//
+            int maxRedirects,//
+            boolean strict302Handling,//
+            boolean compressionEnforced,//
+            String userAgent,//
+            Realm realm,//
+            int maxRequestRetry,//
+            boolean disableUrlEncodingForBoundRequests,//
+            boolean disableZeroCopy,//
+            boolean keepEncodingHeader,//
+            ProxyServerSelector proxyServerSelector,//
 
-    private DefaultAsyncHttpClientConfig(int connectTimeout,//
-            int maxConnections,//
-            int maxConnectionsPerHost,//
+            // timeouts
+            int connectTimeout,//
             int requestTimeout,//
             int readTimeout,//
-            int webSocketTimeout,//
-            boolean allowPoolingConnection,//
-            int idleConnectionInPoolTimeout,//
+            int shutdownQuietPeriod,//
+            int shutdownTimeout,//
+
+            // keep-alive
+            boolean keepAlive,//
+            int pooledConnectionIdleTimeout,//
             int connectionTtl,//
-            SSLContext sslContext, //
-            boolean acceptAnyCertificate, //
-            boolean followRedirect, //
-            int maxRedirects, //
-            boolean strict302Handling, //
-            String threadPoolName,//
-            ThreadFactory threadFactory,//
-            ProxyServerSelector proxyServerSelector, //
-            boolean compressionEnforced, //
-            String userAgent,//
-            Realm realm,//
+            int maxConnections,//
+            int maxConnectionsPerHost,//
+            ChannelPool channelPool,//
+            KeepAliveStrategy keepAliveStrategy,//
+
+            // ssl
+            boolean useOpenSsl,//
+            boolean acceptAnyCertificate,//
+            int handshakeTimeout,//
+            String[] enabledProtocols,//
+            String[] enabledCipherSuites,//
+            int sslSessionCacheSize,//
+            int sslSessionTimeout,//
+            SslContext sslContext,//
+            SslEngineFactory sslEngineFactory,//
+
+            // filters
             List<RequestFilter> requestFilters,//
             List<ResponseFilter> responseFilters,//
             List<IOExceptionFilter> ioExceptionFilters,//
-            int maxRequestRetry, //
-            boolean disableUrlEncodingForBoundRequests, //
-            String[] enabledProtocols,//
-            String[] enabledCipherSuites,//
-            Integer sslSessionCacheSize,//
-            Integer sslSessionTimeout,//
+
+            // internals
+            String threadPoolName,//
             int httpClientCodecMaxInitialLineLength,//
             int httpClientCodecMaxHeaderSize,//
             int httpClientCodecMaxChunkSize,//
-            boolean disableZeroCopy,//
-            long handshakeTimeout,//
-            SSLEngineFactory sslEngineFactory,//
             int chunkedFileChunkSize,//
             int webSocketMaxBufferSize,//
             int webSocketMaxFrameSize,//
-            boolean keepEncodingHeader,//
-            int shutdownQuietPeriod,//
-            int shutdownTimeout,//
-            AdvancedConfig advancedConfig) {
+            Map<ChannelOption<Object>, Object> channelOptions,//
+            EventLoopGroup eventLoopGroup,//
+            boolean useNativeTransport,//
+            Timer nettyTimer,//
+            ThreadFactory threadFactory,//
+            AdditionalChannelInitializer httpAdditionalChannelInitializer,//
+            AdditionalChannelInitializer wsAdditionalChannelInitializer,//
+            ResponseBodyPartFactory responseBodyPartFactory) {
 
-        this.connectTimeout = connectTimeout;
-        this.maxConnections = maxConnections;
-        this.maxConnectionsPerHost = maxConnectionsPerHost;
-        this.requestTimeout = requestTimeout;
-        this.readTimeout = readTimeout;
-        this.webSocketTimeout = webSocketTimeout;
-        this.allowPoolingConnections = allowPoolingConnection;
-        this.pooledConnectionIdleTimeout = idleConnectionInPoolTimeout;
-        this.connectionTtl = connectionTtl;
-        this.sslContext = sslContext;
-        this.acceptAnyCertificate = acceptAnyCertificate;
+        // http
         this.followRedirect = followRedirect;
         this.maxRedirects = maxRedirects;
         this.strict302Handling = strict302Handling;
-        this.proxyServerSelector = proxyServerSelector;
         this.compressionEnforced = compressionEnforced;
         this.userAgent = userAgent;
-        this.threadPoolName = threadPoolName;
-        this.threadFactory = threadFactory;
-
         this.realm = realm;
-        this.requestFilters = requestFilters;
-        this.responseFilters = responseFilters;
-        this.ioExceptionFilters = ioExceptionFilters;
         this.maxRequestRetry = maxRequestRetry;
         this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+        this.disableZeroCopy = disableZeroCopy;
+        this.keepEncodingHeader = keepEncodingHeader;
+        this.proxyServerSelector = proxyServerSelector;
+
+        // timeouts
+        this.connectTimeout = connectTimeout;
+        this.requestTimeout = requestTimeout;
+        this.readTimeout = readTimeout;
+        this.shutdownQuietPeriod = shutdownQuietPeriod;
+        this.shutdownTimeout = shutdownTimeout;
+
+        // keep-alive
+        this.keepAlive = keepAlive;
+        this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+        this.connectionTtl = connectionTtl;
+        this.maxConnections = maxConnections;
+        this.maxConnectionsPerHost = maxConnectionsPerHost;
+        this.channelPool = channelPool;
+        this.keepAliveStrategy = keepAliveStrategy;
+
+        // ssl
+        this.useOpenSsl = useOpenSsl;
+        this.acceptAnyCertificate = acceptAnyCertificate;
+        this.handshakeTimeout = handshakeTimeout;
         this.enabledProtocols = enabledProtocols;
         this.enabledCipherSuites = enabledCipherSuites;
         this.sslSessionCacheSize = sslSessionCacheSize;
         this.sslSessionTimeout = sslSessionTimeout;
-        this.advancedConfig = advancedConfig;
+        this.sslContext = sslContext;
+        this.sslEngineFactory = sslEngineFactory;
+
+        // filters
+        this.requestFilters = requestFilters;
+        this.responseFilters = responseFilters;
+        this.ioExceptionFilters = ioExceptionFilters;
+
+        // internals
+        this.threadPoolName = threadPoolName;
         this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
         this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
         this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-        this.disableZeroCopy = disableZeroCopy;
-        this.handshakeTimeout = handshakeTimeout;
-        this.sslEngineFactory = sslEngineFactory;
         this.chunkedFileChunkSize = chunkedFileChunkSize;
         this.webSocketMaxBufferSize = webSocketMaxBufferSize;
         this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-        this.keepEncodingHeader = keepEncodingHeader;
-        this.shutdownQuietPeriod = shutdownQuietPeriod;
-        this.shutdownTimeout = shutdownTimeout;
+        this.channelOptions = channelOptions;
+        this.eventLoopGroup = eventLoopGroup;
+        this.useNativeTransport = useNativeTransport;
+        this.nettyTimer = nettyTimer;
+        this.threadFactory = threadFactory;
+        this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+        this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+        this.responseBodyPartFactory = responseBodyPartFactory;
     }
 
     @Override
@@ -208,146 +254,139 @@ public String getAhcVersion() {
         return AHC_VERSION;
     }
 
+    // http
     @Override
-    public String getThreadPoolName() {
-        return threadPoolName;
+    public boolean isFollowRedirect() {
+        return followRedirect;
     }
 
     @Override
-    public String getThreadPoolNameOrDefault() {
-        String r = threadPoolName;
-        if (r == null || r.isEmpty()) {
-            r = defaultThreadPoolName();
-        }
-        if (r == null || r.isEmpty()) {
-            r = "AsyncHttpClient";
-        }
-        return r;
+    public int getMaxRedirects() {
+        return maxRedirects;
     }
 
     @Override
-    public int getMaxConnections() {
-        return maxConnections;
+    public boolean isStrict302Handling() {
+        return strict302Handling;
     }
 
     @Override
-    public int getMaxConnectionsPerHost() {
-        return maxConnectionsPerHost;
+    public boolean isCompressionEnforced() {
+        return compressionEnforced;
     }
 
     @Override
-    public int getConnectTimeout() {
-        return connectTimeout;
+    public String getUserAgent() {
+        return userAgent;
     }
 
     @Override
-    public int getWebSocketTimeout() {
-        return webSocketTimeout;
+    public Realm getRealm() {
+        return realm;
     }
 
     @Override
-    public int getReadTimeout() {
-        return readTimeout;
+    public int getMaxRequestRetry() {
+        return maxRequestRetry;
     }
 
     @Override
-    public int getPooledConnectionIdleTimeout() {
-        return pooledConnectionIdleTimeout;
+    public boolean isDisableUrlEncodingForBoundRequests() {
+        return disableUrlEncodingForBoundRequests;
     }
 
     @Override
-    public int getRequestTimeout() {
-        return requestTimeout;
+    public boolean isDisableZeroCopy() {
+        return disableZeroCopy;
     }
 
     @Override
-    public boolean isFollowRedirect() {
-        return followRedirect;
+    public boolean isKeepEncodingHeader() {
+        return keepEncodingHeader;
     }
 
     @Override
-    public int getMaxRedirects() {
-        return maxRedirects;
+    public ProxyServerSelector getProxyServerSelector() {
+        return proxyServerSelector;
     }
 
-    @Override
-    public boolean isAllowPoolingConnections() {
-        return allowPoolingConnections;
-    }
+    // timeouts
 
     @Override
-    public String getUserAgent() {
-        return userAgent;
+    public int getConnectTimeout() {
+        return connectTimeout;
     }
 
     @Override
-    public boolean isCompressionEnforced() {
-        return compressionEnforced;
+    public int getRequestTimeout() {
+        return requestTimeout;
     }
 
     @Override
-    public ThreadFactory getThreadFactory() {
-        return threadFactory;
+    public int getReadTimeout() {
+        return readTimeout;
     }
 
     @Override
-    public ProxyServerSelector getProxyServerSelector() {
-        return proxyServerSelector;
+    public int getShutdownQuietPeriod() {
+        return shutdownQuietPeriod;
     }
 
     @Override
-    public SSLContext getSSLContext() {
-        return sslContext;
+    public int getShutdownTimeout() {
+        return shutdownTimeout;
     }
 
+    // keep-alive
     @Override
-    public AdvancedConfig getAdvancedConfig() {
-        return advancedConfig;
+    public boolean isKeepAlive() {
+        return keepAlive;
     }
 
     @Override
-    public Realm getRealm() {
-        return realm;
+    public int getPooledConnectionIdleTimeout() {
+        return pooledConnectionIdleTimeout;
     }
 
     @Override
-    public List<RequestFilter> getRequestFilters() {
-        return requestFilters;
+    public int getConnectionTtl() {
+        return connectionTtl;
     }
 
     @Override
-    public List<ResponseFilter> getResponseFilters() {
-        return responseFilters;
+    public int getMaxConnections() {
+        return maxConnections;
     }
 
     @Override
-    public List<IOExceptionFilter> getIOExceptionFilters() {
-        return ioExceptionFilters;
+    public int getMaxConnectionsPerHost() {
+        return maxConnectionsPerHost;
     }
 
     @Override
-    public int getMaxRequestRetry() {
-        return maxRequestRetry;
+    public ChannelPool getChannelPool() {
+        return channelPool;
     }
 
     @Override
-    public boolean isDisableUrlEncodingForBoundRequests() {
-        return disableUrlEncodingForBoundRequests;
+    public KeepAliveStrategy getKeepAliveStrategy() {
+        return keepAliveStrategy;
     }
 
+    // ssl
     @Override
-    public boolean isStrict302Handling() {
-        return strict302Handling;
+    public boolean isUseOpenSsl() {
+        return useOpenSsl;
     }
-
+    
     @Override
-    public int getConnectionTtl() {
-        return connectionTtl;
+    public boolean isAcceptAnyCertificate() {
+        return acceptAnyCertificate;
     }
 
     @Override
-    public boolean isAcceptAnyCertificate() {
-        return acceptAnyCertificate;
+    public int getHandshakeTimeout() {
+        return handshakeTimeout;
     }
 
     @Override
@@ -361,43 +400,60 @@ public boolean isAcceptAnyCertificate() {
     }
 
     @Override
-    public Integer getSslSessionCacheSize() {
+    public int getSslSessionCacheSize() {
         return sslSessionCacheSize;
     }
 
     @Override
-    public Integer getSslSessionTimeout() {
+    public int getSslSessionTimeout() {
         return sslSessionTimeout;
     }
 
     @Override
-    public int getHttpClientCodecMaxInitialLineLength() {
-        return httpClientCodecMaxInitialLineLength;
+    public SslContext getSslContext() {
+        return sslContext;
     }
 
     @Override
-    public int getHttpClientCodecMaxHeaderSize() {
-        return httpClientCodecMaxHeaderSize;
+    public SslEngineFactory getSslEngineFactory() {
+        return sslEngineFactory;
     }
 
+    // filters
     @Override
-    public int getHttpClientCodecMaxChunkSize() {
-        return httpClientCodecMaxChunkSize;
+    public List<RequestFilter> getRequestFilters() {
+        return requestFilters;
     }
 
     @Override
-    public boolean isDisableZeroCopy() {
-        return disableZeroCopy;
+    public List<ResponseFilter> getResponseFilters() {
+        return responseFilters;
     }
 
     @Override
-    public long getHandshakeTimeout() {
-        return handshakeTimeout;
+    public List<IOExceptionFilter> getIoExceptionFilters() {
+        return ioExceptionFilters;
     }
 
+    // internals
     @Override
-    public SSLEngineFactory getSslEngineFactory() {
-        return sslEngineFactory;
+    public String getThreadPoolName() {
+        return threadPoolName;
+    }
+
+    @Override
+    public int getHttpClientCodecMaxInitialLineLength() {
+        return httpClientCodecMaxInitialLineLength;
+    }
+
+    @Override
+    public int getHttpClientCodecMaxHeaderSize() {
+        return httpClientCodecMaxHeaderSize;
+    }
+
+    @Override
+    public int getHttpClientCodecMaxChunkSize() {
+        return httpClientCodecMaxChunkSize;
     }
 
     @Override
@@ -416,184 +472,233 @@ public int getWebSocketMaxFrameSize() {
     }
 
     @Override
-    public boolean isKeepEncodingHeader() {
-        return keepEncodingHeader;
+    public Map<ChannelOption<Object>, Object> getChannelOptions() {
+        return channelOptions;
     }
 
     @Override
-    public int getShutdownQuietPeriod() {
-        return shutdownQuietPeriod;
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
     }
 
     @Override
-    public int getShutdownTimeout() {
-        return shutdownTimeout;
+    public boolean isUseNativeTransport() {
+        return useNativeTransport;
     }
 
-    /**
-     * Builder for an {@link AsyncHttpClient}
-     */
-    public static class Builder {
-        private int connectTimeout = defaultConnectTimeout();
-        private int maxConnections = defaultMaxConnections();
-        private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
-        private int requestTimeout = defaultRequestTimeout();
-        private int readTimeout = defaultReadTimeout();
-        private int webSocketTimeout = defaultWebSocketTimeout();
-        private boolean allowPoolingConnections = defaultAllowPoolingConnections();
-        private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
-        private int connectionTtl = defaultConnectionTtl();
-        private SSLContext sslContext;
-        private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
+    @Override
+    public Timer getNettyTimer() {
+        return nettyTimer;
+    }
+
+    @Override
+    public ThreadFactory getThreadFactory() {
+        return threadFactory;
+    }
+
+    @Override
+    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
+        return httpAdditionalChannelInitializer;
+    }
+
+    @Override
+    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
+        return wsAdditionalChannelInitializer;
+    }
+
+    @Override
+    public ResponseBodyPartFactory getResponseBodyPartFactory() {
+        return responseBodyPartFactory;
+    }
+
+    /**
+     * Builder for an {@link AsyncHttpClient}
+     */
+    public static class Builder {
+
+        // http
         private boolean followRedirect = defaultFollowRedirect();
         private int maxRedirects = defaultMaxRedirects();
         private boolean strict302Handling = defaultStrict302Handling();
-        private ProxyServerSelector proxyServerSelector;
-        private boolean useProxySelector = defaultUseProxySelector();
-        private boolean useProxyProperties = defaultUseProxyProperties();
         private boolean compressionEnforced = defaultCompressionEnforced();
         private String userAgent = defaultUserAgent();
-        private String threadPoolName = defaultThreadPoolName();
-        private ThreadFactory threadFactory;
         private Realm realm;
-        private final List<RequestFilter> requestFilters = new LinkedList<>();
-        private final List<ResponseFilter> responseFilters = new LinkedList<>();
-        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
         private int maxRequestRetry = defaultMaxRequestRetry();
         private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
+        private boolean disableZeroCopy = defaultDisableZeroCopy();
+        private boolean keepEncodingHeader = defaultKeepEncodingHeader();
+        private ProxyServerSelector proxyServerSelector;
+        private boolean useProxySelector = defaultUseProxySelector();
+        private boolean useProxyProperties = defaultUseProxyProperties();
+
+        // timeouts
+        private int connectTimeout = defaultConnectTimeout();
+        private int requestTimeout = defaultRequestTimeout();
+        private int readTimeout = defaultReadTimeout();
+        private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
+        private int shutdownTimeout = defaultShutdownTimeout();
+
+        // keep-alive
+        private boolean keepAlive = defaultKeepAlive();
+        private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
+        private int connectionTtl = defaultConnectionTtl();
+        private int maxConnections = defaultMaxConnections();
+        private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
+        private ChannelPool channelPool;
+        private KeepAliveStrategy keepAliveStrategy = KeepAliveStrategy.DefaultKeepAliveStrategy.INSTANCE;
+
+        // ssl
+        private boolean useOpenSsl = defaultUseOpenSsl();
+        private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
+        private int handshakeTimeout = defaultHandshakeTimeout();
         private String[] enabledProtocols = defaultEnabledProtocols();
         private String[] enabledCipherSuites;
-        private Integer sslSessionCacheSize = defaultSslSessionCacheSize();
-        private Integer sslSessionTimeout = defaultSslSessionTimeout();
+        private int sslSessionCacheSize = defaultSslSessionCacheSize();
+        private int sslSessionTimeout = defaultSslSessionTimeout();
+        private SslContext sslContext;
+        private SslEngineFactory sslEngineFactory;
+
+        // filters
+        private final List<RequestFilter> requestFilters = new LinkedList<>();
+        private final List<ResponseFilter> responseFilters = new LinkedList<>();
+        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
+
+        // internals
+        private String threadPoolName = defaultThreadPoolName();
         private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
         private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
         private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
-        private boolean disableZeroCopy = defaultDisableZeroCopy();
-        private long handshakeTimeout = defaultHandshakeTimeout();
-        private SSLEngineFactory sslEngineFactory;
         private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
         private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
         private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
-        private boolean keepEncodingHeader = defaultKeepEncodingHeader();
-        private int shutdownQuietPeriod = defaultShutdownQuietPeriod();
-        private int shutdownTimeout = defaultShutdownTimeout();
-        private AdvancedConfig advancedConfig;
+        private boolean useNativeTransport = defaultUseNativeTransport();
+        private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
+        private EventLoopGroup eventLoopGroup;
+        private Timer nettyTimer;
+        private ThreadFactory threadFactory;
+        private AdditionalChannelInitializer httpAdditionalChannelInitializer;
+        private AdditionalChannelInitializer wsAdditionalChannelInitializer;
+        private ResponseBodyPartFactory responseBodyPartFactory = ResponseBodyPartFactory.EAGER;
 
         public Builder() {
         }
 
         public Builder(AsyncHttpClientConfig config) {
-            connectTimeout = config.getConnectTimeout();
-            maxConnections = config.getMaxConnections();
-            maxConnectionsPerHost = config.getMaxConnectionsPerHost();
-            requestTimeout = config.getRequestTimeout();
-            readTimeout = config.getReadTimeout();
-            webSocketTimeout = config.getWebSocketTimeout();
-            allowPoolingConnections = config.isAllowPoolingConnections();
-            pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
-            connectionTtl = config.getConnectionTtl();
-            sslContext = config.getSSLContext();
-            acceptAnyCertificate = config.isAcceptAnyCertificate();
+            // http
             followRedirect = config.isFollowRedirect();
             maxRedirects = config.getMaxRedirects();
             strict302Handling = config.isStrict302Handling();
-            proxyServerSelector = config.getProxyServerSelector();
             compressionEnforced = config.isCompressionEnforced();
             userAgent = config.getUserAgent();
-            threadPoolName = config.getThreadPoolName();
-            threadFactory = config.getThreadFactory();
             realm = config.getRealm();
-            requestFilters.addAll(config.getRequestFilters());
-            responseFilters.addAll(config.getResponseFilters());
-            ioExceptionFilters.addAll(config.getIOExceptionFilters());
             maxRequestRetry = config.getMaxRequestRetry();
             disableUrlEncodingForBoundRequests = config.isDisableUrlEncodingForBoundRequests();
+            disableZeroCopy = config.isDisableZeroCopy();
+            keepEncodingHeader = config.isKeepEncodingHeader();
+            proxyServerSelector = config.getProxyServerSelector();
+
+            // timeouts
+            connectTimeout = config.getConnectTimeout();
+            requestTimeout = config.getRequestTimeout();
+            readTimeout = config.getReadTimeout();
+            shutdownQuietPeriod = config.getShutdownQuietPeriod();
+            shutdownTimeout = config.getShutdownTimeout();
+
+            // keep-alive
+            keepAlive = config.isKeepAlive();
+            pooledConnectionIdleTimeout = config.getPooledConnectionIdleTimeout();
+            connectionTtl = config.getConnectionTtl();
+            maxConnections = config.getMaxConnections();
+            maxConnectionsPerHost = config.getMaxConnectionsPerHost();
+            channelPool = config.getChannelPool();
+            keepAliveStrategy = config.getKeepAliveStrategy();
+
+            // ssl
+            acceptAnyCertificate = config.isAcceptAnyCertificate();
+            handshakeTimeout = config.getHandshakeTimeout();
             enabledProtocols = config.getEnabledProtocols();
             enabledCipherSuites = config.getEnabledCipherSuites();
             sslSessionCacheSize = config.getSslSessionCacheSize();
             sslSessionTimeout = config.getSslSessionTimeout();
+            sslContext = config.getSslContext();
+            sslEngineFactory = config.getSslEngineFactory();
+
+            // filters
+            requestFilters.addAll(config.getRequestFilters());
+            responseFilters.addAll(config.getResponseFilters());
+            ioExceptionFilters.addAll(config.getIoExceptionFilters());
+
+            // internals
+            threadPoolName = config.getThreadPoolName();
             httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
             httpClientCodecMaxHeaderSize = config.getHttpClientCodecMaxHeaderSize();
             httpClientCodecMaxChunkSize = config.getHttpClientCodecMaxChunkSize();
-            disableZeroCopy = config.isDisableZeroCopy();
-            handshakeTimeout = config.getHandshakeTimeout();
-            sslEngineFactory = config.getSslEngineFactory();
             chunkedFileChunkSize = config.getChunkedFileChunkSize();
             webSocketMaxBufferSize = config.getWebSocketMaxBufferSize();
             webSocketMaxFrameSize = config.getWebSocketMaxFrameSize();
-            keepEncodingHeader = config.isKeepEncodingHeader();
-            shutdownQuietPeriod = config.getShutdownQuietPeriod();
-            shutdownTimeout = config.getShutdownTimeout();
-            advancedConfig = config.getAdvancedConfig();
-        }
-
-        public Builder setThreadPoolName(String threadPoolName) {
-            this.threadPoolName = threadPoolName;
-            return this;
-        }
-
-        public Builder setMaxConnections(int maxConnections) {
-            this.maxConnections = maxConnections;
-            return this;
-        }
-
-        public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
-            this.maxConnectionsPerHost = maxConnectionsPerHost;
-            return this;
+            channelOptions.putAll(config.getChannelOptions());
+            eventLoopGroup = config.getEventLoopGroup();
+            useNativeTransport = config.isUseNativeTransport();
+            nettyTimer = config.getNettyTimer();
+            threadFactory = config.getThreadFactory();
+            httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
+            wsAdditionalChannelInitializer = config.getWsAdditionalChannelInitializer();
+            responseBodyPartFactory = config.getResponseBodyPartFactory();
         }
 
-        public Builder setConnectTimeout(int connectTimeout) {
-            this.connectTimeout = connectTimeout;
+        // http
+        public Builder setFollowRedirect(boolean followRedirect) {
+            this.followRedirect = followRedirect;
             return this;
         }
 
-        public Builder setWebSocketTimeout(int webSocketTimeout) {
-            this.webSocketTimeout = webSocketTimeout;
+        public Builder setMaxRedirects(int maxRedirects) {
+            this.maxRedirects = maxRedirects;
             return this;
         }
 
-        public Builder setReadTimeout(int readTimeout) {
-            this.readTimeout = readTimeout;
+        public Builder setStrict302Handling(final boolean strict302Handling) {
+            this.strict302Handling = strict302Handling;
             return this;
         }
 
-        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
-            this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
+        public Builder setCompressionEnforced(boolean compressionEnforced) {
+            this.compressionEnforced = compressionEnforced;
             return this;
         }
 
-        public Builder setRequestTimeout(int requestTimeout) {
-            this.requestTimeout = requestTimeout;
+        public Builder setUserAgent(String userAgent) {
+            this.userAgent = userAgent;
             return this;
         }
 
-        public Builder setFollowRedirect(boolean followRedirect) {
-            this.followRedirect = followRedirect;
+        public Builder setRealm(Realm realm) {
+            this.realm = realm;
             return this;
         }
-
-        public Builder setMaxRedirects(int maxRedirects) {
-            this.maxRedirects = maxRedirects;
+        
+        public Builder setRealm(Realm.Builder realmBuilder) {
+            this.realm = realmBuilder.build();
             return this;
         }
 
-        public Builder setCompressionEnforced(boolean compressionEnforced) {
-            this.compressionEnforced = compressionEnforced;
+        public Builder setMaxRequestRetry(int maxRequestRetry) {
+            this.maxRequestRetry = maxRequestRetry;
             return this;
         }
 
-        public Builder setUserAgent(String userAgent) {
-            this.userAgent = userAgent;
+        public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
+            this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
             return this;
         }
 
-        public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
-            this.allowPoolingConnections = allowPoolingConnections;
+        public Builder setDisableZeroCopy(boolean disableZeroCopy) {
+            this.disableZeroCopy = disableZeroCopy;
             return this;
         }
 
-        public Builder setThreadFactory(ThreadFactory threadFactory) {
-            this.threadFactory = threadFactory;
+        public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
+            this.keepEncodingHeader = keepEncodingHeader;
             return this;
         }
 
@@ -606,79 +711,87 @@ public Builder setProxyServer(ProxyServer proxyServer) {
             this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
             return this;
         }
+        
+        public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServerBuilder.build());
+            return this;
+        }
 
-        public Builder setSslContext(final SSLContext sslContext) {
-            this.sslContext = sslContext;
+        public Builder setUseProxySelector(boolean useProxySelector) {
+            this.useProxySelector = useProxySelector;
             return this;
         }
 
-        public Builder setAdvancedConfig(AdvancedConfig advancedConfig) {
-            this.advancedConfig = advancedConfig;
+        public Builder setUseProxyProperties(boolean useProxyProperties) {
+            this.useProxyProperties = useProxyProperties;
             return this;
         }
 
-        public Builder setRealm(Realm realm) {
-            this.realm = realm;
+        // timeouts
+        public Builder setConnectTimeout(int connectTimeout) {
+            this.connectTimeout = connectTimeout;
             return this;
         }
 
-        public Builder addRequestFilter(RequestFilter requestFilter) {
-            requestFilters.add(requestFilter);
+        public Builder setRequestTimeout(int requestTimeout) {
+            this.requestTimeout = requestTimeout;
             return this;
         }
 
-        public Builder removeRequestFilter(RequestFilter requestFilter) {
-            requestFilters.remove(requestFilter);
+        public Builder setReadTimeout(int readTimeout) {
+            this.readTimeout = readTimeout;
             return this;
         }
 
-        public Builder addResponseFilter(ResponseFilter responseFilter) {
-            responseFilters.add(responseFilter);
+        public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
+            this.shutdownQuietPeriod = shutdownQuietPeriod;
             return this;
         }
 
-        public Builder removeResponseFilter(ResponseFilter responseFilter) {
-            responseFilters.remove(responseFilter);
+        public Builder setShutdownTimeout(int shutdownTimeout) {
+            this.shutdownTimeout = shutdownTimeout;
             return this;
         }
 
-        public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-            ioExceptionFilters.add(ioExceptionFilter);
+        // keep-alive
+        public Builder setKeepAlive(boolean keepAlive) {
+            this.keepAlive = keepAlive;
             return this;
         }
 
-        public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
-            ioExceptionFilters.remove(ioExceptionFilter);
+        public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
+            this.pooledConnectionIdleTimeout = pooledConnectionIdleTimeout;
             return this;
         }
 
-        public Builder setMaxRequestRetry(int maxRequestRetry) {
-            this.maxRequestRetry = maxRequestRetry;
+        public Builder setConnectionTtl(int connectionTtl) {
+            this.connectionTtl = connectionTtl;
             return this;
         }
 
-        public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingForBoundRequests) {
-            this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
+        public Builder setMaxConnections(int maxConnections) {
+            this.maxConnections = maxConnections;
             return this;
         }
 
-        public Builder setUseProxySelector(boolean useProxySelector) {
-            this.useProxySelector = useProxySelector;
+        public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
+            this.maxConnectionsPerHost = maxConnectionsPerHost;
             return this;
         }
 
-        public Builder setUseProxyProperties(boolean useProxyProperties) {
-            this.useProxyProperties = useProxyProperties;
+        public Builder setChannelPool(ChannelPool channelPool) {
+            this.channelPool = channelPool;
             return this;
         }
 
-        public Builder setStrict302Handling(final boolean strict302Handling) {
-            this.strict302Handling = strict302Handling;
+        public Builder setKeepAliveStrategy(KeepAliveStrategy keepAliveStrategy) {
+            this.keepAliveStrategy = keepAliveStrategy;
             return this;
         }
 
-        public Builder setConnectionTtl(int connectionTtl) {
-            this.connectionTtl = connectionTtl;
+        // ssl
+        public Builder setUseOpenSsl(boolean useOpenSsl) {
+            this.useOpenSsl = useOpenSsl;
             return this;
         }
 
@@ -687,6 +800,11 @@ public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
             return this;
         }
 
+        public Builder setHandshakeTimeout(int handshakeTimeout) {
+            this.handshakeTimeout = handshakeTimeout;
+            return this;
+        }
+
         public Builder setEnabledProtocols(String[] enabledProtocols) {
             this.enabledProtocols = enabledProtocols;
             return this;
@@ -707,33 +825,65 @@ public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
             return this;
         }
 
-        public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
-            this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+        public Builder setSslContext(final SslContext sslContext) {
+            this.sslContext = sslContext;
             return this;
         }
 
-        public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
-            this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+            this.sslEngineFactory = sslEngineFactory;
             return this;
         }
 
-        public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
-            this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+        // filters
+        public Builder addRequestFilter(RequestFilter requestFilter) {
+            requestFilters.add(requestFilter);
             return this;
         }
 
-        public Builder setDisableZeroCopy(boolean disableZeroCopy) {
-            this.disableZeroCopy = disableZeroCopy;
+        public Builder removeRequestFilter(RequestFilter requestFilter) {
+            requestFilters.remove(requestFilter);
             return this;
         }
 
-        public Builder setHandshakeTimeout(long handshakeTimeout) {
-            this.handshakeTimeout = handshakeTimeout;
+        public Builder addResponseFilter(ResponseFilter responseFilter) {
+            responseFilters.add(responseFilter);
             return this;
         }
 
-        public Builder setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
-            this.sslEngineFactory = sslEngineFactory;
+        public Builder removeResponseFilter(ResponseFilter responseFilter) {
+            responseFilters.remove(responseFilter);
+            return this;
+        }
+
+        public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+            ioExceptionFilters.add(ioExceptionFilter);
+            return this;
+        }
+
+        public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
+            ioExceptionFilters.remove(ioExceptionFilter);
+            return this;
+        }
+
+        // internals
+        public Builder setThreadPoolName(String threadPoolName) {
+            this.threadPoolName = threadPoolName;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
+            this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
+            this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
+            this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
             return this;
         }
 
@@ -752,74 +902,113 @@ public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
             return this;
         }
 
-        public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
-            this.keepEncodingHeader = keepEncodingHeader;
+        @SuppressWarnings("unchecked")
+        public <T> Builder addChannelOption(ChannelOption<T> name, T value) {
+            channelOptions.put((ChannelOption<Object>) name, value);
             return this;
         }
 
-        public Builder setShutdownQuietPeriod(int shutdownQuietPeriod) {
-            this.shutdownQuietPeriod = shutdownQuietPeriod;
+        public Builder setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+            this.eventLoopGroup = eventLoopGroup;
             return this;
         }
 
-        public Builder setShutdownTimeout(int shutdownTimeout) {
-            this.shutdownTimeout = shutdownTimeout;
+        public Builder setUseNativeTransport(boolean useNativeTransport) {
+            this.useNativeTransport = useNativeTransport;
             return this;
         }
 
-        public DefaultAsyncHttpClientConfig build() {
+        public Builder setNettyTimer(Timer nettyTimer) {
+            this.nettyTimer = nettyTimer;
+            return this;
+        }
 
-            if (proxyServerSelector == null && useProxySelector)
-                proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
+        public Builder setThreadFactory(ThreadFactory threadFactory) {
+            this.threadFactory = threadFactory;
+            return this;
+        }
 
-            if (proxyServerSelector == null && useProxyProperties)
-                proxyServerSelector = ProxyUtils.createProxyServerSelector(System.getProperties());
+        public Builder setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
+            this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
+            return this;
+        }
 
-            if (proxyServerSelector == null)
-                proxyServerSelector = ProxyServerSelector.NO_PROXY_SELECTOR;
+        public Builder setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
+            this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
+            return this;
+        }
 
-            return new DefaultAsyncHttpClientConfig(connectTimeout,//
-                    maxConnections,//
-                    maxConnectionsPerHost,//
-                    requestTimeout,//
-                    readTimeout,//
-                    webSocketTimeout,//
-                    allowPoolingConnections,//
-                    pooledConnectionIdleTimeout,//
-                    connectionTtl,//
-                    sslContext, //
-                    acceptAnyCertificate, //
+        public Builder setResponseBodyPartFactory(ResponseBodyPartFactory responseBodyPartFactory) {
+            this.responseBodyPartFactory = responseBodyPartFactory;
+            return this;
+        }
+
+        private ProxyServerSelector resolveProxyServerSelector() {
+            if (proxyServerSelector != null)
+                return proxyServerSelector;
+
+            if (useProxySelector)
+                return ProxyUtils.getJdkDefaultProxyServerSelector();
+
+            if (useProxyProperties)
+                return ProxyUtils.createProxyServerSelector(System.getProperties());
+
+            return ProxyServerSelector.NO_PROXY_SELECTOR;
+        }
+
+        public DefaultAsyncHttpClientConfig build() {
+
+            return new DefaultAsyncHttpClientConfig(//
                     followRedirect, //
                     maxRedirects, //
                     strict302Handling, //
-                    threadPoolName,//
-                    threadFactory, //
-                    proxyServerSelector, //
                     compressionEnforced, //
-                    userAgent,//
-                    realm,//
-                    requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters), //
-                    responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),//
-                    ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),//
+                    userAgent, //
+                    realm, //
                     maxRequestRetry, //
                     disableUrlEncodingForBoundRequests, //
+                    disableZeroCopy, //
+                    keepEncodingHeader, //
+                    resolveProxyServerSelector(), //
+                    connectTimeout, //
+                    requestTimeout, //
+                    readTimeout, //
+                    shutdownQuietPeriod, //
+                    shutdownTimeout, //
+                    keepAlive, //
+                    pooledConnectionIdleTimeout, //
+                    connectionTtl, //
+                    maxConnections, //
+                    maxConnectionsPerHost, //
+                    channelPool, //
+                    keepAliveStrategy, //
+                    useOpenSsl, //
+                    acceptAnyCertificate, //
+                    handshakeTimeout, //
                     enabledProtocols, //
                     enabledCipherSuites, //
                     sslSessionCacheSize, //
                     sslSessionTimeout, //
+                    sslContext, //
+                    sslEngineFactory, //
+                    requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters), //
+                    responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),//
+                    ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),//
+                    threadPoolName, //
                     httpClientCodecMaxInitialLineLength, //
                     httpClientCodecMaxHeaderSize, //
                     httpClientCodecMaxChunkSize, //
-                    disableZeroCopy, //
-                    handshakeTimeout, //
-                    sslEngineFactory, //
                     chunkedFileChunkSize, //
                     webSocketMaxBufferSize, //
                     webSocketMaxFrameSize, //
-                    keepEncodingHeader, //
-                    shutdownQuietPeriod,//
-                    shutdownTimeout,//
-                    advancedConfig);
+                    channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
+                    eventLoopGroup, //
+                    useNativeTransport, //
+                    nettyTimer, //
+                    threadFactory, //
+                    httpAdditionalChannelInitializer, //
+                    wsAdditionalChannelInitializer, //
+                    responseBodyPartFactory);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 6ac332429..257f67caa 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -80,10 +80,6 @@ public static RequestBuilder request(String method, String url) {
         return new DefaultAsyncHttpClientConfig.Builder();
     }
 
-    public static AdvancedConfig.Builder advancedConfig() {
-        return new AdvancedConfig.Builder();
-    }
-
     // /////////// Realm ////////////////
     public static Realm.Builder realm(Realm prototype) {
         return new Realm.Builder(prototype.getPrincipal(), prototype.getPassword())//
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index a151c05e8..530e70537 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -15,60 +15,31 @@
  */
 package org.asynchttpclient;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.nio.ByteBuffer;
 
 /**
  * A callback class used when an HTTP response body is received.
  */
-public abstract class HttpResponseBodyPart {
+public interface HttpResponseBodyPart {
 
     /**
      * @return length of this part in bytes
      */
-    public abstract int length();
+    int length();
 
     /**
      * @return  the response body's part bytes received.
      */
-    public abstract byte[] getBodyPartBytes();
-
-    /**
-     * @return a stream of this part bytes
-     */
-    public abstract InputStream readBodyPartBytes();
-
-    /**
-     * Write the available bytes to the {@link java.io.OutputStream}
-     *
-     * @param outputStream the target os
-     * @return The number of bytes written
-     * @throws IOException exception while writing in the os
-     */
-    public abstract int writeTo(OutputStream outputStream) throws IOException;
+    byte[] getBodyPartBytes();
 
     /**
      * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
      * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
      */
-    public abstract ByteBuffer getBodyByteBuffer();
+    ByteBuffer getBodyByteBuffer();
 
     /**
      * @return true if this is the last part.
      */
-    public abstract boolean isLast();
-
-    /**
-     * Close the underlying connection once the processing has completed. Invoking that method means the
-     * underlying TCP connection will be closed as soon as the processing of the response is completed. That
-     * means the underlying connection will never get pooled.
-     */
-    public abstract void markUnderlyingConnectionAsToBeClosed();
-
-    /**
-     * @return true of the underlying connection will be closed once the response has been fully processed.
-     */
-    public abstract boolean isUnderlyingConnectionToBeClosed();
+    boolean isLast();
 }
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 03b6119e5..db5db23e2 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -16,6 +16,8 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import static java.nio.charset.StandardCharsets.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
@@ -65,13 +67,10 @@
     private Realm(AuthScheme scheme, String principal, String password, String realmName, String nonce, String algorithm, String response, String qop, String nc, String cnonce,
             Uri uri, String method, boolean usePreemptiveAuth, String ntlmDomain, Charset charset, String host, String opaque, boolean useAbsoluteURI, boolean omitQuery) {
 
-        if (scheme == null)
-            throw new NullPointerException("scheme");
-        if (principal == null)
-            throw new NullPointerException("principal");
-        if (password == null)
-            throw new NullPointerException("password");
-        
+        assertNotNull(scheme, "scheme");
+        assertNotNull(principal, "principal");
+        assertNotNull(password, "password");
+
         this.principal = principal;
         this.password = password;
         this.scheme = scheme;
@@ -232,7 +231,7 @@ public Builder(String principal, String password) {
             this.principal = principal;
             this.password = password;
         }
-        
+
         public Builder setNtlmDomain(String ntlmDomain) {
             this.ntlmDomain = ntlmDomain;
             return this;
@@ -314,7 +313,7 @@ public Builder setCharset(Charset charset) {
             this.charset = charset;
             return this;
         }
-        
+
         private String parseRawQop(String rawQop) {
             String[] rawServerSupportedQops = rawQop.split(",");
             String[] serverSupportedQops = new String[rawServerSupportedQops.length];
@@ -351,7 +350,7 @@ public Builder parseWWWAuthenticateHeader(String headerLine) {
             if (rawQop != null) {
                 setQop(parseRawQop(rawQop));
             }
-            
+
             return this;
         }
 
@@ -366,7 +365,7 @@ public Builder parseProxyAuthenticateHeader(String headerLine) {
             }
             // FIXME qop is different with proxy?
             setQop(match(headerLine, "qop"));
-            
+
             return this;
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index afcdb290a..157db5c17 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -103,15 +103,21 @@ protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding) {
         this.address = prototype.getAddress();
         this.localAddress = prototype.getLocalAddress();
         this.headers.add(prototype.getHeaders());
-        this.cookies = new ArrayList<Cookie>(prototype.getCookies());
+        if (isNonEmpty(prototype.getCookies())) {
+            this.cookies = new ArrayList<>(prototype.getCookies());
+        }
         this.byteData = prototype.getByteData();
         this.compositeByteData = prototype.getCompositeByteData();
         this.stringData = prototype.getStringData();
         this.byteBufferData = prototype.getByteBufferData();
         this.streamData = prototype.getStreamData();
         this.bodyGenerator = prototype.getBodyGenerator();
-        this.formParams = prototype.getFormParams();
-        this.bodyParts = prototype.getBodyParts();
+        if (isNonEmpty(prototype.getFormParams())) {
+            this.formParams = new ArrayList<>(prototype.getFormParams());
+        }
+        if (isNonEmpty(prototype.getBodyParts())) {
+            this.bodyParts = new ArrayList<>(prototype.getBodyParts());
+        }
         this.virtualHost = prototype.getVirtualHost();
         this.contentLength = prototype.getContentLength();
         this.proxyServer = prototype.getProxyServer();
@@ -369,6 +375,11 @@ public T setProxyServer(ProxyServer proxyServer) {
         this.proxyServer = proxyServer;
         return asDerivedType();
     }
+    
+    public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
+        this.proxyServer = proxyServerBuilder.build();
+        return asDerivedType();
+    }
 
     public T setRealm(Realm realm) {
         this.realm = realm;
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
similarity index 52%
rename from client/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java
rename to client/src/main/java/org/asynchttpclient/SslEngineFactory.java
index b3ec0e558..21b737670 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java
+++ b/client/src/main/java/org/asynchttpclient/SslEngineFactory.java
@@ -3,32 +3,27 @@
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.request.body.multipart;
+package org.asynchttpclient;
 
-import java.io.IOException;
+import javax.net.ssl.SSLEngine;
 
-public class CounterPartVisitor implements PartVisitor {
+public interface SslEngineFactory {
 
-    private long count = 0L;
-
-    @Override
-    public void withBytes(byte[] bytes) throws IOException {
-        count += bytes.length;
-    }
-
-    @Override
-    public void withByte(byte b) throws IOException {
-        count++;
-    }
-
-    public long getCount() {
-        return count;
-    }
+    /**
+     * Creates new {@link SSLEngine}.
+     *
+     * @param config the client config
+     * @param peerHost the peer hostname
+     * @param peerPort the peer port
+     * @return new engine
+     */
+    SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort);
 }
diff --git a/client/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java b/client/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java
deleted file mode 100644
index 859186a50..000000000
--- a/client/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.channel;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import java.security.GeneralSecurityException;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLParameters;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.util.SslUtils;
-
-/**
- * Factory that creates an {@link SSLEngine} to be used for a single SSL connection.
- */
-public interface SSLEngineFactory {
-
-    /**
-     * Creates new {@link SSLEngine}.
-     *
-     * @param peerHost the peer hostname
-     * @param peerPort the peer port
-     * @return new engine
-     * @throws GeneralSecurityException if the SSLEngine cannot be created
-     */
-    SSLEngine newSSLEngine(String peerHost, int peerPort) throws GeneralSecurityException;
-
-    class DefaultSSLEngineFactory implements SSLEngineFactory {
-
-        private final AsyncHttpClientConfig config;
-
-        public DefaultSSLEngineFactory(AsyncHttpClientConfig config) {
-            this.config = config;
-        }
-
-        @Override
-        public SSLEngine newSSLEngine(String peerHost, int peerPort) throws GeneralSecurityException {
-            SSLContext sslContext = SslUtils.getInstance().getSSLContext(config);
-
-            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
-            sslEngine.setUseClientMode(true);
-            if (!config.isAcceptAnyCertificate()) {
-                SSLParameters params = sslEngine.getSSLParameters();
-                params.setEndpointIdentificationAlgorithm("HTTPS");
-                sslEngine.setSSLParameters(params);
-            }
-
-            if (isNonEmpty(config.getEnabledProtocols()))
-                sslEngine.setEnabledProtocols(config.getEnabledProtocols());
-
-            if (isNonEmpty(config.getEnabledCipherSuites()))
-                sslEngine.setEnabledCipherSuites(config.getEnabledCipherSuites());
-
-            return sslEngine;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java b/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java
deleted file mode 100644
index 6995a7eec..000000000
--- a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.channel.pool;
-
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-
-import org.asynchttpclient.Request;
-
-/**
- * Provides an interface for decisions about HTTP connections.
- */
-public interface ConnectionStrategy {
-
-    /**
-     * Determines whether the connection should be kept alive after this HTTP message exchange.
-     * @param ahcRequest the Request, as built by AHC
-     * @param nettyRequest the HTTP request sent to Netty
-     * @param nettyResponse the HTTP response received from Netty
-     * @return true if the connection should be kept alive, false if it should be closed.
-     */
-    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
-}
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
new file mode 100644
index 000000000..1c498ddb8
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.channel.pool;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
+import static io.netty.handler.codec.http.HttpHeaders.Values.*;
+import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+
+import org.asynchttpclient.Request;
+
+public interface KeepAliveStrategy {
+
+    /**
+     * Determines whether the connection should be kept alive after this HTTP message exchange.
+     * @param ahcRequest the Request, as built by AHC
+     * @param nettyRequest the HTTP request sent to Netty
+     * @param nettyResponse the HTTP response received from Netty
+     * @return true if the connection should be kept alive, false if it should be closed.
+     */
+    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
+
+    /**
+     * Connection strategy implementing standard HTTP 1.0/1.1 behaviour.
+     */
+    enum DefaultKeepAliveStrategy implements KeepAliveStrategy {
+        
+        INSTANCE;
+
+        /**
+         * Implemented in accordance with RFC 7230 section 6.1
+         * https://tools.ietf.org/html/rfc7230#section-6.1
+         */
+        @Override
+        public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
+
+            String responseConnectionHeader = connectionHeader(response);
+
+            if (CLOSE.equalsIgnoreCase(responseConnectionHeader)) {
+                return false;
+            } else {
+                String requestConnectionHeader = connectionHeader(request);
+
+                if (request.getProtocolVersion() == HttpVersion.HTTP_1_0) {
+                    // only use keep-alive if both parties agreed upon it
+                    return KEEP_ALIVE.equalsIgnoreCase(requestConnectionHeader) && KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader);
+
+                } else {
+                    // 1.1+, keep-alive is default behavior
+                    return !CLOSE.equalsIgnoreCase(requestConnectionHeader);
+                }
+            }
+        }
+
+        private String connectionHeader(HttpMessage message) {
+            return message.headers().get(CONNECTION);
+        }
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index f959414a2..9830912d8 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -47,10 +47,6 @@ public static int defaultRequestTimeout() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "requestTimeout");
     }
 
-    public static int defaultWebSocketTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketTimeout");
-    }
-
     public static int defaultConnectionTtl() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionTtl");
     }
@@ -87,8 +83,8 @@ public static boolean defaultStrict302Handling() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
     }
 
-    public static boolean defaultAllowPoolingConnections() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "allowPoolingConnections");
+    public static boolean defaultKeepAlive() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepAlive");
     }
 
     public static int defaultMaxRequestRetry() {
@@ -99,16 +95,20 @@ public static boolean defaultDisableUrlEncodingForBoundRequests() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableUrlEncodingForBoundRequests");
     }
 
+    public static boolean defaultUseOpenSsl() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useOpenSsl");
+    }
+
     public static boolean defaultAcceptAnyCertificate() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "acceptAnyCertificate");
     }
 
-    public static Integer defaultSslSessionCacheSize() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInteger(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionCacheSize");
+    public static int defaultSslSessionCacheSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionCacheSize");
     }
 
-    public static Integer defaultSslSessionTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInteger(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
+    public static int defaultSslSessionTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
     }
 
     public static int defaultHttpClientCodecMaxInitialLineLength() {
@@ -127,8 +127,8 @@ public static boolean defaultDisableZeroCopy() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableZeroCopy");
     }
 
-    public static long defaultHandshakeTimeout() {
-        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getLong(ASYNC_CLIENT_CONFIG_ROOT + "handshakeTimeout");
+    public static int defaultHandshakeTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "handshakeTimeout");
     }
 
     public static int defaultChunkedFileChunkSize() {
@@ -154,4 +154,8 @@ public static int defaultShutdownQuietPeriod() {
     public static int defaultShutdownTimeout() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "shutdownTimeout");
     }
+
+    public static boolean defaultUseNativeTransport() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/Cookie.java b/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
index 83d2e0ac4..5e8599c6b 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
@@ -12,17 +12,15 @@
  */
 package org.asynchttpclient.cookie;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 public class Cookie {
 
     public static Cookie newValidCookie(String name, String value, boolean wrap, String domain, String path, long maxAge, boolean secure, boolean httpOnly) {
 
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
+        assertNotNull(name, "name");
         name = name.trim();
-        if (name.length() == 0) {
-            throw new IllegalArgumentException("empty name");
-        }
+        assertNotEmpty(name, "name");
 
         for (int i = 0; i < name.length(); i++) {
             char c = name.charAt(i);
@@ -49,10 +47,7 @@ public static Cookie newValidCookie(String name, String value, boolean wrap, Str
             throw new IllegalArgumentException("name starting with '$' not allowed: " + name);
         }
 
-        if (value == null) {
-            throw new NullPointerException("value");
-        }
-
+        assertNotNull(value, "value");
         domain = validateValue("domain", domain);
         path = validateValue("path", path);
 
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java b/client/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
index 15bce1924..bb1fea75d 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.cookie;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -31,9 +33,7 @@
      */
     public static Cookie decode(String header) {
 
-        if (header == null) {
-            throw new NullPointerException("header");
-        }
+        assertNotNull(header, "header");
 
         final int headerLen = header.length();
 
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieUtil.java b/client/src/main/java/org/asynchttpclient/cookie/CookieUtil.java
index bc0563310..6f078fb99 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieUtil.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieUtil.java
@@ -12,7 +12,6 @@
  */
 package org.asynchttpclient.cookie;
 
-import java.text.ParsePosition;
 import java.util.BitSet;
 import java.util.Date;
 
@@ -97,7 +96,7 @@ static CharSequence unwrapValue(CharSequence cs) {
 
     static long computeExpires(String expires) {
         if (expires != null) {
-            Date expiresDate = DateParser.get().parse(expires, new ParsePosition(0));
+            Date expiresDate = DateParser.parse(expires);
             if (expiresDate != null)
                 return expiresDate.getTime();
         }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/DateParser.java b/client/src/main/java/org/asynchttpclient/cookie/DateParser.java
index b1b5fd5d8..38b56866b 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/DateParser.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/DateParser.java
@@ -12,11 +12,12 @@
  */
 package org.asynchttpclient.cookie;
 
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
+import java.time.LocalDateTime;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
 
 /**
  * A parser for <a href="http://tools.ietf.org/html/rfc2616#section-3.3">RFC2616
@@ -24,73 +25,37 @@
  * 
  * @author slandelle
  */
-@SuppressWarnings("serial")
-public class DateParser extends SimpleDateFormat {
-
-    private final SimpleDateFormat format1 = new RFC2616DateParserObsolete1();
-    private final SimpleDateFormat format2 = new RFC2616DateParserObsolete2();
-
-    private static final ThreadLocal<DateParser> DATE_FORMAT_HOLDER = new ThreadLocal<DateParser>() {
-        @Override
-        protected DateParser initialValue() {
-            return new DateParser();
+public final class DateParser {
+
+    private static final DateTimeFormatter PROPER_FORMAT_RFC822 = DateTimeFormatter.RFC_1123_DATE_TIME;
+    // give up on pre 2000 dates
+    private static final DateTimeFormatter OBSOLETE_FORMAT1_RFC850 = DateTimeFormatter.ofPattern("EEEE, dd-MMM-yy HH:mm:ss z", Locale.ENGLISH);
+    private static final DateTimeFormatter OBSOLETE_FORMAT2_ANSIC = DateTimeFormatter.ofPattern("EEE MMM d HH:mm:ss yyyy", Locale.ENGLISH);
+
+    private static Date parseZonedDateTimeSilent(String text, DateTimeFormatter formatter) {
+        try {
+            return Date.from(ZonedDateTime.parse(text, formatter).toInstant());
+        } catch (Exception e) {
+            return null;
         }
-    };
-
-    public static DateParser get() {
-        return DATE_FORMAT_HOLDER.get();
     }
 
-    /**
-     * Standard date format
-     * <br>
-     * E, d MMM yyyy HH:mm:ss z
-     * e.g. Sun, 06 Nov 1994 08:49:37 GMT
-     */
-    private DateParser() {
-        super("E, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
-        setTimeZone(TimeZone.getTimeZone("GMT"));
+    private static Date parseDateTimeSilent(String text, DateTimeFormatter formatter) {
+        try {
+            return Date.from(LocalDateTime.parse(text, formatter).toInstant(ZoneOffset.UTC));
+        } catch (Exception e) {
+            return null;
+        }
     }
 
-    @Override
-    public Date parse(String text, ParsePosition pos) {
-        Date date = super.parse(text, pos);
+    public static Date parse(String text) {
+        Date date = parseZonedDateTimeSilent(text, PROPER_FORMAT_RFC822);
         if (date == null) {
-            date = format1.parse(text, pos);
+            date = parseZonedDateTimeSilent(text, OBSOLETE_FORMAT1_RFC850);
         }
         if (date == null) {
-            date = format2.parse(text, pos);
+            date = parseDateTimeSilent(text, OBSOLETE_FORMAT2_ANSIC);
         }
         return date;
     }
-
-    /**
-     * First obsolete format
-     * <br>
-     * E, d-MMM-y HH:mm:ss z
-     * e.g. Sunday, 06-Nov-94 08:49:37 GMT
-     */
-    private static final class RFC2616DateParserObsolete1 extends SimpleDateFormat {
-        private static final long serialVersionUID = -3178072504225114298L;
-
-        RFC2616DateParserObsolete1() {
-            super("E, dd-MMM-yy HH:mm:ss z", Locale.ENGLISH);
-            setTimeZone(TimeZone.getTimeZone("GMT"));
-        }
-    }
-
-    /**
-     * Second obsolete format
-     * <br>
-     * EEE, MMM d HH:mm:ss yyyy
-     * e.g. Sun Nov 6 08:49:37 1994
-     */
-    private static final class RFC2616DateParserObsolete2 extends SimpleDateFormat {
-        private static final long serialVersionUID = 3010674519968303714L;
-
-        RFC2616DateParserObsolete2() {
-            super("E MMM d HH:mm:ss yyyy", Locale.ENGLISH);
-            setTimeZone(TimeZone.getTimeZone("GMT"));
-        }
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/future/ExecutionList.java b/client/src/main/java/org/asynchttpclient/future/ExecutionList.java
index fd3e3d3ef..1cd7ca39e 100644
--- a/client/src/main/java/org/asynchttpclient/future/ExecutionList.java
+++ b/client/src/main/java/org/asynchttpclient/future/ExecutionList.java
@@ -28,6 +28,8 @@
 
 package org.asynchttpclient.future;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import java.util.Queue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -66,14 +68,8 @@
      */
     public void add(Runnable runnable, Executor executor) {
 
-        if (runnable == null) {
-            throw new NullPointerException("Runnable is null");
-        }
-
-        if (executor == null) {
-            throw new NullPointerException("Executor is null");
-        }
-
+        assertNotNull(runnable, "runnable");
+        assertNotNull(executor, "executor");
         boolean executeImmediate = false;
 
         // Lock while we check state.  We must maintain the lock while adding the
diff --git a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
index 3f53e9e86..872d2972d 100644
--- a/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
@@ -140,7 +140,7 @@ public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception
             headersArrived.countDown();
         }
 
-        bodyPart.writeTo(output);
+        output.write(bodyPart.getBodyPartBytes());
         return State.CONTINUE;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
index 6319c4cb3..3359a8bef 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
@@ -204,7 +204,7 @@ public Request adjustRequestRange(Request request) {
             byteTransferred.set(ri);
         }
 
-        // The Resumbale
+        // The Resumable
         if (resumableListener != null && resumableListener.length() > 0 && byteTransferred.get() != resumableListener.length()) {
             byteTransferred.set(resumableListener.length());
         }
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
index 3261473af..384b99d26 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
@@ -12,13 +12,9 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.netty.util.ByteBufUtils.*;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.nio.ByteBuffer;
 
 /**
@@ -44,22 +40,11 @@ public EagerNettyResponseBodyPart(ByteBuf buf, boolean last) {
         return bytes;
     }
 
-    @Override
-    public InputStream readBodyPartBytes() {
-        return new ByteArrayInputStream(bytes);
-    }
-
     @Override
     public int length() {
         return bytes.length;
     }
 
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-        outputStream.write(bytes);
-        return length();
-    }
-
     @Override
     public ByteBuffer getBodyByteBuffer() {
         return ByteBuffer.wrap(bytes);
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
index 80213bece..b9b30ed36 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
@@ -14,18 +14,15 @@
 
 import io.netty.buffer.ByteBuf;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.netty.util.ByteBufUtils;
+
 /**
  * A callback class used when an HTTP response body is received.
  */
 public class LazyNettyResponseBodyPart extends NettyResponseBodyPart {
 
-    private static final String ERROR_MESSAGE = "This implementation is intended for one to directly read from the underlying ByteBuf and release after usage. Not for the fainted heart!";
-
     private final ByteBuf buf;
 
     public LazyNettyResponseBodyPart(ByteBuf buf, boolean last) {
@@ -49,21 +46,11 @@ public int length() {
      */
     @Override
     public byte[] getBodyPartBytes() {
-        throw new UnsupportedOperationException(ERROR_MESSAGE);
-    }
-
-    @Override
-    public InputStream readBodyPartBytes() {
-        throw new UnsupportedOperationException(ERROR_MESSAGE);
-    }
-
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-        throw new UnsupportedOperationException(ERROR_MESSAGE);
+        return ByteBufUtils.byteBuf2Bytes(buf.duplicate());
     }
 
     @Override
     public ByteBuffer getBodyByteBuffer() {
-        throw new UnsupportedOperationException(ERROR_MESSAGE);
+        return buf.nioBuffer();
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
index a17eb1e62..9c375b328 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
@@ -18,10 +18,9 @@
 /**
  * A callback class used when an HTTP response body is received.
  */
-public abstract class NettyResponseBodyPart extends HttpResponseBodyPart {
+public abstract class NettyResponseBodyPart implements HttpResponseBodyPart {
 
     private final boolean last;
-    private boolean closeConnection;
 
     public NettyResponseBodyPart(boolean last) {
         this.last = last;
@@ -34,20 +33,4 @@ public NettyResponseBodyPart(boolean last) {
     public boolean isLast() {
         return last;
     }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsToBeClosed() {
-        closeConnection = true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isUnderlyingConnectionToBeClosed() {
-        return closeConnection;
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 792eff96e..8e362c171 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -36,6 +36,7 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
 import org.asynchttpclient.future.AbstractListenableFuture;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequest;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
@@ -53,10 +54,6 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
 
-    public enum STATE {
-        NEW, POOLED, RECONNECTED, CLOSED,
-    }
-
     private final long start = millisTime();
     private final ConnectionPoolPartitioning connectionPoolPartitioning;
     private final ProxyServer proxyServer;
@@ -72,7 +69,7 @@
     private final AtomicBoolean inProxyAuth = new AtomicBoolean(false);
     private final AtomicBoolean statusReceived = new AtomicBoolean(false);
     private final AtomicLong touch = new AtomicLong(millisTime());
-    private final AtomicReference<STATE> state = new AtomicReference<>(STATE.NEW);
+    private final AtomicReference<ChannelState> channelState = new AtomicReference<>(ChannelState.NEW);
     private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
     private final AtomicInteger currentRetry = new AtomicInteger(0);
     private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
@@ -348,12 +345,12 @@ public AtomicBoolean getInProxyAuth() {
         return inProxyAuth;
     }
 
-    public STATE getState() {
-        return state.get();
+    public ChannelState getChannelState() {
+        return channelState.get();
     }
 
-    public void setState(STATE state) {
-        this.state.set(state);
+    public void setChannelState(ChannelState channelState) {
+        this.channelState.set(channelState);
     }
 
     public boolean getAndSetStatusReceived(boolean sr) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index f85fac8d0..615176831 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -38,18 +38,17 @@
 import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 
 import java.io.IOException;
-import java.security.GeneralSecurityException;
 import java.util.Map.Entry;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 
 import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
 
-import org.asynchttpclient.AdvancedConfig;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.channel.SSLEngineFactory;
+import org.asynchttpclient.SslEngineFactory;
 import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.Callback;
@@ -57,10 +56,11 @@
 import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.netty.channel.pool.DefaultChannelPool;
 import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
+import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
 import org.asynchttpclient.netty.handler.HttpProtocol;
-import org.asynchttpclient.netty.handler.Processor;
 import org.asynchttpclient.netty.handler.WebSocketProtocol;
 import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.ssl.DefaultSslEngineFactory;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
@@ -69,20 +69,20 @@
 public class ChannelManager {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
-    public static final String HTTP_HANDLER = "httpHandler";
-    public static final String SSL_HANDLER = "sslHandler";
-    public static final String HTTP_PROCESSOR = "httpProcessor";
-    public static final String WS_PROCESSOR = "wsProcessor";
+    public static final String PINNED_ENTRY = "entry";
+    public static final String HTTP_CLIENT_CODEC = "http";
+    public static final String SSL_HANDLER = "ssl";
     public static final String DEFLATER_HANDLER = "deflater";
     public static final String INFLATER_HANDLER = "inflater";
-    public static final String CHUNKED_WRITER_HANDLER = "chunkedWriter";
+    public static final String CHUNKED_WRITER_HANDLER = "chunked-writer";
     public static final String WS_DECODER_HANDLER = "ws-decoder";
     public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
     public static final String WS_ENCODER_HANDLER = "ws-encoder";
+    public static final String AHC_HTTP_HANDLER = "ahc-http";
+    public static final String AHC_WS_HANDLER = "ahc-ws";
 
     private final AsyncHttpClientConfig config;
-    private final AdvancedConfig advancedConfig;
-    private final SSLEngineFactory sslEngineFactory;
+    private final SslEngineFactory sslEngineFactory;
     private final EventLoopGroup eventLoopGroup;
     private final boolean allowReleaseEventLoopGroup;
     private final Class<? extends Channel> socketChannelClass;
@@ -102,24 +102,29 @@
     private final ConcurrentHashMapV8<Channel, Object> channelId2PartitionKey;
     private final ConcurrentHashMapV8.Fun<Object, Semaphore> semaphoreComputer;
 
-    private Processor wsProcessor;
+    private AsyncHttpClientHandler wsHandler;
 
-    public ChannelManager(final AsyncHttpClientConfig config, AdvancedConfig advancedConfig, Timer nettyTimer) {
+    public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
 
         this.config = config;
-        this.advancedConfig = advancedConfig;
-        this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new SSLEngineFactory.DefaultSSLEngineFactory(config);
-
-        ChannelPool channelPool = advancedConfig.getChannelPool();
-        if (channelPool == null && config.isAllowPoolingConnections()) {
-            channelPool = new DefaultChannelPool(config, nettyTimer);
-        } else if (channelPool == null) {
-            channelPool = new NoopChannelPool();
+        try {
+            this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new DefaultSslEngineFactory(config);
+        } catch (SSLException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+
+        ChannelPool channelPool = config.getChannelPool();
+        if (channelPool == null) {
+            if (config.isKeepAlive()) {
+                channelPool = new DefaultChannelPool(config, nettyTimer);
+            } else {
+                channelPool = NoopChannelPool.INSTANCE;
+            }
         }
         this.channelPool = channelPool;
 
-        tooManyConnections = buildStaticIOException(String.format("Too many connections %s", config.getMaxConnections()));
-        tooManyConnectionsPerHost = buildStaticIOException(String.format("Too many connections per host %s", config.getMaxConnectionsPerHost()));
+        tooManyConnections = buildStaticIOException("Too many connections " + config.getMaxConnections());
+        tooManyConnectionsPerHost = buildStaticIOException("Too many connections per host " + config.getMaxConnectionsPerHost());
         poolAlreadyClosed = buildStaticIOException("Pool is already closed");
         maxTotalConnectionsEnabled = config.getMaxConnections() > 0;
         maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
@@ -135,9 +140,9 @@ public boolean remove(Object o) {
                         if (maxConnectionsPerHostEnabled) {
                             Object partitionKey = channelId2PartitionKey.remove(Channel.class.cast(o));
                             if (partitionKey != null) {
-                                Semaphore freeChannelsForHost = freeChannelsPerHost.get(partitionKey);
-                                if (freeChannelsForHost != null)
-                                    freeChannelsForHost.release();
+                                Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);
+                                if (hostFreeChannels != null)
+                                    hostFreeChannels.release();
                             }
                         }
                     }
@@ -168,10 +173,10 @@ public Semaphore apply(Object partitionKey) {
         handshakeTimeout = config.getHandshakeTimeout();
 
         // check if external EventLoopGroup is defined
-        ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolNameOrDefault());
-        allowReleaseEventLoopGroup = advancedConfig.getEventLoopGroup() == null;
+        ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
+        allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
         if (allowReleaseEventLoopGroup) {
-            if (advancedConfig.isPreferNative()) {
+            if (config.isUseNativeTransport()) {
                 eventLoopGroup = newEpollEventLoopGroup(threadFactory);
                 socketChannelClass = getEpollSocketChannelClass();
 
@@ -181,7 +186,7 @@ public Semaphore apply(Object partitionKey) {
             }
 
         } else {
-            eventLoopGroup = advancedConfig.getEventLoopGroup();
+            eventLoopGroup = config.getEventLoopGroup();
             if (eventLoopGroup instanceof OioEventLoopGroup)
                 throw new IllegalArgumentException("Oio is not supported");
 
@@ -203,7 +208,7 @@ public Semaphore apply(Object partitionKey) {
             httpBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
             wsBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
         }
-        for (Entry<ChannelOption<Object>, Object> entry : advancedConfig.getChannelOptions().entrySet()) {
+        for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
             ChannelOption<Object> key = entry.getKey();
             Object value = entry.getValue();
             httpBootstrap.option(key, value);
@@ -228,28 +233,31 @@ private EventLoopGroup newEpollEventLoopGroup(ThreadFactory threadFactory) {
             throw new IllegalArgumentException(e);
         }
     }
-    
+
     public void configureBootstraps(NettyRequestSender requestSender) {
 
-        HttpProtocol httpProtocol = new HttpProtocol(this, config, advancedConfig, requestSender);
-        final Processor httpProcessor = new Processor(config, advancedConfig, this, requestSender, httpProtocol);
+        HttpProtocol httpProtocol = new HttpProtocol(this, config, requestSender);
+        final AsyncHttpClientHandler httpHandler = new AsyncHttpClientHandler(config, this, requestSender, httpProtocol);
+
+        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, requestSender);
+        wsHandler = new AsyncHttpClientHandler(config, this, requestSender, wsProtocol);
 
-        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, advancedConfig, requestSender);
-        wsProcessor = new Processor(config, advancedConfig, this, requestSender, wsProtocol);
+        final NoopHandler pinnedEntry = new NoopHandler();
 
         httpBootstrap.handler(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ch.pipeline()//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(PINNED_ENTRY, pinnedEntry)//
+                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
                         .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//
                         .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
-                        .addLast(HTTP_PROCESSOR, httpProcessor);
+                        .addLast(AHC_HTTP_HANDLER, httpHandler);
 
                 ch.config().setOption(ChannelOption.AUTO_READ, false);
 
-                if (advancedConfig.getHttpAdditionalPipelineInitializer() != null)
-                    advancedConfig.getHttpAdditionalPipelineInitializer().initPipeline(ch.pipeline());
+                if (config.getHttpAdditionalChannelInitializer() != null)
+                    config.getHttpAdditionalChannelInitializer().initChannel(ch);
             }
         });
 
@@ -257,11 +265,12 @@ protected void initChannel(Channel ch) throws Exception {
             @Override
             protected void initChannel(Channel ch) throws Exception {
                 ch.pipeline()//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
-                        .addLast(WS_PROCESSOR, wsProcessor);
+                        .addLast(PINNED_ENTRY, pinnedEntry)//
+                        .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
+                        .addLast(AHC_WS_HANDLER, wsHandler);
 
-                if (advancedConfig.getWsAdditionalPipelineInitializer() != null)
-                    advancedConfig.getWsAdditionalPipelineInitializer().initPipeline(ch.pipeline());
+                if (config.getWsAdditionalChannelInitializer() != null)
+                    config.getWsAdditionalChannelInitializer().initChannel(ch);
             }
         });
     }
@@ -387,8 +396,8 @@ private HttpClientCodec newHttpClientCodec() {
                 false);
     }
 
-    private SslHandler createSslHandler(String peerHost, int peerPort) throws GeneralSecurityException {
-        SSLEngine sslEngine = sslEngineFactory.newSSLEngine(peerHost, peerPort);
+    private SslHandler createSslHandler(String peerHost, int peerPort) {
+        SSLEngine sslEngine = sslEngineFactory.newSslEngine(config, peerHost, peerPort);
         SslHandler sslHandler = new SslHandler(sslEngine);
         if (handshakeTimeout > 0)
             sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
@@ -399,28 +408,28 @@ public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
         return pipeline.get(SSL_HANDLER) != null;
     }
 
-    public void upgradeProtocol(ChannelPipeline pipeline, Uri requestUri) throws GeneralSecurityException {
-        if (pipeline.get(HTTP_HANDLER) != null)
-            pipeline.remove(HTTP_HANDLER);
+    public void upgradeProtocol(ChannelPipeline pipeline, Uri requestUri) throws SSLException {
+        if (pipeline.get(HTTP_CLIENT_CODEC) != null)
+            pipeline.remove(HTTP_CLIENT_CODEC);
 
         if (requestUri.isSecured())
             if (isSslHandlerConfigured(pipeline)) {
-                pipeline.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addAfter(SSL_HANDLER, HTTP_CLIENT_CODEC, newHttpClientCodec());
             } else {
-                pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
-                pipeline.addFirst(SSL_HANDLER, createSslHandler(requestUri.getHost(), requestUri.getExplicitPort()));
+                pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
+                pipeline.addAfter(PINNED_ENTRY, SSL_HANDLER, createSslHandler(requestUri.getHost(), requestUri.getExplicitPort()));
             }
 
         else
-            pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+            pipeline.addAfter(PINNED_ENTRY, HTTP_CLIENT_CODEC, newHttpClientCodec());
 
         if (requestUri.isWebSocket()) {
-            pipeline.addAfter(HTTP_PROCESSOR, WS_PROCESSOR, wsProcessor);
-            pipeline.remove(HTTP_PROCESSOR);
+            pipeline.addAfter(AHC_HTTP_HANDLER, AHC_WS_HANDLER, wsHandler);
+            pipeline.remove(AHC_HTTP_HANDLER);
         }
     }
 
-    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
+    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) {
         String peerHost;
         int peerPort;
 
@@ -444,37 +453,14 @@ public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtua
         return sslHandler;
     }
 
-    /**
-     * Always make sure the channel who got cached support the proper protocol.
-     * It could only occurs when a HttpMethod. CONNECT is used against a proxy
-     * that requires upgrading from http to https.
-     */
-    /**
-     * @param pipeline the pipeline
-     * @param uri the uri
-     * @param virtualHost the virtual host
-     * @throws GeneralSecurityException if creating the SslHandler crashed
-     */
-    public void verifyChannelPipeline(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
-
-        boolean sslHandlerConfigured = isSslHandlerConfigured(pipeline);
-
-        if (uri.isSecured()) {
-            if (!sslHandlerConfigured)
-                addSslHandler(pipeline, uri, virtualHost);
-
-        } else if (sslHandlerConfigured)
-            pipeline.remove(SSL_HANDLER);
-    }
-
     public Bootstrap getBootstrap(Uri uri, ProxyServer proxy) {
         return uri.isWebSocket() && proxy == null ? wsBootstrap : httpBootstrap;
     }
 
     public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
-        pipeline.addAfter(HTTP_HANDLER, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
-        pipeline.remove(HTTP_HANDLER);
-        pipeline.addBefore(WS_PROCESSOR, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
+        pipeline.addAfter(HTTP_CLIENT_CODEC, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+        pipeline.remove(HTTP_CLIENT_CODEC);
+        pipeline.addBefore(AHC_WS_HANDLER, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
         pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
new file mode 100644
index 000000000..a76df2b90
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelState.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+public enum ChannelState {
+    NEW, POOLED, RECONNECTED, CLOSED,
+}
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index f130f59bd..2274d10df 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -118,8 +118,8 @@ private void onFutureFailure(Channel channel, Throwable cause) {
         boolean canRetry = future.canRetry();
         LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
         if (canRetry//
-                && cause != null//
-                && (future.getState() != NettyResponseFuture.STATE.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
+                && cause != null // FIXME when can we have a null cause?
+                && (future.getChannelState() != ChannelState.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
 
             if (requestSender.retry(future)) {
                 return;
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java b/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
new file mode 100644
index 000000000..e0363a85d
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NoopHandler.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelHandler.Sharable;
+
+/**
+ * A noop handler that just serves as a pinned reference for adding and removing handlers in the pipeline
+ */
+@Sharable
+public class NoopHandler extends ChannelHandlerAdapter {
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
index f1c3bb1a3..348dd2e4d 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
@@ -13,8 +13,6 @@
  */
 package org.asynchttpclient.netty.channel.pool;
 
-import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
-
 import io.netty.channel.Channel;
 
 public interface ChannelPool {
@@ -37,7 +35,8 @@
     Channel poll(Object partitionKey);
 
     /**
-     * Remove all channels from the cache. A channel might have been associated with several uri.
+     * Remove all channels from the cache. A channel might have been associated
+     * with several uri.
      * 
      * @param channel a channel
      * @return the true if the channel has been removed
@@ -45,8 +44,9 @@
     boolean removeAll(Channel channel);
 
     /**
-     * Return true if a channel can be cached. A implementation can decide based on some rules to allow caching
-     * Calling this method is equivalent of checking the returned value of {@link ChannelPool#offer(Channel, Object)}
+     * Return true if a channel can be cached. A implementation can decide based
+     * on some rules to allow caching Calling this method is equivalent of
+     * checking the returned value of {@link ChannelPool#offer(Channel, Object)}
      * 
      * @return true if a channel can be cached.
      */
@@ -59,6 +59,7 @@
 
     /**
      * Flush a partition
+     * 
      * @param partitionKey the partition
      */
     void flushPartition(Object partitionKey);
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
index 7b51b721b..d627cf079 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.netty.channel.pool;
 
+import static org.asynchttpclient.util.Assertions.*;
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.channel.Channel;
 import io.netty.util.Timeout;
@@ -97,8 +98,7 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
         final long start;
 
         IdleChannel(Channel channel, long start) {
-            if (channel == null)
-                throw new NullPointerException("channel");
+            assertNotNull(channel, "channel");
             this.channel = channel;
             this.start = start;
         }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
old mode 100755
new mode 100644
index 44c37804d..ea38e4637
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
@@ -17,7 +17,9 @@
 
 import io.netty.channel.Channel;
 
-public class NoopChannelPool implements ChannelPool {
+public enum NoopChannelPool implements ChannelPool {
+
+    INSTANCE;
 
     @Override
     public boolean offer(Channel channel, Object partitionKey) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/Processor.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
similarity index 87%
rename from client/src/main/java/org/asynchttpclient/netty/handler/Processor.java
rename to client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index 3dbd13f21..4381df565 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/Processor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -27,7 +27,6 @@
 import java.io.IOException;
 import java.nio.channels.ClosedChannelException;
 
-import org.asynchttpclient.AdvancedConfig;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.DiscardEvent;
@@ -41,23 +40,20 @@
 import org.slf4j.LoggerFactory;
 
 @Sharable
-public class Processor extends ChannelInboundHandlerAdapter {
+public class AsyncHttpClientHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHttpClientHandler.class);
 
     private final AsyncHttpClientConfig config;
-    private final AdvancedConfig advancedConfig;
     private final ChannelManager channelManager;
     private final NettyRequestSender requestSender;
     private final Protocol protocol;
 
-    public Processor(AsyncHttpClientConfig config,//
-            AdvancedConfig advancedConfig,//
+    public AsyncHttpClientHandler(AsyncHttpClientConfig config,//
             ChannelManager channelManager,//
             NettyRequestSender requestSender,//
             Protocol protocol) {
         this.config = config;
-        this.advancedConfig = advancedConfig;
         this.channelManager = channelManager;
         this.requestSender = requestSender;
         this.protocol = protocol;
@@ -88,32 +84,29 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
 
                 StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
 
-                if (msg instanceof LastHttpContent) {
-                    // Remove the handler from the pipeline, this will trigger
-                    // it to finish
-                    ctx.pipeline().remove(publisher);
-                    // Trigger a read, just in case the last read complete
-                    // triggered no new read
-                    ctx.read();
-                    // Send the last content on to the protocol, so that it can
-                    // conclude the cleanup
-                    protocol.handle(channel, publisher.future(), msg);
-                } else if (msg instanceof HttpContent) {
-
+                if(msg instanceof HttpContent) {
                     ByteBuf content = ((HttpContent) msg).content();
-
                     // Republish as a HttpResponseBodyPart
                     if (content.readableBytes() > 0) {
-                        NettyResponseBodyPart part = advancedConfig.getResponseBodyPartFactory().newResponseBodyPart(content, false);
+                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
                         ctx.fireChannelRead(part);
                     }
-
+                    if (msg instanceof LastHttpContent) {
+                        // Remove the handler from the pipeline, this will trigger
+                        // it to finish
+                        ctx.pipeline().remove(publisher);
+                        // Trigger a read, just in case the last read complete
+                        // triggered no new read
+                        ctx.read();
+                        // Send the last content on to the protocol, so that it can
+                        // conclude the cleanup
+                        protocol.handle(channel, publisher.future(), msg);
+                    }
                 } else {
                     LOGGER.info("Received unexpected message while expecting a chunk: " + msg);
                     ctx.pipeline().remove((StreamedResponsePublisher) attribute);
                     Channels.setDiscard(channel);
                 }
-
             } else if (attribute != DiscardEvent.INSTANCE) {
                 // unhandled message
                 LOGGER.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
@@ -154,7 +147,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             NettyResponseFuture<?> future = NettyResponseFuture.class.cast(attribute);
             future.touch();
 
-            if (!config.getIOExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+            if (!config.getIoExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
                 return;
 
             protocol.onClose(future);
@@ -191,7 +184,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
 
                     // FIXME why drop the original exception and throw a new
                     // one?
-                    if (!config.getIOExceptionFilters().isEmpty()) {
+                    if (!config.getIoExceptionFilters().isEmpty()) {
                         if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
                             // Close the channel so the recovering can occurs.
                             Channels.silentlyCloseChannel(channel);
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java b/client/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
deleted file mode 100644
index 1233926e5..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty.handler;
-
-import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
-import io.netty.handler.codec.http.HttpMessage;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpVersion;
-
-import org.asynchttpclient.Request;
-import org.asynchttpclient.channel.pool.ConnectionStrategy;
-
-/**
- * Connection strategy implementing standard HTTP 1.0/1.1 behaviour.
- */
-public class DefaultConnectionStrategy implements ConnectionStrategy {
-
-    /**
-     * Implemented in accordance with RFC 7230 section 6.1
-     * https://tools.ietf.org/html/rfc7230#section-6.1
-     */
-    @Override
-    public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
-
-        String responseConnectionHeader = connectionHeader(response);
-
-        if (CLOSE.equalsIgnoreCase(responseConnectionHeader)) {
-            return false;
-        } else {
-            String requestConnectionHeader = connectionHeader(request);
-
-            if (request.getProtocolVersion() == HttpVersion.HTTP_1_0) {
-                // only use keep-alive if both parties agreed upon it
-                return KEEP_ALIVE.equalsIgnoreCase(requestConnectionHeader) && KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader);
-
-            } else {
-                // 1.1+, keep-alive is default behavior
-                return !CLOSE.equalsIgnoreCase(requestConnectionHeader);
-            }
-        }
-    }
-
-    private String connectionHeader(HttpMessage message) {
-        return message.headers().get(CONNECTION);
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
index 2e18b31bc..e3751df3b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
@@ -14,7 +14,7 @@
 package org.asynchttpclient.netty.handler;
 
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.Dsl.realm;
 import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -27,18 +27,15 @@
 import io.netty.handler.codec.http.LastHttpContent;
 
 import java.io.IOException;
-import java.security.GeneralSecurityException;
 import java.util.List;
 
-import org.asynchttpclient.AdvancedConfig;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.channel.pool.ConnectionStrategy;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseBodyPart;
@@ -46,6 +43,7 @@
 import org.asynchttpclient.netty.NettyResponseHeaders;
 import org.asynchttpclient.netty.NettyResponseStatus;
 import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.ntlm.NtlmEngine;
@@ -56,12 +54,8 @@
 
 public final class HttpProtocol extends Protocol {
 
-    private final ConnectionStrategy connectionStrategy;
-
-    public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, AdvancedConfig advancedConfig, NettyRequestSender requestSender) {
-        super(channelManager, config, advancedConfig, requestSender);
-
-        connectionStrategy = advancedConfig.getConnectionStrategy();
+    public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+        super(channelManager, config, requestSender);
     }
 
     private void kerberosChallenge(Channel channel,//
@@ -156,12 +150,11 @@ private void finishUpdate(final NettyResponseFuture<?> future, Channel channel,
 
     private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
         boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
-        if (bodyPart.isUnderlyingConnectionToBeClosed())
+        if (interrupt)
             future.setKeepAlive(false);
         return interrupt;
     }
 
-
     private boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
         if (statusCode == CONTINUE.code()) {
             future.setHeadersAlreadyWrittenOnContinue(true);
@@ -187,7 +180,7 @@ private boolean exitAfterHandling401(//
             int statusCode,//
             Realm realm,//
             ProxyServer proxyServer) {
-        
+
         if (statusCode != UNAUTHORIZED.code())
             return false;
 
@@ -195,7 +188,7 @@ private boolean exitAfterHandling401(//
             logger.info("Can't handle 401 as there's no realm");
             return false;
         }
-        
+
         if (future.getInAuth().getAndSet(true)) {
             logger.info("Can't handle 401 as auth was already performed");
             return false;
@@ -209,7 +202,7 @@ private boolean exitAfterHandling401(//
         }
 
         // FIXME what's this???
-        future.setState(NettyResponseFuture.STATE.NEW);
+        future.setChannelState(ChannelState.NEW);
         HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
 
         switch (realm.getScheme()) {
@@ -227,7 +220,7 @@ private boolean exitAfterHandling401(//
                 logger.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
                 return false;
             }
-            
+
             // FIXME do we want to update the realm, or directly
             // set the header?
             Realm newBasicRealm = realm(realm)//
@@ -250,7 +243,7 @@ private boolean exitAfterHandling401(//
                     .build();
             future.setRealm(newDigestRealm);
             break;
-            
+
         case NTLM:
             String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
             if (ntlmHeader == null) {
@@ -273,7 +266,7 @@ private boolean exitAfterHandling401(//
             }
             try {
                 kerberosChallenge(channel, wwwAuthHeaders, request, requestHeaders, realm, future);
-                
+
             } catch (SpnegoEngineException e) {
                 // FIXME
                 String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
@@ -324,25 +317,25 @@ private boolean exitAfterHandling407(//
             logger.info("Can't handle 407 as auth was already performed");
             return false;
         }
-        
+
         Realm proxyRealm = future.getProxyRealm();
-        
+
         if (proxyRealm == null) {
             logger.info("Can't handle 407 as there's no proxyRealm");
             return false;
         }
-        
+
         List<String> proxyAuthHeaders = response.headers().getAll(HttpHeaders.Names.PROXY_AUTHENTICATE);
 
         if (proxyAuthHeaders.isEmpty()) {
             logger.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
             return false;
         }
-        
+
         // FIXME what's this???
-        future.setState(NettyResponseFuture.STATE.NEW);
+        future.setChannelState(ChannelState.NEW);
         HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
-        
+
         switch (proxyRealm.getScheme()) {
         case BASIC:
             if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
@@ -358,7 +351,7 @@ private boolean exitAfterHandling407(//
                 logger.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
                 return false;
             }
-            
+
             // FIXME do we want to update the realm, or directly
             // set the header?
             Realm newBasicRealm = realm(proxyRealm)//
@@ -381,7 +374,7 @@ private boolean exitAfterHandling407(//
                     .build();
             future.setProxyRealm(newDigestRealm);
             break;
-            
+
         case NTLM:
             String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
             if (ntlmHeader == null) {
@@ -403,7 +396,7 @@ private boolean exitAfterHandling407(//
             }
             try {
                 kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, proxyRealm, requestHeaders, future);
-                
+
             } catch (SpnegoEngineException e) {
                 // FIXME
                 String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
@@ -430,7 +423,7 @@ private boolean exitAfterHandling407(//
             nextRequestBuilder.setMethod(HttpMethod.CONNECT.name());
         }
         final Request nextRequest = nextRequestBuilder.build();
-        
+
         logger.debug("Sending proxy authentication to {}", request.getUri());
         if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
             future.setConnectAllowed(true);
@@ -460,15 +453,10 @@ private boolean exitAfterHandlingConnect(//
             Uri requestUri = request.getUri();
             logger.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
 
-            try {
-                channelManager.upgradeProtocol(channel.pipeline(), requestUri);
-                future.setReuseChannel(true);
-                future.setConnectAllowed(false);
-                requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
-
-            } catch (GeneralSecurityException ex) {
-                requestSender.abort(channel, future, ex);
-            }
+            channelManager.upgradeProtocol(channel.pipeline(), requestUri);
+            future.setReuseChannel(true);
+            future.setConnectAllowed(false);
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
 
             return true;
         }
@@ -518,7 +506,7 @@ private boolean handleHttpResponse(final HttpResponse response, final Channel ch
         // the handler in case of trailing headers
         future.setHttpHeaders(response.headers());
 
-        future.setKeepAlive(connectionStrategy.keepAlive(future.getTargetRequest(), httpRequest, response));
+        future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
 
         NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
         int statusCode = response.getStatus().code();
@@ -556,7 +544,7 @@ private void handleChunk(HttpContent chunk,//
 
         ByteBuf buf = chunk.content();
         if (!interrupt && !(handler instanceof StreamedAsyncHandler) && (buf.readableBytes() > 0 || last)) {
-            NettyResponseBodyPart part = advancedConfig.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
+            NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
             interrupt = updateBodyAndInterrupt(future, handler, part);
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
index c04f609ef..ad8030591 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
@@ -15,6 +15,7 @@
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.HttpUtils.*;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -24,11 +25,10 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import org.asynchttpclient.AdvancedConfig;
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
@@ -53,7 +53,6 @@
 
     protected final ChannelManager channelManager;
     protected final AsyncHttpClientConfig config;
-    protected final AdvancedConfig advancedConfig;
     protected final NettyRequestSender requestSender;
 
     private final boolean hasResponseFilters;
@@ -68,14 +67,13 @@
         REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
     }
 
-    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, AdvancedConfig advancedConfig, NettyRequestSender requestSender) {
+    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
         this.channelManager = channelManager;
         this.config = config;
         this.requestSender = requestSender;
-        this.advancedConfig = advancedConfig;
 
         hasResponseFilters = !config.getResponseFilters().isEmpty();
-        hasIOExceptionFilters = !config.getIOExceptionFilters().isEmpty();
+        hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
         maxRedirectException = new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
     }
 
@@ -216,9 +214,7 @@ protected boolean exitAfterProcessingFilters(//
                 try {
                     fc = asyncFilter.filter(fc);
                     // FIXME Is it worth protecting against this?
-                    if (fc == null) {
-                        throw new NullPointerException("FilterContext is null");
-                    }
+                    assertNotNull("fc", "filterContext");
                 } catch (FilterException efe) {
                     requestSender.abort(channel, future, efe);
                 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
index e0c23cdd6..32bfae054 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
@@ -29,11 +29,10 @@
 import java.io.IOException;
 import java.util.Locale;
 
-import org.asynchttpclient.AdvancedConfig;
 import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.netty.Callback;
@@ -51,9 +50,8 @@
 
     public WebSocketProtocol(ChannelManager channelManager,//
             AsyncHttpClientConfig config,//
-            AdvancedConfig advancedConfig,//
             NettyRequestSender requestSender) {
-        super(channelManager, config, advancedConfig, requestSender);
+        super(channelManager, config, requestSender);
     }
 
     // We don't need to synchronize as replacing the "ws-decoder" will
@@ -61,7 +59,7 @@ public WebSocketProtocol(ChannelManager channelManager,//
     private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
         if (!h.touchSuccess()) {
             try {
-                h.onSuccess(advancedConfig.getNettyWebSocketFactory().newNettyWebSocket(channel, config));
+                h.onSuccess(new NettyWebSocket(channel, config));
             } catch (Exception ex) {
                 logger.warn("onSuccess unexpected exception", ex);
             }
@@ -158,7 +156,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
                 } else {
                     ByteBuf buf = frame.content();
                     if (buf != null && buf.readableBytes() > 0) {
-                        NettyResponseBodyPart part = advancedConfig.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
+                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
                         handler.onBodyPartReceived(part);
 
                         if (frame instanceof BinaryWebSocketFrame) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 405dcd79e..736490a19 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -141,7 +141,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
         boolean connect = method == HttpMethod.CONNECT;
 
-        boolean allowConnectionPooling = config.isAllowPoolingConnections();
+        boolean allowConnectionPooling = config.isKeepAlive();
 
         HttpVersion httpVersion = !allowConnectionPooling || (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
         String requestUri = requestUri(uri, proxyServer, connect);
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 1a3605f85..7a97d19f9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static org.asynchttpclient.util.Assertions.*;
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
 import static org.asynchttpclient.util.HttpUtils.*;
 import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
@@ -44,6 +45,7 @@
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.channel.NettyConnectListener;
 import org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask;
@@ -87,23 +89,27 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
         validateWebSocketRequest(request, asyncHandler);
 
         ProxyServer proxyServer = getProxyServer(config, request);
-        boolean connectIsDone = future != null //
-                && future.getNettyRequest() != null //
-                && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT //
-                && !request.getMethod().equals(HttpMethod.CONNECT.name());
 
         // websockets use connect tunnelling to work with proxies
-        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !connectIsDone)
-            // SSL proxy or websocket, have to handle CONNECT
+        if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))
             if (future != null && future.isConnectAllowed())
-                // CONNECT forced
+                // SSL proxy or websocket: CONNECT for sure
                 return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, true);
             else
+                // CONNECT will depend if we can pool or connection or if we have to open a new one
                 return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, proxyServer);
         else
+            // no CONNECT for sure
             return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, false);
     }
 
+    private boolean isConnectDone(Request request,NettyResponseFuture<?> future) {
+        return future != null //
+                && future.getNettyRequest() != null //
+                && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT //
+                && !request.getMethod().equals(HttpMethod.CONNECT.name());
+    }
+
     /**
      * We know for sure if we have to force to connect or not, so we can build
      * the HttpRequest right away This reduces the probability of having a
@@ -119,10 +125,10 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
 
         NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
 
-        Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
+        Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
 
         if (Channels.isChannelValid(channel))
-            return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
+            return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
         else
             return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, reclaimCache);
     }
@@ -142,7 +148,7 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
 
         NettyResponseFuture<T> newFuture = null;
         for (int i = 0; i < 3; i++) {
-            Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
+            Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);
             if (Channels.isChannelValid(channel))
                 if (newFuture == null)
                     newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
@@ -150,7 +156,7 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
             if (Channels.isChannelValid(channel))
                 // if the channel is still active, we can use it, otherwise try
                 // gain
-                return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
+                return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);
             else
                 // pool is empty
                 break;
@@ -193,23 +199,23 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
         }
     }
 
-    private Channel getCachedChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+    private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
 
         if (future != null && future.reuseChannel() && Channels.isChannelValid(future.channel()))
             return future.channel();
         else
-            return pollAndVerifyCachedChannel(request, proxyServer, asyncHandler);
+            return pollPooledChannel(request, proxyServer, asyncHandler);
     }
 
-    private <T> ListenableFuture<T> sendRequestWithCachedChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
+    private <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
             AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);
 
-        future.setState(NettyResponseFuture.STATE.POOLED);
+        future.setChannelState(ChannelState.POOLED);
         future.attachChannel(channel, false);
 
-        LOGGER.debug("Using cached Channel {} for {} '{}'", channel, future.getNettyRequest().getHttpRequest().getMethod(), future.getNettyRequest().getHttpRequest().getUri());
+        LOGGER.debug("Using open Channel {} for {} '{}'", channel, future.getNettyRequest().getHttpRequest().getMethod(), future.getNettyRequest().getHttpRequest().getUri());
 
         if (Channels.isChannelValid(channel)) {
             Channels.setAttribute(channel, future);
@@ -358,7 +364,7 @@ public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
             channelManager.closeChannel(channel);
 
         if (!future.isDone()) {
-            future.setState(NettyResponseFuture.STATE.CLOSED);
+            future.setChannelState(ChannelState.CLOSED);
             LOGGER.debug("Aborting Future {}\n", future);
             LOGGER.debug(t.getMessage(), t);
             future.abort(t);
@@ -379,7 +385,7 @@ public boolean retry(NettyResponseFuture<?> future) {
             return false;
 
         if (future.canBeReplayed()) {
-            future.setState(NettyResponseFuture.STATE.RECONNECTED);
+            future.setChannelState(ChannelState.RECONNECTED);
             future.getAndSetStatusReceived(false);
 
             LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
@@ -407,12 +413,10 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
 
         @SuppressWarnings({ "unchecked", "rawtypes" })
         FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getCurrentRequest()).ioException(e).build();
-        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
+        for (IOExceptionFilter asyncFilter : config.getIoExceptionFilters()) {
             try {
                 fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
+                assertNotNull(fc, "filterContext");
             } catch (FilterException efe) {
                 abort(channel, future, efe);
             }
@@ -442,7 +446,7 @@ else if (!request.getMethod().equals(HttpMethod.GET.name()))
         }
     }
 
-    private Channel pollAndVerifyCachedChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
+    private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
             AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPool();
@@ -452,13 +456,7 @@ private Channel pollAndVerifyCachedChannel(Request request, ProxyServer proxy, A
         final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getConnectionPoolPartitioning());
 
         if (channel != null) {
-            LOGGER.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
-
-            try {
-                channelManager.verifyChannelPipeline(channel.pipeline(), uri, virtualHost);
-            } catch (Exception ex) {
-                LOGGER.debug(ex.getMessage(), ex);
-            }
+            LOGGER.debug("Using polled Channel {}\n for uri {}\n", channel, uri);
         }
         return channel;
     }
@@ -468,7 +466,7 @@ public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc,
 
         Request newRequest = fc.getRequest();
         future.setAsyncHandler(fc.getAsyncHandler());
-        future.setState(NettyResponseFuture.STATE.NEW);
+        future.setChannelState(ChannelState.NEW);
         future.touch();
 
         LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java b/client/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
index ac8b53ef9..3f5b9fe42 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
@@ -22,6 +22,7 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
@@ -49,7 +50,7 @@ public ProgressListener(AsyncHandler<?> asyncHandler,//
 
     private boolean abortOnThrowable(Throwable cause, Channel channel) {
 
-        if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
+        if (cause != null && future.getChannelState() != ChannelState.NEW) {
             if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
                 LOGGER.debug(cause.getMessage(), cause);
                 Channels.silentlyCloseChannel(channel);
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index c53b8e17d..b20281339 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -13,21 +13,19 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import org.asynchttpclient.request.body.Body;
-
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.stream.ChunkedInput;
 
-import java.nio.ByteBuffer;
+import org.asynchttpclient.request.body.Body;
 
 /**
  * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
  */
 public class BodyChunkedInput implements ChunkedInput<ByteBuf> {
 
-    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
+    public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
 
     private final Body body;
     private final int contentLength;
@@ -36,8 +34,7 @@
     private boolean endOfInput;
 
     public BodyChunkedInput(Body body) {
-        if (body == null)
-            throw new NullPointerException("body");
+        assertNotNull(body, "body");
         this.body = body;
         contentLength = (int) body.getContentLength();
         if (contentLength <= 0)
@@ -52,20 +49,17 @@ public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
         if (endOfInput)
             return null;
 
-        // FIXME pass a visitor so we can directly pass a pooled ByteBuf
-        ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-        Body.State state = body.read(buffer);
+        ByteBuf buffer = ctx.alloc().buffer(chunkSize);
+        Body.BodyState state = body.transferTo(buffer);
         switch (state) {
-            case Stop:
+            case STOP:
                 endOfInput = true;
-                buffer.flip();
-                return Unpooled.wrappedBuffer(buffer);
-            case Suspend:
+                return buffer;
+            case SUSPEND:
                 //this will suspend the stream in ChunkedWriteHandler
                 return null;
-            case Continue:
-                buffer.flip();
-                return Unpooled.wrappedBuffer(buffer);
+            case CONTINUE:
+                return buffer;
             default:
                 throw new IllegalStateException("Unknown state: " + state);
         }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
index b6934449e..792d96f23 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -13,6 +13,8 @@
  */
 package org.asynchttpclient.netty.request.body;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import org.asynchttpclient.request.body.RandomAccessBody;
@@ -31,8 +33,7 @@
     private long transfered;
 
     public BodyFileRegion(RandomAccessBody body) {
-        if (body == null)
-            throw new NullPointerException("body");
+        assertNotNull(body, "body");
         this.body = body;
     }
 
@@ -53,7 +54,7 @@ public long transfered() {
 
     @Override
     public long transferTo(WritableByteChannel target, long position) throws IOException {
-        long written = body.transferTo(position, target);
+        long written = body.transferTo(target);
         if (written > 0) {
             transfered += written;
         }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
index 6529dea15..f824aa65a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
@@ -13,18 +13,15 @@
  */
 package org.asynchttpclient.netty.request.body;
 
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.channel.DefaultFileRegion;
-import io.netty.channel.FileRegion;
 import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.stream.ChunkedFile;
+import io.netty.handler.stream.ChunkedNioFile;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.netty.NettyResponseFuture;
@@ -72,26 +69,16 @@ public String getContentType() {
 
     @Override
     public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
-        final RandomAccessFile raf = new RandomAccessFile(file, "r");
+        @SuppressWarnings("resource")
+        // Netty will close the ChunkedNioFile or the DefaultFileRegion
+        final FileChannel fileChannel = new RandomAccessFile(file, "r").getChannel();
 
-        try {
-            ChannelFuture writeFuture;
-            if (ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy()) {
-                writeFuture = channel.write(new ChunkedFile(raf, offset, length, config.getChunkedFileChunkSize()), channel.newProgressivePromise());
-            } else {
-                FileRegion region = new DefaultFileRegion(raf.getChannel(), offset, length);
-                writeFuture = channel.write(region, channel.newProgressivePromise());
-            }
-            writeFuture.addListener(new ProgressListener(future.getAsyncHandler(), future, false, getContentLength()) {
-                public void operationComplete(ChannelProgressiveFuture cf) {
-                    closeSilently(raf);
-                    super.operationComplete(cf);
-                }
-            });
-            channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
-        } catch (IOException ex) {
-            closeSilently(raf);
-            throw ex;
-        }
+        Object message = (ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy()) ? //
+        new ChunkedNioFile(fileChannel, offset, length, config.getChunkedFileChunkSize())
+                : new DefaultFileRegion(fileChannel, offset, length);
+
+        channel.write(message, channel.newProgressivePromise())//
+                .addListener(new ProgressListener(future.getAsyncHandler(), future, false, getContentLength()));
+        channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
new file mode 100644
index 000000000..4658289e1
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/DefaultSslEngineFactory.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ssl;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
+import io.netty.handler.ssl.SslProvider;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class DefaultSslEngineFactory extends SslEngineFactoryBase {
+
+    private final SslContext sslContext;
+
+    public DefaultSslEngineFactory(AsyncHttpClientConfig config) throws SSLException {
+        this.sslContext = getSslContext(config);
+    }
+
+    private SslContext getSslContext(AsyncHttpClientConfig config) throws SSLException {
+        if (config.getSslContext() != null)
+            return config.getSslContext();
+
+        SslContextBuilder sslContextBuilder = SslContextBuilder.forClient()//
+                .sslProvider(config.isUseOpenSsl() ? SslProvider.OPENSSL : SslProvider.JDK)//
+                .sessionCacheSize(config.getSslSessionCacheSize())//
+                .sessionTimeout(config.getSslSessionTimeout());
+
+        if (config.isAcceptAnyCertificate())
+            sslContextBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);
+
+        return sslContextBuilder.build();
+    }
+
+    @Override
+    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+        // FIXME should be using ctx allocator
+        SSLEngine sslEngine = sslContext.newEngine(ByteBufAllocator.DEFAULT, peerHost, peerPort);
+        configureSslEngine(sslEngine, config);
+        return sslEngine;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
new file mode 100644
index 000000000..6e5b190f3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ssl;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class JsseSslEngineFactory extends SslEngineFactoryBase {
+
+    private final SSLContext sslContext;
+
+    public JsseSslEngineFactory(SSLContext sslContext) {
+        this.sslContext = sslContext;
+    }
+
+    @Override
+    public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int peerPort) {
+        SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
+        configureSslEngine(sslEngine, config);
+        return sslEngine;
+    }
+
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
new file mode 100644
index 000000000..3b2fd1bce
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/SslEngineFactoryBase.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ssl;
+
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLParameters;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.SslEngineFactory;
+
+public abstract class SslEngineFactoryBase implements SslEngineFactory {
+
+    protected void configureSslEngine(SSLEngine sslEngine, AsyncHttpClientConfig config) {
+        sslEngine.setUseClientMode(true);
+        if (!config.isAcceptAnyCertificate()) {
+            SSLParameters params = sslEngine.getSSLParameters();
+            params.setEndpointIdentificationAlgorithm("HTTPS");
+            sslEngine.setSSLParameters(params);
+        }
+
+        if (isNonEmpty(config.getEnabledProtocols()))
+            sslEngine.setEnabledProtocols(config.getEnabledProtocols());
+
+        if (isNonEmpty(config.getEnabledCipherSuites()))
+            sslEngine.setEnabledCipherSuites(config.getEnabledCipherSuites());
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index a72d27bfe..872110d97 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -31,9 +31,8 @@
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.ws.WebSocket;
 import org.asynchttpclient.ws.WebSocketByteFragmentListener;
 import org.asynchttpclient.ws.WebSocketByteListener;
@@ -248,7 +247,7 @@ public void onBinaryFragment(HttpResponseBodyPart part) {
         }
 
         if (interestedInByteMessages) {
-            byte[] fragment = NettyResponseBodyPart.class.cast(part).getBodyPartBytes();
+            byte[] fragment = part.getBodyPartBytes();
 
             if (part.isLast()) {
                 if (bufferSize == 0) {
@@ -284,7 +283,7 @@ public void onTextFragment(HttpResponseBodyPart part) {
         }
 
         if (interestedInTextMessages) {
-            byte[] fragment = NettyResponseBodyPart.class.cast(part).getBodyPartBytes();
+            byte[] fragment = part.getBodyPartBytes();
 
             if (part.isLast()) {
                 if (bufferSize == 0) {
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index 5762b19fd..a8a4f06fe 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -16,6 +16,7 @@
  */
 package org.asynchttpclient.proxy;
 
+import static org.asynchttpclient.util.Assertions.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.util.ArrayList;
@@ -79,9 +80,7 @@ public Realm getRealm() {
      * @see <a href="https://docs.oracle.com/javase/8/docs/api/java/net/doc-files/net-properties.html">Networking Properties</a>
      */
     public boolean isIgnoredForHost(String hostname) {
-        if (hostname == null)
-            throw new NullPointerException("hostname");
-
+        assertNotNull(hostname, "hostname");
         if (isNonEmpty(nonProxyHosts)) {
             for (String nonProxyHost : nonProxyHosts) {
                 if (matchNonProxyHost(hostname, nonProxyHost))
diff --git a/client/src/main/java/org/asynchttpclient/request/body/Body.java b/client/src/main/java/org/asynchttpclient/request/body/Body.java
index 69252c5ad..b31185a52 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/Body.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -13,31 +13,32 @@
 
 package org.asynchttpclient.request.body;
 
+import io.netty.buffer.ByteBuf;
+
 import java.io.Closeable;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 
 /**
  * A request body.
  */
 public interface Body extends Closeable {
 
-    enum State {
+    enum BodyState {
 
         /**
          * There's something to read
          */
-        Continue,
+        CONTINUE,
 
         /**
          * There's nothing to read and input has to suspend
          */
-        Suspend,
+        SUSPEND,
 
         /**
          * There's nothing to read and input has to stop
          */
-        Stop;
+        STOP;
     }
 
     /**
@@ -50,10 +51,9 @@
     /**
      * Reads the next chunk of bytes from the body.
      *
-     * @param buffer The buffer to store the chunk in, must not be {@code null}.
+     * @param target The buffer to store the chunk in, must not be {@code null}.
      * @return The non-negative number of bytes actually read or {@code -1} if the body has been read completely.
      * @throws IOException If the chunk could not be read.
      */
-    // FIXME introduce a visitor pattern so that Netty can pass a pooled buffer
-    State read(ByteBuffer buffer) throws IOException;
+    BodyState transferTo(ByteBuf target) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
index 7dbf616c9..e5bea4bf8 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
@@ -24,13 +24,11 @@
     /**
      * Transfers the specified chunk of bytes from this body to the specified channel.
      * 
-     * @param position
-     *            The zero-based byte index from which to start the transfer, must not be negative.
      * @param target
      *            The destination channel to transfer the body chunk to, must not be {@code null}.
      * @return The non-negative number of bytes actually transferred.
      * @throws IOException
      *             If the body chunk could not be transferred.
      */
-    long transferTo(long position, WritableByteChannel target) throws IOException;
+    long transferTo(WritableByteChannel target) throws IOException;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
index 0f7c02c27..9790b0fee 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
@@ -12,8 +12,9 @@
  */
 package org.asynchttpclient.request.body.generator;
 
+import io.netty.buffer.ByteBuf;
+
 import java.io.IOException;
-import java.nio.ByteBuffer;
 
 import org.asynchttpclient.request.body.Body;
 
@@ -36,21 +37,22 @@ public long getContentLength() {
             return bytes.length;
         }
 
-        public State read(ByteBuffer byteBuffer) throws IOException {
+        public BodyState transferTo(ByteBuf target) throws IOException {
 
             if (eof) {
-                return State.Stop;
+                return BodyState.STOP;
             }
 
             final int remaining = bytes.length - lastPosition;
-            if (remaining <= byteBuffer.capacity()) {
-                byteBuffer.put(bytes, lastPosition, remaining);
+            final int initialTargetWritableBytes = target.writableBytes();
+            if (remaining <= initialTargetWritableBytes) {
+                target.writeBytes(bytes, lastPosition, remaining);
                 eof = true;
             } else {
-                byteBuffer.put(bytes, lastPosition, byteBuffer.capacity());
-                lastPosition = lastPosition + byteBuffer.capacity();
+                target.writeBytes(bytes, lastPosition, initialTargetWritableBytes);
+                lastPosition += initialTargetWritableBytes;
             }
-            return State.Continue;
+            return BodyState.CONTINUE;
         }
 
         public void close() throws IOException {
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
index d735396b5..1921b1b5b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -22,8 +22,6 @@
 public interface FeedableBodyGenerator extends BodyGenerator {
     void feed(ByteBuffer buffer, boolean isLast);
 
-    void writeChunkBoundaries();
-
     void setListener(FeedListener listener);
 
     interface FeedListener {
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
index acbe38981..841f10c89 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.request.body.generator;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import java.io.File;
 
 import org.asynchttpclient.request.body.RandomAccessBody;
@@ -30,9 +32,7 @@ public FileBodyGenerator(File file) {
     }
 
     public FileBodyGenerator(File file, long regionSeek, long regionLength) {
-        if (file == null) {
-            throw new NullPointerException("file");
-        }
+        assertNotNull(file, "file");
         this.file = file;
         this.regionLength = regionLength;
         this.regionSeek = regionSeek;
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
index 80774b7d8..ad7057139 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
@@ -13,13 +13,14 @@
 
 package org.asynchttpclient.request.body.generator;
 
-import org.asynchttpclient.request.body.Body;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import io.netty.buffer.ByteBuf;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.ByteBuffer;
+
+import org.asynchttpclient.request.body.Body;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
@@ -61,10 +62,10 @@ public long getContentLength() {
             return -1L;
         }
 
-        public State read(ByteBuffer buffer) throws IOException {
+        public BodyState transferTo(ByteBuf target) throws IOException {
 
             // To be safe.
-            chunk = new byte[buffer.remaining() - 10];
+            chunk = new byte[target.writableBytes() - 10];
 
             int read = -1;
             boolean write = false;
@@ -75,10 +76,10 @@ public State read(ByteBuffer buffer) throws IOException {
             }
 
             if (read > 0) {
-                buffer.put(chunk, 0, read);
+                target.writeBytes(chunk, 0, read);
                 write = true;
             }
-            return write ? State.Continue : State.Stop;
+            return write ? BodyState.CONTINUE : BodyState.STOP;
         }
 
         public void close() throws IOException {
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
index ade089562..efddc0b73 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.request.body.generator;
 
+import io.netty.buffer.ByteBuf;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -45,11 +47,6 @@ public void feed(ByteBuffer buffer, boolean isLast) {
         feedableBodyGenerator.feed(buffer, isLast);
     }
 
-    @Override
-    public void writeChunkBoundaries() {
-        feedableBodyGenerator.writeChunkBoundaries();
-    }
-
     @Override
     public void setListener(FeedListener listener) {
         feedListener.set(listener);
@@ -83,11 +80,11 @@ public long getContentLength() {
         }
 
         @Override
-        public State read(ByteBuffer buffer) throws IOException {
+        public BodyState transferTo(ByteBuf target) throws IOException {
             if(initialized.compareAndSet(false, true))
                 publisher.subscribe(subscriber);
 
-            return body.read(buffer);
+            return body.transferTo(target);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
index 9569bac5f..279b2771c 100755
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
@@ -13,7 +13,7 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
+import io.netty.buffer.ByteBuf;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -23,15 +23,9 @@
 import org.asynchttpclient.request.body.Body;
 
 public final class SimpleFeedableBodyGenerator implements FeedableBodyGenerator, BodyGenerator {
-    private final static byte[] END_PADDING = "\r\n".getBytes(US_ASCII);
-    private final static byte[] ZERO = "0".getBytes(US_ASCII);
-    private final static ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
     private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<>();
     private FeedListener listener;
 
-    // must be set to true when using Netty 3 where native chunking is broken
-    private boolean writeChunkBoundaries = false;
-
     @Override
     public Body createBody() {
         return new PushBody();
@@ -50,14 +44,9 @@ public void setListener(FeedListener listener) {
         this.listener = listener;
     }
 
-    @Override
-    public void writeChunkBoundaries() {
-        this.writeChunkBoundaries = true;
-    }
-
     public final class PushBody implements Body {
 
-        private State state = State.Continue;
+        private BodyState state = BodyState.CONTINUE;
 
         @Override
         public long getContentLength() {
@@ -65,20 +54,20 @@ public long getContentLength() {
         }
 
         @Override
-        public State read(final ByteBuffer buffer) throws IOException {
+        public BodyState transferTo(final ByteBuf target) throws IOException {
             switch (state) {
-                case Continue:
-                    return readNextPart(buffer);
-                case Stop:
-                    return State.Stop;
+                case CONTINUE:
+                    return readNextPart(target);
+                case STOP:
+                    return BodyState.STOP;
                 default:
                     throw new IllegalStateException("Illegal process state.");
             }
         }
 
-        private State readNextPart(ByteBuffer buffer) throws IOException {
-            State res = State.Suspend;
-            while (buffer.hasRemaining() && state != State.Stop) {
+        private BodyState readNextPart(ByteBuf target) throws IOException {
+            BodyState res = BodyState.SUSPEND;
+            while (target.isWritable() && state != BodyState.STOP) {
                 BodyPart nextPart = queue.peek();
                 if (nextPart == null) {
                     // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
@@ -87,22 +76,19 @@ private State readNextPart(ByteBuffer buffer) throws IOException {
                     // skip empty buffers
                     queue.remove();
                 } else {
-                    res = State.Continue;
-                    readBodyPart(buffer, nextPart);
+                    res = BodyState.CONTINUE;
+                    readBodyPart(target, nextPart);
                 }
             }
             return res;
         }
 
-        private void readBodyPart(ByteBuffer buffer, BodyPart part) {
-            part.initBoundaries();
-            move(buffer, part.size);
-            move(buffer, part.buffer);
-            move(buffer, part.endPadding);
+        private void readBodyPart(ByteBuf target, BodyPart part) {
+            move(target, part.buffer);
 
-            if (!part.buffer.hasRemaining() && !part.endPadding.hasRemaining()) {
+            if (!part.buffer.hasRemaining()) {
                 if (part.isLast) {
-                    state = State.Stop;
+                    state = BodyState.STOP;
                 }
                 queue.remove();
             }
@@ -113,59 +99,23 @@ public void close() {
         }
     }
 
-    private void move(ByteBuffer destination, ByteBuffer source) {
-        int size = Math.min(destination.remaining(), source.remaining());
+    private void move(ByteBuf target, ByteBuffer source) {
+        int size = Math.min(target.writableBytes(), source.remaining());
         if (size > 0) {
             ByteBuffer slice = source.slice();
             slice.limit(size);
-            destination.put(slice);
+            target.writeBytes(slice);
             source.position(source.position() + size);
         }
     }
 
     private final class BodyPart {
         private final boolean isLast;
-        private ByteBuffer size = null;
         private final ByteBuffer buffer;
-        private ByteBuffer endPadding = null;
 
         public BodyPart(final ByteBuffer buffer, final boolean isLast) {
             this.buffer = buffer;
             this.isLast = isLast;
         }
-
-        private void initBoundaries() {
-            if(size == null && endPadding == null) {
-                if (SimpleFeedableBodyGenerator.this.writeChunkBoundaries) {
-                    if(buffer.hasRemaining()) {
-                        final byte[] sizeAsHex = Integer.toHexString(buffer.remaining()).getBytes(US_ASCII);
-                        size = ByteBuffer.allocate(sizeAsHex.length + END_PADDING.length);
-                        size.put(sizeAsHex);
-                        size.put(END_PADDING);
-                        size.flip();
-                    } else {
-                        size = EMPTY_BUFFER;
-                    }
-
-                    if(isLast) {
-                        endPadding = ByteBuffer.allocate(END_PADDING.length * 3 + ZERO.length);
-                        if(buffer.hasRemaining()) {
-                            endPadding.put(END_PADDING);
-                        }
-
-                        //add last empty
-                        endPadding.put(ZERO);
-                        endPadding.put(END_PADDING);
-                        endPadding.put(END_PADDING);
-                        endPadding.flip();
-                    } else {
-                        endPadding = ByteBuffer.wrap(END_PADDING);
-                    }
-                } else {
-                    size = EMPTY_BUFFER;
-                    endPadding = EMPTY_BUFFER;
-                }
-            }
-        }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
index 039a735c6..0841ae119 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
@@ -12,11 +12,11 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 import java.nio.charset.Charset;
 
-public class ByteArrayPart extends AbstractFilePart {
+public class ByteArrayPart extends FileLikePart {
 
     private final byte[] bytes;
 
@@ -42,35 +42,12 @@ public ByteArrayPart(String name, byte[] bytes, String contentType, Charset char
 
     public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
         super(name, contentType, charset, contentId, transferEncoding);
-        if (bytes == null)
-            throw new NullPointerException("bytes");
+        assertNotNull(bytes, "bytes");
         this.bytes = bytes;
         setFileName(fileName);
     }
-    
-    @Override
-    protected long getDataLength() {
-        return bytes.length;
-    }
 
     public byte[] getBytes() {
         return bytes;
     }
-
-    @Override
-    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
-        FilePartStallHandler handler = new FilePartStallHandler(getStalledTime(), this);
-
-        try {
-            handler.start();
-
-            long length = MultipartUtils.writeBytesToChannel(target, generateFileStart(boundary));
-            length += MultipartUtils.writeBytesToChannel(target, bytes);
-            length += MultipartUtils.writeBytesToChannel(target, generateFileEnd());
-
-            return length;
-        } finally {
-            handler.completed();
-        }
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
similarity index 54%
rename from client/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java
rename to client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
index 68f42bae4..069e8189b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
@@ -12,16 +12,12 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.*;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.nio.charset.Charset;
 
 /**
  * This class is an adaptation of the Apache HttpClient implementation
  */
-public abstract class AbstractFilePart extends PartBase {
+public abstract class FileLikePart extends PartBase {
 
     /**
      * Default content encoding of file attachments.
@@ -33,13 +29,6 @@
      */
     public static final String DEFAULT_TRANSFER_ENCODING = "binary";
 
-    /**
-     * Attachment's file name as a byte array
-     */
-    private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
-
-    private long stalledTime = -1L;
-
     private String fileName;
 
     /**
@@ -51,7 +40,7 @@
      * @param contentId the content id
      * @param transfertEncoding the transfer encoding
      */
-    public AbstractFilePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
+    public FileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
         super(name,//
                 contentType == null ? DEFAULT_CONTENT_TYPE : contentType,//
                 charset,//
@@ -59,44 +48,6 @@ public AbstractFilePart(String name, String contentType, Charset charset, String
                 transfertEncoding == null ? DEFAULT_TRANSFER_ENCODING : transfertEncoding);
     }
 
-    protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
-        super.visitDispositionHeader(visitor);
-        if (fileName != null) {
-            visitor.withBytes(FILE_NAME_BYTES);
-            visitor.withByte(QUOTE_BYTE);
-            visitor.withBytes(fileName.getBytes(getCharset() != null ? getCharset() : US_ASCII));
-            visitor.withByte(QUOTE_BYTE);
-        }
-    }
-
-    protected byte[] generateFileStart(byte[] boundary) throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
-        visitStart(visitor, boundary);
-        visitDispositionHeader(visitor);
-        visitContentTypeHeader(visitor);
-        visitTransferEncodingHeader(visitor);
-        visitContentIdHeader(visitor);
-        visitCustomHeaders(visitor);
-        visitEndOfHeaders(visitor);
-        return out.toByteArray();
-    }
-
-    protected byte[] generateFileEnd() throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
-        visitEnd(visitor);
-        return out.toByteArray();
-    }
-
-    public void setStalledTime(long ms) {
-        stalledTime = ms;
-    }
-
-    public long getStalledTime() {
-        return stalledTime;
-    }
-
     public void setFileName(String fileName) {
         this.fileName = fileName;
     }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
index cf5eeac2f..248fc5076 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
@@ -12,19 +12,12 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+
 import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class FilePart extends AbstractFilePart {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(FilePart.class);
+public class FilePart extends FileLikePart {
 
     private final File file;
 
@@ -50,8 +43,7 @@ public FilePart(String name, File file, String contentType, Charset charset, Str
 
     public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
         super(name, contentType, charset, contentId, transferEncoding);
-        if (file == null)
-            throw new NullPointerException("file");
+        assertNotNull(file, "file");
         if (!file.isFile())
             throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
         if (!file.canRead())
@@ -59,62 +51,8 @@ public FilePart(String name, File file, String contentType, Charset charset, Str
         this.file = file;
         setFileName(fileName != null ? fileName : file.getName());
     }
-    
-    @Override
-    protected long getDataLength() {
-        return file.length();
-    }
 
     public File getFile() {
         return file;
     }
-
-    @Override
-    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
-        FilePartStallHandler handler = new FilePartStallHandler(getStalledTime(), this);
-
-        handler.start();
-
-        int length = 0;
-
-        length += MultipartUtils.writeBytesToChannel(target, generateFileStart(boundary));
-
-        RandomAccessFile raf = new RandomAccessFile(file, "r");
-        FileChannel fc = raf.getChannel();
-
-        long l = file.length();
-        int fileLength = 0;
-        long nWrite = 0;
-        // FIXME why sync?
-        try {
-            synchronized (fc) {
-                while (fileLength != l) {
-                    if (handler.isFailed()) {
-                        LOGGER.debug("Stalled error");
-                        throw new FileUploadStalledException();
-                    }
-                    nWrite = fc.transferTo(fileLength, l, target);
-
-                    if (nWrite == 0) {
-                        LOGGER.info("Waiting for writing...");
-                        try {
-                            fc.wait(50);
-                        } catch (InterruptedException e) {
-                            LOGGER.trace(e.getMessage(), e);
-                        }
-                    } else {
-                        handler.writeHappened();
-                    }
-                    fileLength += nWrite;
-                }
-            }
-        } finally {
-            handler.completed();
-            raf.close();
-        }
-
-        length += MultipartUtils.writeBytesToChannel(target, generateFileEnd());
-
-        return length;
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java
deleted file mode 100644
index ba07e1d84..000000000
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.request.body.multipart;
-
-import java.util.Timer;
-import java.util.TimerTask;
-
-/**
- * @author Gail Hernandez
- */
-public class FilePartStallHandler extends TimerTask {
-
-    private final long waitTime;
-    private Timer timer;
-    private volatile boolean failed;
-    private volatile boolean written;
-
-    public FilePartStallHandler(long waitTime, AbstractFilePart filePart) {
-        this.waitTime = waitTime;
-        failed = false;
-        written = false;
-    }
-
-    public void completed() {
-        if (waitTime > 0) {
-            timer.cancel();
-        }
-    }
-
-    public boolean isFailed() {
-        return failed;
-    }
-
-    public void run() {
-        if (!written) {
-            failed = true;
-            timer.cancel();
-        }
-        written = false;
-    }
-
-    public void start() {
-        if (waitTime > 0) {
-            timer = new Timer();
-            timer.scheduleAtFixedRate(this, waitTime, waitTime);
-        }
-    }
-
-    public void writeHappened() {
-        written = true;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
index 6802179fa..d38915ed2 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
@@ -1,9 +1,10 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
@@ -12,51 +13,64 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import org.asynchttpclient.request.body.RandomAccessBody;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import io.netty.buffer.ByteBuf;
 
 import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
 import java.nio.channels.WritableByteChannel;
-import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.RandomAccessBody;
+import org.asynchttpclient.request.body.multipart.part.MultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MultipartState;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class MultipartBody implements RandomAccessBody {
 
     private final static Logger LOGGER = LoggerFactory.getLogger(MultipartBody.class);
 
+    private final List<MultipartPart<? extends Part>> parts;
+    private final String contentType;
     private final byte[] boundary;
     private final long contentLength;
-    private final String contentType;
-    private final List<Part> parts;
-    private final List<RandomAccessFile> pendingOpenFiles = new ArrayList<>();
-
-    private boolean transfertDone = false;
-
-    private int currentPart = 0;
-    private byte[] currentBytes;
-    private int currentBytesPosition = -1;
-    private boolean doneWritingParts = false;
-    private FileLocation fileLocation = FileLocation.NONE;
-    private FileChannel currentFileChannel;
-
-    enum FileLocation {
-        NONE, START, MIDDLE, END
-    }
+    private int currentPartIndex;
+    private boolean done = false;
+    private AtomicBoolean closed = new AtomicBoolean();
 
-    public MultipartBody(List<Part> parts, String contentType, long contentLength, byte[] boundary) {
+    public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
+        assertNotNull(parts, "parts");
         this.boundary = boundary;
-        this.contentLength = contentLength;
         this.contentType = contentType;
         this.parts = parts;
+        this.contentLength = computeContentLength();
+    }
+
+    private long computeContentLength() {
+        try {
+            long total = 0;
+            for (MultipartPart<? extends Part> part : parts) {
+                long l = part.length();
+                if (l < 0) {
+                    return -1;
+                }
+                total += l;
+            }
+            return total;
+        } catch (Exception e) {
+            LOGGER.error("An exception occurred while getting the length of the parts", e);
+            return 0L;
+        }
     }
 
     public void close() throws IOException {
-        for (RandomAccessFile file : pendingOpenFiles) {
-            file.close();
+        if (closed.compareAndSet(false, true)) {
+            for (MultipartPart<? extends Part> part : parts) {
+                closeSilently(part);
+            }
         }
     }
 
@@ -72,173 +86,50 @@ public String getContentType() {
         return boundary;
     }
 
-    // RandomAccessBody API, suited for HTTP but not for HTTPS
-    public long transferTo(long position, WritableByteChannel target) throws IOException {
-
-        long overallLength = 0;
-
-        if (transfertDone) {
-            return -1;
-        }
-
-        for (Part part : parts) {
-            overallLength += part.write(target, boundary);
-        }
-
-        overallLength += MultipartUtils.writeBytesToChannel(target, MultipartUtils.getMessageEnd(boundary));
-
-        transfertDone = true;
-
-        return overallLength;
-    }
-
     // Regular Body API
-    public State read(ByteBuffer buffer) throws IOException {
-        try {
-            int overallLength = 0;
-
-            int maxLength = buffer.remaining();
-
-            if (currentPart == parts.size() && transfertDone) {
-                return State.Stop;
-            }
-
-            boolean full = false;
-
-            while (!full && !doneWritingParts) {
-                Part part = null;
-
-                if (currentPart < parts.size()) {
-                    part = parts.get(currentPart);
-                }
-                if (currentFileChannel != null) {
-                    overallLength += writeCurrentFile(buffer);
-                    full = overallLength == maxLength;
-
-                } else if (currentBytesPosition > -1) {
-                    overallLength += writeCurrentBytes(buffer, maxLength - overallLength);
-                    full = overallLength == maxLength;
-
-                    if (currentPart == parts.size() && currentBytesFullyRead()) {
-                        doneWritingParts = true;
-                    }
-
-                } else if (part instanceof StringPart) {
-                    StringPart stringPart = (StringPart) part;
-                    // set new bytes, not full, so will loop to writeCurrentBytes above
-                    initializeCurrentBytes(stringPart.getBytes(boundary));
-                    currentPart++;
-
-                } else if (part instanceof AbstractFilePart) {
-
-                    AbstractFilePart filePart = (AbstractFilePart) part;
-
-                    switch (fileLocation) {
-                    case NONE:
-                        // set new bytes, not full, so will loop to writeCurrentBytes above
-                        initializeCurrentBytes(filePart.generateFileStart(boundary));
-                        fileLocation = FileLocation.START;
-                        break;
-                    case START:
-                        // set current file channel so code above executes first
-                        initializeFileBody(filePart);
-                        fileLocation = FileLocation.MIDDLE;
-                        break;
-                    case MIDDLE:
-                        initializeCurrentBytes(filePart.generateFileEnd());
-                        fileLocation = FileLocation.END;
-                        break;
-                    case END:
-                        currentPart++;
-                        fileLocation = FileLocation.NONE;
-                        if (currentPart == parts.size()) {
-                            doneWritingParts = true;
-                        }
-                    }
-                }
-            }
+    public BodyState transferTo(ByteBuf target) throws IOException {
 
-            if (doneWritingParts) {
-                if (currentBytesPosition == -1) {
-                    initializeCurrentBytes(MultipartUtils.getMessageEnd(boundary));
-                }
+        if (done)
+            return BodyState.STOP;
 
-                if (currentBytesPosition > -1) {
-                    overallLength += writeCurrentBytes(buffer, maxLength - overallLength);
+        while (target.isWritable() && !done) {
+            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+            currentPart.transferTo(target);
 
-                    if (currentBytesFullyRead()) {
-                        currentBytes = null;
-                        currentBytesPosition = -1;
-                        transfertDone = true;
-                    }
+            if (currentPart.getState() == MultipartState.DONE) {
+                currentPartIndex++;
+                if (currentPartIndex == parts.size()) {
+                    done = true;
                 }
             }
-            return transfertDone ? State.Stop : State.Continue;
-
-        } catch (Exception e) {
-            LOGGER.error("Read exception", e);
-            return State.Stop;
         }
-    }
 
-    private boolean currentBytesFullyRead() {
-        return currentBytes == null || currentBytesPosition >= currentBytes.length - 1;
+        return BodyState.CONTINUE;
     }
 
-    private void initializeFileBody(AbstractFilePart part) throws IOException {
+    // RandomAccessBody API, suited for HTTP but not for HTTPS (zero-copy)
+    @Override
+    public long transferTo(WritableByteChannel target) throws IOException {
 
-        if (part instanceof FilePart) {
-            RandomAccessFile raf = new RandomAccessFile(FilePart.class.cast(part).getFile(), "r");
-            pendingOpenFiles.add(raf);
-            currentFileChannel = raf.getChannel();
+        if (done)
+            return -1L;
 
-        } else if (part instanceof ByteArrayPart) {
-            initializeCurrentBytes(ByteArrayPart.class.cast(part).getBytes());
+        long transferred = 0L;
+        boolean slowTarget = false;
 
-        } else {
-            throw new IllegalArgumentException("Unknow AbstractFilePart type");
-        }
-    }
+        while (transferred < BodyChunkedInput.DEFAULT_CHUNK_SIZE && !done && !slowTarget) {
+            MultipartPart<? extends Part> currentPart = parts.get(currentPartIndex);
+            transferred += currentPart.transferTo(target);
+            slowTarget = currentPart.isTargetSlow();
 
-    private void initializeCurrentBytes(byte[] bytes) throws IOException {
-        currentBytes = bytes;
-        currentBytesPosition = 0;
-    }
-
-    private int writeCurrentFile(ByteBuffer buffer) throws IOException {
-
-        int read = currentFileChannel.read(buffer);
-
-        if (currentFileChannel.position() == currentFileChannel.size()) {
-
-            currentFileChannel.close();
-            currentFileChannel = null;
-
-            int currentFile = pendingOpenFiles.size() - 1;
-            pendingOpenFiles.get(currentFile).close();
-            pendingOpenFiles.remove(currentFile);
-        }
-
-        return read;
-    }
-
-    private int writeCurrentBytes(ByteBuffer buffer, int length) throws IOException {
-
-        int available = currentBytes.length - currentBytesPosition;
-
-        int writeLength = Math.min(available, length);
-
-        if (writeLength > 0) {
-            buffer.put(currentBytes, currentBytesPosition, writeLength);
-
-            if (available <= length) {
-                currentBytesPosition = -1;
-                currentBytes = null;
-            } else {
-                currentBytesPosition += writeLength;
+            if (currentPart.getState() == MultipartState.DONE) {
+                currentPartIndex++;
+                if (currentPartIndex == parts.size()) {
+                    done = true;
+                }
             }
         }
 
-        return writeLength;
+        return transferred;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index d64f000b7..784e714f3 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -1,44 +1,35 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.request.body.multipart;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.request.body.multipart.Part.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-import java.nio.channels.WritableByteChannel;
+import java.util.ArrayList;
 import java.util.List;
-import java.util.Random;
-import java.util.Set;
+import java.util.concurrent.ThreadLocalRandom;
 
+import org.asynchttpclient.request.body.multipart.part.ByteArrayMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.FileMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MessageEndMultipartPart;
+import org.asynchttpclient.request.body.multipart.part.MultipartPart;
 import org.asynchttpclient.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 public class MultipartUtils {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(MultipartUtils.class);
-
     /**
      * The Content-Type for multipart/form-data.
      */
@@ -47,11 +38,7 @@
     /**
      * The pool of ASCII chars to be used for generating a multipart boundary.
      */
-    private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
-            .getBytes(US_ASCII);
-
-    private MultipartUtils() {
-    }
+    private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(US_ASCII);
 
     /**
      * Creates a new multipart entity containing the given parts.
@@ -61,11 +48,9 @@ private MultipartUtils() {
      * @return a MultipartBody
      */
     public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders requestHeaders) {
-        if (parts == null) {
-            throw new NullPointerException("parts");
-        }
+        assertNotNull(parts, "parts");
 
-        byte[] multipartBoundary;
+        byte[] boundary;
         String contentType;
 
         String contentTypeHeader = requestHeaders.get(HttpHeaders.Names.CONTENT_TYPE);
@@ -74,128 +59,70 @@ public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders reque
             if (boundaryLocation != -1) {
                 // boundary defined in existing Content-Type
                 contentType = contentTypeHeader;
-                multipartBoundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim())
-                        .getBytes(US_ASCII);
+                boundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim()).getBytes(US_ASCII);
             } else {
                 // generate boundary and append it to existing Content-Type
-                multipartBoundary = generateMultipartBoundary();
-                contentType = computeContentType(contentTypeHeader, multipartBoundary);
+                boundary = generateBoundary();
+                contentType = computeContentType(contentTypeHeader, boundary);
             }
         } else {
-            multipartBoundary = generateMultipartBoundary();
-            contentType = computeContentType(MULTIPART_FORM_CONTENT_TYPE, multipartBoundary);
+            boundary = generateBoundary();
+            contentType = computeContentType(MULTIPART_FORM_CONTENT_TYPE, boundary);
         }
 
-        long contentLength = getLengthOfParts(parts, multipartBoundary);
+        List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
 
-        return new MultipartBody(parts, contentType, contentLength, multipartBoundary);
+        return new MultipartBody(multipartParts, contentType, boundary);
     }
 
-    private static byte[] generateMultipartBoundary() {
-        Random rand = new Random();
-        byte[] bytes = new byte[rand.nextInt(11) + 30]; // a random size from 30 to 40
+    public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
+        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<MultipartPart<? extends Part>>(parts.size());
+        for (Part part : parts) {
+            if (part instanceof FilePart) {
+                multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
+
+            } else if (part instanceof ByteArrayPart) {
+                multipartParts.add(new ByteArrayMultipartPart((ByteArrayPart) part, boundary));
+
+            } else if (part instanceof StringPart) {
+                // convert to a byte array
+                StringPart stringPart = (StringPart) part;
+                byte[] bytes = stringPart.getValue().getBytes(stringPart.getCharset());
+                ByteArrayPart byteArrayPart = new ByteArrayPart(//
+                        stringPart.getName(),//
+                        bytes, //
+                        stringPart.getContentType(), //
+                        stringPart.getCharset(), //
+                        null, //
+                        stringPart.getContentId(), //
+                        stringPart.getTransferEncoding());
+                byteArrayPart.setCustomHeaders(stringPart.getCustomHeaders());
+                multipartParts.add(new ByteArrayMultipartPart(byteArrayPart, boundary));
+
+            } else {
+                throw new IllegalArgumentException("Unknown part type: " + part);
+            }
+        }
+        // add an extra fake part for terminating the message
+        multipartParts.add(new MessageEndMultipartPart(boundary));
+
+        return multipartParts;
+    }
+
+    // a random size from 30 to 40
+    private static byte[] generateBoundary() {
+        ThreadLocalRandom random = ThreadLocalRandom.current();
+        byte[] bytes = new byte[random.nextInt(11) + 30];
         for (int i = 0; i < bytes.length; i++) {
-            bytes[i] = MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)];
+            bytes[i] = MULTIPART_CHARS[random.nextInt(MULTIPART_CHARS.length)];
         }
         return bytes;
     }
 
-    private static String computeContentType(String base, byte[] multipartBoundary) {
+    private static String computeContentType(String base, byte[] boundary) {
         StringBuilder buffer = StringUtils.stringBuilder().append(base);
         if (!base.endsWith(";"))
             buffer.append(';');
-        return buffer.append(" boundary=").append(new String(multipartBoundary, US_ASCII)).toString();
-    }
-
-    public static long writeBytesToChannel(WritableByteChannel target, byte[] bytes) throws IOException {
-
-        int written = 0;
-        int maxSpin = 0;
-        ByteBuffer message = ByteBuffer.wrap(bytes);
-
-        if (target instanceof SocketChannel) {
-            final Selector selector = Selector.open();
-            try {
-                final SocketChannel channel = (SocketChannel) target;
-                channel.register(selector, SelectionKey.OP_WRITE);
-
-                while (written < bytes.length) {
-                    selector.select(1000);
-                    maxSpin++;
-                    final Set<SelectionKey> selectedKeys = selector.selectedKeys();
-
-                    for (SelectionKey key : selectedKeys) {
-                        if (key.isWritable()) {
-                            written += target.write(message);
-                            maxSpin = 0;
-                        }
-                    }
-                    if (maxSpin >= 10) {
-                        throw new IOException("Unable to write on channel " + target);
-                    }
-                }
-            } finally {
-                selector.close();
-            }
-        } else {
-            while ((target.isOpen()) && (written < bytes.length)) {
-                long nWrite = target.write(message);
-                written += nWrite;
-                if (nWrite == 0 && maxSpin++ < 10) {
-                    LOGGER.info("Waiting for writing...");
-                    try {
-                        bytes.wait(1000);
-                    } catch (InterruptedException e) {
-                        LOGGER.trace(e.getMessage(), e);
-                    }
-                } else {
-                    if (maxSpin >= 10) {
-                        throw new IOException("Unable to write on channel " + target);
-                    }
-                    maxSpin = 0;
-                }
-            }
-        }
-        return written;
-    }
-
-    public static byte[] getMessageEnd(byte[] partBoundary) throws IOException {
-
-        if (!isNonEmpty(partBoundary))
-            throw new IllegalArgumentException("partBoundary may not be empty");
-
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(out);
-        visitor.withBytes(EXTRA_BYTES);
-        visitor.withBytes(partBoundary);
-        visitor.withBytes(EXTRA_BYTES);
-        visitor.withBytes(CRLF_BYTES);
-
-        return out.toByteArray();
-    }
-
-    public static long getLengthOfParts(List<Part> parts, byte[] partBoundary) {
-
-        try {
-            if (parts == null) {
-                throw new NullPointerException("parts");
-            }
-            long total = 0;
-            for (Part part : parts) {
-                long l = part.length(partBoundary);
-                if (l < 0) {
-                    return -1;
-                }
-                total += l;
-            }
-            total += EXTRA_BYTES.length;
-            total += partBoundary.length;
-            total += EXTRA_BYTES.length;
-            total += CRLF_BYTES.length;
-            return total;
-        } catch (Exception e) {
-            LOGGER.error("An exception occurred while getting the length of the parts", e);
-            return 0L;
-        }
+        return buffer.append(" boundary=").append(new String(boundary, US_ASCII)).toString();
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java
deleted file mode 100644
index 849e41d28..000000000
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.request.body.multipart;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-public class OutputStreamPartVisitor implements PartVisitor {
-
-    private final OutputStream out;
-
-    public OutputStreamPartVisitor(OutputStream out) {
-        this.out = out;
-    }
-
-    @Override
-    public void withBytes(byte[] bytes) throws IOException {
-        out.write(bytes);
-    }
-
-    @Override
-    public void withByte(byte b) throws IOException {
-        out.write(b);
-    }
-
-    public OutputStream getOutputStream() {
-        return out;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
index 4669d1c61..cb84fce34 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
@@ -14,9 +14,10 @@
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
+import java.util.List;
+
+import org.asynchttpclient.Param;
 
 public interface Part {
 
@@ -80,28 +81,32 @@
     /**
      * Returns the content type of this part.
      * 
-     * @return the content type, or <code>null</code> to exclude the content type header
+     * @return the content type, or <code>null</code> to exclude the content
+     *         type header
      */
     String getContentType();
 
     /**
      * Return the character encoding of this part.
      * 
-     * @return the character encoding, or <code>null</code> to exclude the character encoding header
+     * @return the character encoding, or <code>null</code> to exclude the
+     *         character encoding header
      */
     Charset getCharset();
 
     /**
      * Return the transfer encoding of this part.
      * 
-     * @return the transfer encoding, or <code>null</code> to exclude the transfer encoding header
+     * @return the transfer encoding, or <code>null</code> to exclude the
+     *         transfer encoding header
      */
     String getTransferEncoding();
 
     /**
      * Return the content ID of this part.
      * 
-     * @return the content ID, or <code>null</code> to exclude the content ID header
+     * @return the content ID, or <code>null</code> to exclude the content ID
+     *         header
      */
     String getContentId();
 
@@ -112,13 +117,5 @@
      */
     String getDispositionType();
 
-    /**
-     * Return the full length of all the data. If you override this method make sure to override #send(OutputStream) as well
-     * 
-     * @param boundary the multipart boundary
-     * @return long The length.
-     */
-    long length(byte[] boundary);
-
-    long write(WritableByteChannel target, byte[] boundary) throws IOException;
+    List<Param> getCustomHeaders();
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index 4cc1b295e..b5db7a06c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -12,10 +12,6 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
@@ -76,118 +72,6 @@ public PartBase(String name, String contentType, Charset charset, String content
         this.transferEncoding = transferEncoding;
     }
 
-    protected void visitStart(PartVisitor visitor, byte[] boundary) throws IOException {
-        visitor.withBytes(EXTRA_BYTES);
-        visitor.withBytes(boundary);
-    }
-
-    protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
-        visitor.withBytes(CRLF_BYTES);
-        visitor.withBytes(CONTENT_DISPOSITION_BYTES);
-        visitor.withBytes(getDispositionType() != null ? getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
-        if (getName() != null) {
-            visitor.withBytes(NAME_BYTES);
-            visitor.withByte(QUOTE_BYTE);
-            visitor.withBytes(getName().getBytes(US_ASCII));
-            visitor.withByte(QUOTE_BYTE);
-        }
-    }
-
-    protected void visitContentTypeHeader(PartVisitor visitor) throws IOException {
-        String contentType = getContentType();
-        if (contentType != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_TYPE_BYTES);
-            visitor.withBytes(contentType.getBytes(US_ASCII));
-            Charset charSet = getCharset();
-            if (charSet != null) {
-                visitor.withBytes(CHARSET_BYTES);
-                visitor.withBytes(charset.name().getBytes(US_ASCII));
-            }
-        }
-    }
-
-    protected void visitTransferEncodingHeader(PartVisitor visitor) throws IOException {
-        String transferEncoding = getTransferEncoding();
-        if (transferEncoding != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
-            visitor.withBytes(transferEncoding.getBytes(US_ASCII));
-        }
-    }
-
-    protected void visitContentIdHeader(PartVisitor visitor) throws IOException {
-        String contentId = getContentId();
-        if (contentId != null) {
-            visitor.withBytes(CRLF_BYTES);
-            visitor.withBytes(CONTENT_ID_BYTES);
-            visitor.withBytes(contentId.getBytes(US_ASCII));
-        }
-    }
-
-    protected void visitCustomHeaders(PartVisitor visitor) throws IOException {
-        if (isNonEmpty(customHeaders)) {
-            for (Param param: customHeaders) {
-                visitor.withBytes(CRLF_BYTES);
-                visitor.withBytes(param.getName().getBytes(US_ASCII));
-                visitor.withBytes(param.getValue().getBytes(US_ASCII));
-            }
-        }
-    }
-
-    protected void visitEndOfHeaders(PartVisitor visitor) throws IOException {
-        visitor.withBytes(CRLF_BYTES);
-        visitor.withBytes(CRLF_BYTES);
-    }
-
-    protected void visitEnd(PartVisitor visitor) throws IOException {
-        visitor.withBytes(CRLF_BYTES);
-    }
-
-    protected abstract long getDataLength();
-
-    /**
-     * Return the full length of all the data. If you override this method make sure to override #send(OutputStream) as well
-     * 
-     * @return long The length.
-     */
-    public long length(byte[] boundary) {
-
-        long dataLength = getDataLength();
-        try {
-
-            if (dataLength < 0L) {
-                return -1L;
-            } else {
-                CounterPartVisitor visitor = new CounterPartVisitor();
-                visitStart(visitor, boundary);
-                visitDispositionHeader(visitor);
-                visitContentTypeHeader(visitor);
-                visitTransferEncodingHeader(visitor);
-                visitContentIdHeader(visitor);
-                visitCustomHeaders(visitor);
-                visitEndOfHeaders(visitor);
-                visitEnd(visitor);
-                return dataLength + visitor.getCount();
-            }
-        } catch (IOException e) {
-            // can't happen
-            throw new RuntimeException("IOException while computing length, WTF", e);
-        }
-    }
-
-    public String toString() {
-        return new StringBuilder()//
-                .append(getClass().getSimpleName())//
-                .append(" name=").append(getName())//
-                .append(" contentType=").append(getContentType())//
-                .append(" charset=").append(getCharset())//
-                .append(" tranferEncoding=").append(getTransferEncoding())//
-                .append(" contentId=").append(getContentId())//
-                .append(" dispositionType=").append(getDispositionType())//
-                .toString();
-    }
-
     @Override
     public String getName() {
         return this.name;
@@ -218,6 +102,11 @@ public String getDispositionType() {
         return dispositionType;
     }
 
+    @Override
+    public List<Param> getCustomHeaders() {
+        return customHeaders;
+    }
+
     public void setDispositionType(String dispositionType) {
         this.dispositionType = dispositionType;
     }
@@ -228,4 +117,20 @@ public void addCustomHeader(String name, String value) {
         }
         customHeaders.add(new Param(name, value));
     }
+
+    public void setCustomHeaders(List<Param> customHeaders) {
+        this.customHeaders = customHeaders;
+    }
+
+    public String toString() {
+        return new StringBuilder()//
+                .append(getClass().getSimpleName())//
+                .append(" name=").append(getName())//
+                .append(" contentType=").append(getContentType())//
+                .append(" charset=").append(getCharset())//
+                .append(" tranferEncoding=").append(getTransferEncoding())//
+                .append(" contentId=").append(getContentId())//
+                .append(" dispositionType=").append(getDispositionType())//
+                .toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
index eb32ba9bd..e53fcf6ed 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
@@ -13,10 +13,8 @@
 package org.asynchttpclient.request.body.multipart;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 
 public class StringPart extends PartBase {
@@ -39,7 +37,6 @@
     /**
      * Contents of this StringPart.
      */
-    private final byte[] content;
     private final String value;
 
     private static Charset charsetOrDefault(Charset charset) {
@@ -72,46 +69,15 @@ public StringPart(String name, String value, String contentType, Charset charset
 
     public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
         super(name, contentTypeOrDefault(contentType), charsetOrDefault(charset), contentId, transferEncodingOrDefault(transferEncoding));
-        if (value == null)
-            throw new NullPointerException("value");
+        assertNotNull(value, "value");
 
         if (value.indexOf(0) != -1)
             // See RFC 2048, 2.8. "8bit Data"
             throw new IllegalArgumentException("NULs may not be present in string parts");
 
-        content = value.getBytes(getCharset());
         this.value = value;
     }
 
-    /**
-     * Return the length of the data.
-     * 
-     * @return The length of the data.
-     */
-    protected long getDataLength() {
-        return content.length;
-    }
-
-    public byte[] getBytes(byte[] boundary) throws IOException {
-        ByteArrayOutputStream os = new ByteArrayOutputStream();
-        OutputStreamPartVisitor visitor = new OutputStreamPartVisitor(os);
-        visitStart(visitor, boundary);
-        visitDispositionHeader(visitor);
-        visitContentTypeHeader(visitor);
-        visitTransferEncodingHeader(visitor);
-        visitContentIdHeader(visitor);
-        visitCustomHeaders(visitor);
-        visitEndOfHeaders(visitor);
-        os.write(content);
-        visitEnd(visitor);
-        return os.toByteArray();
-    }
-
-    @Override
-    public long write(WritableByteChannel target, byte[] boundary) throws IOException {
-        return MultipartUtils.writeBytesToChannel(target, getBytes(boundary));
-    }
-
     public String getValue() {
         return value;
     }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
new file mode 100644
index 000000000..a147e9a79
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+
+public class ByteArrayMultipartPart extends MultipartPart<ByteArrayPart> {
+
+    private final ByteBuf contentBuffer;
+
+    public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
+        super(part, boundary);
+        contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
+    }
+
+    @Override
+    protected long getContentLength() {
+        return part.getBytes().length;
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+    
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+    }
+    
+    @Override
+    public void close() {
+        super.close();
+        contentBuffer.release();
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
new file mode 100644
index 000000000..bed98b0a6
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import io.netty.buffer.ByteBuf;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.asynchttpclient.netty.request.body.BodyChunkedInput;
+import org.asynchttpclient.request.body.multipart.FilePart;
+
+public class FileMultipartPart extends MultipartPart<FilePart> {
+
+    private final FileChannel channel;
+    private final long length;
+    private long position = 0L;
+
+    public FileMultipartPart(FilePart part, byte[] boundary) {
+        super(part, boundary);
+        try {
+            channel = new FileInputStream(part.getFile()).getChannel();
+        } catch (FileNotFoundException e) {
+            throw new IllegalArgumentException("File part doesn't exist: " + part.getFile().getAbsolutePath(), e);
+        }
+        length = part.getFile().length();
+    }
+
+    @Override
+    protected long getContentLength() {
+        return part.getFile().length();
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        int transferred = target.writeBytes(channel, target.writableBytes());
+        position += transferred;
+        if (position == length) {
+            state = MultipartState.POST_CONTENT;
+            channel.close();
+        }
+        return transferred;
+    }
+
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        long transferred = channel.transferTo(channel.position(), BodyChunkedInput.DEFAULT_CHUNK_SIZE, target);
+        position += transferred;
+        if (position == length) {
+            state = MultipartState.POST_CONTENT;
+            channel.close();
+        } else {
+            slowTarget = true;
+        }
+        return transferred;
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        closeSilently(channel);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
new file mode 100644
index 000000000..7c529c608
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import static org.asynchttpclient.request.body.multipart.Part.*;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.Unpooled;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+import org.asynchttpclient.request.body.multipart.FileLikePart;
+
+public class MessageEndMultipartPart extends MultipartPart<FileLikePart> {
+
+    private final ByteBuf buffer;
+
+    public MessageEndMultipartPart(byte[] boundary) {
+        super(null, boundary);
+        buffer = ByteBufAllocator.DEFAULT.buffer((int) length());
+        buffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
+        state = MultipartState.PRE_CONTENT;
+    }
+
+    @Override
+    public long transferTo(ByteBuf target) throws IOException {
+        return transfer(buffer, target, MultipartState.DONE);
+    }
+
+    @Override
+    public long transferTo(WritableByteChannel target) throws IOException {
+        slowTarget = false;
+        return transfer(buffer, target, MultipartState.DONE);
+    }
+
+    @Override
+    protected ByteBuf computePreContentBytes() {
+        return Unpooled.EMPTY_BUFFER;
+    }
+
+    @Override
+    protected ByteBuf computePostContentBytes() {
+        return Unpooled.EMPTY_BUFFER;
+    }
+
+    @Override
+    protected long getContentLength() {
+        return EXTRA_BYTES.length + boundary.length + EXTRA_BYTES.length + CRLF_BYTES.length;
+    }
+
+    @Override
+    protected long transferContentTo(ByteBuf target) throws IOException {
+        throw new UnsupportedOperationException("Not supposed to be called");
+    }
+
+    @Override
+    protected long transferContentTo(WritableByteChannel target) throws IOException {
+        throw new UnsupportedOperationException("Not supposed to be called");
+    }
+
+    @Override
+    public void close() {
+        buffer.release();
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
new file mode 100644
index 000000000..d2e76a63d
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+
+import org.asynchttpclient.Param;
+import org.asynchttpclient.request.body.multipart.FileLikePart;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.ByteBufVisitor;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
+
+public abstract class MultipartPart<T extends FileLikePart> implements Closeable {
+
+    /**
+     * Carriage return/linefeed as a byte array
+     */
+    private static final byte[] CRLF_BYTES = "\r\n".getBytes(US_ASCII);
+
+    /**
+     * Content disposition as a byte
+     */
+    private static final byte QUOTE_BYTE = '\"';
+
+    /**
+     * Extra characters as a byte array
+     */
+    private static final byte[] EXTRA_BYTES = "--".getBytes(US_ASCII);
+
+    /**
+     * Content disposition as a byte array
+     */
+    private static final byte[] CONTENT_DISPOSITION_BYTES = "Content-Disposition: ".getBytes(US_ASCII);
+
+    /**
+     * form-data as a byte array
+     */
+    private static final byte[] FORM_DATA_DISPOSITION_TYPE_BYTES = "form-data".getBytes(US_ASCII);
+
+    /**
+     * name as a byte array
+     */
+    private static final byte[] NAME_BYTES = "; name=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_TYPE_BYTES = "Content-Type: ".getBytes(US_ASCII);
+
+    /**
+     * Content charset as a byte array
+     */
+    private static final byte[] CHARSET_BYTES = "; charset=".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_TRANSFER_ENCODING_BYTES = "Content-Transfer-Encoding: ".getBytes(US_ASCII);
+
+    /**
+     * Content type header as a byte array
+     */
+    private static final byte[] CONTENT_ID_BYTES = "Content-ID: ".getBytes(US_ASCII);
+
+    /**
+     * Attachment's file name as a byte array
+     */
+    private static final byte[] FILE_NAME_BYTES = "; filename=".getBytes(US_ASCII);
+
+    protected final T part;
+    protected final byte[] boundary;
+
+    private final long length;
+    private ByteBuf preContentBuffer;
+    private ByteBuf postContentBuffer;
+    protected MultipartState state;
+    protected boolean slowTarget;
+
+    public MultipartPart(T part, byte[] boundary) {
+        this.part = part;
+        this.boundary = boundary;
+        preContentBuffer = computePreContentBytes();
+        postContentBuffer = computePostContentBytes();
+        length = preContentBuffer.readableBytes() + postContentBuffer.readableBytes() + getContentLength();
+        state = MultipartState.PRE_CONTENT;
+    }
+
+    public long length() {
+        return length;
+    }
+
+    public MultipartState getState() {
+        return state;
+    }
+
+    public boolean isTargetSlow() {
+        return slowTarget;
+    }
+
+    public long transferTo(ByteBuf target) throws IOException {
+
+        switch (state) {
+        case DONE:
+            return 0L;
+
+        case PRE_CONTENT:
+            return transfer(preContentBuffer, target, MultipartState.CONTENT);
+
+        case CONTENT:
+            return transferContentTo(target);
+
+        case POST_CONTENT:
+            return transfer(postContentBuffer, target, MultipartState.DONE);
+
+        default:
+            throw new IllegalStateException("Unknown state " + state);
+        }
+    }
+
+    public long transferTo(WritableByteChannel target) throws IOException {
+        slowTarget = false;
+
+        switch (state) {
+        case DONE:
+            return 0L;
+
+        case PRE_CONTENT:
+            return transfer(preContentBuffer, target, MultipartState.CONTENT);
+
+        case CONTENT:
+            return transferContentTo(target);
+
+        case POST_CONTENT:
+            return transfer(postContentBuffer, target, MultipartState.DONE);
+
+        default:
+            throw new IllegalStateException("Unknown state " + state);
+        }
+    }
+
+    @Override
+    public void close() {
+        preContentBuffer.release();
+        postContentBuffer.release();
+    }
+
+    protected abstract long getContentLength();
+
+    protected abstract long transferContentTo(ByteBuf target) throws IOException;
+
+    protected abstract long transferContentTo(WritableByteChannel target) throws IOException;
+
+    protected long transfer(ByteBuf source, ByteBuf target, MultipartState sourceFullyWrittenState) {
+
+        int sourceRemaining = source.readableBytes();
+        int targetRemaining = target.writableBytes();
+
+        if (sourceRemaining <= targetRemaining) {
+            target.writeBytes(source);
+            state = sourceFullyWrittenState;
+            return sourceRemaining;
+        } else {
+            target.writeBytes(source, targetRemaining - sourceRemaining);
+            return targetRemaining;
+        }
+    }
+
+    protected long transfer(ByteBuf source, WritableByteChannel target, MultipartState sourceFullyWrittenState) throws IOException {
+
+        int transferred = 0;
+        if (target instanceof GatheringByteChannel) {
+            transferred = source.readBytes((GatheringByteChannel) target, (int) source.readableBytes());
+        } else {
+            for (ByteBuffer byteBuffer : source.nioBuffers()) {
+                int len = byteBuffer.remaining();
+                int written = target.write(byteBuffer);
+                transferred += written;
+                if (written != len) {
+                    // couldn't write full buffer, exit loop
+                    break;
+                }
+            }
+            // assume this is a basic single ByteBuf
+            source.readerIndex(source.readerIndex() + transferred);
+        }
+
+        if (source.isReadable()) {
+            slowTarget = true;
+        } else {
+            state = sourceFullyWrittenState;
+        }
+        return transferred;
+    }
+
+    protected ByteBuf computePreContentBytes() {
+
+        // compute length
+        CounterPartVisitor counterVisitor = new CounterPartVisitor();
+        visitPreContent(counterVisitor);
+        long length = counterVisitor.getCount();
+
+        // compute bytes
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer((int) length);
+        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+        visitPreContent(bytesVisitor);
+        return buffer;
+    }
+
+    protected ByteBuf computePostContentBytes() {
+
+        // compute length
+        CounterPartVisitor counterVisitor = new CounterPartVisitor();
+        visitPostContent(counterVisitor);
+        long length = counterVisitor.getCount();
+
+        // compute bytes
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer((int) length);
+        ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
+        visitPostContent(bytesVisitor);
+        return buffer;
+    }
+
+    protected void visitStart(PartVisitor visitor) {
+        visitor.withBytes(EXTRA_BYTES);
+        visitor.withBytes(boundary);
+    }
+
+    protected void visitDispositionHeader(PartVisitor visitor) {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CONTENT_DISPOSITION_BYTES);
+        visitor.withBytes(part.getDispositionType() != null ? part.getDispositionType().getBytes(US_ASCII) : FORM_DATA_DISPOSITION_TYPE_BYTES);
+        if (part.getName() != null) {
+            visitor.withBytes(NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(part.getName().getBytes(US_ASCII));
+            visitor.withByte(QUOTE_BYTE);
+        }
+        if (part.getFileName() != null) {
+            visitor.withBytes(FILE_NAME_BYTES);
+            visitor.withByte(QUOTE_BYTE);
+            visitor.withBytes(part.getFileName().getBytes(part.getCharset() != null ? part.getCharset() : US_ASCII));
+            visitor.withByte(QUOTE_BYTE);
+        }
+    }
+
+    protected void visitContentTypeHeader(PartVisitor visitor) {
+        String contentType = part.getContentType();
+        if (contentType != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TYPE_BYTES);
+            visitor.withBytes(contentType.getBytes(US_ASCII));
+            Charset charSet = part.getCharset();
+            if (charSet != null) {
+                visitor.withBytes(CHARSET_BYTES);
+                visitor.withBytes(part.getCharset().name().getBytes(US_ASCII));
+            }
+        }
+    }
+
+    protected void visitTransferEncodingHeader(PartVisitor visitor) {
+        String transferEncoding = part.getTransferEncoding();
+        if (transferEncoding != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_TRANSFER_ENCODING_BYTES);
+            visitor.withBytes(transferEncoding.getBytes(US_ASCII));
+        }
+    }
+
+    protected void visitContentIdHeader(PartVisitor visitor) {
+        String contentId = part.getContentId();
+        if (contentId != null) {
+            visitor.withBytes(CRLF_BYTES);
+            visitor.withBytes(CONTENT_ID_BYTES);
+            visitor.withBytes(contentId.getBytes(US_ASCII));
+        }
+    }
+
+    protected void visitCustomHeaders(PartVisitor visitor) {
+        if (isNonEmpty(part.getCustomHeaders())) {
+            for (Param param : part.getCustomHeaders()) {
+                visitor.withBytes(CRLF_BYTES);
+                visitor.withBytes(param.getName().getBytes(US_ASCII));
+                visitor.withBytes(param.getValue().getBytes(US_ASCII));
+            }
+        }
+    }
+
+    protected void visitEndOfHeaders(PartVisitor visitor) {
+        visitor.withBytes(CRLF_BYTES);
+        visitor.withBytes(CRLF_BYTES);
+    }
+
+    protected void visitPreContent(PartVisitor visitor) {
+        visitStart(visitor);
+        visitDispositionHeader(visitor);
+        visitContentTypeHeader(visitor);
+        visitTransferEncodingHeader(visitor);
+        visitContentIdHeader(visitor);
+        visitCustomHeaders(visitor);
+        visitEndOfHeaders(visitor);
+    }
+
+    protected void visitPostContent(PartVisitor visitor) {
+        visitor.withBytes(CRLF_BYTES);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
similarity index 58%
rename from client/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java
rename to client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
index 0ab6a86ae..df7b96950 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
@@ -1,21 +1,25 @@
 /*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.request.body.multipart;
+package org.asynchttpclient.request.body.multipart.part;
 
-import java.io.IOException;
+public enum MultipartState {
 
-public interface PartVisitor {
+    PRE_CONTENT,
 
-    void withBytes(byte[] bytes) throws IOException;
-    void withByte(byte b) throws IOException;
+    CONTENT,
+
+    POST_CONTENT,
+
+    DONE;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
new file mode 100644
index 000000000..e62ca9832
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.multipart.part;
+
+import io.netty.buffer.ByteBuf;
+
+import java.nio.ByteBuffer;
+
+public interface PartVisitor {
+
+    void withBytes(byte[] bytes);
+
+    void withByte(byte b);
+
+    class CounterPartVisitor implements PartVisitor {
+
+        private long count = 0L;
+
+        @Override
+        public void withBytes(byte[] bytes) {
+            count += bytes.length;
+        }
+
+        @Override
+        public void withByte(byte b) {
+            count++;
+        }
+
+        public long getCount() {
+            return count;
+        }
+    }
+
+    class ByteBufferVisitor implements PartVisitor {
+
+        private final ByteBuffer target;
+
+        public ByteBufferVisitor(ByteBuffer target) {
+            this.target = target;
+        }
+
+        @Override
+        public void withBytes(byte[] bytes) {
+            target.put(bytes);
+        }
+
+        @Override
+        public void withByte(byte b) {
+            target.put(b);
+        }
+    }
+    
+    class ByteBufVisitor implements PartVisitor {
+        private final ByteBuf target;
+
+        public ByteBufVisitor(ByteBuf target) {
+            this.target = target;
+        }
+
+        @Override
+        public void withBytes(byte[] bytes) {
+            target.writeBytes(bytes);
+        }
+
+        @Override
+        public void withByte(byte b) {
+            target.writeByte(b);
+        }
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/uri/Uri.java b/client/src/main/java/org/asynchttpclient/uri/Uri.java
index b603c7b72..99895ee75 100644
--- a/client/src/main/java/org/asynchttpclient/uri/Uri.java
+++ b/client/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.uri;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import java.net.URI;
 import java.net.URISyntaxException;
 
@@ -58,11 +60,8 @@ public Uri(String scheme,//
             String path,//
             String query) {
 
-        if (scheme == null)
-            throw new NullPointerException("scheme");
-        if (host == null)
-            throw new NullPointerException("host");
-
+        assertNotNull(scheme, "scheme");
+        assertNotNull(host, "host");
         this.scheme = scheme;
         this.userInfo = userInfo;
         this.host = host;
diff --git a/client/src/main/java/org/asynchttpclient/uri/UriParser.java b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
index a480a96fd..947c129b8 100644
--- a/client/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.uri;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 final class UriParser {
 
     public String scheme;
@@ -318,8 +320,7 @@ else if (path == null)
 
     public void parse(Uri context, final String originalUrl) {
 
-        if (originalUrl == null)
-            throw new NullPointerException("originalUrl");
+        assertNotNull(originalUrl, "orginalUri");
 
         boolean isRelative = false;
 
diff --git a/client/src/main/java/org/asynchttpclient/util/Assertions.java b/client/src/main/java/org/asynchttpclient/util/Assertions.java
new file mode 100644
index 000000000..f00cb3fa0
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/util/Assertions.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+public final class Assertions {
+
+    private Assertions() {
+    }
+
+    public static void assertNotNull(Object value, String name) {
+        if (value == null)
+            throw new NullPointerException(name);
+    }
+
+    public static void assertNotEmpty(String value, String name) {
+        if (value.length() == 0)
+            throw new IllegalArgumentException("empty " + name);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/util/SslUtils.java b/client/src/main/java/org/asynchttpclient/util/SslUtils.java
deleted file mode 100644
index 5d31125d1..000000000
--- a/client/src/main/java/org/asynchttpclient/util/SslUtils.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.util;
-
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.security.SecureRandom;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-
-/**
- * This class is a copy of http://github.com/sonatype/wagon-ning/raw/master/src/main/java/org/apache/maven/wagon/providers/http/SslUtils.java
- */
-public class SslUtils {
-    
-    static class LooseTrustManager implements X509TrustManager {
-
-        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
-            return new java.security.cert.X509Certificate[0];
-        }
-
-        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
-        }
-
-        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
-        }
-    }
-
-    private SSLContext looseTrustManagerSSLContext = looseTrustManagerSSLContext(); 
-    
-    private SSLContext looseTrustManagerSSLContext() {
-        try {
-            SSLContext sslContext = SSLContext.getInstance("TLS");
-            sslContext.init(null, new TrustManager[] { new LooseTrustManager() }, new SecureRandom());
-            return sslContext;
-        } catch (NoSuchAlgorithmException e) {
-           throw new ExceptionInInitializerError(e);
-        } catch (KeyManagementException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
-    
-    private static class SingletonHolder {
-        public static final SslUtils instance = new SslUtils();
-    }
-
-    public static SslUtils getInstance() {
-        return SingletonHolder.instance;
-    }
-
-    public SSLContext getSSLContext(AsyncHttpClientConfig config) throws GeneralSecurityException {
-        SSLContext sslContext = config.getSSLContext();
-
-        if (sslContext == null) {
-            sslContext = config.isAcceptAnyCertificate() ? looseTrustManagerSSLContext : SSLContext.getDefault();
-            if (config.getSslSessionCacheSize() != null)
-                sslContext.getClientSessionContext().setSessionCacheSize(config.getSslSessionCacheSize());
-            if (config.getSslSessionTimeout() != null)
-                sslContext.getClientSessionContext().setSessionTimeout(config.getSslSessionTimeout());
-        }
-        return sslContext;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
index 06af655e1..8b596003d 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.ws;
 
+import static org.asynchttpclient.util.Assertions.*;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -93,9 +95,7 @@ public final WebSocket onCompleted() throws Exception {
             throw e;
         }
 
-        if (webSocket == null) {
-            throw new NullPointerException("webSocket");
-        }
+        assertNotNull(webSocket, "webSocket");
         return webSocket;
     }
 
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/ahc-default.properties
index e43ca43b4..67961dee5 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/ahc-default.properties
@@ -5,7 +5,6 @@ org.asynchttpclient.connectTimeout=5000
 org.asynchttpclient.pooledConnectionIdleTimeout=60000
 org.asynchttpclient.readTimeout=60000
 org.asynchttpclient.requestTimeout=60000
-org.asynchttpclient.webSocketTimeout=900000
 org.asynchttpclient.connectionTtl=-1
 org.asynchttpclient.followRedirect=false
 org.asynchttpclient.maxRedirects=5
@@ -15,12 +14,15 @@ org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
 org.asynchttpclient.useProxySelector=false
 org.asynchttpclient.useProxyProperties=false
 org.asynchttpclient.strict302Handling=false
-org.asynchttpclient.allowPoolingConnections=true
+org.asynchttpclient.keepAlive=true
 org.asynchttpclient.requestCompressionLevel=-1
 org.asynchttpclient.maxRequestRetry=5
 org.asynchttpclient.disableUrlEncodingForBoundRequests=false
 org.asynchttpclient.removeQueryParamOnRedirect=true
+org.asynchttpclient.useOpenSsl=false
 org.asynchttpclient.acceptAnyCertificate=false
+org.asynchttpclient.sslSessionCacheSize=0
+org.asynchttpclient.sslSessionTimeout=0
 org.asynchttpclient.httpClientCodecMaxInitialLineLength=4096
 org.asynchttpclient.httpClientCodecMaxHeaderSize=8192
 org.asynchttpclient.httpClientCodecMaxChunkSize=8192
@@ -32,3 +34,4 @@ org.asynchttpclient.webSocketMaxFrameSize=10240
 org.asynchttpclient.keepEncodingHeader=false
 org.asynchttpclient.shutdownQuietPeriod=2000
 org.asynchttpclient.shutdownTimeout=15000
+org.asynchttpclient.useNativeTransport=false
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index d8d5228ab..00adc4a2e 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -9,11 +9,11 @@
 
 import java.lang.reflect.Method;
 
-@Test
+@Test(groups = "standalone")
 public class AsyncHttpClientDefaultsTest {
 
     public void testDefaultMaxTotalConnections() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(),-1);
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(), -1);
         testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
     }
 
@@ -42,11 +42,6 @@ public void testDefaultRequestTimeout() {
         testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
     }
 
-    public void testDefaultWebSocketTimeout() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultWebSocketTimeout(), 15 * 60 * 1000);
-        testIntegerSystemProperty("webSocketTimeout", "defaultWebSocketTimeout", "100");
-    }
-
     public void testDefaultConnectionTtl() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTtl(), -1);
         testIntegerSystemProperty("connectionTtl", "defaultConnectionTtl", "100");
@@ -68,7 +63,7 @@ public void testDefaultCompressionEnforced() {
     }
 
     public void testDefaultUserAgent() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(),"NING/1.0");
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "NING/1.0");
         testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
     }
 
@@ -88,8 +83,8 @@ public void testDefaultStrict302Handling() {
     }
 
     public void testDefaultAllowPoolingConnection() {
-       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultAllowPoolingConnections());
-       testBooleanSystemProperty("allowPoolingConnections", "defaultAllowPoolingConnections", "false");
+        Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultKeepAlive());
+        testBooleanSystemProperty("keepAlive", "defaultKeepAlive", "false");
     }
 
     public void testDefaultMaxRequestRetry() {
@@ -103,53 +98,53 @@ public void testDefaultDisableUrlEncodingForBoundRequests() {
     }
 
     public void testDefaultAcceptAnyCertificate() {
-       Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultAcceptAnyCertificate());
-       testBooleanSystemProperty("acceptAnyCertificate", "defaultAcceptAnyCertificate", "true");
+        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultAcceptAnyCertificate());
+        testBooleanSystemProperty("acceptAnyCertificate", "defaultAcceptAnyCertificate", "true");
     }
-    
-    private void testIntegerSystemProperty(String propertyName,String methodName,String value){
+
+    private void testIntegerSystemProperty(String propertyName, String methodName, String value) {
         String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
         System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
         AsyncHttpClientConfigHelper.reloadProperties();
         try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
-            Assert.assertEquals(method.invoke(null, new Object[]{}),Integer.parseInt(value));
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), Integer.parseInt(value));
         } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName,e);
-        } 
-        if(previous != null)
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
             System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
             System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
     }
-    
-    private void testBooleanSystemProperty(String propertyName,String methodName,String value){
+
+    private void testBooleanSystemProperty(String propertyName, String methodName, String value) {
         String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
         System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
         AsyncHttpClientConfigHelper.reloadProperties();
         try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
-            Assert.assertEquals(method.invoke(null, new Object[]{}),Boolean.parseBoolean(value));
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), Boolean.parseBoolean(value));
         } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName,e);
-        } 
-        if(previous != null)
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
             System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
             System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
     }
-    
-    private void testStringSystemProperty(String propertyName,String methodName,String value){
+
+    private void testStringSystemProperty(String propertyName, String methodName, String value) {
         String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
         System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
         AsyncHttpClientConfigHelper.reloadProperties();
         try {
-            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
-            Assert.assertEquals(method.invoke(null, new Object[]{}),value);
+            Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[] {});
+            Assert.assertEquals(method.invoke(null, new Object[] {}), value);
         } catch (Exception e) {
-            Assert.fail("Couldn't find or execute method : " + methodName,e);
-        } 
-        if(previous != null)
+            Assert.fail("Couldn't find or execute method : " + methodName, e);
+        }
+        if (previous != null)
             System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
             System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index 2af8937e8..ad0596e49 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -34,7 +34,7 @@
 
     private static final String RESPONSE = "param_1_";
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamGETTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
@@ -73,7 +73,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamPOSTTest() throws Exception {
 
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
@@ -111,7 +111,7 @@ public String onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamInterruptTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
         
@@ -152,7 +152,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamFutureTest() throws Exception {
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
         final AtomicReference<Throwable> throwable = new AtomicReference<>();
@@ -193,7 +193,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamThrowableRefusedTest() throws Exception {
 
         final CountDownLatch l = new CountDownLatch(1);
@@ -223,7 +223,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncStreamReusePOSTTest() throws Exception {
 
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
@@ -293,11 +293,11 @@ public String onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void asyncStream302RedirectWithBody() throws Exception {
         final AtomicReference<Integer> statusCode = new AtomicReference<>(0);
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             Future<String> f = c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
 
                 public State onStatusReceived(HttpResponseStatus status) throws Exception {
@@ -333,7 +333,7 @@ public String onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
+    @Test(groups = "standalone", timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
     public void asyncStreamJustStatusLine() throws Exception {
         final int STATUS = 0;
         final int COMPLETED = 1;
@@ -399,7 +399,7 @@ public Integer onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void asyncOptionsTest() throws Exception {
         final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
 
@@ -430,7 +430,7 @@ public String onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void closeConnectionTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
@@ -447,11 +447,7 @@ public void onThrowable(Throwable t) {
 
                 public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.accumulate(content);
-
-                    if (content.isLast()) {
-                        content.markUnderlyingConnectionAsToBeClosed();
-                    }
-                    return State.CONTINUE;
+                    return content.isLast() ? State.ABORT : State.CONTINUE;
                 }
 
                 public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index d3c5e6dd8..e809a1d3d 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -93,10 +93,8 @@ public void run() {
         };
     }
 
-    // TODO Netty only.
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void testStream() throws IOException {
+    @Test(groups = "standalone")
+    public void testStream() throws Exception {
         try (AsyncHttpClient ahc = asyncHttpClient()) {
             final AtomicBoolean err = new AtomicBoolean(false);
             final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
@@ -135,11 +133,7 @@ public Object onCompleted() throws Exception {
                     return null;
                 }
             });
-            try {
-                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-            } catch (InterruptedException e) {
-                fail("Interrupted.", e);
-            }
+            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
             assertFalse(err.get());
             assertEquals(queue.size(), 2);
             assertTrue(queue.contains("part1"));
diff --git a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 61a641461..992530e4d 100644
--- a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -79,7 +79,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void basicAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, false);
@@ -90,7 +90,7 @@ public void basicAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void basicPreemptiveAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, true);
@@ -101,7 +101,7 @@ public void basicPreemptiveAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void digestAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, false);
@@ -112,7 +112,7 @@ public void digestAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void digestPreemptiveAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, true);
@@ -123,7 +123,7 @@ public void digestPreemptiveAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void basicFutureAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, false);
@@ -134,7 +134,7 @@ public void basicFutureAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, true);
@@ -145,7 +145,7 @@ public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void digestFutureAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, false);
@@ -156,7 +156,7 @@ public void digestFutureAuthTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
         try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, true);
@@ -176,7 +176,7 @@ protected void inspectException(Throwable t) {
     }
 
     private AsyncHttpClient newClient() {
-        return asyncHttpClient(config().setPooledConnectionIdleTimeout(2000).setConnectTimeout(20000).setRequestTimeout(2000).build());
+        return asyncHttpClient(config().setPooledConnectionIdleTimeout(2000).setConnectTimeout(20000).setRequestTimeout(2000));
     }
 
     protected Future<Response> execute(AsyncHttpClient client, Server server, boolean preemptive) throws IOException {
diff --git a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
index d010ccc47..b0b0f7c37 100644
--- a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -159,7 +159,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet(getTargetUrl())//
@@ -172,9 +172,9 @@ public void basicAuthTest() throws IOException, ExecutionException, TimeoutExcep
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void redirectAndDigestAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
             Future<Response> f = client.prepareGet(getTargetUrl2())//
                     .setRealm(basicAuthRealm(USER, ADMIN).build())//
                     .execute();
@@ -185,7 +185,7 @@ public void redirectAndDigestAuthTest() throws Exception, ExecutionException, Ti
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             BoundRequestBuilder r = client.prepareGet(getTargetUrl())//
@@ -227,7 +227,7 @@ public Integer onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // send the request to the no-auth endpoint to be able to verify the
@@ -243,7 +243,7 @@ public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException,
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet(getTargetUrl())//
@@ -256,7 +256,7 @@ public void basicAuthNegativeTest() throws IOException, ExecutionException, Time
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost(getTargetUrl())//
@@ -272,7 +272,7 @@ public void basicAuthInputStreamTest() throws IOException, ExecutionException, T
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthFileTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost(getTargetUrl())//
@@ -288,9 +288,9 @@ public void basicAuthFileTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthAsyncConfigTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN).build()).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(basicAuthRealm(USER, ADMIN)))) {
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(SIMPLE_TEXT_FILE_STRING)//
                     .execute();
@@ -303,9 +303,9 @@ public void basicAuthAsyncConfigTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicAuthFileNoKeepAliveTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setAllowPoolingConnections(false).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(false))) {
 
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(SIMPLE_TEXT_FILE)//
@@ -320,7 +320,7 @@ public void basicAuthFileNoKeepAliveTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(basicAuthRealm(USER, ADMIN).build());
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index 3fe3a90c7..e7b8d5bec 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -31,7 +31,6 @@
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.nio.channels.UnresolvedAddressException;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
@@ -55,10 +54,10 @@
 
 public class BasicHttpTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncProviderEncodingTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "?q=+%20x").build();
+            Request request = get(getTargetUrl() + "?q=+%20x").build();
             assertEquals(request.getUrl(), getTargetUrl() + "?q=+%20x");
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
@@ -78,10 +77,10 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncProviderEncodingTest2() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "").addQueryParam("q", "a b").build();
+            Request request = get(getTargetUrl() + "").addQueryParam("q", "a b").build();
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
@@ -100,10 +99,10 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void emptyRequestURI() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            Request request = get(getTargetUrl()).build();
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
@@ -122,7 +121,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncProviderContentLenghtGETTest() throws Exception {
         final HttpURLConnection connection = (HttpURLConnection) new URL(getTargetUrl()).openConnection();
         connection.connect();
@@ -131,7 +130,7 @@ public void asyncProviderContentLenghtGETTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
 
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            Request request = get(getTargetUrl()).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -166,11 +165,11 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncContentTypeGETTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            Request request = get(getTargetUrl()).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -190,11 +189,11 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncHeaderGETTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            Request request = get(getTargetUrl()).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -215,7 +214,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncHeaderPOSTTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -225,7 +224,7 @@ public void asyncHeaderPOSTTest() throws Exception {
             h.add("Test3", "Test3");
             h.add("Test4", "Test4");
             h.add("Test5", "Test5");
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
+            Request request = get(getTargetUrl()).setHeaders(h).build();
 
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
@@ -249,7 +248,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncParamPOSTTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -260,7 +259,7 @@ public void asyncParamPOSTTest() throws Exception {
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setFormParams(m).build();
+            Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -283,11 +282,11 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncStatusHEADTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
+            Request request = head(getTargetUrl()).build();
             Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -315,11 +314,11 @@ public Response onCompleted(Response response) throws Exception {
     }
 
     // TODO: fix test
-    @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void asyncStatusHEADContentLenghtTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(120 * 1000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(120 * 1000))) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
+            Request request = head(getTargetUrl()).build();
 
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
                 @Override
@@ -346,14 +345,14 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" }, expectedExceptions = { NullPointerException.class })
+    @Test(groups = "online", expectedExceptions = NullPointerException.class)
     public void asyncNullSchemeTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             client.prepareGet("www.sun.com").execute();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetTransferEncodingTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -378,7 +377,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetHeadersTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -409,7 +408,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetCookieTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -443,7 +442,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostDefaultContentType() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -468,7 +467,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostBodyIsoTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
@@ -476,7 +475,7 @@ public void asyncDoPostBodyIsoTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostBytesTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -512,7 +511,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostInputStreamTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -548,7 +547,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPutInputStreamTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -582,7 +581,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostMultiPartTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -610,9 +609,9 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostBasicGZIPTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setCompressionEnforced(true).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setCompressionEnforced(true))) {
             final CountDownLatch l = new CountDownLatch(1);
             HttpHeaders h = new DefaultHttpHeaders();
             h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
@@ -642,7 +641,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostProxyTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port2).build()))) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -669,7 +668,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncRequestVirtualServerPOSTTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -679,7 +678,7 @@ public void asyncRequestVirtualServerPOSTTest() throws Exception {
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setFormParams(m).setVirtualHost("localhost:" + port1).build();
+            Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).setVirtualHost("localhost:" + port1).build();
 
             Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
 
@@ -692,7 +691,7 @@ public void asyncRequestVirtualServerPOSTTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPutTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -709,7 +708,7 @@ public void asyncDoPutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostLatchBytesTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -743,7 +742,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" }, expectedExceptions = { CancellationException.class })
+    @Test(groups = "standalone", expectedExceptions = CancellationException.class)
     public void asyncDoPostDelayCancelTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -762,7 +761,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostDelayBytesTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -792,7 +791,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostNullBytesTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -811,7 +810,7 @@ public void asyncDoPostNullBytesTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostListenerBytesTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -842,7 +841,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncConnectInvalidFuture() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             int dummyPort = findFreePort();
@@ -867,7 +866,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncConnectInvalidPortFuture() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             int dummyPort = findFreePort();
@@ -888,7 +887,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncConnectInvalidPort() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // pick a random unused local port
@@ -908,7 +907,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncConnectInvalidHandlerPort() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
@@ -931,7 +930,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" }, expectedExceptions = { ConnectException.class, UnresolvedAddressException.class, UnknownHostException.class })
+    @Test(groups = "online", expectedExceptions = UnknownHostException.class)
     public void asyncConnectInvalidHandlerHost() throws Throwable {
         try (AsyncHttpClient client = asyncHttpClient()) {
 
@@ -955,7 +954,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncConnectInvalidFuturePort() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final AtomicBoolean called = new AtomicBoolean(false);
@@ -982,7 +981,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncContentLenghtGETTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
@@ -998,7 +997,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncResponseEmptyBody() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
@@ -1013,7 +1012,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
+    @Test(groups = "standalone")
     public void asyncAPIContentLenghtGETTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // Use a l in case the assert fail
@@ -1042,7 +1041,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
+    @Test(groups = "standalone")
     public void asyncAPIHandlerExceptionTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // Use a l in case the assert fail
@@ -1072,9 +1071,9 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetDelayHandlerTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(5 * 1000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(5 * 1000))) {
             HttpHeaders h = new DefaultHttpHeaders();
             h.add("LockThread", "true");
 
@@ -1113,7 +1112,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetQueryStringTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // Use a l in case the assert fail
@@ -1133,7 +1132,7 @@ public Response onCompleted(Response response) throws Exception {
                 }
             };
 
-            Request req = new RequestBuilder("GET").setUrl(getTargetUrl() + "?foo=bar").build();
+            Request req = get(getTargetUrl() + "?foo=bar").build();
 
             client.executeRequest(req, handler).get();
 
@@ -1143,7 +1142,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoGetKeepAliveHandlerTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // Use a l in case the assert fail
@@ -1178,9 +1177,9 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
+    @Test(groups = "online")
     public void asyncDoGetMaxRedirectTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setMaxRedirects(0).setFollowRedirect(true).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setMaxRedirects(0).setFollowRedirect(true))) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
 
@@ -1211,7 +1210,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
+    @Test(groups = "online")
     public void asyncDoGetNestedTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // FIXME find a proper website that redirects the same number of
@@ -1252,7 +1251,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
+    @Test(groups = "online")
     public void asyncDoGetStreamAndBodyTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
@@ -1260,7 +1259,7 @@ public void asyncDoGetStreamAndBodyTest() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
+    @Test(groups = "online")
     public void asyncUrlWithoutPathTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
@@ -1268,7 +1267,7 @@ public void asyncUrlWithoutPathTest() throws Exception {
         }
     }
 
-    @Test(groups = { "default_provider", "async" })
+    @Test(groups = "standalone")
     public void optionsTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareOptions(getTargetUrl()).execute().get();
@@ -1278,7 +1277,7 @@ public void optionsTest() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testAwsS3() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
@@ -1290,10 +1289,9 @@ public void testAwsS3() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testAsyncHttpProviderConfig() throws Exception {
-        AsyncHttpClientConfig config = config().setAdvancedConfig(advancedConfig().addChannelOption(ChannelOption.TCP_NODELAY, Boolean.TRUE).build()).build();
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
+        try (AsyncHttpClient client = asyncHttpClient(config().addChannelOption(ChannelOption.TCP_NODELAY, Boolean.TRUE))) {
             Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
             if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
                 fail("No response Body");
@@ -1303,9 +1301,9 @@ public void testAsyncHttpProviderConfig() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void idleRequestTimeoutTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000))) {
             HttpHeaders h = new DefaultHttpHeaders();
             h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
             h.add("LockThread", "true");
@@ -1323,7 +1321,7 @@ public void idleRequestTimeoutTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void asyncDoPostCancelTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             HttpHeaders h = new DefaultHttpHeaders();
@@ -1355,21 +1353,21 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void getShouldAllowBody() throws IOException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = { NullPointerException.class })
+    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
     public void invalidUri() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             client.prepareGet(String.format("http:127.0.0.1:%d/foo/test", port1)).build();
         }
     }
 
-    @Test(groups = { "default_provider", "async" })
+    @Test(groups = "standalone")
     public void bodyAsByteTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.prepareGet(getTargetUrl()).execute().get();
@@ -1378,7 +1376,7 @@ public void bodyAsByteTest() throws Exception {
         }
     }
 
-    @Test(groups = { "default_provider", "async" })
+    @Test(groups = "standalone")
     public void mirrorByteTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response response = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
@@ -1387,9 +1385,9 @@ public void mirrorByteTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = "standalone")
     public void testNewConnectionEventsFired() throws Exception {
-        Request request = new RequestBuilder("GET").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+        Request request = get("http://127.0.0.1:" + port1 + "/Test").build();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             EventCollectingHandler handler = new EventCollectingHandler();
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index ac5edc059..005ab2850 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -22,14 +22,16 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 
+import java.net.ConnectException;
 import java.util.Arrays;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.net.ssl.SSLHandshakeException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.asynchttpclient.channel.pool.KeepAliveStrategy;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.testng.annotations.Test;
 
@@ -39,10 +41,10 @@ protected String getTargetUrl() {
         return String.format("https://127.0.0.1:%d/foo/test", port1);
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void zeroCopyPostTest() throws Exception {
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslContext(createSslContext(new AtomicBoolean(true))).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
             Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -50,9 +52,9 @@ public void zeroCopyPostTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void multipleSSLRequestsTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setSslContext(createSslContext(new AtomicBoolean(true))).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
             String body = "hello there";
 
             // once
@@ -67,18 +69,18 @@ public void multipleSSLRequestsTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void multipleSSLWithoutCacheTest() throws Exception {
 
-        AdvancedConfig advancedConfig = advancedConfig().setConnectionStrategy(new ConnectionStrategy() {
+        KeepAliveStrategy keepAliveStrategy = new KeepAliveStrategy() {
 
             @Override
             public boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse) {
                 return !ahcRequest.getUri().isSecured();
             }
-        }).build();
+        };
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setSslContext(createSslContext(new AtomicBoolean(true))).setAdvancedConfig(advancedConfig).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))).setKeepAliveStrategy(keepAliveStrategy))) {
             String body = "hello there";
             c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
@@ -90,11 +92,11 @@ public boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpRespo
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void reconnectsAfterFailedCertificationPath() throws Exception {
 
         AtomicBoolean trust = new AtomicBoolean(false);
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslContext(createSslContext(trust)).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(trust)))) {
             String body = "hello there";
 
             // first request fails because server certificate is rejected
@@ -114,21 +116,22 @@ public void reconnectsAfterFailedCertificationPath() throws Exception {
         }
     }
 
-    @Test(timeOut = 2000, expectedExceptions = { Exception.class })
+    @Test(groups = "standalone", timeOut = 2000)
     public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(2000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(2000))) {
             try {
                 client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
             } catch (ExecutionException e) {
-                throw e.getCause() != null ? e.getCause() : e;
+                assertTrue(e.getCause() instanceof ConnectException, "Expecting a ConnectException");
+                assertTrue(e.getCause().getCause() instanceof SSLHandshakeException, "Expecting SSLHandshakeException cause");
             }
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testNormalEventsFired() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslContext(createSslContext(new AtomicBoolean(true))).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
             EventCollectingHandler handler = new EventCollectingHandler();
             client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, TimeUnit.SECONDS);
             handler.waitForCompletion(3, TimeUnit.SECONDS);
diff --git a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 7a7a89908..8aecbe521 100644
--- a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
+++ b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -69,7 +69,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicByteBufferTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             File largeFile = createTempFile(1024 * 100 * 10);
diff --git a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
index bda303fb7..82d135dfe 100644
--- a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
+++ b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -24,7 +24,7 @@
 
 public class ComplexClientTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void multipleRequestsTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String body = "hello there";
@@ -41,7 +41,7 @@ public void multipleRequestsTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void urlWithoutSlashTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String body = "hello there";
diff --git a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
index edc3006a1..b224bf324 100644
--- a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -59,7 +59,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new SimpleHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
@@ -72,7 +72,7 @@ public void digestAuthTest() throws IOException, ExecutionException, TimeoutExce
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
@@ -85,7 +85,7 @@ public void digestAuthTestWithoutScheme() throws IOException, ExecutionException
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
diff --git a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index e40a26305..3af1b6d59 100644
--- a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -60,7 +60,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new ErrorHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testQueryParameters() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
diff --git a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index 080892f61..69e0f44df 100644
--- a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
+++ b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -58,7 +58,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new ZeroCopyHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void Expect100Continue() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(SIMPLE_TEXT_FILE).execute();
diff --git a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
index d5b1f6238..2709fdfb5 100644
--- a/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
+++ b/client/src/test/java/org/asynchttpclient/FollowingThreadTest.java
@@ -33,7 +33,7 @@
 
     private static final int COUNT = 10;
 
-    @Test(timeOut = 30 * 1000, groups = { "online", "default_provider", "scalability" })
+    @Test(groups = "online", timeOut = 30 * 1000)
     public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         final CountDownLatch countDown = new CountDownLatch(COUNT);
@@ -46,7 +46,7 @@ public void testFollowRedirect() throws IOException, ExecutionException, Timeout
 
                     public void run() {
                         final CountDownLatch l = new CountDownLatch(1);
-                        try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true).build())) {
+                        try (AsyncHttpClient ahc = asyncHttpClient(config().setFollowRedirect(true))) {
                             ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
 
                                 public void onThrowable(Throwable t) {
diff --git a/client/src/test/java/org/asynchttpclient/Head302Test.java b/client/src/test/java/org/asynchttpclient/Head302Test.java
index 7a1499050..675d1d8ea 100644
--- a/client/src/test/java/org/asynchttpclient/Head302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Head302Test.java
@@ -62,11 +62,11 @@ public AbstractHandler configureHandler() throws Exception {
         return new Head302handler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+            Request request = head("http://127.0.0.1:" + port1 + "/Test").build();
 
             client.executeRequest(request, new AsyncCompletionHandlerBase() {
                 @Override
diff --git a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
index 2379982fc..d84d62176 100644
--- a/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
@@ -79,7 +79,7 @@ public void setUpGlobal() throws Exception {
         logger.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     // FIXME find a way to make this threadsafe, other, set @Test(singleThreaded = true)
     public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
         httpToHttpsRedirect();
@@ -87,7 +87,7 @@ public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
         relativeLocationUrl();
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void httpToHttpsRedirect() throws Exception {
         redirectDone.getAndSet(false);
 
@@ -104,7 +104,7 @@ public void httpToHttpsRedirect() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void httpToHttpsProperConfig() throws Exception {
         redirectDone.getAndSet(false);
 
@@ -127,7 +127,7 @@ public void httpToHttpsProperConfig() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void relativeLocationUrl() throws Exception {
         redirectDone.getAndSet(false);
 
diff --git a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
index f5f402a69..ad00bc8e8 100644
--- a/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
@@ -57,11 +57,9 @@ public void setUpGlobal() throws Exception {
         logger.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "standalone")
     public void idleStateTest() throws Exception {
-        AsyncHttpClientConfig cg = config().setPooledConnectionIdleTimeout(10 * 1000).build();
-
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setPooledConnectionIdleTimeout(10 * 1000))) {
             c.prepareGet(getTargetUrl()).execute().get();
         } catch (ExecutionException e) {
             fail("Should allow to finish processing request.", e);
diff --git a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 3b3aba159..c95d540d9 100644
--- a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -25,7 +25,7 @@
 
 public class ListenableFutureTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testListenableFuture() throws Exception {
         final AtomicInteger statusCode = new AtomicInteger(500);
         try (AsyncHttpClient ahc = asyncHttpClient()) {
diff --git a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
index 87e5f1d82..cad5fd0d3 100644
--- a/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
+++ b/client/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
@@ -88,12 +88,12 @@ public void tearDownGlobal() throws Exception {
         serverSocket.close();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         final String[] xffHeaders = new String[] { null, null };
 
         try (AsyncHttpClient ahc = asyncHttpClient()) {
-            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
+            Request req = get("http://localhost:" + port1 + "/MultiOther").build();
             final CountDownLatch latch = new CountDownLatch(1);
             ahc.executeRequest(req, new AsyncHandler<Void>() {
                 public void onThrowable(Throwable t) {
@@ -137,12 +137,12 @@ public Void onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         final String[] clHeaders = new String[] { null, null };
 
         try (AsyncHttpClient ahc = asyncHttpClient()) {
-            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
+            Request req = get("http://localhost:" + port1 + "/MultiEnt").build();
             final CountDownLatch latch = new CountDownLatch(1);
             ahc.executeRequest(req, new AsyncHandler<Void>() {
                 public void onThrowable(Throwable t) {
diff --git a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
index 0e3d7401b..4fec15e43 100644
--- a/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/NoNullResponseTest.java
@@ -19,26 +19,17 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.assertNotNull;
 
-import java.security.GeneralSecurityException;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
 import org.testng.annotations.Test;
 
 public class NoNullResponseTest extends AbstractBasicTest {
     private static final String GOOGLE_HTTPS_URL = "https://www.google.com";
 
-    @Test(invocationCount = 4, groups = { "online", "default_provider" })
+    @Test(groups = "online", invocationCount = 4)
     public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
 
         AsyncHttpClientConfig config = config()//
                 .setFollowRedirect(true)//
-                .setSslContext(getSSLContext())//
-                .setAllowPoolingConnections(true)//
+                .setKeepAlive(true)//
                 .setConnectTimeout(10000)//
                 .setPooledConnectionIdleTimeout(60000)//
                 .setRequestTimeout(10000)//
@@ -51,33 +42,8 @@ public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
             final Response response1 = builder.execute().get();
             Thread.sleep(4000);
             final Response response2 = builder.execute().get();
-            if (response2 != null) {
-                System.out.println("Success (2nd response was not null).");
-            } else {
-                System.out.println("Failed (2nd response was null).");
-            }
             assertNotNull(response1);
             assertNotNull(response2);
         }
     }
-
-    private SSLContext getSSLContext() throws GeneralSecurityException {
-        final SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, new TrustManager[] { new MockTrustManager() }, null);
-        return sslContext;
-    }
-
-    private static class MockTrustManager implements X509TrustManager {
-        public X509Certificate[] getAcceptedIssuers() {
-            return null;
-        }
-
-        public void checkClientTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
-            // do nothing.
-        }
-
-        public void checkServerTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {
-            // Do nothing.
-        }
-    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
index d29018ab5..6c0002864 100644
--- a/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
+++ b/client/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
@@ -62,7 +62,7 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques
         server.start();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testNonAsciiContentLength() throws Exception {
         execute("test");
         execute("\u4E00"); // Unicode CJK ideograph for one
diff --git a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index 6ef8a2e7c..a6731b761 100644
--- a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -53,7 +53,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 041d479d0..2c97f1caa 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -75,7 +75,7 @@ public void setUpGlobal() throws Exception {
         logger.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     // FIXME threadsafe
     public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
         redirected302Test();
@@ -84,7 +84,7 @@ public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
         redirected302InvalidTest();
     }
 
-    // @Test(groups = { "online", "default_provider" })
+    // @Test(groups = "online")
     public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
         try (AsyncHttpClient c = asyncHttpClient()) {
@@ -100,11 +100,10 @@ public void redirected302Test() throws Exception {
         }
     }
 
-    // @Test(groups = { "online", "default_provider" })
+    // @Test(groups = "online")
     public void notRedirected302Test() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
@@ -128,7 +127,7 @@ private static int getPort(Uri uri) {
         return port;
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
         try (AsyncHttpClient c = asyncHttpClient()) {
@@ -142,7 +141,7 @@ public void redirected302InvalidTest() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void relativeLocationUrl() throws Exception {
         isSet.getAndSet(false);
 
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 738c37e52..936f3347d 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -90,7 +90,7 @@ public void run() {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testRequestTimeout() throws IOException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
@@ -106,9 +106,9 @@ public void testRequestTimeout() throws IOException {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
             Response response = responseFuture.get();
             assertNotNull(response);
@@ -120,9 +120,9 @@ public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testGlobalRequestTimeout() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100))) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
@@ -136,11 +136,11 @@ public void testGlobalRequestTimeout() throws IOException {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testGlobalIdleTimeout() throws IOException {
         final long times[] = new long[] { -1, -1 };
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(2000))) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
index 0f6d4b786..2e01e2854 100644
--- a/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
@@ -41,27 +41,27 @@ public AbstractHandler configureHandler() throws Exception {
 
     // ------------------------------------------------------------ Test Methods
 
-    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
+    @Test(groups = "standalone")
     public void postRedirectGet302Test() throws Exception {
         doTestPositive(302);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
+    @Test(groups = "standalone")
     public void postRedirectGet302StrictTest() throws Exception {
         doTestNegative(302, true);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
+    @Test(groups = "standalone")
     public void postRedirectGet303Test() throws Exception {
         doTestPositive(303);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
+    @Test(groups = "standalone")
     public void postRedirectGet301Test() throws Exception {
-        doTestNegative(301, false);
+        doTestPositive(301);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
+    @Test(groups = "standalone")
     public void postRedirectGet307Test() throws Exception {
         doTestNegative(307, false);
     }
@@ -70,7 +70,7 @@ public void postRedirectGet307Test() throws Exception {
 
     private void doTestNegative(final int status, boolean strict) throws Exception {
 
-        AsyncHttpClientConfig config = config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
+        ResponseFilter responseFilter = new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -80,10 +80,10 @@ private void doTestNegative(final int status, boolean strict) throws Exception {
                 ctx.getRequest().getHeaders().remove("x-redirect");
                 return ctx;
             }
-        }).build();
+        };
 
-        try (AsyncHttpClient p = asyncHttpClient(config)) {
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(responseFilter))) {
+            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
                 @Override
@@ -105,7 +105,7 @@ public void onThrowable(Throwable t) {
 
     private void doTestPositive(final int status) throws Exception {
 
-        AsyncHttpClientConfig config = config().setFollowRedirect(true).addResponseFilter(new ResponseFilter() {
+        ResponseFilter responseFilter = new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -115,10 +115,10 @@ private void doTestPositive(final int status) throws Exception {
                 ctx.getRequest().getHeaders().remove("x-redirect");
                 return ctx;
             }
-        }).build();
+        };
 
-        try (AsyncHttpClient p = asyncHttpClient(config)) {
-            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(responseFilter))) {
+            Request request = post(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
                 @Override
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
index a16b36cd0..6074b1386 100644
--- a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
@@ -67,7 +67,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
@@ -77,7 +77,7 @@ public void postWithQS() throws IOException, ExecutionException, TimeoutExceptio
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
@@ -97,7 +97,7 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
@@ -117,7 +117,7 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
diff --git a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
index 5669b3abe..5e61810d5 100644
--- a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
+++ b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -16,7 +16,7 @@
 package org.asynchttpclient;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.testng.Assert.*;
 
@@ -34,7 +34,6 @@
 
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.slf4j.LoggerFactory;
 import org.testng.annotations.Test;
 
 /**
@@ -68,7 +67,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new QueryStringHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
@@ -80,21 +79,21 @@ public void testQueryParameters() throws IOException, ExecutionException, Timeou
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
         String URL = getTargetUrl() + "?q=";
         String REQUEST_PARAM = "github github \ngithub";
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
-            LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
+            logger.info("Executing request [{}] ...", requestUrl2);
             Response response = client.prepareGet(requestUrl2).execute().get();
             String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
             assertEquals(s, REQUEST_PARAM);
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void urlWithColonTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String query = "test:colon:";
diff --git a/client/src/test/java/org/asynchttpclient/RC10KTest.java b/client/src/test/java/org/asynchttpclient/RC10KTest.java
index cb5c04d19..ec745b463 100644
--- a/client/src/test/java/org/asynchttpclient/RC10KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC10KTest.java
@@ -92,7 +92,7 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C10K).setAllowPoolingConnections(true).build())) {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxConnectionsPerHost(C10K).setKeepAlive(true))) {
             List<Future<Integer>> resps = new ArrayList<>(C10K);
             int i = 0;
             while (i < C10K) {
diff --git a/client/src/test/java/org/asynchttpclient/RealmTest.java b/client/src/test/java/org/asynchttpclient/RealmTest.java
index 4fa4eb6b8..425185fb9 100644
--- a/client/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/client/src/test/java/org/asynchttpclient/RealmTest.java
@@ -23,7 +23,7 @@
 import org.testng.annotations.Test;
 
 public class RealmTest {
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testClone() {
         Realm orig = basicAuthRealm("user", "pass").setCharset(UTF_16)//
                 .setUsePreemptiveAuth(true)//
@@ -40,13 +40,13 @@ public void testClone() {
         assertEquals(clone.getScheme(), orig.getScheme());
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testOldDigestEmptyString() {
         String qop = "";
         testOldDigest(qop);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testOldDigestNull() {
         String qop = null;
         testOldDigest(qop);
@@ -73,7 +73,7 @@ private void testOldDigest(String qop) {
         assertEquals(expectedResponse, orig.getResponse());
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testStrongDigest() {
         String user = "user";
         String pass = "pass";
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index 530dbca26..602d8b0e5 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -56,9 +56,9 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
         }
     };
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void regular301LosesBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
 
             Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
@@ -66,9 +66,9 @@ public void regular301LosesBody() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void regular302LosesBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
 
             Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
@@ -76,9 +76,9 @@ public void regular302LosesBody() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void regular302StrictKeepsBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
 
             Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
@@ -86,9 +86,9 @@ public void regular302StrictKeepsBody() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void regular307KeepsBody() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
 
             Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
diff --git a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
index 31d6b1a61..5321defdf 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
@@ -63,11 +63,11 @@ public void setUp() throws Exception {
     /**
      * Tests that after a redirect the final url in the response reflect the redirect
      */
-    @Test
+    @Test(groups = "standalone")
     public void testGetRedirectFinalUrl() throws Exception {
 
         AsyncHttpClientConfig config = config()//
-                .setAllowPoolingConnections(true)//
+                .setKeepAlive(true)//
                 .setMaxConnectionsPerHost(1)//
                 .setMaxConnections(1)//
                 .setConnectTimeout(1000)//
@@ -76,9 +76,7 @@ public void testGetRedirectFinalUrl() throws Exception {
                 .build();
 
         try (AsyncHttpClient c = asyncHttpClient(config)) {
-            Request r = new RequestBuilder("GET").setUrl(servletEndpointRedirectUrl).build();
-
-            ListenableFuture<Response> response = c.executeRequest(r);
+            ListenableFuture<Response> response = c.executeRequest(get(servletEndpointRedirectUrl));
             Response res = null;
             res = response.get();
             assertNotNull(res.getResponseBody());
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index 9c7488812..e34647d76 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -72,7 +72,7 @@ public void setUpGlobal() throws Exception {
         logger.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
         redirected302Test();
         redirected302InvalidTest();
@@ -80,12 +80,11 @@ public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
         relativePathRedirectTest();
     }
 
-    // @Test(groups = { "online", "default_provider" })
+    // @Test(groups = "online")
     public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
 
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -95,13 +94,12 @@ public void redirected302Test() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
@@ -111,12 +109,11 @@ public void redirected302InvalidTest() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void absolutePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             String redirectTarget = "/bar/test";
             String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
@@ -129,12 +126,11 @@ public void absolutePathRedirectTest() throws Exception {
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void relativePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             String redirectTarget = "bar/test1";
             String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
index 4aa809957..55bc31e6d 100644
--- a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -29,8 +29,7 @@
 import org.testng.annotations.Test;
 
 /**
- * Unit tests for remote site.
- * <br>
+ * Unit tests for remote site. <br>
  * see http://github.com/MSch/ning-async-http-client-bug/tree/master
  * 
  * @author Martin Schurrer
@@ -40,69 +39,68 @@
     public static final String URL = "http://google.com?q=";
     public static final String REQUEST_PARAM = "github github \n" + "github";
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testGoogleCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testMailGoogleCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         }
     }
 
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     // FIXME
     public void testMicrosoftCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 301);
         }
     }
 
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     // FIXME
     public void testWwwMicrosoftCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
         }
     }
 
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     // FIXME
     public void testUpdateMicrosoftCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testGoogleComWithTimeout() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000).build())) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
             Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void asyncStatusHEADContentLenghtTest() throws Exception {
-        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true).build())) {
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true))) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("HEAD").setUrl("http://www.google.com/").build();
 
-            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            p.executeRequest(head("http://www.google.com/"), new AsyncCompletionHandlerAdapter() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
@@ -120,10 +118,14 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     public void invalidStreamTest2() throws Exception {
-        AsyncHttpClientConfig config = config().setRequestTimeout(10000).setFollowRedirect(true)
-                .setAllowPoolingConnections(false).setMaxRedirects(6).build();
+        AsyncHttpClientConfig config = config()//
+                .setRequestTimeout(10000)//
+                .setFollowRedirect(true)//
+                .setKeepAlive(false)//
+                .setMaxRedirects(6)//
+                .build();
 
         try (AsyncHttpClient c = asyncHttpClient(config)) {
             Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
@@ -137,7 +139,7 @@ public void invalidStreamTest2() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void asyncFullBodyProperlyRead() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
@@ -150,7 +152,7 @@ public void asyncFullBodyProperlyRead() throws Exception {
     }
 
     // FIXME Get a 302 in France...
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     public void testUrlRequestParametersEncoding() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
@@ -160,11 +162,10 @@ public void testUrlRequestParametersEncoding() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void stripQueryStringTest() throws Exception {
 
-        AsyncHttpClientConfig cg = config().setFollowRedirect(true).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
 
             assertNotNull(response);
@@ -172,55 +173,53 @@ public void stripQueryStringTest() throws Exception {
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void evilCoookieTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            RequestBuilder builder2 = new RequestBuilder("GET");
-            builder2.setFollowRedirect(true);
-            builder2.setUrl("http://www.google.com/");
-            builder2.addHeader("Content-Type", "text/plain");
-            builder2.addCookie(new Cookie("evilcookie", "test", false, ".google.com", "/", Long.MIN_VALUE, false, false));
-            Request request2 = builder2.build();
-            Response response = c.executeRequest(request2).get();
+            RequestBuilder builder = get("http://localhost")//
+                    .setFollowRedirect(true)//
+                    .setUrl("http://www.google.com/")//
+                    .addHeader("Content-Type", "text/plain")//
+                    .addCookie(new Cookie("evilcookie", "test", false, ".google.com", "/", Long.MIN_VALUE, false, false));
 
+            Response response = c.executeRequest(builder.build()).get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         }
     }
 
-    @Test(groups = { "online", "default_provider" }, enabled = false)
+    @Test(groups = "online", enabled = false)
     public void testAHC62Com() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).build())) {
-            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js")
-                    .execute(new AsyncHandler<Response>() {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
 
-                        private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-                        public void onThrowable(Throwable t) {
-                            t.printStackTrace();
-                        }
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
 
-                        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                            System.out.println(bodyPart.getBodyPartBytes().length);
-                            builder.accumulate(bodyPart);
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    System.out.println(bodyPart.getBodyPartBytes().length);
+                    builder.accumulate(bodyPart);
 
-                            return State.CONTINUE;
-                        }
+                    return State.CONTINUE;
+                }
 
-                        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                            builder.accumulate(responseStatus);
-                            return State.CONTINUE;
-                        }
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return State.CONTINUE;
+                }
 
-                        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                            builder.accumulate(headers);
-                            return State.CONTINUE;
-                        }
+                public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return State.CONTINUE;
+                }
 
-                        public Response onCompleted() throws Exception {
-                            return builder.build();
-                        }
-                    }).get(10, TimeUnit.SECONDS);
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertTrue(response.getResponseBody().length() >= 3870);
         }
diff --git a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
index a3205e4cf..de11fd92a 100644
--- a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
+++ b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
@@ -16,6 +16,7 @@
 package org.asynchttpclient;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.get;
 import static org.testng.Assert.assertEquals;
 
 import java.io.IOException;
@@ -23,40 +24,30 @@
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.testng.annotations.Test;
 
 public class RequestBuilderTest {
 
-    private final static String SAFE_CHARS =
-            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_~.";
+    private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_~.";
     private final static String HEX_CHARS = "0123456789ABCDEF";
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testEncodesQueryParameters() throws UnsupportedEncodingException {
-        String[] values = new String[]{
-                "abcdefghijklmnopqrstuvwxyz",
-                "ABCDEFGHIJKQLMNOPQRSTUVWXYZ",
-                "1234567890", "1234567890",
-                "`~!@#$%^&*()", "`~!@#$%^&*()",
-                "_+-=,.<>/?", "_+-=,.<>/?",
-                ";:'\"[]{}\\| ", ";:'\"[]{}\\| "
-        };
-
-        /* as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
+        String[] values = new String[] { "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKQLMNOPQRSTUVWXYZ", "1234567890", "1234567890", "`~!@#$%^&*()", "`~!@#$%^&*()", "_+-=,.<>/?",
+                "_+-=,.<>/?", ";:'\"[]{}\\| ", ";:'\"[]{}\\| " };
+
+        /*
+         * as per RFC-5849 (Oauth), and RFC-3986 (percent encoding) we MUST
          * encode everything except for "safe" characters; and nothing but them.
          * Safe includes ascii letters (upper and lower case), digits (0 - 9)
-         * and FOUR special characters: hyphen ('-'), underscore ('_'),
-         * tilde ('~') and period ('.')). Everything else must be percent-encoded,
+         * and FOUR special characters: hyphen ('-'), underscore ('_'), tilde
+         * ('~') and period ('.')). Everything else must be percent-encoded,
          * byte-by-byte, using UTF-8 encoding (meaning three-byte Unicode/UTF-8
-         * code points are encoded as three three-letter percent-encode entities).
+         * code points are encoded as three three-letter percent-encode
+         * entities).
          */
         for (String value : values) {
-            RequestBuilder builder = new RequestBuilder("GET").
-                    setUrl("http://example.com/").
-                    addQueryParam("name", value);
+            RequestBuilder builder = get("http://example.com/").addQueryParam("name", value);
 
             StringBuilder sb = new StringBuilder();
             for (int i = 0, len = value.length(); i < len; ++i) {
@@ -75,24 +66,18 @@ public void testEncodesQueryParameters() throws UnsupportedEncodingException {
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testChaining() throws IOException, ExecutionException, InterruptedException {
-        Request request = new RequestBuilder("GET")
-                .setUrl("http://foo.com")
-                .addQueryParam("x", "value")
-                .build();
+        Request request = get("http://foo.com").addQueryParam("x", "value").build();
 
         Request request2 = new RequestBuilder(request).build();
 
         assertEquals(request2.getUri(), request.getUri());
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testParsesQueryParams() throws IOException, ExecutionException, InterruptedException {
-        Request request = new RequestBuilder("GET")
-                .setUrl("http://foo.com/?param1=value1")
-                .addQueryParam("param2", "value2")
-                .build();
+        Request request = get("http://foo.com/?param1=value1").addQueryParam("param2", "value2").build();
 
         assertEquals(request.getUrl(), "http://foo.com/?param1=value1&param2=value2");
         List<Param> params = request.getQueryParams();
@@ -101,25 +86,25 @@ public void testParsesQueryParams() throws IOException, ExecutionException, Inte
         assertEquals(params.get(1), new Param("param2", "value2"));
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testUserProvidedRequestMethod() {
         Request req = new RequestBuilder("ABC").setUrl("http://foo.com").build();
         assertEquals(req.getMethod(), "ABC");
         assertEquals(req.getUrl(), "http://foo.com");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testPercentageEncodedUserInfo() {
-        final Request req = new RequestBuilder("GET").setUrl("http://hello:wor%20ld@foo.com").build();
+        final Request req = get("http://hello:wor%20ld@foo.com").build();
         assertEquals(req.getMethod(), "GET");
         assertEquals(req.getUrl(), "http://hello:wor%20ld@foo.com");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = "standalone")
     public void testContentTypeCharsetToBodyEncoding() {
-        final Request req = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=utf-8").build();
+        final Request req = get("http://localhost").setHeader("Content-Type", "application/json; charset=utf-8").build();
         assertEquals(req.getCharset(), UTF_8);
-        final Request req2 = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
+        final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
         assertEquals(req2.getCharset(), UTF_8);
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
index 5f25660be..a4bad984a 100644
--- a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
+++ b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -68,9 +68,9 @@ public AbstractHandler configureHandler() throws Exception {
         return new SlowAndBigHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMaxRetry() throws Exception {
-        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0).build())) {
+        try (AsyncHttpClient ahc = asyncHttpClient(config().setMaxRequestRetry(0))) {
             ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
             fail();
         } catch (Exception t) {
diff --git a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
index 2ab20e0a0..69aa1ee81 100644
--- a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
+++ b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -43,10 +43,10 @@
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testThreadName() throws Exception {
         String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
-        try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/").execute();
             f.get(3, TimeUnit.SECONDS);
 
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index 47e1751f2..ee768bcbb 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -22,8 +22,6 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.net.URI;
-import java.net.URISyntaxException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -46,20 +44,22 @@
 
 public class MaxConnectionsInThreads extends AbstractBasicTest {
 
-    // FIXME weird
-    private static URI servletEndpointUri;
-
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "standalone")
     public void testMaxConnectionsWithinThreads() throws Exception {
 
-        String[] urls = new String[] { servletEndpointUri.toString(), servletEndpointUri.toString() };
+        String[] urls = new String[] { getTargetUrl(), getTargetUrl() };
 
-        AsyncHttpClientConfig config = config().setConnectTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(true)//
-                .setMaxConnections(1).setMaxConnectionsPerHost(1).build();
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(true)//
+                .setMaxConnections(1)//
+                .setMaxConnectionsPerHost(1)//
+                .build();
 
         final CountDownLatch inThreadsLatch = new CountDownLatch(2);
         final AtomicInteger failedCount = new AtomicInteger();
-        
+
         try (AsyncHttpClient client = asyncHttpClient(config)) {
             for (int i = 0; i < urls.length; i++) {
                 final String url = urls[i];
@@ -72,7 +72,7 @@ public Response onCompleted(Response response) throws Exception {
                                 inThreadsLatch.countDown();
                                 return r;
                             }
-                            
+
                             @Override
                             public void onThrowable(Throwable t) {
                                 super.onThrowable(t);
@@ -100,7 +100,7 @@ public Response onCompleted(Response response) throws Exception {
                         notInThreadsLatch.countDown();
                         return r;
                     }
-                    
+
                     @Override
                     public void onThrowable(Throwable t) {
                         super.onThrowable(t);
@@ -109,9 +109,9 @@ public void onThrowable(Throwable t) {
                     }
                 });
             }
-            
+
             notInThreadsLatch.await();
-            
+
             assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
         }
     }
@@ -129,19 +129,10 @@ public void setUpGlobal() throws Exception {
         context.addServlet(new ServletHolder(new MockTimeoutHttpServlet()), "/timeout/*");
 
         server.start();
-
-        String endpoint = "http://127.0.0.1:" + port1 + "/timeout/";
-        servletEndpointUri = new URI(endpoint);
     }
 
     public String getTargetUrl() {
-        String s = "http://127.0.0.1:" + port1 + "/timeout/";
-        try {
-            servletEndpointUri = new URI(s);
-        } catch (URISyntaxException e) {
-            e.printStackTrace();
-        }
-        return s;
+        return "http://127.0.0.1:" + port1 + "/timeout/";
     }
 
     @SuppressWarnings("serial")
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 8f803fbdf..1d8cd1100 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -30,20 +30,21 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Response;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
 public class MaxTotalConnectionTest extends AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "online")
     public void testMaxTotalConnectionsExceedingException() throws IOException {
         String[] urls = new String[] { "http://google.com", "http://github.com/" };
 
-        AsyncHttpClientConfig config = config().setConnectTimeout(1000)
-                .setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1)
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(false)//
+                .setMaxConnections(1)//
+                .setMaxConnectionsPerHost(1)//
                 .build();
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
@@ -51,14 +52,15 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
             for (int i = 0; i < urls.length; i++) {
                 futures.add(client.prepareGet(urls[i]).execute());
             }
-            
+
             boolean caughtError = false;
             int i;
             for (i = 0; i < urls.length; i++) {
                 try {
                     futures.get(i).get();
                 } catch (Exception e) {
-                    // assert that 2nd request fails, because maxTotalConnections=1
+                    // assert that 2nd request fails, because
+                    // maxTotalConnections=1
                     caughtError = true;
                     break;
                 }
@@ -69,16 +71,21 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
         }
     }
 
-    @Test
+    @Test(groups = "online")
     public void testMaxTotalConnections() throws Exception {
-        String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
+        String[] urls = new String[] { "http://google.com", "http://gatling.io" };
 
         final CountDownLatch latch = new CountDownLatch(2);
         final AtomicReference<Throwable> ex = new AtomicReference<>();
         final AtomicReference<String> failedUrl = new AtomicReference<>();
 
-        AsyncHttpClientConfig config = config().setConnectTimeout(1000).setRequestTimeout(5000)
-                .setAllowPoolingConnections(false).setMaxConnections(2).setMaxConnectionsPerHost(1).build();
+        AsyncHttpClientConfig config = config()//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(5000)//
+                .setKeepAlive(false)//
+                .setMaxConnections(2)//
+                .setMaxConnectionsPerHost(1)//
+                .build();
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
             for (String url : urls) {
diff --git a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java b/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
index 030cccd56..1cb37464d 100644
--- a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
@@ -34,30 +34,25 @@
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.test.EventCollectingHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.testng.annotations.Test;
 
 public class ConnectionPoolTest extends AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMaxTotalConnections() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setAllowPoolingConnections(true).setMaxConnections(1))) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
             String url = getTargetUrl();
             int i;
             Exception exception = null;
             for (i = 0; i < 3; i++) {
                 try {
-                    log.info("{} requesting url [{}]...", i, url);
+                    logger.info("{} requesting url [{}]...", i, url);
                     Response response = client.prepareGet(url).execute().get();
-                    log.info("{} response [{}].", i, response);
+                    logger.info("{} response [{}].", i, response);
                 } catch (Exception ex) {
                     exception = ex;
                 }
@@ -66,17 +61,17 @@ public void testMaxTotalConnections() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMaxTotalConnectionsException() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setAllowPoolingConnections(true).setMaxConnections(1))) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
             String url = getTargetUrl();
 
             List<ListenableFuture<Response>> futures = new ArrayList<>();
             for (int i = 0; i < 5; i++) {
-                log.info("{} requesting url [{}]...", i, url);
+                logger.info("{} requesting url [{}]...", i, url);
                 futures.add(client.prepareGet(url).execute());
             }
-            
+
             Exception exception = null;
             for (ListenableFuture<Response> future : futures) {
                 try {
@@ -93,7 +88,7 @@ public void testMaxTotalConnectionsException() throws IOException {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" }, enabled = true, invocationCount = 10, alwaysRun = true)
+    @Test(groups = "standalone", invocationCount = 10, alwaysRun = true)
     public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             // Use a l in case the assert fail
@@ -129,10 +124,9 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void multipleMaxConnectionOpenTest() throws Exception {
-        AsyncHttpClientConfig cg = config().setAllowPoolingConnections(true).setConnectTimeout(5000).setMaxConnections(1).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
             String body = "hello there";
 
             // once
@@ -155,10 +149,9 @@ public void multipleMaxConnectionOpenTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
-        AsyncHttpClientConfig cg = config().setAllowPoolingConnections(true).setConnectTimeout(5000).setMaxConnections(1).build();
-        try (AsyncHttpClient c = asyncHttpClient(cg)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
             String body = "hello there";
 
             // once
@@ -181,12 +174,13 @@ public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
     }
 
     /**
-     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
+     * This test just make sure the hack used to catch disconnected channel
+     * under win7 doesn't throw any exception. The onComplete method must be
+     * only called once.
      * 
-     * @throws Exception
-     *             if something wrong happens.
+     * @throws Exception if something wrong happens.
      */
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void win7DisconnectTest() throws Exception {
         final AtomicInteger count = new AtomicInteger(0);
 
@@ -216,7 +210,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void asyncHandlerOnThrowableTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final AtomicInteger count = new AtomicInteger();
@@ -250,17 +244,12 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
 
-        AsyncHttpClientConfig config = config()
-        .setMaxConnections(6)
-        .setMaxConnectionsPerHost(3)
-        .build();
-
-        Request request = new RequestBuilder().setUrl(getTargetUrl()).setHeader("Connection", "close").build();
+        RequestBuilder request = get(getTargetUrl()).setHeader("Connection", "close");
 
-        try (AsyncHttpClient client = asyncHttpClient(config)) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(6).setMaxConnectionsPerHost(3))) {
             client.executeRequest(request).get();
             Thread.sleep(1000);
             client.executeRequest(request).get();
@@ -270,10 +259,10 @@ public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
             client.executeRequest(request).get();
         }
     }
-    
-    @Test(groups = { "standalone", "default_provider" })
+
+    @Test(groups = "standalone")
     public void testPooledEventsFired() throws Exception {
-        Request request = new RequestBuilder("GET").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+        RequestBuilder request = get("http://127.0.0.1:" + port1 + "/Test");
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             EventCollectingHandler firstHandler = new EventCollectingHandler();
@@ -284,15 +273,8 @@ public void testPooledEventsFired() throws Exception {
             client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
             secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
 
-            Object[] expectedEvents = new Object[] {
-                    CONNECTION_POOL_EVENT,
-                    CONNECTION_POOLED_EVENT,
-                    REQUEST_SEND_EVENT,
-                    HEADERS_WRITTEN_EVENT,
-                    STATUS_RECEIVED_EVENT,
-                    HEADERS_RECEIVED_EVENT,
-                    CONNECTION_OFFER_EVENT,
-                    COMPLETED_EVENT};
+            Object[] expectedEvents = new Object[] { CONNECTION_POOL_EVENT, CONNECTION_POOLED_EVENT, REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT,
+                    HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT };
 
             assertEquals(secondHandler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
         }
diff --git a/client/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java b/client/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
index 9c5f735b1..90e405baa 100644
--- a/client/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
+++ b/client/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
@@ -20,7 +20,7 @@
 
 public class CookieDecoderTest {
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testDecodeUnquoted() {
         Cookie cookie = CookieDecoder.decode("foo=value; domain=/; path=/");
         assertNotNull(cookie);
@@ -30,7 +30,7 @@ public void testDecodeUnquoted() {
         assertEquals(cookie.getPath(), "/");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testDecodeQuoted() {
         Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
         assertNotNull(cookie);
@@ -38,7 +38,7 @@ public void testDecodeQuoted() {
         assertEquals(cookie.isWrap(), true);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testDecodeQuotedContainingEscapedQuote() {
         Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\\\"\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
         assertNotNull(cookie);
@@ -46,7 +46,7 @@ public void testDecodeQuotedContainingEscapedQuote() {
         assertEquals(cookie.isWrap(), true);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testIgnoreEmptyDomain() {
         Cookie cookie = CookieDecoder.decode("sessionid=OTY4ZDllNTgtYjU3OC00MWRjLTkzMWMtNGUwNzk4MTY0MTUw;Domain=;Path=/");
         assertNull(cookie.getDomain());
diff --git a/client/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java b/client/src/test/java/org/asynchttpclient/cookie/DateParserTest.java
similarity index 85%
rename from client/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java
rename to client/src/test/java/org/asynchttpclient/cookie/DateParserTest.java
index 0657852a5..42e1e7f20 100644
--- a/client/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java
+++ b/client/src/test/java/org/asynchttpclient/cookie/DateParserTest.java
@@ -28,11 +28,11 @@
  * 
  * @author slandelle
  */
-public class RFC2616DateParserTest {
+public class DateParserTest {
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testRFC822() throws ParseException {
-        Date date = DateParser.get().parse("Sun, 06 Nov 1994 08:49:37 GMT");
+        Date date = DateParser.parse("Sun, 06 Nov 1994 08:49:37 GMT");
         assertNotNull(date);
 
         Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
@@ -46,9 +46,9 @@ public void testRFC822() throws ParseException {
         assertEquals(cal.get(Calendar.SECOND), 37);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testRFC822SingleDigitDayOfMonth() throws ParseException {
-        Date date = DateParser.get().parse("Sun, 6 Nov 1994 08:49:37 GMT");
+        Date date = DateParser.parse("Sun, 6 Nov 1994 08:49:37 GMT");
         assertNotNull(date);
 
         Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
@@ -62,9 +62,9 @@ public void testRFC822SingleDigitDayOfMonth() throws ParseException {
         assertEquals(cal.get(Calendar.SECOND), 37);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testRFC822SingleDigitHour() throws ParseException {
-        Date date = DateParser.get().parse("Sun, 6 Nov 1994 8:49:37 GMT");
+        Date date = DateParser.parse("Sun, 6 Nov 1994 8:49:37 GMT");
         assertNotNull(date);
 
         Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
@@ -78,25 +78,25 @@ public void testRFC822SingleDigitHour() throws ParseException {
         assertEquals(cal.get(Calendar.SECOND), 37);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testRFC850() throws ParseException {
-        Date date = DateParser.get().parse("Sunday, 06-Nov-94 08:49:37 GMT");
+        Date date = DateParser.parse("Saturday, 06-Nov-94 08:49:37 GMT");
         assertNotNull(date);
-        
+
         Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
         cal.setTime(date);
-        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SATURDAY);
         assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
         assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
-        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.YEAR), 2094);
         assertEquals(cal.get(Calendar.HOUR), 8);
         assertEquals(cal.get(Calendar.MINUTE), 49);
         assertEquals(cal.get(Calendar.SECOND), 37);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testANSIC() throws ParseException {
-        Date date = DateParser.get().parse("Sun Nov  6 08:49:37 1994");
+        Date date = DateParser.parse("Sun Nov 6 08:49:37 1994");
         assertNotNull(date);
 
         Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
diff --git a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
index 394ee8275..b94b3998e 100644
--- a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
+++ b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -29,7 +29,6 @@
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
@@ -64,7 +63,7 @@ public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(100)))) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
@@ -73,7 +72,7 @@ public void basicTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void loadThrottleTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(10)))) {
             List<Future<Response>> futures = new ArrayList<>();
@@ -89,7 +88,7 @@ public void loadThrottleTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void maxConnectionsText() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().addRequestFilter(new ThrottleRequestFilter(0, 1000)))) {
             c.preparePost(getTargetUrl()).execute().get();
@@ -99,42 +98,38 @@ public void maxConnectionsText() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicResponseFilterTest() throws Exception {
-        AsyncHttpClientConfig config = config().addResponseFilter(new ResponseFilter() {
 
+        ResponseFilter responseFilter = new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 return ctx;
             }
+        };
 
-        }).build();
-
-        try (AsyncHttpClient c = asyncHttpClient(config)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void replayResponseFilterTest() throws Exception {
-        final AtomicBoolean replay = new AtomicBoolean(true);
-
-        AsyncHttpClientConfig config = config().addResponseFilter(new ResponseFilter() {
 
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-
                 if (replay.getAndSet(false)) {
                     Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
                     return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
                 }
                 return ctx;
             }
+        };
 
-        }).build();
-
-        try (AsyncHttpClient c = asyncHttpClient(config)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -142,24 +137,21 @@ public void replayResponseFilterTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void replayStatusCodeResponseFilterTest() throws Exception {
-        final AtomicBoolean replay = new AtomicBoolean(true);
-
-        AsyncHttpClientConfig config = config().addResponseFilter(new ResponseFilter() {
 
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-
                 if (ctx.getResponseStatus() != null && ctx.getResponseStatus().getStatusCode() == 200 && replay.getAndSet(false)) {
                     Request request = new RequestBuilder(ctx.getRequest()).addHeader("X-Replay", "true").build();
                     return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
                 }
                 return ctx;
             }
+        };
 
-        }).build();
-
-        try (AsyncHttpClient c = asyncHttpClient(config)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -167,24 +159,21 @@ public void replayStatusCodeResponseFilterTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void replayHeaderResponseFilterTest() throws Exception {
-        final AtomicBoolean replay = new AtomicBoolean(true);
-        AsyncHttpClientConfig config = config().addResponseFilter(new ResponseFilter() {
 
+        final AtomicBoolean replay = new AtomicBoolean(true);
+        ResponseFilter responseFilter = new ResponseFilter() {
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
-
                 if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().getHeaders().get("Ping").equals("Pong") && replay.getAndSet(false)) {
-
                     Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
                     return new FilterContext.FilterContextBuilder<T>().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
                 }
                 return ctx;
             }
+        };
 
-        }).build();
-
-        try (AsyncHttpClient c = asyncHttpClient(config)) {
+        try (AsyncHttpClient c = asyncHttpClient(config().addResponseFilter(responseFilter))) {
             Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
diff --git a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index 348ad0d25..f591e033e 100644
--- a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -109,7 +109,7 @@ public AsyncHttpClientConfig getAsyncHttpClientConfig() {
         return config().setMaxRequestRetry(0).setRequestTimeout(10000).build();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
@@ -133,7 +133,7 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
@@ -163,7 +163,7 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
@@ -196,7 +196,7 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
@@ -229,7 +229,7 @@ public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionE
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone", expectedExceptions = IOException.class)
     public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         int newPortWithoutAnyoneListening = findFreePort();
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
@@ -238,12 +238,7 @@ public void testConnectionRefused() throws IOException, ExecutionException, Time
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
             r.execute(bdah);
-            try {
-                bdah.getResponse();
-                fail("IOException should be thrown here!");
-            } catch (IOException e) {
-                // good
-            }
+            bdah.getResponse();
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index bd672f026..e046d4cf8 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -24,7 +24,8 @@
  * @author Benjamin Hanzelmann
  */
 public class PropertiesBasedResumableProcesserTest {
-    @Test
+    
+    @Test(groups = "standalone")
     public void testSaveLoad() throws Exception {
         PropertiesBasedResumableProcessor p = new PropertiesBasedResumableProcessor();
         p.put("http://localhost/test.url", 15L);
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index 2d3823769..611c21341 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -13,25 +13,24 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
+import static org.asynchttpclient.Dsl.get;
+import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.testng.annotations.Test;
 
 /**
  * @author Benjamin Hanzelmann
  */
 public class ResumableAsyncHandlerTest {
-    @Test
+
+    @Test(groups = "standalone")
     public void testAdjustRange() {
         MapResumableProcessor proc = new MapResumableProcessor();
 
         ResumableAsyncHandler h = new ResumableAsyncHandler(proc);
-        Request request = new RequestBuilder("GET").setUrl("http://test/url").build();
+        Request request = get("http://test/url").build();
         Request newRequest = h.adjustRequestRange(request);
         assertEquals(newRequest.getUri(), request.getUri());
         String rangeHeader = newRequest.getHeaders().get(HttpHeaders.Names.RANGE);
diff --git a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
index dd9353143..5fb91a02f 100644
--- a/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/EventPipelineTest.java
@@ -15,38 +15,34 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
+import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.HttpMessage;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AdvancedConfig;
-import org.asynchttpclient.AdvancedConfig.AdditionalPipelineInitializer;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 public class EventPipelineTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "netty_provider" })
+    @Test(groups = "standalone")
     public void asyncPipelineTest() throws Exception {
 
-        AdvancedConfig advancedConfig = advancedConfig().setHttpAdditionalPipelineInitializer(new AdditionalPipelineInitializer() {
-            public void initPipeline(ChannelPipeline pipeline) throws Exception {
-                pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+        AsyncHttpClientConfig.AdditionalChannelInitializer httpAdditionalPipelineInitializer = new AsyncHttpClientConfig.AdditionalChannelInitializer() {
+            public void initChannel(Channel channel) throws Exception {
+                channel.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
             }
-        }).build();
+        };
 
-        try (AsyncHttpClient p = asyncHttpClient(config().setAdvancedConfig(advancedConfig).build())) {
+        try (AsyncHttpClient p = asyncHttpClient(config().setHttpAdditionalChannelInitializer(httpAdditionalPipelineInitializer))) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            p.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
                     try {
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index b81e9f818..39061e10b 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -27,15 +27,12 @@
 import org.asynchttpclient.cookie.Cookie;
 import org.testng.annotations.Test;
 
-/**
- * @author Benjamin Hanzelmann
- */
 public class NettyAsyncResponseTest {
 
     @Test(groups = "standalone")
     public void testCookieParseExpires() {
-        // e.g. "Sun, 06-Feb-2012 03:45:24 GMT";
-        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
+        // e.g. "Tue, 27 Oct 2015 12:54:24 GMT";
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
         sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
 
         Date date = new Date(System.currentTimeMillis() + 60000);
@@ -87,5 +84,4 @@ public HttpHeaders getHeaders() {
         Cookie cookie = cookies.get(0);
         assertEquals(cookie.getMaxAge(), Long.MIN_VALUE);
     }
-
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index 9a1218394..263f3b291 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -71,13 +71,13 @@ public void run() {
         }
     }
 
-    @Test(groups = { "standalone", "netty_provider" })
+    @Test(groups = "standalone")
     public void testRequestTimeout() throws IOException {
         final Semaphore requestThrottle = new Semaphore(1);
 
         int samples = 10;
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
             final CountDownLatch latch = new CountDownLatch(samples);
             final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
 
diff --git a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index 6f68dce9b..b09357987 100644
--- a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -34,7 +34,6 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.servlet.ServletContextHandler;
@@ -63,12 +62,10 @@ protected String getTargetUrl() {
     }
 
     private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
-        Request r = new RequestBuilder("GET")//
-                .setUrl(getTargetUrl())//
+        RequestBuilder r = get(getTargetUrl())//
                 .addQueryParam(action, "1")//
                 .addQueryParam("maxRequests", "" + requests)//
-                .addQueryParam("id", id)//
-                .build();
+                .addQueryParam("id", id);
         return client.executeRequest(r);
     }
 
@@ -79,11 +76,11 @@ protected String getTargetUrl() {
      * @throws ExecutionException
      * @throws InterruptedException
      */
-    @Test
+    @Test(groups = "standalone")
     public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
 
         AsyncHttpClientConfig config = config()//
-                .setAllowPoolingConnections(true)//
+                .setKeepAlive(true)//
                 .setMaxConnections(100)//
                 .setConnectTimeout(60000)//
                 .setRequestTimeout(30000)//
@@ -110,11 +107,11 @@ public void testRetryNonBlocking() throws IOException, InterruptedException, Exe
         }
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
 
         AsyncHttpClientConfig config = config()//
-                .setAllowPoolingConnections(true)//
+                .setKeepAlive(true)//
                 .setMaxConnections(100)//
                 .setConnectTimeout(60000)//
                 .setRequestTimeout(30000)//
diff --git a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
index 624ba5511..2f3acce7e 100644
--- a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
@@ -38,7 +38,7 @@
 
 public class NettyReactiveStreamsTest extends ReactiveStreamsTest {
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone")
     public void testRetryingOnFailingStream() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 180af58ce..81eb4fb1d 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -26,8 +26,6 @@
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
@@ -38,8 +36,8 @@
     public static class NTLMHandler extends AbstractHandler {
 
         @Override
-        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest,
-                HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException,
+                ServletException {
 
             String authorization = httpRequest.getHeader("Authorization");
             if (authorization == null) {
@@ -76,22 +74,20 @@ public AbstractHandler configureHandler() throws Exception {
 
     private void ntlmAuthTest(Realm.Builder realmBuilder) throws IOException, InterruptedException, ExecutionException {
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder.build()))) {
-            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-            Future<Response> responseFuture = client.executeRequest(request);
+        try (AsyncHttpClient client = asyncHttpClient(config().setRealm(realmBuilder))) {
+            Future<Response> responseFuture = client.executeRequest(get(getTargetUrl()));
             int status = responseFuture.get().getStatusCode();
             Assert.assertEquals(status, 200);
         }
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
         ntlmAuthTest(realmBuilderBase());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
         ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
     }
 }
-
diff --git a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
index 1388ab80a..7c8b6bea0 100644
--- a/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
+++ b/client/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
@@ -15,8 +15,8 @@
  */
 package org.asynchttpclient.oauth;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
@@ -27,7 +27,6 @@
 
 import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.uri.Uri;
 import org.testng.annotations.Test;
 
@@ -132,11 +131,10 @@ private void testSignatureBaseStringWithEncodableOAuthToken(Request request) {
                 + "oauth_version%3D1.0");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testSignatureBaseStringWithProperlyEncodedUri() {
 
-        Request request = new RequestBuilder("POST")//
-                .setUrl("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
+        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
                 .addFormParam("c2", "")//
                 .addFormParam("a3", "2 q")//
                 .build();
@@ -145,15 +143,14 @@ public void testSignatureBaseStringWithProperlyEncodedUri() {
         testSignatureBaseStringWithEncodableOAuthToken(request);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testSignatureBaseStringWithRawUri() {
 
         // note: @ is legal so don't decode it into %40 because it won't be
         // encoded back
         // note: we don't know how to fix a = that should have been encoded as
         // %3D but who would be stupid enough to do that?
-        Request request = new RequestBuilder("POST")//
-                .setUrl("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")//
+        Request request = post("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")//
                 .addFormParam("c2", "")//
                 .addFormParam("a3", "2 q")//
                 .build();
@@ -164,7 +161,7 @@ public void testSignatureBaseStringWithRawUri() {
 
     // based on the reference test case from
     // http://oauth.pbwiki.com/TestCases
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetCalculateSignature() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
@@ -178,7 +175,7 @@ public void testGetCalculateSignature() {
         assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testPostCalculateSignature() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
@@ -188,8 +185,7 @@ public void testPostCalculateSignature() {
         formParams.add(new Param("file", "vacation.jpg"));
         formParams.add(new Param("size", "original"));
         String url = "http://photos.example.net/photos";
-        final Request req = new RequestBuilder("POST")//
-                .setUri(Uri.create(url))//
+        final Request req = post(url)//
                 .setFormParams(formParams)//
                 .setSignatureCalculator(calc)//
                 .build();
@@ -217,7 +213,7 @@ public void testPostCalculateSignature() {
         assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetWithRequestBuilder() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
@@ -228,8 +224,7 @@ public void testGetWithRequestBuilder() {
         queryParams.add(new Param("size", "original"));
         String url = "http://photos.example.net/photos";
 
-        final Request req = new RequestBuilder("GET")//
-                .setUri(Uri.create(url))//
+        final Request req = get(url)//
                 .setQueryParams(queryParams)//
                 .setSignatureCalculator(calc)//
                 .build();
@@ -261,7 +256,7 @@ public void testGetWithRequestBuilder() {
         assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetWithRequestBuilderAndQuery() {
         ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
         RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
@@ -269,8 +264,7 @@ public void testGetWithRequestBuilderAndQuery() {
 
         String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
 
-        final Request req = new RequestBuilder("GET")//
-                .setUri(Uri.create(url))//
+        final Request req = get(url)//
                 .setSignatureCalculator(calc)//
                 .build();
 
@@ -298,15 +292,14 @@ public void testGetWithRequestBuilderAndQuery() {
         assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testWithNullRequestToken() {
       String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
       ConsumerKey consumer = new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET);
       RequestToken user = new RequestToken(null, null);
       OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
 
-      final Request request = new RequestBuilder("GET")//
-          .setUri(Uri.create(url))//
+      final Request request = get(url)//
           .setSignatureCalculator(calc)//
           .build();
 
diff --git a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
index 85872185e..1426e153c 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
@@ -19,11 +19,9 @@
 
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 
 import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.RequestBuilder;
@@ -69,37 +67,18 @@ public void tearDownGlobal() throws Exception {
         server2.stop();
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "standalone")
     public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-        ProxyServer ps = proxyServer("127.0.0.1", port1).build();
-
-        AsyncHttpClientConfig config = config()//
-        .setFollowRedirect(true)//
-        .setAcceptAnyCertificate(true)//
-        .build();
-
-        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
-            RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
-            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    logger.debug(t.getMessage(), t);
-                }
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    return response;
-                }
-            });
-            Response r = responseFuture.get();
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true))) {
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+            Response r = asyncHttpClient.executeRequest(rb.build()).get();
             assertEquals(r.getStatusCode(), 200);
             assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "standalone")
     public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClientConfig config = config()//
                 .setFollowRedirect(true)//
@@ -107,21 +86,23 @@ public void testConfigProxy() throws IOException, InterruptedException, Executio
                 .setAcceptAnyCertificate(true)//
                 .build();
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
-            Future<Response> responseFuture = asyncHttpClient.executeRequest(new RequestBuilder("GET").setUrl(getTargetUrl2()).build(), new AsyncCompletionHandlerBase() {
-
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    logger.debug(t.getMessage(), t);
-                }
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    return response;
-                }
-            });
-            Response r = responseFuture.get();
+            Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
             assertEquals(r.getStatusCode(), 200);
             assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
+
+    @Test(groups = "standalone")
+    public void testPooledConnectionsWithProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+
+        try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true).setKeepAlive(true))) {
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+
+            Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
+            assertEquals(r1.getStatusCode(), 200);
+
+            Response r2 = asyncHttpClient.executeRequest(rb.build()).get();
+            assertEquals(r2.getStatusCode(), 200);
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
index d347dcb39..98d36f397 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
@@ -29,7 +29,6 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.eclipse.jetty.http.HttpStatus;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -91,11 +90,11 @@ public AbstractHandler configureHandler() throws Exception {
         return new NTLMProxyHandler();
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void ntlmProxyTest() throws IOException, InterruptedException, ExecutionException {
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = new RequestBuilder("GET").setProxyServer(ntlmProxy()).build();
+            Request request = get("http://localhost").setProxyServer(ntlmProxy()).build();
             Future<Response> responseFuture = client.executeRequest(request);
             int status = responseFuture.get().getStatusCode();
             Assert.assertEquals(status, 200);
diff --git a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index 05c5af57b..71b421aa1 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -39,9 +39,7 @@
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
 import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
@@ -56,7 +54,7 @@
  */
 public class ProxyTest extends AbstractBasicTest {
     public static class ProxyHandler extends AbstractHandler {
-        public void handle(String s,  org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 response.addHeader("target", r.getUri().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
@@ -73,11 +71,11 @@ public AbstractHandler configureHandler() throws Exception {
         return new ProxyHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1).build()).execute();
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -85,10 +83,9 @@ public void testRequestLevelProxy() throws IOException, ExecutionException, Time
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg = config().setProxyServer(proxyServer("127.0.0.1", port1).build()).build();
-        try (AsyncHttpClient client = asyncHttpClient(cfg)) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1)))) {
             String target = "http://127.0.0.1:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
@@ -98,12 +95,11 @@ public void testGlobalProxy() throws IOException, ExecutionException, TimeoutExc
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg = config().setProxyServer(proxyServer("127.0.0.1", port1 - 1).build()).build();
-        try (AsyncHttpClient client = asyncHttpClient(cfg)) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1 - 1)))) {
             String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1).build()).execute();
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -111,31 +107,31 @@ public void testBothProxies() throws IOException, ExecutionException, TimeoutExc
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testNonProxyHost() {
 
         // // should avoid, it's in non-proxy hosts
-        Request req = new RequestBuilder("GET").setUrl("http://somewhere.com/foo").build();
+        Request req = get("http://somewhere.com/foo").build();
         ProxyServer proxyServer = proxyServer("foo", 1234).setNonProxyHost("somewhere.com").build();
         assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
         //
         // // should avoid, it's in non-proxy hosts (with "*")
-        req = new RequestBuilder("GET").setUrl("http://sub.somewhere.com/foo").build();
+        req = get("http://sub.somewhere.com/foo").build();
         proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
         assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
 
         // should use it
-        req = new RequestBuilder("GET").setUrl("http://sub.somewhere.com/foo").build();
+        req = get("http://sub.somewhere.com/foo").build();
         proxyServer = proxyServer("foo", 1234).setNonProxyHost("*.somewhere.com").build();
         assertTrue(proxyServer.isIgnoredForHost(req.getUri().getHost()));
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testNonProxyHostsRequestOverridesConfig() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        
+
         ProxyServer configProxy = proxyServer("127.0.0.1", port1 - 1).build();
         ProxyServer requestProxy = proxyServer("127.0.0.1", port1).setNonProxyHost("127.0.0.1").build();
-        
+
         try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
             String target = "http://127.0.0.1:1234/";
             client.prepareGet(target).setProxyServer(requestProxy).execute().get();
@@ -146,9 +142,9 @@ public void testNonProxyHostsRequestOverridesConfig() throws IOException, Execut
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        
+
         ProxyServer proxy = proxyServer("127.0.0.1", port1 - 1).setNonProxyHost("127.0.0.1").build();
         try (AsyncHttpClient client = asyncHttpClient()) {
             String target = "http://127.0.0.1:" + port1 + "/";
@@ -159,8 +155,8 @@ public void testRequestNonProxyHost() throws IOException, ExecutionException, Ti
             assertEquals(resp.getHeader("target"), "/");
         }
     }
-    
-    @Test(groups = { "standalone", "default_provider" })
+
+    @Test(groups = "standalone")
     public void runSequentiallyBecauseNotThreadSafe() throws Exception {
         testProxyProperties();
         testIgnoreProxyPropertiesByDefault();
@@ -169,7 +165,7 @@ public void runSequentiallyBecauseNotThreadSafe() throws Exception {
         testUseProxySelector();
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -179,7 +175,6 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
         System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
         AsyncHttpClientConfigHelper.reloadProperties();
 
-
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
             String target = "http://127.0.0.1:1234/";
             Future<Response> f = client.prepareGet(target).execute();
@@ -201,7 +196,7 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -225,7 +220,7 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+     @Test(groups = "standalone", enabled = false)
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -257,7 +252,7 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void testWildcardNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -281,7 +276,7 @@ public void testWildcardNonProxyHosts() throws IOException, ExecutionException,
         }
     }
 
-    // @Test(groups = { "standalone", "default_provider" })
+    // @Test(groups = "standalone")
     public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         ProxySelector originalProxySelector = ProxySelector.getDefault();
         ProxySelector.setDefault(new ProxySelector() {
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
index b9a981c39..fb8479112 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
@@ -23,8 +23,13 @@
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.util.concurrent.Future;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public final class HttpStaticFileServer {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpStaticFileServer.class);
+
     static private EventLoopGroup bossGroup;
     static private EventLoopGroup workerGroup;
 
@@ -32,19 +37,18 @@ public static void start(int port) throws Exception {
         bossGroup = new NioEventLoopGroup(1);
         workerGroup = new NioEventLoopGroup();
         ServerBootstrap b = new ServerBootstrap();
-        b.group(bossGroup, workerGroup)
-            .channel(NioServerSocketChannel.class)
-            .handler(new LoggingHandler(LogLevel.INFO))
-            .childHandler(new HttpStaticFileServerInitializer());
+        b.group(bossGroup, workerGroup)//
+                .channel(NioServerSocketChannel.class)//
+                .handler(new LoggingHandler(LogLevel.INFO))//
+                .childHandler(new HttpStaticFileServerInitializer());
 
         b.bind(port).sync().channel();
-        System.err.println("Open your web browser and navigate to " +
-                    ("http") + "://127.0.0.1:" + port + '/');
+        LOGGER.info("Open your web browser and navigate to " + ("http") + "://127.0.0.1:" + port + '/');
     }
 
     public static void shutdown() {
-        Future bossFuture = bossGroup.shutdownGracefully();
-        Future workerFuture = workerGroup.shutdownGracefully();
+        Future<?> bossFuture = bossGroup.shutdownGracefully();
+        Future<?> workerFuture = workerGroup.shutdownGracefully();
         try {
             bossFuture.await();
             workerFuture.await();
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
index ca36eba21..c0aeb2572 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerHandler.java
@@ -36,7 +36,6 @@
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedFile;
 import io.netty.util.CharsetUtil;
-import io.netty.util.internal.SystemPropertyUtil;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.RandomAccessFile;
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
index 741a2dbd4..003cd23a1 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServerInitializer.java
@@ -20,15 +20,10 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
-import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
 
-
 public class HttpStaticFileServerInitializer extends ChannelInitializer<SocketChannel> {
 
-    public HttpStaticFileServerInitializer() {
-    }
-
     @Override
     public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index 5633f3fb6..6bee45f3e 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -7,8 +7,10 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.DefaultAsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
@@ -18,148 +20,151 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-
 public class ReactiveStreamsDownLoadTest {
-  private int serverPort = 8080;
-  private File largeFile;
-  private File smallFile;
-  @BeforeClass(alwaysRun = true)
-  public void setUpBeforeTest() throws Exception {
-    largeFile = TestUtils.createTempFile(15 * 1024);
-    smallFile = TestUtils.createTempFile(20);
-    HttpStaticFileServer.start(serverPort);
-  }
-
-  @AfterClass(alwaysRun = true)
-  public void tearDown() throws Exception {
-    HttpStaticFileServer.shutdown();
-  }
-
-  @Test
-  public void streamedResponseLargeFileTest() throws Throwable {
-    AsyncHttpClient c = new DefaultAsyncHttpClient();
-    String largeFileName = "http://127.0.0.1:" + serverPort + "/" + largeFile.getName();
-    ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName)
-        .execute(new SimpleStreamedAsyncHandler());
-    byte[] result = future.get().getBytes();
-    System.out.println("Result file size: " + result.length);
-    //assert(result.length == largeFile.length());
-  }
-
-  @Test
-  public void streamedResponseSmallFileTest() throws Throwable {
-    AsyncHttpClient c = new DefaultAsyncHttpClient();
-    String smallFileName = "http://127.0.0.1:" + serverPort + "/" + smallFile.getName();
-    ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName)
-        .execute(new SimpleStreamedAsyncHandler());
-    byte[] result = future.get().getBytes();
-    System.out.println("Result file size: " + result.length);
-    //assert(result.length == smallFile.length());
-    assert(result.length > 0);
-  }
-
-  static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
-    private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
-
-    public SimpleStreamedAsyncHandler() {
-      this(new SimpleSubscriber<HttpResponseBodyPart>());
-    }
-
-    public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
-      this.subscriber = subscriber;
-    }
-    @Override
-    public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-      System.out.println("SimpleStreamedAsyncHandleronCompleted onStream");
-      publisher.subscribe(subscriber);
-      return State.CONTINUE;
-    }
-
-    @Override
-    public void onThrowable(Throwable t) {
-      throw new AssertionError(t);
-    }
 
-    @Override
-    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-      System.out.println("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
-      throw new AssertionError("Should not have received body part");
-    }
+    private static final Logger LOGGER = LoggerFactory.getLogger(ReactiveStreamsDownLoadTest.class);
 
-    @Override
-    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-      return State.CONTINUE;
-    }
+    private int serverPort = 8080;
+    private File largeFile;
+    private File smallFile;
 
-    @Override
-    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-      return State.CONTINUE;
+    @BeforeClass(alwaysRun = true)
+    public void setUpBeforeTest() throws Exception {
+        largeFile = TestUtils.createTempFile(15 * 1024);
+        smallFile = TestUtils.createTempFile(20);
+        HttpStaticFileServer.start(serverPort);
     }
 
-    @Override
-    public SimpleStreamedAsyncHandler onCompleted() throws Exception {
-      System.out.println("SimpleStreamedAsyncHandleronCompleted onSubscribe");
-      return this;
+    @AfterClass(alwaysRun = true)
+    public void tearDown() throws Exception {
+        HttpStaticFileServer.shutdown();
     }
 
-    public byte[] getBytes() throws Throwable {
-      List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
-      ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-      for (HttpResponseBodyPart part : bodyParts) {
-        part.writeTo(bytes);
-      }
-      return bytes.toByteArray();
-    }
-  }
-
-  /**
-   * Simple subscriber that requests and buffers one element at a time.
-   */
-  static protected class SimpleSubscriber<T> implements Subscriber<T> {
-    private volatile Subscription subscription;
-    private volatile Throwable error;
-    private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
-    private final CountDownLatch latch = new CountDownLatch(1);
-
-    @Override
-    public void onSubscribe(Subscription subscription) {
-      System.out.println("SimpleSubscriber onSubscribe");
-      this.subscription = subscription;
-      subscription.request(1);
+    @Test(groups = "standalone")
+    public void streamedResponseLargeFileTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String largeFileName = "http://127.0.0.1:" + serverPort + "/" + largeFile.getName();
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
+            byte[] result = future.get().getBytes();
+            assertEquals(result.length, largeFile.length());
+        }
     }
 
-    @Override
-    public void onNext(T t) {
-      System.out.println("SimpleSubscriber onNext");
-      elements.add(t);
-      subscription.request(1);
+    @Test(groups = "standalone")
+    public void streamedResponseSmallFileTest() throws Throwable {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            String smallFileName = "http://127.0.0.1:" + serverPort + "/" + smallFile.getName();
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
+            byte[] result = future.get().getBytes();
+            LOGGER.debug("Result file size: " + result.length);
+            assertEquals(result.length, smallFile.length());
+        }
     }
 
-    @Override
-    public void onError(Throwable error) {
-      System.out.println("SimpleSubscriber onError");
-      this.error = error;
-      latch.countDown();
+    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
+        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+
+        public SimpleStreamedAsyncHandler() {
+            this(new SimpleSubscriber<HttpResponseBodyPart>());
+        }
+
+        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            this.subscriber = subscriber;
+        }
+
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onStream");
+            publisher.subscribe(subscriber);
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onBodyPartReceived");
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+            LOGGER.debug("SimpleStreamedAsyncHandleronCompleted onSubscribe");
+            return this;
+        }
+
+        public byte[] getBytes() throws Throwable {
+            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            for (HttpResponseBodyPart part : bodyParts) {
+                bytes.write(part.getBodyPartBytes());
+            }
+            return bytes.toByteArray();
+        }
     }
 
-    @Override
-    public void onComplete() {
-      System.out.println("SimpleSubscriber onComplete");
-      latch.countDown();
+    /**
+     * Simple subscriber that requests and buffers one element at a time.
+     */
+    static protected class SimpleSubscriber<T> implements Subscriber<T> {
+        private volatile Subscription subscription;
+        private volatile Throwable error;
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final CountDownLatch latch = new CountDownLatch(1);
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            LOGGER.debug("SimpleSubscriber onSubscribe");
+            this.subscription = subscription;
+            subscription.request(1);
+        }
+
+        @Override
+        public void onNext(T t) {
+            LOGGER.debug("SimpleSubscriber onNext");
+            elements.add(t);
+            subscription.request(1);
+        }
+
+        @Override
+        public void onError(Throwable error) {
+            LOGGER.error("SimpleSubscriber onError");
+            this.error = error;
+            latch.countDown();
+        }
+
+        @Override
+        public void onComplete() {
+            LOGGER.debug("SimpleSubscriber onComplete");
+            latch.countDown();
+        }
+
+        public List<T> getElements() throws Throwable {
+            latch.await();
+            if (error != null) {
+                throw error;
+            } else {
+                return elements;
+            }
+        }
     }
-
-    public List<T> getElements() throws Throwable {
-      latch.await();
-      if (error != null) {
-        throw error;
-      } else {
-        return elements;
-      }
-    }
-  }
-
 }
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index 4186f4dd8..1bcac1496 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -13,82 +13,112 @@
 package org.asynchttpclient.reactivestreams;
 
 import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
 
 import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
 import org.testng.annotations.Test;
 
+import rx.Observable;
+import rx.RxReactiveStreams;
+
 public class ReactiveStreamsTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
+    public void testStreamingPutImage() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Response response = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    @Test(groups = "standalone")
+    public void testConnectionDoesNotGetClosed() throws Exception {
+        // test that we can stream the same request multiple times
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER);
+            Response response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+
+            response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    @Test(groups = "standalone", expectedExceptions = ExecutionException.class)
+    public void testFailingStream() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+            Observable<ByteBuffer> failingObservable = Observable.error(new FailedStream());
+            Publisher<ByteBuffer> failingPublisher = RxReactiveStreams.toPublisher(failingObservable);
+
+            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    private class FailedStream extends RuntimeException {
+    }
+
+    @Test(groups = "standalone")
     public void streamedResponseTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
 
-            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl())
-                    .setBody(LARGE_IMAGE_BYTES)
-                    .execute(new SimpleStreamedAsyncHandler());
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
 
             assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
 
             // Run it again to check that the pipeline is in a good state
-            future = c.preparePost(getTargetUrl())
-                    .setBody(LARGE_IMAGE_BYTES)
-                    .execute(new SimpleStreamedAsyncHandler());
+            future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler());
 
             assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
 
             // Make sure a regular request still works
-            assertEquals(c.preparePost(getTargetUrl())
-                    .setBody("Hello")
-                    .execute().get().getResponseBody(), "Hello");
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
 
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void cancelStreamedResponseTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
 
             // Cancel immediately
-            c.preparePost(getTargetUrl())
-                    .setBody(LARGE_IMAGE_BYTES)
-                    .execute(new CancellingStreamedAsyncProvider(0)).get();
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(0)).get();
 
             // Cancel after 1 element
-            c.preparePost(getTargetUrl())
-                    .setBody(LARGE_IMAGE_BYTES)
-                    .execute(new CancellingStreamedAsyncProvider(1)).get();
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(1)).get();
 
             // Cancel after 10 elements
-            c.preparePost(getTargetUrl())
-                    .setBody(LARGE_IMAGE_BYTES)
-                    .execute(new CancellingStreamedAsyncProvider(10)).get();
+            c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new CancellingStreamedAsyncProvider(10)).get();
 
             // Make sure a regular request works
-            assertEquals(c.preparePost(getTargetUrl())
-                    .setBody("Hello")
-                    .execute().get().getResponseBody(), "Hello");
-
+            assertEquals(c.preparePost(getTargetUrl()).setBody("Hello").execute().get().getResponseBody(), "Hello");
         }
     }
 
-    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler>{
+    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler> {
         private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
         public SimpleStreamedAsyncHandler() {
@@ -98,6 +128,7 @@ public SimpleStreamedAsyncHandler() {
         public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
             this.subscriber = subscriber;
         }
+
         @Override
         public State onStream(Publisher<HttpResponseBodyPart> publisher) {
             publisher.subscribe(subscriber);
@@ -133,7 +164,7 @@ public SimpleStreamedAsyncHandler onCompleted() throws Exception {
             List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
             ByteArrayOutputStream bytes = new ByteArrayOutputStream();
             for (HttpResponseBodyPart part : bodyParts) {
-                part.writeTo(bytes);
+                bytes.write(part.getBodyPartBytes());
             }
             return bytes.toByteArray();
         }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
index adc81fc84..598d5290b 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
@@ -33,7 +33,7 @@
 
     private static final String MY_MESSAGE = "my message";
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void negativeContentTypeTest() throws Exception {
 
         AsyncHttpClientConfig config = config()//
@@ -43,9 +43,9 @@ public void negativeContentTypeTest() throws Exception {
                 .build();
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
-            RequestBuilder requestBuilder = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeader("Content-Type", "message/rfc822");
-
-            requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+            RequestBuilder requestBuilder = post(getTargetUrl())//
+                    .setHeader("Content-Type", "message/rfc822")//
+                    .setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
             Future<Response> future = client.executeRequest(requestBuilder.build());
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
index 353c85955..e9fb7dd25 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -35,30 +35,26 @@
 import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
 import org.testng.annotations.Test;
 
-/**
- * Test that the url fetcher is able to communicate via a proxy
- * 
- * @author dominict
- */
 public class ChunkingTest extends AbstractBasicTest {
+
     // So we can just test the returned data is the image,
     // and doesn't contain the chunked delimeters.
-    @Test()
+    @Test(groups = "standalone")
     public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
         doTestWithInputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE), 400000));
     }
 
-    @Test()
+    @Test(groups = "standalone")
     public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
         doTestWithInputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE)));
     }
 
-    @Test()
+    @Test(groups = "standalone")
     public void testDirectFileWithStreamBodyGenerator() throws Throwable {
         doTestWithInputStreamBodyGenerator(new FileInputStream(LARGE_IMAGE_FILE));
     }
 
-    @Test()
+    @Test(groups = "standalone")
     public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
         doTestWithFeedableBodyGenerator(new FileInputStream(LARGE_IMAGE_FILE));
     }
@@ -66,9 +62,7 @@ public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
     public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
 
-            RequestBuilder builder = new RequestBuilder("POST");
-            builder.setUrl(getTargetUrl());
-            builder.setBody(new InputStreamBodyGenerator(is));
+            RequestBuilder builder = post(getTargetUrl()).setBody(new InputStreamBodyGenerator(is));
 
             Request r = builder.build();
 
@@ -80,14 +74,10 @@ public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable
     public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
 
-            RequestBuilder builder = new RequestBuilder("POST");
-            builder.setUrl(getTargetUrl());
             final FeedableBodyGenerator feedableBodyGenerator = new SimpleFeedableBodyGenerator();
-            builder.setBody(feedableBodyGenerator);
+            Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
 
-            Request r = builder.build();
-
-            final ListenableFuture<Response> responseFuture = c.executeRequest(r);
+            ListenableFuture<Response> responseFuture = c.executeRequest(r);
 
             feed(feedableBodyGenerator, is);
 
@@ -110,7 +100,7 @@ private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) t
 
     private DefaultAsyncHttpClientConfig.Builder httpClientBuilder() {
         return config()//
-                .setAllowPoolingConnections(true)//
+                .setKeepAlive(true)//
                 .setMaxConnectionsPerHost(1)//
                 .setMaxConnections(1)//
                 .setConnectTimeout(1000)//
diff --git a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
index d4d0c9824..511ff2256 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
@@ -64,7 +64,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new NoBodyResponseHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testEmptyBody() throws IOException {
         try (AsyncHttpClient ahc = asyncHttpClient()) {
             final AtomicBoolean err = new AtomicBoolean(false);
@@ -119,7 +119,7 @@ public Object onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testPutEmptyBody() throws Exception {
         try (AsyncHttpClient ahc = asyncHttpClient()) {
             Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
diff --git a/client/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java b/client/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
index e8d612180..5802cf9bb 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
@@ -49,7 +49,7 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H
         };
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone")
     public void testUnauthorizedWhileUploading() throws Exception {
         File file = createTempFile(1024 * 1024);
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
index a389972e2..0945c2e24 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
@@ -60,19 +60,19 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H
         };
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone")
     public void testPutImageFile() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
             Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
             assertEquals(response.getStatusCode(), 200);
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone")
     public void testPutLargeTextFile() throws Exception {
         File file = createTempFile(1024 * 1024);
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
             Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
             assertEquals(response.getStatusCode(), 200);
         }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
index 812a99782..610b4d085 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
@@ -67,7 +67,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new InputStreamHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         try (AsyncHttpClient c = asyncHttpClient()) {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
index 1b2dbf405..49719fd19 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
@@ -35,20 +35,20 @@
  */
 public class PutLargeFileTest extends AbstractBasicTest {
 
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone")
     public void testPutLargeFile() throws Exception {
 
         File file = createTempFile(1024 * 1024);
 
         int timeout = (int) file.length() / 1000;
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
             Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
             assertEquals(response.getStatusCode(), 200);
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testPutSmallFile() throws Exception {
 
         File file = createTempFile(1024);
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java
deleted file mode 100644
index f1b78eda5..000000000
--- a/client/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.request.body;
-
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.assertEquals;
-
-import java.nio.ByteBuffer;
-import java.util.concurrent.ExecutionException;
-
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
-import org.reactivestreams.Publisher;
-import org.testng.annotations.Test;
-
-import rx.Observable;
-import rx.RxReactiveStreams;
-
-public class ReactiveStreamsTest extends AbstractBasicTest {
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
-    public void testStreamingPutImage() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000).build())) {
-            Response response = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER).execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
-    public void testConnectionDoesNotGetClosed() throws Exception { // test that we can stream the same request multiple times
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000).build())) {
-            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER);
-            Response response = requestBuilder.execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-            
-            response = requestBuilder.execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = true, expectedExceptions = ExecutionException.class)
-    public void testFailingStream() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000).build())) {
-            Observable<ByteBuffer> failingObservable = Observable.error(new FailedStream());
-            Publisher<ByteBuffer> failingPublisher = RxReactiveStreams.toPublisher(failingObservable);
-
-            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
-        }
-    }
-
-    @SuppressWarnings("serial")
-    private class FailedStream extends RuntimeException {}
-}
diff --git a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
index 4e55dd5e2..1852a6f34 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
@@ -77,7 +77,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicGetTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final AtomicReference<Throwable> throwable = new AtomicReference<>();
@@ -125,7 +125,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicPutFileTest() throws Exception {
         final AtomicReference<Throwable> throwable = new AtomicReference<>();
         final AtomicReference<HttpHeaders> hSent = new AtomicReference<>();
@@ -139,7 +139,7 @@ public void basicPutFileTest() throws Exception {
 
         int timeout = (int) (file.length() / 1000);
 
-        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout).build())) {
+        try (AsyncHttpClient client = asyncHttpClient(config().setConnectTimeout(timeout))) {
             TransferCompletionHandler tl = new TransferCompletionHandler();
             tl.addTransferListener(new TransferListener() {
 
@@ -179,7 +179,7 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicPutFileBodyGeneratorTest() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final AtomicReference<Throwable> throwable = new AtomicReference<>();
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index aeb8ca352..08579f49d 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -65,7 +65,7 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final AtomicBoolean headerSent = new AtomicBoolean(false);
@@ -96,7 +96,7 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
@@ -112,7 +112,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new ZeroCopyHandler();
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
         tmp.deleteOnExit();
@@ -123,7 +123,7 @@ public void onThrowable(Throwable t) {
                     }
 
                     public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                        bodyPart.writeTo(stream);
+                        stream.write(bodyPart.getBodyPartBytes());
                         return State.CONTINUE;
                     }
 
@@ -145,7 +145,7 @@ public Response onCompleted() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
         tmp.deleteOnExit();
@@ -156,7 +156,7 @@ public void onThrowable(Throwable t) {
                     }
 
                     public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                        bodyPart.writeTo(stream);
+                        stream.write(bodyPart.getBodyPartBytes());
 
                         if (bodyPart.getBodyPartBytes().length == 0) {
                             return State.ABORT;
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
index 200bed7a6..f20799fe4 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -13,16 +13,18 @@
  */
 package org.asynchttpclient.request.body.generator;
 
-import org.asynchttpclient.request.body.Body;
-import org.asynchttpclient.request.body.Body.State;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 
-import static org.testng.Assert.*;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.BodyState;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
 
 public class FeedableBodyGeneratorTest {
 
@@ -44,66 +46,30 @@ public void feedNotifiesListener() throws Exception {
     }
 
     @Test(groups = "standalone")
-    public void readingBytesReturnsFedContentWithEmptyLastBufferWhenChunkBoundariesEnabled() throws Exception {
-        feedableBodyGenerator.writeChunkBoundaries();
-        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
-        feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
-        Body body = feedableBodyGenerator.createBody();
-        assertEquals(readFromBody(body), "7\r\nTest123\r\n".getBytes(StandardCharsets.US_ASCII));
-        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
-        assertEquals(readFromBody(body), "0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
-        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
-    }
-
-    @Test(groups = "standalone")
-    public void readingBytesReturnsFedContentWithEmptyLastBufferWhenChunkBoundariesEnabledAllContentAvailable() throws Exception {
-        feedableBodyGenerator.writeChunkBoundaries();
-        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
-        feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
-        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
-        Body body = feedableBodyGenerator.createBody();
-        assertEquals(readFromBody(body), "7\r\nTest123\r\n0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
-        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
-    }
-
-    @Test(groups = "standalone")
-    public void readingBytesReturnsFedContentWithFilledLastBufferWhenChunkBoundariesEnabled() throws Exception {
-        feedableBodyGenerator.writeChunkBoundaries();
-        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
-        feedableBodyGenerator.feed(ByteBuffer.wrap(content), true);
-        Body body = feedableBodyGenerator.createBody();
-        assertEquals(readFromBody(body), "7\r\nTest123\r\n0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
-        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
-
-    }
-
-    @Test(groups = "standalone")
-    public void readingBytesReturnsFedContentWithoutChunkBoundariesWhenNotEnabled() throws Exception {
+    public void readingBytesReturnsFedContentWithoutChunkBoundaries() throws Exception {
         byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
         feedableBodyGenerator.feed(ByteBuffer.wrap(content), true);
         Body body = feedableBodyGenerator.createBody();
         assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
-        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
+        assertEquals(body.transferTo(Unpooled.buffer(1)), BodyState.STOP);
     }
 
 
     @Test(groups = "standalone")
     public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
-        feedableBodyGenerator.writeChunkBoundaries();
         byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
         feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
 
         Body body = feedableBodyGenerator.createBody();
-        assertEquals(readFromBody(body), "7\r\nTest123\r\n".getBytes(StandardCharsets.US_ASCII));
-        assertEquals(body.read(ByteBuffer.allocate(1)), State.Suspend);
+        assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.transferTo(Unpooled.buffer(1)), BodyState.SUSPEND);
     }
 
     private byte[] readFromBody(Body body) throws IOException {
-        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
-        body.read(byteBuffer);
-        byteBuffer.flip();
-        byte[] readBytes = new byte[byteBuffer.remaining()];
-        byteBuffer.get(readBytes);
+        ByteBuf byteBuf = Unpooled.buffer(512);
+        body.transferTo(byteBuf);
+        byte[] readBytes = new byte[byteBuf.readableBytes()];
+        byteBuf.readBytes(readBytes);
         return readBytes;
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
index 7cc1dc95d..052c2d847 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
@@ -14,16 +14,17 @@
 package org.asynchttpclient.request.body.generators;
 
 import static org.testng.Assert.assertEquals;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.io.IOException;
+import java.util.Random;
 
 import org.asynchttpclient.request.body.Body;
-import org.asynchttpclient.request.body.Body.State;
+import org.asynchttpclient.request.body.Body.BodyState;
 import org.asynchttpclient.request.body.generator.ByteArrayBodyGenerator;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Random;
-
 /**
  * @author Bryan Davis bpd@keynetics.com
  */
@@ -42,14 +43,14 @@ public void testSingleRead() throws IOException {
             new ByteArrayBodyGenerator(srcArray);
         final Body body = babGen.createBody();
 
-        final ByteBuffer chunkBuffer = ByteBuffer.allocate(chunkSize);
+        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
         // should take 1 read to get through the srcArray
-        body.read(chunkBuffer);
-        assertEquals(chunkBuffer.position(), srcArraySize, "bytes read");
+        body.transferTo(chunkBuffer);
+        assertEquals(chunkBuffer.readableBytes(), srcArraySize, "bytes read");
         chunkBuffer.clear();
 
-        assertEquals(body.read(chunkBuffer), State.Stop, "body at EOF");
+        assertEquals(body.transferTo(chunkBuffer), BodyState.STOP, "body at EOF");
     }
 
     @Test(groups = "standalone")
@@ -62,13 +63,13 @@ public void testMultipleReads() throws IOException {
             new ByteArrayBodyGenerator(srcArray);
         final Body body = babGen.createBody();
 
-        final ByteBuffer chunkBuffer = ByteBuffer.allocate(chunkSize);
+        final ByteBuf chunkBuffer = Unpooled.buffer(chunkSize);
 
         int reads = 0;
         int bytesRead = 0;
-        while (body.read(chunkBuffer) != State.Stop) {
+        while (body.transferTo(chunkBuffer) != BodyState.STOP) {
           reads += 1;
-          bytesRead += chunkBuffer.position();
+          bytesRead += chunkBuffer.readableBytes();
           chunkBuffer.clear();
         }
         assertEquals(reads, 4, "reads to drain generator");
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 1d175cc6c..69b192dcb 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -13,24 +13,25 @@
 package org.asynchttpclient.request.body.multipart;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.File;
 import java.io.IOException;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.asynchttpclient.request.body.Body;
-import org.asynchttpclient.request.body.Body.State;
+import org.asynchttpclient.request.body.Body.BodyState;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
 public class MultipartBodyTest {
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testBasics() throws IOException {
         final List<Part> parts = new ArrayList<>();
 
@@ -66,14 +67,14 @@ private static void compareContentLength(final List<Part> parts) throws IOExcept
         final Body multipartBody = MultipartUtils.newMultipartBody(parts, HttpHeaders.EMPTY_HEADERS);
         final long expectedContentLength = multipartBody.getContentLength();
         try {
-            final ByteBuffer buffer = ByteBuffer.allocate(8192);
+            final ByteBuf buffer = Unpooled.buffer(8192);
             boolean last = false;
             while (!last) {
-                if (multipartBody.read(buffer) == State.Stop) {
+                if (multipartBody.transferTo(buffer) == BodyState.STOP) {
                     last = true;
                 }
             }
-            Assert.assertEquals(buffer.position(), expectedContentLength);
+            Assert.assertEquals(buffer.readableBytes(), expectedContentLength);
         } finally {
             try {
                 multipartBody.close();
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
index 813480891..f380302ec 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
@@ -80,7 +80,7 @@ public void setUp() throws Exception {
      * Tests that the streaming of a file works.
      * @throws IOException 
      */
-    @Test
+    @Test(groups = "standalone")
     public void testSendingSmallFilesAndByteArray() throws IOException {
         String expectedContents = "filecontent: hello";
         String expectedContents2 = "gzipcontent: hello";
@@ -152,13 +152,11 @@ public void testSendingSmallFilesAndByteArray() throws IOException {
 
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
 
-            RequestBuilder builder = new RequestBuilder("POST");
-            builder.setUrl("http://localhost" + ":" + port1 + "/upload/bob");
+            RequestBuilder builder = post("http://localhost" + ":" + port1 + "/upload/bob");
             builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8));
             builder.addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null));
             builder.addBodyPart(new StringPart("Name", "Dominic"));
             builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8));
-
             builder.addBodyPart(new StringPart("Age", "3"));
             builder.addBodyPart(new StringPart("Height", "shrimplike"));
             builder.addBodyPart(new StringPart("Hair", "ridiculous"));
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index a491eddd0..2cd9be945 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -1,32 +1,8 @@
 package org.asynchttpclient.test;
 
-import static java.nio.charset.StandardCharsets.*;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.testng.Assert.assertEquals;
 
-import org.apache.commons.io.FileUtils;
-import org.eclipse.jetty.security.ConstraintMapping;
-import org.eclipse.jetty.security.ConstraintSecurityHandler;
-import org.eclipse.jetty.security.HashLoginService;
-import org.eclipse.jetty.security.LoginService;
-import org.eclipse.jetty.security.authentication.BasicAuthenticator;
-import org.eclipse.jetty.security.authentication.DigestAuthenticator;
-import org.eclipse.jetty.security.authentication.LoginAuthenticator;
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.HttpConfiguration;
-import org.eclipse.jetty.server.HttpConnectionFactory;
-import org.eclipse.jetty.server.SecureRequestCustomizer;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.ServerConnector;
-import org.eclipse.jetty.server.SslConnectionFactory;
-import org.eclipse.jetty.util.security.Constraint;
-import org.eclipse.jetty.util.ssl.SslContextFactory;
-import org.reactivestreams.Publisher;
-
-import rx.Observable;
-import rx.RxReactiveStreams;
-
-import javax.net.ssl.*;
-
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -38,7 +14,9 @@
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import java.security.*;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -50,6 +28,38 @@
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.SslEngineFactory;
+import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
+import org.eclipse.jetty.security.ConstraintMapping;
+import org.eclipse.jetty.security.ConstraintSecurityHandler;
+import org.eclipse.jetty.security.HashLoginService;
+import org.eclipse.jetty.security.LoginService;
+import org.eclipse.jetty.security.authentication.BasicAuthenticator;
+import org.eclipse.jetty.security.authentication.DigestAuthenticator;
+import org.eclipse.jetty.security.authentication.LoginAuthenticator;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpConfiguration;
+import org.eclipse.jetty.server.HttpConnectionFactory;
+import org.eclipse.jetty.server.SecureRequestCustomizer;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.SslConnectionFactory;
+import org.eclipse.jetty.util.security.Constraint;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.reactivestreams.Publisher;
+
+import rx.Observable;
+import rx.RxReactiveStreams;
+
 public class TestUtils {
 
     public static final String USER = "user";
@@ -69,10 +79,10 @@
         try {
             TMP_DIR.mkdirs();
             TMP_DIR.deleteOnExit();
-            LARGE_IMAGE_FILE = new File(TestUtils.class.getClassLoader().getResource("300k.png").toURI());
+            LARGE_IMAGE_FILE = resourceAsFile("300k.png");
             LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
-            LARGE_IMAGE_PUBLISHER = createPublisher(LARGE_IMAGE_BYTES, /*chunkSize*/ 1000);
-            SIMPLE_TEXT_FILE = new File(TestUtils.class.getClassLoader().getResource("SimpleTextFile.txt").toURI());
+            LARGE_IMAGE_PUBLISHER = createPublisher(LARGE_IMAGE_BYTES, /* chunkSize */1000);
+            SIMPLE_TEXT_FILE = resourceAsFile("SimpleTextFile.txt");
             SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
         } catch (Exception e) {
             throw new ExceptionInInitializerError(e);
@@ -85,6 +95,21 @@ public static synchronized int findFreePort() throws IOException {
         }
     }
 
+    private static File resourceAsFile(String path) throws URISyntaxException, IOException {
+        ClassLoader cl = TestUtils.class.getClassLoader();
+        URI uri = cl.getResource(path).toURI();
+        if (uri.isAbsolute() && !uri.isOpaque()) {
+            return new File(uri);
+        } else {
+            File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
+            tmpFile.deleteOnExit();
+            try (InputStream is = cl.getResourceAsStream(path)) {
+                FileUtils.copyInputStreamToFile(is, tmpFile);
+                return tmpFile;
+            }
+        }
+    }
+
     public static File createTempFile(int approxSize) throws IOException {
         long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
@@ -115,11 +140,11 @@ public ByteBufferIterable(byte[] payload, int chunkSize) {
             this.chunkSize = chunkSize;
         }
 
-
         @Override
         public Iterator<ByteBuffer> iterator() {
             return new Iterator<ByteBuffer>() {
                 private int currentIndex = 0;
+
                 @Override
                 public boolean hasNext() {
                     return currentIndex != payload.length;
@@ -154,21 +179,19 @@ public static void addHttpConnector(Server server, int port) {
         server.addConnector(connector);
     }
 
-    public static Server newJettyHttpsServer(int port) throws URISyntaxException {
+    public static Server newJettyHttpsServer(int port) throws IOException, URISyntaxException {
         Server server = new Server();
         addHttpsConnector(server, port);
         return server;
     }
 
-    public static void addHttpsConnector(Server server, int port) throws URISyntaxException {
-        ClassLoader cl = TestUtils.class.getClassLoader();
+    public static void addHttpsConnector(Server server, int port) throws IOException, URISyntaxException {
 
-        URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        String keyStoreFile = new File(keystoreUrl.toURI()).getAbsolutePath();
+        String keyStoreFile = resourceAsFile("ssltest-keystore.jks").getAbsolutePath();
         SslContextFactory sslContextFactory = new SslContextFactory(keyStoreFile);
         sslContextFactory.setKeyStorePassword("changeit");
 
-        String trustStoreFile = new File(cl.getResource("ssltest-cacerts.jks").toURI()).getAbsolutePath();
+        String trustStoreFile = resourceAsFile("ssltest-cacerts.jks").getAbsolutePath();
         sslContextFactory.setTrustStorePath(trustStoreFile);
         sslContextFactory.setTrustStorePassword("changeit");
 
@@ -220,11 +243,12 @@ private static void addAuthHandler(Server server, String auth, LoginAuthenticato
     }
 
     private static KeyManager[] createKeyManagers() throws GeneralSecurityException, IOException {
-        InputStream keyStoreStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("ssltest-cacerts.jks");
-        char[] keyStorePassword = "changeit".toCharArray();
         KeyStore ks = KeyStore.getInstance("JKS");
-        ks.load(keyStoreStream, keyStorePassword);
-        assert(ks.size() > 0);
+        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-cacerts.jks")) {
+            char[] keyStorePassword = "changeit".toCharArray();
+            ks.load(keyStoreStream, keyStorePassword);
+        }
+        assert (ks.size() > 0);
 
         // Set up key manager factory to use our key store
         char[] certificatePassword = "changeit".toCharArray();
@@ -236,18 +260,20 @@ private static void addAuthHandler(Server server, String auth, LoginAuthenticato
     }
 
     private static TrustManager[] createTrustManagers() throws GeneralSecurityException, IOException {
-        InputStream keyStoreStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("ssltest-keystore.jks");
-        char[] keyStorePassword = "changeit".toCharArray();
         KeyStore ks = KeyStore.getInstance("JKS");
-        ks.load(keyStoreStream, keyStorePassword);
-        assert(ks.size() > 0);
+        try (InputStream keyStoreStream = TestUtils.class.getClassLoader().getResourceAsStream("ssltest-keystore.jks")) {
+            char[] keyStorePassword = "changeit".toCharArray();
+            ks.load(keyStoreStream, keyStorePassword);
+        }
+        assert (ks.size() > 0);
 
         TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
         tmf.init(ks);
         return tmf.getTrustManagers();
     }
 
-    public static SSLContext createSslContext(AtomicBoolean trust) {
+    public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) throws SSLException {
+
         try {
             KeyManager[] keyManagers = createKeyManagers();
             TrustManager[] trustManagers = new TrustManager[] { dummyTrustManager(trust, (X509TrustManager) createTrustManagers()[0]) };
@@ -256,9 +282,10 @@ public static SSLContext createSslContext(AtomicBoolean trust) {
             SSLContext sslContext = SSLContext.getInstance("TLS");
             sslContext.init(keyManagers, trustManagers, secureRandom);
 
-            return sslContext;
+            return new JsseSslEngineFactory(sslContext);
+
         } catch (Exception e) {
-            throw new Error("Failed to initialize the server-side SSLContext", e);
+            throw new ExceptionInInitializerError(e);
         }
     }
 
@@ -273,14 +300,12 @@ public DummyTrustManager(final AtomicBoolean trust, final X509TrustManager tm) {
         }
 
         @Override
-        public void checkClientTrusted(X509Certificate[] chain, String authType)
-                throws CertificateException {
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             tm.checkClientTrusted(chain, authType);
         }
 
         @Override
-        public void checkServerTrusted(X509Certificate[] chain, String authType)
-                throws CertificateException {
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             if (!trust.get()) {
                 throw new CertificateException("Server certificate not trusted.");
             }
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriTest.java b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
index 3f798ed7f..6ff410a07 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -19,7 +19,7 @@
 
 public class UriTest {
 
-    @Test
+    @Test(groups = "standalone")
     public void testSimpleParsing() {
         Uri url = Uri.create("https://graph.facebook.com/750198471659552/accounts/test-users?method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
         assertEquals(url.getScheme(), "https");
@@ -29,7 +29,7 @@ public void testSimpleParsing() {
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRootRelativeURIWithRootContext() {
 
         Uri context = Uri.create("https://graph.facebook.com");
@@ -43,7 +43,7 @@ public void testRootRelativeURIWithRootContext() {
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
     
-    @Test
+    @Test(groups = "standalone")
     public void testRootRelativeURIWithNonRootContext() {
 
         Uri context = Uri.create("https://graph.facebook.com/foo/bar");
@@ -57,7 +57,7 @@ public void testRootRelativeURIWithNonRootContext() {
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
     
-    @Test
+    @Test(groups = "standalone")
     public void testNonRootRelativeURIWithNonRootContext() {
 
         Uri context = Uri.create("https://graph.facebook.com/foo/bar");
@@ -71,7 +71,7 @@ public void testNonRootRelativeURIWithNonRootContext() {
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
     
-    @Test
+    @Test(groups = "standalone")
     public void testAbsoluteURIWithContext() {
 
         Uri context = Uri.create("https://hello.com/foo/bar");
@@ -85,7 +85,7 @@ public void testAbsoluteURIWithContext() {
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithDots() {
         Uri context = Uri.create("https://hello.com/level1/level2/");
 
@@ -98,7 +98,7 @@ public void testRelativeUriWithDots() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithDotsAboveRoot() {
         Uri context = Uri.create("https://hello.com/level1");
 
@@ -111,7 +111,7 @@ public void testRelativeUriWithDotsAboveRoot() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithAbsoluteDots() {
         Uri context = Uri.create("https://hello.com/level1/");
 
@@ -124,7 +124,7 @@ public void testRelativeUriWithAbsoluteDots() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDots() {
         Uri context = Uri.create("https://hello.com/level1/level2/");
 
@@ -137,7 +137,7 @@ public void testRelativeUriWithConsecutiveDots() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDotsAboveRoot() {
         Uri context = Uri.create("https://hello.com/level1/level2");
 
@@ -150,7 +150,7 @@ public void testRelativeUriWithConsecutiveDotsAboveRoot() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithAbsoluteConsecutiveDots() {
         Uri context = Uri.create("https://hello.com/level1/level2/");
 
@@ -163,7 +163,7 @@ public void testRelativeUriWithAbsoluteConsecutiveDots() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDotsFromRoot() {
         Uri context = Uri.create("https://hello.com/");
 
@@ -176,7 +176,7 @@ public void testRelativeUriWithConsecutiveDotsFromRoot() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDotsFromRootResource() {
         Uri context = Uri.create("https://hello.com/level1");
 
@@ -189,7 +189,7 @@ public void testRelativeUriWithConsecutiveDotsFromRootResource() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDotsFromSubrootResource() {
         Uri context = Uri.create("https://hello.com/level1/level2");
 
@@ -202,7 +202,7 @@ public void testRelativeUriWithConsecutiveDotsFromSubrootResource() {
         assertNull(url.getQuery());
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() {
         Uri context = Uri.create("https://hello.com/level1/level2/level3");
 
diff --git a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java b/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
index 7c74caa9c..5fa3651ae 100644
--- a/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
+++ b/client/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
@@ -20,7 +20,7 @@
 import org.testng.annotations.Test;
 
 public class TestUTF8UrlCodec {
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testBasics() {
         assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
         assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
diff --git a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
index bc83dc291..3df819975 100644
--- a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
@@ -88,12 +88,11 @@ protected String getTargetUrl() {
     // FIXME not sure that's threadsafe
     public void clean() throws InterruptedException, Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            Request deleteRequest = new RequestBuilder("DELETE").setUrl(getTargetUrl()).build();
-            c.executeRequest(deleteRequest).get();
+            c.executeRequest(delete(getTargetUrl())).get();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
@@ -102,7 +101,7 @@ public void mkcolWebDavTest1() throws InterruptedException, IOException, Executi
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
@@ -111,7 +110,7 @@ public void mkcolWebDavTest2() throws InterruptedException, IOException, Executi
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
@@ -121,14 +120,14 @@ public void basicPropFindWebDavTest() throws InterruptedException, IOException,
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
-            Request putRequest = new RequestBuilder("PUT").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
+            Request putRequest = put(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
             response = c.executeRequest(putRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
@@ -140,7 +139,7 @@ public void propFindWebDavTest() throws InterruptedException, IOException, Execu
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
         try (AsyncHttpClient c = asyncHttpClient()) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
diff --git a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
index 09bbe6690..1aad7df4c 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
@@ -35,7 +35,7 @@ public void configure(WebSocketServletFactory factory) {
         };
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void echoByte() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -73,7 +73,7 @@ public void onMessage(byte[] message) {
         }
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void echoTwoMessagesTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(2);
diff --git a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 19ce3b2e7..d724d30c8 100644
--- a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -36,7 +36,7 @@ public void configure(WebSocketServletFactory factory) {
         };
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onCloseWithCode() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -51,7 +51,7 @@ public void onCloseWithCode() throws Exception {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onCloseWithCodeServerClose() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -95,7 +95,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000, expectedExceptions = { ExecutionException.class })
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = ExecutionException.class)
     public void getWebSocketThrowsException() throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
         try (AsyncHttpClient client = asyncHttpClient()) {
@@ -123,7 +123,7 @@ public void onError(Throwable t) {
         latch.await();
     }
 
-    @Test(timeOut = 60000, expectedExceptions = { IllegalArgumentException.class })
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalArgumentException.class)
     public void wrongStatusCode() throws Throwable {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -156,7 +156,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000, expectedExceptions = { IllegalStateException.class })
+    @Test(groups = "online", timeOut = 60000, expectedExceptions = IllegalStateException.class)
     public void wrongProtocolCode() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
diff --git a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index 68512f5b5..b6f2adad8 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -66,12 +66,12 @@ public void tearDownGlobal() throws Exception {
         server2.stop();
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void echoWSText() throws Exception {
         runTest(false);
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void echoWSSText() throws Exception {
         runTest(true);
     }
diff --git a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index a2f316eb6..81f8e3359 100644
--- a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -72,7 +72,7 @@ public void configure(WebSocketServletFactory factory) {
     }
 
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void testRedirectToWSResource() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
             final CountDownLatch latch = new CountDownLatch(1);
diff --git a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
index f48dad33b..ccc6bebde 100644
--- a/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
@@ -12,12 +12,10 @@
  */
 package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.testng.Assert.*;
 
-import java.net.ConnectException;
 import java.net.UnknownHostException;
-import java.nio.channels.UnresolvedAddressException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
@@ -39,7 +37,7 @@ public void configure(WebSocketServletFactory factory) {
         };
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onOpen() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -69,7 +67,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onEmptyListenerTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             WebSocket websocket = null;
@@ -82,19 +80,16 @@ public void onEmptyListenerTest() throws Exception {
         }
     }
 
-    @Test(timeOut = 60000, expectedExceptions = { ConnectException.class, UnresolvedAddressException.class, UnknownHostException.class })
+    @Test(groups = "standalone", timeOut = 60000, expectedExceptions = UnknownHostException.class)
     public void onFailureTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
             c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
         } catch (ExecutionException e) {
-            if (e.getCause() != null)
-                throw e.getCause();
-            else
-                throw e;
+            throw e.getCause();
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onTimeoutCloseTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -124,7 +119,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void onClose() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -156,7 +151,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void echoText() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(1);
@@ -193,7 +188,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void echoDoubleListenerText() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -252,7 +247,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test
+    @Test(groups = "standalone")
     public void echoTwoMessagesTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch latch = new CountDownLatch(2);
@@ -325,7 +320,7 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(groups = "standalone", timeOut = 60000)
     public void echoTextAndThenClose() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
             final CountDownLatch textLatch = new CountDownLatch(1);
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 3edf5151a..218cb9808 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -28,7 +28,7 @@
 
     /**
      * Returns a singleton instance of AsyncHttpClientRegistry
-     * @return
+     * @return the current instance
      */
     public static AsyncHttpClientRegistry getInstance() {
         if (_instance == null) {
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
index bfab690f4..d5b020bb5 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -67,7 +67,7 @@ public void tearDown() throws Exception {
      * @throws Exception 
      */
     // ================================================================================================================
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClient() throws Exception {
         try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
             Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
@@ -75,7 +75,7 @@ public void testGetAsyncHttpClient() throws Exception {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientConfig() throws Exception {
         try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
             Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
@@ -83,7 +83,7 @@ public void testGetAsyncHttpClientConfig() throws Exception {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientProvider() throws Exception {
         try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
             Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
@@ -98,14 +98,14 @@ public void testGetAsyncHttpClientProvider() throws Exception {
      * returned
      */
     // ===================================================================================================================================
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testFactoryWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
         Assert.assertTrue(AsyncHttpClientFactory.getAsyncHttpClient().getClass().equals(TestAsyncHttpClient.class));
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientConfigWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -113,7 +113,7 @@ public void testGetAsyncHttpClientConfigWithSystemProperty() {
         Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientProviderWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -128,7 +128,7 @@ public void testGetAsyncHttpClientProviderWithSystemProperty() {
      * AsyncHttpClientException is thrown.
      */
     // ===================================================================================================================================
-    @Test(groups = "fast", expectedExceptions = BadAsyncHttpClientException.class)
+    @Test(groups = "standalone", expectedExceptions = BadAsyncHttpClientException.class)
     public void testFactoryWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -136,7 +136,7 @@ public void testFactoryWithBadAsyncHttpClient() {
         Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -148,7 +148,7 @@ public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() {
         //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -166,7 +166,7 @@ public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() {
      * If the system property exists instantiate the class else if the class is
      * not found throw an AsyncHttpClientException.
      */
-    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
     public void testFactoryWithNonExistentAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -178,7 +178,7 @@ public void testFactoryWithNonExistentAsyncHttpClient() {
      * If property is specified but the class can’t be created or found for any
      * reason subsequent calls should throw an AsyncClientException.
      */
-    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
     public void testRepeatedCallsToBadAsyncHttpClient() {
         boolean exceptionCaught = false;
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
index 83a14e158..6fe6a3e38 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -48,7 +48,7 @@ public void tearDown() {
         System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testGetAndRegister() {
         AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
         Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
@@ -56,7 +56,7 @@ public void testGetAndRegister() {
         Assert.assertNotNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testDeRegister() {
         AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
         Assert.assertFalse(AsyncHttpClientRegistryImpl.getInstance().unregister(TEST_AHC));
@@ -65,7 +65,7 @@ public void testDeRegister() {
         Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC));
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testRegisterIfNew() {
         AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
         AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient();
@@ -78,7 +78,7 @@ public void testRegisterIfNew() {
         Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 1) == ahc);
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testClearAllInstances() {
         AsyncHttpClient ahc = AsyncHttpClientFactory.getAsyncHttpClient();
         AsyncHttpClient ahc2 = AsyncHttpClientFactory.getAsyncHttpClient();
@@ -94,14 +94,14 @@ public void testClearAllInstances() {
         Assert.assertNull(AsyncHttpClientRegistryImpl.getInstance().get(TEST_AHC + 3));
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testCustomAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
         AsyncHttpClientConfigHelper.reloadProperties();
         Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
     }
 
-    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
     public void testNonExistentAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
@@ -109,7 +109,7 @@ public void testNonExistentAsyncHttpClientRegistry() {
         Assert.fail("Should never have reached here");
     }
 
-    @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
+    @Test(groups = "standalone", expectedExceptions = AsyncHttpClientImplException.class)
     public void testBadAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
         AsyncHttpClientConfigHelper.reloadProperties();
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
index 15385b186..41c083fe5 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -18,6 +18,7 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SignatureCalculator;
 
@@ -110,4 +111,18 @@ public BoundRequestBuilder prepareRequest(Request request) {
         return null;
     }
 
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
index 2e46cfcb8..febee33bc 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -18,6 +18,7 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SignatureCalculator;
 
@@ -106,4 +107,19 @@ public BoundRequestBuilder prepareRequest(Request request) {
         return null;
     }
 
+    @Override
+    public BoundRequestBuilder prepareRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
+    @Override
+    public <T> ListenableFuture<T> executeRequest(RequestBuilder requestBuilder, AsyncHandler<T> handler) {
+        return null;
+    }
+
+    @Override
+    public ListenableFuture<Response> executeRequest(RequestBuilder requestBuilder) {
+        return null;
+    }
+
 }
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
index 72a5ee43d..188bfeef3 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -28,7 +28,7 @@
 
 public class AsyncHttpObservableTest {
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testToObservableNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
@@ -53,7 +53,7 @@ public BoundRequestBuilder call() {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testToObservableError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
@@ -78,7 +78,7 @@ public BoundRequestBuilder call() {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testObserveNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
@@ -103,7 +103,7 @@ public BoundRequestBuilder call() {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testObserveError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
@@ -128,7 +128,7 @@ public BoundRequestBuilder call() {
         }
     }
 
-    @Test(groups = "fast")
+    @Test(groups = "standalone")
     public void testObserveMultiple() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index 07d58fc96..3ea07836b 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -15,6 +15,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.ssl.SslContext;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -24,8 +25,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 
-import javax.net.ssl.SSLContext;
-
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
@@ -40,6 +39,7 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.SslEngineFactory;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
@@ -305,7 +305,7 @@ private RequestBuilder rebuildRequest(Request rb) {
             handler = new ResumableBodyConsumerAsyncHandler(length, handler);
         }
 
-        return asyncHttpClient().executeRequest(request, handler);
+        return getAsyncHttpClient().executeRequest(request, handler);
     }
 
     private AsyncHttpClient getAsyncHttpClient() {
@@ -546,8 +546,8 @@ public Builder setUserAgent(String userAgent) {
             return this;
         }
 
-        public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
-            configBuilder.setAllowPoolingConnections(allowPoolingConnections);
+        public Builder setKeepAlive(boolean allowPoolingConnections) {
+            configBuilder.setKeepAlive(allowPoolingConnections);
             return this;
         }
 
@@ -556,10 +556,15 @@ public Builder setThreadFactory(ThreadFactory threadFactory) {
             return this;
         }
 
-        public Builder setSSLContext(final SSLContext sslContext) {
+        public Builder setSslContext(SslContext sslContext) {
             configBuilder.setSslContext(sslContext);
             return this;
         }
+        
+        public Builder setSslEngineFactory(SslEngineFactory sslEngineFactory) {
+            configBuilder.setSslEngineFactory(sslEngineFactory);
+            return this;
+        }
 
         public Builder setRealm(Realm realm) {
             configBuilder.setRealm(realm);
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
index 3c9d2685a..9adb88d1e 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
@@ -48,7 +48,7 @@ public void tearDownGlobal() throws Exception {
         server2.stop();
     }
 
-    @Test(groups = { "online", "default_provider" })
+    @Test(groups = "online")
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
index d03dfdb77..f2ca7f76c 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncClientErrorBehaviourTest.java
@@ -34,7 +34,7 @@
  */
 public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
     
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testAccumulateErrorBody() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
                 .setUrl(getTargetUrl() + "/nonexistent")//
@@ -50,7 +50,7 @@ public void testAccumulateErrorBody() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testOmitErrorBody() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
                 .setUrl(getTargetUrl() + "/nonexistent")//
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
index eaeda0b39..c206a142d 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
@@ -37,7 +37,7 @@
 
     private final static String MY_MESSAGE = "my message";
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void inputStreamBodyConsumerTest() throws Exception {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
@@ -54,7 +54,7 @@ public void inputStreamBodyConsumerTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void stringBuilderBodyConsumerTest() throws Exception {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
@@ -72,7 +72,7 @@ public void stringBuilderBodyConsumerTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
@@ -89,7 +89,7 @@ public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
@@ -105,7 +105,7 @@ public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
     /**
      * See https://issues.sonatype.org/browse/AHC-5
      */
-    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    @Test(groups = "standalone", enabled = true)
     public void testPutZeroBytesFileTest() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
                 .setPooledConnectionIdleTimeout(100)//
@@ -127,7 +127,7 @@ public void testPutZeroBytesFileTest() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testDerive() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build();
         SimpleAsyncHttpClient derived = client.derive().build();
@@ -139,7 +139,7 @@ public void testDerive() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testDeriveOverrideURL() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
@@ -157,7 +157,7 @@ public void testDeriveOverrideURL() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testSimpleTransferListener() throws Exception {
 
         final List<Error> errors = Collections.synchronizedList(new ArrayList<Error>());
@@ -245,7 +245,7 @@ public void onBytesReceived(Uri uri, long amount, long current, long total) {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testNullUrl() throws Exception {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
@@ -253,7 +253,7 @@ public void testNullUrl() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testCloseDerivedValidMaster() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
             try (SimpleAsyncHttpClient derived = client.derive().build()) {
@@ -265,7 +265,7 @@ public void testCloseDerivedValidMaster() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = { IllegalStateException.class })
+    @Test(groups = "standalone", expectedExceptions = IllegalStateException.class)
     public void testCloseMasterInvalidDerived() throws Throwable {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
@@ -280,7 +280,7 @@ public void testCloseMasterInvalidDerived() throws Throwable {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMultiPartPut() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
             Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
@@ -301,7 +301,7 @@ public void testMultiPartPut() throws Exception {
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
+    @Test(groups = "standalone")
     public void testMultiPartPost() throws Exception {
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
             Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
diff --git a/pom.xml b/pom.xml
index e2f5a6c27..c752a3898 100644
--- a/pom.xml
+++ b/pom.xml
@@ -411,7 +411,7 @@
 		<slf4j.version>1.7.12</slf4j.version>
 		<logback.version>1.1.3</logback.version>
 		<log4j.version>1.2.17</log4j.version>
-		<testng.version>6.8.8</testng.version>
+		<testng.version>6.9.9</testng.version>
 		<jetty.version>9.2.11.v20150529</jetty.version>
 		<tomcat.version>6.0.29</tomcat.version>
 		<commons-io.version>2.4</commons-io.version>
