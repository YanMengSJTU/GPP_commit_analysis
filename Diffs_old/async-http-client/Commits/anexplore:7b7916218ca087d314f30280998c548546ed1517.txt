diff --git a/README.md b/README.md
index 487cf8ffc..fdf03f4a1 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,12 @@
 # Async Http Client [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.asynchttpclient/async-http-client/)
 
+## 修改
+### 2018-08-23
+* 为单个Request增加最大跳转次数参数
+* 修改跳转时Cookie策略，在没有CookieStore时仍然将Set-Cookie带入下次请求
+* 修改newNettyRequest方法将request.headers以及cookies中的cookie合并   
+
+------
 Follow [@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on Twitter.
 
 The AsyncHttpClient (AHC) library allows Java applications to easily execute HTTP requests and asynchronously process HTTP responses.
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index 121bb7165..0b4325bb5 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -17,6 +17,7 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
+import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
 import io.netty.handler.codec.http.cookie.Cookie;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Realm;
@@ -24,7 +25,6 @@
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.cookie.CookieStore;
-import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.request.NettyRequestSender;
@@ -39,9 +39,9 @@
 import static io.netty.handler.codec.http.HttpHeaderNames.*;
 import static org.asynchttpclient.util.HttpConstants.Methods.GET;
 import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
+import static org.asynchttpclient.util.HttpConstants.ExtrasHeaders.*;
 import static org.asynchttpclient.util.HttpUtils.followRedirect;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import static org.asynchttpclient.util.ThrowableUtil.unknownStackTrace;
 
 public class Redirect30xInterceptor {
 
@@ -59,14 +59,13 @@
   private final ChannelManager channelManager;
   private final AsyncHttpClientConfig config;
   private final NettyRequestSender requestSender;
-  private final MaxRedirectException maxRedirectException;
-
+  private final ClientCookieDecoder cookieDecoder;
+  
   Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
     this.channelManager = channelManager;
     this.config = config;
     this.requestSender = requestSender;
-    maxRedirectException = unknownStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()), Redirect30xInterceptor.class,
-            "exitAfterHandlingRedirect");
+    this.cookieDecoder = config.isUseLaxCookieEncoder() ? ClientCookieDecoder.LAX : ClientCookieDecoder.STRICT;
   }
 
   public boolean exitAfterHandlingRedirect(Channel channel,
@@ -77,9 +76,19 @@ public boolean exitAfterHandlingRedirect(Channel channel,
                                            Realm realm) throws Exception {
 
     if (followRedirect(config, request)) {
-      if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
-        throw maxRedirectException;
-
+      // Modify by @anexplore
+      // Add support for Refresh header, eg, Refresh: 5; https://www.google.com/
+      HttpHeaders responseHeaders = response.headers();
+      String location = responseHeaders.get(LOCATION);
+      if (hasRefreshHeader(response)) {
+        location = decodeRefreshUri(responseHeaders.get(REFRESH));
+      }
+      if (isNonEmpty(location)) {
+        return false;
+      }
+      int redirectCount = future.incrementAndGetCurrentRedirectCount();
+      if (request.getMaxRedirects() == null ? redirectCount > config.getMaxRedirects() : redirectCount > request.getMaxRedirects() ) {
+        return false;
       } else {
         // We must allow auth handling again.
         future.setInAuth(false);
@@ -97,6 +106,7 @@ public boolean exitAfterHandlingRedirect(Channel channel,
                 .setNameResolver(request.getNameResolver())
                 .setProxyServer(request.getProxyServer())
                 .setRealm(request.getRealm())
+                .setReadTimeout(request.getReadTimeout())
                 .setRequestTimeout(request.getRequestTimeout());
 
         if (keepBody) {
@@ -120,8 +130,6 @@ else if (request.getBodyGenerator() != null)
         final boolean initialConnectionKeepAlive = future.isKeepAlive();
         final Object initialPartitionKey = future.getPartitionKey();
 
-        HttpHeaders responseHeaders = response.headers();
-        String location = responseHeaders.get(LOCATION);
         Uri newUri = Uri.create(future.getUri(), location);
 
         LOGGER.debug("Redirecting to {}", newUri);
@@ -133,6 +141,14 @@ else if (request.getBodyGenerator() != null)
           if (!cookies.isEmpty())
             for (Cookie cookie : cookies)
               requestBuilder.addOrReplaceCookie(cookie);
+        } else {
+          // When CookieStore is null, propagate set-cookie. add by @anexplore
+          for (String cookieStr : responseHeaders.getAll(SET_COOKIE)) {
+            Cookie c = cookieDecoder.decode(cookieStr);
+            if (c != null) {
+              requestBuilder.addOrReplaceCookie(c);
+            }
+          }
         }
 
         boolean sameBase = request.getUri().isSameBase(newUri);
@@ -185,4 +201,29 @@ private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keep
     }
     return headers;
   }
+  
+  /**
+   * add by @anexplore
+   * @param request
+   * @return if has Refresh header
+   */
+  private boolean hasRefreshHeader(HttpResponse response) {
+    return !isNonEmpty(response.headers().get(REFRESH));
+  }
+  
+  /**
+   * add by @anexplore
+   * @param refresh
+   * @return refresh target uri
+   */
+  private String decodeRefreshUri(String refresh) {
+    if (isNonEmpty(refresh)) {
+      return null;
+    }
+    int eqPos = refresh.indexOf('=');
+    if (eqPos >= 0 && eqPos < refresh.length() - 1) {
+      return refresh.substring(eqPos + 1).trim();
+    }
+    return null;
+  }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 663ced6ce..3c88d3655 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -146,7 +146,12 @@ public NettyRequest newNettyRequest(Request request, boolean performConnectReque
       headers.set(request.getHeaders());
 
       if (isNonEmpty(request.getCookies())) {
-        headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
+        // merge cookies when cookie string exists both in request.headers and request.cookies by @anexplore
+        if (isNonEmpty(headers.get(COOKIE))) {
+          headers.set(COOKIE, cookieEncoder.encode(request.getCookies()) + "; " + headers.get(COOKIE));
+        } else {
+          headers.set(COOKIE, cookieEncoder.encode(request.getCookies()));
+        }
       }
 
       String userDefinedAcceptEncoding = headers.get(ACCEPT_ENCODING);
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
index e17681e6d..28ea5ebe6 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -15,6 +15,7 @@
 
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.util.AsciiString;
 
 public final class HttpConstants {
 
@@ -51,4 +52,11 @@ private Methods() {
     private ResponseStatusCodes() {
     }
   }
+  
+  public static final class ExtrasHeaders {
+    private ExtrasHeaders() {
+    }
+    
+    public static final AsciiString REFRESH = AsciiString.cached("refresh");
+  }
 }
