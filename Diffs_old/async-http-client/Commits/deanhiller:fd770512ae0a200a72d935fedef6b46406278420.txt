diff --git a/providers/channelmgr/lib/channelmgr.jar b/providers/channelmgr/lib/channelmgr.jar
new file mode 100644
index 000000000..db5b3b97c
Binary files /dev/null and b/providers/channelmgr/lib/channelmgr.jar differ
diff --git a/providers/channelmgr/pom.xml b/providers/channelmgr/pom.xml
new file mode 100644
index 000000000..1894a7678
--- /dev/null
+++ b/providers/channelmgr/pom.xml
@@ -0,0 +1,51 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>com.ning</groupId>
+        <artifactId>async-http-client-providers-parent</artifactId>
+        <version>1.8.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>com.ning</groupId>
+    <artifactId>async-http-client-channelmanager-provider</artifactId>
+    <name>Asynchronous Http Client ChannelManager Provider</name>
+    <version>1.8.0-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <description>
+        The Async Http Client ChannelManager Provider.
+    </description>
+
+    <dependencies>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty</artifactId>
+            <version>3.4.4.Final</version>
+            <exclusions>
+                <exclusion>
+                    <groupId>javax.servlet</groupId>
+                    <artifactId>servlet-api</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>commons-logging</groupId>
+                    <artifactId>commons-logging</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>org.slf4j</groupId>
+                    <artifactId>slf4j-api</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>log4j</groupId>
+                    <artifactId>log4j</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+<dependency>
+    <artifactId>channelmanager2</artifactId>
+    <groupId>org.playorm</groupId>
+    <version>2.1.0</version>
+</dependency>
+
+    </dependencies>
+
+</project>
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyChunkedInput.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyChunkedInput.java
new file mode 100644
index 000000000..7c0abf87f
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyChunkedInput.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.Body;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.handler.stream.ChunkedInput;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
+ */
+class BodyChunkedInput
+        implements ChunkedInput {
+
+    private final Body body;
+
+    private final int chunkSize = 1024 * 8;
+
+    private ByteBuffer nextChunk;
+
+    private static final ByteBuffer EOF = ByteBuffer.allocate(0);
+
+    private boolean endOfInput = false;
+
+    public BodyChunkedInput(Body body) {
+        if (body == null) {
+            throw new IllegalArgumentException("no body specified");
+        }
+        this.body = body;
+    }
+
+    private ByteBuffer peekNextChunk()
+            throws IOException {
+
+        if (nextChunk == null) {
+            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
+            long length = body.read(buffer);
+            if (length < 0) {
+                // Negative means this is finished
+                buffer.flip();
+                nextChunk = buffer;
+                endOfInput = true;
+            } else if (length == 0) {
+                // Zero means we didn't get anything this time, but may get next time
+                buffer.flip();
+                nextChunk = null;
+            } else {
+                buffer.flip();
+                nextChunk = buffer;
+            }
+        }
+        return nextChunk;
+    }
+
+    /**
+     * Having no next chunk does not necessarily means end of input, other chunks may arrive later
+     */
+    public boolean hasNextChunk() throws Exception {
+        return peekNextChunk() != null;
+    }
+
+    public Object nextChunk() throws Exception {
+        ByteBuffer buffer = peekNextChunk();
+        if (buffer == null || buffer == EOF) {
+            return null;
+        }
+        nextChunk = null;
+
+        return ChannelBuffers.wrappedBuffer(buffer);
+    }
+
+    public boolean isEndOfInput() throws Exception {
+        return endOfInput;
+    }
+
+    public void close() throws Exception {
+        body.close();
+    }
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyFileRegion.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyFileRegion.java
new file mode 100644
index 000000000..5edeab279
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/BodyFileRegion.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.RandomAccessBody;
+import org.jboss.netty.channel.FileRegion;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+/**
+ * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
+ */
+class BodyFileRegion
+        implements FileRegion {
+
+    private final RandomAccessBody body;
+
+    public BodyFileRegion(RandomAccessBody body) {
+        if (body == null) {
+            throw new IllegalArgumentException("no body specified");
+        }
+        this.body = body;
+    }
+
+    public long getPosition() {
+        return 0;
+    }
+
+    public long getCount() {
+        return body.getContentLength();
+    }
+
+    public long transferTo(WritableByteChannel target, long position)
+            throws IOException {
+        return body.transferTo(position, Long.MAX_VALUE, target);
+    }
+
+    public void releaseExternalResources() {
+        try {
+            body.close();
+        } catch (IOException e) {
+            // we tried
+        }
+    }
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/FeedableBodyGenerator.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/FeedableBodyGenerator.java
new file mode 100644
index 000000000..4e28bcd41
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/FeedableBodyGenerator.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+
+/**
+ * {@link BodyGenerator} which may return just part of the payload at the time
+ * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
+ * for finishing payload transferring asynchronously.
+ */
+public class FeedableBodyGenerator implements BodyGenerator {
+    private final static byte[] END_PADDING = "\r\n".getBytes();
+    private final static byte[] ZERO = "0".getBytes();
+    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
+    private final AtomicInteger queueSize = new AtomicInteger();
+    private FeedListener listener;
+
+    @Override
+    public Body createBody() throws IOException {
+        return new PushBody();
+    }
+
+    public void feed(final ByteBuffer buffer, final boolean isLast) throws IOException {
+        queue.offer(new BodyPart(buffer, isLast));
+        queueSize.incrementAndGet();
+        if (listener != null) {
+            listener.onContentAdded();
+        }
+    }
+
+    public static interface FeedListener {
+        public void onContentAdded();
+    }
+
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+
+    private final class PushBody implements Body {
+        private final int ONGOING = 0;
+        private final int CLOSING = 1;
+        private final int FINISHED = 2;
+
+        private int finishState = 0;
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+
+        @Override
+        public long read(final ByteBuffer buffer) throws IOException {
+            BodyPart nextPart = queue.peek();
+            if (nextPart == null) {
+                // Nothing in the queue
+                switch (finishState) {
+                case ONGOING:
+                    return 0;
+                case CLOSING:
+                    buffer.put(ZERO);
+                    buffer.put(END_PADDING);
+                    finishState = FINISHED;
+                    return buffer.position();
+                case FINISHED:
+                    buffer.put(END_PADDING);
+                    return -1;
+                }
+            }
+            int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
+            int size = Math.min(nextPart.buffer.remaining(), capacity);
+            buffer.put(Integer.toHexString(size).getBytes());
+            buffer.put(END_PADDING);
+            for (int i=0; i < size; i++) {
+              buffer.put(nextPart.buffer.get());
+            }
+            buffer.put(END_PADDING);
+            if (!nextPart.buffer.hasRemaining()) {
+                if (nextPart.isLast) {
+                    finishState = CLOSING;
+                }
+                queue.remove();
+            }
+            return size;
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+
+    }
+
+    private final static class BodyPart {
+        private final boolean isLast;
+        private final ByteBuffer buffer;
+
+        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
+            this.buffer = buffer;
+            this.isLast = isLast;
+        }
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java
new file mode 100644
index 000000000..c61412ea8
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java
@@ -0,0 +1,2474 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHandler.STATE;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.MaxRedirectException;
+import com.ning.http.client.PerRequestConfig;
+import com.ning.http.client.ProgressAsyncHandler;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.RandomAccessBody;
+import com.ning.http.client.Realm;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.filter.FilterContext;
+import com.ning.http.client.filter.FilterException;
+import com.ning.http.client.filter.IOExceptionFilter;
+import com.ning.http.client.filter.ResponseFilter;
+import com.ning.http.client.generators.InputStreamBodyGenerator;
+import com.ning.http.client.listener.TransferCompletionHandler;
+import com.ning.http.client.ntlm.NTLMEngine;
+import com.ning.http.client.ntlm.NTLMEngineException;
+import com.ning.http.client.providers.chanmgr.FeedableBodyGenerator.FeedListener;
+import com.ning.http.client.providers.chanmgr.spnego.SpnegoEngine;
+import com.ning.http.client.providers.chanmgr.util.CleanupChannelGroup;
+import com.ning.http.client.websocket.WebSocketUpgradeHandler;
+import com.ning.http.multipart.MultipartBody;
+import com.ning.http.multipart.MultipartRequestEntity;
+import com.ning.http.util.AsyncHttpProviderUtils;
+import com.ning.http.util.AuthenticatorUtils;
+import com.ning.http.util.ProxyUtils;
+import com.ning.http.util.SslUtils;
+import com.ning.http.util.UTF8UrlEncoder;
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBufferOutputStream;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureProgressListener;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelPipelineFactory;
+import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.DefaultChannelFuture;
+import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.FileRegion;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.oio.OioClientSocketChannelFactory;
+import org.jboss.netty.handler.codec.http.CookieEncoder;
+import org.jboss.netty.handler.codec.http.DefaultCookie;
+import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.HttpClientCodec;
+import org.jboss.netty.handler.codec.http.HttpContentCompressor;
+import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.jboss.netty.handler.stream.ChunkedFile;
+import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.net.ssl.SSLEngine;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.jboss.netty.channel.Channels.pipeline;
+
+public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
+    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
+    private final static String HTTP_HANDLER = "httpHandler";
+    protected final static String SSL_HANDLER = "sslHandler";
+    private final static String HTTPS = "https";
+    private final static String HTTP = "http";
+    private static final String WEBSOCKET = "ws";
+    private static final String WEBSOCKET_SSL = "wss";
+
+    private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
+    private final static Charset UTF8 = Charset.forName("UTF-8");
+
+    private final ClientBootstrap plainBootstrap;
+    private final ClientBootstrap secureBootstrap;
+    private final ClientBootstrap webSocketBootstrap;
+    private final ClientBootstrap secureWebSocketBootstrap;
+    private final static int MAX_BUFFERED_BYTES = 8192;
+    private final AsyncHttpClientConfig config;
+    private final AtomicBoolean isClose = new AtomicBoolean(false);
+    private final ClientSocketChannelFactory socketChannelFactory;
+
+    private final ChannelGroup openChannels = new
+            CleanupChannelGroup("asyncHttpClient") {
+                @Override
+                public boolean remove(Object o) {
+                    boolean removed = super.remove(o);
+                    if (removed && trackConnections) {
+                        freeConnections.release();
+                    }
+                    return removed;
+                }
+            };
+    private final ConnectionsPool<String, Channel> connectionsPool;
+    private Semaphore freeConnections = null;
+    private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
+    private boolean executeConnectAsync = true;
+    public static final ThreadLocal<Boolean> IN_IO_THREAD = new ThreadLocalBoolean();
+    private final boolean trackConnections;
+    private final boolean useRawUrl;
+    private final static NTLMEngine ntlmEngine = new NTLMEngine();
+    private final static SpnegoEngine spnegoEngine = new SpnegoEngine();
+    private final Protocol httpProtocol = new HttpProtocol();
+    private final Protocol webSocketProtocol = new WebSocketProtocol();
+
+    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
+
+        if (config.getAsyncHttpProviderConfig() != null
+                && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
+            asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
+        } else {
+            asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
+        }
+
+        if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO) != null) {
+            socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
+        } else {
+            ExecutorService e;
+            Object o = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE);
+            if (o != null && ExecutorService.class.isAssignableFrom(o.getClass())) {
+                e = ExecutorService.class.cast(o);
+            } else {
+                e = Executors.newCachedThreadPool();
+            }
+            int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
+            log.debug("Number of application's worker threads is {}", numWorkers);
+            socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
+        }
+        plainBootstrap = new ClientBootstrap(socketChannelFactory);
+        secureBootstrap = new ClientBootstrap(socketChannelFactory);
+        webSocketBootstrap = new ClientBootstrap(socketChannelFactory);
+        secureWebSocketBootstrap = new ClientBootstrap(socketChannelFactory);
+        configureNetty();
+
+        this.config = config;
+
+        // This is dangerous as we can't catch a wrong typed ConnectionsPool
+        ConnectionsPool<String, Channel> cp = (ConnectionsPool<String, Channel>) config.getConnectionsPool();
+        if (cp == null && config.getAllowPoolingConnection()) {
+            cp = new NettyConnectionsPool(this);
+        } else if (cp == null) {
+            cp = new NonConnectionsPool();
+        }
+        this.connectionsPool = cp;
+
+        if (config.getMaxTotalConnections() != -1) {
+            trackConnections = true;
+            freeConnections = new Semaphore(config.getMaxTotalConnections());
+        } else {
+            trackConnections = false;
+        }
+
+        useRawUrl = config.isUseRawUrl();
+    }
+
+    @Override
+    public String toString() {
+        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",
+                config.getMaxTotalConnections() - freeConnections.availablePermits(),
+                openChannels.toString(),
+                connectionsPool.toString());
+    }
+
+    void configureNetty() {
+        if (asyncHttpProviderConfig != null) {
+            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
+                plainBootstrap.setOption(entry.getKey(), entry.getValue());
+            }
+        }
+
+        plainBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
+
+                if (config.getRequestCompressionLevel() > 0) {
+                    pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
+                }
+
+                if (config.isCompressionEnabled()) {
+                    pipeline.addLast("inflater", new HttpContentDecompressor());
+                }
+                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        });
+        DefaultChannelFuture.setUseDeadLockChecker(false);
+
+        if (asyncHttpProviderConfig != null) {
+            Object value = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT);
+            if (value != null && Boolean.class.isAssignableFrom(value.getClass())) {
+                executeConnectAsync = Boolean.class.cast(value);
+            } else if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.DISABLE_NESTED_REQUEST) != null) {
+                DefaultChannelFuture.setUseDeadLockChecker(true);
+            }
+        }
+
+        webSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
+                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        });
+    }
+
+    void constructSSLPipeline(final NettyConnectListener<?> cl) {
+
+        secureBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                try {
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                } catch (Throwable ex) {
+                    abort(cl.future(), ex);
+                }
+
+                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
+
+                if (config.isCompressionEnabled()) {
+                    pipeline.addLast("inflater", new HttpContentDecompressor());
+                }
+                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+                return pipeline;
+            }
+        });
+
+        secureWebSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            /* @Override */
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+
+                try {
+                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
+                } catch (Throwable ex) {
+                    abort(cl.future(), ex);
+                }
+
+                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
+                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
+                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
+
+                return pipeline;
+            }
+        });
+
+        if (asyncHttpProviderConfig != null) {
+            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
+                secureBootstrap.setOption(entry.getKey(), entry.getValue());
+                secureWebSocketBootstrap.setOption(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+
+    private Channel lookupInCache(URI uri) {
+        final Channel channel = connectionsPool.poll(AsyncHttpProviderUtils.getBaseUrl(uri));
+
+        if (channel != null) {
+            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+
+            try {
+                // Always make sure the channel who got cached support the proper protocol. It could
+                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
+                // https.
+                return verifyChannelPipeline(channel, uri.getScheme());
+            } catch (Exception ex) {
+                log.debug(ex.getMessage(), ex);
+            }
+        }
+        return null;
+    }
+
+    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
+        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
+        if (sslEngine == null) {
+            sslEngine = SslUtils.getSSLEngine();
+        }
+        return sslEngine;
+    }
+
+    private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
+
+        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+            channel.getPipeline().remove(SSL_HANDLER);
+        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+            return channel;
+        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
+            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+        }
+        return channel;
+    }
+
+    protected final <T> void writeRequest(final Channel channel,
+                                          final AsyncHttpClientConfig config,
+                                          final NettyResponseFuture<T> future,
+                                          final HttpRequest nettyRequest) {
+        try {
+            /**
+             * If the channel is dead because it was pooled and the remote server decided to close it,
+             * we just let it go and the closeChannel do it's work.
+             */
+            if (!channel.isOpen() || !channel.isConnected()) {
+                return;
+            }
+
+            Body body = null;
+            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+                BodyGenerator bg = future.getRequest().getBodyGenerator();
+                if (bg != null) {
+                    // Netty issue with chunking.
+                    if (InputStreamBodyGenerator.class.isAssignableFrom(bg.getClass())) {
+                        InputStreamBodyGenerator.class.cast(bg).patchNettyChunkingIssue(true);
+                    }
+
+                    try {
+                        body = bg.createBody();
+                    } catch (IOException ex) {
+                        throw new IllegalStateException(ex);
+                    }
+                    long length = body.getContentLength();
+                    if (length >= 0) {
+                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, length);
+                    } else {
+                        nettyRequest.setHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+                    }
+                } else {
+                    body = null;
+                }
+            }
+
+            if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
+
+                FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+                for (String s : future.getNettyRequest().getHeaderNames()) {
+                    for (String header : future.getNettyRequest().getHeaders(s)) {
+                        h.add(s, header);
+                    }
+                }
+
+                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(
+                        new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
+            }
+
+            // Leave it to true.
+            if (future.getAndSetWriteHeaders(true)) {
+                try {
+                    channel.write(nettyRequest).addListener(new ProgressListener(true, future.getAsyncHandler(), future));
+                } catch (Throwable cause) {
+                    log.debug(cause.getMessage(), cause);
+                    try {
+                        channel.close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                }
+            }
+
+            if (future.getAndSetWriteBody(true)) {
+                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+
+                    if (future.getRequest().getFile() != null) {
+                        final File file = future.getRequest().getFile();
+                        long fileLength = 0;
+                        final RandomAccessFile raf = new RandomAccessFile(file, "r");
+
+                        try {
+                            fileLength = raf.length();
+
+                            ChannelFuture writeFuture;
+                            if (channel.getPipeline().get(SslHandler.class) != null) {
+                                writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
+                            } else {
+                                final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
+                                writeFuture = channel.write(region);
+                            }
+                            writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future));
+                        } catch (IOException ex) {
+                            if (raf != null) {
+                                try {
+                                    raf.close();
+                                } catch (IOException e) {
+                                }
+                            }
+                            throw ex;
+                        }
+                    } else if (body != null || future.getRequest().getParts() != null) {
+                        /**
+                         * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
+                         */
+                        if (future.getRequest().getParts() != null) {
+                            String boundary = future.getNettyRequest().getHeader("Content-Type");
+                            String length = future.getNettyRequest().getHeader("Content-Length");
+                            body = new MultipartBody(future.getRequest().getParts(), boundary, length);
+                        }
+
+                        ChannelFuture writeFuture;
+                        if (channel.getPipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
+                            BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
+                            writeFuture = channel.write(bodyFileRegion);
+                        } else {
+                            BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
+                            BodyGenerator bg = future.getRequest().getBodyGenerator();
+                                if (bg instanceof FeedableBodyGenerator) {
+                                    ((FeedableBodyGenerator)bg).setListener(new FeedListener() {
+                                        @Override public void onContentAdded() {
+                                            channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                                        }
+                                    });
+                                }
+                            writeFuture = channel.write(bodyChunkedInput);
+                        }
+
+                        final Body b = body;
+                        writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
+                            public void operationComplete(ChannelFuture cf) {
+                                try {
+                                    b.close();
+                                } catch (IOException e) {
+                                    log.warn("Failed to close request body: {}", e.getMessage(), e);
+                                }
+                                super.operationComplete(cf);
+                            }
+                        });
+                    }
+                }
+            }
+        } catch (Throwable ioe) {
+            try {
+                channel.close();
+            } catch (RuntimeException ex) {
+                log.debug(ex.getMessage(), ex);
+            }
+        }
+
+        try {
+            future.touch();
+            int delay = requestTimeout(config, future.getRequest().getPerRequestConfig());
+            if (delay != -1 && !future.isDone() && !future.isCancelled()) {
+                ReaperFuture reaperFuture = new ReaperFuture(future);
+                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, delay, TimeUnit.MILLISECONDS);
+                reaperFuture.setScheduledFuture(scheduledFuture);
+                future.setReaperFuture(reaperFuture);
+            }
+        } catch (RejectedExecutionException ex) {
+            abort(future, ex);
+        }
+
+    }
+
+    private static boolean isProxyServer(AsyncHttpClientConfig config, Request request) {
+        return request.getProxyServer() != null || config.getProxyServer() != null;
+    }
+
+    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
+                                                    boolean allowConnect, ChannelBuffer buffer) throws IOException {
+
+        String method = request.getMethod();
+        if (allowConnect && (isProxyServer(config, request) && isSecure(uri))) {
+            method = HttpMethod.CONNECT.toString();
+        }
+        return construct(config, request, new HttpMethod(method), uri, buffer);
+    }
+
+    private static HttpRequest construct(AsyncHttpClientConfig config,
+                                         Request request,
+                                         HttpMethod m,
+                                         URI uri,
+                                         ChannelBuffer buffer) throws IOException {
+
+        String host = AsyncHttpProviderUtils.getHost(uri);
+        boolean webSocket = isWebSocket(uri);
+
+        if (request.getVirtualHost() != null) {
+            host = request.getVirtualHost();
+        }
+
+        HttpRequest nettyRequest;
+        if (m.equals(HttpMethod.CONNECT)) {
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
+        } else {
+            StringBuilder path = null;
+            if (isProxyServer(config, request))
+                path = new StringBuilder(uri.toString());
+            else {
+                path = new StringBuilder(uri.getRawPath());
+                if (uri.getQuery() != null) {
+                    path.append("?").append(uri.getRawQuery());
+                }
+            }
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path.toString());
+        }
+
+        if (webSocket) {
+            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
+            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
+            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":"
+                    + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
+            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
+            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
+        }
+
+        if (host != null) {
+            if (uri.getPort() == -1) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else if (request.getVirtualHost() != null) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+            }
+        } else {
+            host = "127.0.0.1";
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            FluentCaseInsensitiveStringsMap h = request.getHeaders();
+            if (h != null) {
+                for (String name : h.keySet()) {
+                    if (!"host".equalsIgnoreCase(name)) {
+                        for (String value : h.get(name)) {
+                            nettyRequest.addHeader(name, value);
+                        }
+                    }
+                }
+            }
+
+            if (config.isCompressionEnabled()) {
+                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+            }
+        } else {
+            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+            if (auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM")) {
+                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
+            }
+        }
+        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+
+            String domain = realm.getNtlmDomain();
+            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
+                domain = proxyServer.getNtlmDomain();
+            }
+
+            String authHost = realm.getNtlmHost();
+            if (proxyServer != null && proxyServer.getHost() != null) {
+                host = proxyServer.getHost();
+            }
+
+            switch (realm.getAuthScheme()) {
+                case BASIC:
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                            AuthenticatorUtils.computeBasicAuthentication(realm));
+                    break;
+                case DIGEST:
+                    if (realm.getNonce() != null && !realm.getNonce().equals("")) {
+                        try {
+                            nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                                    AuthenticatorUtils.computeDigestAuthentication(realm));
+                        } catch (NoSuchAlgorithmException e) {
+                            throw new SecurityException(e);
+                        }
+                    }
+                    break;
+                case NTLM:
+                    try {
+                        String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
+                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
+                    } catch (NTLMEngineException e) {
+                        IOException ie = new IOException();
+                        ie.initCause(e);
+                        throw ie;
+                    }
+                    break;
+                case KERBEROS:
+                case SPNEGO:
+                    String challengeHeader = null;
+                    String server = proxyServer == null ? host : proxyServer.getHost();
+                    try {
+                        challengeHeader = spnegoEngine.generateToken(server);
+                    } catch (Throwable e) {
+                        IOException ie = new IOException();
+                        ie.initCause(e);
+                        throw ie;
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+                    break;
+                case NONE:
+                    break;
+                default:
+                    throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
+            }
+        }
+
+        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
+            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, "keep-alive");
+        }
+
+        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
+        if (!avoidProxy) {
+            if (!request.getHeaders().containsKey("Proxy-Connection")) {
+                nettyRequest.setHeader("Proxy-Connection", "keep-alive");
+            }
+
+            if (proxyServer.getPrincipal() != null) {
+                if (proxyServer.getNtlmDomain() != null && proxyServer.getNtlmDomain().length() > 0) {
+
+                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+                    if (!(auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM"))) {
+                        try {
+                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
+                                    proxyServer.getHost());
+                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
+                        } catch (NTLMEngineException e) {
+                            IOException ie = new IOException();
+                            ie.initCause(e);
+                            throw ie;
+                        }
+                    }
+                } else {
+                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION,
+                            AuthenticatorUtils.computeBasicAuthentication(proxyServer));
+                }
+            }
+        }
+
+        // Add default accept headers.
+        if (request.getHeaders().getFirstValue("Accept") == null) {
+            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
+        }
+
+        if (request.getHeaders().getFirstValue("User-Agent") != null) {
+            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
+        } else if (config.getUserAgent() != null) {
+            nettyRequest.setHeader("User-Agent", config.getUserAgent());
+        } else {
+            nettyRequest.setHeader("User-Agent",
+                         AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class,
+                                                                   config));
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            if (request.getCookies() != null && !request.getCookies().isEmpty()) {
+                CookieEncoder httpCookieEncoder = new CookieEncoder(false);
+                Iterator<Cookie> ic = request.getCookies().iterator();
+                Cookie c;
+                org.jboss.netty.handler.codec.http.Cookie cookie;
+                while (ic.hasNext()) {
+                    c = ic.next();
+                    cookie = new DefaultCookie(c.getName(), c.getValue());
+                    cookie.setPath(c.getPath());
+                    cookie.setMaxAge(c.getMaxAge());
+                    cookie.setDomain(c.getDomain());
+                    httpCookieEncoder.addCookie(cookie);
+                }
+                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
+            }
+
+            String reqType = request.getMethod();
+            if (!"GET".equals(reqType) && !"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
+
+                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
+
+                // We already have processed the body.
+                if (buffer != null && buffer.writerIndex() != 0) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
+                    nettyRequest.setContent(buffer);
+                } else if (request.getByteData() != null) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
+                } else if (request.getStringData() != null) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
+                } else if (request.getStreamData() != null) {
+                    int[] lengthWrapper = new int[1];
+                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
+                    int length = lengthWrapper[0];
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
+                } else if (request.getParams() != null && !request.getParams().isEmpty()) {
+                    StringBuilder sb = new StringBuilder();
+                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
+                        final String key = paramEntry.getKey();
+                        for (final String value : paramEntry.getValue()) {
+                            if (sb.length() > 0) {
+                                sb.append("&");
+                            }
+                            UTF8UrlEncoder.appendEncoded(sb, key);
+                            sb.append("=");
+                            UTF8UrlEncoder.appendEncoded(sb, value);
+                        }
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
+
+                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
+                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
+                    }
+
+                } else if (request.getParts() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
+
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
+
+                    /**
+                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
+                     */
+
+                    if (isSecure(uri)) {
+                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                        mre.writeRequest(new ChannelBufferOutputStream(b));
+                        nettyRequest.setContent(b);
+                    }
+                } else if (request.getEntityWriter() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
+                    nettyRequest.setContent(b);
+                } else if (request.getFile() != null) {
+                    File file = request.getFile();
+                    if (!file.isFile()) {
+                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
+                }
+            }
+        }
+        return nettyRequest;
+    }
+
+    public void close() {
+        isClose.set(true);
+        try {
+            connectionsPool.destroy();
+            openChannels.close();
+
+            for (Channel channel : openChannels) {
+                ChannelHandlerContext ctx = channel.getPipeline().getContext(NettyAsyncHttpProvider.class);
+                if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+                    future.setReaperFuture(null);
+                }
+            }
+
+            config.executorService().shutdown();
+            config.reaper().shutdown();
+            socketChannelFactory.releaseExternalResources();
+            plainBootstrap.releaseExternalResources();
+            secureBootstrap.releaseExternalResources();
+            webSocketBootstrap.releaseExternalResources();
+            secureWebSocketBootstrap.releaseExternalResources();
+        } catch (Throwable t) {
+            log.warn("Unexpected error on close", t);
+        }
+    }
+
+    /* @Override */
+
+    public Response prepareResponse(final HttpResponseStatus status,
+                                    final HttpResponseHeaders headers,
+                                    final List<HttpResponseBodyPart> bodyParts) {
+        return new NettyResponse(status, headers, bodyParts);
+    }
+
+    /* @Override */
+
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
+        return doConnect(request, asyncHandler, null, true, executeConnectAsync, false);
+    }
+
+    private <T> void execute(final Request request, final NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
+        doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
+    }
+
+    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f,
+                                              boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
+
+        if (isClose.get()) {
+            throw new IOException("Closed");
+        }
+
+        if (request.getUrl().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler)) {
+            throw new IOException("WebSocket method must be a GET");
+        }
+
+        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        String requestUrl;
+        if (useRawUrl) {
+            requestUrl = request.getRawUrl();
+        } else {
+            requestUrl = request.getUrl();
+        }
+        URI uri = AsyncHttpProviderUtils.createUri(requestUrl);
+        Channel channel = null;
+
+        if (useCache) {
+            if (f != null && f.reuseChannel() && f.channel() != null) {
+                channel = f.channel();
+            } else {
+                channel = lookupInCache(uri);
+            }
+        }
+
+        ChannelBuffer bufferedBytes = null;
+        if (f != null && f.getRequest().getFile() == null &&
+                !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
+            bufferedBytes = f.getNettyRequest().getContent();
+        }
+
+        boolean useSSl = isSecure(uri) && proxyServer == null;
+        if (channel != null && channel.isOpen() && channel.isConnected()) {
+            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes);
+
+            if (f == null) {
+                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this);
+            } else {
+                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes);
+                f.setNettyRequest(nettyRequest);
+            }
+            f.setState(NettyResponseFuture.STATE.POOLED);
+            f.attachChannel(channel, false);
+
+            log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
+
+            try {
+                writeRequest(channel, config, f, nettyRequest);
+            } catch (Exception ex) {
+                log.debug("writeRequest failure", ex);
+                if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
+                    log.debug("SSLEngine failure", ex);
+                    f = null;
+                } else {
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        log.warn("doConnect.writeRequest()", t);
+                    }
+                    IOException ioe = new IOException(ex.getMessage());
+                    ioe.initCause(ex);
+                    throw ioe;
+                }
+            }
+            return f;
+        }
+
+        // Do not throw an exception when we need an extra connection for a redirect.
+        if (!reclaimCache && !connectionsPool.canCacheConnection()) {
+            IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
+            try {
+                asyncHandler.onThrowable(ex);
+            } catch (Throwable t) {
+                log.warn("!connectionsPool.canCacheConnection()", t);
+            }
+            throw ex;
+        }
+
+        boolean acquiredConnection = false;
+
+        if (trackConnections) {
+            if (!reclaimCache) {
+                if (!freeConnections.tryAcquire()) {
+                    IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        log.warn("!connectionsPool.canCacheConnection()", t);
+                    }
+                    throw ex;
+                } else {
+                    acquiredConnection = true;
+                }
+            }
+        }
+
+        NettyConnectListener<T> c = new NettyConnectListener.Builder<T>(config, request, asyncHandler, f, this, bufferedBytes).build(uri);
+        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
+
+        if (useSSl) {
+            constructSSLPipeline(c);
+        }
+
+        ChannelFuture channelFuture;
+        ClientBootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
+        bootstrap.setOption("connectTimeoutMillis", config.getConnectionTimeoutInMs());
+
+        // Do no enable this with win.
+        if (System.getProperty("os.name").toLowerCase().indexOf("win") == -1) {
+            bootstrap.setOption("reuseAddress", asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.REUSE_ADDRESS));
+        }
+
+        try {
+            InetSocketAddress remoteAddress;
+            if (request.getInetAddress() != null) {
+                remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
+            } else if (proxyServer == null || avoidProxy) {
+                remoteAddress = new InetSocketAddress(AsyncHttpProviderUtils.getHost(uri), AsyncHttpProviderUtils.getPort(uri));
+            } else {
+                remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
+            }
+
+            if(request.getLocalAddress() != null){
+                channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
+            }else{
+                channelFuture = bootstrap.connect(remoteAddress);
+            }
+
+        } catch (Throwable t) {
+            if (acquiredConnection) {
+                freeConnections.release();
+            }
+            abort(c.future(), t.getCause() == null ? t : t.getCause());
+            return c.future();
+        }
+
+        boolean directInvokation = true;
+        if (IN_IO_THREAD.get() && DefaultChannelFuture.isUseDeadLockChecker()) {
+            directInvokation = false;
+        }
+
+        if (directInvokation && !asyncConnect && request.getFile() == null) {
+            int timeOut = config.getConnectionTimeoutInMs() > 0 ? config.getConnectionTimeoutInMs() : Integer.MAX_VALUE;
+            if (!channelFuture.awaitUninterruptibly(timeOut, TimeUnit.MILLISECONDS)) {
+                if (acquiredConnection) {
+                    freeConnections.release();
+                }
+                channelFuture.cancel();
+                abort(c.future(), new ConnectException(String.format("Connect operation to %s timeout %s", uri, timeOut)));
+            }
+
+            try {
+                c.operationComplete(channelFuture);
+            } catch (Exception e) {
+                if (acquiredConnection) {
+                    freeConnections.release();
+                }
+                IOException ioe = new IOException(e.getMessage());
+                ioe.initCause(e);
+                try {
+                    asyncHandler.onThrowable(ioe);
+                } catch (Throwable t) {
+                    log.warn("c.operationComplete()", t);
+                }
+                throw ioe;
+            }
+        } else {
+            channelFuture.addListener(c);
+        }
+
+        log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
+
+        if (!c.future().isCancelled() || !c.future().isDone()) {
+            openChannels.add(channelFuture.getChannel());
+            c.future().attachChannel(channelFuture.getChannel(), false);
+        }
+        return c.future();
+    }
+
+    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
+        int result;
+        if (perRequestConfig != null) {
+            int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
+            result = (prRequestTimeout != 0 ? prRequestTimeout : config.getRequestTimeoutInMs());
+        } else {
+            result = config.getRequestTimeoutInMs();
+        }
+        return result;
+    }
+
+    private void closeChannel(final ChannelHandlerContext ctx) {
+        connectionsPool.removeAll(ctx.getChannel());
+        finishChannel(ctx);
+    }
+
+    private void finishChannel(final ChannelHandlerContext ctx) {
+        ctx.setAttachment(new DiscardEvent());
+
+        // The channel may have already been removed if a timeout occurred, and this method may be called just after.
+        if (ctx.getChannel() == null) {
+            return;
+        }
+
+        log.debug("Closing Channel {} ", ctx.getChannel());
+
+
+        try {
+            ctx.getChannel().close();
+        } catch (Throwable t) {
+            log.debug("Error closing a connection", t);
+        }
+
+        if (ctx.getChannel() != null) {
+            openChannels.remove(ctx.getChannel());
+        }
+
+    }
+
+    @Override
+    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+        //call super to reset the read timeout
+        super.messageReceived(ctx, e);
+        IN_IO_THREAD.set(Boolean.TRUE);
+        if (ctx.getAttachment() == null) {
+            log.debug("ChannelHandlerContext wasn't having any attachment");
+        }
+
+        if (ctx.getAttachment() instanceof DiscardEvent) {
+            return;
+        } else if (ctx.getAttachment() instanceof AsyncCallable) {
+            if (e.getMessage() instanceof HttpChunk) {
+                HttpChunk chunk = (HttpChunk) e.getMessage();
+                if (chunk.isLast()) {
+                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+                    ac.call();
+                } else {
+                    return;
+                }
+            } else {
+                AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+                ac.call();
+            }
+            ctx.setAttachment(new DiscardEvent());
+            return;
+        } else if (!(ctx.getAttachment() instanceof NettyResponseFuture<?>)) {
+            try {
+                ctx.getChannel().close();
+            } catch (Throwable t) {
+                log.trace("Closing an orphan channel {}", ctx.getChannel());
+            }
+            return;
+        }
+
+        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+        p.handle(ctx, e);
+    }
+
+    private Realm kerberosChallenge(List<String> proxyAuth,
+                                    Request request,
+                                    ProxyServer proxyServer,
+                                    FluentCaseInsensitiveStringsMap headers,
+                                    Realm realm,
+                                    NettyResponseFuture<?> future) throws NTLMEngineException {
+
+        URI uri = URI.create(request.getUrl());
+        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
+        String server = proxyServer == null ? host : proxyServer.getHost();
+        try {
+            String challengeHeader = spnegoEngine.generateToken(server);
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            Realm.RealmBuilder realmBuilder;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+            }
+            return realmBuilder.setUri(uri.getPath())
+                    .setMethodName(request.getMethod())
+                    .setScheme(Realm.AuthScheme.KERBEROS)
+                    .build();
+        } catch (Throwable throwable) {
+            if (proxyAuth.contains("NTLM")) {
+                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+            }
+            abort(future, throwable);
+            return null;
+        }
+    }
+
+    private Realm ntlmChallenge(List<String> wwwAuth,
+                                Request request,
+                                ProxyServer proxyServer,
+                                FluentCaseInsensitiveStringsMap headers,
+                                Realm realm,
+                                NettyResponseFuture<?> future) throws NTLMEngineException {
+
+        boolean useRealm = (proxyServer == null && realm != null);
+
+        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
+        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
+        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
+        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
+
+        Realm newRealm;
+        if (realm != null && !realm.isNtlmMessageType2Received()) {
+            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
+
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
+                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setMethodName(request.getMethod())
+                    .setNtlmMessageType2Received(true)
+                    .build();
+            future.getAndSetAuth(false);
+        } else {
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+
+            if (wwwAuth.get(0).startsWith("NTLM ")) {
+                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+                String challengeHeader = ntlmEngine.generateType3Msg(principal, password,
+                        ntlmDomain, ntlmHost, serverChallenge);
+
+                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            }
+
+            Realm.RealmBuilder realmBuilder;
+            Realm.AuthScheme authScheme;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+                authScheme = realm.getAuthScheme();
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+                authScheme = Realm.AuthScheme.NTLM;
+            }
+            newRealm = realmBuilder.setScheme(authScheme)
+                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setMethodName(request.getMethod())
+                    .build();
+        }
+
+        return newRealm;
+    }
+
+    private Realm ntlmProxyChallenge(List<String> wwwAuth,
+                                     Request request,
+                                     ProxyServer proxyServer,
+                                     FluentCaseInsensitiveStringsMap headers,
+                                     Realm realm,
+                                     NettyResponseFuture<?> future) throws NTLMEngineException {
+        future.getAndSetAuth(false);
+        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
+
+        if (wwwAuth.get(0).startsWith("NTLM ")) {
+            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(),
+                    proxyServer.getPassword(),
+                    proxyServer.getNtlmDomain(),
+                    proxyServer.getHost(),
+                    serverChallenge);
+            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+        }
+        Realm newRealm;
+        Realm.RealmBuilder realmBuilder;
+        if (realm != null) {
+            realmBuilder = new Realm.RealmBuilder().clone(realm);
+        } else {
+            realmBuilder = new Realm.RealmBuilder();
+        }
+        newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
+                .setUri(URI.create(request.getUrl()).getPath())
+                .setMethodName(request.getMethod())
+                .build();
+
+        return newRealm;
+    }
+
+    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final boolean keepAlive, final URI uri) {
+        ctx.setAttachment(new AsyncCallable(future) {
+            public Object call() throws Exception {
+                if (keepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(uri), ctx.getChannel())) {
+                    return null;
+                }
+
+                finishChannel(ctx);
+                return null;
+            }
+
+            @Override
+            public String toString() {
+                return String.format("Draining task for channel %s", ctx.getChannel());
+            }
+        });
+    }
+
+    private FilterContext handleIoException(FilterContext fc, NettyResponseFuture<?> future) {
+        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                if (fc == null) {
+                    throw new NullPointerException("FilterContext is null");
+                }
+            } catch (FilterException efe) {
+                abort(future, efe);
+            }
+        }
+        return fc;
+    }
+
+    private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, HttpResponse response, ChannelHandlerContext ctx) throws IOException {
+        final Request newRequest = fc.getRequest();
+        future.setAsyncHandler(fc.getAsyncHandler());
+        future.setState(NettyResponseFuture.STATE.NEW);
+        future.touch();
+
+        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+        nextRequest(newRequest, future);
+        return;
+    }
+
+    private List<String> getAuthorizationToken(List<Entry<String, String>> list, String headerAuth) {
+        ArrayList<String> l = new ArrayList<String>();
+        for (Entry<String, String> e : list) {
+            if (e.getKey().equalsIgnoreCase(headerAuth)) {
+                l.add(e.getValue().trim());
+            }
+        }
+        return l;
+    }
+
+    private void nextRequest(final Request request, final NettyResponseFuture<?> future) throws IOException {
+        nextRequest(request, future, true);
+    }
+
+    private void nextRequest(final Request request, final NettyResponseFuture<?> future, final boolean useCache) throws IOException {
+        execute(request, future, useCache, true, true);
+    }
+
+    private void abort(NettyResponseFuture<?> future, Throwable t) {
+        Channel channel = future.channel();
+        if (channel != null && openChannels.contains(channel)) {
+            closeChannel(channel.getPipeline().getContext(NettyAsyncHttpProvider.class));
+            openChannels.remove(channel);
+        }
+
+        if (!future.isCancelled() && !future.isDone()) {
+            log.debug("Aborting Future {}\n", future);
+            log.debug(t.getMessage(), t);
+        }
+
+        future.abort(t);
+    }
+
+    private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOException, GeneralSecurityException {
+        if (p.get(HTTP_HANDLER) != null) {
+            p.remove(HTTP_HANDLER);
+        }
+
+        if (isSecure(scheme)) {
+            if (p.get(SSL_HANDLER) == null) {
+                p.addFirst(HTTP_HANDLER, new HttpClientCodec());
+                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+            } else {
+                p.addAfter(SSL_HANDLER, HTTP_HANDLER, new HttpClientCodec());
+            }
+
+        } else {
+            p.addFirst(HTTP_HANDLER, new HttpClientCodec());
+        }
+    }
+
+    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
+
+        if (isClose.get()) {
+            return;
+        }
+
+        connectionsPool.removeAll(ctx.getChannel());
+        try {
+            super.channelClosed(ctx, e);
+        } catch (Exception ex) {
+            log.trace("super.channelClosed", ex);
+        }
+
+        log.debug("Channel Closed: {} with attachment {}", e.getChannel(), ctx.getAttachment());
+
+        if (ctx.getAttachment() instanceof AsyncCallable) {
+            AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
+            ctx.setAttachment(ac.future());
+            ac.call();
+            return;
+        }
+
+        if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+            future.touch();
+
+            if (config.getIOExceptionFilters().size() > 0) {
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
+                        .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                fc = handleIoException(fc, future);
+
+                if (fc.replayRequest() && !future.cannotBeReplay()) {
+                    replayRequest(future, fc, null, ctx);
+                    return;
+                }
+            }
+
+            Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+            p.onClose(ctx, e);
+
+            if (future != null && !future.isDone() && !future.isCancelled()) {
+                if (!remotelyClosed(ctx.getChannel(), future)) {
+                    abort(future, new IOException("Remotely Closed " + ctx.getChannel()));
+                }
+            } else {
+                closeChannel(ctx);
+            }
+        }
+    }
+
+    protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future) {
+
+        if (isClose.get()) {
+            return false;
+        }
+
+        connectionsPool.removeAll(channel);
+
+        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null
+                && NettyResponseFuture.class.isAssignableFrom(
+                channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
+            future = (NettyResponseFuture<?>)
+                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+        }
+
+        if (future == null || future.cannotBeReplay()) {
+            log.debug("Unable to recover future {}\n", future);
+            return false;
+        }
+
+        future.setState(NettyResponseFuture.STATE.RECONNECTED);
+        future.getAndSetStatusReceived(false);
+
+        log.debug("Trying to recover request {}\n", future.getNettyRequest());
+
+        try {
+            nextRequest(future.getRequest(), future);
+            return true;
+        } catch (IOException iox) {
+            future.setState(NettyResponseFuture.STATE.CLOSED);
+            future.abort(iox);
+            log.error("Remotely Closed, unable to recover", iox);
+        }
+        return false;
+    }
+
+    private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx) throws MalformedURLException {
+        // We need to make sure everything is OK before adding the connection back to the pool.
+        try {
+            future.done(null);
+        } catch (Throwable t) {
+            // Never propagate exception once we know we are done.
+            log.debug(t.getMessage(), t);
+        }
+
+        if (!future.getKeepAlive() || !ctx.getChannel().isReadable()) {
+            closeChannel(ctx);
+        }
+    }
+
+    private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
+        if (lastValidChunk && future.getKeepAlive()) {
+            drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+        } else {
+            if (future.getKeepAlive() && ctx.getChannel().isReadable() &&
+                    connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(future.getURI()), ctx.getChannel())) {
+                markAsDone(future, ctx);
+                return;
+            }
+            finishChannel(ctx);
+        }
+        markAsDone(future, ctx);
+    }
+
+    private final boolean updateStatusAndInterrupt(AsyncHandler<?> handler, HttpResponseStatus c) throws Exception {
+        return handler.onStatusReceived(c) != STATE.CONTINUE;
+    }
+
+    private final boolean updateHeadersAndInterrupt(AsyncHandler<?> handler, HttpResponseHeaders c) throws Exception {
+        return handler.onHeadersReceived(c) != STATE.CONTINUE;
+    }
+
+    private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart c) throws Exception {
+        boolean state = handler.onBodyPartReceived(c) != STATE.CONTINUE;
+        if (c.closeUnderlyingConnection()) {
+            future.setKeepAlive(false);
+        }
+        return state;
+    }
+
+    //Simple marker for stopping publishing bytes.
+
+    final static class DiscardEvent {
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
+            throws Exception {
+        Channel channel = e.getChannel();
+        Throwable cause = e.getCause();
+        NettyResponseFuture<?> future = null;
+
+        /** Issue 81
+        if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) {
+            return;
+        }
+        */
+        if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
+            return;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Unexpected I/O exception on channel {}", channel, cause);
+        }
+
+        try {
+
+            if (cause != null && ClosedChannelException.class.isAssignableFrom(cause.getClass())) {
+                return;
+            }
+
+            if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) ctx.getAttachment();
+                future.attachChannel(null, false);
+                future.touch();
+
+                if (IOException.class.isAssignableFrom(cause.getClass())) {
+
+                    if (config.getIOExceptionFilters().size() > 0) {
+                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
+                                .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
+                        fc = handleIoException(fc, future);
+
+                        if (fc.replayRequest()) {
+                            replayRequest(future, fc, null, ctx);
+                            return;
+                        }
+                    } else {
+                        // Close the channel so the recovering can occurs.
+                        try {
+                            ctx.getChannel().close();
+                        } catch (Throwable t) {
+                            ; // Swallow.
+                        }
+                        return;
+                    }
+                }
+
+                if (abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
+                    log.debug("Trying to recover from dead Channel: {}", channel);
+                    return;
+                }
+            } else if (ctx.getAttachment() instanceof AsyncCallable) {
+                future = ((AsyncCallable) ctx.getAttachment()).future();
+            }
+        } catch (Throwable t) {
+            cause = t;
+        }
+
+        if (future != null) {
+            try {
+                log.debug("Was unable to recover Future: {}", future);
+                abort(future, cause);
+            } catch (Throwable t) {
+                log.error(t.getMessage(), t);
+            }
+        }
+
+        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
+        p.onError(ctx, e);
+
+        closeChannel(ctx);
+        ctx.sendUpstream(e);
+    }
+
+    protected static boolean abortOnConnectCloseException(Throwable cause) {
+        try {
+            for (StackTraceElement element : cause.getStackTrace()) {
+                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl")
+                        && element.getMethodName().equals("checkConnect")) {
+                    return true;
+                }
+            }
+
+            if (cause.getCause() != null) {
+                return abortOnConnectCloseException(cause.getCause());
+            }
+
+        } catch (Throwable t) {
+        }
+        return false;
+    }
+
+    protected static boolean abortOnDisconnectException(Throwable cause) {
+        try {
+            for (StackTraceElement element : cause.getStackTrace()) {
+                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler")
+                        && element.getMethodName().equals("channelDisconnected")) {
+                    return true;
+                }
+            }
+
+            if (cause.getCause() != null) {
+                return abortOnConnectCloseException(cause.getCause());
+            }
+
+        } catch (Throwable t) {
+        }
+        return false;
+    }
+
+    protected static boolean abortOnReadCloseException(Throwable cause) {
+
+        for (StackTraceElement element : cause.getStackTrace()) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
+                    && element.getMethodName().equals("read")) {
+                return true;
+            }
+        }
+
+        if (cause.getCause() != null) {
+            return abortOnReadCloseException(cause.getCause());
+        }
+
+        return false;
+    }
+
+    protected static boolean abortOnWriteCloseException(Throwable cause) {
+
+        for (StackTraceElement element : cause.getStackTrace()) {
+            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
+                    && element.getMethodName().equals("write")) {
+                return true;
+            }
+        }
+
+        if (cause.getCause() != null) {
+            return abortOnReadCloseException(cause.getCause());
+        }
+
+        return false;
+    }
+
+    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
+        int length = (int) request.getContentLength();
+        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
+            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
+        }
+
+        if (length >= 0) {
+            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+        }
+        return length;
+    }
+
+    public static <T> NettyResponseFuture<T> newFuture(URI uri,
+                                                       Request request,
+                                                       AsyncHandler<T> asyncHandler,
+                                                       HttpRequest nettyRequest,
+                                                       AsyncHttpClientConfig config,
+                                                       NettyAsyncHttpProvider provider) {
+
+        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest,
+                requestTimeout(config, request.getPerRequestConfig()), config.getIdleConnectionTimeoutInMs(), provider);
+
+        if (request.getHeaders().getFirstValue("Expect") != null
+                && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
+            f.getAndSetWriteBody(false);
+        }
+        return f;
+    }
+
+    private class ProgressListener implements ChannelFutureProgressListener {
+
+        private final boolean notifyHeaders;
+        private final AsyncHandler asyncHandler;
+        private final NettyResponseFuture<?> future;
+
+        public ProgressListener(boolean notifyHeaders, AsyncHandler asyncHandler, NettyResponseFuture<?> future) {
+            this.notifyHeaders = notifyHeaders;
+            this.asyncHandler = asyncHandler;
+            this.future = future;
+        }
+
+        public void operationComplete(ChannelFuture cf) {
+            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+            // Let's retry a second time.
+            Throwable cause = cf.getCause();
+            if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
+
+                if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
+                    log.debug(cause.getMessage(), cause);
+                    try {
+                        cf.getChannel().close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                }
+
+                if (ClosedChannelException.class.isAssignableFrom(cause.getClass())
+                        || abortOnReadCloseException(cause)
+                        || abortOnWriteCloseException(cause)) {
+
+                    if (log.isDebugEnabled()) {
+                        log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
+                    }
+
+                    try {
+                        cf.getChannel().close();
+                    } catch (RuntimeException ex) {
+                        log.debug(ex.getMessage(), ex);
+                    }
+                    return;
+                } else {
+                    future.abort(cause);
+                }
+                return;
+            }
+            future.touch();
+
+            /**
+             * We need to make sure we aren't in the middle of an authorization process before publishing events
+             * as we will re-publish again the same event after the authorization, causing unpredictable behavior.
+             */
+            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
+            boolean startPublishing = future.isInAuth()
+                    || realm == null
+                    || realm.getUsePreemptiveAuth() == true;
+
+            if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+                if (notifyHeaders) {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
+                } else {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
+                }
+            }
+        }
+
+        public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
+            future.touch();
+            if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+                ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
+            }
+        }
+    }
+
+    /**
+     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run
+     * them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future
+     * this wrapper will release the references to the channel and the nettyResponseFuture immediately. Otherwise,
+     * the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
+     */
+    private final class ReaperFuture implements Future, Runnable {
+        private Future scheduledFuture;
+        private NettyResponseFuture<?> nettyResponseFuture;
+
+        public ReaperFuture(NettyResponseFuture<?> nettyResponseFuture) {
+            this.nettyResponseFuture = nettyResponseFuture;
+        }
+
+        public void setScheduledFuture(Future scheduledFuture) {
+            this.scheduledFuture = scheduledFuture;
+        }
+
+        /**
+         * @Override
+         */
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            nettyResponseFuture = null;
+            return scheduledFuture.cancel(mayInterruptIfRunning);
+        }
+
+        /**
+         * @Override
+         */
+        public Object get() throws InterruptedException, ExecutionException {
+            return scheduledFuture.get();
+        }
+
+        /**
+         * @Override
+         */
+        public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            return scheduledFuture.get(timeout, unit);
+        }
+
+        /**
+         * @Override
+         */
+        public boolean isCancelled() {
+            return scheduledFuture.isCancelled();
+        }
+
+        /**
+         * @Override
+         */
+        public boolean isDone() {
+            return scheduledFuture.isDone();
+        }
+
+        /**
+         * @Override
+         */
+        public synchronized void run() {
+            if (isClose.get()) {
+                cancel(true);
+                return;
+            }
+
+            if (nettyResponseFuture != null && nettyResponseFuture.hasExpired()
+                    && !nettyResponseFuture.isDone() && !nettyResponseFuture.isCancelled()) {
+                log.debug("Request Timeout expired for {}\n", nettyResponseFuture);
+
+                int requestTimeout = config.getRequestTimeoutInMs();
+                PerRequestConfig p = nettyResponseFuture.getRequest().getPerRequestConfig();
+                if (p != null && p.getRequestTimeoutInMs() != -1) {
+                    requestTimeout = p.getRequestTimeoutInMs();
+                }
+
+                abort(nettyResponseFuture, new TimeoutException(String.format("No response received after %s", requestTimeout)));
+
+                nettyResponseFuture = null;
+            }
+
+            if (nettyResponseFuture == null || nettyResponseFuture.isDone() || nettyResponseFuture.isCancelled()) {
+                cancel(true);
+            }
+        }
+    }
+
+    private abstract class AsyncCallable implements Callable<Object> {
+
+        private final NettyResponseFuture<?> future;
+
+        public AsyncCallable(NettyResponseFuture<?> future) {
+            this.future = future;
+        }
+
+        abstract public Object call() throws Exception;
+
+        public NettyResponseFuture<?> future() {
+            return future;
+        }
+    }
+
+    public static class ThreadLocalBoolean extends ThreadLocal<Boolean> {
+
+        private final boolean defaultValue;
+
+        public ThreadLocalBoolean() {
+            this(false);
+        }
+
+        public ThreadLocalBoolean(boolean defaultValue) {
+            this.defaultValue = defaultValue;
+        }
+
+        @Override
+        protected Boolean initialValue() {
+            return defaultValue ? Boolean.TRUE : Boolean.FALSE;
+        }
+    }
+
+    public static class OptimizedFileRegion implements FileRegion {
+
+        private final FileChannel file;
+        private final RandomAccessFile raf;
+        private final long position;
+        private final long count;
+        private long byteWritten;
+
+        public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
+            this.raf = raf;
+            this.file = raf.getChannel();
+            this.position = position;
+            this.count = count;
+        }
+
+        public long getPosition() {
+            return position;
+        }
+
+        public long getCount() {
+            return count;
+        }
+
+        public long transferTo(WritableByteChannel target, long position) throws IOException {
+            long count = this.count - position;
+            if (count < 0 || position < 0) {
+                throw new IllegalArgumentException(
+                        "position out of range: " + position +
+                                " (expected: 0 - " + (this.count - 1) + ")");
+            }
+            if (count == 0) {
+                return 0L;
+            }
+
+            long bw = file.transferTo(this.position + position, count, target);
+            byteWritten += bw;
+            if (byteWritten == raf.length()) {
+                releaseExternalResources();
+            }
+            return bw;
+        }
+
+        public void releaseExternalResources() {
+            try {
+                file.close();
+            } catch (IOException e) {
+                log.warn("Failed to close a file.", e);
+            }
+
+            try {
+                raf.close();
+            } catch (IOException e) {
+                log.warn("Failed to close a file.", e);
+            }
+        }
+    }
+
+    private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
+
+        private final ChannelBuffer content;
+        private final FileInputStream file;
+        private int byteRead = 0;
+
+        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ChannelBuffer content, File file) throws IOException {
+            super(headers);
+            this.content = content;
+            if (file != null) {
+                this.file = new FileInputStream(file);
+            } else {
+                this.file = null;
+            }
+        }
+
+        @Override
+        public void getBytes(byte[] bytes) {
+            if (content.writableBytes() != 0) {
+                content.getBytes(byteRead, bytes);
+                byteRead += bytes.length;
+            } else if (file != null) {
+                try {
+                    byteRead += file.read(bytes);
+                } catch (IOException e) {
+                    log.error(e.getMessage(), e);
+                }
+            }
+        }
+    }
+
+    protected AsyncHttpClientConfig getConfig() {
+        return config;
+    }
+
+    private static class NonConnectionsPool implements ConnectionsPool<String, Channel> {
+
+        public boolean offer(String uri, Channel connection) {
+            return false;
+        }
+
+        public Channel poll(String uri) {
+            return null;
+        }
+
+        public boolean removeAll(Channel connection) {
+            return false;
+        }
+
+        public boolean canCacheConnection() {
+            return true;
+        }
+
+        public void destroy() {
+        }
+    }
+
+    private static final boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        if (request.getMethod() != "GET" || !WebSocketUpgradeHandler.class.isAssignableFrom(asyncHandler.getClass())) {
+            return false;
+        }
+        return true;
+    }
+
+    private boolean redirect(Request request,
+                             NettyResponseFuture<?> future,
+                             HttpResponse response,
+                             final ChannelHandlerContext ctx) throws Exception {
+
+        int statusCode = response.getStatus().getCode();
+        boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
+        if (redirectEnabled && (statusCode == 302
+                || statusCode == 301
+                || statusCode == 303
+                || statusCode == 307)) {
+
+            if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
+                // We must allow 401 handling again.
+                future.getAndSetAuth(false);
+
+                String location = response.getHeader(HttpHeaders.Names.LOCATION);
+                URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
+                boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
+                if (!uri.toString().equals(future.getURI().toString())) {
+                    final RequestBuilder nBuilder = stripQueryString ?
+                            new RequestBuilder(future.getRequest()).setQueryParameters(null)
+                            : new RequestBuilder(future.getRequest());
+
+                    if (!(statusCode < 302 || statusCode > 303)
+                            && !(statusCode == 302
+                            && config.isStrict302Handling())) {
+                        nBuilder.setMethod("GET");
+                    }
+                    final URI initialConnectionUri = future.getURI();
+                    final boolean initialConnectionKeepAlive = future.getKeepAlive();
+                    future.setURI(uri);
+                    String newUrl = uri.toString();
+                    if (request.getUrl().startsWith(WEBSOCKET)) {
+                        newUrl = newUrl.replace(HTTP, WEBSOCKET);
+                    }
+
+                    log.debug("Redirecting to {}", newUrl);
+                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE)) {
+                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
+                        nBuilder.addOrReplaceCookie(c);
+                    }
+
+                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE2)) {
+                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
+                        nBuilder.addOrReplaceCookie(c);
+                    }
+
+                    AsyncCallable ac = new AsyncCallable(future) {
+                        public Object call() throws Exception {
+                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() &&
+                                    connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(initialConnectionUri), ctx.getChannel())) {
+                                return null;
+                            }
+                            finishChannel(ctx);
+                            return null;
+                        }
+                    };
+
+                    if (response.isChunked()) {
+                        // We must make sure there is no bytes left before executing the next request.
+                        ctx.setAttachment(ac);
+                    } else {
+                        ac.call();
+                    }
+                    nextRequest(nBuilder.setUrl(newUrl).build(), future);
+                    return true;
+                }
+            } else {
+                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+            }
+        }
+        return false;
+    }
+
+    private final class HttpProtocol implements Protocol {
+        // @Override
+        public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws Exception {
+            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
+            future.touch();
+
+            // The connect timeout occured.
+            if (future.isCancelled() || future.isDone()) {
+                finishChannel(ctx);
+                return;
+            }
+
+            HttpRequest nettyRequest = future.getNettyRequest();
+            AsyncHandler handler = future.getAsyncHandler();
+            Request request = future.getRequest();
+            HttpResponse response = null;
+            try {
+                if (e.getMessage() instanceof HttpResponse) {
+                    response = (HttpResponse) e.getMessage();
+
+                    log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
+
+                    // Required if there is some trailing headers.
+                    future.setHttpResponse(response);
+
+                    int statusCode = response.getStatus().getCode();
+
+                    String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
+                    future.setKeepAlive(ka == null || ! ka.toLowerCase().equals("close"));
+
+                    List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
+                    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+                    HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                    HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
+                    FilterContext fc = new FilterContext.FilterContextBuilder()
+                            .asyncHandler(handler)
+                            .request(request)
+                            .responseStatus(status)
+                            .responseHeaders(responseHeaders)
+                            .build();
+
+                    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                        try {
+                            fc = asyncFilter.filter(fc);
+                            if (fc == null) {
+                                throw new NullPointerException("FilterContext is null");
+                            }
+                        } catch (FilterException efe) {
+                            abort(future, efe);
+                        }
+                    }
+
+                    // The handler may have been wrapped.
+                    handler = fc.getAsyncHandler();
+                    future.setAsyncHandler(handler);
+
+                    // The request has changed
+                    if (fc.replayRequest()) {
+                        replayRequest(future, fc, response, ctx);
+                        return;
+                    }
+
+                    Realm newRealm = null;
+                    ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+                    final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
+                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
+
+                    //if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
+                    //    builder.setUrl(future.getURI().toString());
+                    //}
+
+                    if (statusCode == 401
+                            && realm != null
+                            && wwwAuth.size() > 0
+                            && !future.getAndSetAuth(true)) {
+
+                        future.setState(NettyResponseFuture.STATE.NEW);
+                        // NTLM
+                        if (!wwwAuth.contains("Kerberos") && (wwwAuth.contains("NTLM") || (wwwAuth.contains("Negotiate")))) {
+                            newRealm = ntlmChallenge(wwwAuth, request, proxyServer, headers, realm, future);
+                            // SPNEGO KERBEROS
+                        } else if (wwwAuth.contains("Negotiate")) {
+                            newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
+                            if (newRealm == null) return;
+                        } else {
+                            Realm.RealmBuilder realmBuilder;
+                            if (realm != null) {
+                                realmBuilder = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
+                                ;
+                            } else {
+                                realmBuilder = new Realm.RealmBuilder();
+                            }
+                            newRealm = realmBuilder
+                                    .setUri(URI.create(request.getUrl()).getPath())
+                                    .setMethodName(request.getMethod())
+                                    .setUsePreemptiveAuth(true)
+                                    .parseWWWAuthenticateHeader(wwwAuth.get(0))
+                                    .build();
+                        }
+
+                        final Realm nr = new Realm.RealmBuilder().clone(newRealm)
+                                .setUri(URI.create(request.getUrl()).getPath()).build();
+
+                        log.debug("Sending authentication to {}", request.getUrl());
+                        AsyncCallable ac = new AsyncCallable(future) {
+                            public Object call() throws Exception {
+                                drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+                                nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
+                                return null;
+                            }
+                        };
+
+                        if (future.getKeepAlive() && response.isChunked()) {
+                            // We must make sure there is no bytes left before executing the next request.
+                            ctx.setAttachment(ac);
+                        } else {
+                            ac.call();
+                        }
+                        return;
+                    }
+
+                    if (statusCode == 100) {
+                        future.getAndSetWriteHeaders(false);
+                        future.getAndSetWriteBody(true);
+                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
+                        return;
+                    }
+
+                    List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
+                    if (statusCode == 407
+                            && realm != null
+                            && proxyAuth.size() > 0
+                            && !future.getAndSetAuth(true)) {
+
+                        log.debug("Sending proxy authentication to {}", request.getUrl());
+
+                        future.setState(NettyResponseFuture.STATE.NEW);
+
+                        if (!proxyAuth.contains("Kerberos") && (proxyAuth.get(0).contains("NTLM") || (proxyAuth.contains("Negotiate")))) {
+                            newRealm = ntlmProxyChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+                            // SPNEGO KERBEROS
+                        } else if (proxyAuth.contains("Negotiate")) {
+                            newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+                            if (newRealm == null) return;
+                        } else {
+                            newRealm = future.getRequest().getRealm();
+                        }
+
+                        Request req = builder.setHeaders(headers).setRealm(newRealm).build();
+                        future.setReuseChannel(true);
+                        future.setConnectAllowed(true);
+                        nextRequest(req, future);
+                        return;
+                    }
+
+                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)
+                            && statusCode == 200) {
+
+                        log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
+
+                        if (future.getKeepAlive()) {
+                            future.attachChannel(ctx.getChannel(), true);
+                        }
+
+                        try {
+                            log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
+                            upgradeProtocol(ctx.getChannel().getPipeline(), URI.create(request.getUrl()).getScheme());
+                        } catch (Throwable ex) {
+                            abort(future, ex);
+                        }
+                        Request req = builder.build();
+                        future.setReuseChannel(true);
+                        future.setConnectAllowed(false);
+                        nextRequest(req, future);
+                        return;
+                    }
+
+                    if (redirect(request, future, response, ctx)) return;
+
+                    if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
+                        finishUpdate(future, ctx, response.isChunked());
+                        return;
+                    } else if (updateHeadersAndInterrupt(handler, responseHeaders)) {
+                        finishUpdate(future, ctx, response.isChunked());
+                        return;
+                    } else if (!response.isChunked()) {
+                        if (response.getContent().readableBytes() != 0) {
+                            updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
+                        }
+                        finishUpdate(future, ctx, false);
+                        return;
+                    }
+
+                    if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
+                        updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
+                        markAsDone(future, ctx);
+                        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
+                    }
+
+                } else if (e.getMessage() instanceof HttpChunk) {
+                    HttpChunk chunk = (HttpChunk) e.getMessage();
+
+                    if (handler != null) {
+                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler,
+                                new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
+                            if (chunk instanceof DefaultHttpChunkTrailer) {
+                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(),
+                                        future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
+                            }
+                            finishUpdate(future, ctx, !chunk.isLast());
+                        }
+                    }
+                }
+            } catch (Exception t) {
+                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
+                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
+                            .request(future.getRequest()).ioException(IOException.class.cast(t)).build();
+                    fc = handleIoException(fc, future);
+
+                    if (fc.replayRequest()) {
+                        replayRequest(future, fc, response, ctx);
+                        return;
+                    }
+                }
+
+                try {
+                    abort(future, t);
+                } finally {
+                    finishUpdate(future, ctx, false);
+                    throw t;
+                }
+            }
+        }
+
+        // @Override
+        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
+        }
+
+        // @Override
+        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
+        }
+    }
+
+    private final class WebSocketProtocol implements Protocol {
+
+        // @Override
+        public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+            NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
+            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+            Request request = future.getRequest();
+
+            if (e.getMessage() instanceof HttpResponse) {
+                HttpResponse response = (HttpResponse) e.getMessage();
+
+                HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
+                FilterContext<?> fc = new FilterContext.FilterContextBuilder()
+                        .asyncHandler(h)
+                        .request(request)
+                        .responseStatus(s)
+                        .responseHeaders(responseHeaders)
+                        .build();
+                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                    try {
+                        fc = asyncFilter.filter(fc);
+                        if (fc == null) {
+                            throw new NullPointerException("FilterContext is null");
+                        }
+                    } catch (FilterException efe) {
+                        abort(future, efe);
+                    }
+
+                }
+
+                // The handler may have been wrapped.
+                future.setAsyncHandler(fc.getAsyncHandler());
+
+                // The request has changed
+                if (fc.replayRequest()) {
+                    replayRequest(future, fc, response, ctx);
+                    return;
+                }
+
+                future.setHttpResponse(response);
+                if (redirect(request, future, response, ctx)) return;
+
+                final org.jboss.netty.handler.codec.http.HttpResponseStatus status =
+                        new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
+
+                final boolean validStatus = response.getStatus().equals(status);
+                final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
+                String c = response.getHeader(HttpHeaders.Names.CONNECTION);
+                if (c == null) {
+                    c = response.getHeader("connection");
+                }
+
+                final boolean validConnection = c == null ? false : c.equalsIgnoreCase(HttpHeaders.Values.UPGRADE);
+
+                s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
+                final boolean statusReceived = h.onStatusReceived(s) == STATE.UPGRADE;
+
+                if (!statusReceived) {
+                    h.onClose(new NettyWebSocket(ctx.getChannel()), 1002, "Bad response status " + response.getStatus().getCode());
+                    future.done(null);
+                    return;
+                }
+
+                if (!validStatus || !validUpgrade || !validConnection) {
+                    throw new IOException("Invalid handshake response");
+                }
+
+                String accept = response.getHeader("Sec-WebSocket-Accept");
+                String key = WebSocketUtil.getAcceptKey(future.getNettyRequest().getHeader(WEBSOCKET_KEY));
+                if (accept == null || !accept.equals(key)) {
+                    throw new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key));
+                }
+
+                ctx.getPipeline().replace("ws-decoder", "ws-decoder", new WebSocket08FrameDecoder(false, false));
+                ctx.getPipeline().replace("ws-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
+                if (h.onHeadersReceived(responseHeaders) == STATE.CONTINUE) {
+                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
+                }
+                future.done(null);
+            } else if (e.getMessage() instanceof WebSocketFrame) {
+                final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
+
+                HttpChunk webSocketChunk = new HttpChunk() {
+                    private ChannelBuffer content;
+
+                    // @Override
+                    public boolean isLast() {
+                        return false;
+                    }
+
+                    // @Override
+                    public ChannelBuffer getContent() {
+                        return content;
+                    }
+
+                    // @Override
+                    public void setContent(ChannelBuffer content) {
+                        this.content = content;
+                    }
+                };
+
+                if (frame.getBinaryData() != null) {
+                    webSocketChunk.setContent(ChannelBuffers.wrappedBuffer(frame.getBinaryData()));
+                    ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
+                    h.onBodyPartReceived(rp);
+
+                    NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+                    webSocket.onMessage(rp.getBodyPartBytes());
+                    webSocket.onTextMessage(frame.getBinaryData().toString(UTF8));
+
+                    if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
+                        try {
+                            webSocket.onClose(CloseWebSocketFrame.class.cast(frame).getStatusCode(), CloseWebSocketFrame.class.cast(frame).getReasonText());
+                        } catch (Throwable t) {
+                            // Swallow any exception that may comes from a Netty version released before 3.4.0
+                            log.trace("", t);
+                        }
+                    }
+                }
+            } else {
+                log.error("Invalid attachment {}", ctx.getAttachment());
+            }
+        }
+
+        //@Override
+        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
+            try {
+                log.warn("onError {}", e);
+                if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
+                    return;
+                }
+
+                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
+                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
+
+                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+                webSocket.onError(e.getCause());
+                webSocket.close();
+            } catch (Throwable t) {
+                log.error("onError", t);
+            }
+        }
+
+        //@Override
+        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
+            log.trace("onClose {}", e);
+            if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
+                return;
+            }
+
+            try {
+                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
+                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
+                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+
+                webSocket.close();
+            } catch (Throwable t) {
+                log.error("onError", t);
+            }
+        }
+    }
+
+    private static boolean isWebSocket(URI uri) {
+        return WEBSOCKET.equalsIgnoreCase(uri.getScheme()) || WEBSOCKET_SSL.equalsIgnoreCase(uri.getScheme());
+    }
+
+    private static boolean isSecure(String scheme) {
+        return HTTPS.equalsIgnoreCase(scheme) || WEBSOCKET_SSL.equalsIgnoreCase(scheme);
+    }
+
+    private static boolean isSecure(URI uri) {
+        return isSecure(uri.getScheme());
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java
new file mode 100644
index 000000000..25167b822
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpProviderConfig;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
+ */
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
+
+    /**
+     * Use Netty's blocking IO stategy.
+     */
+    public final static String USE_BLOCKING_IO = "useBlockingIO";
+
+    /**
+     * Use direct {@link java.nio.ByteBuffer}
+     */
+    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
+
+    /**
+     * Execute the connect operation asynchronously.
+     */
+    public final static String EXECUTE_ASYNC_CONNECT = "asyncConnect";
+
+    /**
+     * Allow nested request from any {@link com.ning.http.client.AsyncHandler}
+     */
+    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
+
+    /**
+     * Allow configuring the Netty's boss executor service.
+     */
+    public final static String BOSS_EXECUTOR_SERVICE = "bossExecutorService";
+
+    /**
+     * See {@link java.net.Socket#setReuseAddress(boolean)}
+     */
+    public final static String REUSE_ADDRESS = "reuseAddress";
+
+    private final ConcurrentHashMap<String, Object> properties = new ConcurrentHashMap<String, Object>();
+
+    public NettyAsyncHttpProviderConfig() {
+        properties.put(REUSE_ADDRESS, "false");
+    }
+
+    /**
+     * Add a property that will be used when the AsyncHttpClient initialize its {@link com.ning.http.client.AsyncHttpProvider}
+     *
+     * @param name  the name of the property
+     * @param value the value of the property
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+        properties.put(name, value);
+        return this;
+    }
+
+    /**
+     * Return the value associated with the property's name
+     *
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public Object getProperty(String name) {
+        return properties.get(name);
+    }
+
+    /**
+     * Remove the value associated with the property's name
+     *
+     * @param name
+     * @return true if removed
+     */
+    public Object removeProperty(String name) {
+        return properties.remove(name);
+    }
+
+    /**
+     * Return the curent entry set.
+     *
+     * @return a the curent entry set.
+     */
+    public Set<Map.Entry<String, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java
new file mode 100644
index 000000000..6a2bde0e4
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.Request;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureListener;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.net.ssl.HostnameVerifier;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+
+/**
+ * Non Blocking connect.
+ */
+final class NettyConnectListener<T> implements ChannelFutureListener {
+    private final static Logger logger = LoggerFactory.getLogger(NettyConnectListener.class);
+    private final AsyncHttpClientConfig config;
+    private final NettyResponseFuture<T> future;
+    private final HttpRequest nettyRequest;
+    private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
+
+    private NettyConnectListener(AsyncHttpClientConfig config,
+                                 NettyResponseFuture<T> future,
+                                 HttpRequest nettyRequest) {
+        this.config = config;
+        this.future = future;
+        this.nettyRequest = nettyRequest;
+    }
+
+    public NettyResponseFuture<T> future() {
+        return future;
+    }
+
+    public final void operationComplete(ChannelFuture f) throws Exception {
+        if (f.isSuccess()) {
+            Channel channel = f.getChannel();
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(future);
+            SslHandler sslHandler = (SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
+            if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
+                ((SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
+                return;
+            }
+
+            HostnameVerifier v = config.getHostnameVerifier();
+            if (sslHandler != null) {
+                if (!v.verify(future.getURI().getHost(), sslHandler.getEngine().getSession())) {
+                	ConnectException exception = new ConnectException("HostnameVerifier exception.");
+                	future.abort(exception);
+                	throw exception;
+                }
+            }
+
+            future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
+        } else {
+            Throwable cause = f.getCause();
+
+            logger.debug("Trying to recover a dead cached channel {} with a retry value of {} ", f.getChannel(), future.canRetry());
+            if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
+                    || ClosedChannelException.class.isAssignableFrom(cause.getClass())
+                    || future.getState() != NettyResponseFuture.STATE.NEW)) {
+
+                logger.debug("Retrying {} ", nettyRequest);
+                if (future.provider().remotelyClosed(f.getChannel(), future)) {
+                    return;
+                }
+            }
+
+            logger.debug("Failed to recover from exception: {} with channel {}", cause, f.getChannel());
+
+            boolean printCause = f.getCause() != null && cause.getMessage() != null;
+            ConnectException e = new ConnectException(printCause ? cause.getMessage() + " to " + future.getURI().toString() : future.getURI().toString());
+            if (cause != null) {
+                e.initCause(cause);
+            }
+            future.abort(e);
+        }
+    }
+
+    public static class Builder<T> {
+        private final AsyncHttpClientConfig config;
+
+        private final Request request;
+        private final AsyncHandler<T> asyncHandler;
+        private NettyResponseFuture<T> future;
+        private final NettyAsyncHttpProvider provider;
+        private final ChannelBuffer buffer;
+
+        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
+                       NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
+
+            this.config = config;
+            this.request = request;
+            this.asyncHandler = asyncHandler;
+            this.future = null;
+            this.provider = provider;
+            this.buffer = buffer;
+        }
+
+        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
+                       NettyResponseFuture<T> future, NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
+
+            this.config = config;
+            this.request = request;
+            this.asyncHandler = asyncHandler;
+            this.future = future;
+            this.provider = provider;
+            this.buffer = buffer;
+        }
+
+        public NettyConnectListener<T> build(final URI uri) throws IOException {
+            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer);
+            if (future == null) {
+                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider);
+            } else {
+                future.setNettyRequest(nettyRequest);
+                future.setRequest(request);
+            }
+            return new NettyConnectListener<T>(config, future, nettyRequest);
+        }
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java
new file mode 100644
index 000000000..ee03b2495
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.ConnectionsPool;
+import org.jboss.netty.channel.Channel;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * A simple implementation of {@link com.ning.http.client.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ */
+public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
+
+    private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
+    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
+    private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
+    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final Timer idleConnectionDetector = new Timer(true);
+    private final boolean sslConnectionPoolEnabled;
+    private final int maxTotalConnections;
+    private final int maxConnectionPerHost;
+    private final int maxConnectionLifeTimeInMs;
+    private final long maxIdleTime;
+
+    public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
+        this.maxTotalConnections = provider.getConfig().getMaxTotalConnections();
+        this.maxConnectionPerHost = provider.getConfig().getMaxConnectionPerHost();
+        this.sslConnectionPoolEnabled = provider.getConfig().isSslConnectionPoolEnabled();
+        this.maxIdleTime = provider.getConfig().getIdleConnectionInPoolTimeoutInMs();
+        this.maxConnectionLifeTimeInMs = provider.getConfig().getMaxConnectionLifeTimeInMs();
+        this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
+    }
+
+    private static class IdleChannel {
+        final String uri;
+        final Channel channel;
+        final long start;
+
+        IdleChannel(String uri, Channel channel) {
+            this.uri = uri;
+            this.channel = channel;
+            this.start = System.currentTimeMillis();
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof IdleChannel)) return false;
+
+            IdleChannel that = (IdleChannel) o;
+
+            if (channel != null ? !channel.equals(that.channel) : that.channel != null) return false;
+
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            return channel != null ? channel.hashCode() : 0;
+        }
+    }
+
+    private class IdleChannelDetector extends TimerTask {
+        @Override
+        public void run() {
+            try {
+                if (isClosed.get()) return;
+
+                if (log.isDebugEnabled()) {
+                    Set<String> keys = connectionsPool.keySet();
+
+                    for (String s : keys) {
+                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
+                    }
+                }
+
+                List<IdleChannel> channelsInTimeout = new ArrayList<IdleChannel>();
+                long currentTime = System.currentTimeMillis();
+
+                for (IdleChannel idleChannel : channel2IdleChannel.values()) {
+                    long age = currentTime - idleChannel.start;
+                    if (age > maxIdleTime) {
+
+                        log.debug("Adding Candidate Idle Channel {}", idleChannel.channel);
+
+                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
+                        channelsInTimeout.add(idleChannel);
+                    }
+                }
+                long endConcurrentLoop = System.currentTimeMillis();
+
+                for (IdleChannel idleChannel : channelsInTimeout) {
+                    Object attachment = idleChannel.channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
+                    if (attachment != null) {
+                        if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
+                            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
+
+                            if (!future.isDone() && !future.isCancelled()) {
+                                log.debug("Future not in appropriate state %s\n", future);
+                                continue;
+                            }
+                        }
+                    }
+
+                    if (remove(idleChannel)) {
+                        log.debug("Closing Idle Channel {}", idleChannel.channel);
+                        close(idleChannel.channel);
+                    }
+                }
+
+                if (log.isTraceEnabled())
+                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
+                        connectionsPool.size(), channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
+            } catch (Throwable t) {
+                log.error("uncaught exception!", t);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean offer(String uri, Channel channel) {
+        if (isClosed.get()) return false;
+
+        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
+            return false;
+        }
+
+        Long createTime = channel2CreationDate.get(channel);
+        if (createTime == null){
+           channel2CreationDate.putIfAbsent(channel, System.currentTimeMillis());
+        }
+        else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < System.currentTimeMillis() ) {
+           log.debug("Channel {} expired", channel);
+           return false;
+        }
+
+        log.debug("Adding uri: {} for channel {}", uri, channel);
+        channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+
+        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        if (idleConnectionForHost == null) {
+            ConcurrentLinkedQueue<IdleChannel> newPool = new ConcurrentLinkedQueue<IdleChannel>();
+            idleConnectionForHost = connectionsPool.putIfAbsent(uri, newPool);
+            if (idleConnectionForHost == null) idleConnectionForHost = newPool;
+        }
+
+        boolean added;
+        int size = idleConnectionForHost.size();
+        if (maxConnectionPerHost == -1 || size < maxConnectionPerHost) {
+            IdleChannel idleChannel = new IdleChannel(uri, channel);
+            synchronized (idleConnectionForHost) {
+                added = idleConnectionForHost.add(idleChannel);
+
+                if (channel2IdleChannel.put(channel, idleChannel) != null) {
+                    log.error("Channel {} already exists in the connections pool!", channel);
+                }
+            }
+        } else {
+            log.debug("Maximum number of requests per host reached {} for {}", maxConnectionPerHost, uri);
+            added = false;
+        }
+        return added;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Channel poll(String uri) {
+        if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
+            return null;
+        }
+
+        IdleChannel idleChannel = null;
+        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        if (idleConnectionForHost != null) {
+            boolean poolEmpty = false;
+            while (!poolEmpty && idleChannel == null) {
+                if (idleConnectionForHost.size() > 0) {
+                    synchronized (idleConnectionForHost) {
+                        idleChannel = idleConnectionForHost.poll();
+                        if (idleChannel != null) {
+                            channel2IdleChannel.remove(idleChannel.channel);
+                        }
+                    }
+                }
+
+                if (idleChannel == null) {
+                    poolEmpty = true;
+                } else if (!idleChannel.channel.isConnected() || !idleChannel.channel.isOpen()) {
+                    idleChannel = null;
+                    log.trace("Channel not connected or not opened!");
+                }
+            }
+        }
+        return idleChannel != null ? idleChannel.channel : null;
+    }
+
+    private boolean remove(IdleChannel pooledChannel) {
+        if (pooledChannel == null || isClosed.get()) return false;
+
+        boolean isRemoved = false;
+        ConcurrentLinkedQueue<IdleChannel> pooledConnectionForHost = connectionsPool.get(pooledChannel.uri);
+        if (pooledConnectionForHost != null) {
+            isRemoved = pooledConnectionForHost.remove(pooledChannel);
+        }
+        isRemoved |= channel2IdleChannel.remove(pooledChannel.channel) != null;
+        return isRemoved;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean removeAll(Channel channel) {
+        channel2CreationDate.remove(channel);
+        return !isClosed.get() && remove(channel2IdleChannel.get(channel));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean canCacheConnection() {
+        if (!isClosed.get() && maxTotalConnections != -1 && channel2IdleChannel.size() >= maxTotalConnections) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void destroy() {
+        if (isClosed.getAndSet(true)) return;
+
+        // stop timer
+        idleConnectionDetector.cancel();
+        idleConnectionDetector.purge();
+
+        for (Channel channel : channel2IdleChannel.keySet()) {
+            close(channel);
+        }
+        connectionsPool.clear();
+        channel2IdleChannel.clear();
+        channel2CreationDate.clear();
+    }
+
+    private void close(Channel channel) {
+        try {
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel2CreationDate.remove(channel);
+            channel.close();
+        } catch (Throwable t) {
+            // noop
+        }
+    }
+
+    public final String toString() {
+        return String.format("NettyConnectionPool: {pool-size: %d}", channel2IdleChannel.size());
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponse.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponse.java
new file mode 100644
index 000000000..862c4f10e
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponse.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.Cookie;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.providers.ResponseBase;
+import com.ning.http.util.AsyncHttpProviderUtils;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Wrapper around the {@link com.ning.http.client.Response} API.
+ */
+public class NettyResponse extends ResponseBase {
+    private final List<Cookie> cookies = new ArrayList<Cookie>();
+
+    public NettyResponse(HttpResponseStatus status,
+                         HttpResponseHeaders headers,
+                         List<HttpResponseBodyPart> bodyParts) {
+        super(status, headers, bodyParts);
+    }
+
+    /* @Override */
+    public String getResponseBodyExcerpt(int maxLength) throws IOException {
+        return getResponseBodyExcerpt(maxLength, null);
+    }
+
+    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
+        // should be fine; except that it may split multi-byte chars (last char may become '?')
+        if (charset == null) {
+            charset = calculateCharset();
+        }
+        byte[] b = AsyncHttpProviderUtils.contentToBytes(bodyParts, maxLength);
+        return new String(b, charset);
+    }
+
+    /* @Override */
+
+    public List<Cookie> getCookies() {
+        if (headers == null) {
+            throw new IllegalStateException(HEADERS_NOT_COMPUTED);
+        }
+        if (cookies.isEmpty()) {
+            for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+                if (header.getKey().equalsIgnoreCase("Set-Cookie")) {
+                    // TODO: ask for parsed header
+                    List<String> v = header.getValue();
+                    for (String value : v) {
+                        Cookie cookie = AsyncHttpProviderUtils.parseCookie(value);
+                        cookies.add(cookie);
+                    }
+                }
+            }
+        }
+        return Collections.unmodifiableList(cookies);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean hasResponseStatus() {
+        return (status != null ? true : false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean hasResponseHeaders() {
+        return (headers != null ? true : false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean hasResponseBody() {
+        return (bodyParts != null && bodyParts.size() > 0 ? true : false);
+    }
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java
new file mode 100755
index 000000000..9daee180c
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java
@@ -0,0 +1,490 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.Request;
+import com.ning.http.client.listenable.AbstractListenableFuture;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
+ *
+ * @param <V>
+ */
+public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+
+    private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
+    public final static String MAX_RETRY = "com.ning.http.client.providers.netty.maxRetry";
+
+    enum STATE {
+        NEW,
+        POOLED,
+        RECONNECTED,
+        CLOSED,
+    }
+
+    private final CountDownLatch latch = new CountDownLatch(1);
+    private final AtomicBoolean isDone = new AtomicBoolean(false);
+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
+    private AsyncHandler<V> asyncHandler;
+    private final int responseTimeoutInMs;
+    private final int idleConnectionTimeoutInMs;
+    private Request request;
+    private HttpRequest nettyRequest;
+    private final AtomicReference<V> content = new AtomicReference<V>();
+    private URI uri;
+    private boolean keepAlive = true;
+    private HttpResponse httpResponse;
+    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
+    private final AtomicInteger redirectCount = new AtomicInteger();
+    private volatile Future<?> reaperFuture;
+    private final AtomicBoolean inAuth = new AtomicBoolean(false);
+    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
+    private final AtomicLong touch = new AtomicLong(System.currentTimeMillis());
+    private final long start = System.currentTimeMillis();
+    private final NettyAsyncHttpProvider asyncHttpProvider;
+    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
+    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
+    private Channel channel;
+    private boolean reuseChannel = false;
+    private final AtomicInteger currentRetry = new AtomicInteger(0);
+    private final int maxRetry;
+    private boolean writeHeaders;
+    private boolean writeBody;
+    private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
+    private boolean allowConnect = false;
+
+    public NettyResponseFuture(URI uri,
+                               Request request,
+                               AsyncHandler<V> asyncHandler,
+                               HttpRequest nettyRequest,
+                               int responseTimeoutInMs,
+                               int idleConnectionTimeoutInMs,
+                               NettyAsyncHttpProvider asyncHttpProvider) {
+
+        this.asyncHandler = asyncHandler;
+        this.responseTimeoutInMs = responseTimeoutInMs;
+        this.idleConnectionTimeoutInMs = idleConnectionTimeoutInMs;
+        this.request = request;
+        this.nettyRequest = nettyRequest;
+        this.uri = uri;
+        this.asyncHttpProvider = asyncHttpProvider;
+
+        if (System.getProperty(MAX_RETRY) != null) {
+            maxRetry = Integer.valueOf(System.getProperty(MAX_RETRY));
+        } else {
+            maxRetry = asyncHttpProvider.getConfig().getMaxRequestRetry();
+        }
+        writeHeaders = true;
+        writeBody = true;
+    }
+
+    protected URI getURI() throws MalformedURLException {
+        return uri;
+    }
+
+    protected void setURI(URI uri) {
+        this.uri = uri;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean isDone() {
+        return isDone.get();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean isCancelled() {
+        return isCancelled.get();
+    }
+
+    void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+        this.asyncHandler = asyncHandler;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean cancel(boolean force) {
+        cancelReaper();
+
+        if (isCancelled.get()) return false;
+
+        try {
+            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel.close();
+        } catch (Throwable t) {
+            // Ignore
+        }
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(new CancellationException());
+            } catch (Throwable t) {
+                logger.warn("cancel", t);
+            }
+        }
+        latch.countDown();
+        isCancelled.set(true);
+        super.done();
+        return true;
+    }
+
+    /**
+     * Is the Future still valid
+     *
+     * @return <code>true</code> if response has expired and should be terminated.
+     */
+    public boolean hasExpired() {
+        long now = System.currentTimeMillis();
+        return idleConnectionTimeoutInMs != -1 && ((now - touch.get()) >= idleConnectionTimeoutInMs)
+                || responseTimeoutInMs != -1 && ((now - start) >= responseTimeoutInMs);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public V get() throws InterruptedException, ExecutionException {
+        try {
+            return get(responseTimeoutInMs, TimeUnit.MILLISECONDS);
+        } catch (TimeoutException e) {
+            cancelReaper();
+            throw new ExecutionException(e);
+        }
+    }
+
+    void cancelReaper() {
+        if (reaperFuture != null) {
+            reaperFuture.cancel(true);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+        if (!isDone() && !isCancelled()) {
+            boolean expired = false;
+            if (l == -1) {
+                latch.await();
+            } else {
+                expired = !latch.await(l, tu);
+            }
+
+            if (expired) {
+                isCancelled.set(true);
+                try {
+                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+                    channel.close();
+                } catch (Throwable t) {
+                    // Ignore
+                }
+                TimeoutException te = new TimeoutException(String.format("No response received after %s %s", l, tu.name().toLowerCase()));
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(te);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        cancelReaper();
+                        throw new ExecutionException(te);
+                    }
+                }
+            }
+            isDone.set(true);
+
+            ExecutionException e = exEx.getAndSet(null);
+            if (e != null) {
+                throw e;
+            }
+        }
+        return getContent();
+    }
+
+    V getContent() throws ExecutionException {
+        ExecutionException e = exEx.getAndSet(null);
+        if (e != null) {
+            throw e;
+        }
+
+        V update = content.get();
+        // No more retry
+        currentRetry.set(maxRetry);
+        if (exEx.get() == null && !contentProcessed.getAndSet(true)) {
+            try {
+                update = asyncHandler.onCompleted();
+            } catch (Throwable ex) {
+                if (!throwableCalled.getAndSet(true)) {
+                    try {
+                        asyncHandler.onThrowable(ex);
+                    } catch (Throwable t) {
+                        logger.debug("asyncHandler.onThrowable", t);
+                    } finally {
+                        cancelReaper();
+                        throw new RuntimeException(ex);
+                    }
+                }
+            }
+            content.compareAndSet(null, update);
+        }
+        return update;
+    }
+
+    public final void done(Callable callable) {
+        try {
+            cancelReaper();
+
+            if (exEx.get() != null) {
+                return;
+            }
+            getContent();
+            isDone.set(true);
+            if (callable != null) {
+                try {
+                    callable.call();
+                } catch (Exception ex) {
+                    throw new RuntimeException(ex);
+                }
+            }
+        } catch (ExecutionException t) {
+            return;
+        } catch (RuntimeException t) {
+            exEx.compareAndSet(null, new ExecutionException(t));
+        } finally {
+            latch.countDown();
+        }
+        super.done();
+    }
+
+    public final void abort(final Throwable t) {
+        cancelReaper();
+
+        if (isDone.get() || isCancelled.get()) return;
+
+        exEx.compareAndSet(null, new ExecutionException(t));
+        if (!throwableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                logger.debug("asyncHandler.onThrowable", te);
+            } finally {
+                isCancelled.set(true);
+            }
+        }
+        latch.countDown();
+        super.done();
+    }
+
+    public void content(V v) {
+        content.set(v);
+    }
+
+    protected final Request getRequest() {
+        return request;
+    }
+
+    public final HttpRequest getNettyRequest() {
+        return nettyRequest;
+    }
+
+    protected final void setNettyRequest(HttpRequest nettyRequest) {
+        this.nettyRequest = nettyRequest;
+    }
+
+    protected final AsyncHandler<V> getAsyncHandler() {
+        return asyncHandler;
+    }
+
+    protected final boolean getKeepAlive() {
+        return keepAlive;
+    }
+
+    protected final void setKeepAlive(final boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
+
+    protected final HttpResponse getHttpResponse() {
+        return httpResponse;
+    }
+
+    protected final void setHttpResponse(final HttpResponse httpResponse) {
+        this.httpResponse = httpResponse;
+    }
+
+    protected int incrementAndGetCurrentRedirectCount() {
+        return redirectCount.incrementAndGet();
+    }
+
+    protected void setReaperFuture(Future<?> reaperFuture) {
+        cancelReaper();
+        this.reaperFuture = reaperFuture;
+    }
+
+    protected boolean isInAuth() {
+        return inAuth.get();
+    }
+
+    protected boolean getAndSetAuth(boolean inDigestAuth) {
+        return inAuth.getAndSet(inDigestAuth);
+    }
+
+    protected STATE getState() {
+        return state.get();
+    }
+
+    protected void setState(STATE state) {
+        this.state.set(state);
+    }
+
+    public boolean getAndSetStatusReceived(boolean sr) {
+        return statusReceived.getAndSet(sr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public void touch() {
+        touch.set(System.currentTimeMillis());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
+        boolean b = this.writeHeaders;
+        this.writeHeaders = writeHeaders;
+        return b;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    /* @Override */
+    public boolean getAndSetWriteBody(boolean writeBody) {
+        boolean b = this.writeBody;
+        this.writeBody = writeBody;
+        return b;
+    }
+
+    protected NettyAsyncHttpProvider provider() {
+        return asyncHttpProvider;
+    }
+
+    protected void attachChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setReuseChannel(boolean reuseChannel) {
+        this.reuseChannel = reuseChannel;
+    }
+
+    public boolean isConnectAllowed() {
+        return allowConnect;
+    }
+
+    public void setConnectAllowed(boolean allowConnect) {
+        this.allowConnect = allowConnect;
+    }
+
+    protected void attachChannel(Channel channel, boolean reuseChannel) {
+        this.channel = channel;
+        this.reuseChannel = reuseChannel;
+    }
+
+    protected Channel channel() {
+        return channel;
+    }
+
+    protected boolean reuseChannel() {
+        return reuseChannel;
+    }
+
+    protected boolean canRetry() {
+        if (currentRetry.incrementAndGet() > maxRetry) {
+            return false;
+        }
+        return true;
+    }
+
+    public void setRequest(Request request) {
+        this.request = request;
+    }
+
+    /**
+     * Return true if the {@link Future} cannot be recovered. There is some scenario where a connection can be
+     * closed by an unexpected IOException, and in some situation we can recover from that exception.
+     *
+     * @return true if that {@link Future} cannot be recovered.
+     */
+    public boolean cannotBeReplay() {
+        return isDone()
+                || !canRetry()
+                || isCancelled()
+                || (channel() != null && channel().isOpen() && uri.getScheme().compareToIgnoreCase("https") != 0)
+                || isInAuth();
+    }
+
+    @Override
+    public String toString() {
+        return "NettyResponseFuture{" +
+                "currentRetry=" + currentRetry +
+                ",\n\tisDone=" + isDone +
+                ",\n\tisCancelled=" + isCancelled +
+                ",\n\tasyncHandler=" + asyncHandler +
+                ",\n\tresponseTimeoutInMs=" + responseTimeoutInMs +
+                ",\n\tnettyRequest=" + nettyRequest +
+                ",\n\tcontent=" + content +
+                ",\n\turi=" + uri +
+                ",\n\tkeepAlive=" + keepAlive +
+                ",\n\thttpResponse=" + httpResponse +
+                ",\n\texEx=" + exEx +
+                ",\n\tredirectCount=" + redirectCount +
+                ",\n\treaperFuture=" + reaperFuture +
+                ",\n\tinAuth=" + inAuth +
+                ",\n\tstatusReceived=" + statusReceived +
+                ",\n\ttouch=" + touch +
+                '}';
+    }
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyWebSocket.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyWebSocket.java
new file mode 100644
index 000000000..03836e1a9
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyWebSocket.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.websocket.WebSocket;
+import com.ning.http.client.websocket.WebSocketByteListener;
+import com.ning.http.client.websocket.WebSocketCloseCodeReasonListener;
+import com.ning.http.client.websocket.WebSocketListener;
+import com.ning.http.client.websocket.WebSocketTextListener;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import static org.jboss.netty.buffer.ChannelBuffers.wrappedBuffer;
+
+public class NettyWebSocket implements WebSocket {
+    private final static Logger logger = LoggerFactory.getLogger(NettyWebSocket.class);
+
+    private final Channel channel;
+    private final ConcurrentLinkedQueue<WebSocketListener> listeners = new ConcurrentLinkedQueue<WebSocketListener>();
+
+    public NettyWebSocket(Channel channel) {
+        this.channel = channel;
+    }
+
+    // @Override
+    public WebSocket sendMessage(byte[] message) {
+        channel.write(new BinaryWebSocketFrame(wrappedBuffer(message)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket stream(byte[] fragment, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket sendTextMessage(String message) {
+        channel.write(new TextWebSocketFrame(message));
+        return this;
+    }
+
+    // @Override
+    public WebSocket streamText(String fragment, boolean last) {
+        throw new UnsupportedOperationException("Streaming currently only supported by the Grizzly provider.");
+    }
+
+    // @Override
+    public WebSocket sendPing(byte[] payload) {
+        channel.write(new PingWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket sendPong(byte[] payload) {
+        channel.write(new PongWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    // @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        listeners.add(l);
+        return this;
+    }
+
+    // @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        listeners.remove(l);
+        return this;
+    }
+
+    // @Override
+    public boolean isOpen() {
+        return channel.isOpen();
+    }
+
+    // @Override
+    public void close() {
+        onClose();
+        listeners.clear();
+        channel.close();
+    }
+
+    protected void onMessage(byte[] message) {
+        for (WebSocketListener l : listeners) {
+            if (WebSocketByteListener.class.isAssignableFrom(l.getClass())) {
+                try {
+                    WebSocketByteListener.class.cast(l).onMessage(message);
+                } catch (Exception ex) {
+                    l.onError(ex);
+                }
+            }
+        }
+    }
+
+    protected void onTextMessage(String message) {
+        for (WebSocketListener l : listeners) {
+            if (WebSocketTextListener.class.isAssignableFrom(l.getClass())) {
+                try {
+                    WebSocketTextListener.class.cast(l).onMessage(message);
+                } catch (Exception ex) {
+                    l.onError(ex);
+                }
+            }
+        }
+    }
+
+    protected void onError(Throwable t) {
+        for (WebSocketListener l : listeners) {
+            try {
+                l.onError(t);
+            } catch (Throwable t2) {
+                logger.error("", t2);
+            }
+
+        }
+    }
+
+    protected void onClose() {
+        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
+    }
+
+    protected void onClose(int code, String reason) {
+        for (WebSocketListener l : listeners) {
+            try {
+                if (WebSocketCloseCodeReasonListener.class.isAssignableFrom(l.getClass())) {
+                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
+                }
+                l.onClose(this);
+            } catch (Throwable t) {
+                l.onError(t);
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "NettyWebSocket{" +
+                "channel=" + channel +
+                '}';
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/Protocol.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/Protocol.java
new file mode 100644
index 000000000..9af3f99a9
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/Protocol.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.MessageEvent;
+
+public interface Protocol {
+
+    void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception;
+
+    void onError(ChannelHandlerContext ctx, ExceptionEvent e);
+
+    void onClose(ChannelHandlerContext ctx, ChannelStateEvent e);
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseBodyPart.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseBodyPart.java
new file mode 100644
index 000000000..67ae1ff91
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseBodyPart.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.HttpResponseBodyPart;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A callback class used when an HTTP response body is received.
+ */
+public class ResponseBodyPart extends HttpResponseBodyPart {
+    // Empty arrays are immutable, can freely reuse
+    private final static byte[] NO_BYTES = new byte[0];
+
+    private final HttpChunk chunk;
+    private final HttpResponse response;
+    private final AtomicReference<byte[]> bytes = new AtomicReference<byte[]>(null);
+    private final boolean isLast;
+    private boolean closeConnection = false;
+
+    /**
+     * Constructor used for non-chunked GET requests and HEAD requests.
+     */
+    public ResponseBodyPart(URI uri, HttpResponse response, AsyncHttpProvider provider, boolean last) {
+        this(uri, response, provider, null, last);
+    }
+
+    public ResponseBodyPart(URI uri, HttpResponse response, AsyncHttpProvider provider, HttpChunk chunk, boolean last) {
+        super(uri, provider);
+        this.chunk = chunk;
+        this.response = response;
+        isLast = last;
+    }
+    
+    /**
+     * Return the response body's part bytes received.
+     *
+     * @return the response body's part bytes received.
+     */
+    @Override
+    public byte[] getBodyPartBytes() {
+        byte[] bp = bytes.get();
+        if (bp != null) {
+            return bp;
+        }
+
+        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
+        int available = b.readableBytes();
+
+        final byte[] rb = (available == 0) ? NO_BYTES : new byte[available];
+        b.getBytes(b.readerIndex(), rb, 0, available);
+        return rb;
+    }
+
+    @Override
+    public InputStream readBodyPartBytes() {
+        return new ByteArrayInputStream(getBodyPartBytes());
+    }
+
+    @Override
+    public int length() {
+        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
+        return b.readableBytes();
+    }
+    
+    @Override
+    public int writeTo(OutputStream outputStream) throws IOException {
+        ChannelBuffer b = (chunk != null) ? chunk.getContent() : response.getContent();
+        int available = b.readableBytes();
+        if (available > 0) {
+            b.getBytes(b.readerIndex(), outputStream, available);
+        }
+        return available;
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        return ByteBuffer.wrap(getBodyPartBytes());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isLast() {
+        return isLast;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void markUnderlyingConnectionAsClosed() {
+        closeConnection = true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean closeUnderlyingConnection() {
+        return closeConnection;
+    }
+
+    protected HttpChunk chunk() {
+        return chunk;
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseHeaders.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseHeaders.java
new file mode 100644
index 000000000..a18074147
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseHeaders.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.HttpResponseHeaders;
+import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+import java.net.URI;
+
+/**
+ * A class that represent the HTTP headers.
+ */
+public class ResponseHeaders extends HttpResponseHeaders {
+
+    private final HttpChunkTrailer trailingHeaders;
+    private final HttpResponse response;
+    private final FluentCaseInsensitiveStringsMap headers;
+
+    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider) {
+        super(uri, provider, false);
+        this.trailingHeaders = null;
+        this.response = response;
+        headers = computerHeaders();
+    }
+
+    public ResponseHeaders(URI uri, HttpResponse response, AsyncHttpProvider provider, HttpChunkTrailer traillingHeaders) {
+        super(uri, provider, true);
+        this.trailingHeaders = traillingHeaders;
+        this.response = response;
+        headers = computerHeaders();
+    }
+
+    private FluentCaseInsensitiveStringsMap computerHeaders() {
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (String s : response.getHeaderNames()) {
+            for (String header : response.getHeaders(s)) {
+                h.add(s, header);
+            }
+        }
+
+        if (trailingHeaders != null && trailingHeaders.getHeaderNames().size() > 0) {
+            for (final String s : trailingHeaders.getHeaderNames()) {
+                for (String header : response.getHeaders(s)) {
+                    h.add(s, header);
+                }
+            }
+        }
+
+        return h;
+    }
+
+    /**
+     * Return the HTTP header
+     *
+     * @return an {@link com.ning.http.client.FluentCaseInsensitiveStringsMap}
+     */
+    @Override
+    public FluentCaseInsensitiveStringsMap getHeaders() {
+        return headers;
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseStatus.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseStatus.java
new file mode 100644
index 000000000..3a4153fe1
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ResponseStatus.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.HttpResponseStatus;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+import java.net.URI;
+
+/**
+ * A class that represent the HTTP response' status line (code + text)
+ */
+public class ResponseStatus extends HttpResponseStatus {
+
+    private final HttpResponse response;
+
+    public ResponseStatus(URI uri, HttpResponse response, AsyncHttpProvider provider) {
+        super(uri, provider);
+        this.response = response;
+    }
+
+    /**
+     * Return the response status code
+     *
+     * @return the response status code
+     */
+    public int getStatusCode() {
+        return response.getStatus().getCode();
+    }
+
+    /**
+     * Return the response status text
+     *
+     * @return the response status text
+     */
+    public String getStatusText() {
+        return response.getStatus().getReasonPhrase();
+    }
+
+    @Override
+    public String getProtocolName() {
+        return response.getProtocolVersion().getProtocolName();
+    }
+
+    @Override
+    public int getProtocolMajorVersion() {
+        return response.getProtocolVersion().getMajorVersion();
+    }
+
+    @Override
+    public int getProtocolMinorVersion() {
+        return response.getProtocolVersion().getMinorVersion();
+    }
+
+    @Override
+    public String getProtocolText() {
+        return response.getProtocolVersion().getText();
+    }
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/WebSocketUtil.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/WebSocketUtil.java
new file mode 100644
index 000000000..96cedcbbb
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/WebSocketUtil.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.util.Base64;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public final class WebSocketUtil {
+    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+    public static String getKey() {
+        byte[] nonce = createRandomBytes(16);
+        return base64Encode(nonce);
+    }
+
+    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
+        String acceptSeed = key + MAGIC_GUID;
+        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
+        return base64Encode(sha1);
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("MD5 not supported on this platform");
+        }
+    }
+
+    public static byte[] sha1(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("SHA-1 not supported on this platform");
+        }
+    }
+
+    public static String base64Encode(byte[] bytes) {
+        return Base64.encode(bytes);
+    }
+
+    public static byte[] createRandomBytes(int size) {
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size; i++) {
+            bytes[i] = (byte) createRandomNumber(0, 255);
+        }
+
+        return bytes;
+    }
+
+    public static int createRandomNumber(int min, int max) {
+        return (int) (Math.random() * max + min);
+    }
+
+}
+
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoEngine.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoEngine.java
new file mode 100644
index 000000000..bf667b295
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoEngine.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * ====================================================================
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package com.ning.http.client.providers.chanmgr.spnego;
+
+import com.ning.http.util.Base64;
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+import org.ietf.jgss.GSSName;
+import org.ietf.jgss.Oid;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+
+/**
+ * SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication
+ * scheme.
+ *
+ * @since 4.1
+ */
+public class SpnegoEngine {
+    private static final String SPNEGO_OID = "1.3.6.1.5.5.2";
+    private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
+
+    private final Logger log = LoggerFactory.getLogger(getClass());
+
+    private final SpnegoTokenGenerator spnegoGenerator;
+
+    public SpnegoEngine(final SpnegoTokenGenerator spnegoGenerator) {
+        this.spnegoGenerator = spnegoGenerator;
+    }
+
+    public SpnegoEngine() {
+        this(null);
+    }
+
+    public String generateToken(String server) throws Throwable {
+        GSSContext gssContext = null;
+        byte[] token = null; // base64 decoded challenge
+        Oid negotiationOid = null;
+
+        try {
+            log.debug("init {}", server);
+            /* Using the SPNEGO OID is the correct method.
+             * Kerberos v5 works for IIS but not JBoss. Unwrapping
+             * the initial token when using SPNEGO OID looks like what is
+             * described here...
+             *
+             * http://msdn.microsoft.com/en-us/library/ms995330.aspx
+             *
+             * Another helpful URL...
+             *
+             * http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tsec_SPNEGO_token.html
+             *
+             * Unfortunately SPNEGO is JRE >=1.6.
+             */
+
+            /** Try SPNEGO by default, fall back to Kerberos later if error */
+            negotiationOid = new Oid(SPNEGO_OID);
+
+            boolean tryKerberos = false;
+            try {
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(
+                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            } catch (GSSException ex) {
+                log.error("generateToken", ex);
+                // BAD MECH means we are likely to be using 1.5, fall back to Kerberos MECH.
+                // Rethrow any other exception.
+                if (ex.getMajor() == GSSException.BAD_MECH) {
+                    log.debug("GSSException BAD_MECH, retry with Kerberos MECH");
+                    tryKerberos = true;
+                } else {
+                    throw ex;
+                }
+
+            }
+            if (tryKerberos) {
+                /* Kerberos v5 GSS-API mechanism defined in RFC 1964.*/
+                log.debug("Using Kerberos MECH {}", KERBEROS_OID);
+                negotiationOid = new Oid(KERBEROS_OID);
+                GSSManager manager = GSSManager.getInstance();
+                GSSName serverName = manager.createName("HTTP@" + server, GSSName.NT_HOSTBASED_SERVICE);
+                gssContext = manager.createContext(
+                        serverName.canonicalize(negotiationOid), negotiationOid, null,
+                        GSSContext.DEFAULT_LIFETIME);
+                gssContext.requestMutualAuth(true);
+                gssContext.requestCredDeleg(true);
+            }
+
+            // TODO suspicious: this will always be null because no value has been assigned before. Assign directly?
+            if (token == null) {
+                token = new byte[0];
+            }
+
+            token = gssContext.initSecContext(token, 0, token.length);
+            if (token == null) {
+                throw new Exception("GSS security context initialization failed");
+            }
+
+            /*
+             * IIS accepts Kerberos and SPNEGO tokens. Some other servers Jboss, Glassfish?
+             * seem to only accept SPNEGO. Below wraps Kerberos into SPNEGO token.
+             */
+            if (spnegoGenerator != null && negotiationOid.toString().equals(KERBEROS_OID)) {
+                token = spnegoGenerator.generateSpnegoDERObject(token);
+            }
+
+            gssContext.dispose();
+
+            String tokenstr = new String(Base64.encode(token));
+            log.debug("Sending response '{}' back to the server", tokenstr);
+
+            return tokenstr;
+        } catch (GSSException gsse) {
+            log.error("generateToken", gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL
+                    || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
+                throw new Exception(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.NO_CRED)
+                throw new Exception(gsse.getMessage(), gsse);
+            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN
+                    || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
+                    || gsse.getMajor() == GSSException.OLD_TOKEN)
+                throw new Exception(gsse.getMessage(), gsse);
+            // other error
+            throw new Exception(gsse.getMessage());
+        } catch (IOException ex) {
+            throw new Exception(ex.getMessage());
+        }
+    }
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoTokenGenerator.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoTokenGenerator.java
new file mode 100644
index 000000000..365dc108d
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/spnego/SpnegoTokenGenerator.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * ====================================================================
+ *
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+
+package com.ning.http.client.providers.chanmgr.spnego;
+
+import java.io.IOException;
+
+/**
+ * Abstract SPNEGO token generator. Implementations should take an Kerberos ticket and transform
+ * into a SPNEGO token.
+ * <p/>
+ * Implementations of this interface are expected to be thread-safe.
+ *
+ * @since 4.1
+ */
+public interface SpnegoTokenGenerator {
+
+    byte[] generateSpnegoDERObject(byte[] kerberosTicket) throws IOException;
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/util/CleanupChannelGroup.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/util/CleanupChannelGroup.java
new file mode 100644
index 000000000..8e77afb85
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/util/CleanupChannelGroup.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+/*
+ * Copyright 2010 Bruno de Carvalho
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.ning.http.client.providers.chanmgr.util;
+
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.group.ChannelGroupFuture;
+import org.jboss.netty.channel.group.DefaultChannelGroup;
+import org.jboss.netty.channel.group.DefaultChannelGroupFuture;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
+ * supposed to be called once.
+ *
+ * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
+ */
+public class CleanupChannelGroup extends DefaultChannelGroup {
+
+    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
+
+    // internal vars --------------------------------------------------------------------------------------------------
+
+    private final AtomicBoolean closed;
+    private final ReentrantReadWriteLock lock;
+
+    // constructors ---------------------------------------------------------------------------------------------------
+
+    public CleanupChannelGroup() {
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    public CleanupChannelGroup(String name) {
+        super(name);
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    // DefaultChannelGroup --------------------------------------------------------------------------------------------
+
+    @Override
+    public ChannelGroupFuture close() {
+        this.lock.writeLock().lock();
+        try {
+            if (!this.closed.getAndSet(true)) {
+                // First time close() is called.
+                return super.close();
+            } else {
+                Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
+                logger.debug("CleanupChannelGroup Already closed");
+                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public boolean add(Channel channel) {
+        // Synchronization must occur to avoid add() and close() overlap (thus potentially leaving one channel open).
+        // This could also be done by synchronizing the method itself but using a read lock here (rather than a
+        // synchronized() block) allows multiple concurrent calls to add().
+        this.lock.readLock().lock();
+        try {
+            if (this.closed.get()) {
+                // Immediately close channel, as close() was already called.
+                channel.close();
+                return false;
+            }
+
+            return super.add(channel);
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java
new file mode 100644
index 000000000..a74883499
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.Response;
+import com.ning.http.client.async.AbstractBasicTest;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+
+import org.testng.annotations.Test;
+
+import java.util.concurrent.Executors;
+
+import static org.testng.Assert.assertEquals;
+
+public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
+
+    @Test
+    public void bossThreadPoolExecutor() throws Throwable {
+        NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
+        conf.addProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE, Executors.newSingleThreadExecutor());
+
+        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
+        AsyncHttpClient c = getAsyncHttpClient(cf);
+
+        Response r = c.prepareGet(getTargetUrl()).execute().get();
+        assertEquals(r.getStatusCode(), 200);
+    }
+
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java
new file mode 100644
index 000000000..54a306499
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProviderConfig;
+import com.ning.http.client.async.AsyncProvidersBasicTest;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+
+public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    protected AsyncHttpProviderConfig getProviderConfig() {
+        final NettyAsyncHttpProviderConfig config = 
+                new NettyAsyncHttpProviderConfig();
+        config.addProperty("tcpNoDelay", true);
+        return config;
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncResponseTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncResponseTest.java
new file mode 100644
index 000000000..3eba5d667
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncResponseTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.providers.chanmgr.NettyResponse;
+import com.ning.http.client.providers.chanmgr.ResponseStatus;
+
+import org.testng.annotations.Test;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+/**
+ * @author Benjamin Hanzelmann
+ */
+public class NettyAsyncResponseTest {
+
+    @Test(groups = "standalone")
+    public void testCookieParseExpires() {
+        // e.g. "Sun, 06-Feb-2012 03:45:24 GMT";
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
+        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
+
+        Date date = new Date(System.currentTimeMillis() + 60000); // sdf.parse( dateString );
+        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
+
+        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertTrue(cookie.getMaxAge() > 55 && cookie.getMaxAge() < 61, "");
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseMaxAge() {
+        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), 60);
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseWeirdExpiresValue() {
+        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new ResponseStatus(null, null, null), new HttpResponseHeaders(null, null, false) {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), 60);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamHandlerTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamHandlerTest.java
new file mode 100644
index 000000000..2895a3768
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamHandlerTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.AsyncStreamHandlerTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamLifecycleTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamLifecycleTest.java
new file mode 100644
index 000000000..90914d78b
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncStreamLifecycleTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.AsyncStreamLifecycleTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAuthTimeoutTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAuthTimeoutTest.java
new file mode 100644
index 000000000..1824f8ad4
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAuthTimeoutTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.AuthTimeoutTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyAuthTimeoutTest extends AuthTimeoutTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicAuthTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicAuthTest.java
new file mode 100644
index 000000000..652dfe0b5
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicAuthTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.BasicAuthTest;
+import com.ning.http.client.async.ProviderUtil;
+import org.testng.annotations.Test;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
+public class NettyBasicAuthTest extends BasicAuthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    @Test
+    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
+        super.redirectAndBasicAuthTest();    //To change body of overridden methods use File | Settings | File Templates.
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicHttpsTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicHttpsTest.java
new file mode 100644
index 000000000..da3841ccd
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBasicHttpsTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.BasicHttpsTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyBasicHttpsTest extends BasicHttpsTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyChunkTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyChunkTest.java
new file mode 100644
index 000000000..31f3fadd9
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyChunkTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.BodyChunkTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyBodyChunkTest extends BodyChunkTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyDeferringAsyncHandlerTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyDeferringAsyncHandlerTest.java
new file mode 100644
index 000000000..146eba89b
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyBodyDeferringAsyncHandlerTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.BodyDeferringAsyncHandlerTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyBodyDeferringAsyncHandlerTest extends
+        BodyDeferringAsyncHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyByteBufferCapacityTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyByteBufferCapacityTest.java
new file mode 100644
index 000000000..d19c4ce29
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyByteBufferCapacityTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ByteBufferCapacityTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java
new file mode 100644
index 000000000..974f20e86
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java
@@ -0,0 +1,13 @@
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ChunkingTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyChunkingTest extends ChunkingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyComplexClientTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyComplexClientTest.java
new file mode 100644
index 000000000..7bacaf714
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyComplexClientTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ComplexClientTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyComplexClientTest extends ComplexClientTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyConnectionPoolTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyConnectionPoolTest.java
new file mode 100644
index 000000000..66ae8f563
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyConnectionPoolTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.async.ConnectionPoolTest;
+import com.ning.http.client.async.ProviderUtil;
+import org.jboss.netty.channel.Channel;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+
+public class NettyConnectionPoolTest extends ConnectionPoolTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public void testInvalidConnectionsPool() {
+        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
+
+            public boolean offer(String key, Channel connection) {
+                return false;
+            }
+
+            public Channel poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Channel connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return false;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(
+                new AsyncHttpClientConfig.Builder()
+                        .setConnectionsPool(cp)
+                        .build()
+        );
+
+        Exception exception = null;
+        try {
+            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            exception = ex;
+        }
+        assertNotNull(exception);
+        assertEquals(exception.getMessage(), "Too many connections -1");
+        client.close();
+    }
+
+    @Override
+    public void testValidConnectionsPool() {
+        ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
+
+            public boolean offer(String key, Channel connection) {
+                return true;
+            }
+
+            public Channel poll(String connection) {
+                return null;
+            }
+
+            public boolean removeAll(Channel connection) {
+                return false;
+            }
+
+            public boolean canCacheConnection() {
+                return true;
+            }
+
+            public void destroy() {
+
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(
+                new AsyncHttpClientConfig.Builder()
+                        .setConnectionsPool(cp)
+                        .build()
+        );
+
+        Exception exception = null;
+        try {
+            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            exception = ex;
+        }
+        assertNull(exception);
+        client.close();
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyDigestAuthTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyDigestAuthTest.java
new file mode 100644
index 000000000..60f425c4b
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyDigestAuthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.DigestAuthTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyDigestAuthTest extends DigestAuthTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyEmptyBodyTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyEmptyBodyTest.java
new file mode 100644
index 000000000..38fc21759
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyEmptyBodyTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.EmptyBodyTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyEmptyBodyTest extends EmptyBodyTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyErrorResponseTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyErrorResponseTest.java
new file mode 100644
index 000000000..2f37da347
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyErrorResponseTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ErrorResponseTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyErrorResponseTest extends ErrorResponseTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyExpect100ContinueTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyExpect100ContinueTest.java
new file mode 100644
index 000000000..4b8d78ecf
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyExpect100ContinueTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.Expect100ContinueTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyExpect100ContinueTest extends Expect100ContinueTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilePartLargeFileTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilePartLargeFileTest.java
new file mode 100644
index 000000000..5cf8b5dba
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilePartLargeFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.FilePartLargeFileTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilterTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilterTest.java
new file mode 100644
index 000000000..c39bac2e4
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFilterTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.FilterTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyFilterTest extends FilterTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFollowingThreadTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFollowingThreadTest.java
new file mode 100644
index 000000000..3dca17ed6
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyFollowingThreadTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.FollowingThreadTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyFollowingThreadTest extends FollowingThreadTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
+
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHead302Test.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHead302Test.java
new file mode 100644
index 000000000..a85a4299e
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHead302Test.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.Head302Test;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyHead302Test extends Head302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHostnameVerifierTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHostnameVerifierTest.java
new file mode 100644
index 000000000..dd3b835fe
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHostnameVerifierTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.HostnameVerifierTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyHostnameVerifierTest extends HostnameVerifierTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHttpToHttpsRedirectTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHttpToHttpsRedirectTest.java
new file mode 100644
index 000000000..a553805cc
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyHttpToHttpsRedirectTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.HttpToHttpsRedirectTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyIdleStateHandlerTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyIdleStateHandlerTest.java
new file mode 100644
index 000000000..ccb3fb725
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyIdleStateHandlerTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.IdleStateHandlerTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyInputStreamTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyInputStreamTest.java
new file mode 100644
index 000000000..5e17e5cf7
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyInputStreamTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.InputStreamTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyInputStreamTest extends InputStreamTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyListenableFutureTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyListenableFutureTest.java
new file mode 100644
index 000000000..a08afae41
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyListenableFutureTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ListenableFutureTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyListenableFutureTest extends ListenableFutureTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxConnectionsInThreads.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxConnectionsInThreads.java
new file mode 100644
index 000000000..67655929f
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxConnectionsInThreads.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright (c) 2010-2012 Sonatype, Inc.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * and Apache License v2.0 which accompanies this distribution.
+ * The Eclipse Public License is available at
+ *   http://www.eclipse.org/legal/epl-v10.html
+ * The Apache License v2.0 is available at
+ *   http://www.apache.org/licenses/LICENSE-2.0.html
+ * You may elect to redistribute this code under either of these licenses.
+ *******************************************************************************/
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.MaxConnectionsInThreads;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxTotalConnectionTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxTotalConnectionTest.java
new file mode 100644
index 000000000..6a80c6528
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMaxTotalConnectionTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.MaxTotalConnectionTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipartUploadTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipartUploadTest.java
new file mode 100644
index 000000000..76ac472ce
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipartUploadTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.MultipartUploadTest;
+import com.ning.http.client.async.ProviderUtil;
+
+/**
+ * @author dominict
+ */
+public class NettyMultipartUploadTest extends MultipartUploadTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipleHeaderTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipleHeaderTest.java
new file mode 100644
index 000000000..1370228f4
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyMultipleHeaderTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.MultipleHeaderTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyMultipleHeaderTest extends MultipleHeaderTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNoNullResponseTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNoNullResponseTest.java
new file mode 100644
index 000000000..dcf78f2ec
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNoNullResponseTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.NoNullResponseTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyNoNullResponseTest extends NoNullResponseTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNonAsciiContentLengthTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNonAsciiContentLengthTest.java
new file mode 100644
index 000000000..ce8e3f63e
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyNonAsciiContentLengthTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.NonAsciiContentLengthTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
+
+    @Override
+	public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+		return ProviderUtil.nettyProvider(config);
+	}
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyParamEncodingTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyParamEncodingTest.java
new file mode 100644
index 000000000..dd96737db
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyParamEncodingTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ParamEncodingTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyParamEncodingTest extends ParamEncodingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestRelative302Test.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestRelative302Test.java
new file mode 100644
index 000000000..d8d65c6b5
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestRelative302Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.PerRequestRelative302Test;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestTimeoutTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestTimeoutTest.java
new file mode 100644
index 000000000..ccad232d3
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPerRequestTimeoutTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.PerRequestTimeoutTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostRedirectGetTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostRedirectGetTest.java
new file mode 100644
index 000000000..d48d68216
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostRedirectGetTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.PostRedirectGetTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyPostRedirectGetTest extends PostRedirectGetTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostWithQSTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostWithQSTest.java
new file mode 100644
index 000000000..88499734b
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPostWithQSTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.PostWithQSTest;
+import com.ning.http.client.async.ProviderUtil;
+
+public class NettyPostWithQSTest extends PostWithQSTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTest.java
new file mode 100644
index 000000000..52cf2ee36
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.ProxyTest;
+
+public class NettyProxyTest extends ProxyTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
+
+
+
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTunnellingTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTunnellingTest.java
new file mode 100644
index 000000000..98ffb992f
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyProxyTunnellingTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.ProxyTunnellingTest;
+
+public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPutLargeFileTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPutLargeFileTest.java
new file mode 100644
index 000000000..14103f463
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyPutLargeFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.PutLargeFileTest;
+
+public class NettyPutLargeFileTest extends PutLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyQueryParametersTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyQueryParametersTest.java
new file mode 100644
index 000000000..2fa82894a
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyQueryParametersTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.QueryParametersTest;
+
+public class NettyQueryParametersTest extends QueryParametersTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRC10KTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRC10KTest.java
new file mode 100644
index 000000000..b2d85bd1b
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRC10KTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.RC10KTest;
+
+public class NettyRC10KTest extends RC10KTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java
new file mode 100644
index 000000000..cef8cfb75
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProviderConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.RedirectConnectionUsageTest;
+import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+
+public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    protected AsyncHttpProviderConfig getProviderConfig() {
+        final NettyAsyncHttpProviderConfig config = 
+                new NettyAsyncHttpProviderConfig();
+        if (System.getProperty("blockingio") != null) {
+            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+        }
+        return config;
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRelative302Test.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRelative302Test.java
new file mode 100644
index 000000000..26ae29d7a
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRelative302Test.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.Relative302Test;
+
+public class NettyRelative302Test extends Relative302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRemoteSiteTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRemoteSiteTest.java
new file mode 100644
index 000000000..4e535f010
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRemoteSiteTest.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.RemoteSiteTest;
+
+public class NettyRemoteSiteTest extends RemoteSiteTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRequestThrottleTimeoutTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRequestThrottleTimeoutTest.java
new file mode 100644
index 000000000..abfa471be
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRequestThrottleTimeoutTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.*;
+import com.ning.http.client.async.AbstractBasicTest;
+import com.ning.http.client.async.ProviderUtil;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.*;
+
+import static org.testng.Assert.*;
+import static org.testng.Assert.fail;
+
+public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
+    private static final String MSG = "Enough is enough.";
+    private static final int SLEEPTIME_MS = 1000;
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
+    }
+
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(SLEEPTIME_MS);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        log.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        log.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
+
+    @Test(groups = {"standalone", "netty_provider"})
+    public void testRequestTimeout() throws IOException {
+        final Semaphore requestThrottle = new Semaphore(1);
+
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
+                .setCompressionEnabled(true)
+                .setAllowPoolingConnection(true)
+                .setMaximumConnectionsTotal(1).build());
+
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        final List<Exception> tooManyConnections = new ArrayList<Exception>(2);
+        for(int i=0;i<2;i++) {
+            final int threadNumber = i;
+            new Thread(new Runnable() {
+
+                public void run() {
+                    try {
+                        requestThrottle.acquire();
+                        PerRequestConfig requestConfig = new PerRequestConfig();
+                        requestConfig.setRequestTimeoutInMs(SLEEPTIME_MS/2);
+                        Future<Response> responseFuture = null;
+                        try {
+                             responseFuture =
+                                    client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute(new AsyncCompletionHandler<Response>() {
+
+                                        @Override
+                                        public Response onCompleted(Response response) throws Exception {
+                                            requestThrottle.release();
+                                            return response;
+                                        }
+
+                                        @Override
+                                        public void onThrowable(Throwable t) {
+                                            requestThrottle.release();
+                                        }
+                                    });
+                        } catch(Exception e) {
+                            tooManyConnections.add(e);
+                        }
+
+                        if(responseFuture!=null)
+                            responseFuture.get();
+                    } catch (Exception e) {
+                    } finally {
+                        latch.countDown();
+                    }
+
+                }
+            }).start();
+
+
+        }
+
+        try {
+            latch.await(30,TimeUnit.SECONDS);
+        } catch (Exception e) {
+            fail("failed to wait for requests to complete");
+        }
+
+        assertTrue(tooManyConnections.size()==0,"Should not have any connection errors where too many connections have been attempted");
+
+        client.close();
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRetryRequestTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRetryRequestTest.java
new file mode 100644
index 000000000..a45865bd9
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRetryRequestTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.RetryRequestTest;
+
+public class NettyRetryRequestTest extends RetryRequestTest{
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettySimpleAsyncHttpClientTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettySimpleAsyncHttpClientTest.java
new file mode 100644
index 000000000..d52ac3ec4
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettySimpleAsyncHttpClientTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.SimpleAsyncHttpClientTest;
+
+public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
+
+    /**
+     * Not Used with {@link com.ning.http.client.SimpleAsyncHttpClient}
+     * @param config
+     * @return
+     */
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return null;
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyTransferListenerTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyTransferListenerTest.java
new file mode 100644
index 000000000..e2526ca52
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyTransferListenerTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.TransferListenerTest;
+
+public class NettyTransferListenerTest extends TransferListenerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyWebDavBasicTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyWebDavBasicTest.java
new file mode 100644
index 000000000..ac95aba7d
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyWebDavBasicTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.WebDavBasicTest;
+
+public class NettyWebDavBasicTest extends WebDavBasicTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyZeroCopyFileTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyZeroCopyFileTest.java
new file mode 100644
index 000000000..cb7ebe634
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyZeroCopyFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.async.ZeroCopyFileTest;
+
+public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java
new file mode 100644
index 000000000..9ab80ae22
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java
@@ -0,0 +1,333 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+
+import org.eclipse.jetty.server.Connector;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+
+import static org.testng.Assert.assertTrue;
+
+
+public class RetryNonBlockingIssue {
+
+    private URI servletEndpointUri;
+
+    private Server server;
+
+    private int port1;
+
+    public static int findFreePort() throws IOException {
+        ServerSocket socket = null;
+
+        try {
+            // 0 is open a socket on any free port
+            socket = new ServerSocket(0);
+            return socket.getLocalPort();
+        } finally {
+            if (socket != null) {
+                socket.close();
+            }
+        }
+    }
+
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        server = new Server();
+
+        port1 = findFreePort();
+
+        Connector listener = new SelectChannelConnector();
+        listener.setHost("127.0.0.1");
+        listener.setPort(port1);
+
+        server.addConnector(listener);
+
+
+        ServletContextHandler context = new
+                ServletContextHandler(ServletContextHandler.SESSIONS);
+
+        context.setContextPath("/");
+        server.setHandler(context);
+        context.addServlet(new ServletHolder(new
+                MockExceptionServlet()), "/*");
+
+        server.start();
+
+        servletEndpointUri = new URI("http://127.0.0.1:" + port1 + "/");
+    }
+
+    @AfterMethod
+    public void stop() {
+
+        try {
+            if (server != null) server.stop();
+        } catch (Exception e) {
+        }
+
+
+    }
+
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient
+            fetcher, int requests, String action, String id) throws IOException {
+        RequestBuilder builder = new RequestBuilder("GET");
+        builder.addQueryParameter(action, "1");
+
+        builder.addQueryParameter("maxRequests", "" + requests);
+        builder.addQueryParameter("id", id);
+        builder.setUrl(servletEndpointUri.toString());
+        com.ning.http.client.Request r = builder.build();
+        return fetcher.executeRequest(r);
+
+    }
+
+    /**
+     * Tests that a head request can be made
+     *
+     * @throws IOException
+     * @throws ExecutionException
+     * @throws InterruptedException
+     */
+    @Test
+    public void testRetryNonBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(60000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @Test
+    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(60000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+            config.addProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT, "true");
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @Test
+    public void testRetryBlocking() throws IOException, InterruptedException,
+            ExecutionException {
+        AsyncHttpClient c = null;
+        List<ListenableFuture<Response>> res = new
+                ArrayList<ListenableFuture<Response>>();
+        try {
+            AsyncHttpClientConfig.Builder bc =
+                    new AsyncHttpClientConfig.Builder();
+
+            bc.setAllowPoolingConnection(true);
+            bc.setMaximumConnectionsTotal(100);
+            bc.setConnectionTimeoutInMs(30000);
+            bc.setRequestTimeoutInMs(30000);
+
+            NettyAsyncHttpProviderConfig config = new
+                    NettyAsyncHttpProviderConfig();
+            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+
+            bc.setAsyncHttpClientProviderConfig(config);
+            c = new AsyncHttpClient(bc.build());
+
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(c, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+
+        }
+        finally {
+            if (c != null) c.close();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    public class MockExceptionServlet extends HttpServlet {
+
+        private Map<String, Integer> requests = new
+                ConcurrentHashMap<String, Integer>();
+
+        private synchronized int increment(String id) {
+            int val = 0;
+            if (requests.containsKey(id)) {
+                Integer i = requests.get(id);
+                val = i + 1;
+                requests.put(id, val);
+            } else {
+                requests.put(id, 1);
+                val = 1;
+            }
+            System.out.println("REQUESTS: " + requests);
+            return val;
+        }
+
+        public void service(HttpServletRequest req, HttpServletResponse res)
+                throws ServletException, IOException {
+            String maxRequests = req.getParameter("maxRequests");
+            int max = 0;
+            try {
+                max = Integer.parseInt(maxRequests);
+            }
+            catch (NumberFormatException e) {
+                max = 3;
+            }
+            String id = req.getParameter("id");
+            int requestNo = increment(id);
+            String servlet = req.getParameter("servlet");
+            String io = req.getParameter("io");
+            String error = req.getParameter("500");
+
+
+            if (requestNo >= max) {
+                res.setHeader("Success-On-Attempt", "" + requestNo);
+                res.setHeader("id", id);
+                if (servlet != null && servlet.trim().length() > 0)
+                    res.setHeader("type", "servlet");
+                if (error != null && error.trim().length() > 0)
+                    res.setHeader("type", "500");
+                if (io != null && io.trim().length() > 0)
+                    res.setHeader("type", "io");
+                res.setStatus(200);
+                res.setContentLength(0);
+                return;
+            }
+
+
+            res.setStatus(200);
+            res.setContentLength(100);
+            res.setContentType("application/octet-stream");
+
+            res.flushBuffer();
+
+            if (servlet != null && servlet.trim().length() > 0)
+                throw new ServletException("Servlet Exception");
+
+            if (io != null && io.trim().length() > 0)
+                throw new IOException("IO Exception");
+
+            if (error != null && error.trim().length() > 0)
+                res.sendError(500, "servlet process was 500");
+        }
+
+    }
+}
+
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyByteMessageTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyByteMessageTest.java
new file mode 100644
index 000000000..10764162f
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyByteMessageTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr.websocket;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.websocket.ByteMessageTest;
+
+public class NettyByteMessageTest extends ByteMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyCloseCodeReasonMsgTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyCloseCodeReasonMsgTest.java
new file mode 100644
index 000000000..2a709bde8
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyCloseCodeReasonMsgTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package com.ning.http.client.providers.chanmgr.websocket;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.websocket.CloseCodeReasonMessageTest;
+
+public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyRedirectTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyRedirectTest.java
new file mode 100644
index 000000000..76786882c
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyRedirectTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr.websocket;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.websocket.RedirectTest;
+
+public class NettyRedirectTest extends RedirectTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyTextMessageTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyTextMessageTest.java
new file mode 100644
index 000000000..c6639dc55
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/websocket/NettyTextMessageTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package com.ning.http.client.providers.chanmgr.websocket;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
+import com.ning.http.client.websocket.TextMessageTest;
+
+public class NettyTextMessageTest extends TextMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return ProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/channelmgr/src/test/resources/300k.png b/providers/channelmgr/src/test/resources/300k.png
new file mode 100644
index 000000000..bff4a8598
Binary files /dev/null and b/providers/channelmgr/src/test/resources/300k.png differ
diff --git a/providers/channelmgr/src/test/resources/SimpleTextFile.txt b/providers/channelmgr/src/test/resources/SimpleTextFile.txt
new file mode 100644
index 000000000..088788f82
--- /dev/null
+++ b/providers/channelmgr/src/test/resources/SimpleTextFile.txt
@@ -0,0 +1 @@
+This is a simple test file
\ No newline at end of file
diff --git a/providers/channelmgr/src/test/resources/client.keystore b/providers/channelmgr/src/test/resources/client.keystore
new file mode 100644
index 000000000..eaf8339f4
Binary files /dev/null and b/providers/channelmgr/src/test/resources/client.keystore differ
diff --git a/providers/channelmgr/src/test/resources/gzip.txt.gz b/providers/channelmgr/src/test/resources/gzip.txt.gz
new file mode 100644
index 000000000..80aeb98d2
Binary files /dev/null and b/providers/channelmgr/src/test/resources/gzip.txt.gz differ
diff --git a/providers/channelmgr/src/test/resources/logback-test.xml b/providers/channelmgr/src/test/resources/logback-test.xml
new file mode 100644
index 000000000..4acf27871
--- /dev/null
+++ b/providers/channelmgr/src/test/resources/logback-test.xml
@@ -0,0 +1,13 @@
+<configuration>
+    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
+        <layout class="ch.qos.logback.classic.PatternLayout">
+            <Pattern>%d [%thread] %level %logger - %m%n</Pattern>
+        </layout>
+    </appender>
+
+    <logger name="org.eclipse" level="INFO"/>
+
+    <root level="debug">
+        <appender-ref ref="CONSOLE"/>
+    </root>
+</configuration>
\ No newline at end of file
diff --git a/providers/channelmgr/src/test/resources/realm.properties b/providers/channelmgr/src/test/resources/realm.properties
new file mode 100644
index 000000000..bc9faad66
--- /dev/null
+++ b/providers/channelmgr/src/test/resources/realm.properties
@@ -0,0 +1 @@
+user=admin, admin
\ No newline at end of file
diff --git a/providers/channelmgr/src/test/resources/ssltest-cacerts.jks b/providers/channelmgr/src/test/resources/ssltest-cacerts.jks
new file mode 100644
index 000000000..9c1ffbe49
Binary files /dev/null and b/providers/channelmgr/src/test/resources/ssltest-cacerts.jks differ
diff --git a/providers/channelmgr/src/test/resources/ssltest-keystore.jks b/providers/channelmgr/src/test/resources/ssltest-keystore.jks
new file mode 100644
index 000000000..a95b7c5f4
Binary files /dev/null and b/providers/channelmgr/src/test/resources/ssltest-keystore.jks differ
diff --git a/providers/channelmgr/src/test/resources/textfile.txt b/providers/channelmgr/src/test/resources/textfile.txt
new file mode 100644
index 000000000..87daee60a
--- /dev/null
+++ b/providers/channelmgr/src/test/resources/textfile.txt
@@ -0,0 +1 @@
+filecontent: hello
\ No newline at end of file
diff --git a/providers/channelmgr/src/test/resources/textfile2.txt b/providers/channelmgr/src/test/resources/textfile2.txt
new file mode 100644
index 000000000..6a91fe609
--- /dev/null
+++ b/providers/channelmgr/src/test/resources/textfile2.txt
@@ -0,0 +1 @@
+filecontent: hello2
\ No newline at end of file
diff --git a/providers/pom.xml b/providers/pom.xml
index a33f23dc5..222b1ed87 100644
--- a/providers/pom.xml
+++ b/providers/pom.xml
@@ -49,6 +49,7 @@
         <module>apache</module>
         <module>grizzly</module>
         <module>netty</module>
+        <module>channelmgr</module>
     </modules>
 
     <dependencies>
@@ -65,4 +66,4 @@
             <classifier>tests</classifier>
         </dependency>
     </dependencies>
-</project>
\ No newline at end of file
+</project>
