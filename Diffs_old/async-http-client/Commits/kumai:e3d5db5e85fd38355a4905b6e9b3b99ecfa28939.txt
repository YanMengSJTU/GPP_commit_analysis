diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index b03f0e8b0..94e46626d 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -435,7 +435,10 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
         return channel;
     }
 
-    protected final <T> void writeRequest(final Channel channel, final AsyncHttpClientConfig config, final NettyResponseFuture<T> future, final HttpRequest nettyRequest) {
+    protected final <T> void writeRequest(final Channel channel, final AsyncHttpClientConfig config, final NettyResponseFuture<T> future) {
+
+        HttpRequest nettyRequest = future.getNettyRequest();
+
         try {
             /**
              * If the channel is dead because it was pooled and the remote server decided to close it, we just let it go and the closeChannel do it's work.
@@ -445,7 +448,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
             }
 
             Body body = null;
-            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+            if (!nettyRequest.getMethod().equals(HttpMethod.CONNECT)) {
                 BodyGenerator bg = future.getRequest().getBodyGenerator();
                 if (bg != null) {
                     // Netty issue with chunking.
@@ -472,8 +475,8 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
             if (future.getAsyncHandler() instanceof TransferCompletionHandler) {
 
                 FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-                for (String s : future.getNettyRequest().getHeaderNames()) {
-                    for (String header : future.getNettyRequest().getHeaders(s)) {
+                for (String s : nettyRequest.getHeaderNames()) {
+                    for (String header : nettyRequest.getHeaders(s)) {
                         h.add(s, header);
                     }
                 }
@@ -497,7 +500,7 @@ private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOE
             }
 
             if (future.getAndSetWriteBody(true)) {
-                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
+                if (!nettyRequest.getMethod().equals(HttpMethod.CONNECT)) {
 
                     if (future.getRequest().getFile() != null) {
                         final File file = future.getRequest().getFile();
@@ -538,8 +541,8 @@ public void operationComplete(ChannelFuture cf) {
                          * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
                          */
                         if (future.getRequest().getParts() != null) {
-                            String contentType = future.getNettyRequest().getHeader(HttpHeaders.Names.CONTENT_TYPE);
-                            String length = future.getNettyRequest().getHeader(HttpHeaders.Names.CONTENT_LENGTH);
+                            String contentType = nettyRequest.getHeader(HttpHeaders.Names.CONTENT_TYPE);
+                            String length = nettyRequest.getHeader(HttpHeaders.Names.CONTENT_LENGTH);
                             body = new MultipartBody(future.getRequest().getParts(), contentType, length);
                         }
 
@@ -953,7 +956,7 @@ public Response prepareResponse(final HttpResponseStatus status, final HttpRespo
             channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
 
             try {
-                writeRequest(channel, config, f, nettyRequest);
+                writeRequest(channel, config, f);
             } catch (Exception ex) {
                 log.debug("writeRequest failure", ex);
                 if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
@@ -2144,7 +2147,7 @@ public Object call() throws Exception {
                     if (statusCode == 100) {
                         future.getAndSetWriteHeaders(false);
                         future.getAndSetWriteBody(true);
-                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
+                        writeRequest(ctx.getChannel(), config, future);
                         return;
                     }
 
diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java b/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java
index 3fd5ab573..0dbca7a33 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyConnectListener.java
@@ -52,11 +52,10 @@
     private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
 
     private NettyConnectListener(AsyncHttpClientConfig config,
-                                 NettyResponseFuture<T> future,
-                                 HttpRequest nettyRequest) {
+                                 NettyResponseFuture<T> future) {
         this.config = config;
         this.future = future;
-        this.nettyRequest = nettyRequest;
+        this.nettyRequest = future.getNettyRequest();
     }
 
     public NettyResponseFuture<T> future() {
@@ -82,7 +81,7 @@ public final void operationComplete(ChannelFuture f) throws Exception {
                 }
             }
 
-            future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
+            future.provider().writeRequest(f.getChannel(), config, future);
         } else {
             Throwable cause = f.getCause();
 
@@ -148,7 +147,7 @@ public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> as
                 future.setNettyRequest(nettyRequest);
                 future.setRequest(request);
             }
-            return new NettyConnectListener<T>(config, future, nettyRequest);
+            return new NettyConnectListener<T>(config, future);
         }
     }
 }
