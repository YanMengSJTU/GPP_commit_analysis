diff --git a/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java b/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java
index 2a27b409b..8cff37fa4 100755
--- a/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java
+++ b/src/test/java/com/ning/http/client/async/AsyncProvidersBasicTest.java
@@ -16,25 +16,10 @@
 package com.ning.http.client.async;
 
 import static com.ning.http.util.MiscUtil.isNonEmpty;
-
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpClientConfig.Builder;
-import com.ning.http.client.AsyncHttpClientConfigBean;
-import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.Part;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.StringPart;
-import com.ning.http.client.providers.netty.NettyAsyncHttpProviderConfig;
-import org.testng.Assert;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -58,1535 +43,1633 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncCompletionHandler;
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpClientConfig.Builder;
+import com.ning.http.client.AsyncHttpClientConfigBean;
+import com.ning.http.client.AsyncHttpProviderConfig;
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.MaxRedirectException;
+import com.ning.http.client.Part;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.StringPart;
 
 public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
     private static final String UTF_8 = "text/html;charset=UTF-8";
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderEncodingTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html?q=+%20x").build();
-        String requestUrl = request.getUrl();
-        Assert.assertEquals(requestUrl, "http://foo.com/foo.html?q=%20%20x");
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html?q=+%20x").build();
+            String requestUrl = request.getUrl();
+            Assert.assertEquals(requestUrl, "http://foo.com/foo.html?q=%20%20x");
+            Future<String> responseFuture = client.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/foo.html?q=%20%20x");
-        p.close();
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/foo.html?q=%20%20x");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderEncodingTest2() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html")
-                .addQueryParameter("q", "a b")
-                .build();
-
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com/foo.html").addQueryParameter("q", "a b").build();
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+            Future<String> responseFuture = client.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/foo.html?q=a%20b");
-        p.close();
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/foo.html?q=a%20b");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void emptyRequestURI() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Request request = new RequestBuilder("GET").setUrl("http://foo.com")
-                .build();
-
-        Future<String> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<String>() {
-            @Override
-            public String onCompleted(Response response) throws Exception {
-                return response.getUri().toString();
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Request request = new RequestBuilder("GET").setUrl("http://foo.com").build();
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+            Future<String> responseFuture = client.executeRequest(request, new AsyncCompletionHandler<String>() {
+                @Override
+                public String onCompleted(Response response) throws Exception {
+                    return response.getUri().toString();
+                }
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        String url = responseFuture.get();
-        Assert.assertEquals(url, "http://foo.com/");
-        p.close();
+            });
+            String url = responseFuture.get();
+            Assert.assertEquals(url, "http://foo.com/");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
-        URL url = new URL(getTargetUrl());
-        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.connect();
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            URL url = new URL(getTargetUrl());
+            final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.connect();
 
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    int contentLenght = -1;
-                    if (response.getHeader("content-length") != null) {
-                        contentLenght = Integer.valueOf(response.getHeader("content-length"));
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        int contentLenght = -1;
+                        if (response.getHeader("content-length") != null) {
+                            contentLenght = Integer.valueOf(response.getHeader("content-length"));
+                        }
+                        int ct = connection.getContentLength();
+                        assertEquals(contentLenght, ct);
+                    } finally {
+                        l.countDown();
                     }
-                    int ct = connection.getContentLength();
-                    assertEquals(contentLenght, ct);
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
-            }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("Unexpected exception", t);
-                } finally {
-                    l.countDown();
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("Unexpected exception", t);
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }
 
+            }).get();
 
-        }).get();
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-
-        p.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncContentTypeGETTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getContentType(), UTF_8);
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getContentType(), UTF_8);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        p.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncHeaderGETTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getContentType(), UTF_8);
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getContentType(), UTF_8);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        n.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncHeaderPOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-        Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).setHeaders(h).build();
 
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    System.out.println(">>>>> " + response.getStatusText());
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        System.out.println(">>>>> " + response.getStatusText());
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        n.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncParamPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        for (int i = 0; i < 5; i++) {
-            m.put("param_" + i, Arrays.asList("value_" + i));
-        }
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).build();
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            for (int i = 0; i < 5; i++) {
+                m.put("param_" + i, Arrays.asList("value_" + i));
+            }
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                        }
+
+                    } finally {
+                        l.countDown();
                     }
-
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        n.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncStatusHEADTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
-        Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
+            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        try {
-            String s = response.getResponseBody();
-            Assert.assertEquals("",s);
-        } catch (IllegalStateException ex) {
-            fail();
-        }
+            try {
+                String s = response.getResponseBody();
+                Assert.assertEquals("", s);
+            } catch (IllegalStateException ex) {
+                fail();
+            }
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        n.close();
-
     }
 
     // TODO: fix test
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = false)
+    @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
     public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setRequestTimeoutInMs(120 * 1000).build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(120 * 1000).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
 
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD")
-                .setUrl(getTargetUrl())
-                .build();
+            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.fail();
+                    return response;
+                }
 
-        n.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.fail();
-                return response;
-            }
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        assertEquals(t.getClass(), IOException.class);
+                        assertEquals(t.getMessage(), "No response received. Connection timed out");
+                    } finally {
+                        l.countDown();
+                    }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    assertEquals(t.getClass(), IOException.class);
-                    assertEquals(t.getMessage(), "No response received. Connection timed out");
-                } finally {
-                    l.countDown();
                 }
+            }).get();
 
+            if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-
-        if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        n.close();
-
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
+    @Test(groups = { "online", "default_provider", "async" })
     public void asyncNullSchemeTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            c.prepareGet("www.sun.com").execute();
+            client.prepareGet("www.sun.com").execute();
             Assert.fail();
         } catch (IllegalArgumentException ex) {
             Assert.assertTrue(true);
         }
-        c.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetTransferEncodingTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch l = new CountDownLatch(1);
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
 
-        c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader("Transfer-Encoding"), "chunked");
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("Transfer-Encoding"), "chunked");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetHeadersTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-        c.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetCookieTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Test1", "Test1");
-        h.add("Test2", "Test2");
-        h.add("Test3", "Test3");
-        h.add("Test4", "Test4");
-        h.add("Test5", "Test5");
-
-        final Cookie coo = new Cookie("/", "foo", "value", "/", -1, false);
-        c.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    List<Cookie> cookies = response.getCookies();
-                    assertEquals(cookies.size(), 1);
-                    assertEquals(cookies.get(0).toString(), coo.toString());
-                } finally {
-                    l.countDown();
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Test1", "Test1");
+            h.add("Test2", "Test2");
+            h.add("Test3", "Test3");
+            h.add("Test4", "Test4");
+            h.add("Test5", "Test5");
+
+            final Cookie coo = new Cookie("/", "foo", "value", "/", -1, false);
+            client.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        List<Cookie> cookies = response.getCookies();
+                        assertEquals(cookies.size(), 1);
+                        assertEquals(cookies.get(0).toString(), coo.toString());
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostDefaultContentType() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            client.preparePost(getTargetUrl()).addParameter("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        c.preparePost(getTargetUrl()).addParameter("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    FluentCaseInsensitiveStringsMap h = response.getHeaders();
-                    assertEquals(h.getJoinedValue("X-Content-Type", ", "), "application/x-www-form-urlencoded");
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        FluentCaseInsensitiveStringsMap h = response.getHeaders();
+                        assertEquals(h.getJoinedValue("X-Content-Type", ", "), "application/x-www-form-urlencoded");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostBodyIsoTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        Response r = c.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
-        assertEquals(r.getResponseBody().getBytes("ISO-8859-1"),"\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
-        c.close();
-    }
-    
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostBytesTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
+            assertEquals(r.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
+        } finally {
+            client.close();
         }
-        sb.deleteCharAt(sb.length() - 1);
+    }
 
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostBytesTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
-            }
-        }).get();
+            }).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostInputStreamTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
+            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
 
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPutInputStreamTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
+            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-        c.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            client.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
 
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostEntityWriterTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+
+            final StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
+            byte[] bytes = sb.toString().getBytes();
+            h.add("Content-Length", String.valueOf(bytes.length));
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        final StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-        byte[] bytes = sb.toString().getBytes();
-        h.add("Content-Length", String.valueOf(bytes.length));
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(new Request.EntityWriter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(new Request.EntityWriter() {
 
-            /* @Override */
-            public void writeEntity(OutputStream out) throws IOException {
-                out.write(sb.toString().getBytes("UTF-8"));
-            }
-        }).execute(new AsyncCompletionHandlerAdapter() {
+                /* @Override */
+                public void writeEntity(OutputStream out) throws IOException {
+                    out.write(sb.toString().getBytes("UTF-8"));
+                }
+            }).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostMultiPartTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-
-        Part p = new StringPart("foo", "bar");
+            Part p = new StringPart("foo", "bar");
 
-        c.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    String xContentType = response.getHeader("X-Content-Type");
-                    String boundary = xContentType.substring(
-                            (xContentType.indexOf("boundary") + "boundary".length() + 1));
-
-                    String s = response.getResponseBodyExcerpt(boundary.length() + "--".length()).substring("--".length());
-                    assertEquals(boundary, s);
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        String xContentType = response.getHeader("X-Content-Type");
+                        String boundary = xContentType.substring((xContentType.indexOf("boundary") + "boundary".length() + 1));
+
+                        String s = response.getResponseBodyExcerpt(boundary.length() + "--".length()).substring("--".length());
+                        assertEquals(boundary, s);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostBasicGZIPTest() throws Throwable {
-
         AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
+        AsyncHttpClient client = getAsyncHttpClient(cf);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    assertEquals(response.getHeader("X-Accept-Encoding"), "gzip");
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Accept-Encoding"), "gzip");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            client.close();
         }
-        c.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostProxyTest() throws Throwable {
-
         AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build();
-        AsyncHttpClient c = getAsyncHttpClient(cf);
-
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        Response response = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
+        AsyncHttpClient client = getAsyncHttpClient(cf);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
             }
+            sb.deleteCharAt(sb.length() - 1);
 
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-        }).get();
+            Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
 
+                @Override
+                public void onThrowable(Throwable t) {
+                }
+            }).get();
 
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-Proxy-Connection"), "keep-alive");
-        c.close();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncRequestVirtualServerPOSTTest() throws Throwable {
-        AsyncHttpClient n = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            for (int i = 0; i < 5; i++) {
+                m.put("param_" + i, Arrays.asList("value_" + i));
+            }
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeaders(h).setParameters(m).setVirtualHost("localhost:" + port1).build();
 
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        for (int i = 0; i < 5; i++) {
-            m.put("param_" + i, Arrays.asList("value_" + i));
-        }
-        Request request = new RequestBuilder("POST")
-                .setUrl(getTargetUrl())
-                .setHeaders(h)
-                .setParameters(m)
-                .setVirtualHost("localhost:" + port1)
-                .build();
-
-        Response response = n.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
-
-        assertEquals(response.getStatusCode(), 200);
-        if (response.getHeader("X-Host").startsWith("localhost")) {
-            assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
-        } else {
-            assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
-        }
-        n.close();
+            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
 
+            assertEquals(response.getStatusCode(), 200);
+            if (response.getHeader("X-Host").startsWith("localhost")) {
+                assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
+            } else {
+                assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
+            }
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPutTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        Response response = c.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
-
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+            Response response = client.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
 
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostLatchBytesTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
-        }
-        sb.deleteCharAt(sb.length() - 1);
-
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                    for (int i = 1; i < 5; i++) {
-                        System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                        assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        for (int i = 1; i < 5; i++) {
+                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
+                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                        }
+                        return response;
+                    } finally {
+                        l.countDown();
                     }
-                    return response;
-                } finally {
-                    l.countDown();
                 }
-            }
-        });
+            });
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostDelayCancelTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
+            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public void onThrowable(Throwable t) {
+                }
+            });
 
-        Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter(){
-            @Override
-            public void onThrowable(Throwable t) {
-            }
-        });
-
-        // Make sure we are connected before cancelling. I know, Thread.sleep sucks!
-        Thread.sleep(1000);
-        future.cancel(true);
-        Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
-        Assert.assertNull(response);
-        c.close();
+            // Make sure we are connected before cancelling. I know, Thread.sleep
+            // sucks!
+            Thread.sleep(1000);
+            future.cancel(true);
+            Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
+            Assert.assertNull(response);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostDelayBytesTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
+            try {
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        t.printStackTrace();
+                    }
+                });
 
-        try {
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
+                future.get(10, TimeUnit.SECONDS);
+            } catch (ExecutionException ex) {
+                if (ex.getCause() != null && TimeoutException.class.isAssignableFrom(ex.getCause().getClass())) {
+                    Assert.assertTrue(true);
                 }
-            });
-
-            future.get(10, TimeUnit.SECONDS);
-        } catch (ExecutionException ex) {            
-            if (ex.getCause() != null && TimeoutException.class.isAssignableFrom(ex.getCause().getClass())) {
+            } catch (TimeoutException te) {
                 Assert.assertTrue(true);
+            } catch (IllegalStateException ex) {
+                Assert.assertTrue(false);
             }
-        } catch (TimeoutException te) {
-            Assert.assertTrue(true);
-        } catch (IllegalStateException ex) {
-            Assert.assertTrue(false);
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostNullBytesTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
+            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
+
+            Response response = future.get();
+            Assert.assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
         }
-        sb.deleteCharAt(sb.length() - 1);
+    }
 
-        Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncDoPostListenerBytesTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < 5; i++) {
+                sb.append("param_");
+                sb.append(i);
+                sb.append("=value_");
+                sb.append(i);
+                sb.append("&");
+            }
+            sb.deleteCharAt(sb.length() - 1);
 
-        Response response = future.get();
-        Assert.assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+            final CountDownLatch l = new CountDownLatch(1);
 
-    }
+            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            });
 
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncDoPostListenerBytesTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < 5; i++) {
-            sb.append("param_");
-            sb.append(i);
-            sb.append("=value_");
-            sb.append(i);
-            sb.append("&");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Latch time out");
+            }
+        } finally {
+            client.close();
         }
-        sb.deleteCharAt(sb.length() - 1);
-
-        final CountDownLatch l = new CountDownLatch(1);
+    }
 
-        c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidFuture() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            int dummyPort = findFreePort();
+            final AtomicInteger count = new AtomicInteger();
+            for (int i = 0; i < 20; i++) {
                 try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
+                    Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                        /* @Override */
+                        public void onThrowable(Throwable t) {
+                            count.incrementAndGet();
+                        }
+                    }).get();
+                    assertNull(response, "Should have thrown ExecutionException");
+                } catch (ExecutionException ex) {
+                    Throwable cause = ex.getCause();
+                    if (!(cause instanceof ConnectException)) {
+                        fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
+                    }
                 }
-                return response;
             }
-        });
+            assertEquals(count.get(), 20);
+        } finally {
+            client.close();
+        }
+    }
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Latch time out");
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidPortFuture() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            int dummyPort = findFreePort();
+            try {
+                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        t.printStackTrace();
+                    }
+                }).get();
+                assertNull(response, "Should have thrown ExecutionException");
+            } catch (ExecutionException ex) {
+                Throwable cause = ex.getCause();
+                if (!(cause instanceof ConnectException)) {
+                    fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
+                }
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidFuture() throws Throwable {
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidPort() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // pick a random unused local port
+            int port = findFreePort();
 
-        int dummyPort = findFreePort();
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicInteger count = new AtomicInteger();
-        for (int i = 0; i < 20; i++) {
             try {
-                Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     /* @Override */
                     public void onThrowable(Throwable t) {
-                        count.incrementAndGet();
+                        t.printStackTrace();
                     }
                 }).get();
-                assertNull(response, "Should have thrown ExecutionException");
+                assertNull(response, "No ExecutionException was thrown");
             } catch (ExecutionException ex) {
-                Throwable cause = ex.getCause();
-                if (!(cause instanceof ConnectException)) {
-                    fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
-                }
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
             }
+        } finally {
+            client.close();
         }
-        assertEquals(count.get(), 20);
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidPortFuture() throws Throwable {
-
-        int dummyPort = findFreePort();
-        AsyncHttpClient c = getAsyncHttpClient(null);
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidHandlerPort() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+            final CountDownLatch l = new CountDownLatch(1);
+            int port = findFreePort();
+
+            client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                 /* @Override */
                 public void onThrowable(Throwable t) {
-                    t.printStackTrace();
+                    try {
+                        assertEquals(t.getClass(), ConnectException.class);
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }).get();
-            assertNull(response, "Should have thrown ExecutionException");
-        } catch (ExecutionException ex) {
-            Throwable cause = ex.getCause();
-            if (!(cause instanceof ConnectException)) {
-                fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
+            });
+
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
             }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        // pick a random unused local port
-        int port = findFreePort();
-
+    @Test(groups = { "online", "default_provider", "async" })
+    public void asyncConnectInvalidHandlerHost() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            client.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
                 /* @Override */
                 public void onThrowable(Throwable t) {
-                    t.printStackTrace();
+                    if (t != null) {
+                        if (t.getClass().equals(ConnectException.class)) {
+                            l.countDown();
+                        } else if (t.getClass().equals(UnresolvedAddressException.class)) {
+                            l.countDown();
+                        }
+                    }
                 }
-            }).get();
-            assertNull(response, "No ExecutionException was thrown");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        }
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidHandlerPort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        int port = findFreePort();
+            });
 
-        c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                try {
-                    assertEquals(t.getClass(), ConnectException.class);
-                } finally {
-                    l.countDown();
-                }
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
             }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
-    public void asyncConnectInvalidHandlerHost() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-
-        c.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                if (t != null) {
-                    if (t.getClass().equals(ConnectException.class)) {
-                        l.countDown();
-                    } else if (t.getClass().equals(UnresolvedAddressException.class)) {
-                        l.countDown();
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncConnectInvalidFuturePort() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final AtomicBoolean called = new AtomicBoolean(false);
+            final AtomicBoolean rightCause = new AtomicBoolean(false);
+            // pick a random unused local port
+            int port = findFreePort();
+
+            try {
+                Response response = client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        called.set(true);
+                        if (t instanceof ConnectException) {
+                            rightCause.set(true);
+                        }
                     }
-                }
+                }).get();
+                assertNull(response, "No ExecutionException was thrown");
+            } catch (ExecutionException ex) {
+                assertEquals(ex.getCause().getClass(), ConnectException.class);
             }
-        });
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            assertTrue(called.get(), "onThrowable should get called.");
+            assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncConnectInvalidFuturePort() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        final AtomicBoolean called = new AtomicBoolean(false);
-        final AtomicBoolean rightCause = new AtomicBoolean(false);
-        // pick a random unused local port
-        int port = findFreePort();
-
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void asyncContentLenghtGETTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+
                 @Override
                 public void onThrowable(Throwable t) {
-                    called.set(true);
-                    if (t instanceof ConnectException) {
-                        rightCause.set(true);
-                    }
+                    Assert.fail("Unexpected exception", t);
                 }
             }).get();
-            assertNull(response, "No ExecutionException was thrown");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        }
-        assertTrue(called.get(), "onThrowable should get called.");
-        assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
-        c.close();
-    }
-
-    @Test(groups = {"standalone", "default_provider", "async"})
-    public void asyncContentLenghtGETTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
 
-        Assert.assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+            Assert.assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncResponseBodyTooLarge() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response response = client.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("Unexpected exception", t);
+                }
+            }).get();
 
-        Assert.assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
-        c.close();
+            Assert.assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncResponseEmptyBody() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        Response response = c.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("Unexpected exception", t);
-            }
-        }).get();
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("Unexpected exception", t);
+                }
+            }).get();
 
-        assertEquals(response.getResponseBody(),"");
-        c.close();
+            assertEquals(response.getResponseBody(), "");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider", "asyncAPI"})
+    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
     public void asyncAPIContentLenghtGETTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    assertEquals(response.getStatusCode(), 200);
-                } finally {
-                    l.countDown();
+                @Override
+                public void onThrowable(Throwable t) {
                 }
-                return response;
-            }
+            });
 
-            @Override
-            public void onThrowable(Throwable t) {
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
             }
-        });
-
-
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "asyncAPI"})
+    @Test(groups = { "standalone", "default_provider", "asyncAPI" })
     public void asyncAPIHandlerExceptionTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                throw new IllegalStateException("FOO");
-            }
+            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    throw new IllegalStateException("FOO");
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t.getMessage() != null) {
-                        assertEquals(t.getMessage(), "FOO");
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t.getMessage() != null) {
+                            assertEquals(t.getMessage(), "FOO");
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
                 }
-            }
-        });
-
+            });
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetDelayHandlerTest() throws Throwable {
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("LockThread", "true");
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(5 * 1000).build());
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("LockThread", "true");
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
 
-        client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
+            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    Assert.fail("Must not receive a response");
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        Assert.fail("Must not receive a response");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t instanceof TimeoutException) {
-                        Assert.assertTrue(true);
-                    } else {
-                        Assert.fail("Unexpected exception", t);
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t instanceof TimeoutException) {
+                            Assert.assertTrue(true);
+                        } else {
+                            Assert.fail("Unexpected exception", t);
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
                 }
-            }
-        });
+            });
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
-
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetQueryStringTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    Assert.assertTrue(response.getHeader("X-pathInfo") != null);
-                    Assert.assertTrue(response.getHeader("X-queryString") != null);
-                } finally {
-                    l.countDown();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        Assert.assertTrue(response.getHeader("X-pathInfo") != null);
+                        Assert.assertTrue(response.getHeader("X-queryString") != null);
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
                 }
-                return response;
-            }
-        };
+            };
 
-        Request req = new RequestBuilder("GET")
-                .setUrl(getTargetUrl() + "?foo=bar").build();
+            Request req = new RequestBuilder("GET").setUrl(getTargetUrl() + "?foo=bar").build();
 
-        client.executeRequest(req, handler).get();
+            client.executeRequest(req, handler).get();
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetKeepAliveHandlerTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+                String remoteAddr = null;
 
-            String remoteAddr = null;
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    assertEquals(response.getStatusCode(), 200);
+                    if (remoteAddr == null) {
+                        remoteAddr = response.getHeader("X-KEEP-ALIVE");
+                        l.countDown();
+                    } else {
+                        assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
+                        l.countDown();
+                    }
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                assertEquals(response.getStatusCode(), 200);
-                if (remoteAddr == null) {
-                    remoteAddr = response.getHeader("X-KEEP-ALIVE");
-                    l.countDown();
-                } else {
-                    assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
-                    l.countDown();
+                    return response;
                 }
+            };
 
-                return response;
-            }
-        };
-
-        client.prepareGet(getTargetUrl()).execute(handler).get();
-        client.prepareGet(getTargetUrl()).execute(handler);
+            client.prepareGet(getTargetUrl()).execute(handler).get();
+            client.prepareGet(getTargetUrl()).execute(handler);
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
+    @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetMaxRedirectTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaximumNumberOfRedirects(0).setFollowRedirects(true).build());
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(1);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(1);
-
-        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.fail("Should not be here");
-                return response;
-            }
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.fail("Should not be here");
+                    return response;
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                try {
-                    assertEquals(t.getClass(), MaxRedirectException.class);
-                } finally {
-                    l.countDown();
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    try {
+                        assertEquals(t.getClass(), MaxRedirectException.class);
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }
-        };
+            };
 
-        client.prepareGet("http://google.com/").execute(handler);
+            client.prepareGet("http://google.com/").execute(handler);
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
+    @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetNestedTest() throws Throwable {
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
-
-        final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
+            final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
 
-            private final static int MAX_NESTED = 2;
+                private final static int MAX_NESTED = 2;
 
-            private AtomicInteger nestedCount = new AtomicInteger(0);
+                private AtomicInteger nestedCount = new AtomicInteger(0);
 
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                try {
-                    if (nestedCount.getAndIncrement() < MAX_NESTED) {
-                        System.out.println("Executing a nested request: " + nestedCount);
-                        client.prepareGet("http://google.com/").execute(this);
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        if (nestedCount.getAndIncrement() < MAX_NESTED) {
+                            System.out.println("Executing a nested request: " + nestedCount);
+                            client.prepareGet("http://google.com/").execute(this);
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
+                    return response;
                 }
-                return response;
-            }
-
-            @Override
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-            }
-        };
 
+                @Override
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+            };
 
-        client.prepareGet("http://www.google.com/").execute(handler);
+            client.prepareGet("http://www.google.com/").execute(handler);
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
+    @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetStreamAndBodyTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet("http://www.google.com/").execute().get();
-
-        r.getResponseBody();
-        r.getResponseBodyAsStream();
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            Response r = client.prepareGet("http://www.google.com/").execute().get();
 
-        client.close();
+            r.getResponseBody();
+            r.getResponseBodyAsStream();
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider", "async"})
+    @Test(groups = { "online", "default_provider", "async" })
     public void asyncUrlWithoutPathTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet("http://www.google.com").execute().get();
-
-        r.getResponseBody();
-        r.getResponseBodyAsStream();
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            Response r = client.prepareGet("http://www.google.com").execute().get();
 
-        client.close();
+            r.getResponseBody();
+            r.getResponseBodyAsStream();
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"default_provider", "async"})
+    @Test(groups = { "default_provider", "async" })
     public void optionsTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareOptions(getTargetUrl()).execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            Response r = client.prepareOptions(getTargetUrl()).execute().get();
 
-        client.close();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testAwsS3() throws Exception {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().build());
-        Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-        if (!isNonEmpty(response.getResponseBody())) {
-            fail("No response Body");
-        } else {
-            assertEquals(response.getStatusCode(), 403);
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            if (!isNonEmpty(response.getResponseBody())) {
+                fail("No response Body");
+            } else {
+                assertEquals(response.getStatusCode(), 403);
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testAsyncHttpProviderConfig() throws Exception {
 
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
-        Response response = c.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-        if (!isNonEmpty(response.getResponseBody())) {
-            fail("No response Body");
-        } else {
-            assertEquals(response.getStatusCode(), 403);
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
+        try {
+            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
+            if (!isNonEmpty(response.getResponseBody())) {
+                fail("No response Body");
+            } else {
+                assertEquals(response.getStatusCode(), 403);
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void idleRequestTimeoutTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(5000).setRequestTimeoutInMs(10000).build());
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-
-        long t1 = System.currentTimeMillis();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(5000).setRequestTimeoutInMs(10000).build());
         try {
-            c.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
 
-                /* @Override */
-                public void onThrowable(Throwable t) {
-//                    t.printStackTrace();
-                }
+            long t1 = System.currentTimeMillis();
+            try {
+                client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
-            }).get();
-            Assert.fail();
-        } catch (Throwable ex) {
-            final long elapsedTime = System.currentTimeMillis() - t1;
-            System.out.println("EXPIRED: " + (elapsedTime));
-            Assert.assertNotNull(ex.getCause());
-            Assert.assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        // t.printStackTrace();
+                    }
+
+                }).get();
+                Assert.fail();
+            } catch (Throwable ex) {
+                final long elapsedTime = System.currentTimeMillis() - t1;
+                System.out.println("EXPIRED: " + (elapsedTime));
+                Assert.assertNotNull(ex.getCause());
+                Assert.assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"})
+    @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostCancelTest() throws Throwable {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        h.add("LockThread", "true");
-        StringBuilder sb = new StringBuilder();
-        sb.append("LockThread=true");
-
-        final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
-        ex.set(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            Future<Response> future = c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            h.add("LockThread", "true");
+            StringBuilder sb = new StringBuilder();
+            sb.append("LockThread=true");
+
+            final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
+            ex.set(null);
+            try {
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    if (t instanceof CancellationException) {
-                        ex.set((CancellationException)t);
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        if (t instanceof CancellationException) {
+                            ex.set((CancellationException) t);
+                        }
+                        t.printStackTrace();
                     }
-                    t.printStackTrace();
-                }
-                
-            });
 
-            Thread.sleep(1000);
-            future.cancel(true);
-        } catch (IllegalStateException ise) {
-            fail();
+                });
+
+                Thread.sleep(1000);
+                future.cancel(true);
+            } catch (IllegalStateException ise) {
+                fail();
+            }
+            Assert.assertNotNull(ex.get());
+        } finally {
+            client.close();
         }
-        Assert.assertNotNull(ex.get());
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, expectedExceptions = IllegalArgumentException.class)
+    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = IllegalArgumentException.class)
     public void getShouldNotAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
+            AsyncHttpClient.BoundRequestBuilder builder = client.prepareGet(getTargetUrl());
             builder.setBody("Boo!");
             builder.execute();
         } finally {
-            c.close();
+            client.close();
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"}, expectedExceptions = IllegalArgumentException.class)
+    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = IllegalArgumentException.class)
     public void headShouldNotAllowBody() throws IllegalArgumentException, IOException {
-        AsyncHttpClient c = getAsyncHttpClient(null);
+        AsyncHttpClient client = getAsyncHttpClient(null);
         try {
-            AsyncHttpClient.BoundRequestBuilder builder = c.prepareHead(getTargetUrl());
+            AsyncHttpClient.BoundRequestBuilder builder = client.prepareHead(getTargetUrl());
             builder.setBody("Boo!");
             builder.execute();
         } finally {
-            c.close();
+            client.close();
         }
     }
 
@@ -1594,45 +1677,55 @@ protected String getBrokenTargetUrl() {
         return String.format("http:127.0.0.1:%d/foo/test", port1);
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void invalidUri() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getBrokenTargetUrl());
-        Response r = c.executeRequest(builder.build()).get();
-        assertEquals(200, r.getStatusCode());
-        c.close();
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = client.prepareGet(getBrokenTargetUrl());
+            Response r = client.executeRequest(builder.build()).get();
+            assertEquals(200, r.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncHttpClientConfigBeanTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
-        AsyncHttpClient.BoundRequestBuilder builder = c.prepareGet(getTargetUrl());
-        Response r = c.executeRequest(builder.build()).get();
-        assertEquals(200, r.getStatusCode());
-        c.close();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
+        try {
+            AsyncHttpClient.BoundRequestBuilder builder = client.prepareGet(getTargetUrl());
+            Response r = client.executeRequest(builder.build()).get();
+            assertEquals(200, r.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"default_provider", "async"})
+    @Test(groups = { "default_provider", "async" })
     public void bodyAsByteTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
-        Response r = client.prepareGet(getTargetUrl()).execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getResponseBodyAsBytes(), new byte[]{});
+        AsyncHttpClient client = getAsyncHttpClient(new Builder().build());
+        try {
+            Response r = client.prepareGet(getTargetUrl()).execute().get();
 
-        client.close();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getResponseBodyAsBytes(), new byte[] {});
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"default_provider", "async"})
+    @Test(groups = { "default_provider", "async" })
     public void mirrorByteTest() throws Throwable {
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Response r = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
-
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(new String(r.getResponseBodyAsBytes(), "UTF-8"), "MIRROR");
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        try {
+            Response r = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
 
-        client.close();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(new String(r.getResponseBodyAsBytes(), "UTF-8"), "MIRROR");
+        } finally {
+            client.close();
+        }
     }
 
-    protected abstract AsyncHttpProviderConfig getProviderConfig();
+    protected abstract AsyncHttpProviderConfig<?, ?> getProviderConfig();
 }
diff --git a/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java b/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
index 3e58bc887..00c1f0072 100644
--- a/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/AsyncStreamHandlerTest.java
@@ -40,516 +40,543 @@
     private final static String RESPONSE = "param_1_";
     private final static String UTF8 = "text/html;charset=utf-8";
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamGETTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                try {
-                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                    Assert.assertNotNull(h);
-                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                    return STATE.ABORT;
-                } finally {
-                    l.countDown();
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    try {
+                        FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                        Assert.assertNotNull(h);
+                        Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                        return STATE.ABORT;
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("", t);
-                } finally {
-                    l.countDown();
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("", t);
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }
-        });
+            });
 
-        if (!l.await(5, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamPOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            m.put("param_1", Arrays.asList("value_1"));
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+            client.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
 
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
                 }
-            }
-        });
 
-        if (!l.await(10, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(10, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamInterruptTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            m.put("param_1", Arrays.asList("value_1"));
 
-        final AtomicBoolean a = new AtomicBoolean(true);
-        AsyncHttpClient c = getAsyncHttpClient(null);
+            final AtomicBoolean a = new AtomicBoolean(true);
 
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+            client.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
 
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.ABORT;
-            }
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.ABORT;
+                }
 
-            @Override
-            public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                a.set(false);
-                Assert.fail("Interrupted not working");
-                return STATE.ABORT;
-            }
+                @Override
+                public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                    a.set(false);
+                    Assert.fail("Interrupted not working");
+                    return STATE.ABORT;
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                try {
-                    Assert.fail("", t);
-                } finally {
-                    l.countDown();
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        Assert.fail("", t);
+                    } finally {
+                        l.countDown();
+                    }
                 }
-            }
-        });
+            });
 
-        l.await(5, TimeUnit.SECONDS);
-        Assert.assertTrue(a.get());
-        c.close();
+            l.await(5, TimeUnit.SECONDS);
+            Assert.assertTrue(a.get());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamFutureTest() throws Throwable {
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Future<String> f = c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            m.put("param_1", Arrays.asList("value_1"));
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+            Future<String> f = client.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
 
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString().trim();
-                Assert.assertEquals(r, RESPONSE);
-                return r;
-            }
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                Assert.fail("", t);
-            }
-        });
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
 
-        try {
-            String r = f.get(5, TimeUnit.SECONDS);
-            Assert.assertNotNull(r);
-            Assert.assertEquals(r.trim(), RESPONSE);
-        } catch (TimeoutException ex) {
-            Assert.fail();
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString().trim();
+                    Assert.assertEquals(r, RESPONSE);
+                    return r;
+                }
+
+                @Override
+                public void onThrowable(Throwable t) {
+                    Assert.fail("", t);
+                }
+            });
+
+            try {
+                String r = f.get(5, TimeUnit.SECONDS);
+                Assert.assertNotNull(r);
+                Assert.assertEquals(r.trim(), RESPONSE);
+            } catch (TimeoutException ex) {
+                Assert.fail();
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamThrowableRefusedTest() throws Throwable {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
 
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                throw new RuntimeException("FOO");
-            }
+            client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
-            @Override
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    throw new RuntimeException("FOO");
+                }
 
-            public void onThrowable(Throwable t) {
-                try {
-                    if (t.getMessage() != null) {
-                        Assert.assertEquals(t.getMessage(), "FOO");
+                @Override
+                public void onThrowable(Throwable t) {
+                    try {
+                        if (t.getMessage() != null) {
+                            Assert.assertEquals(t.getMessage(), "FOO");
+                        }
+                    } finally {
+                        l.countDown();
                     }
-                } finally {
-                    l.countDown();
                 }
-            }
-        });
-
+            });
 
-        if (!l.await(10, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            if (!l.await(10, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamReusePOSTTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
-
-        Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
-        m.put("param_1", Arrays.asList("value_1"));
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+            Map<String, Collection<String>> m = new HashMap<String, Collection<String>>();
+            m.put("param_1", Arrays.asList("value_1"));
 
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
+            client.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
+
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
                 }
 
-            }
-        });
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
 
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
-        }
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
 
-        // Let do the same again
-        c.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
+                }
+            });
 
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
-                return STATE.CONTINUE;
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+            // Let do the same again
+            client.preparePost(getTargetUrl()).setParameters(m).execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
 
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    String r = builder.toString().trim();
-                    Assert.assertEquals(r, RESPONSE);
-                    return r;
-                } finally {
-                    l.countDown();
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), UTF8);
+                    return STATE.CONTINUE;
                 }
-            }
-        });
 
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        String r = builder.toString().trim();
+                        Assert.assertEquals(r, RESPONSE);
+                        return r;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void asyncStream301WithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), "text/html; charset=utf-8");
-                return STATE.CONTINUE;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            client.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(), "text/html; charset=utf-8");
+                    return STATE.CONTINUE;
+                }
 
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString();
-                Assert.assertTrue(r.contains("301 Moved"));
-                l.countDown();
-                return r;
-            }
-        });
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
+
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString();
+                    Assert.assertTrue(r.contains("301 Moved"));
+                    l.countDown();
+                    return r;
+                }
+            });
 
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void asyncStream301RedirectWithBody() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-            private StringBuilder builder = new StringBuilder();
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                Assert.assertEquals(h.getFirstValue( "server" ), "gws");
-                // This assertion below is not an invariant, since implicitly contains locale-dependant settings
-                // and fails when run in country having own localized Google site and it's locale relies on something
-                // other than ISO-8859-1.
-                // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
-                // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
-                // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
-                //
-                // Assert.assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
-                return STATE.CONTINUE;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            client.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
+                private StringBuilder builder = new StringBuilder();
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.append(new String(content.getBodyPartBytes()));
-                return STATE.CONTINUE;
-            }
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    Assert.assertEquals(h.getFirstValue("server"), "gws");
+                    // This assertion below is not an invariant, since implicitly contains locale-dependant settings
+                    // and fails when run in country having own localized Google site and it's locale relies on something
+                    // other than ISO-8859-1.
+                    // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
+                    // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
+                    // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
+                    //
+                    // Assert.assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
+                    return STATE.CONTINUE;
+                }
 
-            @Override
-            public String onCompleted() throws Exception {
-                String r = builder.toString();
-                Assert.assertTrue(!r.contains("301 Moved"));
-                l.countDown();
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.append(new String(content.getBodyPartBytes()));
+                    return STATE.CONTINUE;
+                }
 
-                return r;
-            }
-        });
+                @Override
+                public String onCompleted() throws Exception {
+                    String r = builder.toString();
+                    Assert.assertTrue(!r.contains("301 Moved"));
+                    l.countDown();
 
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+                    return r;
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
+    @Test(groups = { "standalone", "default_provider" }, timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
     public void asyncStreamJustStatusLine() throws Throwable {
-        final int STATUS = 0;
-        final int COMPLETED = 1;
-        final int OTHER = 2;
-        final boolean[] whatCalled = new boolean[]{false, false, false};
-        final CountDownLatch latch = new CountDownLatch(1);
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
-            private int status = -1;
+        try {
+            final int STATUS = 0;
+            final int COMPLETED = 1;
+            final int OTHER = 2;
+            final boolean[] whatCalled = new boolean[] { false, false, false };
+            final CountDownLatch latch = new CountDownLatch(1);
+            Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
+                private int status = -1;
+
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-            }
+                /* @Override */
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
 
-            /* @Override */
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-                return STATE.ABORT;
-            }
+                /* @Override */
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    whatCalled[STATUS] = true;
+                    System.out.println(responseStatus);
+                    status = responseStatus.getStatusCode();
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
 
-            /* @Override */
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                whatCalled[STATUS] = true;
-                System.out.println(responseStatus);
-                status = responseStatus.getStatusCode();
-                latch.countDown();
-                return STATE.ABORT;
-            }
+                /* @Override */
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    whatCalled[OTHER] = true;
+                    latch.countDown();
+                    return STATE.ABORT;
+                }
 
-            /* @Override */
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                whatCalled[OTHER] = true;
-                latch.countDown();
-                return STATE.ABORT;
-            }
+                /* @Override */
+                public Integer onCompleted() throws Exception {
+                    whatCalled[COMPLETED] = true;
+                    latch.countDown();
+                    return status;
+                }
+            });
 
-            /* @Override */
-            public Integer onCompleted() throws Exception {
-                whatCalled[COMPLETED] = true;
-                latch.countDown();
-                return status;
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout");
+                return;
             }
-        });
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout");
-            return;
-        }
-        Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-        Assert.assertEquals((int) status, 200, "Expected status code failed.");
+            Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
+            Assert.assertEquals((int) status, 200, "Expected status code failed.");
 
-        if (!whatCalled[STATUS]) {
-            Assert.fail("onStatusReceived not called.");
-        }
-        if (!whatCalled[COMPLETED]) {
-            Assert.fail("onCompleted not called.");
-        }
-        if (whatCalled[OTHER]) {
-            Assert.fail("Other method of AsyncHandler got called.");
+            if (!whatCalled[STATUS]) {
+                Assert.fail("onStatusReceived not called.");
+            }
+            if (!whatCalled[COMPLETED]) {
+                Assert.fail("onCompleted not called.");
+            }
+            if (whatCalled[OTHER]) {
+                Assert.fail("Other method of AsyncHandler got called.");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void asyncOptionsTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
-
-            @Override
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                FluentCaseInsensitiveStringsMap h = content.getHeaders();
-                Assert.assertNotNull(h);
-                String result = h.getJoinedValue("Allow", ", ");
-                String[] resultParts = result.split(",");
-                String[] expected = "OPTIONS,GET,HEAD,POST,TRACE".split(",");
-                Arrays.sort(resultParts);
-                Arrays.sort(expected);
-                Assert.assertEquals(expected, resultParts);
-                return STATE.ABORT;
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                return STATE.CONTINUE;
-            }
+                @Override
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    FluentCaseInsensitiveStringsMap h = content.getHeaders();
+                    Assert.assertNotNull(h);
+                    String result = h.getJoinedValue("Allow", ", ");
+                    String[] resultParts = result.split(",");
+                    String[] expected = "OPTIONS,GET,HEAD,POST,TRACE".split(",");
+                    Arrays.sort(resultParts);
+                    Arrays.sort(expected);
+                    Assert.assertEquals(expected, resultParts);
+                    return STATE.ABORT;
+                }
 
-            @Override
-            public String onCompleted() throws Exception {
-                try {
-                    return "OK";
-                } finally {
-                    l.countDown();
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    return STATE.CONTINUE;
                 }
-            }
-        });
 
-        if (!l.await(20, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+                @Override
+                public String onCompleted() throws Exception {
+                    try {
+                        return "OK";
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            });
+
+            if (!l.await(20, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void closeConnectionTest() throws Throwable {
-        final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
 
-            private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-            public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                builder.accumulate(content);
-                return STATE.CONTINUE;
-            }
+                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                    builder.accumulate(content);
+                    return STATE.CONTINUE;
+                }
 
-            public void onThrowable(Throwable t) {
-            }
+                public void onThrowable(Throwable t) {
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                builder.accumulate(content);
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    builder.accumulate(content);
 
-                if (content.isLast()) {
-                    content.markUnderlyingConnectionAsClosed();
+                    if (content.isLast()) {
+                        content.markUnderlyingConnectionAsClosed();
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                builder.accumulate(responseStatus);
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
 
-                return STATE.CONTINUE;
-            }
+                    return STATE.CONTINUE;
+                }
 
-            public Response onCompleted() throws Exception {
-                return builder.build();
-            }
-        }).get();
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get();
 
-        Assert.assertNotNull(r);
-        Assert.assertEquals(r.getStatusCode(), 200);
-        c.close();
+            Assert.assertNotNull(r);
+            Assert.assertEquals(r.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java b/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java
index 3208972a2..d12e647e5 100644
--- a/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java
+++ b/src/test/java/com/ning/http/client/async/AsyncStreamLifecycleTest.java
@@ -47,7 +47,7 @@
 
 /**
  * Tests default asynchronous life cycle.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class AsyncStreamLifecycleTest extends AbstractBasicTest {
@@ -63,8 +63,7 @@ public void tearDownGlobal() throws Exception {
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
-            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
                 resp.setContentType("text/plain;charset=utf-8");
                 resp.setStatus(200);
                 final Continuation continuation = ContinuationSupport.getContinuation(req);
@@ -100,62 +99,64 @@ public void run() {
         };
     }
 
-    //TODO Netty only.
+    // TODO Netty only.
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testStream() throws IOException {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final AtomicBoolean err = new AtomicBoolean(false);
-        final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
-        final AtomicBoolean status = new AtomicBoolean(false);
-        final AtomicInteger headers = new AtomicInteger(0);
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-            public void onThrowable(Throwable t) {
-                fail("Got throwable.", t);
-                err.set(true);
-            }
+        AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            client.executeRequest(client.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                String s = new String(e.getBodyPartBytes());
-                log.info("got part: {}", s);
-                if (s.isEmpty()) {
-                    //noinspection ThrowableInstanceNeverThrown
-                    log.warn("Sampling stacktrace.",
-                            new Throwable("trace that, we should not get called for empty body."));
+                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    String s = new String(e.getBodyPartBytes());
+                    log.info("got part: {}", s);
+                    if (s.isEmpty()) {
+                        // noinspection ThrowableInstanceNeverThrown
+                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    }
+                    queue.put(s);
+                    return STATE.CONTINUE;
                 }
-                queue.put(s);
-                return STATE.CONTINUE;
-            }
 
-            public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
-                status.set(true);
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
-                if (headers.incrementAndGet() == 2) {
-                    throw new Exception("Analyze this.");
+                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public Object onCompleted() throws Exception {
-                latch.countDown();
-                return null;
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            try {
+                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
             }
-        });
-        try {
-            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
+            assertFalse(err.get());
+            assertEquals(queue.size(), 2);
+            assertTrue(queue.contains("part1"));
+            assertTrue(queue.contains("part2"));
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
+        } finally {
+            client.close();
         }
-        assertFalse(err.get());
-        assertEquals(queue.size(), 2);
-        assertTrue(queue.contains("part1"));
-        assertTrue(queue.contains("part2"));
-        assertTrue(status.get());
-        assertEquals(headers.get(), 1);
-        ahc.close();
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java b/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java
index 37b83eff8..b5a4c9961 100644
--- a/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java
+++ b/src/test/java/com/ning/http/client/async/AuthTimeoutTest.java
@@ -39,7 +39,6 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -50,8 +49,7 @@
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
-public abstract class AuthTimeoutTest
-        extends AbstractBasicTest {
+public abstract class AuthTimeoutTest extends AbstractBasicTest {
 
     private final static String user = "user";
 
@@ -59,8 +57,7 @@
 
     protected AsyncHttpClient client;
 
-    public void setUpServer(String auth)
-            throws Exception {
+    public void setUpServer(String auth) throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
@@ -79,7 +76,7 @@ public void setUpServer(String auth)
 
         Constraint constraint = new Constraint();
         constraint.setName(auth);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -106,10 +103,8 @@ public void setUpServer(String auth)
         log.info("Local HTTP server started successfully");
     }
 
-    private class SimpleHandler
-            extends AbstractHandler {
-        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response)
-                throws IOException, ServletException {
+    private class SimpleHandler extends AbstractHandler {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             // NOTE: handler sends less bytes than are given in Content-Length, which should lead to timeout
 
@@ -129,150 +124,138 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(false);
         try {
-            f.get();
-            fail("expected timeout");
-        }
-        catch (Exception e) {
-            inspectException(e);
+            Future<Response> f = execute(false);
+            try {
+                f.get();
+                fail("expected timeout");
+            } catch (Exception e) {
+                inspectException(e);
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicPreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicPreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(true);
         try {
-            f.get();
-            fail("expected timeout");
-        }
-        catch (Exception e) {
-            inspectException(e);
+            Future<Response> f = execute(true);
+            try {
+                f.get();
+                fail("expected timeout");
+            } catch (Exception e) {
+                inspectException(e);
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
-
-        Future<Response> f = execute(false);
         try {
-            f.get();
-            fail("expected timeout");
-        }
-        catch (Exception e) {
-            inspectException(e);
+            Future<Response> f = execute(false);
+            try {
+                f.get();
+                fail("expected timeout");
+            } catch (Exception e) {
+                inspectException(e);
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestPreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestPreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get();
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicFutureAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicFutureAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void basicFuturePreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__BASIC_AUTH);
-
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestFutureAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestFutureAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
-
-        Future<Response> f = execute(false);
         try {
+            Future<Response> f = execute(false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = false)
-    public void digestFuturePreemptiveAuthTimeoutTest()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
+    public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
         setUpServer(Constraint.__DIGEST_AUTH);
 
-        Future<Response> f = execute(true);
         try {
+            Future<Response> f = execute(true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             inspectException(e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     protected void inspectException(Throwable t) {
         assertNotNull(t.getCause());
         assertEquals(t.getCause().getClass(), IOException.class);
-        if (!t.getCause().getMessage().startsWith("Remotely Closed")){
+        if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
             fail();
-        };
+        }
+        ;
     }
 
-    protected Future<Response> execute(boolean preemptive)
-            throws IOException {
-        client =
-                getAsyncHttpClient(
-                        new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).setConnectionTimeoutInMs(20000).setRequestTimeoutInMs(2000).build());
-        AsyncHttpClient.BoundRequestBuilder r =
-                client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content",
-                        "Test");
+    protected Future<Response> execute(boolean preemptive) throws IOException {
+        client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).setConnectionTimeoutInMs(20000).setRequestTimeoutInMs(2000).build());
+        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm(realm(preemptive)).setHeader("X-Content", "Test");
         Future<Response> f = r.execute();
         return f;
     }
@@ -287,8 +270,7 @@ protected String getTargetUrl() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new SimpleHandler();
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/BasicAuthTest.java b/src/test/java/com/ning/http/client/async/BasicAuthTest.java
index bbdefbd3e..4c7aec83e 100644
--- a/src/test/java/com/ning/http/client/async/BasicAuthTest.java
+++ b/src/test/java/com/ning/http/client/async/BasicAuthTest.java
@@ -54,7 +54,6 @@
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -62,7 +61,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
@@ -81,8 +79,7 @@ public void setUpGlobal() throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(
-                new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
+        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
 
         port1 = findFreePort();
         Connector listener = new SelectChannelConnector();
@@ -97,7 +94,7 @@ public void setUpGlobal() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -136,8 +133,7 @@ private String getFileContent(final File file) {
                 }
                 return sb.toString();
             }
-            throw new IllegalArgumentException("File does not exist or cannot be read: "
-                    + file.getCanonicalPath());
+            throw new IllegalArgumentException("File does not exist or cannot be read: " + file.getCanonicalPath());
         } catch (IOException ioe) {
             throw new IllegalStateException(ioe);
         } finally {
@@ -166,7 +162,7 @@ private void setUpSecondServer() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__DIGEST_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -180,8 +176,7 @@ private void setUpSecondServer() throws Exception {
         ConstraintSecurityHandler security = new ConstraintSecurityHandler() {
 
             @Override
-            public void handle(String arg0, Request arg1, HttpServletRequest arg2, HttpServletResponse arg3)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest arg2, HttpServletResponse arg3) throws IOException, ServletException {
                 System.err.println("request in security handler");
                 System.err.println("Authorization: " + arg2.getHeader("Authorization"));
                 System.err.println("RequestUri: " + arg2.getRequestURI());
@@ -208,12 +203,7 @@ private void stopSecondServer() throws Exception {
 
     private class RedirectHandler extends AbstractHandler {
 
-        private AtomicBoolean redirectOnce = new AtomicBoolean(false);
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             System.err.println("redirecthandler");
             System.err.println("request: " + request.getRequestURI());
@@ -240,10 +230,7 @@ public void handle(String s,
     }
 
     private class SimpleHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             if (request.getHeader("X-401") != null) {
                 response.setStatus(401);
@@ -256,7 +243,6 @@ public void handle(String s,
             response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
             response.setStatus(200);
 
-
             int size = 10 * 1024;
             if (request.getContentLength() > 0) {
                 size = request.getContentLength();
@@ -273,28 +259,30 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = null;
         try {
             setUpSecondServer();
             client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setMaximumNumberOfRedirects(10).build());
             AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl2())
-                    // .setHeader( "X-302", "/bla" )
+            // .setHeader( "X-302", "/bla" )
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
 
             Future<Response> f = r.execute();
@@ -304,7 +292,8 @@ public void redirectAndBasicAuthTest() throws Exception, ExecutionException, Tim
             assertNotNull(resp.getHeader("X-Auth"));
 
         } finally {
-            if (client != null) client.close();
+            if (client != null)
+                client.close();
             stopSecondServer();
         }
     }
@@ -318,152 +307,165 @@ protected String getTargetUrl2() {
         return "http://127.0.0.1:" + port2 + "/uff";
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setHeader("X-401", "401").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setHeader("X-401", "401").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
 
-            private HttpResponseStatus status;
+            Future<Integer> f = r.execute(new AsyncHandler<Integer>() {
 
+                private HttpResponseStatus status;
 
-            public void onThrowable(Throwable t) {
+                public void onThrowable(Throwable t) {
 
-            }
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                this.status = responseStatus;
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    this.status = responseStatus;
 
-                if (status.getStatusCode() != 200) {
-                    return STATE.ABORT;
+                    if (status.getStatusCode() != 200) {
+                        return STATE.ABORT;
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public Integer onCompleted() throws Exception {
-                return status.getStatusCode();
-            }
-        });
-        Integer statusCode = f.get(10, TimeUnit.SECONDS);
-        assertNotNull(statusCode);
-        assertEquals(statusCode.intValue(), 401);
-        client.close();
+                public Integer onCompleted() throws Exception {
+                    return status.getStatusCode();
+                }
+            });
+            Integer statusCode = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(statusCode);
+            assertEquals(statusCode.intValue(), 401);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(true).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setUsePreemptiveAuth(true).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 401);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        ByteArrayInputStream is = new ByteArrayInputStream("test".getBytes());
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(is).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(30, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "test");
-        client.close();
+        try {
+            ByteArrayInputStream is = new ByteArrayInputStream("test".getBytes());
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(is).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(30, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "test");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthAsyncConfigTest() throws Throwable {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build()).build());
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file);
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build()).build());
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file);
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileNoKeepAliveTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(false).build());
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final String fileContent = getFileContent(file);
-
-        AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl())
-                .setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), fileContent);
-        client.close();
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final String fileContent = getFileContent(file);
+
+            AsyncHttpClient.BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(file).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), fileContent);
+        } finally {
+            client.close();
+        }
     }
 
     @Override
@@ -471,40 +473,37 @@ public AbstractHandler configureHandler() throws Exception {
         return new SimpleHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void StringBufferBodyConsumerTest() throws Throwable {
-
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-                .setRealmPrincipal(user)
-                .setRealmPassword(admin)
-                .setUrl(getTargetUrl())
-                .setHeader("Content-Type", "text/html").build();
-
-        StringBuilder s = new StringBuilder();
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(s.toString(), MY_MESSAGE);
-        assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(response.getHeader("X-Auth"));
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setRealmPrincipal(user).setRealmPassword(admin).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            StringBuilder s = new StringBuilder();
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(s.toString(), MY_MESSAGE);
+            assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(response.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl())
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertNotNull(resp.getHeader("X-Auth"));
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertNotNull(resp.getHeader("X-Auth"));
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 }
-
diff --git a/src/test/java/com/ning/http/client/async/BasicHttpsTest.java b/src/test/java/com/ning/http/client/async/BasicHttpsTest.java
index a9a54f20d..2d2c180fd 100644
--- a/src/test/java/com/ning/http/client/async/BasicHttpsTest.java
+++ b/src/test/java/com/ning/http/client/async/BasicHttpsTest.java
@@ -65,10 +65,7 @@
     public static class EchoHandler extends AbstractHandler {
 
         /* @Override */
-        public void handle(String pathInContext,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws ServletException, IOException {
+        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
 
             httpResponse.setContentType("text/html; charset=utf-8");
             Enumeration<?> e = httpRequest.getHeaderNames();
@@ -124,7 +121,7 @@ public void handle(String pathInContext,
             byte[] bytes = new byte[size];
             int pos = 0;
             if (bytes.length > 0) {
-                //noinspection ResultOfMethodCallIgnored
+                // noinspection ResultOfMethodCallIgnored
                 int read = 0;
                 while (read != -1) {
                     read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
@@ -167,8 +164,7 @@ protected int findFreePort() throws IOException {
             socket = new ServerSocket(0);
 
             return socket.getLocalPort();
-        }
-        finally {
+        } finally {
             if (socket != null) {
                 socket.close();
             }
@@ -209,111 +205,95 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPostTest() throws Throwable {
-
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLRequestsTest() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
 
-        // twice
-        response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // twice
+            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLWithoutCacheTest() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).setAllowSslConnectionPool(false).build());
+        try {
+            String body = "hello there";
+            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
-        String body = "hello there";
-        c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute();
-
-        c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute();
+            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
-       Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get();
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get();
 
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void reconnectsAfterFailedCertificationPath() throws Throwable {
         final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext()).build());
-
-        final String body = "hello there";
-
-        TRUST_SERVER_CERT.set(false);
         try {
-            // first request fails because server certificate is rejected
+            final String body = "hello there";
+
+            TRUST_SERVER_CERT.set(false);
             try {
-                c.preparePost(getTargetUrl())
-                        .setBody(body)
-                        .setHeader("Content-Type", "text/html")
-                        .execute().get(TIMEOUT, TimeUnit.SECONDS);
-            }
-            catch (final ExecutionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof ConnectException) {
-                    assertNotNull(cause.getCause());
-                    assertTrue(cause.getCause() instanceof SSLHandshakeException);
-                } else {
-                    assertTrue(cause instanceof SSLHandshakeException);
+                // first request fails because server certificate is rejected
+                try {
+                    c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+                } catch (final ExecutionException e) {
+                    Throwable cause = e.getCause();
+                    if (cause instanceof ConnectException) {
+                        assertNotNull(cause.getCause());
+                        assertTrue(cause.getCause() instanceof SSLHandshakeException);
+                    } else {
+                        assertTrue(cause instanceof SSLHandshakeException);
+                    }
                 }
-            }
 
-            TRUST_SERVER_CERT.set(true);
+                TRUST_SERVER_CERT.set(true);
 
-            // second request should succeed
-            final Response response = c.preparePost(getTargetUrl())
-                    .setBody(body)
-                    .setHeader("Content-Type", "text/html")
-                    .execute().get(TIMEOUT, TimeUnit.SECONDS);
+                // second request should succeed
+                final Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getResponseBody(), body);
-        }
-        finally {
-            TRUST_SERVER_CERT.set(true);
+                assertEquals(response.getResponseBody(), body);
+            } finally {
+                TRUST_SERVER_CERT.set(true);
+            }
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     private static SSLContext createSSLContext() {
@@ -330,15 +310,14 @@ private static SSLContext createSSLContext() {
 
             // Initialize the SSLContext to work with our key managers.
             KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[]{DUMMY_TRUST_MANAGER};
+            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
             SecureRandom secureRandom = new SecureRandom();
 
             SSLContext sslContext = SSLContext.getInstance("TLS");
             sslContext.init(keyManagers, trustManagers, secureRandom);
 
             return sslContext;
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             throw new Error("Failed to initialize the server-side SSLContext", e);
         }
     }
@@ -349,17 +328,14 @@ private static SSLContext createSSLContext() {
             return new X509Certificate[0];
         }
 
-        public void checkClientTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
         }
 
-        public void checkServerTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             if (!TRUST_SERVER_CERT.get()) {
                 throw new CertificateException("Server certificate not trusted.");
             }
         }
     };
 
-
 }
diff --git a/src/test/java/com/ning/http/client/async/BodyChunkTest.java b/src/test/java/com/ning/http/client/async/BodyChunkTest.java
index 8db2bfb64..c86605f70 100644
--- a/src/test/java/com/ning/http/client/async/BodyChunkTest.java
+++ b/src/test/java/com/ning/http/client/async/BodyChunkTest.java
@@ -31,9 +31,8 @@
 
     private final static String MY_MESSAGE = "my message";
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void negativeContentTypeTest() throws Throwable {
-
         AsyncHttpClientConfig.Builder confbuilder = new AsyncHttpClientConfig.Builder();
         confbuilder = confbuilder.setConnectionTimeoutInMs(100);
         confbuilder = confbuilder.setMaximumConnectionsTotal(50);
@@ -41,23 +40,19 @@ public void negativeContentTypeTest() throws Throwable {
 
         // Create client
         AsyncHttpClient client = getAsyncHttpClient(confbuilder.build());
+        try {
+            RequestBuilder requestBuilder = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeader("Content-Type", "message/rfc822");
 
-        RequestBuilder requestBuilder = new RequestBuilder("POST")
-                .setUrl(getTargetUrl())
-                .setHeader("Content-Type", "message/rfc822");
-
-        requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+            requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
-        Future<Response> future = client.executeRequest(requestBuilder.build());
+            Future<Response> future = client.executeRequest(requestBuilder.build());
 
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBody(), MY_MESSAGE);
-        
-        client.close();
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
-
 }
-
-
diff --git a/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java b/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java
index 48e1836a6..7960b0bfb 100644
--- a/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/BodyDeferringAsyncHandlerTest.java
@@ -44,9 +44,7 @@
 
     public static class SlowAndBigHandler extends AbstractHandler {
 
-        public void handle(String pathInContext, Request request,
-                HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-                throws IOException, ServletException {
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             // 512MB large download
             // 512 * 1024 * 1024 = 536870912
@@ -56,8 +54,7 @@ public void handle(String pathInContext, Request request,
 
             httpResponse.flushBuffer();
 
-            final boolean wantFailure = httpRequest
-                    .getHeader("X-FAIL-TRANSFER") != null;
+            final boolean wantFailure = httpRequest.getHeader("X-FAIL-TRANSFER") != null;
             final boolean wantSlow = httpRequest.getHeader("X-SLOW") != null;
 
             OutputStream os = httpResponse.getOutputStream();
@@ -104,8 +101,7 @@ public int getByteCount() {
     }
 
     // simple stream copy just to "consume". It closes streams.
-    public static void copy(InputStream in, OutputStream out)
-            throws IOException {
+    public static void copy(InputStream in, OutputStream out) throws IOException {
         byte[] buf = new byte[1024];
         int len;
         while ((len = in.read(buf)) > 0) {
@@ -122,163 +118,148 @@ public AbstractHandler configureHandler() throws Exception {
 
     public AsyncHttpClientConfig getAsyncHttpClientConfig() {
         // for this test brevity's sake, we are limiting to 1 retries
-        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0)
-                .setRequestTimeoutInMs(10000).build();
+        return new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).setRequestTimeoutInMs(10000).build();
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredSimple() throws IOException, ExecutionException,
-            TimeoutException, InterruptedException {
+    public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        Future<Response> f = r.execute(bdah);
-        Response resp = bdah.getResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // we got headers only, it's probably not all yet here (we have BIG file
-        // downloading)
-        assertEquals(true, HALF_GIG >= cos.getByteCount());
-
-        // now be polite and wait for body arrival too (otherwise we would be
-        // dropping the "line" on server)
-        f.get();
-        // it all should be here now
-        assertEquals(true, HALF_GIG == cos.getByteCount());
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertEquals(true, HALF_GIG >= cos.getByteCount());
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            f.get();
+            // it all should be here now
+            assertEquals(true, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
-    public void deferredSimpleWithFailure() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(
-                "http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure")
-                .addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        Future<Response> f = r.execute(bdah);
-        Response resp = bdah.getResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // we got headers only, it's probably not all yet here (we have BIG file
-        // downloading)
-        assertEquals(true, HALF_GIG >= cos.getByteCount());
-
-        // now be polite and wait for body arrival too (otherwise we would be
-        // dropping the "line" on server)
         try {
-            f.get();
-            Assert.fail("get() should fail with IOException!");
-        } catch (Exception e) {
-            // good
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            Future<Response> f = r.execute(bdah);
+            Response resp = bdah.getResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // we got headers only, it's probably not all yet here (we have BIG file
+            // downloading)
+            assertEquals(true, HALF_GIG >= cos.getByteCount());
+
+            // now be polite and wait for body arrival too (otherwise we would be
+            // dropping the "line" on server)
+            try {
+                f.get();
+                Assert.fail("get() should fail with IOException!");
+            } catch (Exception e) {
+                // good
+            }
+            // it's incomplete, there was an error
+            assertEquals(false, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
         }
-        // it's incomplete, there was an error
-        assertEquals(false, HALF_GIG == cos.getByteCount());
-        client.close();
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredInputStreamTrick() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + port1
-                        + "/deferredInputStreamTrick");
-
-        PipedOutputStream pos = new PipedOutputStream();
-        PipedInputStream pis = new PipedInputStream(pos);
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-        Future<Response> f = r.execute(bdah);
-
-        BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-        Response resp = is.getAsapResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // "consume" the body, but our code needs input stream
-        CountingOutputStream cos = new CountingOutputStream();
-        copy(is, cos);
-
-        // now we don't need to be polite, since consuming and closing
-        // BodyDeferringInputStream does all.
-        // it all should be here now
-        assertEquals(true, HALF_GIG == cos.getByteCount());
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
+
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+            Future<Response> f = r.execute(bdah);
+
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            copy(is, cos);
+
+            // now we don't need to be polite, since consuming and closing
+            // BodyDeferringInputStream does all.
+            // it all should be here now
+            assertEquals(true, HALF_GIG == cos.getByteCount());
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void deferredInputStreamTrickWithFailure() throws IOException,
-            ExecutionException, TimeoutException, InterruptedException {
+    public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet(
-                "http://127.0.0.1:" + port1
-                        + "/deferredInputStreamTrickWithFailure").addHeader(
-                "X-FAIL-TRANSFER", Boolean.TRUE.toString());
-
-        PipedOutputStream pos = new PipedOutputStream();
-        PipedInputStream pis = new PipedInputStream(pos);
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
-
-        Future<Response> f = r.execute(bdah);
-
-        BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
-
-        Response resp = is.getAsapResponse();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(
-                true,
-                resp.getHeader("content-length").equals(
-                        String.valueOf(HALF_GIG)));
-        // "consume" the body, but our code needs input stream
-        CountingOutputStream cos = new CountingOutputStream();
         try {
-            copy(is, cos);
-            Assert.fail("InputStream consumption should fail with IOException!");
-        } catch (IOException e) {
-            // good!
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER", Boolean.TRUE.toString());
+
+            PipedOutputStream pos = new PipedOutputStream();
+            PipedInputStream pis = new PipedInputStream(pos);
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(pos);
+
+            Future<Response> f = r.execute(bdah);
+
+            BodyDeferringInputStream is = new BodyDeferringInputStream(f, bdah, pis);
+
+            Response resp = is.getAsapResponse();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(true, resp.getHeader("content-length").equals(String.valueOf(HALF_GIG)));
+            // "consume" the body, but our code needs input stream
+            CountingOutputStream cos = new CountingOutputStream();
+            try {
+                copy(is, cos);
+                Assert.fail("InputStream consumption should fail with IOException!");
+            } catch (IOException e) {
+                // good!
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testConnectionRefused() throws IOException, ExecutionException,
-            TimeoutException, InterruptedException {
-        int newPortWithoutAnyoneListening = findFreePort();
+    public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        AsyncHttpClient.BoundRequestBuilder r = client
-                .prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening
-                        + "/testConnectionRefused");
-
-        CountingOutputStream cos = new CountingOutputStream();
-        BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
-        r.execute(bdah);
         try {
-            bdah.getResponse();
-            Assert.fail("IOException should be thrown here!");
-        } catch (IOException e) {
-            // good
+            int newPortWithoutAnyoneListening = findFreePort();
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+
+            CountingOutputStream cos = new CountingOutputStream();
+            BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
+            r.execute(bdah);
+            try {
+                bdah.getResponse();
+                Assert.fail("IOException should be thrown here!");
+            } catch (IOException e) {
+                // good
+            }
+        } finally {
+            client.close();
         }
-
-        client.close();
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java b/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java
index ea8e7134f..b32caf72c 100644
--- a/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java
+++ b/src/test/java/com/ning/http/client/async/ByteBufferCapacityTest.java
@@ -12,15 +12,10 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.fail;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -28,21 +23,25 @@
 import java.io.OutputStream;
 import java.util.Enumeration;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.*;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.Response;
 
 public abstract class ByteBufferCapacityTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -76,44 +75,43 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicByteBufferTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicBoolean completed = new AtomicBoolean(false);
-
-        byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
-        long repeats = (1024 * 100 * 10 / bytes.length) + 1;
-        File largeFile = createTempFile(bytes, (int) repeats);
-        final AtomicInteger byteReceived = new AtomicInteger();
-
         try {
-            Response response = c.preparePut(getTargetUrl()).setBody(largeFile)
-                    .execute(new AsyncCompletionHandlerAdapter() {
-                        /* @Override */
-                        public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                            byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
-                            return super.onBodyPartReceived(content);
-                        }
-
-                    }).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(byteReceived.get(), largeFile.length());
-            assertEquals(response.getResponseBody().length(), largeFile.length());
-
-        } catch (IOException ex) {
-            fail("Should have timed out");
+            byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
+            long repeats = (1024 * 100 * 10 / bytes.length) + 1;
+            File largeFile = createTempFile(bytes, (int) repeats);
+            final AtomicInteger byteReceived = new AtomicInteger();
+
+            try {
+                Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
+                    /* @Override */
+                    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                        byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
+                        return super.onBodyPartReceived(content);
+                    }
+
+                }).get();
+
+                assertNotNull(response);
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(byteReceived.get(), largeFile.length());
+                assertEquals(response.getResponseBody().length(), largeFile.length());
+
+            } catch (IOException ex) {
+                fail("Should have timed out");
+            }
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -122,8 +120,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -132,8 +129,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/src/test/java/com/ning/http/client/async/ChunkingTest.java b/src/test/java/com/ning/http/client/async/ChunkingTest.java
index 1860da24d..9d4288e9c 100644
--- a/src/test/java/com/ning/http/client/async/ChunkingTest.java
+++ b/src/test/java/com/ning/http/client/async/ChunkingTest.java
@@ -35,7 +35,7 @@
 
 /**
  * Test that the url fetcher is able to communicate via a proxy
- *
+ * 
  * @author dominict
  */
 abstract public class ChunkingTest extends AbstractBasicTest {
@@ -58,8 +58,7 @@
                 baos.write(buf, 0, len);
             }
             LARGE_IMAGE_BYTES = baos.toByteArray();
-        }
-        catch (Throwable e) {
+        } catch (Throwable e) {
             LARGE_IMAGE_BYTES = new byte[265495];
             Random x = new Random();
             x.nextBytes(LARGE_IMAGE_BYTES);
@@ -67,20 +66,17 @@
     }
 
     /**
-     * Tests that the custom chunked stream result in success and
-     * content returned that is unchunked
+     * Tests that the custom chunked stream result in success and content returned that is unchunked
      */
     @Test()
     public void testCustomChunking() throws Throwable {
         doTest(true);
     }
 
-
     private void doTest(boolean customChunkedInputStream) throws Exception {
         AsyncHttpClient c = null;
         try {
-            AsyncHttpClientConfig.Builder bc =
-                    new AsyncHttpClientConfig.Builder();
+            AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
 
             bc.setAllowPoolingConnection(true);
             bc.setMaximumConnectionsPerHost(1);
@@ -89,7 +85,6 @@ private void doTest(boolean customChunkedInputStream) throws Exception {
             bc.setRequestTimeoutInMs(1000);
             bc.setFollowRedirects(true);
 
-
             c = getAsyncHttpClient(bc.build());
 
             RequestBuilder builder = new RequestBuilder("POST");
@@ -120,14 +115,13 @@ private void doTest(boolean customChunkedInputStream) throws Exception {
                 } else {
                     assertEquals(LARGE_IMAGE_BYTES, readInputStreamToBytes(res.getResponseBodyAsStream()));
                 }
-            }
-            catch (Exception e) {
+            } catch (Exception e) {
 
                 fail("Exception Thrown:" + e.getMessage());
             }
-        }
-        finally {
-            if (c != null) c.close();
+        } finally {
+            if (c != null)
+                c.close();
         }
     }
 
@@ -143,11 +137,9 @@ private void doTest(boolean customChunkedInputStream) throws Exception {
             }
             buffer.flush();
             data = buffer.toByteArray();
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
 
-        }
-        finally {
+        } finally {
             try {
                 stream.close();
             } catch (Exception e2) {
diff --git a/src/test/java/com/ning/http/client/async/ComplexClientTest.java b/src/test/java/com/ning/http/client/async/ComplexClientTest.java
index 6b7a30ffa..b52e9431b 100644
--- a/src/test/java/com/ning/http/client/async/ComplexClientTest.java
+++ b/src/test/java/com/ning/http/client/async/ComplexClientTest.java
@@ -25,44 +25,38 @@
 
 public abstract class ComplexClientTest extends AbstractBasicTest {
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleRequestsTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
 
-        assertEquals(response.getResponseBody(), body);
+            // twice
+            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        // twice
-        response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void urlWithoutSlashTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1))
-                .setBody(body)
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
-        c.close();
+            assertEquals(response.getResponseBody(), body);
+        } finally {
+            c.close();
+        }
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java b/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java
index 184992d57..1a329be84 100644
--- a/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java
+++ b/src/test/java/com/ning/http/client/async/ConnectionPoolTest.java
@@ -43,106 +43,97 @@
 public abstract class ConnectionPoolTest extends AbstractBasicTest {
     protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnections() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 3; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-                Response response = client.prepareGet(url).execute().get();
-                log.info("{} response [{}].", i, response);
-            } catch (Exception ex) {
-                exception = ex;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 3; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+                    Response response = client.prepareGet(url).execute().get();
+                    log.info("{} response [{}].", i, response);
+                } catch (Exception ex) {
+                    exception = ex;
+                }
             }
+            assertNull(exception);
+        } finally {
+            client.close();
         }
-        assertNull(exception);
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 20; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-
-                if (i < 5) {
-                    client.prepareGet(url).execute().get();
-                } else {
-                    client.prepareGet(url).execute();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 20; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+
+                    if (i < 5) {
+                        client.prepareGet(url).execute().get();
+                    } else {
+                        client.prepareGet(url).execute();
+                    }
+                } catch (Exception ex) {
+                    exception = ex;
+                    break;
                 }
-            } catch (Exception ex) {
-                exception = ex;
-                break;
             }
+            assertNotNull(exception);
+            assertNotNull(exception.getMessage());
+            assertEquals(exception.getMessage(), "Too many connections 1");
+        } finally {
+            client.close();
         }
-        assertNotNull(exception);
-        assertNotNull(exception.getMessage());
-        assertEquals(exception.getMessage(),"Too many connections 1");
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = true, invocationCount = 10, alwaysRun = true)
+    @Test(groups = { "standalone", "default_provider", "async" }, enabled = true, invocationCount = 10, alwaysRun = true)
     public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            // Use a l in case the assert fail
+            final CountDownLatch l = new CountDownLatch(2);
 
-        // Use a l in case the assert fail
-        final CountDownLatch l = new CountDownLatch(2);
-
-        final Map<String, Boolean> remoteAddresses = new
-                ConcurrentHashMap<String, Boolean>();
+            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<String, Boolean>();
 
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-                        System.out.println("ON COMPLETED INVOKED " +
-                                response.getHeader("X-KEEP-ALIVE"));
-                        try {
-                            assertEquals(response.getStatusCode(), 200);
-                            remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
-                        } finally {
-                            l.countDown();
-                        }
-                        return response;
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    System.out.println("ON COMPLETED INVOKED " + response.getHeader("X-KEEP-ALIVE"));
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        remoteAddresses.put(response.getHeader("X-KEEP-ALIVE"), true);
+                    } finally {
+                        l.countDown();
                     }
-                };
+                    return response;
+                }
+            };
 
-        client.prepareGet(getTargetUrl()).execute(handler).get();
-        server.stop();
-        server.start();
-        client.prepareGet(getTargetUrl()).execute(handler);
+            client.prepareGet(getTargetUrl()).execute(handler).get();
+            server.stop();
+            server.start();
+            client.prepareGet(getTargetUrl()).execute(handler);
 
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timed out");
+            }
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timed out");
+            assertEquals(remoteAddresses.size(), 2);
+        } finally {
+            client.close();
         }
-
-        assertEquals(remoteAddresses.size(), 2);
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testInvalidConnectionsPool() {
 
         ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
@@ -168,25 +159,23 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertEquals(exception.getMessage(), "Too many connections -1");
+        } finally {
+            client.close();
         }
-        assertNotNull(exception);
-        assertEquals(exception.getMessage(), "Too many connections -1");
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testValidConnectionsPool() {
 
         ConnectionsPool<String, Channel> cp = new ConnectionsPool<String, Channel>() {
@@ -212,153 +201,150 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
         }
-        assertNull(exception);
-        client.close();
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
 
-        // twice
-        Exception exception = null;
-        try {
-            c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            fail("Should throw exception. Too many connections issued.");
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            // twice
+            Exception exception = null;
+            try {
+                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                fail("Should throw exception. Too many connections issued.");
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertEquals(exception.getMessage(), "Too many connections 1");
+        } finally {
+            c.close();
         }
-        assertNotNull(exception);
-        assertEquals(exception.getMessage(), "Too many connections 1");
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void multipleMaxConnectionOpenTestWithQuery() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl() + "?foo=bar")
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl() + "?foo=bar").setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), "foo_" + body);
+            assertEquals(response.getResponseBody(), "foo_" + body);
 
-        // twice
-        Exception exception = null;
-        try {
-            response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            // twice
+            Exception exception = null;
+            try {
+                response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
         }
-        assertNull(exception);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
     }
 
     /**
-     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception.
-     * The onComplete method must be only called once.
-     *
-     * @throws Throwable if something wrong happens.
+     * This test just make sure the hack used to catch disconnected channel under win7 doesn't throw any exception. The onComplete method must be only called once.
+     * 
+     * @throws Throwable
+     *             if something wrong happens.
      */
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void win7DisconnectTest() throws Throwable {
         final AtomicInteger count = new AtomicInteger(0);
 
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
+        try {
+            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-
-                        count.incrementAndGet();
-                        StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-                        IOException t = new IOException();
-                        t.setStackTrace(new StackTraceElement[]{e});
-                        throw t;
-                    }
-                };
+                @Override
+                public Response onCompleted(Response response) throws Exception {
 
-        try {
-            client.prepareGet(getTargetUrl()).execute(handler).get();
-            fail("Must have received an exception");
-        } catch (ExecutionException ex) {
-            assertNotNull(ex);
-            assertNotNull(ex.getCause());
-            assertEquals(ex.getCause().getCause().getClass(), IOException.class);
-            assertEquals(count.get(), 1);
+                    count.incrementAndGet();
+                    StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
+                    IOException t = new IOException();
+                    t.setStackTrace(new StackTraceElement[] { e });
+                    throw t;
+                }
+            };
+
+            try {
+                client.prepareGet(getTargetUrl()).execute(handler).get();
+                fail("Must have received an exception");
+            } catch (ExecutionException ex) {
+                assertNotNull(ex);
+                assertNotNull(ex.getCause());
+                assertEquals(ex.getCause().getCause().getClass(), IOException.class);
+                assertEquals(count.get(), 1);
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void asyncHandlerOnThrowableTest() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final AtomicInteger count = new AtomicInteger();
-        final String THIS_IS_NOT_FOR_YOU = "This is not for you";
-        final CountDownLatch latch = new CountDownLatch(16);
-        for (int i = 0; i < 16; i++) {
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    throw new Exception(THIS_IS_NOT_FOR_YOU);
-                }
-            });
+        try {
+            final AtomicInteger count = new AtomicInteger();
+            final String THIS_IS_NOT_FOR_YOU = "This is not for you";
+            final CountDownLatch latch = new CountDownLatch(16);
+            for (int i = 0; i < 16; i++) {
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw new Exception(THIS_IS_NOT_FOR_YOU);
+                    }
+                });
 
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
-                /* @Override */
-                public void onThrowable(Throwable t) {
-                    if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
-                        count.incrementAndGet();
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerBase() {
+                    /* @Override */
+                    public void onThrowable(Throwable t) {
+                        if (t.getMessage() != null && t.getMessage().equalsIgnoreCase(THIS_IS_NOT_FOR_YOU)) {
+                            count.incrementAndGet();
+                        }
                     }
-                }
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    latch.countDown();
-                    return response;
-                }
-            });
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        latch.countDown();
+                        return response;
+                    }
+                });
+            }
+            latch.await(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(count.get(), 0);
+        } finally {
+            client.close();
         }
-        latch.await(TIMEOUT, TimeUnit.SECONDS);
-        assertEquals(count.get(), 0);
-        client.close();
     }
-
 }
-
diff --git a/src/test/java/com/ning/http/client/async/DigestAuthTest.java b/src/test/java/com/ning/http/client/async/DigestAuthTest.java
index 293139e10..66d1ce308 100644
--- a/src/test/java/com/ning/http/client/async/DigestAuthTest.java
+++ b/src/test/java/com/ning/http/client/async/DigestAuthTest.java
@@ -38,7 +38,6 @@
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -61,8 +60,7 @@ public void setUpGlobal() throws Exception {
         server = new Server();
         Logger root = Logger.getRootLogger();
         root.setLevel(Level.DEBUG);
-        root.addAppender(new ConsoleAppender(
-                new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
+        root.addAppender(new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN)));
 
         port1 = findFreePort();
         Connector listener = new SelectChannelConnector();
@@ -77,7 +75,7 @@ public void setUpGlobal() throws Exception {
 
         Constraint constraint = new Constraint();
         constraint.setName(Constraint.__BASIC_AUTH);
-        constraint.setRoles(new String[]{user, admin});
+        constraint.setRoles(new String[] { user, admin });
         constraint.setAuthenticate(true);
 
         ConstraintMapping mapping = new ConstraintMapping();
@@ -104,10 +102,7 @@ public void setUpGlobal() throws Exception {
     }
 
     private class SimpleHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             response.addHeader("X-Auth", request.getHeader("Authorization"));
             response.setStatus(200);
@@ -116,50 +111,51 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user)
-                        .setPassword(admin)
-                        .setRealmName("MyRealm")
-                        .setScheme(Realm.AuthScheme.DIGEST).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(60, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(resp.getHeader("X-Auth"));
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").setScheme(Realm.AuthScheme.DIGEST).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal(user)
-                        .setPassword(admin)
-                        .setRealmName("MyRealm").build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(60, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertNotNull(resp.getHeader("X-Auth"));
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal(user).setPassword(admin).setRealmName("MyRealm").build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(60, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertNotNull(resp.getHeader("X-Auth"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/")
-                .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).setScheme(Realm.AuthScheme.DIGEST).build());
-
-        Future<Response> f = r.execute();
-        Response resp = f.get(20, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 401);
-        client.close();
+        try {
+            AsyncHttpClient.BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/").setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(admin).setScheme(Realm.AuthScheme.DIGEST).build());
+
+            Future<Response> f = r.execute();
+            Response resp = f.get(20, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 401);
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/EmptyBodyTest.java b/src/test/java/com/ning/http/client/async/EmptyBodyTest.java
index d687a6cb2..ccec37a18 100644
--- a/src/test/java/com/ning/http/client/async/EmptyBodyTest.java
+++ b/src/test/java/com/ning/http/client/async/EmptyBodyTest.java
@@ -15,19 +15,12 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.CountDownLatch;
@@ -36,31 +29,34 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-import static org.testng.Assert.fail;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.Response;
 
 /**
  * Tests case where response doesn't have body.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class EmptyBodyTest extends AbstractBasicTest {
     private class NoBodyResponseHandler extends AbstractHandler {
-        public void handle(
-                String s,
-                Request request,
-                HttpServletRequest req,
-                HttpServletResponse resp)
-                throws IOException, ServletException {
+        public void handle(String s, Request request, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
             if (!req.getMethod().equalsIgnoreCase("PUT")) {
                 resp.setStatus(HttpServletResponse.SC_OK);
             } else {
-                resp.setStatus(204);                
+                resp.setStatus(204);
             }
             request.setHandled(true);
         }
@@ -71,72 +67,77 @@ public AbstractHandler configureHandler() throws Exception {
         return new NoBodyResponseHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testEmptyBody() throws IOException {
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final AtomicBoolean err = new AtomicBoolean(false);
-        final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
-        final AtomicBoolean status = new AtomicBoolean(false);
-        final AtomicInteger headers = new AtomicInteger(0);
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
-            public void onThrowable(Throwable t) {
-                fail("Got throwable.", t);
-                err.set(true);
-            }
+        try {
+            final AtomicBoolean err = new AtomicBoolean(false);
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final AtomicBoolean status = new AtomicBoolean(false);
+            final AtomicInteger headers = new AtomicInteger(0);
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build(), new AsyncHandler<Object>() {
+                public void onThrowable(Throwable t) {
+                    fail("Got throwable.", t);
+                    err.set(true);
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
-                String s = new String(e.getBodyPartBytes());
-                log.info("got part: {}", s);
-                if (s.isEmpty()) {
-                    //noinspection ThrowableInstanceNeverThrown
-                    log.warn("Sampling stacktrace.",
-                            new Throwable("trace that, we should not get called for empty body."));
+                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                    String s = new String(e.getBodyPartBytes());
+                    log.info("got part: {}", s);
+                    if (s.isEmpty()) {
+                        // noinspection ThrowableInstanceNeverThrown
+                        log.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
+                    }
+                    queue.put(s);
+                    return STATE.CONTINUE;
                 }
-                queue.put(s);
-                return STATE.CONTINUE;
-            }
 
-            public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
-                status.set(true);
-                return AsyncHandler.STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                    status.set(true);
+                    return AsyncHandler.STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
-                if (headers.incrementAndGet() == 2) {
-                    throw new Exception("Analyze this.");
+                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                    if (headers.incrementAndGet() == 2) {
+                        throw new Exception("Analyze this.");
+                    }
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public Object onCompleted() throws Exception {
-                latch.countDown();
-                return null;
+                public Object onCompleted() throws Exception {
+                    latch.countDown();
+                    return null;
+                }
+            });
+            try {
+                assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
+            } catch (InterruptedException e) {
+                fail("Interrupted.", e);
             }
-        });
-        try {
-            assertTrue(latch.await(1, TimeUnit.SECONDS), "Latch failed.");
-        } catch (InterruptedException e) {
-            fail("Interrupted.", e);
+            assertFalse(err.get());
+            assertEquals(queue.size(), 0);
+            assertTrue(status.get());
+            assertEquals(headers.get(), 1);
+        } finally {
+            ahc.close();
         }
-        assertFalse(err.get());
-        assertEquals(queue.size(), 0);
-        assertTrue(status.get());
-        assertEquals(headers.get(), 1);
-        ahc.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testPutEmptyBody() throws Throwable {
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
+        try {
+            Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
 
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 204);
-        assertEquals(response.getResponseBody(), "");
-        assertTrue(InputStream.class.isAssignableFrom(response.getResponseBodyAsStream().getClass()));
-        assertEquals(response.getResponseBodyAsStream().read(), -1); 
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 204);
+            assertEquals(response.getResponseBody(), "");
+            assertTrue(InputStream.class.isAssignableFrom(response.getResponseBodyAsStream().getClass()));
+            assertEquals(response.getResponseBodyAsStream().read(), -1);
 
-        ahc.close();
+        } finally {
+            ahc.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/ErrorResponseTest.java b/src/test/java/com/ning/http/client/async/ErrorResponseTest.java
index 0613c27ef..c3b527736 100644
--- a/src/test/java/com/ning/http/client/async/ErrorResponseTest.java
+++ b/src/test/java/com/ning/http/client/async/ErrorResponseTest.java
@@ -16,34 +16,35 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.Response;
 
 /**
  * Tests to reproduce issues with handling of error responses
- *
+ * 
  * @author Tatu Saloranta
  */
 public abstract class ErrorResponseTest extends AbstractBasicTest {
     final static String BAD_REQUEST_STR = "Very Bad Request! No cookies.";
 
     private static class ErrorHandler extends AbstractHandler {
-        public void handle(String s, Request r,
-                           HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             try {
                 Thread.sleep(210L);
             } catch (InterruptedException e) {
@@ -61,18 +62,18 @@ public AbstractHandler configureHandler() throws Exception {
         return new ErrorHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws Exception {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .prepareGet("http://127.0.0.1:" + port1 + "/foo")
-                .addHeader("Accepts", "*/*")
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), 400);
-        String respStr = resp.getResponseBody();
-        assertEquals(BAD_REQUEST_STR, respStr);
-        client.close();
+        try {
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), 400);
+            String respStr = resp.getResponseBody();
+            assertEquals(BAD_REQUEST_STR, respStr);
+        } finally {
+            client.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java b/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java
index 8ebb82d34..d0fd1f32d 100644
--- a/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java
+++ b/src/test/java/com/ning/http/client/async/Expect100ContinueTest.java
@@ -15,22 +15,24 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
 import java.util.concurrent.Future;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.Response;
 
 /**
  * Test the Expect: 100-Continue.
@@ -38,10 +40,7 @@
 public abstract class Expect100ContinueTest extends AbstractBasicTest {
 
     private class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int size = 10 * 1024;
             if (httpRequest.getContentLength() > 0) {
@@ -58,26 +57,26 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void Expect100Continue() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
 
-        ClassLoader cl = getClass().getClassLoader();
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(file).execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
-
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(file).execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new ZeroCopyHandler();
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java b/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java
index 87dd3aa37..0f27acb0a 100644
--- a/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java
+++ b/src/test/java/com/ning/http/client/async/FilePartLargeFileTest.java
@@ -12,66 +12,70 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.FilePart;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.Test;
+import static org.testng.FileAssert.fail;
 
-import javax.servlet.ServletException;
-import javax.servlet.ServletInputStream;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.URL;
 import java.util.UUID;
 
-import static org.testng.FileAssert.fail;
+import javax.servlet.ServletException;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-public abstract class FilePartLargeFileTest
-        extends AbstractBasicTest {
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.Assert;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClient.BoundRequestBuilder;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.FilePart;
+import com.ning.http.client.Response;
+
+public abstract class FilePartLargeFileTest extends AbstractBasicTest {
 
     private File largeFile;
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutImageFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutImageFile() throws Exception {
         largeFile = getTestFile();
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100 * 6000).build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
-
-        rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream" , "UTF-8"));
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
+            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
 
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutLargeTextFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutLargeTextFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 * 1024 / bytes.length) + 1;
         largeFile = createTempFile(bytes, (int) repeats);
 
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream" , "UTF-8"));
+            rb.addBodyPart(new FilePart("test", largeFile, "application/octet-stream", "UTF-8"));
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
     private static File getTestFile() {
@@ -96,12 +100,10 @@ public void after() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
-            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
                 ServletInputStream in = req.getInputStream();
                 byte[] b = new byte[8192];
@@ -125,11 +127,9 @@ public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServle
         };
     }
 
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -139,8 +139,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -149,8 +148,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/src/test/java/com/ning/http/client/async/FilterTest.java b/src/test/java/com/ning/http/client/async/FilterTest.java
index 6932087da..99b21033f 100644
--- a/src/test/java/com/ning/http/client/async/FilterTest.java
+++ b/src/test/java/com/ning/http/client/async/FilterTest.java
@@ -42,10 +42,7 @@
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -65,63 +62,65 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(100));
 
         AsyncHttpClient c = getAsyncHttpClient(b.build());
-
-        Response response = c.preparePost(getTargetUrl())
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+        try {
+            Response response = c.preparePost(getTargetUrl()).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void loadThrottleTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(10));
 
         AsyncHttpClient c = getAsyncHttpClient(b.build());
+        try {
+            List<Future<Response>> futures = new ArrayList<Future<Response>>();
+            for (int i = 0; i < 200; i++) {
+                futures.add(c.preparePost(getTargetUrl()).execute());
+            }
 
-        List<Future<Response>> futures = new ArrayList<Future<Response>>();
-        for (int i = 0; i < 200; i++) {
-            futures.add(c.preparePost(getTargetUrl()).execute());
-        }
-
-        for (Future<Response> f : futures) {
-            Response r = f.get();
-            assertNotNull(f.get());
-            assertEquals(r.getStatusCode(), 200);
+            for (Future<Response> f : futures) {
+                Response r = f.get();
+                assertNotNull(f.get());
+                assertEquals(r.getStatusCode(), 200);
+            }
+        } finally {
+            c.close();
         }
-
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void maxConnectionsText() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(0, 1000));
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            c.preparePost(getTargetUrl()).execute().get();
             fail("Should have timed out");
         } catch (IOException ex) {
             assertNotNull(ex);
             assertEquals(ex.getCause().getClass(), FilterException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addResponseFilter(new ResponseFilter() {
@@ -134,18 +133,18 @@ public FilterContext filter(FilterContext ctx) throws FilterException {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -165,19 +164,19 @@ public FilterContext filter(FilterContext ctx) throws FilterException {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayStatusCodeResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -197,19 +196,19 @@ public FilterContext filter(FilterContext ctx) throws FilterException {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void replayHeaderResponseFilterTest() throws Throwable {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         final AtomicBoolean replay = new AtomicBoolean(true);
@@ -218,16 +217,10 @@ public void replayHeaderResponseFilterTest() throws Throwable {
 
             public FilterContext filter(FilterContext ctx) throws FilterException {
 
-                if (ctx.getResponseHeaders() != null
-                        && ctx.getResponseHeaders().getHeaders().getFirstValue("Ping").equals("Pong")
-                        && replay.getAndSet(false)) {
+                if (ctx.getResponseHeaders() != null && ctx.getResponseHeaders().getHeaders().getFirstValue("Ping").equals("Pong") && replay.getAndSet(false)) {
 
                     Request request = new RequestBuilder(ctx.getRequest()).addHeader("Ping", "Pong").build();
-                    return new FilterContext.FilterContextBuilder()
-                            .asyncHandler(ctx.getAsyncHandler())
-                            .request(request)
-                            .replayRequest(true)
-                            .build();
+                    return new FilterContext.FilterContextBuilder().asyncHandler(ctx.getAsyncHandler()).request(request).replayRequest(true).build();
                 }
                 return ctx;
             }
@@ -236,15 +229,15 @@ public FilterContext filter(FilterContext ctx) throws FilterException {
         AsyncHttpClient c = getAsyncHttpClient(b.build());
 
         try {
-            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong")
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("Ping"), "Pong");
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/FollowingThreadTest.java b/src/test/java/com/ning/http/client/async/FollowingThreadTest.java
index b8de801eb..82d6c6d95 100644
--- a/src/test/java/com/ning/http/client/async/FollowingThreadTest.java
+++ b/src/test/java/com/ning/http/client/async/FollowingThreadTest.java
@@ -30,7 +30,6 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeoutException;
 
-
 /**
  * Simple stress test for exercising the follow redirect.
  */
@@ -38,59 +37,62 @@
 
     private final static int COUNT = 10;
 
-    @Test(timeOut = 30 * 1000, groups = {"online", "default_provider", "scalability"})
+    @Test(timeOut = 30 * 1000, groups = { "online", "default_provider", "scalability" })
     public void testFollowRedirect() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         final CountDownLatch countDown = new CountDownLatch(COUNT);
         ExecutorService pool = Executors.newCachedThreadPool();
-        for (int i = 0; i < COUNT; i++) {
-            pool.submit(new Runnable() {
-
-                private int status;
-
-                public void run() {
-                    final CountDownLatch l = new CountDownLatch(1);
-                    final AsyncHttpClient ahc = getAsyncHttpClient(
-                            new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-                    try {
-                        ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
-
-                            public void onThrowable(Throwable t) {
-                                t.printStackTrace();
-                            }
-
-                            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                                System.out.println(new String(bodyPart.getBodyPartBytes()));
-                                return STATE.CONTINUE;
-                            }
-
-                            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                                status = responseStatus.getStatusCode();
-                                System.out.println(responseStatus.getStatusText());
-                                return STATE.CONTINUE;
-                            }
-
-                            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                                return STATE.CONTINUE;
-                            }
-
-                            public Integer onCompleted() throws Exception {
-                                l.countDown();
-                                return status;
-                            }
-                        });
-
-                        l.await();
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    } finally {
-                        ahc.close();
-                        countDown.countDown();
+        try {
+            for (int i = 0; i < COUNT; i++) {
+                pool.submit(new Runnable() {
+
+                    private int status;
+
+                    public void run() {
+                        final CountDownLatch l = new CountDownLatch(1);
+                        final AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+                        try {
+                            ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
+
+                                public void onThrowable(Throwable t) {
+                                    t.printStackTrace();
+                                }
+
+                                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                                    System.out.println(new String(bodyPart.getBodyPartBytes()));
+                                    return STATE.CONTINUE;
+                                }
+
+                                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                                    status = responseStatus.getStatusCode();
+                                    System.out.println(responseStatus.getStatusText());
+                                    return STATE.CONTINUE;
+                                }
+
+                                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                                    return STATE.CONTINUE;
+                                }
+
+                                public Integer onCompleted() throws Exception {
+                                    l.countDown();
+                                    return status;
+                                }
+                            });
+
+                            l.await();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        } finally {
+                            ahc.close();
+                            countDown.countDown();
+                        }
                     }
-                }
-            });
+                });
+            }
+            countDown.await();
+        } finally {
+            pool.shutdown();
         }
-        countDown.await();
     }
 
 }
\ No newline at end of file
diff --git a/src/test/java/com/ning/http/client/async/Head302Test.java b/src/test/java/com/ning/http/client/async/Head302Test.java
index c84f827dc..b3603688e 100644
--- a/src/test/java/com/ning/http/client/async/Head302Test.java
+++ b/src/test/java/com/ning/http/client/async/Head302Test.java
@@ -15,19 +15,6 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncCompletionHandlerBase;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.omg.CORBA.TIMEOUT;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.concurrent.BrokenBarrierException;
 import java.util.concurrent.CountDownLatch;
@@ -35,9 +22,23 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncCompletionHandlerBase;
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+
 /**
  * Tests HEAD request that gets 302 response.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class Head302Test extends AbstractBasicTest {
@@ -45,10 +46,7 @@
      * Handler that does Found (302) in response to HEAD method.
      */
     private class Head302handler extends AbstractHandler {
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("HEAD".equalsIgnoreCase(request.getMethod())) {
                 if (request.getPathInfo().endsWith("_moved")) {
                     response.setStatus(HttpServletResponse.SC_OK);
@@ -62,24 +60,27 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
 
-        client.executeRequest(request, new AsyncCompletionHandlerBase() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                l.countDown();
-                return super.onCompleted(response);
-            }
-        }).get(3, TimeUnit.SECONDS);
+            client.executeRequest(request, new AsyncCompletionHandlerBase() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    l.countDown();
+                    return super.onCompleted(response);
+                }
+            }).get(3, TimeUnit.SECONDS);
 
-        if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java b/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java
index ca0a4f7c9..6ee99cb0d 100644
--- a/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java
+++ b/src/test/java/com/ning/http/client/async/HostnameVerifierTest.java
@@ -54,10 +54,7 @@
     public static class EchoHandler extends AbstractHandler {
 
         /* @Override */
-        public void handle(String pathInContext,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws ServletException, IOException {
+        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
 
             httpResponse.setContentType("text/html; charset=utf-8");
             Enumeration<?> e = httpRequest.getHeaderNames();
@@ -113,7 +110,7 @@ public void handle(String pathInContext,
             byte[] bytes = new byte[size];
             int pos = 0;
             if (bytes.length > 0) {
-                //noinspection ResultOfMethodCallIgnored
+                // noinspection ResultOfMethodCallIgnored
                 int read = 0;
                 while (read != -1) {
                     read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
@@ -197,76 +194,84 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void positiveHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new PositiveHostVerifier()).setSSLContext(createSSLContext()).build());
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
 
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
+            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void negativeHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new NegativeHostVerifier()).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        } catch (ConnectException ex) {
-            assertEquals(ConnectException.class, ex.getClass());
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            } catch (ConnectException ex) {
+                assertEquals(ConnectException.class, ex.getClass());
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void remoteIDHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("bouette")).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        } catch (ConnectException ex) {
-            assertEquals(ConnectException.class, ex.getClass());
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            } catch (ConnectException ex) {
+                assertEquals(ConnectException.class, ex.getClass());
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void remotePosHostnameVerifierTest() throws Throwable {
 
         final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("localhost")).setSSLContext(createSSLContext()).build());
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
         try {
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
-        } catch (ConnectException ex) {
-            assertEquals(ConnectException.class, ex.getClass());
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            try {
+                client.preparePost(getTargetUrl()).setBody(file).setHeader("Content-Type", "text/html").execute();
+            } catch (ConnectException ex) {
+                assertEquals(ConnectException.class, ex.getClass());
+            }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
     public static class PositiveHostVerifier implements HostnameVerifier {
@@ -315,7 +320,7 @@ private static SSLContext createSSLContext() {
 
             // Initialize the SSLContext to work with our key managers.
             KeyManager[] keyManagers = kmf.getKeyManagers();
-            TrustManager[] trustManagers = new TrustManager[]{DUMMY_TRUST_MANAGER};
+            TrustManager[] trustManagers = new TrustManager[] { DUMMY_TRUST_MANAGER };
             SecureRandom secureRandom = new SecureRandom();
 
             SSLContext sslContext = SSLContext.getInstance("TLS");
@@ -333,17 +338,14 @@ private static SSLContext createSSLContext() {
             return new X509Certificate[0];
         }
 
-        public void checkClientTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
         }
 
-        public void checkServerTrusted(
-                X509Certificate[] chain, String authType) throws CertificateException {
+        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             if (!TRUST_SERVER_CERT.get()) {
                 throw new CertificateException("Server certificate not trusted.");
             }
         }
     };
 
-
 }
diff --git a/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java b/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java
index 7cd04b99b..b12b08ad8 100644
--- a/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java
+++ b/src/test/java/com/ning/http/client/async/HttpToHttpsRedirectTest.java
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -120,33 +116,14 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    private String getBaseUrl(URI uri) {
-        String url = uri.toString();
-        int port = uri.getPort();
-        if (port == -1) {
-            port = getPort(uri);
-            url = url.substring(0, url.length() - 1) + ":" + port;
-        }
-        return url.substring(0, url.lastIndexOf(":") + String.valueOf(port).length() + 1);
-    }
-
-    private static int getPort(URI uri) {
-        int port = uri.getPort();
-        if (port == -1)
-            port = uri.getScheme().equals("http") ? 80 : 443;
-        return port;
-    }
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void httpToHttpsRedirect() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2())
-                .execute().get();
+        Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
         assertNotNull(response);
         assertEquals(response.getStatusCode(), 200);
         assertEquals(response.getHeader("X-httpToHttps"), "PASS");
@@ -157,43 +134,41 @@ public String getTargetUrl2() {
         return String.format("https://127.0.0.1:%d/foo/test", port2);
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void httpToHttpsProperConfig() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2() + "/test2")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-
-        // Test if the internal channel is downgraded to clean http.
-        response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", getTargetUrl2() + "/foo2")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        c.close();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+
+            // Test if the internal channel is downgraded to clean http.
+            response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/foo2").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getHeader("X-httpToHttps"), "PASS");
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativeLocationUrl() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setMaximumNumberOfRedirects(5).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", "/foo/test")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        assertEquals(response.getUri().toString(), getTargetUrl());
-        c.close();
+        try {
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getUri().toString(), getTargetUrl());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/InputStreamTest.java b/src/test/java/com/ning/http/client/async/InputStreamTest.java
index 70ceb4b48..f6d8c395a 100644
--- a/src/test/java/com/ning/http/client/async/InputStreamTest.java
+++ b/src/test/java/com/ning/http/client/async/InputStreamTest.java
@@ -36,10 +36,7 @@
 public abstract class InputStreamTest extends AbstractBasicTest {
 
     private class InputStreamHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
                 byte[] b = new byte[3];
                 request.getInputStream().read(b, 0, 3);
@@ -54,43 +51,46 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-        h.add("Content-Type", "application/x-www-form-urlencoded");
+        try {
+            FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+            h.add("Content-Type", "application/x-www-form-urlencoded");
 
-        InputStream is = new InputStream() {
+            InputStream is = new InputStream() {
 
-            public int readAllowed;
+                public int readAllowed;
 
-            @Override
-            public int available() {
-                return 1; // Fake
-            }
-
-            @Override
-            public int read() throws IOException {
-                int fakeCount = readAllowed++;
-                if (fakeCount == 0) {
-                    return (int) 'a';
-                } else if (fakeCount == 1) {
-                    return (int) 'b';
-                } else if (fakeCount == 2) {
-                    return (int) 'c';
-                } else {
-                    return -1;
+                @Override
+                public int available() {
+                    return 1; // Fake
                 }
 
-            }
-        };
+                @Override
+                public int read() throws IOException {
+                    int fakeCount = readAllowed++;
+                    if (fakeCount == 0) {
+                        return (int) 'a';
+                    } else if (fakeCount == 1) {
+                        return (int) 'b';
+                    } else if (fakeCount == 2) {
+                        return (int) 'c';
+                    } else {
+                        return -1;
+                    }
 
-        Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("X-Param"), "abc");
-        c.close();
+                }
+            };
+
+            Response resp = c.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute().get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), "abc");
+        } finally {
+            c.close();
+        }
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/ListenableFutureTest.java b/src/test/java/com/ning/http/client/async/ListenableFutureTest.java
index 6de42566a..f80168bc5 100644
--- a/src/test/java/com/ning/http/client/async/ListenableFutureTest.java
+++ b/src/test/java/com/ning/http/client/async/ListenableFutureTest.java
@@ -27,28 +27,31 @@
 
 public abstract class ListenableFutureTest extends AbstractBasicTest {
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testListenableFuture() throws Throwable {
         final AtomicInteger statusCode = new AtomicInteger(500);
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        final CountDownLatch latch = new CountDownLatch(1);
-        final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
-        future.addListener(new Runnable(){
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
+            future.addListener(new Runnable() {
 
-            public void run() {
-                try {
-                    statusCode.set(future.get().getStatusCode());
-                    latch.countDown();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                } catch (ExecutionException e) {
-                    e.printStackTrace();
+                public void run() {
+                    try {
+                        statusCode.set(future.get().getStatusCode());
+                        latch.countDown();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    } catch (ExecutionException e) {
+                        e.printStackTrace();
+                    }
                 }
-            }
-        }, Executors.newFixedThreadPool(1));
+            }, Executors.newFixedThreadPool(1));
 
-        latch.await(10, TimeUnit.SECONDS);
-        assertEquals(statusCode.get(), 200);
-        ahc.close();
+            latch.await(10, TimeUnit.SECONDS);
+            assertEquals(statusCode.get(), 200);
+        } finally {
+            ahc.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java b/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java
index 01484c610..405ef9b76 100644
--- a/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java
+++ b/src/test/java/com/ning/http/client/async/MaxConnectionsInThreads.java
@@ -43,96 +43,79 @@
 
     private static URI servletEndpointUri;
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testMaxConnectionsWithinThreads() {
 
-        String[] urls = new String[]{
-                servletEndpointUri.toString(),
-                servletEndpointUri.toString()};
-
-
-        final AsyncHttpClient client =
-               getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build());
-
-
-        final Boolean[] caughtError = new Boolean[]{Boolean.FALSE};
-        List<Thread> ts = new ArrayList<Thread>();
-        for (int i = 0; i < urls.length; i++) {
-            final String url = urls[i];
-            Thread t = new Thread() {
-                public void run() {
-                    try {
-                        client.prepareGet(url).execute();
-                    } catch (IOException e) {
-                        // assert that 2nd request fails, because maxTotalConnections=1
-                        //            		System.out.println(i);
-                        caughtError[0] = true;
-                        System.err.println("============");
-                        e.printStackTrace();
-                        System.err.println("============");
+        String[] urls = new String[] { servletEndpointUri.toString(), servletEndpointUri.toString() };
 
+        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+
+        try {
+            final Boolean[] caughtError = new Boolean[] { Boolean.FALSE };
+            List<Thread> ts = new ArrayList<Thread>();
+            for (int i = 0; i < urls.length; i++) {
+                final String url = urls[i];
+                Thread t = new Thread() {
+                    public void run() {
+                        try {
+                            client.prepareGet(url).execute();
+                        } catch (IOException e) {
+                            // assert that 2nd request fails, because maxTotalConnections=1
+                            // System.out.println(i);
+                            caughtError[0] = true;
+                            System.err.println("============");
+                            e.printStackTrace();
+                            System.err.println("============");
+
+                        }
                     }
+                };
+                t.start();
+                ts.add(t);
+            }
+
+            for (Thread t : ts) {
+                try {
+                    t.join();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
                 }
-            };
-            t.start();
-            ts.add(t);
-        }
+            }
 
-        for (Thread t : ts) {
+            // Let the threads finish
             try {
-                t.join();
-            } catch (InterruptedException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
+                Thread.sleep(4500);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
             }
-        }
 
-
-        // Let the threads finish
-        try {
-            Thread.sleep(4500);
-        } catch (InterruptedException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        }
-
-        assertTrue("Max Connections should have been reached", caughtError[0]);
-
-
-        boolean errorInNotThread = false;
-        for (int i = 0; i < urls.length; i++) {
-            final String url = urls[i];
+            assertTrue("Max Connections should have been reached", caughtError[0]);
+
+            boolean errorInNotThread = false;
+            for (int i = 0; i < urls.length; i++) {
+                final String url = urls[i];
+                try {
+                    client.prepareGet(url).execute();
+                    // client.prepareGet(url).execute();
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    // System.out.println(i);
+                    errorInNotThread = true;
+                    System.err.println("============");
+                    e.printStackTrace();
+                    System.err.println("============");
+                }
+            }
+            // Let the request finish
             try {
-                client.prepareGet(url).execute();
-                // client.prepareGet(url).execute();
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                // System.out.println(i);
-                errorInNotThread = true;
-                System.err.println("============");
-                e.printStackTrace();
-                System.err.println("============");
+                Thread.sleep(2500);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
             }
+            assertTrue("Max Connections should have been reached", errorInNotThread);
+        } finally {
+            client.close();
         }
-        // Let the request finish
-        try {
-            Thread.sleep(2500);
-        } catch (InterruptedException e1) {
-            // TODO Auto-generated catch block
-            e1.printStackTrace();
-        }
-        assertTrue("Max Connections should have been reached", errorInNotThread);
-
-
-        client.close();
-
-
     }
 
     @Override
@@ -149,7 +132,6 @@ public void setUpGlobal() throws Exception {
 
         server.addConnector(listener);
 
-
         ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
 
         context.setContextPath("/");
@@ -185,8 +167,7 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
             try {
                 sleepTime = Integer.parseInt(req.getParameter("timeout"));
 
-            }
-            catch (NumberFormatException e) {
+            } catch (NumberFormatException e) {
                 sleepTime = DEFAULT_TIMEOUT;
             }
 
@@ -200,8 +181,7 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
                 System.out.println("Servlet is awake for");
                 System.out.println("=======================================");
                 System.out.flush();
-            }
-            catch (Exception e) {
+            } catch (Exception e) {
 
             }
 
@@ -209,10 +189,12 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
 
             byte[] retVal = "1".getBytes();
             OutputStream os = res.getOutputStream();
-
-            res.setContentLength(retVal.length);
-            os.write(retVal);
-            os.close();
+            try {
+                res.setContentLength(retVal.length);
+                os.write(retVal);
+            } finally {
+                os.close();
+            }
         }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java b/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java
index ad47d1cea..307d38937 100644
--- a/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java
+++ b/src/test/java/com/ning/http/client/async/MaxTotalConnectionTest.java
@@ -1,18 +1,18 @@
 /*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License. You may obtain a copy of the License at:
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
 package com.ning.http.client.async;
 
 import com.ning.http.client.AsyncHttpClient;
@@ -32,21 +32,11 @@
 public abstract class MaxTotalConnectionTest extends AbstractBasicTest {
     protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnectionsExceedingException() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://github.com/"};
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
 
         boolean caughtError = false;
         for (int i = 0; i < urls.length; i++) {
@@ -64,92 +54,72 @@ public void testMaxTotalConnectionsExceedingException() {
 
     @Test
     public void testMaxTotalConnections() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://lenta.ru"};
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(2)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
-
-        for (String url : urls) {
-            try {
-                client.prepareGet(url).execute();
-            } catch (IOException e) {
-                Assert.fail("Smth wrong with connections handling!");
+        String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(2).setMaximumConnectionsPerHost(1).build());
+        try {
+            for (String url : urls) {
+                try {
+                    client.prepareGet(url).execute();
+                } catch (IOException e) {
+                    Assert.fail("Smth wrong with connections handling!");
+                }
             }
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-
     /**
-     * JFA: Disable this test for 1.2.0 release as it can easily fail because a request may complete
-     * before the second one is made, hence failing. The issue occurs frequently on Linux.
+     * JFA: Disable this test for 1.2.0 release as it can easily fail because a request may complete before the second one is made, hence failing. The issue occurs frequently on Linux.
      */
     @Test(enabled = false)
     public void testMaxTotalConnectionsCorrectExceptionHandling() {
-        String[] urls = new String[]{
-                "http://google.com",
-                "http://github.com/"};
-
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionTimeoutInMs(1000)
-                        .setRequestTimeoutInMs(5000)
-                        .setAllowPoolingConnection(false)
-                        .setMaximumConnectionsTotal(1)
-                        .setMaximumConnectionsPerHost(1)
-                        .build()
-        );
-
-        List<Future> futures = new ArrayList<Future>();
-        boolean caughtError = false;
-        for (int i = 0; i < urls.length; i++) {
-            try {
-                Future<Response> future = client.prepareGet(urls[i]).execute();
-                if (future != null) {
-                    futures.add(future);
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(1000).setRequestTimeoutInMs(5000).setAllowPoolingConnection(false).setMaximumConnectionsTotal(1).setMaximumConnectionsPerHost(1).build());
+        try {
+            List<Future> futures = new ArrayList<Future>();
+            boolean caughtError = false;
+            for (int i = 0; i < urls.length; i++) {
+                try {
+                    Future<Response> future = client.prepareGet(urls[i]).execute();
+                    if (future != null) {
+                        futures.add(future);
+                    }
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    Assert.assertEquals(i, 1);
+                    caughtError = true;
                 }
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                Assert.assertEquals(i, 1);
-                caughtError = true;
             }
-        }
-        Assert.assertTrue(caughtError);
-
-        // get results of executed requests
-        for (Future future : futures) {
-            try {
-                Object res = future.get();
-            } catch (InterruptedException e) {
-                log.error("Error!", e);
-            } catch (ExecutionException e) {
-                log.error("Error!", e);
+            Assert.assertTrue(caughtError);
+
+            // get results of executed requests
+            for (Future future : futures) {
+                try {
+                    Object res = future.get();
+                } catch (InterruptedException e) {
+                    log.error("Error!", e);
+                } catch (ExecutionException e) {
+                    log.error("Error!", e);
+                }
             }
-        }
 
-        // try to execute once again, expecting that 1 connection is released
-        caughtError = false;
-        for (int i = 0; i < urls.length; i++) {
-            try {
-                client.prepareGet(urls[i]).execute();
-            } catch (IOException e) {
-                // assert that 2nd request fails, because maxTotalConnections=1
-                Assert.assertEquals(i, 1);
-                caughtError = true;
+            // try to execute once again, expecting that 1 connection is released
+            caughtError = false;
+            for (int i = 0; i < urls.length; i++) {
+                try {
+                    client.prepareGet(urls[i]).execute();
+                } catch (IOException e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    Assert.assertEquals(i, 1);
+                    caughtError = true;
+                }
             }
+            Assert.assertTrue(caughtError);
+        } finally {
+            client.close();
         }
-        Assert.assertTrue(caughtError);
-        client.close();
     }
 }
-
-
diff --git a/src/test/java/com/ning/http/client/async/MultipartUploadTest.java b/src/test/java/com/ning/http/client/async/MultipartUploadTest.java
index 580af9ba0..991983e8c 100644
--- a/src/test/java/com/ning/http/client/async/MultipartUploadTest.java
+++ b/src/test/java/com/ning/http/client/async/MultipartUploadTest.java
@@ -70,7 +70,7 @@
     private String BASE_URL;
 
     private String servletEndpointRedirectUrl;
-    public static byte GZIPTEXT[] = new byte[]{31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48, 58, 54, 6, 0, 0, 0};
+    public static byte GZIPTEXT[] = new byte[] { 31, -117, 8, 8, 11, 43, 79, 75, 0, 3, 104, 101, 108, 108, 111, 46, 116, 120, 116, 0, -53, 72, -51, -55, -55, -25, 2, 0, 32, 48, 58, 54, 6, 0, 0, 0 };
 
     @BeforeClass
     public void setUp() throws Exception {
@@ -130,7 +130,7 @@ private File getClasspathFile(String file) throws FileNotFoundException {
     /**
      * Tests that the streaming of a file works.
      */
-    @Test (enabled = true)
+    @Test(enabled = true)
     public void testSendingSmallFilesAndByteArray() {
         String expectedContents = "filecontent: hello";
         String expectedContents2 = "gzipcontent: hello";
@@ -155,7 +155,6 @@ public void testSendingSmallFilesAndByteArray() {
             fail("unable to find " + testResource2);
         }
 
-
         File testResource3File = null;
         try {
             testResource3File = getClasspathFile(testResource3);
@@ -179,7 +178,6 @@ public void testSendingSmallFilesAndByteArray() {
         gzipped.add(true);
         gzipped.add(false);
 
-
         boolean tmpFileCreated = false;
         File tmpFile = null;
         FileOutputStream os = null;
@@ -193,7 +191,6 @@ public void testSendingSmallFilesAndByteArray() {
             expected.add(expectedContents);
             gzipped.add(false);
 
-
         } catch (FileNotFoundException e1) {
             // TODO Auto-generated catch block
             e1.printStackTrace();
@@ -210,13 +207,10 @@ public void testSendingSmallFilesAndByteArray() {
             fail("Unable to test ByteArrayMultiPart, as unable to write to filesystem the tmp test content");
         }
 
-
-        AsyncHttpClientConfig.Builder bc =
-                new AsyncHttpClientConfig.Builder();
+        AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
 
         bc.setFollowRedirects(true);
 
-
         AsyncHttpClient c = new AsyncHttpClient(bc.build());
 
         try {
@@ -232,8 +226,7 @@ public void testSendingSmallFilesAndByteArray() {
             builder.addBodyPart(new StringPart("Height", "shrimplike", AsyncHttpProviderUtils.DEFAULT_CHARSET));
             builder.addBodyPart(new StringPart("Hair", "ridiculous", AsyncHttpProviderUtils.DEFAULT_CHARSET));
 
-            builder.addBodyPart(new ByteArrayPart("file4", "bytearray.txt", expectedContents.getBytes("UTF-8") ,"text/plain", "UTF-8"));
-
+            builder.addBodyPart(new ByteArrayPart("file4", "bytearray.txt", expectedContents.getBytes("UTF-8"), "text/plain", "UTF-8"));
 
             com.ning.http.client.Request r = builder.build();
 
@@ -243,26 +236,24 @@ public void testSendingSmallFilesAndByteArray() {
 
             testSentFile(expected, testFiles, res, gzipped);
 
-            c.close();
         } catch (Exception e) {
             e.printStackTrace();
             fail("Download Exception");
         } finally {
+            c.close();
             FileUtils.deleteQuietly(tmpFile);
         }
     }
 
-
     /**
      * Test that the files were sent, based on the response from the servlet
-     *
+     * 
      * @param expectedContents
      * @param sourceFiles
      * @param r
      * @param deflate
      */
-    private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
-                              Response r, List<Boolean> deflate) {
+    private void testSentFile(List<String> expectedContents, List<File> sourceFiles, Response r, List<Boolean> deflate) {
         String content = null;
         try {
             content = r.getResponseBody();
@@ -283,11 +274,10 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
 
         String[] responseFiles = tmpFiles.split(",");
         assertNotNull(responseFiles);
-        assertEquals( sourceFiles.size(), responseFiles.length);
-
+        assertEquals(sourceFiles.size(), responseFiles.length);
 
         System.out.println(Arrays.toString(responseFiles));
-        //assertTrue("File should exist: " + tmpFile.getAbsolutePath(),tmpFile.exists());
+        // assertTrue("File should exist: " + tmpFile.getAbsolutePath(),tmpFile.exists());
 
         int i = 0;
         for (File sourceFile : sourceFiles) {
@@ -315,7 +305,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                     IOUtils.closeQuietly(instream);
                 }
 
-
                 tmp = new File(responseFiles[i].trim());
                 System.out.println("==============================");
                 System.out.println(tmp.getAbsolutePath());
@@ -323,7 +312,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 System.out.flush();
                 assertTrue(tmp.exists());
 
-
                 instream = new FileInputStream(tmp);
                 ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
                 byte[] buf = new byte[8092];
@@ -359,7 +347,8 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 e.printStackTrace();
                 fail("Download Exception");
             } finally {
-                if (tmp != null) FileUtils.deleteQuietly(tmp);
+                if (tmp != null)
+                    FileUtils.deleteQuietly(tmp);
                 IOUtils.closeQuietly(instream);
                 i++;
             }
@@ -368,7 +357,7 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
 
     /**
      * Takes the content that is being passed to it, and streams to a file on disk
-     *
+     * 
      * @author dominict
      */
     public static class MockMultipartUploadServlet extends HttpServlet {
@@ -379,7 +368,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
         private int filesProcessed = 0;
         private int stringsProcessed = 0;
 
-
         public MockMultipartUploadServlet() {
 
         }
@@ -411,8 +399,7 @@ public int getStringsProcessed() {
         }
 
         @Override
-        public void service(HttpServletRequest request, HttpServletResponse response)
-                throws ServletException, IOException {
+        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             // Check that we have a file upload request
             boolean isMultipart = ServletFileUpload.isMultipartContent(request);
             if (isMultipart) {
@@ -430,12 +417,10 @@ public void service(HttpServletRequest request, HttpServletResponse response)
                             stream = item.openStream();
 
                             if (item.isFormField()) {
-                                System.out.println("Form field " + name + " with value "
-                                        + Streams.asString(stream) + " detected.");
+                                System.out.println("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
                                 incrementStringsProcessed();
                             } else {
-                                System.out.println("File field " + name + " with file name "
-                                        + item.getName() + " detected.");
+                                System.out.println("File field " + name + " with file name " + item.getName() + " detected.");
                                 // Process the input stream
                                 OutputStream os = null;
                                 try {
@@ -480,5 +465,4 @@ public void service(HttpServletRequest request, HttpServletResponse response)
 
     }
 
-
 }
diff --git a/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java b/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
index 6bf0b416b..1e13f6ecc 100644
--- a/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
+++ b/src/test/java/com/ning/http/client/async/MultipleHeaderTest.java
@@ -43,116 +43,118 @@
 /**
  * @author Hubert Iwaniuk
  */
-public abstract class MultipleHeaderTest extends AbstractBasicTest{
+public abstract class MultipleHeaderTest extends AbstractBasicTest {
     private ExecutorService executorService;
     private ServerSocket serverSocket;
     private Future<?> voidFuture;
 
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMultipleOtherHeaders()
-            throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] xffHeaders = new String[]{null, null};
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] xffHeaders = new String[] { null, null };
 
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(req, new AsyncHandler<Void>() {
-            public void onThrowable(Throwable t) {
-                t.printStackTrace(System.out);
-            }
+        try {
+            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
-                int i = 0;
-                for (String header : response.getHeaders().get("X-Forwarded-For")) {
-                    xffHeaders[i++] = header;
+                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                    int i = 0;
+                    for (String header : response.getHeaders().get("X-Forwarded-For")) {
+                        xffHeaders[i++] = header;
+                    }
+                    latch.countDown();
+                    return STATE.CONTINUE;
                 }
-                latch.countDown();
-                return STATE.CONTINUE;
-            }
 
-            public Void onCompleted() throws Exception {
-                return null;
-            }
-        }).get(3, TimeUnit.SECONDS);
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
 
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Time out");
-        }
-        Assert.assertNotNull(xffHeaders[0]);
-        Assert.assertNotNull(xffHeaders[1]);
-        try {
-            Assert.assertEquals(xffHeaders[0], "abc");
-            Assert.assertEquals(xffHeaders[1], "def");
-        } catch (AssertionError ex) {
-            Assert.assertEquals(xffHeaders[1], "abc");
-            Assert.assertEquals(xffHeaders[0], "def");
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Time out");
+            }
+            Assert.assertNotNull(xffHeaders[0]);
+            Assert.assertNotNull(xffHeaders[1]);
+            try {
+                Assert.assertEquals(xffHeaders[0], "abc");
+                Assert.assertEquals(xffHeaders[1], "def");
+            } catch (AssertionError ex) {
+                Assert.assertEquals(xffHeaders[1], "abc");
+                Assert.assertEquals(xffHeaders[0], "def");
+            }
+        } finally {
+            ahc.close();
         }
-        ahc.close();
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
-    public void testMultipleEntityHeaders()
-            throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        final String[] clHeaders = new String[]{null, null};
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
+        final String[] clHeaders = new String[] { null, null };
 
         AsyncHttpClient ahc = getAsyncHttpClient(null);
-        Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
-        final CountDownLatch latch = new CountDownLatch(1);
-        ahc.executeRequest(req, new AsyncHandler<Void>() {
-            public void onThrowable(Throwable t) {
-                t.printStackTrace(System.out);
-            }
+        try {
+            Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
+            final CountDownLatch latch = new CountDownLatch(1);
+            ahc.executeRequest(req, new AsyncHandler<Void>() {
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace(System.out);
+                }
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
-                try {
-                    int i = 0;
-                    for (String header : response.getHeaders().get("Content-Length")) {
-                        clHeaders[i++] = header;
+                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                    try {
+                        int i = 0;
+                        for (String header : response.getHeaders().get("Content-Length")) {
+                            clHeaders[i++] = header;
+                        }
+                    } finally {
+                        latch.countDown();
                     }
-                } finally {
-                    latch.countDown();
+                    return STATE.CONTINUE;
                 }
-                return STATE.CONTINUE;
-            }
 
-            public Void onCompleted() throws Exception {
-                return null;
-            }
-        }).get(3, TimeUnit.SECONDS);
-
-        if (!latch.await(2, TimeUnit.SECONDS)) {
-            Assert.fail("Time out");
-        }
-        Assert.assertNotNull(clHeaders[0]);
-        Assert.assertNotNull(clHeaders[1]);
+                public Void onCompleted() throws Exception {
+                    return null;
+                }
+            }).get(3, TimeUnit.SECONDS);
 
-        // We can predict the order
-        try {
-            Assert.assertEquals(clHeaders[0], "2");
-            Assert.assertEquals(clHeaders[1], "1");
-        } catch (Throwable ex) {
-            Assert.assertEquals(clHeaders[0], "1");
-            Assert.assertEquals(clHeaders[1], "2");
+            if (!latch.await(2, TimeUnit.SECONDS)) {
+                Assert.fail("Time out");
+            }
+            Assert.assertNotNull(clHeaders[0]);
+            Assert.assertNotNull(clHeaders[1]);
+
+            // We can predict the order
+            try {
+                Assert.assertEquals(clHeaders[0], "2");
+                Assert.assertEquals(clHeaders[1], "1");
+            } catch (Throwable ex) {
+                Assert.assertEquals(clHeaders[0], "1");
+                Assert.assertEquals(clHeaders[1], "2");
+            }
+        } finally {
+            ahc.close();
         }
-        ahc.close();
-
     }
 
     @BeforeClass(alwaysRun = true)
@@ -174,23 +176,12 @@ public Void call() throws Exception {
                     socket.shutdownInput();
                     if (req.endsWith("MultiEnt")) {
                         OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" +
-                                "Connection: close\n" +
-                                "Content-Type: text/plain; charset=iso-8859-1\n" +
-                                "Content-Length: 2\n" +
-                                "Content-Length: 1\n" +
-                                "\n0\n");
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 2\n" + "Content-Length: 1\n" + "\n0\n");
                         outputStreamWriter.flush();
                         socket.shutdownOutput();
                     } else if (req.endsWith("MultiOther")) {
                         OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());
-                        outputStreamWriter.append("HTTP/1.0 200 OK\n" +
-                                "Connection: close\n" +
-                                "Content-Type: text/plain; charset=iso-8859-1\n" +
-                                "Content-Length: 1\n" +
-                                "X-Forwarded-For: abc\n" +
-                                "X-Forwarded-For: def\n" +
-                                "\n0\n");
+                        outputStreamWriter.append("HTTP/1.0 200 OK\n" + "Connection: close\n" + "Content-Type: text/plain; charset=iso-8859-1\n" + "Content-Length: 1\n" + "X-Forwarded-For: abc\n" + "X-Forwarded-For: def\n" + "\n0\n");
                         outputStreamWriter.flush();
                         socket.shutdownOutput();
                     }
diff --git a/src/test/java/com/ning/http/client/async/NoNullResponseTest.java b/src/test/java/com/ning/http/client/async/NoNullResponseTest.java
index 2dcb65322..587b29cab 100644
--- a/src/test/java/com/ning/http/client/async/NoNullResponseTest.java
+++ b/src/test/java/com/ning/http/client/async/NoNullResponseTest.java
@@ -33,40 +33,35 @@
 public abstract class NoNullResponseTest extends AbstractBasicTest {
     private static final String VERISIGN_HTTPS_URL = "https://www.verisign.com";
 
-    @Test(invocationCount = 4, groups = {"online", "default_provider"})
+    @Test(invocationCount = 4, groups = { "online", "default_provider" })
     public void multipleSslRequestsWithDelayAndKeepAlive() throws Throwable {
         final AsyncHttpClient client = create();
-        final BoundRequestBuilder builder = client.prepareGet(VERISIGN_HTTPS_URL);
-        final Response response1 = builder.execute().get();
-        Thread.sleep(5000);
-        final Response response2 = builder.execute().get();
-        if (response2 != null) {
-            System.out.println("Success (2nd response was not null).");
-        } else {
-            System.out.println("Failed (2nd response was null).");
+        try {
+            final BoundRequestBuilder builder = client.prepareGet(VERISIGN_HTTPS_URL);
+            final Response response1 = builder.execute().get();
+            Thread.sleep(5000);
+            final Response response2 = builder.execute().get();
+            if (response2 != null) {
+                System.out.println("Success (2nd response was not null).");
+            } else {
+                System.out.println("Failed (2nd response was null).");
+            }
+            Assert.assertNotNull(response1);
+            Assert.assertNotNull(response2);
+        } finally {
+            client.close();
         }
-        Assert.assertNotNull(response1);
-        Assert.assertNotNull(response2);
-        client.close();
     }
 
     private AsyncHttpClient create() throws GeneralSecurityException {
-        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder()
-                .setCompressionEnabled(true)
-                .setFollowRedirects(true)
-                .setSSLContext(getSSLContext())
-                .setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(10000)
-                .setIdleConnectionInPoolTimeoutInMs(60000)
-                .setRequestTimeoutInMs(10000)
-                .setMaximumConnectionsPerHost(-1)
-                .setMaximumConnectionsTotal(-1);
+        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder().setCompressionEnabled(true).setFollowRedirects(true).setSSLContext(getSSLContext()).setAllowPoolingConnection(true).setConnectionTimeoutInMs(10000)
+                .setIdleConnectionInPoolTimeoutInMs(60000).setRequestTimeoutInMs(10000).setMaximumConnectionsPerHost(-1).setMaximumConnectionsTotal(-1);
         return getAsyncHttpClient(configBuilder.build());
     }
 
     private SSLContext getSSLContext() throws GeneralSecurityException {
         final SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, new TrustManager[]{new MockTrustManager()}, null);
+        sslContext.init(null, new TrustManager[] { new MockTrustManager() }, null);
         return sslContext;
     }
 
diff --git a/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java b/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java
index 80acc7942..cebeb26e2 100644
--- a/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java
+++ b/src/test/java/com/ning/http/client/async/NonAsciiContentLengthTest.java
@@ -36,61 +36,62 @@
 
 public abstract class NonAsciiContentLengthTest extends AbstractBasicTest {
 
+    public void setUpServer() throws Exception {
+        server = new Server();
+        port1 = findFreePort();
+        Connector listener = new SelectChannelConnector();
 
-	public void setUpServer() throws Exception {
-		server = new Server();
-		port1 = findFreePort();
-		Connector listener = new SelectChannelConnector();
+        listener.setHost("127.0.0.1");
+        listener.setPort(port1);
+        server.addConnector(listener);
+        server.setHandler(new AbstractHandler() {
 
-		listener.setHost("127.0.0.1");
-		listener.setPort(port1);
-		server.addConnector(listener);
-		server.setHandler(new AbstractHandler() {
+            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                int MAX_BODY_SIZE = 1024; // Can only handle bodies of up to 1024 bytes.
+                byte[] b = new byte[MAX_BODY_SIZE];
+                int offset = 0;
+                int numBytesRead;
+                ServletInputStream is = request.getInputStream();
+                try {
+                    while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
+                        offset += numBytesRead;
+                    }
+                } finally {
+                    is.close();
+                }
+                assertEquals(request.getContentLength(), offset);
+                response.setStatus(200);
+                response.setCharacterEncoding(request.getCharacterEncoding());
+                response.setContentLength(request.getContentLength());
+                ServletOutputStream os = response.getOutputStream();
+                try {
+                    os.write(b, 0, offset);
+                } finally {
+                    os.close();
+                }
+            }
+        });
+        server.start();
+    }
 
-			public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)
-			    throws IOException, ServletException {
-				int MAX_BODY_SIZE = 1024; //Can only handle bodies of up to 1024 bytes.
-				byte[] b = new byte[MAX_BODY_SIZE];
-				int offset = 0;
-				int numBytesRead;
-				ServletInputStream is = request.getInputStream();
-				try {
-					while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
-						offset += numBytesRead;
-					}
-				} finally {
-					is.close();
-				}
-				assertEquals(request.getContentLength(), offset);
-				response.setStatus(200);
-				response.setCharacterEncoding(request.getCharacterEncoding());
-				response.setContentLength(request.getContentLength());
-				ServletOutputStream os = response.getOutputStream();
-				try {
-					os.write(b, 0, offset);
-				} finally {
-					os.close();
-				}
-			}
-		});
-		server.start();
-	}
+    @Test(groups = { "standalone", "default_provider" })
+    public void testNonAsciiContentLength() throws Exception {
+        setUpServer();
+        execute("test");
+        execute("\u4E00"); // Unicode CJK ideograph for one
+    }
 
-	@Test(groups = { "standalone", "default_provider" })
-	public void testNonAsciiContentLength() throws Exception {
-		setUpServer();
-		execute("test");
-		execute("\u4E00"); // Unicode CJK ideograph for one
-	}
-
-	protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
-		AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-		BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding("UTF-8");
-		Future<Response> f = r.execute();
-		Response resp = f.get();
-		assertEquals(resp.getStatusCode(), 200);
-		assertEquals(body, resp.getResponseBody("UTF-8"));
-		client.close();
-	}
+    protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        try {
+            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding("UTF-8");
+            Future<Response> f = r.execute();
+            Response resp = f.get();
+            assertEquals(resp.getStatusCode(), 200);
+            assertEquals(body, resp.getResponseBody("UTF-8"));
+        } finally {
+            client.close();
+        }
+    }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/ParamEncodingTest.java b/src/test/java/com/ning/http/client/async/ParamEncodingTest.java
index eb742de2d..fc84431aa 100644
--- a/src/test/java/com/ning/http/client/async/ParamEncodingTest.java
+++ b/src/test/java/com/ning/http/client/async/ParamEncodingTest.java
@@ -38,10 +38,7 @@
 public abstract class ParamEncodingTest extends AbstractBasicTest {
 
     private class ParamEncoding extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
                 String p = request.getParameter("test");
                 if (isNonEmpty(p)) {
@@ -58,20 +55,20 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .preparePost("http://127.0.0.1:" + port1)
-                .addParameter("test", value)
-                .execute();
-        Response resp = f.get(10, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("X-Param"), value.trim());
-        client.close();
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addParameter("test", value).execute();
+            Response resp = f.get(10, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-Param"), value.trim());
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java b/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java
index 756a25833..e2bc68a31 100644
--- a/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java
+++ b/src/test/java/com/ning/http/client/async/PerRequestRelative302Test.java
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -89,46 +85,42 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void redirected302Test() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+
+            // once
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
 
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setFollowRedirects(true)
-                .setHeader("X-redirect", "http://www.microsoft.com/")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-
-        String anyMicrosoftPage = "http://www.microsoft.com[^:]*:80";
-        String baseUrl = getBaseUrl(response.getUri());
-        
-        c.close();
-        
-        assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+            String anyMicrosoftPage = "http://www.microsoft.com[^:]*:80";
+            String baseUrl = getBaseUrl(response.getUri());
+
+            assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void notRedirected302Test() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            // once
+            Response response = c.prepareGet(getTargetUrl()).setFollowRedirects(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
 
-
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setFollowRedirects(false)
-                .setHeader("X-redirect", "http://www.microsoft.com/")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-
-        c.close();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
     }
 
     private String getBaseUrl(URI uri) {
@@ -148,7 +140,7 @@ private static int getPort(URI uri) {
         return port;
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirected302InvalidTest() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
@@ -156,33 +148,30 @@ public void redirected302InvalidTest() throws Throwable {
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try {
-            Response response = c.preparePost(getTargetUrl())
-                    .setFollowRedirects(true)
-                    .setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2))
-                    .execute().get();
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativeLocationUrl() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
-
-        Response response = c.preparePost(getTargetUrl())
-                .setFollowRedirects(true)
-                .setHeader("X-redirect", "/foo/test")
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        assertEquals(response.getUri().toString(), getTargetUrl());
-        c.close();
+        try {
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirects(true).setHeader("X-redirect", "/foo/test").execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getUri().toString(), getTargetUrl());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java b/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java
index e50bee78d..72de9b993 100644
--- a/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java
+++ b/src/test/java/com/ning/http/client/async/PerRequestTimeoutTest.java
@@ -1,18 +1,18 @@
 /*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License. You may obtain a copy of the License at:
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
 package com.ning.http.client.async;
 
 import com.ning.http.client.AsyncCompletionHandler;
@@ -44,7 +44,7 @@
 
 /**
  * Per request timeout configuration test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class PerRequestTimeoutTest extends AbstractBasicTest {
@@ -95,14 +95,13 @@ public void run() {
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testRequestTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(null);
         PerRequestConfig requestConfig = new PerRequestConfig();
         requestConfig.setRequestTimeoutInMs(100);
-        Future<Response> responseFuture =
-                client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
             client.close();
@@ -113,18 +112,18 @@ public void testRequestTimeout() throws IOException {
             assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
         PerRequestConfig requestConfig = new PerRequestConfig();
         requestConfig.setRequestTimeoutInMs(-1);
-        Future<Response> responseFuture =
-                client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setPerRequestConfig(requestConfig).execute();
             Response response = responseFuture.get();
             assertNotNull(response);
             client.close();
@@ -133,15 +132,16 @@ public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
         } catch (ExecutionException e) {
             assertTrue(e.getCause() instanceof TimeoutException);
             assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalRequestTimeout() throws IOException {
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(100).build());
-        Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
         try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
             client.close();
@@ -152,44 +152,45 @@ public void testGlobalRequestTimeout() throws IOException {
             assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalIdleTimeout() throws IOException {
-        final long times[] = new long[]{-1, -1};
+        final long times[] = new long[] { -1, -1 };
 
         AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setIdleConnectionInPoolTimeoutInMs(2000).build());
-        Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
+        try {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
 
-            @Override
-            public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                times[0] = System.currentTimeMillis();
-                return super.onBodyPartReceived(content);
-            }
+                @Override
+                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                    times[0] = System.currentTimeMillis();
+                    return super.onBodyPartReceived(content);
+                }
 
-            @Override
-            public void onThrowable(Throwable t) {
-                times[1] = System.currentTimeMillis();
-                super.onThrowable(t);
-            }
-        });
-        try {
+                @Override
+                public void onThrowable(Throwable t) {
+                    times[1] = System.currentTimeMillis();
+                    super.onThrowable(t);
+                }
+            });
             Response response = responseFuture.get();
             assertNotNull(response);
             assertEquals(response.getResponseBody(), MSG + MSG);
         } catch (InterruptedException e) {
             fail("Interrupted.", e);
         } catch (ExecutionException e) {
-            log.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.",
-                    times[0], times[1], (times[1] - times[0])));
+            log.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
             fail("Timeouted on idle.", e);
+        } finally {
+            client.close();
         }
-        client.close();
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java b/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java
index 658673384..e581b9f8a 100644
--- a/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java
+++ b/src/test/java/com/ning/http/client/async/PostRedirectGetTest.java
@@ -35,10 +35,8 @@
 
 public abstract class PostRedirectGetTest extends AbstractBasicTest {
 
-
     // ------------------------------------------------------ Test Configuration
 
-
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new PostRedirectGetHandler();
@@ -46,123 +44,111 @@ public AbstractHandler configureHandler() throws Exception {
 
     // ------------------------------------------------------------ Test Methods
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet302Test() throws Exception {
         doTestPositive(302);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet302StrictTest() throws Exception {
         doTestNegative(302, true);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet303Test() throws Exception {
         doTestPositive(303);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet301Test() throws Exception {
         doTestNegative(301, false);
     }
 
-    @Test(groups = {"standalone", "post_redirect_get"})
+    @Test(groups = { "standalone", "post_redirect_get" })
     public void postRedirectGet307Test() throws Exception {
         doTestNegative(307, false);
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private void doTestNegative(final int status, boolean strict) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).
-                setStrict302Handling(strict).
-                addResponseFilter(new ResponseFilter() {
-                    @Override
-                    public FilterContext filter(FilterContext ctx) throws FilterException {
-                        // pass on the x-expect-get and remove the x-redirect
-                        // headers if found in the response
-                        ctx.getResponseHeaders().getHeaders().get("x-expect-post");
-                        ctx.getRequest().getHeaders().add("x-expect-post", "true");
-                        ctx.getRequest().getHeaders().remove("x-redirect");
-                        return ctx;
-                    }
-                }).build());
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl())
-                .addParameter("q", "a b")
-                .addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz")
-                .addHeader("x-negative", "true")
-                .build();
-        Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
             @Override
-            public Integer onCompleted(Response response) throws Exception {
-                return response.getStatusCode();
+            public FilterContext filter(FilterContext ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().getHeaders().get("x-expect-post");
+                ctx.getRequest().getHeaders().add("x-expect-post", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
             }
+        }).build());
+        try {
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        int statusCode = responseFuture.get();
-        Assert.assertEquals(statusCode, 200);
-        p.close();
+            });
+            int statusCode = responseFuture.get();
+            Assert.assertEquals(statusCode, 200);
+        } finally {
+            p.close();
+        }
     }
 
-
     private void doTestPositive(final int status) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).
-                addResponseFilter(new ResponseFilter() {
-                    @Override
-                    public FilterContext filter(FilterContext ctx) throws FilterException {
-                        // pass on the x-expect-get and remove the x-redirect
-                        // headers if found in the response
-                        ctx.getResponseHeaders().getHeaders().get("x-expect-get");
-                        ctx.getRequest().getHeaders().add("x-expect-get", "true");
-                        ctx.getRequest().getHeaders().remove("x-redirect");
-                        return ctx;
-                    }
-                }).build());
-        Request request = new RequestBuilder("POST").setUrl(getTargetUrl())
-                .addParameter("q", "a b")
-                .addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz")
-                .build();
-        Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
-
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).addResponseFilter(new ResponseFilter() {
             @Override
-            public Integer onCompleted(Response response) throws Exception {
-                return response.getStatusCode();
+            public FilterContext filter(FilterContext ctx) throws FilterException {
+                // pass on the x-expect-get and remove the x-redirect
+                // headers if found in the response
+                ctx.getResponseHeaders().getHeaders().get("x-expect-get");
+                ctx.getRequest().getHeaders().add("x-expect-get", "true");
+                ctx.getRequest().getHeaders().remove("x-redirect");
+                return ctx;
             }
+        }).build());
+        try {
+            Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addParameter("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
+            Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
+
+                @Override
+                public Integer onCompleted(Response response) throws Exception {
+                    return response.getStatusCode();
+                }
 
-            /* @Override */
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                Assert.fail("Unexpected exception: " + t.getMessage(), t);
-            }
+                /* @Override */
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    Assert.fail("Unexpected exception: " + t.getMessage(), t);
+                }
 
-        });
-        int statusCode = responseFuture.get();
-        Assert.assertEquals(statusCode, 200);
-        p.close();
+            });
+            int statusCode = responseFuture.get();
+            Assert.assertEquals(statusCode, 200);
+        } finally {
+            p.close();
+        }
     }
 
-
     // ---------------------------------------------------------- Nested Classes
 
-
     public static class PostRedirectGetHandler extends AbstractHandler {
 
         final AtomicInteger counter = new AtomicInteger();
 
         /* @Override */
-        public void handle(String pathInContext,
-                           org.eclipse.jetty.server.Request request,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             final boolean expectGet = (httpRequest.getHeader("x-expect-get") != null);
             final boolean expectPost = (httpRequest.getHeader("x-expect-post") != null);
@@ -212,7 +198,6 @@ public void handle(String pathInContext,
                 return;
             }
 
-
             httpResponse.sendError(500);
             httpResponse.getOutputStream().flush();
             httpResponse.getOutputStream().close();
diff --git a/src/test/java/com/ning/http/client/async/PostWithQSTest.java b/src/test/java/com/ning/http/client/async/PostWithQSTest.java
index dc214579c..39cb9e1c7 100644
--- a/src/test/java/com/ning/http/client/async/PostWithQSTest.java
+++ b/src/test/java/com/ning/http/client/async/PostWithQSTest.java
@@ -41,7 +41,7 @@
 
 /**
  * Tests POST request with Query String.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class PostWithQSTest extends AbstractBasicTest {
@@ -50,10 +50,7 @@
      * POST with QS server part.
      */
     private class PostWithQSHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("POST".equalsIgnoreCase(request.getMethod())) {
                 String qs = request.getQueryString();
                 if (isNonEmpty(qs) && request.getContentLength() == 3) {
@@ -74,54 +71,63 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
-            /* @Override */
-            public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=")) {
-                    throw new IOException(status.getUrl().toURL().toString());
+                /* @Override */
+                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=")) {
+                        throw new IOException(status.getUrl().toURL().toString());
+                    }
+                    return super.onStatusReceived(status);
                 }
-                return super.onStatusReceived(status);
-            }
 
-        });
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+        try {
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
-            /* @Override */
-            public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-                if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
-                    throw new IOException("failed to parse the query properly");
+                /* @Override */
+                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                    if (!status.getUrl().toURL().toString().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
+                        throw new IOException("failed to parse the query properly");
+                    }
+                    return super.onStatusReceived(status);
                 }
-                return super.onStatusReceived(status);
-            }
 
-        });
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        client.close();
+            });
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+        } finally {
+            client.close();
+        }
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/ProviderUtil.java b/src/test/java/com/ning/http/client/async/ProviderUtil.java
index 70f79dc94..17cdbe33d 100644
--- a/src/test/java/com/ning/http/client/async/ProviderUtil.java
+++ b/src/test/java/com/ning/http/client/async/ProviderUtil.java
@@ -1,28 +1,28 @@
 /*
-* Copyright 2010 Ning, Inc.
-*
-* Ning licenses this file to you under the Apache License, version 2.0
-* (the "License"); you may not use this file except in compliance with the
-* License.  You may obtain a copy of the License at:
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-* License for the specific language governing permissions and limitations
-* under the License.
-*/
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
 package com.ning.http.client.async;
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.providers.apache.ApacheAsyncHttpProvider;
+import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 import com.ning.http.client.providers.jdk.JDKAsyncHttpProvider;
 
 public class ProviderUtil {
 
-
     public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
         if (config == null) {
             return new AsyncHttpClient();
@@ -31,6 +31,13 @@ public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
         }
     }
 
+    public static AsyncHttpClient grizzlyProvider(AsyncHttpClientConfig config) {
+        if (config == null) {
+            config = new AsyncHttpClientConfig.Builder().build();
+        }
+        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+    }
+
     public static AsyncHttpClient apacheProvider(AsyncHttpClientConfig config) {
         if (config == null) {
             return new AsyncHttpClient(new ApacheAsyncHttpProvider(new AsyncHttpClientConfig.Builder().build()));
diff --git a/src/test/java/com/ning/http/client/async/ProxyTest.java b/src/test/java/com/ning/http/client/async/ProxyTest.java
index 941897ce0..8a67a6fa7 100644
--- a/src/test/java/com/ning/http/client/async/ProxyTest.java
+++ b/src/test/java/com/ning/http/client/async/ProxyTest.java
@@ -21,8 +21,6 @@
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.ProxyServer;
 import com.ning.http.client.Response;
-import com.ning.http.client.ProxyServer.Protocol;
-import com.ning.http.util.ProxyUtils;
 
 import java.io.IOException;
 import java.net.ConnectException;
@@ -42,15 +40,12 @@
 
 /**
  * Proxy usage tests.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class ProxyTest extends AbstractBasicTest {
     private class ProxyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 response.addHeader("target", r.getUri().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
@@ -66,73 +61,68 @@ public AbstractHandler configureHandler() throws Exception {
         return new ProxyHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .setProxyServer(new ProxyServer("127.0.0.1", port1))
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
-        String target = "http://127.0.0.1:1234/";
-        Future<Response> f = client
-                .prepareGet(target)
-                .setProxyServer(new ProxyServer("127.0.0.1", port1))
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("target"), "/");
-        client.close();
+        try {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClientConfig cfg
-                = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
         AsyncHttpClient client = getAsyncHttpClient(cfg);
         try {
 
             String target = "http://127.0.0.1:1234/";
-            client.prepareGet(target)
-                    .setProxyServer(new ProxyServer("127.0.0.1", port1).addNonProxyHost("127.0.0.1"))
-                    .execute().get();
+            client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1).addNonProxyHost("127.0.0.1")).execute().get();
             assertFalse(true);
         } catch (Throwable e) {
             assertNotNull(e.getCause());
             assertEquals(e.getCause().getClass(), ConnectException.class);
+        } finally {
+            client.close();
         }
-
-        client.close();
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -150,29 +140,31 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
 
             AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
             AsyncHttpClient client = getAsyncHttpClient(cfg);
-
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
             try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                Response resp = f.get(3, TimeUnit.SECONDS);
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getHeader("target"), "/");
+
+                target = "http://localhost:1234/";
+                f = client.prepareGet(target).execute();
+                try {
+                    resp = f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+
+            } finally {
+                client.close();
             }
-            
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
@@ -188,22 +180,24 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
 
             AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().build();
             AsyncHttpClient client = getAsyncHttpClient(cfg);
-
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
             try {
-                f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                try {
+                    f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+
+            } finally {
+                client.close();
             }
-
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         Properties originalProps = System.getProperties();
@@ -220,27 +214,28 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
 
             AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().build();
             AsyncHttpClient client = getAsyncHttpClient(cfg);
-
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
-            Response resp = f.get(3, TimeUnit.SECONDS);
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getHeader("target"), "/");
-
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
             try {
-                resp = f.get(3, TimeUnit.SECONDS);
-                fail("should not be able to connect");
-            } catch (ExecutionException e) {
-                // ok, no proxy used
+                String target = "http://127.0.0.1:1234/";
+                Future<Response> f = client.prepareGet(target).execute();
+                Response resp = f.get(3, TimeUnit.SECONDS);
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getHeader("target"), "/");
+
+                target = "http://localhost:1234/";
+                f = client.prepareGet(target).execute();
+                try {
+                    resp = f.get(3, TimeUnit.SECONDS);
+                    fail("should not be able to connect");
+                } catch (ExecutionException e) {
+                    // ok, no proxy used
+                }
+
+            } finally {
+                client.close();
             }
-            
-            client.close();
         } finally {
             System.setProperties(originalProps);
         }
     }
-    
 }
diff --git a/src/test/java/com/ning/http/client/async/ProxyyTunnellingTest.java b/src/test/java/com/ning/http/client/async/ProxyyTunnellingTest.java
index 9d5bb3ed2..da2a0756f 100644
--- a/src/test/java/com/ning/http/client/async/ProxyyTunnellingTest.java
+++ b/src/test/java/com/ning/http/client/async/ProxyyTunnellingTest.java
@@ -88,7 +88,7 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.setFollowRedirects(true);
@@ -97,28 +97,30 @@ public void testRequestProxy() throws IOException, InterruptedException, Executi
 
         AsyncHttpClientConfig config = b.build();
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-
-        RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
-        Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                log.debug(t.getMessage(), t);
-            }
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response r = responseFuture.get();
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        asyncHttpClient.close();
+        try {
+            RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
+            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    log.debug(t.getMessage(), t);
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response r = responseFuture.get();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+
+        } finally {
+            asyncHttpClient.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.setFollowRedirects(true);
@@ -128,60 +130,53 @@ public void testConfigProxy() throws IOException, InterruptedException, Executio
 
         AsyncHttpClientConfig config = b.build();
         AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-
-        RequestBuilder rb = new RequestBuilder("GET").setUrl(getTargetUrl2());
-        Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-                log.debug(t.getMessage(), t);
-            }
-
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response r = responseFuture.get();
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        asyncHttpClient.close();
+        try {
+            RequestBuilder rb = new RequestBuilder("GET").setUrl(getTargetUrl2());
+            Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                    log.debug(t.getMessage(), t);
+                }
+
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response r = responseFuture.get();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            asyncHttpClient.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()
-                .setProxyProtocol(ProxyServer.Protocol.HTTPS)
-                .setProxyHost("127.0.0.1")
-                .setProxyPort(port1)
-                .setFollowRedirects(true)
-                .setUrl(getTargetUrl2())
-                .setHeader("Content-Type", "text/html").build();
-
-        StringBuffer s = new StringBuffer();
-        Response r = client.get().get();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProxyProtocol(ProxyServer.Protocol.HTTPS).setProxyHost("127.0.0.1").setProxyPort(port1).setFollowRedirects(true).setUrl(getTargetUrl2()).setHeader("Content-Type", "text/html").build();
+        try {
+            Response r = client.get().get();
 
-        assertEquals(r.getStatusCode(), 200);
-        assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
-
-        client.close();
+            assertEquals(r.getStatusCode(), 200);
+            assertEquals(r.getHeader("X-Proxy-Connection"), "keep-alive");
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNonProxyHostsSsl() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-
-        Response resp = client.prepareGet(getTargetUrl2()).setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)
-                .addNonProxyHost("127.0.0.1"))
-                .execute().get(3, TimeUnit.SECONDS);
-
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("X-pathInfo"), "/foo/test");
-
-        client.close();
+        try {
+            Response resp = client.prepareGet(getTargetUrl2()).setProxyServer(new ProxyServer("127.0.0.1", port1 - 1).addNonProxyHost("127.0.0.1")).execute().get(3, TimeUnit.SECONDS);
+
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("X-pathInfo"), "/foo/test");
+        } finally {
+            client.close();
+        }
     }
 }
-
diff --git a/src/test/java/com/ning/http/client/async/PutLargeFileTest.java b/src/test/java/com/ning/http/client/async/PutLargeFileTest.java
index 27cc6b61f..d84ec3234 100644
--- a/src/test/java/com/ning/http/client/async/PutLargeFileTest.java
+++ b/src/test/java/com/ning/http/client/async/PutLargeFileTest.java
@@ -34,46 +34,48 @@
 /**
  * @author Benjamin Hanzelmann
  */
-public abstract class PutLargeFileTest
-        extends AbstractBasicTest {
+public abstract class PutLargeFileTest extends AbstractBasicTest {
 
     private File largeFile;
 
-    @Test(groups = {"standalone", "default_provider"}, enabled = true)
-    public void testPutLargeFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testPutLargeFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 * 1024 * 100 / bytes.length) + 1;
         largeFile = createTempFile(bytes, (int) repeats);
         int timeout = (int) (largeFile.length() / 1000);
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectionTimeoutInMs(timeout).build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.setBody(largeFile);
+            rb.setBody(largeFile);
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
-    public void testPutSmallFile()
-            throws Exception {
+    @Test(groups = { "standalone", "default_provider" })
+    public void testPutSmallFile() throws Exception {
         byte[] bytes = "RatherLargeFileRatherLargeFileRatherLargeFileRatherLargeFile".getBytes("UTF-16");
         long repeats = (1024 / bytes.length) + 1;
-        int timeout = (5000);
         largeFile = createTempFile(bytes, (int) repeats);
 
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
         AsyncHttpClient client = getAsyncHttpClient(config);
-        BoundRequestBuilder rb = client.preparePut(getTargetUrl());
+        try {
+            BoundRequestBuilder rb = client.preparePut(getTargetUrl());
 
-        rb.setBody(largeFile);
+            rb.setBody(largeFile);
 
-        Response response = rb.execute().get();
-        Assert.assertEquals(200, response.getStatusCode());
-        client.close();
+            Response response = rb.execute().get();
+            Assert.assertEquals(200, response.getStatusCode());
+        } finally {
+            client.close();
+        }
     }
 
     @AfterMethod
@@ -82,12 +84,10 @@ public void after() {
     }
 
     @Override
-    public AbstractHandler configureHandler()
-            throws Exception {
+    public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
 
-            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp)
-                    throws IOException, ServletException {
+            public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
 
                 ServletInputStream in = req.getInputStream();
                 byte[] b = new byte[8092];
@@ -110,11 +110,9 @@ public void handle(String arg0, Request arg1, HttpServletRequest req, HttpServle
         };
     }
 
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -124,8 +122,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -134,12 +131,10 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
         }
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/QueryParametersTest.java b/src/test/java/com/ning/http/client/async/QueryParametersTest.java
index da715345d..27d796a07 100644
--- a/src/test/java/com/ning/http/client/async/QueryParametersTest.java
+++ b/src/test/java/com/ning/http/client/async/QueryParametersTest.java
@@ -40,15 +40,12 @@
 
 /**
  * Testing query parameters support.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class QueryParametersTest extends AbstractBasicTest {
     private class QueryStringHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest request,
-                           HttpServletResponse response) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
                 String qs = request.getQueryString();
                 if (isNonEmpty(qs)) {
@@ -72,61 +69,63 @@ public AbstractHandler configureHandler() throws Exception {
         return new QueryStringHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Future<Response> f = client
-                .prepareGet("http://127.0.0.1:" + port1)
-                .addQueryParameter("a", "1")
-                .addQueryParameter("b", "2")
-                .execute();
-        Response resp = f.get(3, TimeUnit.SECONDS);
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getHeader("a"), "1");
-        assertEquals(resp.getHeader("b"), "2");
-        client.close();
+        try {
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParameter("a", "1").addQueryParameter("b", "2").execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("a"), "1");
+            assertEquals(resp.getHeader("b"), "2");
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testUrlRequestParametersEncoding() throws IOException, ExecutionException, InterruptedException {
         String URL = getTargetUrl() + "?q=";
         String REQUEST_PARAM = "github github \ngithub";
 
         AsyncHttpClient client = getAsyncHttpClient(null);
-        String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
-        LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
-        Response response = client.prepareGet(requestUrl2).execute().get();
-        String s = URLDecoder.decode(response.getHeader("q"), "UTF-8");
-        assertEquals(s, REQUEST_PARAM);
-        client.close();
+        try {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
+            LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            String s = URLDecoder.decode(response.getHeader("q"), "UTF-8");
+            assertEquals(s, REQUEST_PARAM);
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void urlWithColonTest_Netty() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
 
-        String query = "test:colon:";
-        Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query))
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+        try {
+            String query = "test:colon:";
+            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
-        c.close();
+            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void urlWithColonTest_JDK() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
+        try {
+            String query = "test:colon:";
+            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        String query = "test:colon:";
-        Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query))
-                .setHeader("Content-Type", "text/html")
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-        assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
-        c.close();
+            assertEquals(response.getHeader("q"), URLEncoder.encode(query, "UTF-8"));
+        } finally {
+            c.close();
+        }
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/RC10KTest.java b/src/test/java/com/ning/http/client/async/RC10KTest.java
index d37c9d2c6..53ae5d400 100644
--- a/src/test/java/com/ning/http/client/async/RC10KTest.java
+++ b/src/test/java/com/ning/http/client/async/RC10KTest.java
@@ -46,7 +46,7 @@
 
 /**
  * Reverse C10K Problem test.
- *
+ * 
  * @author Hubert Iwaniuk
  */
 public abstract class RC10KTest extends AbstractBasicTest {
@@ -102,20 +102,22 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient ahc = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setMaximumConnectionsPerHost(C10K).setAllowPoolingConnection(true).build());
-        List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
-        int i = 0;
-        while (i < C10K) {
-            resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
-        }
-        i = 0;
-        for (Future<Integer> fResp : resps) {
-            Integer resp = fResp.get();
-            assertNotNull(resp);
-            assertEquals(resp.intValue(), i++);
+        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaximumConnectionsPerHost(C10K).setAllowPoolingConnection(true).build());
+        try {
+            List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
+            int i = 0;
+            while (i < C10K) {
+                resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+            }
+            i = 0;
+            for (Future<Integer> fResp : resps) {
+                Integer resp = fResp.get();
+                assertNotNull(resp);
+                assertEquals(resp.intValue(), i++);
+            }
+        } finally {
+            ahc.close();
         }
-        ahc.close();
     }
 
     private class MyAsyncHandler implements AsyncHandler<Integer> {
diff --git a/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java b/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java
index 6cc687e49..e8b638716 100644
--- a/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java
+++ b/src/test/java/com/ning/http/client/async/RedirectConnectionUsageTest.java
@@ -21,7 +21,6 @@
 import com.ning.http.client.ListenableFuture;
 import com.ning.http.client.RequestBuilder;
 import com.ning.http.client.Response;
-import com.ning.http.client.providers.netty.NettyAsyncHttpProviderConfig;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.nio.SelectChannelConnector;
@@ -144,8 +143,6 @@ public void testGetRedirectFinalUrl() {
             // can hang here
             if (c != null) c.close();
         }
-
-
     }
 
     protected abstract AsyncHttpProviderConfig getProviderConfig();
@@ -182,6 +179,4 @@ public void service(HttpServletRequest req, HttpServletResponse res) throws Serv
             os.close();
         }
     }
-
-
 }
diff --git a/src/test/java/com/ning/http/client/async/Relative302Test.java b/src/test/java/com/ning/http/client/async/Relative302Test.java
index e8a72640b..69b21cbc6 100644
--- a/src/test/java/com/ning/http/client/async/Relative302Test.java
+++ b/src/test/java/com/ning/http/client/async/Relative302Test.java
@@ -45,11 +45,7 @@
 
     private class Relative302Handler extends AbstractHandler {
 
-
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
             httpResponse.setContentType("text/html; charset=utf-8");
@@ -89,26 +85,25 @@ public void setUpGlobal() throws Exception {
         log.info("Local HTTP server started successfully");
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void redirected302Test() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            // once
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
 
-        // once
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", "http://www.google.com/")
-                .execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
 
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        
-        String anyGoogleSubdomain = "http://www.google.[a-z]{1,}:80";
-        String baseUrl = getBaseUrl( response.getUri() );
-        
-        assertTrue(baseUrl.matches( anyGoogleSubdomain ), "response does not show redirection to " + anyGoogleSubdomain);
+            String anyGoogleSubdomain = "http://www.google.[a-z]{1,}:80";
+            String baseUrl = getBaseUrl(response.getUri());
 
-        c.close();
+            assertTrue(baseUrl.matches(anyGoogleSubdomain), "response does not show redirection to " + anyGoogleSubdomain);
+        } finally {
+            c.close();
+        }
     }
 
     private String getBaseUrl(URI uri) {
@@ -128,7 +123,7 @@ private static int getPort(URI uri) {
         return port;
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void redirected302InvalidTest() throws Throwable {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
@@ -136,59 +131,56 @@ public void redirected302InvalidTest() throws Throwable {
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try {
-            Response response = c.prepareGet(getTargetUrl())
-                    .setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2))
-                    .execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void absolutePathRedirectTest() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String redirectTarget = "/bar/test";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
+
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
 
-        String redirectTarget = "/bar/test";
-        String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
-        
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", redirectTarget)
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getUri().toString(), destinationUrl);
-        
-        log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        
-        c.close();
+            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void relativePathRedirectTest() throws Throwable {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String redirectTarget = "bar/test1";
+            String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
-        String redirectTarget = "bar/test1";
-        String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
-        
-        Response response = c.prepareGet(getTargetUrl())
-                .setHeader("X-redirect", redirectTarget)
-                .execute().get();
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getUri().toString(), destinationUrl);
-
-        log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        
-        c.close();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", redirectTarget).execute().get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getUri().toString(), destinationUrl);
+
+            log.debug("{} was redirected to {}", redirectTarget, destinationUrl);
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/RemoteSiteTest.java b/src/test/java/com/ning/http/client/async/RemoteSiteTest.java
index 6509b57e5..3f8d12518 100644
--- a/src/test/java/com/ning/http/client/async/RemoteSiteTest.java
+++ b/src/test/java/com/ning/http/client/async/RemoteSiteTest.java
@@ -41,109 +41,112 @@
  * Unit tests for remote site.
  * <p/>
  * see http://github.com/MSch/ning-async-http-client-bug/tree/master
- *
+ * 
  * @author Martin Schurrer
  */
-public abstract class RemoteSiteTest extends AbstractBasicTest{
+public abstract class RemoteSiteTest extends AbstractBasicTest {
 
     public static final String URL = "http://google.com?q=";
-    public static final String REQUEST_PARAM = "github github \n" +
-            "github";
-    
-    @Test(groups = {"online", "default_provider"})
+    public static final String REQUEST_PARAM = "github github \n" + "github";
+
+    @Test(groups = { "online", "default_provider" })
     public void testGoogleCom() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        // Works
-        Response response = c.prepareGet("http://www.google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testMailGoogleCom() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://mail.google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testMicrosoftCom() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        // Works
-        Response response = c.prepareGet("http://microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testWwwMicrosoftCom() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testUpdateMicrosoftCom() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 302);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testGoogleComWithTimeout() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).build());
-        
-        // Works
-        Response response = c.prepareGet("http://google.com/").execute().get(10,TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void asyncStatusHEADContentLenghtTest() throws Throwable {
-        AsyncHttpClient p = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-
-        final CountDownLatch l = new CountDownLatch(1);
-        Request request = new RequestBuilder("HEAD")
-                .setUrl("http://www.google.com/")
-                .build();
-
-        p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-            @Override
-            public Response onCompleted(Response response) throws Exception {
-                Assert.assertEquals(response.getStatusCode(), 200);
-                l.countDown();
-                return response;
+        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
+        try {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("HEAD").setUrl("http://www.google.com/").build();
+
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    Assert.assertEquals(response.getStatusCode(), 200);
+                    l.countDown();
+                    return response;
+                }
+            }).get();
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                Assert.fail("Timeout out");
             }
-        }).get();
-
-        if (!l.await(5, TimeUnit.SECONDS)) {
-            Assert.fail("Timeout out");
+        } finally {
+            p.close();
         }
-        p.close();
     }
 
-    @Test(groups = {"online", "default_provider"}, enabled = false)
+    @Test(groups = { "online", "default_provider" }, enabled = false)
     public void invalidStreamTest2() throws Throwable {
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-                .setRequestTimeoutInMs(10000)
-                .setFollowRedirects(true)
-                .setAllowPoolingConnection(false)
-                .setMaximumNumberOfRedirects(6)
-                .build();
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeoutInMs(10000).setFollowRedirects(true).setAllowPoolingConnection(false).setMaximumNumberOfRedirects(6).build();
 
         AsyncHttpClient c = getAsyncHttpClient(config);
         try {
@@ -155,134 +158,143 @@ public void invalidStreamTest2() throws Throwable {
             t.printStackTrace();
             assertNotNull(t.getCause());
             assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void asyncFullBodyProperlyRead() throws Throwable {
         final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
+        try {
+            Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
 
-        InputStream stream = r.getResponseBodyAsStream();
-        int available = stream.available();
-        int[] lengthWrapper = new int[1];
-        byte[] bytes = AsyncHttpProviderUtils.readFully(stream, lengthWrapper);
-        int byteToRead = lengthWrapper[0];
+            InputStream stream = r.getResponseBodyAsStream();
+            int available = stream.available();
+            int[] lengthWrapper = new int[1];
+            AsyncHttpProviderUtils.readFully(stream, lengthWrapper);
+            int byteToRead = lengthWrapper[0];
 
-        Assert.assertEquals(available, byteToRead);
-        client.close();
+            Assert.assertEquals(available, byteToRead);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})    
+    @Test(groups = { "online", "default_provider" })
     public void testUrlRequestParametersEncoding() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
-        log.info(String.format("Executing request [%s] ...", requestUrl2));
-        Response response = client.prepareGet(requestUrl2).execute().get();
-        Assert.assertEquals(response.getStatusCode(), 301);
-        client.close();
+        try {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, "UTF-8");
+            log.info(String.format("Executing request [%s] ...", requestUrl2));
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            Assert.assertEquals(response.getStatusCode(), 301);
+        } finally {
+            client.close();
+        }
     }
 
     /**
-     * See  https://issues.sonatype.org/browse/AHC-61
+     * See https://issues.sonatype.org/browse/AHC-61
+     * 
      * @throws Throwable
      */
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void testAHC60() throws Throwable {
         AsyncHttpClient client = getAsyncHttpClient(null);
-        Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
-        Assert.assertEquals(response.getStatusCode(), 200);
-        client.close();
+        try {
+            Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
+            Assert.assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void stripQueryStringTest() throws Throwable {
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
 
-        Response response = c.prepareGet("http://www.freakonomics.com/?p=55846")
-                .execute().get();
+        Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
 
         assertNotNull(response);
         assertEquals(response.getStatusCode(), 200);
 
-
         c.close();
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void stripQueryStringNegativeTest() throws Throwable {
 
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder()
-                .setRemoveQueryParamsOnRedirect(false).setFollowRedirects(true).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setRemoveQueryParamsOnRedirect(false).setFollowRedirects(true).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
 
-        Response response = c.prepareGet("http://www.freakonomics.com/?p=55846")
-                .execute().get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 301);
-
-
-        c.close();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"})
+    @Test(groups = { "online", "default_provider" })
     public void evilCoookieTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        RequestBuilder builder2 = new RequestBuilder("GET");
-        builder2.setFollowRedirects(true);
-        builder2.setUrl("http://www.google.com/");
-        builder2.addHeader("Content-Type", "text/plain");
-        builder2.addCookie(new com.ning.http.client.Cookie(".google.com", "evilcookie", "test", "/", 10, false));
-        com.ning.http.client.Request request2 = builder2.build();
-        Response response = c.executeRequest(request2).get();
-
-        assertNotNull(response);
-        assertEquals(response.getStatusCode(), 200);
-        c.close();
+        try {
+            RequestBuilder builder2 = new RequestBuilder("GET");
+            builder2.setFollowRedirects(true);
+            builder2.setUrl("http://www.google.com/");
+            builder2.addHeader("Content-Type", "text/plain");
+            builder2.addCookie(new com.ning.http.client.Cookie(".google.com", "evilcookie", "test", "/", 10, false));
+            com.ning.http.client.Request request2 = builder2.build();
+            Response response = c.executeRequest(request2).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"online", "default_provider"}, enabled = false)
+    @Test(groups = { "online", "default_provider" }, enabled = false)
     public void testAHC62Com() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        // Works
-        Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
-
-            private Response.ResponseBuilder builder = new Response.ResponseBuilder();
-
-            public void onThrowable(Throwable t) {
-                t.printStackTrace();
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                System.out.println(bodyPart.getBodyPartBytes().length);
-                builder.accumulate(bodyPart);
-
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                builder.accumulate(responseStatus);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                builder.accumulate(headers);
-                return STATE.CONTINUE;
-            }
-
-            public Response onCompleted() throws Exception {
-                return builder.build();
-            }
-        }).get(10, TimeUnit.SECONDS);
-        assertNotNull(response);
-        assertTrue(response.getResponseBody().length() >= 3870);
-        c.close();
+        try {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    System.out.println(bodyPart.getBodyPartBytes().length);
+                    builder.accumulate(bodyPart);
+
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return STATE.CONTINUE;
+                }
+
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return STATE.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getResponseBody().length() >= 3870);
+        } finally {
+            c.close();
+        }
     }
-
 }
-
diff --git a/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java b/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java
index 247fe8c2a..86eabd4ba 100644
--- a/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java
+++ b/src/test/java/com/ning/http/client/async/RetryNonBlockingIssue.java
@@ -259,6 +259,7 @@ public void testRetryBlocking() throws IOException, InterruptedException,
         }
     }
 
+    @SuppressWarnings("serial")
     public class MockExceptionServlet extends HttpServlet {
 
         private Map<String, Integer> requests = new
@@ -325,7 +326,6 @@ public void service(HttpServletRequest req, HttpServletResponse res)
             if (error != null && error.trim().length() > 0)
                 res.sendError(500, "servlet process was 500");
         }
-
     }
 }
 
diff --git a/src/test/java/com/ning/http/client/async/RetryRequestTest.java b/src/test/java/com/ning/http/client/async/RetryRequestTest.java
index 3cd92523b..6b6ccd86b 100644
--- a/src/test/java/com/ning/http/client/async/RetryRequestTest.java
+++ b/src/test/java/com/ning/http/client/async/RetryRequestTest.java
@@ -29,9 +29,7 @@
 public abstract class RetryRequestTest extends AbstractBasicTest {
     public static class SlowAndBigHandler extends AbstractHandler {
 
-        public void handle(String pathInContext, Request request,
-                           HttpServletRequest httpRequest, HttpServletResponse httpResponse)
-                throws IOException, ServletException {
+        public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int load = 100;
             httpResponse.setStatus(200);
@@ -40,7 +38,6 @@ public void handle(String pathInContext, Request request,
 
             httpResponse.flushBuffer();
 
-
             OutputStream os = httpResponse.getOutputStream();
             for (int i = 0; i < load; i++) {
                 os.write(i % 255);
@@ -51,7 +48,6 @@ public void handle(String pathInContext, Request request,
                     // nuku
                 }
 
-
                 if (i > load / 10) {
                     httpResponse.sendError(500);
                 }
@@ -71,8 +67,7 @@ public AbstractHandler configureHandler() throws Exception {
         return new SlowAndBigHandler();
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testMaxRetry() throws Throwable {
         AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).build());
         try {
@@ -84,8 +79,8 @@ public void testMaxRetry() throws Throwable {
             if (!t.getCause().getMessage().startsWith("Remotely Closed")) {
                 fail();
             }
+        } finally {
+            ahc.close();
         }
-
-        ahc.close();
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java b/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java
index 4206f6b96..064b472e0 100644
--- a/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java
+++ b/src/test/java/com/ning/http/client/async/SimpleAsyncClientErrorBehaviourTest.java
@@ -34,60 +34,57 @@
 
 /**
  * @author Benjamin Hanzelmann
- *
+ * 
  */
 public class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testAccumulateErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour( ErrorDocumentBehaviour.ACCUMULATE ).build();
-    
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-    
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 404);
-        assertEquals(o.toString(), "");
-        assertTrue(response.getResponseBody().startsWith("<html>"));
-    
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertTrue(response.getResponseBody().startsWith("<html>"));
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testOmitErrorBody() throws Throwable {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour( ErrorDocumentBehaviour.OMIT ).build();
-    
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
-    
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 404);
-        assertEquals(o.toString(), "");
-        assertEquals(response.getResponseBody(), "");
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 404);
+            assertEquals(o.toString(), "");
+            assertEquals(response.getResponseBody(), "");
+        } finally {
+            client.close();
+        }
     }
 
     @Override
-    public AsyncHttpClient getAsyncHttpClient( AsyncHttpClientConfig config )
-    {
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         // disabled
         return null;
     }
 
     @Override
-    public AbstractHandler configureHandler()
-        throws Exception
-    {
+    public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
-    
-            public void handle( String target, org.eclipse.jetty.server.Request baseRequest,
-                                HttpServletRequest request, HttpServletResponse response )
-                throws IOException, ServletException
-            {
-                response.sendError( 404 );
-                baseRequest.setHandled( true );
+
+            public void handle(String target, org.eclipse.jetty.server.Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+                response.sendError(404);
+                baseRequest.setHandled(true);
             }
         };
     }
diff --git a/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java b/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
index f981fc61b..8039591c3 100644
--- a/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
+++ b/src/test/java/com/ning/http/client/async/SimpleAsyncHttpClientTest.java
@@ -12,7 +12,6 @@
  */
 package com.ning.http.client.async;
 
-import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.ByteArrayPart;
 import com.ning.http.client.Response;
 import com.ning.http.client.SimpleAsyncHttpClient;
@@ -43,67 +42,68 @@
     @Test(groups = { "standalone", "default_provider" })
     public void inpuStreamBodyConsumerTest() throws Throwable {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(response.getResponseBody(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBody(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void StringBufferBodyConsumerTest() throws Throwable {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        StringBuilder s = new StringBuilder();
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(s.toString(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            StringBuilder s = new StringBuilder();
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(s.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void ByteArrayOutputStreamBodyConsumerTest() throws Throwable {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-
-        client.close();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
 
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-        Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
-
-        System.out.println("waiting for response");
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
-
-        client.close();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+            Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
+
+            System.out.println("waiting for response");
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     /**
@@ -111,53 +111,55 @@ public void RequestByteArrayOutputStreamBodyConsumerTest() throws Throwable {
      */
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
     public void testPutZeroBytesFileTest() throws Throwable {
-        System.err.println("setting up client");
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50)
-                .setRequestTimeoutInMs(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain").build();
-
-        File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
-        tmpfile.deleteOnExit();
-
-        Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setIdleConnectionInPoolTimeoutInMs(100).setMaximumConnectionsTotal(50).setRequestTimeoutInMs(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain")
+                .build();
+        try {
+            File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
+            tmpfile.deleteOnExit();
 
-        System.out.println("waiting for response");
-        Response response = future.get();
+            Future<Response> future = client.put(new FileBodyGenerator(tmpfile));
 
-        tmpfile.delete();
+            Response response = future.get();
 
-        assertEquals(response.getStatusCode(), 200);
+            tmpfile.delete();
 
-        client.close();
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDerive() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build();
         SimpleAsyncHttpClient derived = client.derive().build();
-
-        assertNotSame(derived, client);
-        client.close();
-        derived.close();
+        try {
+            assertNotSame(derived, client);
+        } finally {
+            client.close();
+            derived.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDeriveOverrideURL() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build();
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
-
-        InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-        OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
-
         SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build();
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-        Future<Response> future = derived.post(generator, consumer);
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-        Response response = future.get();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
+            Future<Response> future = derived.post(generator, consumer);
 
-        client.close();
-        derived.close();
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+            derived.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -194,44 +196,47 @@ public void onBytesReceived(String url, long amount, long current, long total) {
         };
 
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).setHeader("Custom", "custom").setListener(listener).build();
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+        try {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-        InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-        OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-        Future<Response> future = client.post(generator, consumer);
+            Future<Response> future = client.post(generator, consumer);
 
-        Response response = future.get();
-        client.close();
-        assertEquals(response.getStatusCode(), 200);
-        assertEquals(o.toString(), MY_MESSAGE);
+            Response response = future.get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(o.toString(), MY_MESSAGE);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNullUrl() throws Exception {
+        SimpleAsyncHttpClient c = new SimpleAsyncHttpClient.Builder().build().derive().build();
         try {
-            SimpleAsyncHttpClient c = new SimpleAsyncHttpClient.Builder().build().derive().build();
             assertTrue(true);
+        } finally {
             c.close();
-        } catch (NullPointerException ex) {
-            fail();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testCloseDerivedValidMaster() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
-        SimpleAsyncHttpClient derived = client.derive().build();
-
-        derived.get().get();
-
-        derived.close();
+        try {
+            SimpleAsyncHttpClient derived = client.derive().build();
+            derived.get().get();
 
-        Response response = client.get().get();
+            derived.close();
 
-        assertEquals(response.getStatusCode(), 200);
+            Response response = client.get().get();
 
-        client.close();
+            assertEquals(response.getStatusCode(), 200);
+        } finally {
+            client.close();
+        }
     }
 
     @Test(groups = { "standalone", "default_provider" })
@@ -252,49 +257,49 @@ public void testCloseMasterInvalidDerived() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPut() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
-        
-        Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
-        
-        String body = response.getResponseBody();
-        String contentType = response.getHeader("X-Content-Type");
-        
-        assertTrue(contentType.contains("multipart/form-data"));
-        
-        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-        
-        assertTrue(body.startsWith("--" + boundary));
-        assertTrue(body.trim().endsWith("--" + boundary + "--"));
-        assertTrue(body.contains("Content-Disposition:"));
-        assertTrue(body.contains("Content-Type: application/test"));
-        assertTrue(body.contains("name=\"baPart"));
-        assertTrue(body.contains("filename=\"fileName"));
+        try {
+            Response response = client.put(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
 
-        client.close();
-        
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
+
+            assertTrue(contentType.contains("multipart/form-data"));
+
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        } finally {
+            client.close();
+        }
     }
-    
+
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPost() throws Exception {
         SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build();
-        
-        Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
-        
-        String body = response.getResponseBody();
-        String contentType = response.getHeader("X-Content-Type");
-        
-        assertTrue(contentType.contains("multipart/form-data"));
-        
-        String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
-        
-        assertTrue(body.startsWith("--" + boundary));
-        assertTrue(body.trim().endsWith("--" + boundary + "--"));
-        assertTrue(body.contains("Content-Disposition:"));
-        assertTrue(body.contains("Content-Type: application/test"));
-        assertTrue(body.contains("name=\"baPart"));
-        assertTrue(body.contains("filename=\"fileName"));
+        try {
+            Response response = client.post(new ByteArrayPart("baPart", "fileName", "testMultiPart".getBytes("utf-8"), "application/test", "utf-8")).get();
 
-        client.close();
-        
+            String body = response.getResponseBody();
+            String contentType = response.getHeader("X-Content-Type");
+
+            assertTrue(contentType.contains("multipart/form-data"));
+
+            String boundary = contentType.substring(contentType.lastIndexOf("=") + 1);
+
+            assertTrue(body.startsWith("--" + boundary));
+            assertTrue(body.trim().endsWith("--" + boundary + "--"));
+            assertTrue(body.contains("Content-Disposition:"));
+            assertTrue(body.contains("Content-Type: application/test"));
+            assertTrue(body.contains("name=\"baPart"));
+            assertTrue(body.contains("filename=\"fileName"));
+        } finally {
+            client.close();
+        }
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/TransferListenerTest.java b/src/test/java/com/ning/http/client/async/TransferListenerTest.java
index e2b80690c..894f1150d 100644
--- a/src/test/java/com/ning/http/client/async/TransferListenerTest.java
+++ b/src/test/java/com/ning/http/client/async/TransferListenerTest.java
@@ -40,15 +40,11 @@
 import static org.testng.Assert.fail;
 
 public abstract class TransferListenerTest extends AbstractBasicTest {
-    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-"
-            + UUID.randomUUID().toString().substring(0, 8));
+    private static final File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
 
     private class BasicHandler extends AbstractHandler {
 
-        public void handle(String s,
-                           org.eclipse.jetty.server.Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             Enumeration<?> e = httpRequest.getHeaderNames();
             String param;
@@ -78,10 +74,8 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicGetTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-
         final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
         final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
@@ -115,9 +109,9 @@ public void onThrowable(Throwable t) {
             }
         });
 
+        AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.prepareGet(getTargetUrl())
-                    .execute(tl).get();
+            Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -127,13 +121,13 @@ public void onThrowable(Throwable t) {
             assertNull(throwable.get());
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicPutTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
 
         final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
@@ -175,9 +169,9 @@ public void onThrowable(Throwable t) {
             }
         });
 
+        AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePut(getTargetUrl()).setBody(largeFile)
-                    .execute(tl).get();
+            Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(tl).get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -187,13 +181,13 @@ public void onThrowable(Throwable t) {
             assertEquals(bbSentLenght.get(), largeFile.length());
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicPutBodyTest() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
 
         final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
         final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
@@ -235,9 +229,9 @@ public void onThrowable(Throwable t) {
             }
         });
 
+        AsyncHttpClient c = getAsyncHttpClient(null);
         try {
-            Response response = c.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(largeFile))
-                    .execute(tl).get();
+            Response response = c.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(largeFile)).execute(tl).get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -247,16 +241,16 @@ public void onThrowable(Throwable t) {
             assertEquals(bbSentLenght.get(), largeFile.length());
         } catch (IOException ex) {
             fail("Should have timed out");
+        } finally {
+            c.close();
         }
-        c.close();
     }
 
     public String getTargetUrl() {
         return String.format("http://127.0.0.1:%d/foo/test", port1);
     }
 
-    public static File createTempFile(byte[] pattern, int repeat)
-            throws IOException {
+    public static File createTempFile(byte[] pattern, int repeat) throws IOException {
         TMP.mkdirs();
         TMP.deleteOnExit();
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP);
@@ -265,8 +259,7 @@ public static File createTempFile(byte[] pattern, int repeat)
         return tmpFile;
     }
 
-    public static void write(byte[] pattern, int repeat, File file)
-            throws IOException {
+    public static void write(byte[] pattern, int repeat, File file) throws IOException {
         file.deleteOnExit();
         file.getParentFile().mkdirs();
         FileOutputStream out = null;
@@ -275,8 +268,7 @@ public static void write(byte[] pattern, int repeat, File file)
             for (int i = 0; i < repeat; i++) {
                 out.write(pattern);
             }
-        }
-        finally {
+        } finally {
             if (out != null) {
                 out.close();
             }
diff --git a/src/test/java/com/ning/http/client/async/WebDavBasicTest.java b/src/test/java/com/ning/http/client/async/WebDavBasicTest.java
index 77b69dcf6..720cd5adb 100644
--- a/src/test/java/com/ning/http/client/async/WebDavBasicTest.java
+++ b/src/test/java/com/ning/http/client/async/WebDavBasicTest.java
@@ -38,7 +38,6 @@
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 
-
 public abstract class WebDavBasicTest extends AbstractBasicTest {
 
     public Embedded embedded;
@@ -94,91 +93,100 @@ public void tearDownGlobal() throws InterruptedException, Exception {
         embedded.stop();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-
-        assertEquals(response.getStatusCode(), 201);
-
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+
+            assertEquals(response.getStatusCode(), 201);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 409);
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 409);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(propFindRequest).get();
-
-        assertEquals(response.getStatusCode(), 404);
-        c.close();
+        try {
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(propFindRequest).get();
+
+            assertEquals(response.getStatusCode(), 404);
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request putRequest = new RequestBuilder("PUT").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
-        response = c.executeRequest(putRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
-        response = c.executeRequest(propFindRequest).get();
-
-        assertEquals(response.getStatusCode(), 207);
-        assertTrue(response.getResponseBody().contains("<status>HTTP/1.1 200 OK</status>"));
-        c.close();
-
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request putRequest = new RequestBuilder("PUT").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
+            response = c.executeRequest(putRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
+            response = c.executeRequest(propFindRequest).get();
+
+            assertEquals(response.getStatusCode(), 207);
+            assertTrue(response.getResponseBody().contains("<status>HTTP/1.1 200 OK</status>"));
+        } finally {
+            c.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
 
         AsyncHttpClient c = getAsyncHttpClient(null);
-
-        Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
-        Response response = c.executeRequest(mkcolRequest).get();
-        assertEquals(response.getStatusCode(), 201);
-
-        Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
-        WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
-            /**
-             * {@inheritDoc}
-             */
-            /* @Override */
-            public void onThrowable(Throwable t) {
-
-                t.printStackTrace();
-            }
-
-            @Override
-            public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
-                return response;
-            }
-        }).get();
-
-        assertNotNull(webDavResponse);
-        assertEquals(webDavResponse.getStatusCode(), 200);
-        c.close();
+        try {
+            Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
+            Response response = c.executeRequest(mkcolRequest).get();
+            assertEquals(response.getStatusCode(), 201);
+
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
+            WebDavResponse webDavResponse = c.executeRequest(propFindRequest, new WebDavCompletionHandlerBase<WebDavResponse>() {
+                /**
+                 * {@inheritDoc}
+                 */
+                /* @Override */
+                public void onThrowable(Throwable t) {
+
+                    t.printStackTrace();
+                }
+
+                @Override
+                public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
+                    return response;
+                }
+            }).get();
+
+            assertNotNull(webDavResponse);
+            assertEquals(webDavResponse.getStatusCode(), 200);
+        } finally {
+            c.close();
+        }
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java b/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java
index 64efdb4c2..b5400b183 100644
--- a/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java
+++ b/src/test/java/com/ning/http/client/async/ZeroCopyFileTest.java
@@ -47,10 +47,7 @@
 public abstract class ZeroCopyFileTest extends AbstractBasicTest {
 
     private class ZeroCopyHandler extends AbstractHandler {
-        public void handle(String s,
-                           Request r,
-                           HttpServletRequest httpRequest,
-                           HttpServletResponse httpResponse) throws IOException, ServletException {
+        public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             int size = 10 * 1024;
             if (httpRequest.getContentLength() > 0) {
@@ -67,59 +64,62 @@ public void handle(String s,
         }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+            final AtomicBoolean headerSent = new AtomicBoolean(false);
+            final AtomicBoolean operationCompleted = new AtomicBoolean(false);
+
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncCompletionHandler<Response>() {
+
+                public STATE onHeaderWriteCompleted() {
+                    headerSent.set(true);
+                    return STATE.CONTINUE;
+                }
 
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-        final AtomicBoolean headerSent = new AtomicBoolean(false);
-        final AtomicBoolean operationCompleted = new AtomicBoolean(false);
-
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncCompletionHandler() {
-
-            public STATE onHeaderWriteCompleted() {
-                headerSent.set(true);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onContentWriteCompleted() {
-                operationCompleted.set(true);
-                return STATE.CONTINUE;
-            }
+                public STATE onContentWriteCompleted() {
+                    operationCompleted.set(true);
+                    return STATE.CONTINUE;
+                }
 
-            @Override
-            public Object onCompleted(Response response) throws Exception {
-                return response;
-            }
-        });
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        assertTrue(operationCompleted.get());
-        assertTrue(headerSent.get());
-        client.close();
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    return response;
+                }
+            });
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+            assertTrue(operationCompleted.get());
+            assertTrue(headerSent.get());
+        } finally {
+            client.close();
+        }
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
-
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(file).execute();
-        Response resp = f.get();
-        assertNotNull(resp);
-        assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        assertEquals(resp.getResponseBody(), "This is a simple test file");
-        client.close();
-
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(file).execute();
+            Response resp = f.get();
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getResponseBody(), "This is a simple test file");
+        } finally {
+            client.close();
+        }
     }
 
     @Override
@@ -127,92 +127,92 @@ public AbstractHandler configureHandler() throws Exception {
         return new ZeroCopyHandler();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+            tmp.deleteOnExit();
+            final FileOutputStream stream = new FileOutputStream(tmp);
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+                public void onThrowable(Throwable t) {
+                }
 
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
-            public void onThrowable(Throwable t) {
-            }
-
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                bodyPart.writeTo(stream);
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    bodyPart.writeTo(stream);
+                    return STATE.CONTINUE;
+                }
 
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public Response onCompleted() throws Exception {
-                return null;
-            }
-        });
-        Response resp = f.get();
-        stream.close();
-        assertNull(resp);
-        assertEquals(file.length(), tmp.length());
-        client.close();
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
+                public Response onCompleted() throws Exception {
+                    return null;
+                }
+            });
+            Response resp = f.get();
+            stream.close();
+            assertNull(resp);
+            assertEquals(file.length(), tmp.length());
+        } finally {
+            client.close();
+        }
     }
 
-
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         AsyncHttpClient client = getAsyncHttpClient(null);
+        try {
+            ClassLoader cl = getClass().getClassLoader();
+            // override system properties
+            URL url = cl.getResource("SimpleTextFile.txt");
+            File file = new File(url.toURI());
+
+            File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
+            tmp.deleteOnExit();
+            final FileOutputStream stream = new FileOutputStream(tmp);
+            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
+                public void onThrowable(Throwable t) {
+                }
 
-        ClassLoader cl = getClass().getClassLoader();
-        // override system properties
-        URL url = cl.getResource("SimpleTextFile.txt");
-        File file = new File(url.toURI());
-
-        File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
-        tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(file).execute(new AsyncHandler<Response>() {
-            public void onThrowable(Throwable t) {
-            }
+                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    bodyPart.writeTo(stream);
 
-            public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                bodyPart.writeTo(stream);
+                    if (bodyPart.getBodyPartBytes().length == 0) {
+                        return STATE.ABORT;
+                    }
 
-                if (bodyPart.getBodyPartBytes().length == 0) {
-                    return STATE.ABORT;
+                    return STATE.CONTINUE;
                 }
-                          
-                return STATE.CONTINUE;
-            }
-
-            public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                return STATE.CONTINUE;
-            }
 
-            public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                return STATE.CONTINUE;
-            }
+                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
-            public Response onCompleted() throws Exception {
-                return null;
-            }
-        });
-        Response resp = f.get();
-        stream.close();
-        assertNull(resp);
-        assertEquals(file.length(), tmp.length());
-        client.close();
+                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return STATE.CONTINUE;
+                }
 
+                public Response onCompleted() throws Exception {
+                    return null;
+                }
+            });
+            Response resp = f.get();
+            stream.close();
+            assertNull(resp);
+            assertEquals(file.length(), tmp.length());
+        } finally {
+            client.close();
+        }
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncProviderBasicTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncProviderBasicTest.java
index c718e2e03..739bb8f4f 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncProviderBasicTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncProviderBasicTest.java
@@ -13,46 +13,36 @@
 
 package com.ning.http.client.async.grizzly;
 
+import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+
+import org.glassfish.grizzly.filterchain.FilterChainBuilder;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
+import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.AsyncHttpProviderConfig;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.Response;
 import com.ning.http.client.async.AsyncProvidersBasicTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
 import com.ning.http.client.providers.grizzly.TransportCustomizer;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
-import static org.testng.Assert.assertEquals;
 
 public class GrizzlyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Override
     @Test
     public void asyncHeaderPOSTTest() throws Throwable {
-        super.asyncHeaderPOSTTest();    //To change body of overridden methods use File | Settings | File Templates.
+        super.asyncHeaderPOSTTest(); // To change body of overridden methods use File | Settings | File Templates.
     }
 
     @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
         final GrizzlyAsyncHttpProviderConfig config = new GrizzlyAsyncHttpProviderConfig();
         config.addProperty(TRANSPORT_CUSTOMIZER, new TransportCustomizer() {
             @Override
@@ -64,7 +54,7 @@ public void customize(TCPNIOTransport transport, FilterChainBuilder builder) {
         return config;
     }
 
-    @Test(groups = {"standalone", "default_provider", "async"}, enabled = false)
+    @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
     public void asyncDoPostBasicGZIPTest() throws Throwable {
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamHandlerTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamHandlerTest.java
index c9bb4de00..cce326372 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamHandlerTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.AsyncStreamHandlerTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamLifecycleTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamLifecycleTest.java
index b2d376d69..094eecb13 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamLifecycleTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAsyncStreamLifecycleTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.AsyncStreamLifecycleTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAuthTimeoutTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAuthTimeoutTest.java
index c0224564c..631d25c9d 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAuthTimeoutTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyAuthTimeoutTest.java
@@ -16,17 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.AuthTimeoutTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyAuthTimeoutTest extends AuthTimeoutTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicAuthTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicAuthTest.java
index 4f0dc2634..98323e7b2 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicAuthTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicAuthTest.java
@@ -16,17 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.BasicAuthTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyBasicAuthTest extends BasicAuthTest {
 
-
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicHttpsTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicHttpsTest.java
index d5e27c68f..2ebeedc18 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicHttpsTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBasicHttpsTest.java
@@ -16,20 +16,17 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.BasicHttpsTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyBasicHttpsTest extends BasicHttpsTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Override
     public void zeroCopyPostTest() throws Throwable {
-        super.zeroCopyPostTest();    //To change body of overridden methods use File | Settings | File Templates.
+        super.zeroCopyPostTest(); // To change body of overridden methods use File | Settings | File Templates.
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyChunkTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyChunkTest.java
index 643628e64..9a5867898 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyChunkTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyChunkTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.BodyChunkTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyBodyChunkTest extends BodyChunkTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
index 889f49ad8..5b0810fee 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
@@ -16,15 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.BodyDeferringAsyncHandlerTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyByteBufferCapacityTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyByteBufferCapacityTest.java
index b875ce10f..d3522541b 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyByteBufferCapacityTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyByteBufferCapacityTest.java
@@ -13,23 +13,21 @@
 
 package com.ning.http.client.async.grizzly;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ByteBufferCapacityTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.testng.annotations.Test;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyByteBufferCapacityTest extends ByteBufferCapacityTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
-    @Test(groups = {"standalone", "default_provider"}, enabled=false)
+    @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicByteBufferTest() throws Throwable {
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyChunkingTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyChunkingTest.java
index 153f80c80..9f07b7d49 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyChunkingTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyChunkingTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ChunkingTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyChunkingTest extends ChunkingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyComplexClientTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyComplexClientTest.java
index 0b8b4a9d1..5a5bd7a0f 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyComplexClientTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyComplexClientTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ComplexClientTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyComplexClientTest extends ComplexClientTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyConnectionPoolTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyConnectionPoolTest.java
index 37395056c..4eabd6c65 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyConnectionPoolTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyConnectionPoolTest.java
@@ -13,63 +13,61 @@
 
 package com.ning.http.client.async.grizzly;
 
-import com.ning.http.client.AsyncCompletionHandler;
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Response;
-import com.ning.http.client.async.ConnectionPoolTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.Connection;
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.fail;
 
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.testng.Assert.*;
+import org.glassfish.grizzly.Connection;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.AsyncCompletionHandler;
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.Response;
+import com.ning.http.client.async.ConnectionPoolTest;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyConnectionPoolTest extends ConnectionPoolTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Override
     @Test
     public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setAllowPoolingConnection(true)
-                        .setMaximumConnectionsTotal(1)
-                        .build()
-        );
-
-        String url = getTargetUrl();
-        int i;
-        Exception exception = null;
-        for (i = 0; i < 20; i++) {
-            try {
-                log.info("{} requesting url [{}]...", i, url);
-
-                if (i < 5) {
-                    client.prepareGet(url).execute().get();
-                } else {
-                    client.prepareGet(url).execute();
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setMaximumConnectionsTotal(1).build());
+        try {
+            String url = getTargetUrl();
+            int i;
+            Exception exception = null;
+            for (i = 0; i < 20; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+
+                    if (i < 5) {
+                        client.prepareGet(url).execute().get();
+                    } else {
+                        client.prepareGet(url).execute();
+                    }
+                } catch (Exception ex) {
+                    exception = ex;
+                    break;
                 }
-            } catch (Exception ex) {
-                exception = ex;
-                break;
             }
+            assertNotNull(exception);
+            assertNotNull(exception.getMessage());
+        } finally {
+            client.close();
         }
-        assertNotNull(exception);
-        assertNotNull(exception.getMessage());
-
     }
 
     @Override
@@ -97,24 +95,22 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        } finally {
+            client.close();
         }
-        assertNull(exception);
-        client.close();
     }
 
-    @Test(groups = {"standalone", "default_provider"})
+    @Test(groups = { "standalone", "default_provider" })
     public void testInvalidConnectionsPool() {
 
         ConnectionsPool<String, Connection> cp = new ConnectionsPool<String, Connection>() {
@@ -140,74 +136,68 @@ public void destroy() {
             }
         };
 
-        AsyncHttpClient client = getAsyncHttpClient(
-                new AsyncHttpClientConfig.Builder()
-                        .setConnectionsPool(cp)
-                        .build()
-        );
-
-        Exception exception = null;
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionsPool(cp).build());
         try {
-            client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+        } finally {
+            client.close();
         }
-        assertNotNull(exception);
-        client.close();
     }
 
     @Override
     @Test
     public void multipleMaxConnectionOpenTest() throws Throwable {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true)
-                .setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnection(true).setConnectionTimeoutInMs(5000).setMaximumConnectionsTotal(1).build();
         AsyncHttpClient c = getAsyncHttpClient(cg);
+        try {
+            String body = "hello there";
 
-        String body = "hello there";
-
-        // once
-        Response response = c.preparePost(getTargetUrl())
-                .setBody(body)
-                .execute().get(TIMEOUT, TimeUnit.SECONDS);
+            // once
+            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-        assertEquals(response.getResponseBody(), body);
+            assertEquals(response.getResponseBody(), body);
 
-        // twice
-        Exception exception = null;
-        try {
-            c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            fail("Should throw exception. Too many connections issued.");
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            exception = ex;
+            // twice
+            Exception exception = null;
+            try {
+                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                fail("Should throw exception. Too many connections issued.");
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+        } finally {
+            c.close();
         }
-        assertNotNull(exception);
-        c.close();
     }
 
-
     @Override
     @Test
     public void win7DisconnectTest() throws Throwable {
         final AtomicInteger count = new AtomicInteger(0);
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        AsyncCompletionHandler<Response> handler = new
-                AsyncCompletionHandlerAdapter() {
-
-                    @Override
-                    public Response onCompleted(Response response) throws
-                            Exception {
-
-                        count.incrementAndGet();
-                        StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
-                        IOException t = new IOException();
-                        t.setStackTrace(new StackTraceElement[]{e});
-                        throw t;
-                    }
-                };
+        AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
+            @Override
+            public Response onCompleted(Response response) throws Exception {
+
+                count.incrementAndGet();
+                StackTraceElement e = new StackTraceElement("sun.nio.ch.SocketDispatcher", "read0", null, -1);
+                IOException t = new IOException();
+                t.setStackTrace(new StackTraceElement[] { e });
+                throw t;
+            }
+        };
+
+        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
         try {
             client.prepareGet(getTargetUrl()).execute(handler).get();
             fail("Must have received an exception");
@@ -216,8 +206,8 @@ public Response onCompleted(Response response) throws
             assertNotNull(ex.getCause());
             assertEquals(ex.getCause().getClass(), IOException.class);
             assertEquals(count.get(), 1);
+        } finally {
+            client.close();
         }
-        client.close();
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyDigestAuthTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyDigestAuthTest.java
index 95f2f8879..77805bedf 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyDigestAuthTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyDigestAuthTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.DigestAuthTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyDigestAuthTest extends DigestAuthTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyEmptyBodyTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyEmptyBodyTest.java
index a6a88a423..308177d33 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyEmptyBodyTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyEmptyBodyTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.EmptyBodyTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyEmptyBodyTest extends EmptyBodyTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyErrorResponseTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyErrorResponseTest.java
index 33c0ff2e7..5ff47a0be 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyErrorResponseTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyErrorResponseTest.java
@@ -16,16 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ErrorResponseTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyErrorResponseTest extends ErrorResponseTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyExpectContinue100Test.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyExpectContinue100Test.java
index 09307e718..0b8b08559 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyExpectContinue100Test.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyExpectContinue100Test.java
@@ -16,16 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.Expect100ContinueTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
-public class GrizzlyExpectContinue100Test extends Expect100ContinueTest{
+public class GrizzlyExpectContinue100Test extends Expect100ContinueTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFilterTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFilterTest.java
index 19a7d7ce2..c6587ebb6 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFilterTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFilterTest.java
@@ -16,16 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.FilterTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyFilterTest extends FilterTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
-
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFollowingThreadTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFollowingThreadTest.java
index 9835a67d7..74c6347ce 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFollowingThreadTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyFollowingThreadTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.FollowingThreadTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyFollowingThreadTest extends FollowingThreadTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHead302Test.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHead302Test.java
index a84023b1a..70b6630f3 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHead302Test.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHead302Test.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.Head302Test;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyHead302Test extends Head302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHttpToHttpsRedirectTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHttpToHttpsRedirectTest.java
index c6ea5c47d..c6c1351aa 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHttpToHttpsRedirectTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyHttpToHttpsRedirectTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.HttpToHttpsRedirectTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyIdleStateHandlerTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyIdleStateHandlerTest.java
index 1096adab6..9b6500bec 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyIdleStateHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyIdleStateHandlerTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.IdleStateHandlerTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyIdleStateHandlerTest extends IdleStateHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyInputStreamTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyInputStreamTest.java
index 670203593..943a711aa 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyInputStreamTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyInputStreamTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.InputStreamTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyInputStreamTest extends InputStreamTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyListenableFutureTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyListenableFutureTest.java
index 285e61272..5839c271c 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyListenableFutureTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyListenableFutureTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ListenableFutureTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyListenableFutureTest extends ListenableFutureTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxConnectionsInThreadsTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
index d9a95eace..c3982b645 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.MaxConnectionsInThreads;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyMaxConnectionsInThreadsTest extends MaxConnectionsInThreads {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxTotalConnectionTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxTotalConnectionTest.java
index eeb1c08bf..7a2829c5e 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxTotalConnectionTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMaxTotalConnectionTest.java
@@ -16,15 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.MaxTotalConnectionTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyMaxTotalConnectionTest extends MaxTotalConnectionTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMultipleHeaderTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMultipleHeaderTest.java
index 9635878ac..4b58ba744 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMultipleHeaderTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyMultipleHeaderTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.MultipleHeaderTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyMultipleHeaderTest extends MultipleHeaderTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNoNullResponseTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNoNullResponseTest.java
index 2c4fac257..63c10d687 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNoNullResponseTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNoNullResponseTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.NoNullResponseTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyNoNullResponseTest extends NoNullResponseTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNonAsciiContentLengthTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNonAsciiContentLengthTest.java
index 9ab8b96c3..f9342f299 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNonAsciiContentLengthTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyNonAsciiContentLengthTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.NonAsciiContentLengthTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyParamEncodingTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyParamEncodingTest.java
index 98fe02b2e..be3a76409 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyParamEncodingTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyParamEncodingTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ParamEncodingTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyParamEncodingTest extends ParamEncodingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestRelative302Test.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestRelative302Test.java
index e52d331e1..e22cff3d0 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestRelative302Test.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestRelative302Test.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.PerRequestRelative302Test;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyPerRequestRelative302Test extends PerRequestRelative302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestTimeoutTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestTimeoutTest.java
index 0a7a16eb7..e13d10ac4 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestTimeoutTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPerRequestTimeoutTest.java
@@ -16,7 +16,7 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.PerRequestTimeoutTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyPerRequestTimeoutTest extends PerRequestTimeoutTest {
 
@@ -27,10 +27,7 @@ protected String getExpectedTimeoutMessage() {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostRedirectGetTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostRedirectGetTest.java
index 54a6c78c2..269772a41 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostRedirectGetTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostRedirectGetTest.java
@@ -16,15 +16,12 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.PostRedirectGetTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyPostRedirectGetTest extends PostRedirectGetTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostWithQSTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostWithQSTest.java
index d9dd8b19b..140f60562 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostWithQSTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPostWithQSTest.java
@@ -16,16 +16,13 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.PostWithQSTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 
 public class GrizzlyPostWithQSTest extends PostWithQSTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTest.java
index 1bfbc7f47..63ab5cc82 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.ProxyTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyProxyTest extends ProxyTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTunnelingTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTunnelingTest.java
index 9033261a2..8f112b2af 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTunnelingTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyProxyTunnelingTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.ProxyyTunnellingTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyProxyTunnelingTest extends ProxyyTunnellingTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPutLargeFileTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPutLargeFileTest.java
index c26efc51f..47c8158c4 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPutLargeFileTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyPutLargeFileTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.PutLargeFileTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyPutLargeFileTest extends PutLargeFileTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyQueryParametersTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyQueryParametersTest.java
index 8ee03ce46..6f46beba1 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyQueryParametersTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyQueryParametersTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.QueryParametersTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyQueryParametersTest extends QueryParametersTest{
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRC10KTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRC10KTest.java
index 837b10c43..fbd14d7f9 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRC10KTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRC10KTest.java
@@ -15,16 +15,13 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.RC10KTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyRC10KTest extends RC10KTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRedirectConnectionUsageTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRedirectConnectionUsageTest.java
index 5397cf5fa..f70cc2c92 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRedirectConnectionUsageTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRedirectConnectionUsageTest.java
@@ -13,27 +13,25 @@
 
 package com.ning.http.client.async.grizzly;
 
+import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
+
+import org.glassfish.grizzly.filterchain.FilterChainBuilder;
+import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
+import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.AsyncHttpProviderConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.RedirectConnectionUsageTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig;
 import com.ning.http.client.providers.grizzly.TransportCustomizer;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.strategies.SameThreadIOStrategy;
-
-import static com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.TRANSPORT_CUSTOMIZER;
 
 public class GrizzlyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Override
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRelative302Test.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRelative302Test.java
index 684f75835..33d65c5af 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRelative302Test.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRelative302Test.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.Relative302Test;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyRelative302Test extends Relative302Test {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRemoteSiteTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRemoteSiteTest.java
index 23b8b217b..21b647271 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRemoteSiteTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRemoteSiteTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.RemoteSiteTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyRemoteSiteTest extends RemoteSiteTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRetryRequestTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRetryRequestTest.java
index 20b7cca95..d89247f60 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRetryRequestTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyRetryRequestTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.RetryRequestTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyRetryRequestTest extends RetryRequestTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlySimpleAsyncHttpClientTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlySimpleAsyncHttpClientTest.java
index 34709e2d6..ccbcfbd07 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlySimpleAsyncHttpClientTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlySimpleAsyncHttpClientTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.SimpleAsyncHttpClientTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyTransferListenerTest.java b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyTransferListenerTest.java
index 90181ac0a..3be998d25 100644
--- a/src/test/java/com/ning/http/client/async/grizzly/GrizzlyTransferListenerTest.java
+++ b/src/test/java/com/ning/http/client/async/grizzly/GrizzlyTransferListenerTest.java
@@ -15,17 +15,14 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.TransferListenerTest;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 
 public class GrizzlyTransferListenerTest extends TransferListenerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
 }
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyAsyncProviderBasicTest.java b/src/test/java/com/ning/http/client/async/netty/NettyAsyncProviderBasicTest.java
index 4292c85f6..bf713d309 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyAsyncProviderBasicTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyAsyncProviderBasicTest.java
@@ -27,7 +27,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
         final NettyAsyncHttpProviderConfig config = 
                 new NettyAsyncHttpProviderConfig();
         config.addProperty("tcpNoDelay", true);
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyBodyDeferringAsyncHandlerTest.java b/src/test/java/com/ning/http/client/async/netty/NettyBodyDeferringAsyncHandlerTest.java
index 8e71e559f..45ad55e29 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyBodyDeferringAsyncHandlerTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyBodyDeferringAsyncHandlerTest.java
@@ -17,8 +17,7 @@
 import com.ning.http.client.async.BodyDeferringAsyncHandlerTest;
 import com.ning.http.client.async.ProviderUtil;
 
-public class NettyBodyDeferringAsyncHandlerTest extends
-        BodyDeferringAsyncHandlerTest {
+public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyByteBufferCapacityTest.java b/src/test/java/com/ning/http/client/async/netty/NettyByteBufferCapacityTest.java
index 0d1d9ef43..e3c232641 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyByteBufferCapacityTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyByteBufferCapacityTest.java
@@ -14,7 +14,6 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.async.AbstractBasicTest;
 import com.ning.http.client.async.ByteBufferCapacityTest;
 import com.ning.http.client.async.ProviderUtil;
 
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyProxyTest.java b/src/test/java/com/ning/http/client/async/netty/NettyProxyTest.java
index 2a3326320..6d6babc83 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyProxyTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyProxyTest.java
@@ -22,7 +22,6 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return ProviderUtil.nettyProvider(config);
     }
-
 }
 
 
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyRedirectConnectionUsageTest.java b/src/test/java/com/ning/http/client/async/netty/NettyRedirectConnectionUsageTest.java
index 201b13e28..c179b9d63 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyRedirectConnectionUsageTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyRedirectConnectionUsageTest.java
@@ -26,7 +26,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    protected AsyncHttpProviderConfig getProviderConfig() {
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
         final NettyAsyncHttpProviderConfig config = 
                 new NettyAsyncHttpProviderConfig();
         if (System.getProperty("blockingio") != null) {
diff --git a/src/test/java/com/ning/http/client/async/netty/NettyZeroCopyFileTest.java b/src/test/java/com/ning/http/client/async/netty/NettyZeroCopyFileTest.java
index c1cc52480..0bec53681 100644
--- a/src/test/java/com/ning/http/client/async/netty/NettyZeroCopyFileTest.java
+++ b/src/test/java/com/ning/http/client/async/netty/NettyZeroCopyFileTest.java
@@ -15,7 +15,6 @@
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.async.TransferListenerTest;
 import com.ning.http.client.async.ZeroCopyFileTest;
 
 public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
diff --git a/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java b/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java
index a2c393783..105d75075 100644
--- a/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java
+++ b/src/test/java/com/ning/http/client/generators/ByteArrayBodyGeneratorTest.java
@@ -13,16 +13,15 @@
 
 package com.ning.http.client.generators;
 
-import com.ning.http.client.Body;
-
-import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Random;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
+import org.testng.annotations.Test;
+
+import com.ning.http.client.Body;
 
 /**
  * @author Bryan Davis bpd@keynetics.com
diff --git a/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java b/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java
index 0566cd9ad..7cfd29b8c 100644
--- a/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java
+++ b/src/test/java/com/ning/http/client/websocket/ByteMessageTest.java
@@ -67,183 +67,194 @@ public WebSocketHandler getWebSocketHandler() {
     @Test
     public void echoByte() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
 
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
-                    @Override
-                    public void onOpen(WebSocket websocket) {
-                    }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-                    @Override
-                    public void onClose(WebSocket websocket) {
-                        latch.countDown();
-                    }
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onMessage(byte[] message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
+                @Override
+                public void onMessage(byte[] message) {
+                    text.set(message);
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onFragment(byte[] fragment, boolean last) {
-                    }
-                }).build()).get();
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
 
-        websocket.sendMessage("ECHO".getBytes());
+            websocket.sendMessage("ECHO".getBytes());
 
-        latch.await();
-        assertEquals(text.get(), "ECHO".getBytes());
+            latch.await();
+            assertEquals(text.get(), "ECHO".getBytes());
+        } finally {
+            c.close();
+        }
     }
 
     @Test
     public void echoTwoMessagesTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
 
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
-                    @Override
-                    public void onOpen(WebSocket websocket) {
-                    }
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
 
-                    @Override
-                    public void onClose(WebSocket websocket) {
-                        latch.countDown();
-                    }
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onMessage(byte[] message) {
-                        if (text.get() == null) {
-                            text.set(message);
-                        } else {
-                            byte[] n = new byte[text.get().length + message.length];
-                            System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                            System.arraycopy(message, 0, n, text.get().length, message.length);
-                            text.set(n);
-                        }
-                        latch.countDown();
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
                     }
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onFragment(byte[] fragment, boolean last) {
-                    }
-                }).build()).get();
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
 
-        websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
+            websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
 
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO".getBytes());
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
     }
 
     @Test
     public void echoOnOpenMessagesTest() throws Throwable {
-            AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
+        try {
             final CountDownLatch latch = new CountDownLatch(2);
             final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
 
-            WebSocket websocket = c.prepareGet(getTargetUrl())
-                    .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                        @Override
-                        public void onOpen(WebSocket websocket) {
-                            websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
-                        }
-
-                        @Override
-                        public void onClose(WebSocket websocket) {
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onError(Throwable t) {
-                            t.printStackTrace();
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onMessage(byte[] message) {
-                            if (text.get() == null) {
-                                text.set(message);
-                            } else {
-                                byte[] n = new byte[text.get().length + message.length];
-                                System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                                System.arraycopy(message, 0, n, text.get().length, message.length);
-                                text.set(n);
-                            }
-                            latch.countDown();
-                        }
-
-                        @Override
-                        public void onFragment(byte[] fragment, boolean last) {
-                        }
-                    }).build()).get();
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                    websocket.sendMessage("ECHO".getBytes()).sendMessage("ECHO".getBytes());
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
     }
 
-
     public void echoFragments() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-                final CountDownLatch latch = new CountDownLatch(1);
-                final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
-
-                WebSocket websocket = c.prepareGet(getTargetUrl())
-                        .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
-
-                            @Override
-                            public void onOpen(WebSocket websocket) {
-                            }
-
-                            @Override
-                            public void onClose(WebSocket websocket) {
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onError(Throwable t) {
-                                t.printStackTrace();
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onMessage(byte[] message) {
-                                if (text.get() == null) {
-                                    text.set(message);
-                                } else {
-                                    byte[] n = new byte[text.get().length + message.length];
-                                    System.arraycopy(text.get(), 0, n, 0, text.get().length);
-                                    System.arraycopy(message, 0, n, text.get().length, message.length);
-                                    text.set(n);
-                                }
-                                latch.countDown();
-                            }
-
-                            @Override
-                            public void onFragment(byte[] fragment, boolean last) {
-                            }
-                        }).build()).get();
-                websocket.stream("ECHO".getBytes(), false);
-                websocket.stream("ECHO".getBytes(), true);
-                latch.await();
-                assertEquals(text.get(), "ECHOECHO".getBytes());
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+
+                @Override
+                public void onMessage(byte[] message) {
+                    if (text.get() == null) {
+                        text.set(message);
+                    } else {
+                        byte[] n = new byte[text.get().length + message.length];
+                        System.arraycopy(text.get(), 0, n, 0, text.get().length);
+                        System.arraycopy(message, 0, n, text.get().length, message.length);
+                        text.set(n);
+                    }
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(byte[] fragment, boolean last) {
+                }
+            }).build()).get();
+            websocket.stream("ECHO".getBytes(), false);
+            websocket.stream("ECHO".getBytes(), true);
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO".getBytes());
+        } finally {
+            c.close();
+        }
     }
 }
diff --git a/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java b/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java
index 9329973e0..02ef933ce 100644
--- a/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java
+++ b/src/test/java/com/ning/http/client/websocket/CloseCodeReasonMessageTest.java
@@ -36,35 +36,41 @@
     @Test(timeOut = 60000)
     public void onCloseWithCode() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
 
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
-        websocket.close();
+            websocket.close();
 
-        latch.await();
-        assertTrue(text.get().startsWith("1000"));
+            latch.await();
+            assertTrue(text.get().startsWith("1000"));
+        } finally {
+            c.close();
+        }
     }
 
     @Test(timeOut = 60000)
     public void onCloseWithCodeServerClose() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
-
-        latch.await();
-        final String[] parts = text.get().split(" ");
-        assertEquals(parts.length, 5);
-        assertEquals(parts[0], "1000-Idle");
-        assertEquals(parts[1], "for");
-        assertTrue(Integer.parseInt(parts[2].substring(0, parts[2].indexOf('m'))) > 10000);
-        assertEquals(parts[3], ">");
-        assertEquals(parts[4], "10000ms");
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
+
+            latch.await();
+            final String[] parts = text.get().split(" ");
+            assertEquals(parts.length, 5);
+            assertEquals(parts[0], "1000-Idle");
+            assertEquals(parts[1], "for");
+            assertTrue(Integer.parseInt(parts[2].substring(0, parts[2].indexOf('m'))) > 10000);
+            assertEquals(parts[3], ">");
+            assertEquals(parts[4], "10000ms");
+        } finally {
+            c.close();
+        }
     }
 
     public final static class Listener implements WebSocketListener, WebSocketCloseCodeReasonListener {
@@ -77,11 +83,11 @@ public Listener(CountDownLatch latch, AtomicReference<String> text) {
             this.text = text;
         }
 
-        //@Override
+        // @Override
         public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
         }
 
-        //@Override
+        // @Override
         public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
         }
 
@@ -90,7 +96,7 @@ public void onClose(WebSocket websocket, int code, String reason) {
             latch.countDown();
         }
 
-        //@Override
+        // @Override
         public void onError(Throwable t) {
             t.printStackTrace();
             latch.countDown();
diff --git a/src/test/java/com/ning/http/client/websocket/RedirectTest.java b/src/test/java/com/ning/http/client/websocket/RedirectTest.java
index 25febcf53..215cfce30 100644
--- a/src/test/java/com/ning/http/client/websocket/RedirectTest.java
+++ b/src/test/java/com/ning/http/client/websocket/RedirectTest.java
@@ -13,26 +13,25 @@
 
 package com.ning.http.client.websocket;
 
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
-import com.ning.http.client.AsyncHttpClient;
-import com.ning.http.client.AsyncHttpClientConfig;
-import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.eclipse.jetty.server.handler.HandlerList;
 import org.eclipse.jetty.server.nio.SelectChannelConnector;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.testng.Assert.assertEquals;
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
 
 public abstract class RedirectTest extends AbstractBasicTest {
 
@@ -50,9 +49,6 @@ public void setUpGlobal() throws Exception {
 
         addConnector(_connector);
 
-
-
-
         port2 = findFreePort();
         final SelectChannelConnector connector2 = new SelectChannelConnector();
         connector2.setPort(port2);
@@ -60,13 +56,13 @@ public void setUpGlobal() throws Exception {
         WebSocketHandler _wsHandler = getWebSocketHandler();
         HandlerList list = new HandlerList();
         list.addHandler(new AbstractHandler() {
-                    @Override
-                    public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
-                        if (request.getLocalPort() == port2) {
-                            httpServletResponse.sendRedirect(getTargetUrl());
-                        }
-                    }
-                });
+            @Override
+            public void handle(String s, Request request, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException, ServletException {
+                if (request.getLocalPort() == port2) {
+                    httpServletResponse.sendRedirect(getTargetUrl());
+                }
+            }
+        });
         list.addHandler(_wsHandler);
         setHandler(list);
 
@@ -89,39 +85,39 @@ public WebSocketHandler getWebSocketHandler() {
     @Test(timeOut = 60000)
     public void testRedirectToWSResource() throws Exception {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirects(true).build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getRedirectURL())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnOpen");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-
-        latch.await();
-        assertEquals(text.get(), "OnOpen");
-        websocket.close();
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
+            websocket.close();
+        } finally {
+            c.close();
+        }
     }
 
-
     // --------------------------------------------------------- Private Methods
 
-
     private String getRedirectURL() {
         return String.format("ws://127.0.0.1:%d/", port2);
     }
diff --git a/src/test/java/com/ning/http/client/websocket/TextMessageTest.java b/src/test/java/com/ning/http/client/websocket/TextMessageTest.java
index 2b1b15477..93657e3a0 100644
--- a/src/test/java/com/ning/http/client/websocket/TextMessageTest.java
+++ b/src/test/java/com/ning/http/client/websocket/TextMessageTest.java
@@ -66,321 +66,339 @@ public WebSocketHandler getWebSocketHandler() {
         };
     }
 
-
-
     @Test(timeOut = 60000)
     public void onOpen() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
 
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnOpen");
-                        latch.countDown();
-                    }
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                    text.set("OnOpen");
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                }
 
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        latch.await();
-        assertEquals(text.get(), "OnOpen");
+            latch.await();
+            assertEquals(text.get(), "OnOpen");
+        } finally {
+            c.close();
+        }
     }
 
     @Test(timeOut = 60000)
     public void onEmptyListenerTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-
-        WebSocket websocket = null;
         try {
-            websocket = c.prepareGet(getTargetUrl())
-                    .execute(new WebSocketUpgradeHandler.Builder().build()).get();
-        } catch (Throwable t) {
-            fail();
+            WebSocket websocket = null;
+            try {
+                websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
+            } catch (Throwable t) {
+                fail();
+            }
+            assertTrue(websocket != null);
+        } finally {
+            c.close();
         }
-        assertTrue(websocket != null);
     }
 
     @Test(timeOut = 60000)
     public void onFailureTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = null;
-        Throwable t = null;
         try {
-            websocket = c.prepareGet("ws://abcdefg")
-                    .execute(new WebSocketUpgradeHandler.Builder().build()).get();
-        } catch (Throwable t2) {
-            t = t2;
+            Throwable t = null;
+            try {
+                c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
+            } catch (Throwable t2) {
+                t = t2;
+            }
+            assertTrue(t != null);
+        } finally {
+            c.close();
         }
-        assertTrue(t != null);
     }
 
     @Test(timeOut = 60000)
     public void onTimeoutCloseTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnClose");
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        latch.await();
-        assertEquals(text.get(), "OnClose");
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "OnClose");
+        } finally {
+            c.close();
+        }
     }
 
     @Test(timeOut = 60000)
     public void onClose() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
 
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
 
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        text.set("OnClose");
-                        latch.countDown();
-                    }
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    text.set("OnClose");
+                    latch.countDown();
+                }
 
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
 
-        websocket.close();
+            websocket.close();
 
-        latch.await();
-        assertEquals(text.get(), "OnClose");
+            latch.await();
+            assertEquals(text.get(), "OnClose");
+        } finally {
+            c.close();
+        }
     }
 
     @Test(timeOut = 60000)
     public void echoText() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.sendTextMessage("ECHO");
-
-        latch.await();
-        assertEquals(text.get(), "ECHO");
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendTextMessage("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHO");
+        } finally {
+            c.close();
+        }
     }
 
     @Test(timeOut = 60000)
     public void echoDoubleListenerText() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(text.get() + message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.sendTextMessage("ECHO");
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(text.get() + message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.sendTextMessage("ECHO");
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
     }
 
     @Test
     public void echoTwoMessagesTest() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(2);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(text.get() + message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    boolean t = false;
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                        websocket.sendTextMessage("ECHO").sendTextMessage("ECHO");
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
-    }
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                    text.set(text.get() + message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
 
+                boolean t = false;
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                    websocket.sendTextMessage("ECHO").sendTextMessage("ECHO");
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
+    }
 
     public void echoFragments() throws Throwable {
         AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        final CountDownLatch latch = new CountDownLatch(1);
-        final AtomicReference<String> text = new AtomicReference<String>("");
-
-        WebSocket websocket = c.prepareGet(getTargetUrl())
-                .execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
-
-                    @Override
-                    public void onMessage(String message) {
-                        text.set(message);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onFragment(String fragment, boolean last) {
-                    }
-
-                    @Override
-                    public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
-                    }
-
-                    @Override
-                    public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        t.printStackTrace();
-                        latch.countDown();
-                    }
-                }).build()).get();
-
-        websocket.streamText("ECHO", false);
-        websocket.streamText("ECHO", true);
-
-        latch.await();
-        assertEquals(text.get(), "ECHOECHO");
-    }
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<String> text = new AtomicReference<String>("");
+
+            WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
+                @Override
+                public void onMessage(String message) {
+                    text.set(message);
+                    latch.countDown();
+                }
+
+                @Override
+                public void onFragment(String fragment, boolean last) {
+                }
+
+                @Override
+                public void onOpen(com.ning.http.client.websocket.WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(com.ning.http.client.websocket.WebSocket websocket) {
+                    latch.countDown();
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    t.printStackTrace();
+                    latch.countDown();
+                }
+            }).build()).get();
+
+            websocket.streamText("ECHO", false);
+            websocket.streamText("ECHO", true);
+
+            latch.await();
+            assertEquals(text.get(), "ECHOECHO");
+        } finally {
+            c.close();
+        }
+    }
 }
diff --git a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyByteMessageTest.java b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyByteMessageTest.java
index 5497ba0e6..37b1429e3 100644
--- a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyByteMessageTest.java
+++ b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyByteMessageTest.java
@@ -12,20 +12,17 @@
  */
 package com.ning.http.client.websocket.grizzly;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 import com.ning.http.client.websocket.ByteMessageTest;
-import org.testng.annotations.Test;
 
 public class GrizzlyByteMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Test(timeOut = 60000)
diff --git a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyCloseCodeReasonMsgTest.java b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyCloseCodeReasonMsgTest.java
index c767e5508..941de2bfb 100644
--- a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyCloseCodeReasonMsgTest.java
+++ b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyCloseCodeReasonMsgTest.java
@@ -13,25 +13,23 @@
 
 package com.ning.http.client.websocket.grizzly;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.websocket.CloseCodeReasonMessageTest;
-import org.testng.annotations.Test;
 
 public class GrizzlyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Override
     @Test
     public void onCloseWithCode() throws Throwable {
-        super.onCloseWithCode();    //To change body of overridden methods use File | Settings | File Templates.
+        super.onCloseWithCode(); // To change body of overridden methods use File | Settings | File Templates.
     }
 }
diff --git a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyRedirectTest.java b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyRedirectTest.java
index 2cdda3be9..15cd220c8 100644
--- a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyRedirectTest.java
+++ b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyRedirectTest.java
@@ -15,16 +15,13 @@
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
+import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.websocket.RedirectTest;
 
 public class GrizzlyRedirectTest extends RedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 }
diff --git a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyTextMessageTest.java b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyTextMessageTest.java
index bef60cb99..7499f39c3 100644
--- a/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyTextMessageTest.java
+++ b/src/test/java/com/ning/http/client/websocket/grizzly/GrizzlyTextMessageTest.java
@@ -12,25 +12,22 @@
  */
 package com.ning.http.client.websocket.grizzly;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.providers.grizzly.GrizzlyAsyncHttpProvider;
 import com.ning.http.client.websocket.ByteMessageTest;
-import org.testng.annotations.Test;
 
 public class GrizzlyTextMessageTest extends ByteMessageTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return ProviderUtil.grizzlyProvider(config);
     }
 
     @Test(timeOut = 60000)
     @Override
     public void echoFragments() throws Exception {
-        super.echoFragments();    //To change body of overridden methods use File | Settings | File Templates.
+        super.echoFragments(); // To change body of overridden methods use File | Settings | File Templates.
     }
 }
