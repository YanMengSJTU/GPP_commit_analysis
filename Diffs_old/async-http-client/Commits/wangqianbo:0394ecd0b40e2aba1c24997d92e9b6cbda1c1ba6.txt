diff --git a/a.jpg b/a.jpg
new file mode 100644
index 000000000..7a0fceafd
Binary files /dev/null and b/a.jpg differ
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 3a47562e0..c009cee53 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -31,6 +31,7 @@
 import org.asynchttpclient.request.body.generator.FeedListener;
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
 import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
+import org.asynchttpclient.request.body.generator.my.NettyFeedableBodyGenerator;
 
 public class NettyBodyBody implements NettyBody {
 
@@ -67,9 +68,9 @@ public void write(final Channel channel, NettyResponseFuture<?> future) throws I
             msg = new BodyChunkedInput(body);
 
             BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
-            if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
+            if ((bg instanceof FeedableBodyGenerator || bg instanceof NettyFeedableBodyGenerator) && !(bg instanceof ReactiveStreamsBodyGenerator)) {
                 final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
-                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+                FeedListener listener = new FeedListener() {
                     @Override
                     public void onContentAdded() {
                         chunkedWriteHandler.resumeTransfer();
@@ -78,7 +79,12 @@ public void onContentAdded() {
                     @Override
                     public void onError(Throwable t) {
                     }
-                });
+                };
+                if(bg instanceof FeedableBodyGenerator) {
+                    FeedableBodyGenerator.class.cast(bg).setListener(listener);
+                } else {
+                    NettyFeedableBodyGenerator.class.cast(bg).setListener(listener);
+                }
             }
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyBodyChunk.java b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyBodyChunk.java
new file mode 100644
index 000000000..20219b37c
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyBodyChunk.java
@@ -0,0 +1,16 @@
+package org.asynchttpclient.request.body.generator.my;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * Created by Administrator on 2016/12/4.
+ */
+public class NettyBodyChunk {
+    public final boolean last;
+    public final ByteBuf buffer;
+
+    public NettyBodyChunk(final ByteBuf buffer, final boolean last) {
+        this.buffer = buffer;
+        this.last = last;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyFeedableBodyGenerator.java
new file mode 100644
index 000000000..320ea5c36
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyFeedableBodyGenerator.java
@@ -0,0 +1,15 @@
+package org.asynchttpclient.request.body.generator.my;
+
+import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.FeedListener;
+
+/**
+ * Created by Administrator on 2016/12/4.
+ */
+public interface NettyFeedableBodyGenerator extends BodyGenerator {
+
+    boolean feed(ByteBuf buffer, boolean isLast) throws Exception;
+
+    void setListener(FeedListener listener);
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyPushBody.java b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyPushBody.java
new file mode 100644
index 000000000..41d6906cf
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyPushBody.java
@@ -0,0 +1,83 @@
+package org.asynchttpclient.request.body.generator.my;
+
+import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.request.body.Body;
+
+import java.io.IOException;
+import java.util.Queue;
+
+/**
+ * Created by Administrator on 2016/12/4.
+ */
+public class NettyPushBody implements Body {
+
+    private final Queue<NettyBodyChunk> queue;
+    private BodyState state = BodyState.CONTINUE;
+
+    public NettyPushBody(Queue<NettyBodyChunk> queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public BodyState transferTo(final ByteBuf target) throws IOException {
+        System.out.println("transferTo");
+        switch (state) {
+            case CONTINUE:
+                return readNextChunk(target);
+            case STOP:
+                return BodyState.STOP;
+            default:
+                throw new IllegalStateException("Illegal process state.");
+        }
+    }
+
+    private BodyState readNextChunk(ByteBuf target) throws IOException {
+        BodyState res = BodyState.SUSPEND;
+        while (target.isWritable() && state != BodyState.STOP) {
+            NettyBodyChunk nextChunk = queue.peek();
+            System.out.println("queue.size = " + queue.size());
+            if (nextChunk != null) {
+                System.out.println("readableBytes = " + nextChunk.buffer.readableBytes());
+            }
+            if (nextChunk == null) {
+                // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+                return res;
+            } else if (nextChunk.buffer.readableBytes() <= 0 && !nextChunk.last) {
+                // skip empty buffers
+                queue.remove();
+            } else {
+                res = BodyState.CONTINUE;
+                readChunk(target, nextChunk);
+            }
+        }
+        return res;
+    }
+
+    private void readChunk(ByteBuf target, NettyBodyChunk part) {
+        System.out.println("readChunk part = " + part.buffer);
+        move(target, part.buffer);
+        if (part.buffer.readableBytes() <= 0) {
+            if (part.last) {
+                state = BodyState.STOP;
+            }
+            queue.remove();
+        }
+    }
+
+    private void move(ByteBuf target, ByteBuf source) {
+        int size = Math.min(target.writableBytes(), source.readableBytes());
+        if (size > 0) {
+            ByteBuf slice = source.readRetainedSlice(size);
+            target.writeBytes(slice);
+        }
+    }
+
+    @Override
+    public void close() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyQueueBasedFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyQueueBasedFeedableBodyGenerator.java
new file mode 100644
index 000000000..b7318b7c8
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyQueueBasedFeedableBodyGenerator.java
@@ -0,0 +1,41 @@
+package org.asynchttpclient.request.body.generator.my;
+
+import io.netty.buffer.ByteBuf;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.generator.FeedListener;
+
+import java.util.Queue;
+
+/**
+ * Created by Administrator on 2016/12/4.
+ */
+public abstract class NettyQueueBasedFeedableBodyGenerator<T extends Queue<NettyBodyChunk>> implements NettyFeedableBodyGenerator {
+
+    protected final T queue;
+    private FeedListener listener;
+
+    public NettyQueueBasedFeedableBodyGenerator(T queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public Body createBody() {
+        return new NettyPushBody(queue);
+    }
+
+    protected abstract boolean offer(NettyBodyChunk chunk) throws Exception;
+
+    @Override
+    public boolean feed(final ByteBuf buffer, final boolean isLast) throws Exception {
+        boolean offered = offer(new NettyBodyChunk(buffer, isLast));
+        if (offered && listener != null) {
+            listener.onContentAdded();
+        }
+        return offered;
+    }
+
+    @Override
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyUnboundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyUnboundedQueueFeedableBodyGenerator.java
new file mode 100644
index 000000000..5d683cd26
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/my/NettyUnboundedQueueFeedableBodyGenerator.java
@@ -0,0 +1,18 @@
+package org.asynchttpclient.request.body.generator.my;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * Created by Administrator on 2016/12/4.
+ */
+public final class NettyUnboundedQueueFeedableBodyGenerator extends NettyQueueBasedFeedableBodyGenerator<ConcurrentLinkedQueue<NettyBodyChunk>> {
+
+    public NettyUnboundedQueueFeedableBodyGenerator() {
+        super(new ConcurrentLinkedQueue<>());
+    }
+
+    @Override
+    protected boolean offer(NettyBodyChunk chunk) throws Exception {
+        return queue.offer(chunk);
+    }
+}
\ No newline at end of file
diff --git a/example/src/main/java/proxy/HttpClientHandler.java b/example/src/main/java/proxy/HttpClientHandler.java
new file mode 100644
index 000000000..11b994d24
--- /dev/null
+++ b/example/src/main/java/proxy/HttpClientHandler.java
@@ -0,0 +1,32 @@
+package proxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.util.CharsetUtil;
+
+/**
+ * Created by wangqianbo on 2016/11/17.
+ */
+@ChannelHandler.Sharable
+public class HttpClientHandler extends
+        SimpleChannelInboundHandler<ByteBuf> {
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) {
+        ctx.writeAndFlush(Unpooled.copiedBuffer("Netty rocks!",
+                CharsetUtil.UTF_8));
+    }
+    @Override
+    public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {
+        System.out.println(
+                "Client received: " + in.toString(CharsetUtil.UTF_8));
+    }
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx,
+                                Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/example/src/main/java/proxy/HttpFileServer.java b/example/src/main/java/proxy/HttpFileServer.java
new file mode 100644
index 000000000..2315b2191
--- /dev/null
+++ b/example/src/main/java/proxy/HttpFileServer.java
@@ -0,0 +1,76 @@
+package proxy;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.group.DefaultChannelGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.util.concurrent.ImmediateEventExecutor;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+
+import java.net.InetSocketAddress;
+
+/**
+ * Created by wangqianbo on 2016/11/21.
+ */
+public class HttpFileServer {
+    private final ChannelGroup channelGroup =
+            new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);
+    private final EventLoopGroup work = new NioEventLoopGroup();
+    private final EventLoopGroup boss = new NioEventLoopGroup();
+    private Channel channel;
+    private static AsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder()
+            .build();
+
+    public static AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient(config);
+
+    public ChannelFuture start(InetSocketAddress address) {
+        ServerBootstrap bootstrap = new ServerBootstrap();
+        bootstrap.group(boss, work)
+                .channel(NioServerSocketChannel.class)
+                .childHandler(createInitializer(channelGroup));
+        ChannelFuture future = bootstrap.bind(address);
+        future.syncUninterruptibly();
+        channel = future.channel();
+        return future;
+    }
+
+    protected ChannelInitializer<Channel> createInitializer(
+            ChannelGroup group) {
+        return new HttpFileServerInitializer(group);
+    }
+
+    public void destroy() {
+        if (channel != null) {
+            channel.close();
+        }
+        channelGroup.close();
+        work.shutdownGracefully();
+        boss.shutdownGracefully();
+    }
+
+    public static void main(String[] args) throws Exception {
+//        if (args.length != 1) {
+//            System.err.println("Please give port as argument");
+//            System.exit(1);
+//        }
+        int port = 8887;
+        final HttpFileServer endpoint = new HttpFileServer();
+        ChannelFuture future = endpoint.start(
+                new InetSocketAddress(port));
+        Runtime.getRuntime().addShutdownHook(new Thread() {
+            @Override
+            public void run() {
+                endpoint.destroy();
+            }
+        });
+        future.channel().closeFuture().syncUninterruptibly();
+    }
+}
diff --git a/example/src/main/java/proxy/HttpFileServerInitializer.java b/example/src/main/java/proxy/HttpFileServerInitializer.java
new file mode 100644
index 000000000..589aea5b3
--- /dev/null
+++ b/example/src/main/java/proxy/HttpFileServerInitializer.java
@@ -0,0 +1,27 @@
+package proxy;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.handler.codec.http.HttpServerCodec;
+import io.netty.handler.stream.ChunkedWriteHandler;
+
+/**
+ * Created by wangqianbo on 2016/11/21.
+ */
+public class HttpFileServerInitializer extends ChannelInitializer<Channel> {
+    private final ChannelGroup group;
+
+    public HttpFileServerInitializer(ChannelGroup group) {
+        this.group = group;
+    }
+
+    @Override
+    protected void initChannel(Channel ch) throws Exception {
+        ChannelPipeline pipeline = ch.pipeline();
+        pipeline.addLast(new HttpServerCodec());
+        pipeline.addLast(new ChunkedWriteHandler());
+        pipeline.addLast(new MyHttpRequestHandler1());
+    }
+}
diff --git a/example/src/main/java/proxy/HttpFileUploadClient.java b/example/src/main/java/proxy/HttpFileUploadClient.java
new file mode 100644
index 000000000..a675c20f7
--- /dev/null
+++ b/example/src/main/java/proxy/HttpFileUploadClient.java
@@ -0,0 +1,70 @@
+package proxy;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpObjectAggregator;
+import io.netty.handler.stream.ChunkedWriteHandler;
+
+import java.net.InetSocketAddress;
+
+/**
+ * Created by wangqianbo on 2016/11/17.
+ */
+public class HttpFileUploadClient {
+    private final String host;
+    private final int port;
+
+
+    public HttpFileUploadClient(String host, int port) {
+        this.host = host;
+        this.port = port;
+    }
+
+    public Channel start() throws Exception {
+        EventLoopGroup group = new NioEventLoopGroup();
+        Bootstrap b = new Bootstrap();
+        b.group(group)
+                .channel(NioSocketChannel.class)
+                .remoteAddress(new InetSocketAddress(host, port))
+                .handler(new ChannelInitializer<SocketChannel>() {
+                    @Override
+                    public void initChannel(SocketChannel ch)
+                            throws Exception {
+                        ch.pipeline().addLast(new HttpClientCodec());
+//                        ch.pipeline().addLast(new HttpContentDecompressor());
+//                        ch.pipeline().addLast(new HttpContentCompressor());
+                        ch.pipeline().addLast(new HttpObjectAggregator(Integer.MAX_VALUE));
+                        ch.pipeline().addLast(new ChunkedWriteHandler());
+                        ch.pipeline().addLast(new SendRequestHandler());
+                    }
+                });
+        ChannelFuture f = b.connect().sync();
+        return f.channel();
+    }
+
+    public static void main(String[] args) throws Exception {
+        String host = "localhost";
+        int port = 8887;
+        for (int i = 0; i < 1; i++) {
+            Thread thread = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        Channel channel = new HttpFileUploadClient(host, port).start();
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            });
+            thread.start();
+
+        }
+    }
+}
diff --git a/example/src/main/java/proxy/MyHttpRequestHandler.java b/example/src/main/java/proxy/MyHttpRequestHandler.java
new file mode 100644
index 000000000..b328ca5be
--- /dev/null
+++ b/example/src/main/java/proxy/MyHttpRequestHandler.java
@@ -0,0 +1,76 @@
+package proxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.handler.codec.http.*;
+
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+
+/**
+ * Created by wangqianbo on 2016/11/21.
+ */
+public class MyHttpRequestHandler
+        extends SimpleChannelInboundHandler<Object> {
+    private RandomAccessFile file;
+    private FileChannel fileChannel;
+
+    @Override
+    public void channelRead0(ChannelHandlerContext ctx,
+                             Object request) throws Exception {
+        System.out.println(request);
+
+        if (request instanceof DefaultHttpRequest) {
+            long timestamp = System.currentTimeMillis();
+            DefaultHttpRequest defaultHttpRequest = (DefaultHttpRequest) request;
+            file = new RandomAccessFile(timestamp + "-" + ctx.channel().hashCode() + ".pdf", "rw");
+            fileChannel = file.getChannel();
+        }
+        if (request instanceof DefaultHttpContent) {
+            DefaultHttpContent requestContent = (DefaultHttpContent) request;
+            ByteBuf content = requestContent.content();
+//            byte[] bytes = new byte[content.readableBytes()];
+//            content.readBytes(bytes);
+//            for (int i = 0; i < bytes.length; i++) {
+//                System.out.print(StringUtil.byteToHexString(bytes[i]));
+//            }
+//            System.out.println();
+
+            content.readBytes(fileChannel, file.length(), content.readableBytes());
+        } else if (request == LastHttpContent.EMPTY_LAST_CONTENT) {
+            System.out.println(request);
+            fileChannel.close();
+            file.close();
+            RandomAccessFile file = new RandomAccessFile("a.jpg", "r");
+            HttpResponse response = new DefaultHttpResponse(
+                    HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+            response.headers().set(
+                    HttpHeaderNames.CONTENT_TYPE,
+                    "text/plain; charset=UTF-8");
+            boolean keepAlive = true;
+            response.headers().set(
+                    HttpHeaderNames.CONTENT_LENGTH, 0);
+
+            if (keepAlive) {
+                response.headers().set(HttpHeaderNames.CONNECTION,
+                        HttpHeaderValues.KEEP_ALIVE);
+            }
+            ctx.write(response);
+//        ctx.write(new ChunkedNioFile(file.getChannel()));
+            ChannelFuture future = ctx.writeAndFlush(
+                    LastHttpContent.EMPTY_LAST_CONTENT);
+        }
+
+
+    }
+
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
+            throws Exception {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/example/src/main/java/proxy/MyHttpRequestHandler1.java b/example/src/main/java/proxy/MyHttpRequestHandler1.java
new file mode 100644
index 000000000..9e78fe4b2
--- /dev/null
+++ b/example/src/main/java/proxy/MyHttpRequestHandler1.java
@@ -0,0 +1,81 @@
+package proxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.handler.codec.http.*;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.my.NettyUnboundedQueueFeedableBodyGenerator;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Created by wangqianbo on 2016/11/21.
+ */
+public class MyHttpRequestHandler1
+        extends SimpleChannelInboundHandler<Object> {
+    String url = "http://182.48.117.174/chinaapi/users/4/files?share=false";
+    NettyUnboundedQueueFeedableBodyGenerator bodyGenerator;
+
+    @Override
+    public void channelRead0(ChannelHandlerContext ctx,
+                             Object request) throws Exception {
+        System.out.println(request);
+
+        if (request instanceof DefaultHttpRequest) {
+            long timestamp = System.currentTimeMillis();
+            DefaultHttpRequest defaultHttpRequest = (DefaultHttpRequest) request;
+            bodyGenerator = new NettyUnboundedQueueFeedableBodyGenerator();
+            CompletableFuture<Response> future = HttpFileServer.asyncHttpClient
+                    .preparePost(url)
+                    .addHeader("x-ehealth-meta-apikey", "4")
+                    .addHeader("x-ehealth-meta-apikey-type", "USER_ID")
+                    .addHeader("x-ehealth-meta-signature", "USER_ID")
+                    .addHeader("x-ehealth-meta-guid", "1234")
+                    .setBody(bodyGenerator)
+                    .execute()
+                    .toCompletableFuture()
+                    .exceptionally(throwable -> {
+                        throwable.printStackTrace();
+                        return null;
+                    })
+                    .thenApply(response -> {
+                        DefaultHttpResponse responseSent = new DefaultHttpResponse(
+                                HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+                        if (response != null) {
+                            responseSent.headers().add(response.getHeaders());
+                            ctx.write(responseSent);
+                        }
+                        ByteBuffer content = response.getResponseBodyAsByteBuffer();
+                        ByteBuf byteBuf = ctx.alloc().buffer();
+                        byteBuf.writeBytes(content);
+                        ctx.write(byteBuf);
+//        ctx.write(new ChunkedNioFile(file.getChannel()));
+                        ctx.writeAndFlush(
+                                LastHttpContent.EMPTY_LAST_CONTENT);
+                        return response;
+                    });
+            System.out.println("task start!");
+
+        }
+        if (request instanceof DefaultHttpContent) {
+            DefaultHttpContent requestContent = (DefaultHttpContent) request;
+            ByteBuf content = requestContent.content().retain();
+            bodyGenerator.feed(content, false);
+        } else if (request == LastHttpContent.EMPTY_LAST_CONTENT) {
+            bodyGenerator.feed(LastHttpContent.EMPTY_LAST_CONTENT.content(), true);
+        }
+
+    }
+
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
+            throws Exception {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/example/src/main/java/proxy/SendRequestHandler.java b/example/src/main/java/proxy/SendRequestHandler.java
new file mode 100644
index 000000000..c622b1e0e
--- /dev/null
+++ b/example/src/main/java/proxy/SendRequestHandler.java
@@ -0,0 +1,151 @@
+package proxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.handler.codec.http.*;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+
+import java.io.File;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+
+/**
+ * Created by wangqianbo on 2016/11/21.
+ */
+public class SendRequestHandler
+        extends ChannelDuplexHandler {
+    private volatile int count = 1;
+    DefaultFileRegion fileRegion;
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        System.out.println("channelActive!!");
+        for (int i = 0; i < 1; i++) {
+            DefaultHttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/chinaapi/users/4/files?share=false");
+            request.headers().set("x-ehealth-meta-apikey", "4");
+            request.headers().set("x-ehealth-meta-apikey-type", "USER_ID");
+            request.headers().set("x-ehealth-meta-signature", "USER_ID");
+            request.headers().set("x-ehealth-meta-guid", "1234");
+            request.headers().set(CONTENT_TYPE, "application/octet-stream");
+//        request.headers().set(CONTENT_LENGTH, file.length());
+            request.headers().set(ACCEPT_ENCODING, "gzip, deflate");
+            request.headers().set(TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            request.headers().set(HttpHeaderNames.CONNECTION,
+                    HttpHeaderValues.KEEP_ALIVE);
+            request.headers().set(HOST, "182.48.117.175");
+            request.headers().set(ACCEPT, "*/*");
+            request.headers().set(USER_AGENT, "Mozilla/5.0 ");
+            ctx.write(request).addListener(new GenericFutureListener<Future<? super Void>>() {
+                @Override
+                public void operationComplete(Future<? super Void> future) throws Exception {
+                    System.out.println("send request complete!!!");
+                }
+            });
+            File file = new File("a.jpg");
+            fileRegion = new DefaultFileRegion(file, 0, file.length());
+            ctx.write(fileRegion, ctx.newProgressivePromise())//
+                    .addListener(future -> {
+                        System.out.println("write complete!!!");
+                    });
+            ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, ctx.newProgressivePromise()).addListener(future -> {
+                System.out.println("EMPTY_LAST_CONTENT!!!");
+                System.out.println("is open = " + fileRegion.isOpen());
+            });
+        }
+    }
+
+    @Override
+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
+        System.out.println("channelWritabilityChanged !!!!");
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        System.out.println("channelInactive !!!!");
+    }
+
+    @Override
+    public void flush(ChannelHandlerContext ctx) throws Exception {
+        System.out.println("flush !!!!");
+        super.flush(ctx);
+    }
+
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        System.out.println(msg);
+        super.write(ctx, msg, promise);
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        System.out.println(msg.getClass());
+        if (msg instanceof DefaultHttpResponse) {
+            DefaultHttpResponse response = (DefaultHttpResponse) msg;
+//            System.out.println(response);
+        }
+        if (msg instanceof DefaultHttpContent) {
+            DefaultHttpContent content = (DefaultHttpContent) msg;
+            System.out.println(content);
+        }
+        if (msg instanceof FullHttpResponse) {
+            FullHttpResponse response = (FullHttpResponse) msg;
+            System.out.println(response);
+            ByteBuf content = response.content();
+            byte[] bytes = new byte[content.readableBytes()];
+            content.readBytes(bytes);
+            System.out.println(new String(bytes));
+        }
+        System.out.println(msg);
+        if (msg == LastHttpContent.EMPTY_LAST_CONTENT) {
+            if (count < 1) {
+                count++;
+                DefaultHttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/chinaapi/users/4/files?share=false");
+                request.headers().set("x-ehealth-meta-apikey", "4");
+                request.headers().set("x-ehealth-meta-apikey-type", "USER_ID");
+                request.headers().set("x-ehealth-meta-signature", "USER_ID");
+                request.headers().set("x-ehealth-meta-guid", "1234");
+                request.headers().set(CONTENT_TYPE, "application/octet-stream");
+//        request.headers().set(CONTENT_LENGTH, file.length());
+                request.headers().set(ACCEPT_ENCODING, "gzip, deflate");
+                request.headers().set(TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+                request.headers().set(HttpHeaderNames.CONNECTION,
+                        HttpHeaderValues.KEEP_ALIVE);
+                request.headers().set(HOST, "182.48.117.175");
+                request.headers().set(ACCEPT, "*/*");
+                request.headers().set(USER_AGENT, "Mozilla/5.0 ");
+                ctx.write(request).addListener(new GenericFutureListener<Future<? super Void>>() {
+                    @Override
+                    public void operationComplete(Future<? super Void> future) throws Exception {
+                        System.out.println("send request complete!!!");
+                    }
+                });
+                File file = new File("a.jpg");
+                fileRegion = new DefaultFileRegion(file, 0, file.length());
+                ctx.write(fileRegion, ctx.newProgressivePromise())//
+                        .addListener(future -> {
+                            System.out.println("write complete!!!");
+                        });
+                ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, ctx.newProgressivePromise()).addListener(future -> {
+                    System.out.println("EMPTY_LAST_CONTENT!!!");
+                });
+            }
+        }
+    }
+
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+        System.out.println("channelReadComplete");
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
+            throws Exception {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
