diff --git a/.travis.yml b/.travis.yml
index f834d065f..a1cc7f87c 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -20,14 +20,12 @@ jdk:
 - oraclejdk8
 language: java
 script:
-- touch NOW
+- touch /tmp/NOW
 - echo GIBSTUDYSTART $(date)
 - mvn test -Ptest-output
 - find $HOME/.m2 -name "_remote.repositories" | xargs rm
 - find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
 - echo GIBSTUDYEND $(date)
 - cd $TRAVIS_BUILD_DIR
-- if [ "$TRAVIS_OS_NAME" == "osx" ];        then echo TESTNUM $(find . -name TEST-*.xml
-  -newer NOW | wc -l);        else echo TESTNUM $(find -name TEST-*.xml -newer NOW
-  | wc -l);        fi
+- echo TESTNUM $(find . -name TEST-*.xml -newer /tmp/NOW | wc -l)
 sudo: false
diff --git a/README.md b/README.md
index e2cfa63a6..a8919ee79 100644
--- a/README.md
+++ b/README.md
@@ -176,7 +176,7 @@ AsyncHttpClient c = new DefaultAsyncHttpClient(cf);
 
 ## WebSocket
 
-Async Http Client also supports WebSocket by simply doing:
+Async Http Client also support WebSocket by simply doing:
 
 ```java
 WebSocket websocket = c.prepareGet(getTargetUrl())
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 7d4ffdddb..bded469db 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -17,6 +17,9 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import io.netty.channel.EventLoopGroup;
+import io.netty.util.HashedWheelTimer;
+import io.netty.util.Timer;
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Predicate;
@@ -27,14 +30,11 @@
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ConnectionSemaphore;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.HashedWheelTimer;
-import io.netty.util.Timer;
-
 /**
  * Default and threadsafe implementation of {@link AsyncHttpClient}.
  */
@@ -44,6 +44,7 @@
     private final AsyncHttpClientConfig config;
     private final AtomicBoolean closed = new AtomicBoolean(false);
     private final ChannelManager channelManager;
+    private final ConnectionSemaphore connectionSemaphore;
     private final NettyRequestSender requestSender;
     private final boolean allowStopNettyTimer;
     private final Timer nettyTimer;
@@ -51,6 +52,8 @@
     /**
      * Default signature calculator to use for all requests constructed by this
      * client instance.
+     *
+     * @since 1.1
      */
     protected SignatureCalculator signatureCalculator;
 
@@ -83,7 +86,8 @@ public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
         nettyTimer = allowStopNettyTimer ? newNettyTimer() : config.getNettyTimer();
 
         channelManager = new ChannelManager(config, nettyTimer);
-        requestSender = new NettyRequestSender(config, channelManager, nettyTimer, new AsyncHttpClientState(closed));
+        connectionSemaphore = new ConnectionSemaphore(config);
+        requestSender = new NettyRequestSender(config, channelManager, connectionSemaphore, nettyTimer, new AsyncHttpClientState(closed));
         channelManager.configureBootstraps(requestSender);
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 442922165..a80da0ed6 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -18,12 +18,12 @@
 
 import static java.nio.charset.StandardCharsets.*;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledMd5MessageDigest;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.asynchttpclient.util.StringUtils.*;
 
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.ThreadLocalRandom;
 
 import org.asynchttpclient.uri.Uri;
@@ -32,475 +32,486 @@
 import org.asynchttpclient.util.StringUtils;
 
 /**
- * This class is required when authentication is needed. The class support
- * BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
+ * This class is required when authentication is needed. The class support BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
  */
 public class Realm {
 
-	private static final String DEFAULT_NC = "00000001";
-	// MD5("")
-	private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
-
-	private final String principal;
-	private final String password;
-	private final AuthScheme scheme;
-	private final String realmName;
-	private final String nonce;
-	private final String algorithm;
-	private final String response;
-	private final String opaque;
-	private final String qop;
-	private final String nc;
-	private final String cnonce;
-	private final Uri uri;
-	private final boolean usePreemptiveAuth;
-	private final Charset charset;
-	private final String ntlmHost;
-	private final String ntlmDomain;
-	private final boolean useAbsoluteURI;
-	private final boolean omitQuery;
-
-	public enum AuthScheme {
-		BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
-	}
-
-	private Realm(AuthScheme scheme, //
-			String principal, //
-			String password, //
-			String realmName, //
-			String nonce, //
-			String algorithm, //
-			String response, //
-			String opaque, //
-			String qop, //
-			String nc, //
-			String cnonce, //
-			Uri uri, //
-			boolean usePreemptiveAuth, //
-			Charset charset, //
-			String ntlmDomain, //
-			String ntlmHost, //
-			boolean useAbsoluteURI, //
-			boolean omitQuery) {
-
-		this.scheme = assertNotNull(scheme, "scheme");
-		this.principal = assertNotNull(principal, "principal");
-		this.password = assertNotNull(password, "password");
-		this.realmName = realmName;
-		this.nonce = nonce;
-		this.algorithm = algorithm;
-		this.response = response;
-		this.opaque = opaque;
-		this.qop = qop;
-		this.nc = nc;
-		this.cnonce = cnonce;
-		this.uri = uri;
-		this.usePreemptiveAuth = usePreemptiveAuth;
-		this.charset = charset;
-		this.ntlmDomain = ntlmDomain;
-		this.ntlmHost = ntlmHost;
-		this.useAbsoluteURI = useAbsoluteURI;
-		this.omitQuery = omitQuery;
-	}
-
-	public String getPrincipal() {
-		return principal;
-	}
-
-	public String getPassword() {
-		return password;
-	}
-
-	public AuthScheme getScheme() {
-		return scheme;
-	}
-
-	public String getRealmName() {
-		return realmName;
-	}
-
-	public String getNonce() {
-		return nonce;
-	}
-
-	public String getAlgorithm() {
-		return algorithm;
-	}
-
-	public String getResponse() {
-		return response;
-	}
-
-	public String getOpaque() {
-		return opaque;
-	}
-
-	public String getQop() {
-		return qop;
-	}
-
-	public String getNc() {
-		return nc;
-	}
-
-	public String getCnonce() {
-		return cnonce;
-	}
-
-	public Uri getUri() {
-		return uri;
-	}
-
-	public Charset getCharset() {
-		return charset;
-	}
-
-	/**
-	 * Return true is preemptive authentication is enabled
-	 * 
-	 * @return true is preemptive authentication is enabled
-	 */
-	public boolean isUsePreemptiveAuth() {
-		return usePreemptiveAuth;
-	}
-
-	/**
-	 * Return the NTLM domain to use. This value should map the JDK
-	 * 
-	 * @return the NTLM domain
-	 */
-	public String getNtlmDomain() {
-		return ntlmDomain;
-	}
-
-	/**
-	 * Return the NTLM host.
-	 * 
-	 * @return the NTLM host
-	 */
-	public String getNtlmHost() {
-		return ntlmHost;
-	}
-
-	public boolean isUseAbsoluteURI() {
-		return useAbsoluteURI;
-	}
-
-	public boolean isOmitQuery() {
-		return omitQuery;
-	}
-
-	@Override
-	public String toString() {
-		return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\''
-				+ ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm + '\'' + ", response='" + response + '\''
-				+ ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
-				+ ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
-	}
-
-	/**
-	 * A builder for {@link Realm}
-	 */
-	public static class Builder {
-
-		private final String principal;
-		private final String password;
-		private AuthScheme scheme;
-		private String realmName;
-		private String nonce;
-		private String algorithm;
-		private String response;
-		private String opaque;
-		private String qop;
-		private String nc = DEFAULT_NC;
-		private String cnonce;
-		private Uri uri;
-		private String methodName = "GET";
-		private boolean usePreemptive;
-		private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
-		private Charset charset = UTF_8;
-		private String ntlmHost = "localhost";
-		private boolean useAbsoluteURI = false;
-		private boolean omitQuery;
-
-		public Builder(String principal, String password) {
-			this.principal = principal;
-			this.password = password;
-		}
-
-		public Builder setNtlmDomain(String ntlmDomain) {
-			this.ntlmDomain = ntlmDomain;
-			return this;
-		}
-
-		public Builder setNtlmHost(String host) {
-			this.ntlmHost = host;
-			return this;
-		}
-
-		public Builder setScheme(AuthScheme scheme) {
-			this.scheme = scheme;
-			return this;
-		}
-
-		public Builder setRealmName(String realmName) {
-			this.realmName = realmName;
-			return this;
-		}
-
-		public Builder setNonce(String nonce) {
-			this.nonce = nonce;
-			return this;
-		}
-
-		public Builder setAlgorithm(String algorithm) {
-			this.algorithm = algorithm;
-			return this;
-		}
-
-		public Builder setResponse(String response) {
-			this.response = response;
-			return this;
-		}
-
-		public Builder setOpaque(String opaque) {
-			this.opaque = opaque;
-			return this;
-		}
-
-		public Builder setQop(String qop) {
-			if (isNonEmpty(qop)) {
-				this.qop = qop;
-			}
-			return this;
-		}
-
-		public Builder setNc(String nc) {
-			this.nc = nc;
-			return this;
-		}
-
-		public Builder setUri(Uri uri) {
-			this.uri = uri;
-			return this;
-		}
-
-		public Builder setMethodName(String methodName) {
-			this.methodName = methodName;
-			return this;
-		}
-
-		public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
-			this.usePreemptive = usePreemptiveAuth;
-			return this;
-		}
-
-		public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
-			this.useAbsoluteURI = useAbsoluteURI;
-			return this;
-		}
-
-		public Builder setOmitQuery(boolean omitQuery) {
-			this.omitQuery = omitQuery;
-			return this;
-		}
-
-		public Builder setCharset(Charset charset) {
-			this.charset = charset;
-			return this;
-		}
-
-		private String parseRawQop(String rawQop) {
-			String[] rawServerSupportedQops = rawQop.split(",");
-			String[] serverSupportedQops = new String[rawServerSupportedQops.length];
-			for (int i = 0; i < rawServerSupportedQops.length; i++) {
-				serverSupportedQops[i] = rawServerSupportedQops[i].trim();
-			}
-
-			// prefer auth over auth-int
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth"))
-					return rawServerSupportedQop;
-			}
-
-			for (String rawServerSupportedQop : serverSupportedQops) {
-				if (rawServerSupportedQop.equals("auth-int"))
-					return rawServerSupportedQop;
-			}
-
-			return null;
-		}
-
-		public Builder parseWWWAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-
-			// FIXME qop is different with proxy?
-			String rawQop = match(headerLine, "qop");
-			if (rawQop != null) {
-				setQop(parseRawQop(rawQop));
-			}
-
-			return this;
-		}
-
-		public Builder parseProxyAuthenticateHeader(String headerLine) {
-			setRealmName(match(headerLine, "realm"))//
-					.setNonce(match(headerLine, "nonce"))//
-					.setOpaque(match(headerLine, "opaque"))//
-					.setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
-			String algorithm = match(headerLine, "algorithm");
-			if (isNonEmpty(algorithm)) {
-				setAlgorithm(algorithm);
-			}
-			// FIXME qop is different with proxy?
-			setQop(match(headerLine, "qop"));
-
-			return this;
-		}
-
-		private void newCnonce(MessageDigest md) {
-			byte[] b = new byte[8];
-			ThreadLocalRandom.current().nextBytes(b);
-			b = md.digest(b);
-			cnonce = toHexString(b);
-		}
-
-		/**
-		 * TODO: A Pattern/Matcher may be better.
-		 */
-		private String match(String headerLine, String token) {
-			if (headerLine == null) {
-				return null;
-			}
-
-			int match = headerLine.indexOf(token);
-			if (match <= 0)
-				return null;
-
-			// = to skip
-			match += token.length() + 1;
-			int trailingComa = headerLine.indexOf(",", match);
-			String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
-			value = value.length() > 0 && value.charAt(value.length() - 1) == '"'
-					? value.substring(0, value.length() - 1)
-					: value;
-			return value.charAt(0) == '"' ? value.substring(1) : value;
-		}
-
-		private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
-			md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
-			sb.setLength(0);
-			return md.digest();
-		}
-
-		private byte[] ha1(StringBuilder sb, MessageDigest md) {
-			// if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":"
-			// passwd
-			// if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":"
-			// passwd ) ":" nonce-value ":" cnonce-value
-
-			sb.append(principal).append(':').append(realmName).append(':').append(password);
-			byte[] core = md5FromRecycledStringBuilder(sb, md);
-
-			if (algorithm == null || algorithm.equals("MD5")) {
-				// A1 = username ":" realm-value ":" passwd
-				return core;
-			} else if ("MD5-sess".equals(algorithm)) {
-				// A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
-				appendBase16(sb, core);
-				sb.append(':').append(nonce).append(':').append(cnonce);
-				return md5FromRecycledStringBuilder(sb, md);
-			}
-
-			throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
-		}
-
-		private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
-
-			// if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
-			// if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
-			sb.append(methodName).append(':').append(digestUri);
-			if ("auth-int".equals(qop)) {
-				// when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
-				// but we don't have the request body here
-				// we would need a new API
-				sb.append(':').append(EMPTY_ENTITY_MD5);
-
-			} else if (qop != null && !qop.equals("auth")) {
-				throw new UnsupportedOperationException("Digest qop not supported: " + qop);
-			}
-
-			return md5FromRecycledStringBuilder(sb, md);
-		}
-
-		private void appendMiddlePart(StringBuilder sb) {
-			// request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
-			sb.append(':').append(nonce).append(':');
-			if ("auth".equals(qop) || "auth-int".equals(qop)) {
-				sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
-			}
-		}
-
-		private void newResponse(MessageDigest md) {
-			// when using preemptive auth, the request uri is missing
-			if (uri != null) {
-				// BEWARE: compute first as it uses the cached StringBuilder
-				String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
-
-				StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
-
-				// WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
-				byte[] ha1 = ha1(sb, md);
-				byte[] ha2 = ha2(sb, digestUri, md);
-
-				appendBase16(sb, ha1);
-				appendMiddlePart(sb);
-				appendBase16(sb, ha2);
-
-				byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
-				response = toHexString(responseDigest);
-			}
-		}
-
-		/**
-		 * Build a {@link Realm}
-		 * 
-		 * @return a {@link Realm}
-		 */
-		public Realm build() {
-
-			// Avoid generating
-			if (isNonEmpty(nonce)) {
-				MessageDigest md = pooledMd5MessageDigest();
-				newCnonce(md);
-				newResponse(md);
-			}
-
-			return new Realm(scheme, //
-					principal, //
-					password, //
-					realmName, //
-					nonce, //
-					algorithm, //
-					response, //
-					opaque, //
-					qop, //
-					nc, //
-					cnonce, //
-					uri, //
-					usePreemptive, //
-					charset, //
-					ntlmDomain, //
-					ntlmHost, //
-					useAbsoluteURI, //
-					omitQuery);
-		}
-	}
+    private static final String DEFAULT_NC = "00000001";
+    // MD5("")
+    private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
+
+    private final String principal;
+    private final String password;
+    private final AuthScheme scheme;
+    private final String realmName;
+    private final String nonce;
+    private final String algorithm;
+    private final String response;
+    private final String opaque;
+    private final String qop;
+    private final String nc;
+    private final String cnonce;
+    private final Uri uri;
+    private final boolean usePreemptiveAuth;
+    private final Charset charset;
+    private final String ntlmHost;
+    private final String ntlmDomain;
+    private final boolean useAbsoluteURI;
+    private final boolean omitQuery;
+
+    public enum AuthScheme {
+        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
+    }
+
+    private Realm(AuthScheme scheme,//
+            String principal,//
+            String password,//
+            String realmName,//
+            String nonce,//
+            String algorithm,//
+            String response,//
+            String opaque,//
+            String qop,//
+            String nc,//
+            String cnonce,//
+            Uri uri,//
+            boolean usePreemptiveAuth,//
+            Charset charset,//
+            String ntlmDomain,//
+            String ntlmHost,//
+            boolean useAbsoluteURI,//
+            boolean omitQuery) {
+
+        this.scheme = assertNotNull(scheme, "scheme");
+        this.principal = assertNotNull(principal, "principal");
+        this.password = assertNotNull(password, "password");
+        this.realmName = realmName;
+        this.nonce = nonce;
+        this.algorithm = algorithm;
+        this.response = response;
+        this.opaque = opaque;
+        this.qop = qop;
+        this.nc = nc;
+        this.cnonce = cnonce;
+        this.uri = uri;
+        this.usePreemptiveAuth = usePreemptiveAuth;
+        this.charset = charset;
+        this.ntlmDomain = ntlmDomain;
+        this.ntlmHost = ntlmHost;
+        this.useAbsoluteURI = useAbsoluteURI;
+        this.omitQuery = omitQuery;
+    }
+
+    public String getPrincipal() {
+        return principal;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    public AuthScheme getScheme() {
+        return scheme;
+    }
+
+    public String getRealmName() {
+        return realmName;
+    }
+
+    public String getNonce() {
+        return nonce;
+    }
+
+    public String getAlgorithm() {
+        return algorithm;
+    }
+
+    public String getResponse() {
+        return response;
+    }
+
+    public String getOpaque() {
+        return opaque;
+    }
+
+    public String getQop() {
+        return qop;
+    }
+
+    public String getNc() {
+        return nc;
+    }
+
+    public String getCnonce() {
+        return cnonce;
+    }
+
+    public Uri getUri() {
+        return uri;
+    }
+
+    public Charset getCharset() {
+        return charset;
+    }
+
+    /**
+     * Return true is preemptive authentication is enabled
+     * 
+     * @return true is preemptive authentication is enabled
+     */
+    public boolean isUsePreemptiveAuth() {
+        return usePreemptiveAuth;
+    }
+
+    /**
+     * Return the NTLM domain to use. This value should map the JDK
+     * 
+     * @return the NTLM domain
+     */
+    public String getNtlmDomain() {
+        return ntlmDomain;
+    }
+
+    /**
+     * Return the NTLM host.
+     * 
+     * @return the NTLM host
+     */
+    public String getNtlmHost() {
+        return ntlmHost;
+    }
+
+    public boolean isUseAbsoluteURI() {
+        return useAbsoluteURI;
+    }
+
+    public boolean isOmitQuery() {
+        return omitQuery;
+    }
+
+    @Override
+    public String toString() {
+        return "Realm{" + "principal='" + principal + '\'' + ", scheme=" + scheme + ", realmName='" + realmName + '\'' + ", nonce='" + nonce + '\'' + ", algorithm='" + algorithm
+                + '\'' + ", response='" + response + '\'' + ", qop='" + qop + '\'' + ", nc='" + nc + '\'' + ", cnonce='" + cnonce + '\'' + ", uri='" + uri + '\''
+                + ", useAbsoluteURI='" + useAbsoluteURI + '\'' + ", omitQuery='" + omitQuery + '\'' + '}';
+    }
+
+    /**
+     * A builder for {@link Realm}
+     */
+    public static class Builder {
+
+        private static final ThreadLocal<MessageDigest> DIGEST_TL = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("MD5");
+                } catch (NoSuchAlgorithmException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+
+        private static MessageDigest getMessageDigest() {
+            MessageDigest md = DIGEST_TL.get();
+            md.reset();
+            return md;
+        }
+
+        private final String principal;
+        private final String password;
+        private AuthScheme scheme;
+        private String realmName;
+        private String nonce;
+        private String algorithm;
+        private String response;
+        private String opaque;
+        private String qop;
+        private String nc = DEFAULT_NC;
+        private String cnonce;
+        private Uri uri;
+        private String methodName = "GET";
+        private boolean usePreemptive;
+        private String ntlmDomain = System.getProperty("http.auth.ntlm.domain");
+        private Charset charset = UTF_8;
+        private String ntlmHost = "localhost";
+        private boolean useAbsoluteURI = false;
+        private boolean omitQuery;
+
+        public Builder(String principal, String password) {
+            this.principal = principal;
+            this.password = password;
+        }
+
+        public Builder setNtlmDomain(String ntlmDomain) {
+            this.ntlmDomain = ntlmDomain;
+            return this;
+        }
+
+        public Builder setNtlmHost(String host) {
+            this.ntlmHost = host;
+            return this;
+        }
+
+        public Builder setScheme(AuthScheme scheme) {
+            this.scheme = scheme;
+            return this;
+        }
+
+        public Builder setRealmName(String realmName) {
+            this.realmName = realmName;
+            return this;
+        }
+
+        public Builder setNonce(String nonce) {
+            this.nonce = nonce;
+            return this;
+        }
+
+        public Builder setAlgorithm(String algorithm) {
+            this.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder setResponse(String response) {
+            this.response = response;
+            return this;
+        }
+
+        public Builder setOpaque(String opaque) {
+            this.opaque = opaque;
+            return this;
+        }
+
+        public Builder setQop(String qop) {
+            if (isNonEmpty(qop)) {
+                this.qop = qop;
+            }
+            return this;
+        }
+
+        public Builder setNc(String nc) {
+            this.nc = nc;
+            return this;
+        }
+
+        public Builder setUri(Uri uri) {
+            this.uri = uri;
+            return this;
+        }
+
+        public Builder setMethodName(String methodName) {
+            this.methodName = methodName;
+            return this;
+        }
+
+        public Builder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
+            this.usePreemptive = usePreemptiveAuth;
+            return this;
+        }
+
+        public Builder setUseAbsoluteURI(boolean useAbsoluteURI) {
+            this.useAbsoluteURI = useAbsoluteURI;
+            return this;
+        }
+
+        public Builder setOmitQuery(boolean omitQuery) {
+            this.omitQuery = omitQuery;
+            return this;
+        }
+
+        public Builder setCharset(Charset charset) {
+            this.charset = charset;
+            return this;
+        }
+
+        private String parseRawQop(String rawQop) {
+            String[] rawServerSupportedQops = rawQop.split(",");
+            String[] serverSupportedQops = new String[rawServerSupportedQops.length];
+            for (int i = 0; i < rawServerSupportedQops.length; i++) {
+                serverSupportedQops[i] = rawServerSupportedQops[i].trim();
+            }
+
+            // prefer auth over auth-int
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth"))
+                    return rawServerSupportedQop;
+            }
+
+            for (String rawServerSupportedQop : serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth-int"))
+                    return rawServerSupportedQop;
+            }
+
+            return null;
+        }
+
+        public Builder parseWWWAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+
+            // FIXME qop is different with proxy?
+            String rawQop = match(headerLine, "qop");
+            if (rawQop != null) {
+                setQop(parseRawQop(rawQop));
+            }
+
+            return this;
+        }
+
+        public Builder parseProxyAuthenticateHeader(String headerLine) {
+            setRealmName(match(headerLine, "realm"))//
+                    .setNonce(match(headerLine, "nonce"))//
+                    .setOpaque(match(headerLine, "opaque"))//
+                    .setScheme(isNonEmpty(nonce) ? AuthScheme.DIGEST : AuthScheme.BASIC);
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
+            // FIXME qop is different with proxy?
+            setQop(match(headerLine, "qop"));
+
+            return this;
+        }
+
+        private void newCnonce(MessageDigest md) {
+            byte[] b = new byte[8];
+            ThreadLocalRandom.current().nextBytes(b);
+            b = md.digest(b);
+            cnonce = toHexString(b);
+        }
+
+        /**
+         * TODO: A Pattern/Matcher may be better.
+         */
+        private String match(String headerLine, String token) {
+            if (headerLine == null) {
+                return null;
+            }
+
+            int match = headerLine.indexOf(token);
+            if (match <= 0)
+                return null;
+
+            // = to skip
+            match += token.length() + 1;
+            int trailingComa = headerLine.indexOf(",", match);
+            String value = headerLine.substring(match, trailingComa > 0 ? trailingComa : headerLine.length());
+            value = value.length() > 0 && value.charAt(value.length() - 1) == '"' ? value.substring(0, value.length() - 1) : value;
+            return value.charAt(0) == '"' ? value.substring(1) : value;
+        }
+
+        private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
+            md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
+            sb.setLength(0);
+            return md.digest();
+        }
+
+        private byte[] ha1(StringBuilder sb, MessageDigest md) {
+            // if algorithm is "MD5" or is unspecified => A1 = username ":" realm-value ":" passwd
+            // if algorithm is "MD5-sess" => A1 = MD5( username-value ":" realm-value ":" passwd ) ":" nonce-value ":" cnonce-value
+
+            sb.append(principal).append(':').append(realmName).append(':').append(password);
+            byte[] core = md5FromRecycledStringBuilder(sb, md);
+
+            if (algorithm == null || algorithm.equals("MD5")) {
+                // A1 = username ":" realm-value ":" passwd
+                return core;
+            } else if ("MD5-sess".equals(algorithm)) {
+                // A1 = MD5(username ":" realm-value ":" passwd ) ":" nonce ":" cnonce
+                appendBase16(sb, core);
+                sb.append(':').append(nonce).append(':').append(cnonce);
+                return md5FromRecycledStringBuilder(sb, md);
+            }
+
+            throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+        }
+
+        private byte[] ha2(StringBuilder sb, String digestUri, MessageDigest md) {
+
+            // if qop is "auth" or is unspecified => A2 = Method ":" digest-uri-value
+            // if qop is "auth-int" => A2 = Method ":" digest-uri-value ":" H(entity-body)
+            sb.append(methodName).append(':').append(digestUri);
+            if ("auth-int".equals(qop)) {
+                // when qop == "auth-int", A2 = Method ":" digest-uri-value ":" H(entity-body)
+                // but we don't have the request body here
+                // we would need a new API
+                sb.append(':').append(EMPTY_ENTITY_MD5);
+
+            } else if (qop != null && !qop.equals("auth")) {
+                throw new UnsupportedOperationException("Digest qop not supported: " + qop);
+            }
+
+            return md5FromRecycledStringBuilder(sb, md);
+        }
+
+        private void appendMiddlePart(StringBuilder sb) {
+            // request-digest = MD5(H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2))
+            sb.append(':').append(nonce).append(':');
+            if ("auth".equals(qop) || "auth-int".equals(qop)) {
+                sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
+            }
+        }
+
+        private void newResponse(MessageDigest md) {
+            // when using preemptive auth, the request uri is missing
+            if (uri != null) {
+                // BEWARE: compute first as it uses the cached StringBuilder
+                String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
+
+                StringBuilder sb = StringBuilderPool.DEFAULT.stringBuilder();
+
+                // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
+                byte[] ha1 = ha1(sb, md);
+                byte[] ha2 = ha2(sb, digestUri, md);
+
+                appendBase16(sb, ha1);
+                appendMiddlePart(sb);
+                appendBase16(sb, ha2);
+
+                byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
+                response = toHexString(responseDigest);
+            }
+        }
+
+        /**
+         * Build a {@link Realm}
+         * 
+         * @return a {@link Realm}
+         */
+        public Realm build() {
+
+            // Avoid generating
+            if (isNonEmpty(nonce)) {
+                MessageDigest md = getMessageDigest();
+                newCnonce(md);
+                newResponse(md);
+            }
+
+            return new Realm(scheme,//
+                    principal,//
+                    password,//
+                    realmName,//
+                    nonce, //
+                    algorithm, //
+                    response,//
+                    opaque, //
+                    qop, //
+                    nc, //
+                    cnonce, //
+                    uri, //
+                    usePreemptive, //
+                    charset, //
+                    ntlmDomain,//
+                    ntlmHost, //
+                    useAbsoluteURI, //
+                    omitQuery);
+        }
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 0aaebc7fb..9a96ddfd1 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -90,14 +90,11 @@
     @SuppressWarnings("rawtypes")
     private static final AtomicIntegerFieldUpdater<NettyResponseFuture> contentProcessedField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "contentProcessed");
     @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> onThrowableCalledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class,
-            "onThrowableCalled");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture> onThrowableCalledField = AtomicIntegerFieldUpdater.newUpdater(NettyResponseFuture.class, "onThrowableCalled");
     @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> timeoutsHolderField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class,
-            TimeoutsHolder.class, "timeoutsHolder");
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, TimeoutsHolder> timeoutsHolderField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, TimeoutsHolder.class, "timeoutsHolder");
     @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> partitionKeyLockField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class,
-            Object.class, "partitionKeyLock");
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> partitionKeyLockField = AtomicReferenceFieldUpdater.newUpdater(NettyResponseFuture.class, Object.class, "partitionKeyLock");
 
     // volatile where we need CAS ops
     private volatile int redirectCount = 0;
@@ -123,12 +120,12 @@
     private Realm proxyRealm;
     public Throwable pendingException;
 
-    public NettyResponseFuture(Request originalRequest, //
-            AsyncHandler<V> asyncHandler, //
-            NettyRequest nettyRequest, //
-            int maxRetry, //
-            ChannelPoolPartitioning connectionPoolPartitioning, //
-            ConnectionSemaphore connectionSemaphore, //
+    public NettyResponseFuture(Request originalRequest,//
+            AsyncHandler<V> asyncHandler,//
+            NettyRequest nettyRequest,//
+            int maxRetry,//
+            ChannelPoolPartitioning connectionPoolPartitioning,//
+            ConnectionSemaphore connectionSemaphore,//
             ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
@@ -141,10 +138,6 @@ public NettyResponseFuture(Request originalRequest, //
     }
 
     private void releasePartitionKeyLock() {
-        if (connectionSemaphore == null) {
-            return;
-        }
-
         Object partitionKey = takePartitionKeyLock();
         if (partitionKey != null) {
             connectionSemaphore.releaseChannelLock(partitionKey);
@@ -491,7 +484,7 @@ public Object getPartitionKey() {
     }
 
     public void acquirePartitionLockLazily() throws IOException {
-        if (connectionSemaphore == null || partitionKeyLock != null) {
+        if (partitionKeyLock != null) {
             return;
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
index 09c693502..cde61c57c 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ConnectionSemaphore.java
@@ -29,10 +29,6 @@
  */
 public class ConnectionSemaphore {
 
-    public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig config) {
-        return config.getMaxConnections() > 0 || config.getMaxConnectionsPerHost() > 0 ? new ConnectionSemaphore(config) : null;
-    }
-
     private final int maxTotalConnections;
     private final NonBlockingSemaphoreLike freeChannels;
     private final int maxConnectionsPerHost;
@@ -41,7 +37,7 @@ public static ConnectionSemaphore newConnectionSemaphore(AsyncHttpClientConfig c
     private final IOException tooManyConnections;
     private final IOException tooManyConnectionsPerHost;
 
-    private ConnectionSemaphore(AsyncHttpClientConfig config) {
+    public ConnectionSemaphore(AsyncHttpClientConfig config) {
         tooManyConnections = unknownStackTrace(new TooManyConnectionsException(config.getMaxConnections()), ConnectionSemaphore.class, "acquireChannelLock");
         tooManyConnectionsPerHost = unknownStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()), ConnectionSemaphore.class, "acquireChannelLock");
         maxTotalConnections = config.getMaxConnections();
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 771f7e55e..96075ec7b 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -15,6 +15,11 @@
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
+import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -22,7 +27,6 @@
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -32,12 +36,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelId;
-import io.netty.util.Timeout;
-import io.netty.util.Timer;
-import io.netty.util.TimerTask;
-
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
@@ -108,13 +106,9 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
     }
 
     private static final class IdleChannel {
-        
-        private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
-        
         final Channel channel;
         final long start;
-        @SuppressWarnings("unused")
-        private volatile int owned = 0;
+        final AtomicBoolean owned = new AtomicBoolean(false);
 
         IdleChannel(Channel channel, long start) {
             this.channel = assertNotNull(channel, "channel");
@@ -122,7 +116,7 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
         }
 
         public boolean takeOwnership() {
-            return ownedField.getAndSet(this, 1) == 0;
+            return owned.compareAndSet(false, true);
         }
 
         public Channel getChannel() {
@@ -318,7 +312,7 @@ else if (isRemotelyClosed(idleChannel.channel)) {
      */
     public boolean removeAll(Channel channel) {
         ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channel.id()) : null;
-        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(new IdleChannel(channel, Long.MIN_VALUE));
+        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
     }
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 5140535ce..86bcc043f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -89,7 +89,7 @@ private void writeRequest(Channel channel) {
 
     public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {
 
-        if (connectionSemaphore != null) {
+        {
             // transfer lock from future to channel
             Object partitionKeyLock = future.takePartitionKeyLock();
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index c3c5e4861..0829722a9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -226,13 +226,15 @@ private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
         return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
     }
     
-    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean close) throws IOException {
+    protected void finishUpdate(NettyResponseFuture<?> future, Channel channel, boolean keepAlive, boolean expectOtherChunks) throws IOException {
         future.cancelTimeouts();
         
-        if (close) {
+        if (!keepAlive) {
             channelManager.closeChannel(channel);
+        } else if (expectOtherChunks) {
+            channelManager.drainChannelAndOffer(channel, future);
         } else {
-            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), true, future.getPartitionKey());
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
         }
 
         try {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 1edc5b562..906d0a3fd 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -45,7 +45,7 @@ public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager,
 
     private boolean abortAfterHandlingStatus(//
             AsyncHandler<?> handler,//
-            NettyResponseStatus status) throws Exception {
+            NettyResponseStatus status) throws IOException, Exception {
         return handler.onStatusReceived(status) == State.ABORT;
     }
 
@@ -87,7 +87,7 @@ private void handleHttpResponse(final HttpResponse response, final Channel chann
                     abortAfterHandlingReactiveStreams(channel, future, handler);
 
             if (abort) {
-                finishUpdate(future, channel, true);
+                finishUpdate(future, channel, false, true);
             }
         }
     }
@@ -116,8 +116,8 @@ private void handleChunk(HttpContent chunk,//
         }
 
         if (abort || last) {
-            boolean close = abort || !future.isKeepAlive();
-            finishUpdate(future, channel, close);
+            boolean keepAlive = !abort && future.isKeepAlive();
+            finishUpdate(future, channel, keepAlive, !last);
         }
     }
 
@@ -168,7 +168,7 @@ private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwabl
         } catch (Exception abortException) {
             logger.debug("Abort failed", abortException);
         } finally {
-            finishUpdate(future, channel, true);
+            finishUpdate(future, channel, false, false);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
index 0b5d8ce55..9357ae08f 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
@@ -42,15 +42,16 @@ public StreamedResponsePublisher(EventExecutor executor, ChannelManager channelM
     protected void cancelled() {
         logger.debug("Subscriber cancelled, ignoring the rest of the body");
 
+        // The subscriber cancelled early, we need to drain the remaining elements from the stream
+        channelManager.drainChannelAndOffer(channel, future);
+        channel.pipeline().remove(StreamedResponsePublisher.class);
+
         try {
             future.done();
         } catch (Exception t) {
             // Never propagate exception once we know we are done.
             logger.debug(t.getMessage(), t);
         }
-
-        // The subscriber cancelled early - this channel is dead and should be closed.
-        channelManager.closeChannel(channel);
     }
 
     NettyResponseFuture<?> future() {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 637ff2181..42f6d792e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -87,7 +87,7 @@ private void abort(Channel channel, NettyResponseFuture<?> future, WebSocketUpgr
         try {
             handler.onThrowable(new IOException("Invalid Status code=" + status.getStatusCode() + " text=" + status.getStatusText()));
         } finally {
-            finishUpdate(future, channel, true);
+            finishUpdate(future, channel, false, false);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 881eb13ee..a26f4fc06 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -17,7 +17,7 @@
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
 import static org.asynchttpclient.util.HttpUtils.*;
 import static org.asynchttpclient.util.MiscUtils.*;
-import static org.asynchttpclient.ws.WebSocketUtils.getWebSocketKey;
+import static org.asynchttpclient.ws.WebSocketUtils.getKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -194,7 +194,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         if (!connect && uri.isWebSocket()) {
             headers.set(UPGRADE, HttpHeaderValues.WEBSOCKET)//
                     .set(CONNECTION, HttpHeaderValues.UPGRADE)//
-                    .set(SEC_WEBSOCKET_KEY, getWebSocketKey())//
+                    .set(SEC_WEBSOCKET_KEY, getKey())//
                     .set(SEC_WEBSOCKET_VERSION, "13");
 
             if (!headers.contains(ORIGIN)) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index b8cff7f92..6e3e0e0f6 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -84,11 +84,12 @@
 
     public NettyRequestSender(AsyncHttpClientConfig config,//
             ChannelManager channelManager,//
+            ConnectionSemaphore connectionSemaphore,//
             Timer nettyTimer,//
             AsyncHttpClientState clientState) {
         this.config = config;
         this.channelManager = channelManager;
-        this.connectionSemaphore = ConnectionSemaphore.newConnectionSemaphore(config);
+        this.connectionSemaphore = connectionSemaphore;
         this.nettyTimer = nettyTimer;
         this.clientState = clientState;
         requestFactory = new NettyRequestFactory(config);
@@ -526,7 +527,6 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
         }
 
         if (fc.replayRequest() && future.incrementRetryAndCheck() && future.isReplayPossible()) {
-            future.setKeepAlive(false);
             replayRequest(future, fc, channel);
             replayed = true;
         }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
index 007778cf6..70ebc4185 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/FileMultipartPart.java
@@ -31,7 +31,6 @@
     private final long length;
     private long position = 0L;
 
-    @SuppressWarnings("resource")
     public FileMultipartPart(FilePart part, byte[] boundary) {
         super(part, boundary);
         try {
diff --git a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java b/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
deleted file mode 100644
index 17a7e62d1..000000000
--- a/client/src/main/java/org/asynchttpclient/util/MessageDigestUtils.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2017 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-public final class MessageDigestUtils {
-
-	private static final ThreadLocal<MessageDigest> MD5_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("MD5");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("MD5 not supported on this platform");
-		}
-	});
-
-	private static final ThreadLocal<MessageDigest> SHA1_MESSAGE_DIGESTS = ThreadLocal.withInitial(() -> {
-		try {
-			return MessageDigest.getInstance("SHA1");
-		} catch (NoSuchAlgorithmException e) {
-			throw new InternalError("SHA1 not supported on this platform");
-		}
-	});
-
-	public static MessageDigest pooledMd5MessageDigest() {
-		MessageDigest md = MD5_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
-
-	public static MessageDigest pooledSha1MessageDigest() {
-		MessageDigest md = SHA1_MESSAGE_DIGESTS.get();
-		md.reset();
-		return md;
-	}
-}
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index 0a6438660..489e130c9 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -14,25 +14,57 @@
 package org.asynchttpclient.ws;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
-import static org.asynchttpclient.util.MessageDigestUtils.pooledSha1MessageDigest;
 
-import org.asynchttpclient.util.Base64;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 
-import io.netty.util.internal.ThreadLocalRandom;
+import org.asynchttpclient.util.Base64;
 
 public final class WebSocketUtils {
-	public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
-
-	public static String getWebSocketKey() {
-		byte[] nonce = new byte[16];
-		ThreadLocalRandom random = ThreadLocalRandom.current();
-		for (int i = 0; i < nonce.length; i++) {
-			nonce[i] = (byte) random.nextInt(256);
-		}
-		return Base64.encode(nonce);
-	}
-
-	public static String getAcceptKey(String key) {
-		return Base64.encode(pooledSha1MessageDigest().digest((key + MAGIC_GUID).getBytes(US_ASCII)));
-	}
+    public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+    public static String getKey() {
+        byte[] nonce = createRandomBytes(16);
+        return Base64.encode(nonce);
+    }
+
+    public static String getAcceptKey(String key) throws UnsupportedEncodingException {
+        String acceptSeed = key + MAGIC_GUID;
+        byte[] sha1 = sha1(acceptSeed.getBytes(US_ASCII));
+        return Base64.encode(sha1);
+    }
+
+    public static byte[] md5(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("MD5");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("MD5 not supported on this platform");
+        }
+    }
+
+    public static byte[] sha1(byte[] bytes) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA1");
+            return md.digest(bytes);
+        } catch (NoSuchAlgorithmException e) {
+            throw new InternalError("SHA-1 not supported on this platform");
+        }
+    }
+
+    public static byte[] createRandomBytes(int size) {
+        byte[] bytes = new byte[size];
+
+        for (int i = 0; i < size; i++) {
+            bytes[i] = (byte) createRandomNumber(0, 255);
+        }
+
+        return bytes;
+    }
+
+    public static int createRandomNumber(int min, int max) {
+        return (int) (Math.random() * max + min);
+    }
+
 }
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index 2cd0282b3..d3c27d564 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -17,6 +17,7 @@
 
 import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -28,18 +29,17 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.Test;
 
-import io.netty.handler.codec.http.HttpHeaders;
-
 /**
  * Tests default asynchronous life cycle.
  * 
@@ -61,7 +61,8 @@ public AbstractHandler configureHandler() throws Exception {
             public void handle(String s, Request request, HttpServletRequest req, final HttpServletResponse resp) throws IOException, ServletException {
                 resp.setContentType("text/plain;charset=utf-8");
                 resp.setStatus(200);
-                final AsyncContext asyncContext = request.startAsync();
+                final Continuation continuation = ContinuationSupport.getContinuation(req);
+                continuation.suspend();
                 final PrintWriter writer = resp.getWriter();
                 executorService.submit(new Runnable() {
                     public void run() {
@@ -85,7 +86,7 @@ public void run() {
                         logger.info("Delivering part2.");
                         writer.write("part2");
                         writer.flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     }
                 });
                 request.setHandled(true);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 7b878ec13..f8b783d37 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -25,11 +25,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -59,7 +60,8 @@ public AbstractHandler configureHandler() throws Exception {
     private class SlowHandler extends AbstractHandler {
         public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
             new Thread(new Runnable() {
                 public void run() {
                     try {
@@ -79,7 +81,7 @@ public void run() {
                         Thread.sleep(3000);
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     } catch (InterruptedException e) {
                         logger.error(e.getMessage(), e);
                     } catch (IOException e) {
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
new file mode 100644
index 000000000..60f369d55
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * This program is licensed to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient;
+
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.cookie.Cookie;
+import io.netty.handler.codec.http.cookie.DefaultCookie;
+
+import java.io.InputStream;
+import java.net.URLEncoder;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.io.IOUtils;
+import org.testng.annotations.Test;
+
+/**
+ * Unit tests for remote site. <br>
+ * see http://github.com/MSch/ning-async-http-client-bug/tree/master
+ * 
+ * @author Martin Schurrer
+ */
+public class RemoteSiteTest extends AbstractBasicTest {
+
+    public static final String URL = "http://google.com?q=";
+    public static final String REQUEST_PARAM = "github github \n" + "github";
+
+    @Test(groups = "online")
+    public void testGoogleCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 301);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testWwwMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    // FIXME
+    public void testUpdateMicrosoftCom() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void testGoogleComWithTimeout() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
+            Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncStatusHEADContentLenghtTest() throws Exception {
+        try (AsyncHttpClient p = asyncHttpClient(config().setFollowRedirect(true))) {
+            final CountDownLatch l = new CountDownLatch(1);
+
+            p.executeRequest(head("http://www.google.com/"), new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        return response;
+                    } finally {
+                        l.countDown();
+                    }
+                }
+            }).get();
+
+            if (!l.await(5, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void invalidStreamTest2() throws Exception {
+        AsyncHttpClientConfig config = config()//
+                .setRequestTimeout(10000)//
+                .setFollowRedirect(true)//
+                .setKeepAlive(false)//
+                .setMaxRedirects(6)//
+                .build();
+
+        try (AsyncHttpClient c = asyncHttpClient(config)) {
+            Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
+            if (response != null) {
+                System.out.println(response);
+            }
+        } catch (Throwable t) {
+            t.printStackTrace();
+            assertNotNull(t.getCause());
+            assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
+        }
+    }
+
+    @Test(groups = "online")
+    public void asyncFullBodyProperlyRead() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            Response r = client.prepareGet("http://www.typesafe.com/").execute().get();
+
+            InputStream stream = r.getResponseBodyAsStream();
+            int contentLength = Integer.valueOf(r.getHeader(CONTENT_LENGTH));
+
+            assertEquals(contentLength, IOUtils.toByteArray(stream).length);
+        }
+    }
+
+    // FIXME Get a 302 in France...
+    @Test(groups = "online", enabled = false)
+    public void testUrlRequestParametersEncoding() throws Exception {
+        try (AsyncHttpClient client = asyncHttpClient()) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
+            logger.info(String.format("Executing request [%s] ...", requestUrl2));
+            Response response = client.prepareGet(requestUrl2).execute().get();
+            assertEquals(response.getStatusCode(), 302);
+        }
+    }
+
+    @Test(groups = "online")
+    public void stripQueryStringTest() throws Exception {
+
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online")
+    public void evilCookieTest() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            Cookie cookie = new DefaultCookie("evilcookie", "test");
+            cookie.setDomain(".google.com");
+            cookie.setPath("/");
+
+            RequestBuilder builder = get("http://localhost")//
+                    .setFollowRedirect(true)//
+                    .setUrl("http://www.google.com/")//
+                    .addHeader("Content-Type", "text/plain")//
+                    .addCookie(cookie);
+
+            Response response = c.executeRequest(builder.build()).get();
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+        }
+    }
+
+    @Test(groups = "online", enabled = false)
+    public void testAHC62Com() throws Exception {
+        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
+            Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js").execute(new AsyncHandler<Response>() {
+
+                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+
+                public void onThrowable(Throwable t) {
+                    t.printStackTrace();
+                }
+
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    builder.accumulate(bodyPart);
+                    return State.CONTINUE;
+                }
+
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                    builder.accumulate(responseStatus);
+                    return State.CONTINUE;
+                }
+
+                public State onHeadersReceived(HttpHeaders headers) throws Exception {
+                    builder.accumulate(headers);
+                    return State.CONTINUE;
+                }
+
+                public Response onCompleted() throws Exception {
+                    return builder.build();
+                }
+            }).get(10, TimeUnit.SECONDS);
+            assertNotNull(response);
+            assertTrue(response.getResponseBody().length() >= 3870);
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index cec2b0ef5..b58644a00 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -24,7 +24,6 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
-import javax.servlet.AsyncContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -33,6 +32,8 @@
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -50,14 +51,15 @@ public AbstractHandler configureHandler() throws Exception {
         public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
                 throws IOException, ServletException {
             response.setStatus(HttpServletResponse.SC_OK);
-            final AsyncContext asyncContext = request.startAsync();
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
             new Thread(new Runnable() {
                 public void run() {
                     try {
                         Thread.sleep(SLEEPTIME_MS);
                         response.getOutputStream().print(MSG);
                         response.getOutputStream().flush();
-                        asyncContext.complete();
+                        continuation.complete();
                     } catch (InterruptedException e) {
                         logger.error(e.getMessage(), e);
                     } catch (IOException e) {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
index ecb24ab4e..297fd9d24 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
@@ -13,19 +13,19 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static io.netty.handler.codec.http.HttpHeaderNames.*;
-import static io.netty.handler.codec.http.HttpHeaderValues.*;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_OCTET_STREAM;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertEquals;
 
 import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Function;
 
-import org.asynchttpclient.*;
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BasicAuthTest;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -37,6 +37,7 @@
     @BeforeClass(alwaysRun = true)
     @Override
     public void setUpGlobal() throws Exception {
+
         server = new Server();
         ServerConnector connector1 = addHttpConnector(server);
         addBasicAuthHandler(server, configureHandler());
@@ -50,56 +51,31 @@ public AbstractHandler configureHandler() throws Exception {
         return new BasicAuthTest.SimpleHandler();
     }
 
-    private void expectBrokenPipe(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
+    @Test(groups = "standalone", enabled = false)
+    public void testNoRealm() throws Exception {
         File file = createTempFile(1024 * 1024);
 
-        Throwable cause = null;
         try (AsyncHttpClient client = asyncHttpClient()) {
-            try {
-                for (int i = 0; i < 20 && cause == null; i++) {
-                    f.apply(client.preparePut(getTargetUrl())//
-                            .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                            .execute().get();
-                }
-            } catch (ExecutionException e) {
-                cause = e.getCause();
+            for (int i = 0; i < 20; i++) {
+                Response response = client.preparePut(getTargetUrl())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
+                assertEquals(response.getStatusCode(), 401);
             }
         }
-
-        assertTrue(cause instanceof IOException, "Expected an IOException");
     }
 
-    @Test(groups = "standalone")
-    public void noRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb);
-    }
-
-    @Test(groups = "standalone")
-    public void unauthorizedNonPreemptiveRealmCausesServerToCloseSocket() throws Exception {
-        expectBrokenPipe(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)));
-    }
-
-    private void expectSuccess(Function<BoundRequestBuilder, BoundRequestBuilder> f) throws Exception {
+    @Test(groups = "standalone", enabled = false)
+    public void testAuthorizedRealm() throws Exception {
         File file = createTempFile(1024 * 1024);
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             for (int i = 0; i < 20; i++) {
-                Response response = f.apply(client.preparePut(getTargetUrl())//
-                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)))//
-                        .execute().get();
+                Response response = client.preparePut(getTargetUrl())//
+                        .setRealm(basicAuthRealm(USER, ADMIN).build())//
+                        .addBodyPart(new FilePart("test", file, APPLICATION_OCTET_STREAM.toString(), UTF_8)).execute().get();
                 assertEquals(response.getStatusCode(), 200);
                 assertEquals(response.getResponseBodyAsBytes().length, Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue());
             }
         }
     }
-
-    @Test(groups = "standalone")
-    public void authorizedPreemptiveRealmWorks() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN).setUsePreemptiveAuth(true)));
-    }
-
-    @Test(groups = "standalone")
-    public void authorizedNonPreemptiveRealmWorksWithExpectContinue() throws Exception {
-        expectSuccess(rb -> rb.setRealm(basicAuthRealm(USER, ADMIN)).setHeader(EXPECT, CONTINUE));
-    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
index 87b57bc83..b7b9890ce 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -193,7 +193,7 @@ public void testVisitPostContents() {
 
     @Test
     public void transferToShouldWriteStringPart() throws IOException, URISyntaxException {
-        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"), UTF_8);
+        String text = FileUtils.readFileToString(TestUtils.resourceAsFile("test_sample_message.eml"));
 
         List<Part> parts = new ArrayList<>();
         parts.add(new StringPart("test_sample_message.eml", text));
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index 27e88741a..edba32b80 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -13,7 +13,7 @@
 
     <properties>
       <retrofit2.version>2.3.0</retrofit2.version>
-      <lombok.version>1.16.18</lombok.version>
+      <lombok.version>1.16.16</lombok.version>
     </properties>
 
     <dependencies>
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
index b97993dc5..9497d0f81 100644
--- a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -31,7 +31,7 @@ public void testToObservableNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -51,7 +51,7 @@ public void testToObservableError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("https://gatling.io/ttfn"));
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(() -> client.prepareGet("http://gatling.io/ttfn"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -71,7 +71,7 @@ public void testObserveNoError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -91,7 +91,7 @@ public void testObserveError() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io/ttfn"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io/ttfn"));
             o1.subscribe(tester);
             tester.awaitTerminalEvent();
             tester.assertTerminalEvent();
@@ -111,7 +111,7 @@ public void testObserveMultiple() {
         final TestSubscriber<Response> tester = new TestSubscriber<>();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("https://gatling.io"));
+            Observable<Response> o1 = AsyncHttpObservable.observe(() -> client.prepareGet("http://gatling.io"));
             Observable<Response> o2 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.wisc.edu").setFollowRedirect(true));
             Observable<Response> o3 = AsyncHttpObservable.observe(() -> client.prepareGet("http://www.umn.edu").setFollowRedirect(true));
             Observable<Response> all = Observable.merge(o1, o2, o3);
diff --git a/pom.xml b/pom.xml
index 0c0df8d3e..52f433306 100644
--- a/pom.xml
+++ b/pom.xml
@@ -78,9 +78,9 @@
 				<version>1.6</version>
 			</extension>
 		<extension>
-                <groupId>com.vackosar.gitflowincrementalbuilder</groupId>
-                <artifactId>gitflow-incremental-builder</artifactId>
-                <version>3.4</version>
+                <groupId>edu.illinois</groupId>
+                <artifactId>incremental-builder-with-ekstazi</artifactId>
+                <version>3.5.0</version>
             </extension>
         </extensions>
 		<defaultGoal>install</defaultGoal>
@@ -387,22 +387,24 @@
 		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
-		<netty.version>4.1.17.Final</netty.version>
+		<netty.version>4.1.15.Final</netty.version>
 		<slf4j.version>1.7.25</slf4j.version>
 		<reactive-streams.version>1.0.0</reactive-streams.version>
 		<netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
-		<rxjava.version>1.3.3</rxjava.version>
-		<rxjava2.version>2.1.6</rxjava2.version>
+		<rxjava.version>1.3.0</rxjava.version>
+		<rxjava2.version>2.1.3</rxjava2.version>
 		<logback.version>1.2.3</logback.version>
 		<testng.version>6.11</testng.version>
-		<jetty.version>9.4.7.v20170914</jetty.version>
-		<tomcat.version>9.0.1</tomcat.version>
-		<commons-io.version>2.6</commons-io.version>
+		<jetty.version>9.4.6.v20170531</jetty.version>
+		<tomcat.version>8.5.20</tomcat.version>
+		<commons-io.version>2.5</commons-io.version>
 		<commons-fileupload.version>1.3.3</commons-fileupload.version>
 		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
 		<powermock.version>1.6.6</powermock.version>
-	<gib.referenceBranch>HEAD^1</gib.referenceBranch>
+	<gib.commitRange>${env.TRAVIS_COMMIT_RANGE}</gib.commitRange>
         <gib.enabled>true</gib.enabled>
+        <gib.useEkstazi>false</gib.useEkstazi>
+        <gib.excludePathRegex>(.*\.apt$)|(.*\.txt$)|(.*\.md$)|(.*\.html$)|(.*\.rst$)|(.*\.scss$)|(.*\.css$)|(.*\.png$)|(.*\.py$)|(.*README$)|(.*\.jpg$)|(.*\.jpeg$)|(.*NOTICE$)|(.*\.gitignore$)</gib.excludePathRegex>
     </properties>
 </project>
 
