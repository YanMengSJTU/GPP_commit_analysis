diff --git a/client/pom.xml b/client/pom.xml
index 70ff7e8e4..a5fdcf5e0 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.0-RC9-SNAPSHOT</version>
+		<version>2.0.0-RC10-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
diff --git a/client/src/main/java/io/netty/channel/ChannelId.java b/client/src/main/java/io/netty/channel/ChannelId.java
new file mode 100644
index 000000000..b62fff888
--- /dev/null
+++ b/client/src/main/java/io/netty/channel/ChannelId.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import java.io.Serializable;
+
+/**
+ * Represents the globally unique identifier of a {@link Channel}.
+ * <p>
+ * The identifier is generated from various sources listed in the following:
+ * <ul>
+ * <li>MAC address (EUI-48 or EUI-64) or the network adapter, preferrably a globally unique one,</li>
+ * <li>the current process ID,</li>
+ * <li>{@link System#currentTimeMillis()},</li>
+ * <li>{@link System#nanoTime()},</li>
+ * <li>a random 32-bit integer, and</li>
+ * <li>a sequentially incremented 32-bit integer.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * The global uniqueness of the generated identifier mostly depends on the MAC address and the current process ID,
+ * which are auto-detected at the class-loading time in best-effort manner.  If all attempts to acquire them fail,
+ * a warning message is logged, and random values will be used instead.  Alternatively, you can specify them manually
+ * via system properties:
+ * <ul>
+ * <li>{@code io.netty.machineId} - hexadecimal representation of 48 (or 64) bit integer,
+ *     optionally separated by colon or hyphen.</li>
+ * <li>{@code io.netty.processId} - an integer between 0 and 65535</li>
+ * </ul>
+ * </p>
+ */
+public interface ChannelId extends Serializable, Comparable<ChannelId> {
+    /**
+     * Returns the short but globally non-unique string representation of the {@link ChannelId}.
+     */
+    String asShortText();
+
+    /**
+     * Returns the long yet globally unique string representation of the {@link ChannelId}.
+     */
+    String asLongText();
+}
diff --git a/client/src/main/java/io/netty/channel/DefaultChannelId.java b/client/src/main/java/io/netty/channel/DefaultChannelId.java
new file mode 100644
index 000000000..3e7c42c3b
--- /dev/null
+++ b/client/src/main/java/io/netty/channel/DefaultChannelId.java
@@ -0,0 +1,296 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.buffer.ByteBufUtil;
+import io.netty.util.internal.MacAddressUtil;
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.ThreadLocalRandom;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.regex.Pattern;
+
+/**
+ * The default {@link ChannelId} implementation.
+ */
+public final class DefaultChannelId implements ChannelId {
+
+    private static final long serialVersionUID = 3884076183504074063L;
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelId.class);
+
+    private static final Pattern MACHINE_ID_PATTERN = Pattern.compile("^(?:[0-9a-fA-F][:-]?){6,8}$");
+    private static final int MACHINE_ID_LEN = MacAddressUtil.MAC_ADDRESS_LENGTH;
+    private static final byte[] MACHINE_ID;
+    private static final int PROCESS_ID_LEN = 4;
+    // Maximal value for 64bit systems is 2^22.  See man 5 proc.
+    // See https://github.com/netty/netty/issues/2706
+    private static final int MAX_PROCESS_ID = 4194304;
+    private static final int PROCESS_ID;
+    private static final int SEQUENCE_LEN = 4;
+    private static final int TIMESTAMP_LEN = 8;
+    private static final int RANDOM_LEN = 4;
+
+    private static final AtomicInteger nextSequence = new AtomicInteger();
+
+    static ChannelId newInstance() {
+        DefaultChannelId id = new DefaultChannelId();
+        id.init();
+        return id;
+    }
+
+    static {
+        int processId = -1;
+        String customProcessId = SystemPropertyUtil.get("io.netty.processId");
+        if (customProcessId != null) {
+            try {
+                processId = Integer.parseInt(customProcessId);
+            } catch (NumberFormatException e) {
+                // Malformed input.
+            }
+
+            if (processId < 0 || processId > MAX_PROCESS_ID) {
+                processId = -1;
+                logger.warn("-Dio.netty.processId: {} (malformed)", customProcessId);
+            } else if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.processId: {} (user-set)", processId);
+            }
+        }
+
+        if (processId < 0) {
+            processId = defaultProcessId();
+            if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.processId: {} (auto-detected)", processId);
+            }
+        }
+
+        PROCESS_ID = processId;
+
+        byte[] machineId = null;
+        String customMachineId = SystemPropertyUtil.get("io.netty.machineId");
+        if (customMachineId != null) {
+            if (MACHINE_ID_PATTERN.matcher(customMachineId).matches()) {
+                machineId = parseMachineId(customMachineId);
+                logger.debug("-Dio.netty.machineId: {} (user-set)", customMachineId);
+            } else {
+                logger.warn("-Dio.netty.machineId: {} (malformed)", customMachineId);
+            }
+        }
+
+        if (machineId == null) {
+            machineId = defaultMachineId();
+            if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.machineId: {} (auto-detected)", MacAddressUtil.formatAddress(machineId));
+            }
+        }
+
+        MACHINE_ID = machineId;
+    }
+
+    @SuppressWarnings("DynamicRegexReplaceableByCompiledPattern")
+    private static byte[] parseMachineId(String value) {
+        // Strip separators.
+        value = value.replaceAll("[:-]", "");
+
+        byte[] machineId = new byte[MACHINE_ID_LEN];
+        for (int i = 0; i < value.length(); i += 2) {
+            machineId[i] = (byte) Integer.parseInt(value.substring(i, i + 2), 16);
+        }
+
+        return machineId;
+    }
+
+    private static byte[] defaultMachineId() {
+        byte[] bestMacAddr = MacAddressUtil.bestAvailableMac();
+        if (bestMacAddr == null) {
+            bestMacAddr = new byte[MacAddressUtil.MAC_ADDRESS_LENGTH];
+            ThreadLocalRandom.current().nextBytes(bestMacAddr);
+            logger.warn(
+                    "Failed to find a usable hardware address from the network interfaces; using random bytes: {}",
+                    MacAddressUtil.formatAddress(bestMacAddr));
+        }
+        return bestMacAddr;
+    }
+
+    private static int defaultProcessId() {
+        final ClassLoader loader = PlatformDependent.getSystemClassLoader();
+        String value;
+        try {
+            // Invoke java.lang.management.ManagementFactory.getRuntimeMXBean().getName()
+            Class<?> mgmtFactoryType = Class.forName("java.lang.management.ManagementFactory", true, loader);
+            Class<?> runtimeMxBeanType = Class.forName("java.lang.management.RuntimeMXBean", true, loader);
+
+            Method getRuntimeMXBean = mgmtFactoryType.getMethod("getRuntimeMXBean", EmptyArrays.EMPTY_CLASSES);
+            Object bean = getRuntimeMXBean.invoke(null, EmptyArrays.EMPTY_OBJECTS);
+            Method getName = runtimeMxBeanType.getDeclaredMethod("getName", EmptyArrays.EMPTY_CLASSES);
+            value = (String) getName.invoke(bean, EmptyArrays.EMPTY_OBJECTS);
+        } catch (Exception e) {
+            logger.debug("Could not invoke ManagementFactory.getRuntimeMXBean().getName(); Android?", e);
+            try {
+                // Invoke android.os.Process.myPid()
+                Class<?> processType = Class.forName("android.os.Process", true, loader);
+                Method myPid = processType.getMethod("myPid", EmptyArrays.EMPTY_CLASSES);
+                value = myPid.invoke(null, EmptyArrays.EMPTY_OBJECTS).toString();
+            } catch (Exception e2) {
+                logger.debug("Could not invoke Process.myPid(); not Android?", e2);
+                value = "";
+            }
+        }
+
+        int atIndex = value.indexOf('@');
+        if (atIndex >= 0) {
+            value = value.substring(0, atIndex);
+        }
+
+        int pid;
+        try {
+            pid = Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            // value did not contain an integer.
+            pid = -1;
+        }
+
+        if (pid < 0 || pid > MAX_PROCESS_ID) {
+            pid = ThreadLocalRandom.current().nextInt(MAX_PROCESS_ID + 1);
+            logger.warn("Failed to find the current process ID from '{}'; using a random value: {}",  value, pid);
+        }
+
+        return pid;
+    }
+
+    private final byte[] data = new byte[MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN + RANDOM_LEN];
+    private int hashCode;
+
+    private transient String shortValue;
+    private transient String longValue;
+
+    private void init() {
+        int i = 0;
+
+        // machineId
+        System.arraycopy(MACHINE_ID, 0, data, i, MACHINE_ID_LEN);
+        i += MACHINE_ID_LEN;
+
+        // processId
+        i = writeInt(i, PROCESS_ID);
+
+        // sequence
+        i = writeInt(i, nextSequence.getAndIncrement());
+
+        // timestamp (kind of)
+        i = writeLong(i, Long.reverse(System.nanoTime()) ^ System.currentTimeMillis());
+
+        // random
+        int random = ThreadLocalRandom.current().nextInt();
+        hashCode = random;
+        i = writeInt(i, random);
+
+        assert i == data.length;
+    }
+
+    private int writeInt(int i, int value) {
+        data[i ++] = (byte) (value >>> 24);
+        data[i ++] = (byte) (value >>> 16);
+        data[i ++] = (byte) (value >>> 8);
+        data[i ++] = (byte) value;
+        return i;
+    }
+
+    private int writeLong(int i, long value) {
+        data[i ++] = (byte) (value >>> 56);
+        data[i ++] = (byte) (value >>> 48);
+        data[i ++] = (byte) (value >>> 40);
+        data[i ++] = (byte) (value >>> 32);
+        data[i ++] = (byte) (value >>> 24);
+        data[i ++] = (byte) (value >>> 16);
+        data[i ++] = (byte) (value >>> 8);
+        data[i ++] = (byte) value;
+        return i;
+    }
+
+    @Override
+    public String asShortText() {
+        String shortValue = this.shortValue;
+        if (shortValue == null) {
+            this.shortValue = shortValue = ByteBufUtil.hexDump(
+                    data, MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN, RANDOM_LEN);
+        }
+        return shortValue;
+    }
+
+    @Override
+    public String asLongText() {
+        String longValue = this.longValue;
+        if (longValue == null) {
+            this.longValue = longValue = newLongValue();
+        }
+        return longValue;
+    }
+
+    private String newLongValue() {
+        StringBuilder buf = new StringBuilder(2 * data.length + 5);
+        int i = 0;
+        i = appendHexDumpField(buf, i, MACHINE_ID_LEN);
+        i = appendHexDumpField(buf, i, PROCESS_ID_LEN);
+        i = appendHexDumpField(buf, i, SEQUENCE_LEN);
+        i = appendHexDumpField(buf, i, TIMESTAMP_LEN);
+        i = appendHexDumpField(buf, i, RANDOM_LEN);
+        assert i == data.length;
+        return buf.substring(0, buf.length() - 1);
+    }
+
+    private int appendHexDumpField(StringBuilder buf, int i, int length) {
+        buf.append(ByteBufUtil.hexDump(data, i, length));
+        buf.append('-');
+        i += length;
+        return i;
+    }
+
+    @Override
+    public int hashCode() {
+        return hashCode;
+    }
+
+    @Override
+    public int compareTo(ChannelId o) {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+
+        if (!(obj instanceof DefaultChannelId)) {
+            return false;
+        }
+
+        return Arrays.equals(data, ((DefaultChannelId) obj).data);
+    }
+
+    @Override
+    public String toString() {
+        return asShortText();
+    }
+}
\ No newline at end of file
diff --git a/client/src/main/java/io/netty/util/internal/MacAddressUtil.java b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
new file mode 100644
index 000000000..858368d6d
--- /dev/null
+++ b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import io.netty.util.NetUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+public final class MacAddressUtil {
+
+    /**
+     * Length of a valid MAC address.
+     */
+    public static final int MAC_ADDRESS_LENGTH = 8;
+
+    private static final byte[] NOT_FOUND = { -1 };
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(MacAddressUtil.class);
+
+    /**
+     * Obtains the best MAC address found on local network interfaces.
+     * Generally speaking, an active network interface used on public
+     * networks is better than a local network interface.
+     *
+     * @return byte array containing a MAC. null if no MAC can be found.
+     */
+    public static byte[] bestAvailableMac() {
+        // Find the best MAC address available.
+        byte[] bestMacAddr = NOT_FOUND;
+        InetAddress bestInetAddr = NetUtil.LOCALHOST4;
+
+        // Retrieve the list of available network interfaces.
+        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();
+        try {
+            for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {
+                NetworkInterface iface = i.nextElement();
+                // Use the interface with proper INET addresses only.
+                Enumeration<InetAddress> addrs = iface.getInetAddresses();
+                if (addrs.hasMoreElements()) {
+                    InetAddress a = addrs.nextElement();
+                    if (!a.isLoopbackAddress()) {
+                        ifaces.put(iface, a);
+                    }
+                }
+            }
+        } catch (SocketException e) {
+            logger.warn("Failed to retrieve the list of available network interfaces", e);
+        }
+
+        for (Entry<NetworkInterface, InetAddress> entry: ifaces.entrySet()) {
+            NetworkInterface iface = entry.getKey();
+            InetAddress inetAddr = entry.getValue();
+            if (iface.isVirtual()) {
+                continue;
+            }
+
+            byte[] macAddr;
+            try {
+                macAddr = iface.getHardwareAddress();
+            } catch (SocketException e) {
+                logger.debug("Failed to get the hardware address of a network interface: {}", iface, e);
+                continue;
+            }
+
+            boolean replace = false;
+            int res = compareAddresses(bestMacAddr, macAddr);
+            if (res < 0) {
+                // Found a better MAC address.
+                replace = true;
+            } else if (res == 0) {
+                // Two MAC addresses are of pretty much same quality.
+                res = compareAddresses(bestInetAddr, inetAddr);
+                if (res < 0) {
+                    // Found a MAC address with better INET address.
+                    replace = true;
+                } else if (res == 0) {
+                    // Cannot tell the difference.  Choose the longer one.
+                    if (bestMacAddr.length < macAddr.length) {
+                        replace = true;
+                    }
+                }
+            }
+
+            if (replace) {
+                bestMacAddr = macAddr;
+                bestInetAddr = inetAddr;
+            }
+        }
+
+        if (bestMacAddr == NOT_FOUND) {
+            return null;
+        }
+
+        switch (bestMacAddr.length) {
+            case 6: // EUI-48 - convert to EUI-64
+                byte[] newAddr = new byte[MAC_ADDRESS_LENGTH];
+                System.arraycopy(bestMacAddr, 0, newAddr, 0, 3);
+                newAddr[3] = (byte) 0xFF;
+                newAddr[4] = (byte) 0xFE;
+                System.arraycopy(bestMacAddr, 3, newAddr, 5, 3);
+                bestMacAddr = newAddr;
+                break;
+            default: // Unknown
+                bestMacAddr = Arrays.copyOf(bestMacAddr, MAC_ADDRESS_LENGTH);
+        }
+
+        return bestMacAddr;
+    }
+
+    /**
+     * @param addr byte array of a MAC address.
+     * @return hex formatted MAC address.
+     */
+    public static String formatAddress(byte[] addr) {
+        StringBuilder buf = new StringBuilder(24);
+        for (byte b: addr) {
+            buf.append(String.format("%02x:", b & 0xff));
+        }
+        return buf.substring(0, buf.length() - 1);
+    }
+
+    /**
+     * @return positive - current is better, 0 - cannot tell from MAC addr, negative - candidate is better.
+     */
+    private static int compareAddresses(byte[] current, byte[] candidate) {
+        if (candidate == null) {
+            return 1;
+        }
+
+        // Must be EUI-48 or longer.
+        if (candidate.length < 6) {
+            return 1;
+        }
+
+        // Must not be filled with only 0 and 1.
+        boolean onlyZeroAndOne = true;
+        for (byte b: candidate) {
+            if (b != 0 && b != 1) {
+                onlyZeroAndOne = false;
+                break;
+            }
+        }
+
+        if (onlyZeroAndOne) {
+            return 1;
+        }
+
+        // Must not be a multicast address
+        if ((candidate[0] & 1) != 0) {
+            return 1;
+        }
+
+        // Prefer globally unique address.
+        if ((current[0] & 2) == 0) {
+            if ((candidate[0] & 2) == 0) {
+                // Both current and candidate are globally unique addresses.
+                return 0;
+            } else {
+                // Only current is globally unique.
+                return 1;
+            }
+        } else {
+            if ((candidate[0] & 2) == 0) {
+                // Only candidate is globally unique.
+                return -1;
+            } else {
+                // Both current and candidate are non-unique.
+                return 0;
+            }
+        }
+    }
+
+    /**
+     * @return positive - current is better, 0 - cannot tell, negative - candidate is better
+     */
+    private static int compareAddresses(InetAddress current, InetAddress candidate) {
+        return scoreAddress(current) - scoreAddress(candidate);
+    }
+
+    private static int scoreAddress(InetAddress addr) {
+        if (addr.isAnyLocalAddress() || addr.isLoopbackAddress()) {
+            return 0;
+        }
+        if (addr.isMulticastAddress()) {
+            return 1;
+        }
+        if (addr.isLinkLocalAddress()) {
+            return 2;
+        }
+        if (addr.isSiteLocalAddress()) {
+            return 3;
+        }
+
+        return 4;
+    }
+
+    private MacAddressUtil() { }
+}
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index d7152ce33..bd6d0d96e 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -83,13 +83,9 @@ private Realm(AuthScheme scheme,//
             boolean useAbsoluteURI,//
             boolean omitQuery) {
 
-        assertNotNull(scheme, "scheme");
-        assertNotNull(principal, "principal");
-        assertNotNull(password, "password");
-
-        this.scheme = scheme;
-        this.principal = principal;
-        this.password = password;
+        this.scheme = assertNotNull(scheme, "scheme");
+        this.principal = assertNotNull(principal, "principal");
+        this.password = assertNotNull(password, "password");
         this.realmName = realmName;
         this.nonce = nonce;
         this.algorithm = algorithm;
diff --git a/client/src/main/java/org/asynchttpclient/cookie/Cookie.java b/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
index 5e8599c6b..091c16ddc 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/Cookie.java
@@ -18,8 +18,7 @@
 
     public static Cookie newValidCookie(String name, String value, boolean wrap, String domain, String path, long maxAge, boolean secure, boolean httpOnly) {
 
-        assertNotNull(name, "name");
-        name = name.trim();
+        name = assertNotNull(name, "name").trim();
         assertNotEmpty(name, "name");
 
         for (int i = 0; i < name.length(); i++) {
@@ -47,11 +46,7 @@ public static Cookie newValidCookie(String name, String value, boolean wrap, Str
             throw new IllegalArgumentException("name starting with '$' not allowed: " + name);
         }
 
-        assertNotNull(value, "value");
-        domain = validateValue("domain", domain);
-        path = validateValue("path", path);
-
-        return new Cookie(name, value, wrap, domain, path, maxAge, secure, httpOnly);
+        return new Cookie(name, assertNotNull(value, "value"), wrap, validateValue("domain", domain), validateValue("path", path), maxAge, secure, httpOnly);
     }
 
     private static String validateValue(String name, String value) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 67adaa08f..5be13db17 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -14,6 +14,8 @@
 package org.asynchttpclient.netty.channel;
 
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
+import io.netty.channel.DefaultChannelId;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
@@ -26,6 +28,7 @@
     private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
 
     private static final AttributeKey<Object> DEFAULT_ATTRIBUTE = AttributeKey.valueOf("default");
+    private static final AttributeKey<ChannelId> CHANNEL_ID_ATTRIBUTE = AttributeKey.valueOf("channelId");
 
     public static Object getAttribute(Channel channel) {
         Attribute<Object> attr = channel.attr(DEFAULT_ATTRIBUTE);
@@ -44,6 +47,15 @@ public static boolean isChannelValid(Channel channel) {
         return channel != null && channel.isActive();
     }
 
+    public static ChannelId getChannelId(Channel channel) {
+        Attribute<ChannelId> attr = channel.attr(CHANNEL_ID_ATTRIBUTE);
+        return attr != null ? attr.get() : null;
+    }
+
+    public static void initChannelId(Channel channel) {
+        channel.attr(CHANNEL_ID_ATTRIBUTE).set(new DefaultChannelId());
+    }
+
     public static void silentlyCloseChannel(Channel channel) {
         try {
             if (channel != null && channel.isActive())
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 677f10c01..a36a388bf 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -13,9 +13,10 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
 import io.netty.util.TimerTask;
@@ -25,7 +26,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -37,22 +38,20 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * A simple implementation of
- * {@link ChannelPool} based on a
- * {@link java.util.concurrent.ConcurrentHashMap}
+ * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
 public final class DefaultChannelPool implements ChannelPool {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
 
-    private final ConcurrentHashMap<Object, ConcurrentLinkedQueue<IdleChannel>> partitions = new ConcurrentHashMap<>();
-    private final ConcurrentHashMap<Integer, ChannelCreation> channelId2Creation = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;
     private final AtomicBoolean isClosed = new AtomicBoolean(false);
     private final Timer nettyTimer;
-    private final int maxConnectionTtl;
-    private final boolean maxConnectionTtlDisabled;
-    private final long maxIdleTime;
-    private final boolean maxIdleTimeDisabled;
+    private final int connectionTtl;
+    private final boolean connectionTtlEnabled;
+    private final int maxIdleTime;
+    private final boolean maxIdleTimeEnabled;
     private final long cleanerPeriod;
 
     public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
@@ -61,22 +60,28 @@ public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer)
                 hashedWheelTimer);
     }
 
-    private int channelId(Channel channel) {
-        return channel.hashCode();
+    private ChannelId channelId(Channel channel) {
+        return Channels.getChannelId(channel);
     }
 
-    public DefaultChannelPool(long maxIdleTime,//
-            int maxConnectionTtl,//
+    private int cleanerPeriod(int ttl) {
+        return (int) Math.ceil(ttl / 2.0);
+    }
+
+    public DefaultChannelPool(int maxIdleTime,//
+            int connectionTtl,//
             Timer nettyTimer) {
-        this.maxIdleTime = maxIdleTime;
-        this.maxConnectionTtl = maxConnectionTtl;
-        maxConnectionTtlDisabled = maxConnectionTtl <= 0;
+        this.maxIdleTime = (int) maxIdleTime;
+        this.connectionTtl = connectionTtl;
+        connectionTtlEnabled = connectionTtl > 0;
+        channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
         this.nettyTimer = nettyTimer;
-        maxIdleTimeDisabled = maxIdleTime <= 0;
+        maxIdleTimeEnabled = maxIdleTime > 0;
 
-        cleanerPeriod = Math.min(maxConnectionTtlDisabled ? Long.MAX_VALUE : maxConnectionTtl, maxIdleTimeDisabled ? Long.MAX_VALUE : maxIdleTime);
+        // period is half
+        cleanerPeriod = Math.min(connectionTtlEnabled ? cleanerPeriod(connectionTtl) : Integer.MAX_VALUE, maxIdleTimeEnabled ? cleanerPeriod(maxIdleTime) : Long.MAX_VALUE);
 
-        if (!maxConnectionTtlDisabled || !maxIdleTimeDisabled)
+        if (connectionTtlEnabled || maxIdleTimeEnabled)
             scheduleNewIdleChannelDetector(new IdleChannelDetector());
     }
 
@@ -99,8 +104,7 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
         final long start;
 
         IdleChannel(Channel channel, long start) {
-            assertNotNull(channel, "channel");
-            this.channel = channel;
+            this.channel = assertNotNull(channel, "channel");
             this.start = start;
         }
 
@@ -117,11 +121,11 @@ public int hashCode() {
     }
 
     private boolean isTtlExpired(Channel channel, long now) {
-        if (maxConnectionTtlDisabled)
+        if (!connectionTtlEnabled)
             return false;
 
         ChannelCreation creation = channelId2Creation.get(channelId(channel));
-        return creation != null && now - creation.creationTime >= maxConnectionTtl;
+        return creation != null && now - creation.creationTime >= connectionTtl;
     }
 
     private boolean isRemotelyClosed(Channel channel) {
@@ -131,14 +135,14 @@ private boolean isRemotelyClosed(Channel channel) {
     private final class IdleChannelDetector implements TimerTask {
 
         private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
-            return !maxIdleTimeDisabled && now - idleChannel.start >= maxIdleTime;
+            return maxIdleTimeEnabled && now - idleChannel.start >= maxIdleTime;
         }
 
-        private List<IdleChannel> expiredChannels(ConcurrentLinkedQueue<IdleChannel> partition, long now) {
+        private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {
             // lazy create
             List<IdleChannel> idleTimeoutChannels = null;
             for (IdleChannel idleChannel : partition) {
-                if (isTtlExpired(idleChannel.channel, now) || isIdleTimeoutExpired(idleChannel, now) || isRemotelyClosed(idleChannel.channel)) {
+                if (isIdleTimeoutExpired(idleChannel, now) || isRemotelyClosed(idleChannel.channel) || isTtlExpired(idleChannel.channel, now)) {
                     LOGGER.debug("Adding Candidate expired Channel {}", idleChannel.channel);
                     if (idleTimeoutChannels == null)
                         idleTimeoutChannels = new ArrayList<>();
@@ -154,7 +158,7 @@ private boolean isChannelCloseable(Channel channel) {
             if (attribute instanceof NettyResponseFuture) {
                 NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
                 if (!future.isDone()) {
-                    LOGGER.error("Future not in appropriate state %s, not closing", future);
+                    LOGGER.error("Future not in appropriate state {}, not closing", future);
                     return false;
                 }
             }
@@ -191,40 +195,38 @@ public void run(Timeout timeout) throws Exception {
             if (isClosed.get())
                 return;
 
-            try {
-                if (LOGGER.isDebugEnabled())
-                    for (Object key: partitions.keySet()) {
-                        LOGGER.debug("Entry count for : {} : {}", key, partitions.get(key).size());
-                    }
+            if (LOGGER.isDebugEnabled())
+                for (Object key : partitions.keySet()) {
+                    LOGGER.debug("Entry count for : {} : {}", key, partitions.get(key).size());
+                }
 
-                long start = millisTime();
-                int closedCount = 0;
-                int totalCount = 0;
+            long start = millisTime();
+            int closedCount = 0;
+            int totalCount = 0;
 
-                for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+            for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
 
-                    // store in intermediate unsynchronized lists to minimize
-                    // the impact on the ConcurrentLinkedQueue
-                    if (LOGGER.isDebugEnabled())
-                        totalCount += partition.size();
+                // store in intermediate unsynchronized lists to minimize
+                // the impact on the ConcurrentLinkedDeque
+                if (LOGGER.isDebugEnabled())
+                    totalCount += partition.size();
 
-                    List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
+                List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
 
-                    if (!closedChannels.isEmpty()) {
+                if (!closedChannels.isEmpty()) {
+                    if (connectionTtlEnabled) {
                         for (IdleChannel closedChannel : closedChannels)
                             channelId2Creation.remove(channelId(closedChannel.channel));
-
-                        partition.removeAll(closedChannels);
-                        closedCount += closedChannels.size();
                     }
+
+                    partition.removeAll(closedChannels);
+                    closedCount += closedChannels.size();
                 }
+            }
 
+            if (LOGGER.isDebugEnabled()) {
                 long duration = millisTime() - start;
-
                 LOGGER.debug("Closed {} connections out of {} in {}ms", closedCount, totalCount, duration);
-
-            } catch (Throwable t) {
-                LOGGER.error("uncaught exception!", t);
             }
 
             scheduleNewIdleChannelDetector(timeout.task());
@@ -243,38 +245,38 @@ public boolean offer(Channel channel, Object partitionKey) {
         if (isTtlExpired(channel, now))
             return false;
 
-        boolean offered = offer0(channel, partitionKey,now);
-        if (offered) {
+        boolean offered = offer0(channel, partitionKey, now);
+        if (connectionTtlEnabled && offered) {
             registerChannelCreation(channel, partitionKey, now);
         }
 
         return offered;
     }
-    
+
     private boolean offer0(Channel channel, Object partitionKey, long now) {
-        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionKey);
+        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
         if (partition == null) {
-            partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedQueue<>());
+            partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedDeque<>());
         }
-        return partition.add(new IdleChannel(channel, now));
+        return partition.offerFirst(new IdleChannel(channel, now));
     }
-    
+
     private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
         if (channelId2Creation.containsKey(partitionKey)) {
             channelId2Creation.putIfAbsent(channelId(channel), new ChannelCreation(now, partitionKey));
         }
     }
-    
+
     /**
      * {@inheritDoc}
      */
     public Channel poll(Object partitionKey) {
 
         IdleChannel idleChannel = null;
-        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionKey);
+        ConcurrentLinkedDeque<IdleChannel> partition = partitions.get(partitionKey);
         if (partition != null) {
             while (idleChannel == null) {
-                idleChannel = partition.poll();
+                idleChannel = partition.pollFirst();
 
                 if (idleChannel == null)
                     // pool is empty
@@ -292,7 +294,7 @@ else if (isRemotelyClosed(idleChannel.channel)) {
      * {@inheritDoc}
      */
     public boolean removeAll(Channel channel) {
-        ChannelCreation creation = channelId2Creation.remove(channelId(channel));
+        ChannelCreation creation = connectionTtlEnabled ? channelId2Creation.remove(channelId(channel)) : null;
         return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
     }
 
@@ -310,23 +312,27 @@ public void destroy() {
         if (isClosed.getAndSet(true))
             return;
 
-        for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+        for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {
             for (IdleChannel idleChannel : partition)
                 close(idleChannel.channel);
         }
 
         partitions.clear();
-        channelId2Creation.clear();
+        if (connectionTtlEnabled) {
+            channelId2Creation.clear();
+        }
     }
 
     private void close(Channel channel) {
         // FIXME pity to have to do this here
         Channels.setDiscard(channel);
-        channelId2Creation.remove(channelId(channel));
+        if (connectionTtlEnabled) {
+            channelId2Creation.remove(channelId(channel));
+        }
         Channels.silentlyCloseChannel(channel);
     }
 
-    private void flushPartition(Object partitionKey, ConcurrentLinkedQueue<IdleChannel> partition) {
+    private void flushPartition(Object partitionKey, ConcurrentLinkedDeque<IdleChannel> partition) {
         if (partition != null) {
             partitions.remove(partitionKey);
             for (IdleChannel idleChannel : partition)
@@ -342,7 +348,7 @@ public void flushPartition(Object partitionKey) {
     @Override
     public void flushPartitions(ChannelPoolPartitionSelector selector) {
 
-        for (Map.Entry<Object, ConcurrentLinkedQueue<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+        for (Map.Entry<Object, ConcurrentLinkedDeque<IdleChannel>> partitionsEntry : partitions.entrySet()) {
             Object partitionKey = partitionsEntry.getKey();
             if (selector.select(partitionKey))
                 flushPartition(partitionKey, partitionsEntry.getValue());
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 54c9f30dc..e2292fcf0 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -13,6 +13,7 @@
 package org.asynchttpclient.netty.request;
 
 import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -24,8 +25,10 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.SimpleChannelFutureListener;
+import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.channel.NettyConnectListener;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 
@@ -36,15 +39,21 @@
     private final List<InetSocketAddress> remoteAddresses;
     private final TimeoutsHolder timeoutsHolder;
     private final AtomicBoolean closed;
+    private final boolean connectionTtlEnabled;
     private volatile int i = 0;
 
-    public NettyChannelConnector(InetAddress localAddress, List<InetSocketAddress> remoteAddresses, AsyncHandler<?> asyncHandler, TimeoutsHolder timeoutsHolder,
-            AtomicBoolean closed) {
+    public NettyChannelConnector(InetAddress localAddress,//
+            List<InetSocketAddress> remoteAddresses,//
+            AsyncHandler<?> asyncHandler,//
+            TimeoutsHolder timeoutsHolder,//
+            AtomicBoolean closed,//
+            AsyncHttpClientConfig config) {
         this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
         this.remoteAddresses = remoteAddresses;
         this.asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
-        this.timeoutsHolder = timeoutsHolder;
+        this.timeoutsHolder = assertNotNull(timeoutsHolder, "timeoutsHolder");
         this.closed = closed;
+        this.connectionTtlEnabled = config.getConnectionTtl() > 0;
     }
 
     private boolean pickNextRemoteAddress() {
@@ -80,6 +89,9 @@ public void onSuccess(Channel channel) {
                     asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, future.channel());
                 }
                 timeoutsHolder.initRemoteAddress(remoteAddress);
+                if (connectionTtlEnabled) {
+                    Channels.initChannelId(channel);
+                }
                 connectListener.onSuccess(channel);
             }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 0c3d2068a..6cbb9ee98 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -277,7 +277,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
                     @Override
                     protected void onSuccess(List<InetSocketAddress> addresses) {
                         NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, channelPreempted, partitionKey);
-                        new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, future.getTimeoutsHolder(), closed).connect(bootstrap, connectListener);
+                        new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, future.getTimeoutsHolder(), closed, config).connect(bootstrap, connectListener);
                     }
 
                     @Override
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index 72acdfb01..a0d53b048 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -32,8 +32,7 @@
     private boolean endOfInput;
 
     public BodyChunkedInput(Body body) {
-        assertNotNull(body, "body");
-        this.body = body;
+        this.body = assertNotNull(body, "body");
         long contentLength = body.getContentLength();
         if (contentLength <= 0)
             chunkSize = DEFAULT_CHUNK_SIZE;
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
index 792d96f23..9629cd1e9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -33,8 +33,7 @@
     private long transfered;
 
     public BodyFileRegion(RandomAccessBody body) {
-        assertNotNull(body, "body");
-        this.body = body;
+        this.body = assertNotNull(body, "body");
     }
 
     @Override
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
index 841f10c89..55db64295 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
@@ -32,8 +32,7 @@ public FileBodyGenerator(File file) {
     }
 
     public FileBodyGenerator(File file, long regionSeek, long regionLength) {
-        assertNotNull(file, "file");
-        this.file = file;
+        this.file = assertNotNull(file, "file");
         this.regionLength = regionLength;
         this.regionSeek = regionSeek;
     }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
index 0841ae119..ab25827c9 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
@@ -42,8 +42,7 @@ public ByteArrayPart(String name, byte[] bytes, String contentType, Charset char
 
     public ByteArrayPart(String name, byte[] bytes, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
         super(name, contentType, charset, contentId, transferEncoding);
-        assertNotNull(bytes, "bytes");
-        this.bytes = bytes;
+        this.bytes = assertNotNull(bytes, "bytes");
         setFileName(fileName);
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
index 248fc5076..6808ff348 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
@@ -43,8 +43,7 @@ public FilePart(String name, File file, String contentType, Charset charset, Str
 
     public FilePart(String name, File file, String contentType, Charset charset, String fileName, String contentId, String transferEncoding) {
         super(name, contentType, charset, contentId, transferEncoding);
-        assertNotNull(file, "file");
-        if (!file.isFile())
+        if (!assertNotNull(file, "file").isFile())
             throw new IllegalArgumentException("File is not a normal file " + file.getAbsolutePath());
         if (!file.canRead())
             throw new IllegalArgumentException("File is not readable " + file.getAbsolutePath());
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
index d38915ed2..16f590d06 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
@@ -42,10 +42,9 @@
     private AtomicBoolean closed = new AtomicBoolean();
 
     public MultipartBody(List<MultipartPart<? extends Part>> parts, String contentType, byte[] boundary) {
-        assertNotNull(parts, "parts");
         this.boundary = boundary;
         this.contentType = contentType;
-        this.parts = parts;
+        this.parts = assertNotNull(parts, "parts");
         this.contentLength = computeContentLength();
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/uri/Uri.java b/client/src/main/java/org/asynchttpclient/uri/Uri.java
index 99895ee75..0735950f2 100644
--- a/client/src/main/java/org/asynchttpclient/uri/Uri.java
+++ b/client/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -60,11 +60,9 @@ public Uri(String scheme,//
             String path,//
             String query) {
 
-        assertNotNull(scheme, "scheme");
-        assertNotNull(host, "host");
-        this.scheme = scheme;
+        this.scheme = assertNotNull(scheme, "scheme");
         this.userInfo = userInfo;
-        this.host = host;
+        this.host = assertNotNull(host, "host");
         this.port = port;
         this.path = path;
         this.query = query;
diff --git a/client/src/main/java/org/asynchttpclient/util/Assertions.java b/client/src/main/java/org/asynchttpclient/util/Assertions.java
index f00cb3fa0..540e0cf2e 100644
--- a/client/src/main/java/org/asynchttpclient/util/Assertions.java
+++ b/client/src/main/java/org/asynchttpclient/util/Assertions.java
@@ -18,13 +18,16 @@
     private Assertions() {
     }
 
-    public static void assertNotNull(Object value, String name) {
+    public static <T> T assertNotNull(T value, String name) {
         if (value == null)
             throw new NullPointerException(name);
+        return value;
+
     }
 
-    public static void assertNotEmpty(String value, String name) {
+    public static String assertNotEmpty(String value, String name) {
         if (value.length() == 0)
             throw new IllegalArgumentException("empty " + name);
+        return value;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
index 8b596003d..5953dcb56 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
@@ -95,8 +95,7 @@ public final WebSocket onCompleted() throws Exception {
             throw e;
         }
 
-        assertNotNull(webSocket, "webSocket");
-        return webSocket;
+        return assertNotNull(webSocket, "webSocket");
     }
 
     /**
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/ahc-default.properties
index ee526d80b..d5ebbceca 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/ahc-default.properties
@@ -16,7 +16,6 @@ org.asynchttpclient.useProxyProperties=false
 org.asynchttpclient.validateResponseHeaders=true
 org.asynchttpclient.strict302Handling=false
 org.asynchttpclient.keepAlive=true
-org.asynchttpclient.requestCompressionLevel=-1
 org.asynchttpclient.maxRequestRetry=5
 org.asynchttpclient.disableUrlEncodingForBoundRequests=false
 org.asynchttpclient.removeQueryParamOnRedirect=true
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 864314ec4..18f11c695 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.0-RC9-SNAPSHOT</version>
+        <version>2.0.0-RC10-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index f5a7eab24..6b08d1c38 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.0.0-RC9-SNAPSHOT</version>
+    <version>2.0.0-RC10-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index da78fa596..337a97fd2 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.0.0-RC9-SNAPSHOT</version>
+        <version>2.0.0-RC10-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 59899814e..e4dda9ff5 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.0.0-RC9-SNAPSHOT</version>
+		<version>2.0.0-RC10-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index b8181cfac..ea9cac18e 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-RC9-SNAPSHOT</version>
+        <version>2.0.0-RC10-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index ff872a556..387ae19bd 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-RC9-SNAPSHOT</version>
+        <version>2.0.0-RC10-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/netty-bp/codec-dns/pom.xml b/netty-bp/codec-dns/pom.xml
index 3c5a3c50f..4134f10cd 100644
--- a/netty-bp/codec-dns/pom.xml
+++ b/netty-bp/codec-dns/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.0-RC9-SNAPSHOT</version>
+    <version>2.0.0-RC10-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-codec-dns</artifactId>
diff --git a/netty-bp/pom.xml b/netty-bp/pom.xml
index d3c5833f7..516d1c17d 100644
--- a/netty-bp/pom.xml
+++ b/netty-bp/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.0-RC9-SNAPSHOT</version>
+		<version>2.0.0-RC10-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>netty-bp</artifactId>
diff --git a/netty-bp/resolver-dns/pom.xml b/netty-bp/resolver-dns/pom.xml
index e45cdf8fe..1650aba7d 100644
--- a/netty-bp/resolver-dns/pom.xml
+++ b/netty-bp/resolver-dns/pom.xml
@@ -9,7 +9,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>netty-bp</artifactId>
-		<version>2.0.0-RC9-SNAPSHOT</version>
+		<version>2.0.0-RC10-SNAPSHOT</version>
 	</parent>
 
 	<artifactId>netty-resolver-dns</artifactId>
diff --git a/netty-bp/resolver/pom.xml b/netty-bp/resolver/pom.xml
index 9c7f0c2ba..b50d3e163 100644
--- a/netty-bp/resolver/pom.xml
+++ b/netty-bp/resolver/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.0-RC9-SNAPSHOT</version>
+    <version>2.0.0-RC10-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-resolver</artifactId>
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
index 89b00dfa0..509475eb3 100644
--- a/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
@@ -73,7 +73,9 @@ protected AddressResolverGroup() { }
                 executor.terminationFuture().addListener(new FutureListener<Object>() {
                     @Override
                     public void operationComplete(Future<Object> future) throws Exception {
-                        resolvers.remove(executor);
+                        synchronized (resolvers) {
+                            resolvers.remove(executor);
+                        }
                         newResolver.close();
                     }
                 });
diff --git a/pom.xml b/pom.xml
index 87ee9d29a..8fc7a22a6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.0.0-RC9-SNAPSHOT</version>
+	<version>2.0.0-RC10-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -412,7 +412,7 @@
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
 		<netty.version>4.0.34.Final</netty.version>
-		<slf4j.version>1.7.14</slf4j.version>
+		<slf4j.version>1.7.15</slf4j.version>
 		<logback.version>1.1.3</logback.version>
 		<log4j.version>1.2.17</log4j.version>
 		<testng.version>6.9.9</testng.version>
