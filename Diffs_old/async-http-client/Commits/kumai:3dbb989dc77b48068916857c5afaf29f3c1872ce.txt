diff --git a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
index 89a8c11e7..af983e4ce 100644
--- a/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
+++ b/src/main/java/com/ning/http/client/providers/netty/NettyAsyncHttpProvider.java
@@ -123,6 +123,7 @@
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -2243,10 +2244,8 @@ public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
         private static final byte OPCODE_TEXT = 0x1;
         private static final byte OPCODE_BINARY = 0x2;
         private static final byte OPCODE_UNKNOWN = -1;
-
-        protected ChannelBuffer byteBuffer = null;
-        protected StringBuilder textBuffer = null;
         protected byte pendingOpcode = OPCODE_UNKNOWN;
+        private final CountDownLatch onSuccessLatch = new CountDownLatch(1);
 
         // @Override
         public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
@@ -2311,12 +2310,27 @@ public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
                 }
 
                 ctx.getPipeline().replace("http-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
+                ctx.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder", new WebSocket08FrameDecoder(false, false));
                 if (h.onHeadersReceived(responseHeaders) == STATE.CONTINUE) {
-                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
+                    try {
+                        h.onSuccess(new NettyWebSocket(ctx.getChannel()));
+                    } catch (Exception ex) {
+                        NettyAsyncHttpProvider.this.log.warn("onSuccess unexexpected exception", ex);
+                    } finally {
+                        /**
+                         * A websocket message may always be included with the handshake response. As soon as we replace
+                         * the ws-decoder, this class can be called and we are still inside the onSuccess processing
+                         * causing invalid state.
+                         */
+                        onSuccessLatch.countDown();
+                    }
                 }
-                ctx.getPipeline().get(HttpResponseDecoder.class).replace("ws-decoder", new WebSocket08FrameDecoder(false, false));
                 future.done(null);
             } else if (e.getMessage() instanceof WebSocketFrame) {
+
+                // Give a chance to the onSuccess to complete before processing message.
+                onSuccessLatch.await();
+
                 final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
 
                 if (frame instanceof TextWebSocketFrame) {
