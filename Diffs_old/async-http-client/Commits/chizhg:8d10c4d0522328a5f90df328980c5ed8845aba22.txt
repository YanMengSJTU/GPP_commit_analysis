diff --git a/LICENSE-2.0.txt b/LICENSE-2.0.txt
deleted file mode 100644
index d64569567..000000000
--- a/LICENSE-2.0.txt
+++ /dev/null
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 000000000..41caa5b6f
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,13 @@
+Copyright 2014-2016 AsyncHttpClient Project
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/README.md b/README.md
index cbd817f13..b42149517 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@ Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on tw
 The Async Http Client library's purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
 The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
 
-I's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
+It's built on top of [Netty](https://github.com/netty/netty) and currently requires JDK8.
 
 Latest `version`: [![Maven][mavenImg]][mavenLink]
 
diff --git a/client/pom.xml b/client/pom.xml
index 19bf7d27e..1b0f7bd32 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.12-SNAPSHOT</version>
+		<version>2.0.16-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
@@ -25,6 +25,11 @@
 	</build>
 
 	<dependencies>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>async-http-client-netty-utils</artifactId>
+			<version>${project.version}</version>
+		</dependency>
 		<dependency>
 			<groupId>io.netty</groupId>
 			<artifactId>netty-codec-http</artifactId>
@@ -47,7 +52,7 @@
 		<dependency>
 			<groupId>com.typesafe.netty</groupId>
 			<artifactId>netty-reactive-streams</artifactId>
-			<version>1.0.6</version>
+			<version>1.0.7</version>
 		</dependency>
 		<dependency>
 			<groupId>org.javassist</groupId>
diff --git a/client/src/main/java/io/netty/util/internal/MacAddressUtil.java b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
index 858368d6d..7c68bf5cc 100644
--- a/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
+++ b/client/src/main/java/io/netty/util/internal/MacAddressUtil.java
@@ -53,7 +53,7 @@
         InetAddress bestInetAddr = NetUtil.LOCALHOST4;
 
         // Retrieve the list of available network interfaces.
-        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();
+        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<>();
         try {
             for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {
                 NetworkInterface iface = i.nextElement();
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 246fdea21..897b6e25e 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -17,6 +17,7 @@
 package org.asynchttpclient;
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import io.netty.channel.EventLoopGroup;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
 
@@ -247,6 +248,10 @@ public ChannelPool getChannelPool() {
         return channelManager.getChannelPool();
     }
 
+    public EventLoopGroup getEventLoopGroup() {
+        return channelManager.getEventLoopGroup();
+    }
+
     protected BoundRequestBuilder requestBuilder(String method, String url) {
         return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
     }
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 51ca60511..a888ed96c 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -800,13 +800,12 @@ public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
         }
 
         public Builder setProxyServer(ProxyServer proxyServer) {
-            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
+            this.proxyServerSelector = uri -> proxyServer;
             return this;
         }
 
         public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
-            this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServerBuilder.build());
-            return this;
+            return setProxyServer(proxyServerBuilder.build());
         }
 
         public Builder setUseProxySelector(boolean useProxySelector) {
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index 5fca54eb5..6c5e5f775 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -60,7 +60,7 @@
 
     public enum AuthScheme {
 
-        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS;
+        BASIC, DIGEST, NTLM, SPNEGO, KERBEROS
     }
 
     private Realm(AuthScheme scheme,//
@@ -475,9 +475,9 @@ private void newResponse(MessageDigest md) {
 
         private static String toHexString(byte[] data) {
             StringBuilder buffer = StringUtils.stringBuilder();
-            for (int i = 0; i < data.length; i++) {
-                buffer.append(Integer.toHexString((data[i] & 0xf0) >>> 4));
-                buffer.append(Integer.toHexString(data[i] & 0x0f));
+            for (byte aData : data) {
+                buffer.append(Integer.toHexString((aData & 0xf0) >>> 4));
+                buffer.append(Integer.toHexString(aData & 0x0f));
             }
             return buffer.toString();
         }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index b2f3c5ea1..314986a19 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -33,7 +33,7 @@ public static void reloadProperties() {
         public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
         public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
 
-        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<String, String>();
+        private final ConcurrentHashMap<String, String> propsCache = new ConcurrentHashMap<>();
         private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES);
         private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES);
 
@@ -65,9 +65,9 @@ public String getString(String key) {
             return propsCache.computeIfAbsent(key, k -> {
                 String value = System.getProperty(k);
                 if (value == null)
-                    value = (String) customProperties.getProperty(k);
+                    value = customProperties.getProperty(k);
                 if (value == null)
-                    value = (String) defaultProperties.getProperty(k);
+                    value = defaultProperties.getProperty(k);
                 return value;
             });
         }
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
index 74896bca5..01bc6caf1 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -63,8 +63,7 @@ public static String encode(Collection<Cookie> cookies) {
         } else {
             Cookie[] cookiesSorted = cookies.toArray(new Cookie[cookies.size()]);
             Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);
-            for (int i = 0; i < cookiesSorted.length; i++) {
-                Cookie cookie = cookiesSorted[i];
+            for (Cookie cookie : cookiesSorted) {
                 if (cookie != null) {
                     add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
                 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index f8020d260..49450e12f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,7 +12,7 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.util.ByteBufUtils.byteBuf2Bytes;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index 02159fb85..61a1aea83 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -17,7 +17,7 @@
 import java.nio.ByteBuffer;
 
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.util.ByteBufUtils;
+import org.asynchttpclient.netty.util.ByteBufUtils;
 
 /**
  * A callback class used when an HTTP response body is received.
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 277a87150..033b05659 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -487,4 +487,8 @@ public void drainChannelAndOffer(final Channel channel, final NettyResponseFutur
     public ChannelPool getChannelPool() {
         return channelPool;
     }
+
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 6a340f650..878db3a29 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -78,7 +78,7 @@ public DefaultChannelPool(int maxIdleTime,//
             PoolLeaseStrategy poolLeaseStrategy,//
             Timer nettyTimer,//
             int cleanerPeriod) {
-        this.maxIdleTime = (int) maxIdleTime;
+        this.maxIdleTime = maxIdleTime;
         this.connectionTtl = connectionTtl;
         connectionTtlEnabled = connectionTtl > 0;
         channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;
@@ -165,7 +165,7 @@ private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
             return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
         }
 
-        private final List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+        private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
 
             // lazy create, only if we hit a non-closeable channel
             List<IdleChannel> closedChannels = null;
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index ca00f7a4e..95aa5b17f 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -79,11 +79,12 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
 
             } else if (attribute instanceof NettyResponseFuture) {
                 NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.touch();
                 handleRead(channel, future, msg);
 
             } else if (attribute instanceof StreamedResponsePublisher) {
-
                 StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
+                publisher.future().touch();
 
                 if (msg instanceof HttpContent) {
                     ByteBuf content = ((HttpContent) msg).content();
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index 1cfe1ca79..03059f557 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -162,8 +162,6 @@ private void handleChunk(HttpContent chunk,//
     @Override
     public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
 
-        future.touch();
-
         // future is already done because of an exception or a timeout
         if (future.isDone()) {
             // FIXME isn't the channel already properly closed?
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 8c82a90fc..a1418800c 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -15,7 +15,6 @@
 
 import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
 import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -33,7 +32,6 @@
 
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.netty.Callback;
@@ -77,7 +75,7 @@ public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpRespo
         private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
             if (!h.touchSuccess()) {
                 try {
-                    h.onSuccess(new NettyWebSocket(channel, responseHeaders.getHeaders(), config));
+                    h.onSuccess(new NettyWebSocket(channel, responseHeaders.getHeaders()));
                 } catch (Exception ex) {
                     logger.warn("onSuccess unexpected exception", ex);
                 }
@@ -168,7 +166,7 @@ public void run() {
                         } finally {
                             frame.release();
                         }
-                    };
+                    }
                 };
                 handler.bufferFrame(bufferedFrame);
             }
@@ -178,27 +176,23 @@ public void run() {
     }
 
     private void handleFrame(Channel channel, WebSocketFrame frame, WebSocketUpgradeHandler handler, NettyWebSocket webSocket) throws Exception {
-        if (frame instanceof CloseWebSocketFrame) {
+        if (frame instanceof TextWebSocketFrame) {
+            webSocket.onTextFrame((TextWebSocketFrame) frame);
+
+        } else if (frame instanceof BinaryWebSocketFrame) {
+            webSocket.onBinaryFrame((BinaryWebSocketFrame) frame);
+
+        } else if (frame instanceof CloseWebSocketFrame) {
             Channels.setDiscard(channel);
             CloseWebSocketFrame closeFrame = (CloseWebSocketFrame) frame;
             webSocket.onClose(closeFrame.statusCode(), closeFrame.reasonText());
             Channels.silentlyCloseChannel(channel);
-        } else {
-            ByteBuf buf = frame.content();
-            if (buf != null && buf.readableBytes() > 0) {
-                HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
-                handler.onBodyPartReceived(part);
-
-                if (frame instanceof BinaryWebSocketFrame) {
-                    webSocket.onBinaryFragment(part);
-                } else if (frame instanceof TextWebSocketFrame) {
-                    webSocket.onTextFragment(part);
-                } else if (frame instanceof PingWebSocketFrame) {
-                    webSocket.onPing(part);
-                } else if (frame instanceof PongWebSocketFrame) {
-                    webSocket.onPong(part);
-                }
-            }
+
+        } else if (frame instanceof PingWebSocketFrame) {
+            webSocket.onPing((PingWebSocketFrame) frame);
+
+        } else if (frame instanceof PongWebSocketFrame) {
+            webSocket.onPong((PongWebSocketFrame) frame);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 581d2b85a..3a47562e0 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -15,7 +15,6 @@
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelProgressiveFuture;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedWriteHandler;
@@ -83,13 +82,13 @@ public void onError(Throwable t) {
             }
         }
 
-        ChannelFuture writeFuture = channel.write(msg, channel.newProgressivePromise());
-        writeFuture.addListener(new WriteProgressListener(future, false, getContentLength()) {
-            public void operationComplete(ChannelProgressiveFuture cf) {
-                closeSilently(body);
-                super.operationComplete(cf);
-            }
-        });
+        channel.write(msg, channel.newProgressivePromise())//
+                .addListener(new WriteProgressListener(future, false, getContentLength()) {
+                    public void operationComplete(ChannelProgressiveFuture cf) {
+                        closeSilently(body);
+                        super.operationComplete(cf);
+                    }
+                });
         channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, channel.voidPromise());
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 7f3aae98a..0bd249049 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -27,7 +27,7 @@ public ReadTimeoutTimerTask(//
             NettyResponseFuture<?> nettyResponseFuture,//
             NettyRequestSender requestSender,//
             TimeoutsHolder timeoutsHolder,//
-            long readTimeout) {
+            int readTimeout) {
         super(nettyResponseFuture, requestSender, timeoutsHolder);
         this.readTimeout = readTimeout;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index 2546b6914..d108deea4 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -27,7 +27,7 @@ public RequestTimeoutTimerTask(//
             NettyResponseFuture<?> nettyResponseFuture,//
             NettyRequestSender requestSender,//
             TimeoutsHolder timeoutsHolder,//
-            long requestTimeout) {
+            int requestTimeout) {
         super(nettyResponseFuture, requestSender, timeoutsHolder);
         this.requestTimeout = requestTimeout;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index 66a1a9077..c2903056a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -15,6 +15,7 @@
 
 import static io.netty.buffer.Unpooled.wrappedBuffer;
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
@@ -23,24 +24,18 @@
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.net.SocketAddress;
-import java.util.ArrayList;
+import java.nio.charset.CharacterCodingException;
 import java.util.Collection;
-import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.netty.util.ByteBufUtils;
 import org.asynchttpclient.ws.WebSocket;
-import org.asynchttpclient.ws.WebSocketByteFragmentListener;
 import org.asynchttpclient.ws.WebSocketByteListener;
 import org.asynchttpclient.ws.WebSocketCloseCodeReasonListener;
 import org.asynchttpclient.ws.WebSocketListener;
 import org.asynchttpclient.ws.WebSocketPingListener;
 import org.asynchttpclient.ws.WebSocketPongListener;
-import org.asynchttpclient.ws.WebSocketTextFragmentListener;
 import org.asynchttpclient.ws.WebSocketTextListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -52,21 +47,17 @@
     protected final Channel channel;
     protected final HttpHeaders upgradeHeaders;
     protected final Collection<WebSocketListener> listeners;
-    protected final int maxBufferSize;
-    private int bufferSize;
-    private List<byte[]> _fragments;
     private volatile boolean interestedInByteMessages;
     private volatile boolean interestedInTextMessages;
 
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, AsyncHttpClientConfig config) {
-        this(channel, upgradeHeaders, config, new ConcurrentLinkedQueue<WebSocketListener>());
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders) {
+        this(channel, upgradeHeaders, new ConcurrentLinkedQueue<>());
     }
 
-    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, AsyncHttpClientConfig config, Collection<WebSocketListener> listeners) {
+    public NettyWebSocket(Channel channel, HttpHeaders upgradeHeaders, Collection<WebSocketListener> listeners) {
         this.channel = channel;
         this.upgradeHeaders = upgradeHeaders;
         this.listeners = listeners;
-        maxBufferSize = config.getWebSocketMaxBufferSize();
     }
 
     @Override
@@ -207,28 +198,6 @@ public WebSocket removeWebSocketListener(WebSocketListener l) {
         return this;
     }
 
-    private List<byte[]> fragments() {
-        if (_fragments == null)
-            _fragments = new ArrayList<>(2);
-        return _fragments;
-    }
-
-    private void bufferFragment(byte[] buffer) {
-        bufferSize += buffer.length;
-        if (bufferSize > maxBufferSize) {
-            onError(new Exception("Exceeded Netty Web Socket maximum buffer size of " + maxBufferSize));
-            reset();
-            close();
-        } else {
-            fragments().add(buffer);
-        }
-    }
-
-    private void reset() {
-        fragments().clear();
-        bufferSize = 0;
-    }
-
     private void notifyByteListeners(byte[] message) {
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketByteListener)
@@ -236,89 +205,42 @@ private void notifyByteListeners(byte[] message) {
         }
     }
 
-    private void notifyTextListeners(byte[] bytes) {
-        String message = new String(bytes, UTF_8);
+    private void notifyTextListeners(String message) {
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketTextListener)
                 WebSocketTextListener.class.cast(listener).onMessage(message);
         }
     }
 
-    public void onBinaryFragment(HttpResponseBodyPart part) {
-
-        for (WebSocketListener listener : listeners) {
-            if (listener instanceof WebSocketByteFragmentListener)
-                WebSocketByteFragmentListener.class.cast(listener).onFragment(part);
-        }
-
+    public void onBinaryFrame(BinaryWebSocketFrame frame) {
         if (interestedInByteMessages) {
-            byte[] fragment = part.getBodyPartBytes();
-
-            if (part.isLast()) {
-                if (bufferSize == 0) {
-                    notifyByteListeners(fragment);
-
-                } else {
-                    bufferFragment(fragment);
-                    notifyByteListeners(fragmentsBytes());
-                }
-
-                reset();
-
-            } else
-                bufferFragment(fragment);
+            notifyByteListeners(byteBuf2Bytes(frame.content()));
         }
     }
 
-    private byte[] fragmentsBytes() {
-        ByteArrayOutputStream os = new ByteArrayOutputStream(bufferSize);
-        for (byte[] bytes : _fragments)
+    public void onTextFrame(TextWebSocketFrame frame) {
+        if (interestedInTextMessages) {
             try {
-                os.write(bytes);
-            } catch (IOException e) {
-                // yeah, right
+                notifyTextListeners(ByteBufUtils.byteBuf2String(UTF_8, frame.content()));
+            } catch (CharacterCodingException e) {
+                throw new IllegalStateException(e);
             }
-        return os.toByteArray();
-    }
-
-    public void onTextFragment(HttpResponseBodyPart part) {
-        for (WebSocketListener listener : listeners) {
-            if (listener instanceof WebSocketTextFragmentListener)
-                WebSocketTextFragmentListener.class.cast(listener).onFragment(part);
-        }
-
-        if (interestedInTextMessages) {
-            byte[] fragment = part.getBodyPartBytes();
-
-            if (part.isLast()) {
-                if (bufferSize == 0) {
-                    notifyTextListeners(fragment);
-
-                } else {
-                    bufferFragment(fragment);
-                    notifyTextListeners(fragmentsBytes());
-                }
-
-                reset();
-
-            } else
-                bufferFragment(fragment);
         }
     }
 
-    public void onPing(HttpResponseBodyPart part) {
+    public void onPing(PingWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketPingListener)
-                // bytes are cached in the part
-                WebSocketPingListener.class.cast(listener).onPing(part.getBodyPartBytes());
+                WebSocketPingListener.class.cast(listener).onPing(bytes);
         }
     }
 
-    public void onPong(HttpResponseBodyPart part) {
+    public void onPong(PongWebSocketFrame frame) {
+        byte[] bytes = byteBuf2Bytes(frame.content());
         for (WebSocketListener listener : listeners) {
             if (listener instanceof WebSocketPongListener)
-                // bytes are cached in the part
-                WebSocketPongListener.class.cast(listener).onPong(part.getBodyPartBytes());
+                WebSocketPongListener.class.cast(listener).onPong(bytes);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index d9926534c..62e5a5393 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -127,7 +127,7 @@ public Builder setRealm(Realm.Builder realm) {
 
         public Builder setNonProxyHost(String nonProxyHost) {
             if (nonProxyHosts == null)
-                nonProxyHosts = new ArrayList<String>(1);
+                nonProxyHosts = new ArrayList<>(1);
             nonProxyHosts.add(nonProxyHost);
             return this;
         }
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
index dc93a979c..359878b48 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
@@ -18,10 +18,5 @@
     /**
      * A selector that always selects no proxy.
      */
-    ProxyServerSelector NO_PROXY_SELECTOR = new ProxyServerSelector() {
-        @Override
-        public ProxyServer select(Uri uri) {
-            return null;
-        }
-    };
+    ProxyServerSelector NO_PROXY_SELECTOR = uri -> null;
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/Body.java b/client/src/main/java/org/asynchttpclient/request/body/Body.java
index b31185a52..66a588739 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/Body.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -38,7 +38,7 @@
         /**
          * There's nothing to read and input has to stop
          */
-        STOP;
+        STOP
     }
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index 2c3ad83a5..6ca56cba2 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -73,7 +73,7 @@ public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders reque
     }
 
     public static List<MultipartPart<? extends Part>> generateMultipartParts(List<Part> parts, byte[] boundary) {
-        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<MultipartPart<? extends Part>>(parts.size());
+        List<MultipartPart<? extends Part>> multipartParts = new ArrayList<>(parts.size());
         for (Part part : parts) {
             if (part instanceof FilePart) {
                 multipartParts.add(new FileMultipartPart((FilePart) part, boundary));
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index b5db7a06c..ba487476c 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -113,7 +113,7 @@ public void setDispositionType(String dispositionType) {
 
     public void addCustomHeader(String name, String value) {
         if (customHeaders == null) {
-            customHeaders = new ArrayList<Param>(2);
+            customHeaders = new ArrayList<>(2);
         }
         customHeaders.add(new Param(name, value));
     }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
index 4584dc64b..8f9d61081 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -205,7 +205,7 @@ protected long transfer(ByteBuf source, WritableByteChannel target, MultipartSta
 
         int transferred = 0;
         if (target instanceof GatheringByteChannel) {
-            transferred = source.readBytes((GatheringByteChannel) target, (int) source.readableBytes());
+            transferred = source.readBytes((GatheringByteChannel) target, source.readableBytes());
         } else {
             for (ByteBuffer byteBuffer : source.nioBuffers()) {
                 int len = byteBuffer.remaining();
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
index df7b96950..6a44deac1 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartState.java
@@ -21,5 +21,5 @@
 
     POST_CONTENT,
 
-    DONE;
+    DONE
 }
diff --git a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index 205bc4bbe..53d97051a 100644
--- a/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
+++ b/client/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -81,7 +81,7 @@ public static SpnegoEngine instance() {
     public String generateToken(String server) throws SpnegoEngineException {
         GSSContext gssContext = null;
         byte[] token = null; // base64 decoded challenge
-        Oid negotiationOid = null;
+        Oid negotiationOid;
 
         try {
             log.debug("init {}", server);
@@ -152,7 +152,7 @@ public String generateToken(String server) throws SpnegoEngineException {
 
             gssContext.dispose();
 
-            String tokenstr = new String(Base64.encode(token));
+            String tokenstr = Base64.encode(token);
             log.debug("Sending response '{}' back to the server", tokenstr);
 
             return tokenstr;
diff --git a/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
deleted file mode 100755
index 3ebebc85f..000000000
--- a/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import io.netty.buffer.ByteBuf;
-
-import java.io.UTFDataFormatException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.CharacterCodingException;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.StandardCharsets;
-import java.util.List;
-
-public final class ByteBufUtils {
-
-    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-
-    private ByteBufUtils() {
-    }
-
-    public static String byteBuf2String(ByteBuf buf, Charset charset) throws UTFDataFormatException, IndexOutOfBoundsException, CharacterCodingException {
-
-        int byteLen = buf.readableBytes();
-
-        if (charset.equals(StandardCharsets.US_ASCII)) {
-            return Utf8Reader.readUtf8(buf, byteLen);
-        } else if (charset.equals(StandardCharsets.UTF_8)) {
-            try {
-                return Utf8Reader.readUtf8(buf.duplicate(), (int) (byteLen * 1.4));
-            } catch (IndexOutOfBoundsException e) {
-                // try again with 3 bytes per char
-                return Utf8Reader.readUtf8(buf, byteLen * 3);
-            }
-        } else {
-            return byteBuffersToString(buf.nioBuffers(), charset);
-        }
-    }
-
-    private static String byteBuffersToString(ByteBuffer[] bufs, Charset cs) throws CharacterCodingException {
-
-        CharsetDecoder cd = cs.newDecoder();
-        int len = 0;
-        for (ByteBuffer buf : bufs) {
-            len += buf.remaining();
-        }
-        int en = (int) (len * (double) cd.maxCharsPerByte());
-        char[] ca = new char[en];
-        cd.reset();
-        CharBuffer cb = CharBuffer.wrap(ca);
-
-        CoderResult cr = null;
-
-        for (int i = 0; i < bufs.length; i++) {
-
-            ByteBuffer buf = bufs[i];
-            cr = cd.decode(buf, cb, i < bufs.length - 1);
-            if (!cr.isUnderflow())
-                cr.throwException();
-        }
-
-        cr = cd.flush(cb);
-        if (!cr.isUnderflow())
-            cr.throwException();
-
-        return new String(ca, 0, cb.position());
-    }
-
-    public static byte[] byteBuf2Bytes(ByteBuf buf) {
-        int readable = buf.readableBytes();
-        int readerIndex = buf.readerIndex();
-        if (buf.hasArray()) {
-            byte[] array = buf.array();
-            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-                return array;
-            }
-        }
-        byte[] array = new byte[readable];
-        buf.getBytes(readerIndex, array);
-        return array;
-    }
-
-    public static byte[] byteBufs2Bytes(List<ByteBuf> bufs) {
-
-        if (bufs.isEmpty()) {
-            return EMPTY_BYTE_ARRAY;
-
-        } else if (bufs.size() == 1) {
-            return byteBuf2Bytes(bufs.get(0));
-
-        } else {
-            int totalSize = 0;
-            for (ByteBuf buf : bufs) {
-                totalSize += buf.readableBytes();
-            }
-
-            byte[] bytes = new byte[totalSize];
-            int offset = 0;
-            for (ByteBuf buf : bufs) {
-                int readable = buf.readableBytes();
-                buf.getBytes(buf.readerIndex(), bytes, offset, readable);
-                offset += readable;
-            }
-            return bytes;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index 254453b6e..edde95850 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -31,23 +31,23 @@
 
     public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
-    public static final void validateSupportedScheme(Uri uri) {
+    public static void validateSupportedScheme(Uri uri) {
         final String scheme = uri.getScheme();
         if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
             throw new IllegalArgumentException("The URI scheme, of the URI " + uri + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
         }
     }
 
-    public final static String getBaseUrl(Uri uri) {
+    public static String getBaseUrl(Uri uri) {
         // getAuthority duplicate but we don't want to re-concatenate
         return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
     }
 
-    public final static String getAuthority(Uri uri) {
+    public static String getAuthority(Uri uri) {
         return uri.getHost() + ":" + uri.getExplicitPort();
     }
 
-    public final static boolean isSameBase(Uri uri1, Uri uri2) {
+    public static boolean isSameBase(Uri uri1, Uri uri2) {
         return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost()) && uri1.getExplicitPort() == uri2.getExplicitPort();
     }
 
@@ -55,7 +55,7 @@ public final static boolean isSameBase(Uri uri1, Uri uri2) {
      * @param uri the uri
      * @return the raw path or "/" if it's null
      */
-    public final static String getNonEmptyPath(Uri uri) {
+    public static String getNonEmptyPath(Uri uri) {
         return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
     }
 
@@ -79,7 +79,7 @@ public static Charset parseCharset(String contentType) {
     }
 
     public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
-        return request.getFollowRedirect() != null ? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
+        return request.getFollowRedirect() != null ? request.getFollowRedirect() : config.isFollowRedirect();
     }
 
     private static StringBuilder urlEncodeFormParams0(List<Param> params) {
diff --git a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 1d61e2815..569c8e649 100644
--- a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -40,7 +40,7 @@
  */
 public final class ProxyUtils {
 
-    private final static Logger log = LoggerFactory.getLogger(ProxyUtils.class);
+    private final static Logger logger = LoggerFactory.getLogger(ProxyUtils.class);
 
     /**
      * The host to use as proxy.
@@ -120,10 +120,11 @@ public static ProxyServerSelector createProxyServerSelector(Properties propertie
 
             String nonProxyHosts = properties.getProperty(PROXY_NONPROXYHOSTS);
             if (nonProxyHosts != null) {
-                proxyServer.setNonProxyHosts(new ArrayList<String>(Arrays.asList(nonProxyHosts.split("\\|"))));
+                proxyServer.setNonProxyHosts(new ArrayList<>(Arrays.asList(nonProxyHosts.split("\\|"))));
             }
 
-            return createProxyServerSelector(proxyServer.build());
+            ProxyServer proxy = proxyServer.build();
+            return uri -> proxy;
         }
 
         return ProxyServerSelector.NO_PROXY_SELECTOR;
@@ -157,7 +158,7 @@ public ProxyServer select(Uri uri) {
                             switch (proxy.type()) {
                             case HTTP:
                                 if (!(proxy.address() instanceof InetSocketAddress)) {
-                                    log.warn("Don't know how to connect to address " + proxy.address());
+                                    logger.warn("Don't know how to connect to address " + proxy.address());
                                     return null;
                                 } else {
                                     InetSocketAddress address = (InetSocketAddress) proxy.address();
@@ -166,31 +167,17 @@ public ProxyServer select(Uri uri) {
                             case DIRECT:
                                 return null;
                             default:
-                                log.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
+                                logger.warn("ProxySelector returned proxy type that we don't know how to use: " + proxy.type());
                                 break;
                             }
                         }
                     }
                     return null;
                 } catch (URISyntaxException e) {
-                    log.warn(uri + " couldn't be turned into a java.net.URI", e);
+                    logger.warn(uri + " couldn't be turned into a java.net.URI", e);
                     return null;
                 }
             }
         };
     }
-
-    /**
-     * Create a proxy server selector that always selects a single proxy server.
-     *
-     * @param proxyServer The proxy server to select.
-     * @return The proxy server selector.
-     */
-    public static ProxyServerSelector createProxyServerSelector(final ProxyServer proxyServer) {
-        return new ProxyServerSelector() {
-            public ProxyServer select(Uri uri) {
-                return proxyServer;
-            }
-        };
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java b/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java
deleted file mode 100644
index a1cf2192f..000000000
--- a/client/src/main/java/org/asynchttpclient/util/StringCharSequence.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-/**
- * A CharSequence String wrapper that doesn't copy the char[] (damn new String implementation!!!)
- * 
- * @author slandelle
- */
-public class StringCharSequence implements CharSequence {
-
-    private final String value;
-    private final int offset;
-    public final int length;
-    
-    public StringCharSequence(String value, int offset, int length) {
-        this.value = value;
-        this.offset = offset;
-        this.length = length;
-    }
-    
-    @Override
-    public int length() {
-        return length;
-    }
-
-    @Override
-    public char charAt(int index) {
-        return value.charAt(offset + index);
-    }
-
-    @Override
-    public CharSequence subSequence(int start, int end) {
-        int offsetedEnd = offset + end;
-        if (offsetedEnd < length)
-            throw new ArrayIndexOutOfBoundsException();
-        return new StringCharSequence(value, offset + start, end - start);
-    }
-    
-    @Override
-    public String toString() {
-        return value.substring(offset, length);
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/StringUtils.java b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
index 10234d87a..f125b2906 100644
--- a/client/src/main/java/org/asynchttpclient/util/StringUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/StringUtils.java
@@ -18,10 +18,10 @@
 
 public final class StringUtils {
 
-    private static final ThreadLocal<StringBuilder> STRING_BUILDERS = new ThreadLocal<StringBuilder>() {
+    private static final ThreadLocal<StringBuilder> STRING_BUILDER_POOL = new ThreadLocal<StringBuilder>() {
         protected StringBuilder initialValue() {
             return new StringBuilder(512);
-        };
+        }
     };
 
     /**
@@ -29,13 +29,12 @@ protected StringBuilder initialValue() {
      * @return a pooled StringBuilder
      */
     public static StringBuilder stringBuilder() {
-        StringBuilder sb = STRING_BUILDERS.get();
+        StringBuilder sb = STRING_BUILDER_POOL.get();
         sb.setLength(0);
         return sb;
     }
     
     private StringUtils() {
-        // unused
     }
 
     public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
diff --git a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
index 42b6a429a..1907cbe0e 100644
--- a/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/UriEncoder.java
@@ -119,11 +119,11 @@ public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
 
     protected abstract String withoutQueryWithParams(final List<Param> queryParams);
 
-    private final String withQuery(final String query, final List<Param> queryParams) {
+    private String withQuery(final String query, final List<Param> queryParams) {
         return isNonEmpty(queryParams) ? withQueryWithParams(query, queryParams) : withQueryWithoutParams(query);
     }
 
-    private final String withoutQuery(final List<Param> queryParams) {
+    private String withoutQuery(final List<Param> queryParams) {
         return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
     }
 
@@ -140,7 +140,7 @@ public Uri encode(Uri uri, List<Param> queryParams) {
 
     protected abstract String encodePath(String path);
 
-    private final String encodeQuery(final String query, final List<Param> queryParams) {
+    private String encodeQuery(final String query, final List<Param> queryParams) {
         return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
deleted file mode 100644
index 34c495adc..000000000
--- a/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import io.netty.buffer.AbstractByteBuf;
-import io.netty.buffer.ByteBuf;
-import io.netty.util.concurrent.FastThreadLocal;
-
-import java.io.UTFDataFormatException;
-
-public class Utf8Reader {
-
-    private static int SMALL_BUFFER_SIZE = 4096;
-    private static final IndexOutOfBoundsException STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION = new IndexOutOfBoundsException("String decoder index out of bounds");
-
-    private static final FastThreadLocal<char[]> CACHED_CHAR_BUFFERS = new FastThreadLocal<char[]>() {
-        @Override
-        protected char[] initialValue() throws Exception {
-            return new char[SMALL_BUFFER_SIZE];
-        }
-    };
-
-    public static String readUtf8(ByteBuf buf, int utflen) throws UTFDataFormatException, IndexOutOfBoundsException {
-
-        boolean small = utflen <= SMALL_BUFFER_SIZE;
-        char[] chararr = small ? CACHED_CHAR_BUFFERS.get() : new char[utflen];
-
-        int char1, char2, char3;
-        int count = 0, chararr_count = 0;
-
-        if (buf.readableBytes() > utflen) {
-            throw STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION;
-        }
-
-        if (buf instanceof AbstractByteBuf) {
-            AbstractByteBuf b = (AbstractByteBuf) buf;
-            int readerIndex = buf.readerIndex();
-
-            // fast-path
-            while (count < utflen) {
-                char1 = b.getByte(readerIndex + count) & 0xff;
-                if (char1 > 127)
-                    break;
-                count++;
-                chararr[chararr_count++] = (char) char1;
-            }
-
-            while (count < utflen) {
-                char1 = b.getByte(readerIndex + count) & 0xff;
-                switch (char1 >> 4) {
-                case 0:
-                case 1:
-                case 2:
-                case 3:
-                case 4:
-                case 5:
-                case 6:
-                case 7:
-                    /* 0xxxxxxx */
-                    count++;
-                    chararr[chararr_count++] = (char) char1;
-                    break;
-                case 12:
-                case 13:
-                    /* 110x xxxx 10xx xxxx */
-                    count += 2;
-                    if (count > utflen)
-                        throw new UTFDataFormatException("malformed input: partial character at end");
-                    char2 = b.getByte(readerIndex + count - 1);
-                    if ((char2 & 0xC0) != 0x80)
-                        throw new UTFDataFormatException("malformed input around byte " + count);
-                    chararr[chararr_count++] = (char) (((char1 & 0x1F) << 6) | (char2 & 0x3F));
-                    break;
-                case 14:
-                    /* 1110 xxxx 10xx xxxx 10xx xxxx */
-                    count += 3;
-                    if (count > utflen)
-                        throw new UTFDataFormatException("malformed input: partial character at end");
-                    char2 = b.getByte(readerIndex + count - 2);
-                    char3 = b.getByte(readerIndex + count - 1);
-                    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
-                        throw new UTFDataFormatException("malformed input around byte " + (count - 1));
-                    chararr[chararr_count++] = (char) (((char1 & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
-                    break;
-                default:
-                    /* 10xx xxxx, 1111 xxxx */
-                    throw new UTFDataFormatException("malformed input around byte " + count);
-                }
-            }
-
-            buf.readerIndex(buf.readerIndex() + count);
-
-            // The number of chars produced may be less than utflen
-            return new String(chararr, 0, chararr_count);
-
-        } else {
-            byte[] b = new byte[utflen];
-            buf.readBytes(b);
-
-            return new String(b);
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
deleted file mode 100644
index 6a4c04cfc..000000000
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-public final class Utf8UrlDecoder {
-
-    private Utf8UrlDecoder() {
-    }
-
-    private static StringBuilder initSb(StringBuilder sb, String s, int i, int offset, int length) {
-        if (sb != null) {
-            return sb;
-        } else {
-            int initialSbLength = length > 500 ? length / 2 : length;
-            return new StringBuilder(initialSbLength).append(s, offset, i);
-        }
-    }
-
-    private static int hexaDigit(char c) {
-        return Character.digit(c, 16);
-    }
-
-    public static CharSequence decode(String s) {
-        return decode(s, 0, s.length());
-    }
-    
-    public static CharSequence decode(final String s, final int offset, final int length) {
-
-        StringBuilder sb = null;
-        int i = offset;
-        int end = length + offset;
-
-        while (i < end) {
-            char c = s.charAt(i);
-            if (c == '+') {
-                sb = initSb(sb, s, i, offset, length);
-                sb.append(' ');
-                i++;
-
-            } else if (c == '%') {
-                if (end - i < 3) // We expect 3 chars. 0 based i vs. 1 based length!
-                    throw new IllegalArgumentException("UTF8UrlDecoder: Incomplete trailing escape (%) pattern");
-
-                int x, y;
-                if ((x = hexaDigit(s.charAt(i + 1))) == -1 || (y = hexaDigit(s.charAt(i + 2))) == -1)
-                    throw new IllegalArgumentException("UTF8UrlDecoder: Malformed");
-
-                sb = initSb(sb, s, i, offset, length);
-                sb.append((char) (x * 16 + y));
-                i += 3;
-            } else {
-                if (sb != null)
-                    sb.append(c);
-                i++;
-            }
-        }
-
-        return sb != null ? sb.toString() : new StringCharSequence(s, offset, length);
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
index f49d1a217..0859b5f24 100644
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -192,7 +192,7 @@ private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input,
         return sb;
     }
 
-    private final static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
+    private static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
 
         if (value == ' ' && encodeSpaceAsPlus) {
             sb.append('+');
@@ -204,7 +204,7 @@ private final static void appendSingleByteEncoded(StringBuilder sb, int value, b
         sb.append(HEX[value & 0xF]);
     }
 
-    private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
+    private static void appendMultiByteEncoded(StringBuilder sb, int value) {
         if (value < 0x800) {
             appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
             appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index ceffb2747..114b20cc7 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -47,7 +47,7 @@
 
     private HttpResponseStatus status;
     private HttpResponseHeaders headers;
-    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
+    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<>());
 
     /**
      * {@inheritDoc}
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
index 24f075430..ec4ceec1a 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
@@ -17,7 +17,11 @@
 
 /**
  * Invoked when WebSocket binary fragments are received.
+ * 
+ * Actually doesn't do anything, as chunks as assembled into full WebSocket frames.
+ * Will be removed in 2.1.
  */
+@Deprecated
 public interface WebSocketByteFragmentListener extends WebSocketListener {
 
     /**
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
index 1aee42cc7..b818381ba 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
@@ -17,7 +17,11 @@
 
 /**
  * Invoked when WebSocket text fragments are received.
+ * 
+ * Actually doesn't do anything, as chunks as assembled into full WebSocket frames.
+ * Will be removed in 2.1.
  */
+@Deprecated
 public interface WebSocketTextFragmentListener extends WebSocketListener {
 
     /**
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index c3de6d21c..de255cdc5 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -421,7 +421,7 @@ public void asyncOptionsTest() throws Throwable {
 
                 final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
 
-                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
+                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST" };
                 Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
                     @Override
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index 35749ff63..e8041c20e 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -560,7 +560,7 @@ public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
         withClient().run(client -> {
             withServer(server).run(server -> {
                 final CountDownLatch latch = new CountDownLatch(1);
-                final AtomicReference<String> message = new AtomicReference<String>();
+                final AtomicReference<String> message = new AtomicReference<>();
 
                 server.enqueueOk();
                 client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
diff --git a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 9c25275e0..71e612d46 100644
--- a/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
+++ b/client/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -35,9 +35,7 @@ public void testListenableFuture() throws Exception {
                 try {
                     statusCode.set(future.get().getStatusCode());
                     latch.countDown();
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                } catch (ExecutionException e) {
+                } catch (InterruptedException | ExecutionException e) {
                     e.printStackTrace();
                 }
             }, Executors.newFixedThreadPool(1));
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 0e94693ce..cc079e475 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -75,6 +75,7 @@ public void setUpGlobal() throws Exception {
         server.start();
         port1 = connector.getLocalPort();
         logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
     }
 
     @Test(groups = "online")
@@ -132,15 +133,18 @@ private static int getPort(Uri uri) {
     // @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
+        Exception e = null;
 
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 404);
+        try (AsyncHttpClient c = asyncHttpClient()) {
+            c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
         } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            e = ex;
         }
+
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
     }
 
     // @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index a9ca03ebb..d978be2a5 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -72,6 +72,7 @@ public void setUpGlobal() throws Exception {
         server.start();
         port1 = connector.getLocalPort();
         logger.info("Local HTTP server started successfully");
+        port2 = findFreePort();
     }
 
     @Test(groups = "online")
@@ -96,19 +97,22 @@ public void redirected302Test() throws Exception {
         }
     }
 
-    // @Test(groups = "standalone")
+//     @Test(groups = "standalone")
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
+        
+        Exception e = null;
 
-        // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 404);
+            c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
         } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
+            e = ex;
         }
+        
+        assertNotNull(e);
+        Throwable cause = e.getCause();
+        assertTrue(cause instanceof ConnectException);
+        assertTrue(cause.getMessage().contains(":" + port2));
     }
 
     // @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index a72ecef04..34c8b152b 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -63,8 +63,7 @@ public void testMaxConnectionsWithinThreads() throws Exception {
         final AtomicInteger failedCount = new AtomicInteger();
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
-            for (int i = 0; i < urls.length; i++) {
-                final String url = urls[i];
+            for (final String url : urls) {
                 Thread t = new Thread() {
                     public void run() {
                         client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
@@ -93,8 +92,7 @@ public void onThrowable(Throwable t) {
 
             final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
             failedCount.set(0);
-            for (int i = 0; i < urls.length; i++) {
-                final String url = urls[i];
+            for (final String url : urls) {
                 client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
                     @Override
                     public Response onCompleted(Response response) throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 3304081fd..387d9caac 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -49,8 +49,8 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
 
         try (AsyncHttpClient client = asyncHttpClient(config)) {
             List<ListenableFuture<Response>> futures = new ArrayList<>();
-            for (int i = 0; i < urls.length; i++) {
-                futures.add(client.prepareGet(urls[i]).execute());
+            for (String url : urls) {
+                futures.add(client.prepareGet(url).execute());
             }
 
             boolean caughtError = false;
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index 263f3b291..b58644a00 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -79,7 +79,7 @@ public void testRequestTimeout() throws IOException {
 
         try (AsyncHttpClient client = asyncHttpClient(config().setMaxConnections(1))) {
             final CountDownLatch latch = new CountDownLatch(samples);
-            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
+            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<>(2));
 
             for (int i = 0; i < samples; i++) {
                 new Thread(new Runnable() {
diff --git a/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java b/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
deleted file mode 100644
index 02b303382..000000000
--- a/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.asynchttpclient.netty.util;
-
-import static org.testng.Assert.assertEquals;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.asynchttpclient.util.ByteBufUtils;
-import org.testng.annotations.Test;
-
-public class ByteBufUtilsTest {
-
-    @Test
-    public void testByteBuf2BytesHasBackingArray() {
-        byte[] input = "testdata".getBytes();
-        ByteBuf inputBuf = Unpooled.copiedBuffer(input);
-        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
-        assertEquals(output, input, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
-    }
-
-    @Test
-    public void testByteBuf2BytesNoBackingArray() {
-        ByteBuf inputBuf = Unpooled.directBuffer();
-        byte[] inputBytes = "testdata".getBytes();
-        inputBuf.writeBytes(inputBytes);
-        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
-        assertEquals(output, inputBytes, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
-    }
-
-    @Test
-    public void testByteBufs2BytesEmptyList() {
-        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.emptyList());
-        assertEquals(output, ByteBufUtils.EMPTY_BYTE_ARRAY,
-                "When an empty list is passed to byteBufs2Bytes, an empty byte array should be returned");
-    }
-
-    @Test
-    public void testByteBufs2BytesSize1List() {
-        byte[] inputBytes = "testdata".getBytes();
-        ByteBuf inputBuf = Unpooled.copiedBuffer(inputBytes);
-        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.singletonList(inputBuf));
-        assertEquals(output, inputBytes, "When a list of a single ByteBuf element is passed to byteBufs2Bytes,"
-                + " the returned byte array should contain the bytes in that ByteBUf");
-    }
-
-    @Test
-    public void testByteBufs2Bytes() {
-        byte[] input1 = "testdata".getBytes();
-        byte[] input2 = "testdata2".getBytes();
-        byte[] input3 = "testdata3333".getBytes();
-
-        List<ByteBuf> byteBufList = new LinkedList<>();
-        byteBufList.add(Unpooled.copiedBuffer(input1));
-        byteBufList.add(Unpooled.copiedBuffer(input2));
-        byteBufList.add(Unpooled.copiedBuffer(input3));
-
-        byte[] output = ByteBufUtils.byteBufs2Bytes(byteBufList);
-        assertEquals(output.length, input1.length + input2.length + input3.length,
-                "Returned bytes length should equal the sum of the parts");
-    }
-
-}
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 955e94f74..5f922175c 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -15,10 +15,9 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
@@ -27,13 +26,13 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.commons.io.output.ByteArrayOutputStream;
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.ntlm.NtlmEngine.Type2Message;
 import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.ByteBufUtils;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -97,7 +96,7 @@ public void lazyNTLMAuthTest() throws IOException, InterruptedException, Executi
     public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
         ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
     }
-    
+
     @Test
     public void testGenerateType1Msg() {
         NtlmEngine engine = new NtlmEngine();
@@ -119,73 +118,101 @@ public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrect
         fail("An NtlmEngineException must have occurred as challenge format is not correct");
     }
 
+    private static byte[] longToBytes(long x) {
+        ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
+        buffer.putLong(x);
+        return buffer.array();
+    }
+
     @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(3).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeBytes("challenge".getBytes());
+        buf.write(3);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+        buf.write("challenge".getBytes());
         NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
         fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
     }
 
     @Test(expectedExceptions = NtlmEngineException.class)
-    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L)); // we want to write a Long
+
         // flags
-        buf.writeByte(0);// unicode support indicator
-        buf.writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);// challenge
+        buf.write(0);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
         NtlmEngine engine = new NtlmEngine();
-        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
         fail("An NtlmEngineException must have occurred as unicode support is not indicated");
     }
 
-    @Test(groups="standalone")
-    public void testGenerateType2Msg(){
+    @Test(groups = "standalone")
+    public void testGenerateType2Msg() {
         Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
         Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
     }
 
     @Test
-    public void testGenerateType3Msg() {
-        ByteBuf buf = Unpooled.directBuffer();
-        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
-        buf.writeByte(0);
+    public void testGenerateType3Msg() throws IOException {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        buf.write("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.write(0);
         // type 2 indicator
-        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(0);
+        buf.write(2);
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(0L)); // we want to write a Long
+
         // flags
-        buf.writeByte(1);// unicode support indicator
-        buf.writeByte(0).writeByte(0).writeByte(0);
-        buf.writeLong(1);// challenge
+        buf.write(1);// unicode support indicator
+        buf.write(0);
+        buf.write(0);
+        buf.write(0);
+
+        buf.write(longToBytes(1L));// challenge
         NtlmEngine engine = new NtlmEngine();
-        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation",
-                Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
-        assertEquals(type3Msg,
+        String type3Msg = engine.generateType3Msg("username", "password", "localhost", "workstation", Base64.encode(buf.toByteArray()));
+        buf.close();
+        assertEquals(
+                type3Msg,
                 "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAWABYAmgAAAAAAAACwAAAAAQAAAgUBKAoAAAAP1g6lqqN1HZ0wSSxeQ5riQkyh7/UexwVlCPQm0SHU2vsDQm2wM6NbT2zPonPzLJL0TABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAFcATwBSAEsAUwBUAEEAVABJAE8ATgA=",
                 "Incorrect type3 message generated");
     }
 
     @Test
     public void testWriteULong() {
-        //test different combinations so that different positions in the byte array will be written
+        // test different combinations so that different positions in the byte array will be written
         byte[] buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 1, 0);
         assertEquals(buffer, new byte[] { 1, 0, 0, 0 }, "Unsigned long value 1 was not written correctly to the buffer");
-        
+
         buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 257, 0);
         assertEquals(buffer, new byte[] { 1, 1, 0, 0 }, "Unsigned long value 257 was not written correctly to the buffer");
-        
+
         buffer = new byte[4];
         NtlmEngine.writeULong(buffer, 16777216, 0);
         assertEquals(buffer, new byte[] { 0, 0, 0, 1 }, "Unsigned long value 16777216 was not written correctly to the buffer");
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index f36894f61..78f9900f7 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -71,7 +71,7 @@ public void streamedResponseSmallFileTest() throws Throwable {
         private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
         public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<HttpResponseBodyPart>());
+            this(new SimpleSubscriber<>());
         }
 
         public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
@@ -128,7 +128,7 @@ public SimpleStreamedAsyncHandler onCompleted() throws Exception {
     static protected class SimpleSubscriber<T> implements Subscriber<T> {
         private volatile Subscription subscription;
         private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
         private final CountDownLatch latch = new CountDownLatch(1);
 
         @Override
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index 470873848..7b8dae9f0 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -122,7 +122,7 @@ public void cancelStreamedResponseTest() throws Throwable {
         private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
 
         public SimpleStreamedAsyncHandler() {
-            this(new SimpleSubscriber<HttpResponseBodyPart>());
+            this(new SimpleSubscriber<>());
         }
 
         public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
@@ -176,7 +176,7 @@ public SimpleStreamedAsyncHandler onCompleted() throws Exception {
     static protected class SimpleSubscriber<T> implements Subscriber<T> {
         private volatile Subscription subscription;
         private volatile Throwable error;
-        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<>());
         private final CountDownLatch latch = new CountDownLatch(1);
 
         @Override
@@ -221,7 +221,7 @@ public CancellingStreamedAsyncProvider(int cancelAfter) {
 
         @Override
         public State onStream(Publisher<HttpResponseBodyPart> publisher) {
-            publisher.subscribe(new CancellingSubscriber<HttpResponseBodyPart>(cancelAfter));
+            publisher.subscribe(new CancellingSubscriber<>(cancelAfter));
             return State.CONTINUE;
         }
 
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
index e30003d44..a78db7559 100644
--- a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
@@ -43,7 +43,7 @@
     @FunctionalInterface
     public interface HttpServletResponseConsumer {
 
-        public void apply(HttpServletResponse response) throws IOException, ServletException;
+        void apply(HttpServletResponse response) throws IOException, ServletException;
     }
 
     public HttpServer() {
@@ -240,7 +240,7 @@ protected void handle0(String target, Request baseRequest, HttpServletRequest re
             Enumeration<String> parameterNames = request.getParameterNames();
             StringBuilder requestBody = new StringBuilder();
             while (parameterNames.hasMoreElements()) {
-                String param = parameterNames.nextElement().toString();
+                String param = parameterNames.nextElement();
                 response.addHeader("X-" + param, request.getParameter(param));
                 requestBody.append(param);
                 requestBody.append("_");
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 0abfd6b0a..aec5d9435 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.12-SNAPSHOT</version>
+        <version>2.0.16-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
index 0a7cf3ddd..030936437 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -56,7 +56,7 @@ public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerS
             throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
         }
 
-        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<>(ctx.getAsyncHandler(), available))
                 .build();
     }
 
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index eae359ac0..dda449865 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.0.12-SNAPSHOT</version>
+    <version>2.0.16-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index fdb288466..811f53108 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.0.12-SNAPSHOT</version>
+        <version>2.0.16-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 20b5114da..e1906e8a5 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.0.12-SNAPSHOT</version>
+		<version>2.0.16-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 2f701f2f7..b0d5a061a 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -49,7 +49,7 @@ public static AsyncHttpClient getAsyncHttpClient() {
 
         try {
             if (attemptInstantiation())
-                return (AsyncHttpClient) asyncHttpClientImplClass.newInstance();
+                return asyncHttpClientImplClass.newInstance();
         } catch (InstantiationException e) {
             throw new AsyncHttpClientImplException("Unable to create the class specified by system property : "
                     + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, e);
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 218cb9808..f252a8e8d 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -42,9 +42,7 @@ public static AsyncHttpClientRegistry getInstance() {
                     else
                         _instance = new AsyncHttpClientRegistryImpl();
                 }
-            } catch (InstantiationException e) {
-                throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
-            } catch (IllegalAccessException e) {
+            } catch (InstantiationException | IllegalAccessException e) {
                 throw new AsyncHttpClientImplException("Couldn't instantiate AsyncHttpClientRegistry : " + e.getMessage(), e);
             } finally {
                 lock.unlock();
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 89fdc9eb9..a3fda543c 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.12-SNAPSHOT</version>
+        <version>2.0.16-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 11a2a0474..bc402747b 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.12-SNAPSHOT</version>
+        <version>2.0.16-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index fee51be4f..2f6e79f33 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -366,7 +366,7 @@ public DerivedBuilder derive() {
          * Omit error documents. An error document will neither be available in
          * the response nor written via a {@link BodyConsumer}.
          */
-        OMIT;
+        OMIT
     }
 
     /**
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
index 75bf8e517..b02b8c2f1 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClientTest.java
@@ -157,7 +157,7 @@ public void testDeriveOverrideURL() throws Exception {
     @Test(groups = "standalone")
     public void testSimpleTransferListener() throws Exception {
 
-        final List<Error> errors = Collections.synchronizedList(new ArrayList<Error>());
+        final List<Error> errors = Collections.synchronizedList(new ArrayList<>());
 
         SimpleAHCTransferListener listener = new SimpleAHCTransferListener() {
 
diff --git a/netty-bp/codec-dns/pom.xml b/netty-bp/codec-dns/pom.xml
index 4e03a0ef4..18f123e93 100644
--- a/netty-bp/codec-dns/pom.xml
+++ b/netty-bp/codec-dns/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.12-SNAPSHOT</version>
+    <version>2.0.16-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-codec-dns</artifactId>
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
index 3222566e0..2eb61a444 100644
--- a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
@@ -85,7 +85,7 @@ protected void encodeName(String name, ByteBuf buf) throws Exception {
             return;
         }
 
-        final String[] labels = StringUtil.split(name, '.');
+        final String[] labels = name.split("\\.");
         for (String label : labels) {
             final int labelLen = label.length();
             if (labelLen == 0) {
diff --git a/netty-bp/pom.xml b/netty-bp/pom.xml
index 78daa46ee..8d40fd470 100644
--- a/netty-bp/pom.xml
+++ b/netty-bp/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.12-SNAPSHOT</version>
+		<version>2.0.16-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>netty-bp</artifactId>
diff --git a/netty-bp/resolver-dns/pom.xml b/netty-bp/resolver-dns/pom.xml
index 9614f9b46..f7e8499c9 100644
--- a/netty-bp/resolver-dns/pom.xml
+++ b/netty-bp/resolver-dns/pom.xml
@@ -9,7 +9,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>netty-bp</artifactId>
-		<version>2.0.12-SNAPSHOT</version>
+		<version>2.0.16-SNAPSHOT</version>
 	</parent>
 
 	<artifactId>netty-resolver-dns</artifactId>
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
index b87ea86ce..7c663f7ae 100644
--- a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
@@ -70,6 +70,7 @@ public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAd
     private final DnsNameResolver parent;
     private final DnsServerAddressStream nameServerAddrs;
     private final String hostname;
+    protected String pristineHostname;
     private final DnsCache resolveCache;
     private final boolean traceEnabled;
     private final int maxAllowedQueries;
@@ -117,6 +118,7 @@ public void operationComplete(Future<T> future) throws Exception {
                         String nextHostname = DnsNameResolverContext.this.hostname + "." + searchDomain;
                         DnsNameResolverContext<T> nextContext = newResolverContext(parent,
                             nextHostname, resolveCache);
+                        nextContext.pristineHostname = hostname;
                         nextContext.internalResolve(nextPromise);
                         nextPromise.addListener(this);
                     } else {
@@ -450,8 +452,13 @@ private void finishResolve(Promise<T> promise) {
         final int tries = maxAllowedQueries - allowedQueries;
         final StringBuilder buf = new StringBuilder(64);
 
-        buf.append("failed to resolve '")
-           .append(hostname).append('\'');
+        buf.append("failed to resolve '");
+        if (pristineHostname != null) {
+          buf.append(pristineHostname);
+        } else {
+          buf.append(hostname);
+        }
+        buf.append('\'');
         if (tries > 1) {
             if (tries < maxAllowedQueries) {
                 buf.append(" after ")
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
index da8917384..77c652ff7 100644
--- a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -34,7 +35,10 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
+import static org.hamcrest.Matchers.not;
+import static org.hamcrest.core.StringContains.containsString;
 
 public class SearchDomainTest {
 
@@ -265,4 +269,23 @@ private String assertResolve(DnsNameResolver resolver, String inetHost) throws I
         }
         return list;
     }
+
+    @Test
+    public void testExceptionMsgNoSearchDomain() throws Exception {
+        Set<String> domains = new HashSet<String>();
+
+        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);
+        dnsServer = new TestDnsServer(store);
+        dnsServer.start();
+
+        resolver = newResolver().searchDomains(Collections.singletonList("foo.com")).build();
+
+        Future<InetAddress> fut = resolver.resolve("unknown.hostname");
+        assertTrue(fut.await(10, TimeUnit.SECONDS));
+        assertFalse(fut.isSuccess());
+        final Throwable cause = fut.cause();
+        assertEquals(UnknownHostException.class, cause.getClass());
+        assertThat("search domain is included in UnknownHostException", cause.getMessage(),
+            not(containsString("foo.com")));
+    }
 }
diff --git a/netty-bp/resolver/pom.xml b/netty-bp/resolver/pom.xml
index 18ae16a9f..55de91416 100644
--- a/netty-bp/resolver/pom.xml
+++ b/netty-bp/resolver/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>netty-bp</artifactId>
-    <version>2.0.12-SNAPSHOT</version>
+    <version>2.0.16-SNAPSHOT</version>
   </parent>
 
   <artifactId>netty-resolver</artifactId>
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
new file mode 100644
index 000000000..bf6b58e70
--- /dev/null
+++ b/netty-utils/pom.xml
@@ -0,0 +1,17 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.0.16-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-netty-utils</artifactId>
+	<name>Asynchronous Http Client Netty Utils</name>
+
+	<dependencies>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-buffer</artifactId>
+		</dependency>
+	</dependencies>
+</project>
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
new file mode 100755
index 000000000..c5f66ac67
--- /dev/null
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.*;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+
+public final class ByteBufUtils {
+
+    private ByteBufUtils() {
+    }
+
+    public static String byteBuf2String(Charset charset, ByteBuf buf) throws CharacterCodingException {
+        if (charset == UTF_8 || charset == US_ASCII) {
+            return Utf8ByteBufCharsetDecoder.decodeUtf8(buf);
+        } else {
+            return buf.toString(charset);
+        }
+    }
+
+    public static String byteBuf2String(Charset charset, ByteBuf... bufs) throws CharacterCodingException {
+        if (charset == UTF_8 || charset == US_ASCII) {
+            return Utf8ByteBufCharsetDecoder.decodeUtf8(bufs);
+        } else {
+            CompositeByteBuf composite = Unpooled.compositeBuffer(bufs.length);
+
+            try {
+                for (ByteBuf buf : bufs) {
+                    buf.retain();
+                    composite.addComponent(buf);
+                }
+
+                return composite.toString(charset);
+
+            } finally {
+                composite.release();
+            }
+        }
+    }
+
+    public static byte[] byteBuf2Bytes(ByteBuf buf) {
+        int readable = buf.readableBytes();
+        int readerIndex = buf.readerIndex();
+        if (buf.hasArray()) {
+            byte[] array = buf.array();
+            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        buf.getBytes(readerIndex, array);
+        return array;
+    }
+}
diff --git a/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
new file mode 100644
index 000000000..ccc35c27d
--- /dev/null
+++ b/netty-utils/src/main/java/org/asynchttpclient/netty/util/Utf8ByteBufCharsetDecoder.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CoderResult;
+
+public class Utf8ByteBufCharsetDecoder {
+
+    private static final ThreadLocal<Utf8ByteBufCharsetDecoder> POOL = new ThreadLocal<Utf8ByteBufCharsetDecoder>() {
+        protected Utf8ByteBufCharsetDecoder initialValue() {
+            return new Utf8ByteBufCharsetDecoder();
+        }
+    };
+
+    private static Utf8ByteBufCharsetDecoder pooledDecoder() {
+        Utf8ByteBufCharsetDecoder decoder = POOL.get();
+        decoder.reset();
+        return decoder;
+    }
+
+    public static String decodeUtf8(ByteBuf buf) throws CharacterCodingException {
+        return pooledDecoder().decode(buf);
+    }
+
+    public static String decodeUtf8(ByteBuf... bufs) throws CharacterCodingException {
+        return pooledDecoder().decode(bufs);
+    }
+
+    private final CharsetDecoder decoder = UTF_8.newDecoder();
+    protected CharBuffer charBuffer = allocateCharBuffer(1024);
+    private ByteBuffer splitCharBuffer;
+
+    protected void initSplitCharBuffer() {
+        if (splitCharBuffer == null) {
+            // UTF-8 chars are 4 bytes max
+            splitCharBuffer = ByteBuffer.allocate(4);
+        }
+    }
+
+    protected CharBuffer allocateCharBuffer(int l) {
+        return CharBuffer.allocate(l);
+    }
+
+    private void ensureCapacity(int l) {
+        if (charBuffer.position() == 0) {
+            if (charBuffer.capacity() < l) {
+                charBuffer = allocateCharBuffer(l);
+            }
+        } else if (charBuffer.remaining() < l) {
+            CharBuffer newCharBuffer = allocateCharBuffer(charBuffer.position() + l);
+            charBuffer.flip();
+            newCharBuffer.put(charBuffer);
+            charBuffer = newCharBuffer;
+        }
+    }
+
+    public void reset() {
+        decoder.reset();
+        charBuffer.position(0);
+    }
+
+    private static int charSize(byte firstByte) throws CharacterCodingException {
+        if ((firstByte >> 5) == -2 && (firstByte & 0x1e) != 0) {
+            // 2 bytes, 11 bits: 110xxxxx 10xxxxxx
+            return 2;
+
+        } else if ((firstByte >> 4) == -2) {
+            // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
+            return 3;
+
+        } else if ((firstByte >> 3) == -2) {
+            // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+            return 4;
+
+        } else {
+            // charSize isn't supposed to be called for regular bytes
+            throw new CharacterCodingException();
+        }
+    }
+
+    private void handleSplitCharBuffer(ByteBuffer nioBuffer, boolean endOfInput) throws CharacterCodingException {
+        // TODO we could save charSize
+        int missingBytes = charSize(splitCharBuffer.get(0)) - splitCharBuffer.position();
+
+        if (nioBuffer.remaining() < missingBytes) {
+            if (endOfInput) {
+                throw new CharacterCodingException();
+            }
+
+            // still not enough bytes
+            splitCharBuffer.put(nioBuffer);
+
+        } else {
+            // FIXME better way?
+            for (int i = 0; i < missingBytes; i++) {
+                splitCharBuffer.put(nioBuffer.get());
+            }
+
+            splitCharBuffer.flip();
+            CoderResult res = decoder.decode(splitCharBuffer, charBuffer, endOfInput && !nioBuffer.hasRemaining());
+            if (res.isError()) {
+                res.throwException();
+            }
+
+            splitCharBuffer.position(0);
+        }
+    }
+
+    protected void decodePartial(ByteBuffer nioBuffer, boolean endOfInput) throws CharacterCodingException {
+        // deal with pending splitCharBuffer
+        if (splitCharBuffer != null && splitCharBuffer.position() > 0 && nioBuffer.hasRemaining()) {
+            handleSplitCharBuffer(nioBuffer, endOfInput);
+        }
+
+        // decode remaining buffer
+        if (nioBuffer.hasRemaining()) {
+            CoderResult res = decoder.decode(nioBuffer, charBuffer, endOfInput);
+            if (res.isUnderflow()) {
+                if (nioBuffer.remaining() > 0) {
+                    initSplitCharBuffer();
+                    splitCharBuffer.put(nioBuffer);
+                }
+            } else if (res.isError()) {
+                res.throwException();
+            }
+        }
+    }
+
+    private void decode(ByteBuffer[] nioBuffers, int length) throws CharacterCodingException {
+        int count = nioBuffers.length;
+        for (int i = 0; i < count; i++) {
+            decodePartial(nioBuffers[i].duplicate(), i == count - 1);
+        }
+    }
+
+    private void decodeSingleNioBuffer(ByteBuffer nioBuffer, int length) throws CharacterCodingException {
+        CoderResult res = decoder.decode(nioBuffer, charBuffer, true);
+        if (res.isError()) {
+            res.throwException();
+        }
+    }
+
+    public String decode(ByteBuf buf) throws CharacterCodingException {
+        if (buf.isDirect()) {
+            return buf.toString(UTF_8);
+        }
+
+        int length = buf.readableBytes();
+        ensureCapacity(length);
+
+        if (buf.nioBufferCount() == 1) {
+            decodeSingleNioBuffer(buf.internalNioBuffer(buf.readerIndex(), length).duplicate(), length);
+        } else {
+            decode(buf.nioBuffers(), buf.readableBytes());
+        }
+
+        return charBuffer.flip().toString();
+    }
+
+    public String decode(ByteBuf... bufs) throws CharacterCodingException {
+        if (bufs.length == 1) {
+            return decode(bufs[0]);
+        }
+
+        int totalSize = 0;
+        int totalNioBuffers = 0;
+        boolean direct = false;
+        for (ByteBuf buf : bufs) {
+            if (buf.isDirect()) {
+                direct = true;
+                break;
+            }
+            totalSize += buf.readableBytes();
+            totalNioBuffers += buf.nioBufferCount();
+        }
+
+        if (direct) {
+            ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(bufs);
+            try {
+                return wrappedBuffer.toString(UTF_8);
+            } finally {
+                wrappedBuffer.release();
+            }
+
+        } else {
+            ByteBuffer[] nioBuffers = new ByteBuffer[totalNioBuffers];
+            int i = 0;
+            for (ByteBuf buf : bufs) {
+                for (ByteBuffer nioBuffer : buf.nioBuffers()) {
+                    nioBuffers[i++] = nioBuffer;
+                }
+            }
+
+            ensureCapacity(totalSize);
+            decode(nioBuffers, totalSize);
+
+            return charBuffer.flip().toString();
+        }
+    }
+}
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
new file mode 100644
index 000000000..a7da5290f
--- /dev/null
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.testng.Assert.assertEquals;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import org.testng.annotations.Test;
+
+public class ByteBufUtilsTest {
+
+    @Test
+    public void testByteBuf2BytesHasBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf inputBuf = Unpooled.wrappedBuffer(inputBytes);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, inputBytes);
+    }
+
+    @Test
+    public void testByteBuf2BytesNoBackingArray() {
+        byte[] inputBytes = "testdata".getBytes(US_ASCII);
+        ByteBuf inputBuf = Unpooled.directBuffer();
+        inputBuf.writeBytes(inputBytes);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, inputBytes);
+    }
+}
diff --git a/pom.xml b/pom.xml
index f015764f2..eb1463fee 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.0.12-SNAPSHOT</version>
+	<version>2.0.16-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -213,11 +213,17 @@
 	</repositories>
 	<modules>
 		<module>netty-bp</module>
+		<module>netty-utils</module>
 		<module>client</module>
 		<module>extras</module>
 	</modules>
 	<dependencyManagement>
 		<dependencies>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-buffer</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
 			<dependency>
 				<groupId>io.netty</groupId>
 				<artifactId>netty-codec-http</artifactId>
@@ -373,16 +379,16 @@
 		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
-		<netty.version>4.0.39.Final</netty.version>
+		<netty.version>4.0.41.Final</netty.version>
 		<slf4j.version>1.7.21</slf4j.version>
 		<logback.version>1.1.7</logback.version>
 		<testng.version>6.9.10</testng.version>
-		<jetty.version>9.3.10.v20160621</jetty.version>
+		<jetty.version>9.3.11.v20160721</jetty.version>
 		<tomcat.version>6.0.45</tomcat.version>
 		<commons-io.version>2.4</commons-io.version>
 		<commons-fileupload.version>1.3</commons-fileupload.version>
 		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-		<rxjava-reactive-streams.version>1.0.1</rxjava-reactive-streams.version>
+		<rxjava-reactive-streams.version>1.1.1</rxjava-reactive-streams.version>
 		<powermock.version>1.6.4</powermock.version>
 	</properties>
 </project>
