diff --git a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java
index 226cb2acb..9f93fd364 100644
--- a/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java
+++ b/src/main/java/com/ning/http/client/providers/grizzly/GrizzlyConnectionsPool.java
@@ -13,6 +13,8 @@
 
 package com.ning.http.client.providers.grizzly;
 
+import static com.ning.http.util.DateUtil.millisTime;
+
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.ConnectionsPool;
 
@@ -55,6 +57,7 @@
     private final int maxConnections;
     private final boolean unlimitedConnections;
     private final long timeout;
+    private final long maxConnectionLifeTimeInMs;
     private final DelayedExecutor delayedExecutor;
     private final Connection.CloseListener listener;
 
@@ -66,6 +69,7 @@ public GrizzlyConnectionsPool(final AsyncHttpClientConfig config) {
 
         cacheSSLConnections = config.isSslConnectionPoolEnabled();
         timeout = config.getIdleConnectionInPoolTimeoutInMs();
+        maxConnectionLifeTimeInMs = config.getMaxConnectionLifeTimeInMs();
         maxConnectionsPerHost = config.getMaxConnectionPerHost();
         maxConnections = config.getMaxTotalConnections();
         unlimitedConnections = (maxConnections == -1);
@@ -105,7 +109,7 @@ public boolean offer(String uri, Connection connection) {
                         new Object[]{uri, connection});
             }
             DelayedExecutor.IdleConnectionQueue newPool =
-                    delayedExecutor.createIdleConnectionQueue(timeout);
+                    delayedExecutor.createIdleConnectionQueue(timeout, maxConnectionLifeTimeInMs);
             conQueue = connectionsPool.putIfAbsent(uri, newPool);
             if (conQueue == null) {
                 conQueue = newPool;
@@ -289,8 +293,8 @@ private ExecutorService getThreadPool() {
             return threadPool;
         }
 
-        private IdleConnectionQueue createIdleConnectionQueue(final long timeout) {
-            final IdleConnectionQueue queue = new IdleConnectionQueue(timeout);
+        private IdleConnectionQueue createIdleConnectionQueue(final long timeout, final long maxConnectionLifeTimeInMs) {
+            final IdleConnectionQueue queue = new IdleConnectionQueue(timeout, maxConnectionLifeTimeInMs);
             queues.add(queue);
             return queue;
         }
@@ -310,7 +314,7 @@ private static boolean wasModified(final Long l1, final Long l2) {
             @Override
             public void run() {
                 while (isStarted) {
-                    final long currentTimeMs = System.currentTimeMillis();
+                    final long currentTimeMs = millisTime();
 
                     for (final IdleConnectionQueue delayQueue : queues) {
                         if (delayQueue.queue.isEmpty()) continue;
@@ -367,12 +371,14 @@ public void run() {
             final TimeoutResolver resolver = new TimeoutResolver();
             final long timeout;
             final AtomicInteger count = new AtomicInteger(0);
+            final long maxConnectionLifeTimeInMs;
 
             // ---------------------------------------------------- Constructors
 
 
-            public IdleConnectionQueue(final long timeout) {
+            public IdleConnectionQueue(final long timeout, final long maxConnectionLifeTimeInMs) {
                 this.timeout = timeout;
+                this.maxConnectionLifeTimeInMs = maxConnectionLifeTimeInMs;
             }
 
 
@@ -380,9 +386,25 @@ public IdleConnectionQueue(final long timeout) {
 
 
             void offer(final Connection c) {
-                if (timeout >= 0) {
-                    resolver.setTimeoutMs(c, System.currentTimeMillis() + timeout);
+                long timeoutMs = UNSET_TIMEOUT;
+                long currentTime = millisTime();
+                if (maxConnectionLifeTimeInMs < 0 && timeout >= 0) {
+                    timeoutMs = currentTime + timeout;
+                } else if (maxConnectionLifeTimeInMs >= 0) {
+                    long t = resolver.getTimeoutMs(c);
+                    if (t == UNSET_TIMEOUT) {
+                        if (timeout >= 0) {
+                            timeoutMs = currentTime + Math.min(maxConnectionLifeTimeInMs, timeout);
+                        } else {
+                            timeoutMs = currentTime + maxConnectionLifeTimeInMs;
+                        }
+                    } else {
+                        if (timeout >= 0) {
+                            timeoutMs = Math.min(t, currentTime + timeout);
+                        }
+                    }
                 }
+                resolver.setTimeoutMs(c, timeoutMs);
                 queue.offer(c);
                 count.incrementAndGet();
             }
@@ -458,7 +480,7 @@ void setTimeoutMs(final Connection c, final long timeoutMs) {
 
             static final class IdleRecord {
 
-                volatile long timeoutMs;
+                volatile long timeoutMs = UNSET_TIMEOUT;
 
             } // END IdleRecord
 
